<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  构建容器镜像是什么意思？构建过程不是由Docker客户端进行的，而是将整个目录的文件上传到Docker守护进程并在那里进行的。怎么理解？ 镜像不是一个大的二进制块，而是由多层组成的。构建镜像时，Dockerfile中每一条单独的指令都会创建一个新层。镜像构建的过程中，拉取基础镜像所有分层之后，Docker在它们上面创建一个新层并且添加app.js。然后会创建另一层来指定镜像">
<meta name="keywords" content="Kubernetes in Action">
<meta property="og:type" content="article">
<meta property="og:title" content="2-开始使用Kubernetes和Docker">
<meta property="og:url" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  构建容器镜像是什么意思？构建过程不是由Docker客户端进行的，而是将整个目录的文件上传到Docker守护进程并在那里进行的。怎么理解？ 镜像不是一个大的二进制块，而是由多层组成的。构建镜像时，Dockerfile中每一条单独的指令都会创建一个新层。镜像构建的过程中，拉取基础镜像所有分层之后，Docker在它们上面创建一个新层并且添加app.js。然后会创建另一层来指定镜像">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/1.png">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/2.png">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/3.png">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/4.png">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/5.png">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/6.png">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/7.png">
<meta property="og:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/8.png">
<meta property="og:updated_time" content="2022-10-08T02:24:27.132Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2-开始使用Kubernetes和Docker">
<meta name="twitter:description" content="思考并回答以下问题：  构建容器镜像是什么意思？构建过程不是由Docker客户端进行的，而是将整个目录的文件上传到Docker守护进程并在那里进行的。怎么理解？ 镜像不是一个大的二进制块，而是由多层组成的。构建镜像时，Dockerfile中每一条单独的指令都会创建一个新层。镜像构建的过程中，拉取基础镜像所有分层之后，Docker在它们上面创建一个新层并且添加app.js。然后会创建另一层来指定镜像">
<meta name="twitter:image" content="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/1.png">






  <link rel="canonical" href="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>2-开始使用Kubernetes和Docker | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/28/2-开始使用Kubernetes和Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看书不是为了学习，是为了锻炼意志力">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">2-开始使用Kubernetes和Docker

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-09-28 09:38:44" itemprop="dateCreated datePublished" datetime="2022-09-28T09:38:44+08:00">2022-09-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-10-08 10:24:27" itemprop="dateModified" datetime="2022-10-08T10:24:27+08:00">2022-10-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>构建容器镜像是什么意思？构建过程不是由Docker客户端进行的，而是将整个目录的文件上传到Docker守护进程并在那里进行的。怎么理解？</li>
<li>镜像不是一个大的二进制块，而是由多层组成的。构建镜像时，Dockerfile中每一条单独的指令都会创建一个新层。镜像构建的过程中，拉取基础镜像所有分层之后，Docker在它们上面创建一个新层并且添加app.js。然后会创建另一层来指定镜像被运行时所执行的命令。怎么理解？</li>
</ul>
<a id="more"></a>
<p>【本章内容涵盖】</p>
<ul>
<li>使用Docker创建、运行及共享容器镜像</li>
<li>在本地部署单节点的Kubernetes集群</li>
<li>在Google Kubernetes Engine上部署Kubernetes集群</li>
<li>配置和使用命令行客户端——kubectl</li>
<li>在Kubernetes上部署应用并进行水平伸缩</li>
</ul>
<p>在深入学习Kubernetes的概念之前，先来看看如何创建一个简单的应用，把它打包成容器镜像并在远端的Kubernetes集群（如托管在Google Kubernetes Engine中）或本地单节点集群中运行。这会对整个Kubernetes体系有较好的了解，并且会让接下来几个章节对Kubernetes基本概念的学习变得简单。</p>
<h1 id="创建、运行及共享容器镜像"><a href="#创建、运行及共享容器镜像" class="headerlink" title="创建、运行及共享容器镜像"></a><span style="color:#339AFF;">创建、运行及共享容器镜像<span></span></span></h1><p>正如在之前章节所介绍的，在Kubernetes中运行应用需要打包好的容器镜像。本节将会对Docker的使用做简单的介绍。接下来的几节中将会介绍：</p>
<p>1，安装Docker并运行第一个“Hello world”容器</p>
<p>2，创建一个简单的Node.js应用并部署在Kubernetes中</p>
<p>3，把应用打包成可以独立运行的容器镜像</p>
<p>4，基于镜像运行容器</p>
<p>5，把镜像推送到Docker Hub，这样任何人在任何地方都可以使用</p>
<h2 id="安装Docker并运行Hello-World容器"><a href="#安装Docker并运行Hello-World容器" class="headerlink" title="安装Docker并运行Hello World容器"></a><span style="color:#00ACC1;">安装Docker并运行Hello World容器<span></span></span></h2><p>首先，需要在Linux主机上安装Docker。如果使用的不是Linux操作系统，就需要启动Linux虚拟机（VM）并在虚拟机中运行Docker。如果使用的是Mac或Windows系统，Docker将会自己启动一个虚拟机并在虚拟机中运行Docker守护进程。Docker客户端可执行文件可以在宿主操作系统中使用，并可以与虚拟机中的守护进程通信。</p>
<p>根据操作系统的不同，按照<a href="http://docs.docker.com/engine/installation/" target="_blank" rel="noopener">指南</a>安装Docker。安装完成后，可以通过运行Docker客户端可执行文件来执行各种Docker命令。例如，可以试着从Docker Hub的公共镜像仓库拉取、运行镜像，Docker Hub中有许多随时可用的常见镜像，其中就包括busybox，可以用来运行简单的<code>echo &quot;Hello world&quot;</code>命令。</p>
<p><strong><font size="3">运行Hello World容器</font></strong></p>
<p>busybox是一个单一可执行文件，包含多种标准UNIX命令行工具，如：echo、ls、gzip等。除了包含echo命令的busybox命令，也可以使用如Fedora、Ubuntu等功能完备的镜像。</p>
<p>如何才能运行busybox镜像呢？无须下载或者安装任何东西。使用<code>docker run</code>命令然后指定需要运行的镜像的名字，以及需要执行的命令（可选），如下面这段代码。</p>
<blockquote>
<p>代码清单2.1 使用Docker运行一个Hellol world容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run busybox <span class="built_in">echo</span> <span class="string">"Hello world"</span></span><br><span class="line">Unable to find image <span class="string">'busybox:latest'</span> locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">729ce43e2c91: Pull complete </span><br><span class="line">Digest: sha256:ad9bd57a3a57cc95515c537b89aaa69d83a6df54c4050fcf2b41ad367bec0cd5</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>这或许看起来并不那么令人印象深刻，但非常棒的是仅仅使用一个简单的命令就下载、运行一个完整的“应用”，而不用安装应用或是做其他的事情。目前的应用是单一可执行文件（busybox），但也可以是一个有许多依赖的复杂应用。整个配置运行应用的过程是完全一致的。同样重要的是应用是在容器内部被执行的，完全独立于其他所有主机上运行的进程。</p>
<p><strong><font size="4">背后的原理</font></strong></p>
<p>图2.1展示了执行<code>docker run</code>命令之后发生的事情。首先，Docker会检查busybox:latest镜像是否已经存在于本机。如果没有，Docker会从<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker镜像中心</a>拉取镜像。镜像下载到本机之后，Docker基于这个镜像创建一个容器并在容器中运行命令。echo命令打印文字到标准输出流，然后进程终止，容器停止运行。</p>
<blockquote>
<p>图2.1 在一个基于busybox镜像的容器中运行<code>echo &quot;Hello world&quot;</code></p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/1.png">
<p><strong><font size="4">运行其他镜像</font></strong></p>
<p>运行其他的容器镜像和运行busybox镜像是一样的，甚至可能更简单，因为你可以不需要指定执行命令。就像例子中的<code>echo &quot;Hello world&quot;</code>，被执行的命令通常都会被包含在镜像中，但也可以根据需要进行覆盖。在浏览器中搜索<a href="http://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>或其他公开的镜像中心的可用镜像之后，可以像这样在Docker中运行镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run &lt;image&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong><font size="4">容器镜像的版本管理</font></strong></p>
<p>当然，所有的软件包都会更新，所以通常每个包都不止一个版本。Docker支持同一镜像的多个版本。每一个版本必须有唯一的tag名。当引用镜像没有显式地指定tag时，Docker会默认指定tag为latest。如果想要运行别的版本的镜像，需要像这样指定镜像的版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建一个简单的Node-js应用"><a href="#创建一个简单的Node-js应用" class="headerlink" title="创建一个简单的Node.js应用"></a><span style="color:#00ACC1;">创建一个简单的Node.js应用<span></span></span></h2><p>现在有了一个可以工作的Docker环境来创建应用。接下来会构建一个简单的Node.js Web应用，并把它打包到容器镜像中。这个应用会接收HTTP请求并响应应用运行的主机名。这样，应用运行在容器中，看到的是自己的主机名而不是宿主机名，即使它也像其他进程一样运行在宿主机上。这在后面会非常有用，当应用部署在Kubernetes上并进行伸缩时（水平伸缩，复制应用到多个节点），你会发现HTTP请求切换到了应用的不同实例上。</p>
<p>应用包含一个名为app.js的文件，详见下面的代码清单。</p>
<blockquote>
<p>代码清单2.2 一个简单的Node.js应用：app.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Kubia server starting..."</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)  </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received request from "</span> + request.connection.remoteAddress);</span><br><span class="line">    response.writeHead(<span class="number">200</span>);</span><br><span class="line">    response.end(<span class="string">"You've hit "</span>+ os.hostname() + <span class="string">"\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handler);</span><br><span class="line">www.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p>代码清晰地说明了实现的功能。这里在8080端口启动了一个HTTP服务器。服务器会以状态码<code>200 OK</code>和文字<code>&quot;You&#39;ve hit &lt;hostname&gt;&quot;</code>来响应每个请求。请求handler会把客户端的IP打印到标准输出，以便日后查看。</p>
<blockquote>
<p>注意 返回的主机名是服务器真实的主机名，不是客户端发出的HTTP请求中头的Host字段。</p>
</blockquote>
<p>现在可以直接下载安装Node.js来测试代码了，但是这不是必需的，因为可以直接用Docker把应用打包成镜像，这样在需要运行的主机上就无须下载和安装其他的东西（当然不包括安装Docker来运行镜像）。</p>
<h2 id="为镜像创建Dockerfile"><a href="#为镜像创建Dockerfile" class="headerlink" title="为镜像创建Dockerfile"></a><span style="color:#00ACC1;">为镜像创建Dockerfile<span></span></span></h2><p>为了把应用打包成镜像，首先需要创建一个叫Dockerfile的文件，它包含了一系列构建镜像时会执行的指令。Dockerfile文件需要和app.js文件在同一目录，并包含下面代码清单中的命令。</p>
<blockquote>
<p>代码清单2.3 构建应用容器镜像的Dockerfile</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7</span><br><span class="line">ADD app.js /app.js</span><br><span class="line">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"app.js"</span>]</span><br></pre></td></tr></table></figure>
<p>From行定义了镜像的起始内容（构建所基于的基础镜像）。这个例子中使用的是node镜像的tag 7版本。第二行中把app.js文件从本地文件夹添加到镜像的根目录，保持app.js这个文件名。最后一行定义了当镜像被运行时需要被执行的命令，这个例子中，命令是<code>node app.js</code>。</p>
<blockquote>
<p>选择基础镜像<br><br>你或许在想，为什么要选择这个镜像作为基础镜像。因为这个应用是Node.js应用，镜像需要包含可执行的node二进制文件来运行应用。你也可以使用任何包含这个二进制文件的镜像，或者甚至可以使用Linux发行版的基础镜像，如fedora或ubuntu，然后在镜像构建的时候安装Node.js。但是由于node镜像是专门用来运行Node.js应用的，并且包含了运行应用所需的一切，所以把它当作基础镜像。</p>
</blockquote>
<h2 id="构建容器镜像"><a href="#构建容器镜像" class="headerlink" title="构建容器镜像"></a><span style="color:#00ACC1;">构建容器镜像<span></span></span></h2><p>现在有了Dockerfile和app.js文件，这是用来构建镜像的所有文件。运行下面的Docker命令来构建镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t kubia .</span><br></pre></td></tr></table></figure></p>
<p>图2.2展示了镜像构建的过程。用户告诉Docker需要基于当前目录（注意命令结尾的点）构建一个叫kubia的镜像，Docker会在目录中寻找Dockerfile，然后基于其中的指令构建镜像。</p>
<blockquote>
<p>图2.2 基于Dockerfile构建一个新的容器镜像</p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/2.png">
<p><strong><font size="4">镜像是如何构建的</font></strong></p>
<p>构建过程不是由Docker客户端进行的，而是将整个目录的文件上传到Docker守护进程并在那里进行的。Docker客户端和守护进程不要求在同一台机器上。如果你在一台非Linux操作系统中使用Docker，客户端就运行在你的宿主操作系统上，但是守护进程运行在一个虚拟机内。由于构建目录中的文件都被上传到了守护进程中，如果包含了大量的大文件而且守护进程不在本地运行，上传过程会花费更多的时间。</p>
<blockquote>
<p>提示 不要在构建目录中包含任何不需要的文件，这样会减慢构建的速度——尤其当Docker守护进程运行在一个远端机器的时候。</p>
</blockquote>
<p>在构建过程中，Docker首次会从公开的镜像仓库（Docker Hub）拉取基础镜像（node:7），除非已经拉取过镜像并存储在本机上了。</p>
<p><strong><font size="4">镜像分层</font></strong></p>
<p>镜像不是一个大的二进制块，而是由多层组成的，在运行busybox例子时你可能已经注意到（每一层有一行Pull complete），不同镜像可能会共享分层，这会让存储和传输变得更加高效。比如，如果创建了多个基于相同基础镜像（比如例子中的node:7）的镜像，所有组成基础镜像的分层只会被存储一次。拉取镜像的时候，Docker会独立下载每一层。一些分层可能已经存储在机器上了，所以Docker只会下载未被存储的分层。</p>
<p>你或许会认为每个Dockerfile只创建一个新层，但是并不是这样的。构建镜像时，Dockerfile中每一条单独的指令都会创建一个新层。镜像构建的过程中，拉取基础镜像所有分层之后，Docker在它们上面创建一个新层并且添加app.js。然后会创建另一层来指定镜像被运行时所执行的命令。最后一层会被标记为kubia:latest。图2.3展示了这个过程，同时也展示另外一个叫other:latest的镜像如何与我们构建的镜像共享同一层Node.js镜像。</p>
<blockquote>
<p>图2.3 容器镜像是由多层组成的，每一层可以被不同镜像复用</p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/3.png">
<p>构建完成时，新的镜像会存储在本地。下面的代码展示了如何通过Docker列出本地存储的镜像：</p>
<blockquote>
<p>代码清单2.4 列出本地存储的镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       VIRTUAL SIZE</span><br><span class="line">kubia       latest    2bd29714875d   1 minute ago     637.1MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong><font size="4">比较使用Dockerfile和手动构建镜像</font></strong></p>
<p>Dockerfle是使用Docker构建容器镜像的常用方式，但也可以通过运行已有镜像容器来手动构建镜像，在容器中运行命令，退出容器，然后把最终状态作为新镜像。用Dockerfle构建镜像是与此相同的，但是是自动化且可重复的，随时可以通过修改Dockerfle重新构建镜像而无须手动重新输入命令。</p>
<h2 id="运行容器镜像"><a href="#运行容器镜像" class="headerlink" title="运行容器镜像"></a><span style="color:#00ACC1;">运行容器镜像<span></span></span></h2><p>以下的命令可以用来运行镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name kubia-container -p 8080:8080 -d kubia</span><br></pre></td></tr></table></figure></p>
<p>这条命令告知Docker基于kubia镜像创建一个叫kubia-catainer的新容器。这个容器与命令行分离（<code>-d</code>标志），这意味着在后台运行。本机上的8080端口会被映射到容器内的8080端口（<code>-p 8080:8080</code>选项），所以可以通过<code>http://localhost:8080</code>访问这个应用。</p>
<p>如果没有在本机上运行Docker守护进程（比如使用的是Mac或Windows系统，守护进程会运行在VM中），需要使用VM的主机名或IP来代替localhast运行守护进程。可以通过DOCKER_HOST这个环境变量查看主机名。</p>
<p><strong><font size="4">访问应用</font></strong></p>
<p>现在试着通过<code>http://localhost:8080</code>访问你的应用（确保使用Docker主机名或IP替换localhost）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080</span><br><span class="line">you<span class="string">'ve hit 44d76963e8e1</span></span><br></pre></td></tr></table></figure></p>
<p>这是应用的响应。现在应用运行在容器中，与其他东西隔离。可以看到，应用把44d76963e8e1作为主机名返回，这并不是宿主机的主机名。这个十六进制数是Docker容器的ID。</p>
<p><strong><font size="4">列出所有运行中的容器</font></strong></p>
<p>下面的代码清单列出了所有的运行中的容器，可以查看列表（为了更好的可读性，列表被分成了两行显示）。</p>
<blockquote>
<p>代码清单2.5 列出运行中的容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE                COMMAND                 CREATED          STATUS          PORTS                    NAMES</span><br><span class="line">44d76963e8e1   kubia:latest     <span class="string">"bin/sh -c 'node app.js'"</span>   22 seconds ago   Up 21 seconds   0.0.0.0:8080-&gt;8080/tcp   kubia-container</span><br></pre></td></tr></table></figure>
<p>有一个容器在运行。Docker会打印出每一个容器的ID和名称、容器运行所使用的镜像，以及容器中执行的命令。</p>
<p><strong><font size="4">获取更多的容器信息</font></strong></p>
<p><code>docker ps</code>只会展示容器的大部分基础信息。可以使用<code>docker inspect</code>查看更多的信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect kubia-container</span><br></pre></td></tr></table></figure></p>
<p>Docker会打印出包含容器底层信息的长JSON。</p>
<h2 id="探索运行容器的内部"><a href="#探索运行容器的内部" class="headerlink" title="探索运行容器的内部"></a><span style="color:#00ACC1;">探索运行容器的内部<span></span></span></h2><p>我们来看看容器内部的环境。由于一个容器里可以运行多个进程，所以总是可以运行新的进程去看看里面发生了什么。如果镜像里有可用的shell二进制可执行文件，也可以运行一个shell。</p>
<p><strong><font size="4">在已有的容器内部运行shell</font></strong></p>
<p>镜像基于的Node.js镜像包含了bash shell，所以可以像这样在容器内运行shell:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it kubia-container bash</span><br></pre></td></tr></table></figure></p>
<p>这会在已有的kubia-container容器内部运行bash。bash进程会和主容器进程拥有相同的命名空间。这样可以从内部探索容器，查看Node.js和应用是如何在容器里运行的。<code>-it</code>选项是下面两个选项的简写：</p>
<ul>
<li>-i，确保标准输入流保持开放。需要在shell中输入命令。</li>
<li>-t，分配一个伪终端（TTY）。</li>
</ul>
<p>如果希望像平常一样使用shell，需要同时使用这两个选项（如果缺少第一个选项就无法输入任何命令。如果缺少第二个选项，那么命令提示符不会显示，并且一些命令会提示TERM变量没有设置）。</p>
<p><strong><font size="4">从内部探索容器</font></strong></p>
<p>下面的代码展示了如何使用shell查看容器内运行的进程。</p>
<blockquote>
<p>代码清单2.6 从容器内列出进程</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@44d76963e8e1:/<span class="comment"># ps aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  1.3  0.6 614440 25508 ?        Ssl  14:12   0:00 node app.js</span><br><span class="line">root        12  0.6  0.0  20252  3136 pts/0    Ss   14:12   0:00 bash</span><br><span class="line">root        18  0.0  0.0  17508  2040 pts/0    R+   14:12   0:00 ps aux</span><br></pre></td></tr></table></figure>
<p>只看到了三个进程，宿主机上没有看到其他进程。</p>
<p><strong><font size="4">容器内的进程运行在主机操作系统上</font></strong></p>
<p>如果现在打开另一个终端，然后列出主机操作系统上的进程，连同其他的主机进程依然会发现容器内的进程，如代码清单2.7所示。</p>
<blockquote>注意 如果使用的是Mac或者Windows系统，需要登录到Docker守护进程运行的VM查看这些进程。</blockquote>
<br>
<blockquote>代码清单2.7 运行在主机操作系统上的容器进程</blockquote>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@44d76963e8e1:/<span class="comment"># ps aux | grep app.js</span></span><br><span class="line">USER       PID  %CPU  %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root       382  0.0   0.1   614440 25508 ?        Ssl  14:12   0:00 node app.js</span><br></pre></td></tr></table></figure>
<p>这证明了运行在容器中的进程是运行在主机操作系统上的。如果你足够敏锐，会发现进程的ID在容器中与主机上不同。容器使用独立的PID Linux命名空间并且有着独立的系列号，完全独立于进程树。</p>
<p><strong><font size="4">容器的文件系统也是独立的</font></strong></p>
<p>正如拥有独立的进程树一样，每个容器也拥有独立的文件系统。在容器内列出根目录的内容，只会展示容器内的文件，包括镜像内的所有文件，再加上容器运行时创建的任何文件（类似日志文件），如下面的代码清单所示。</p>
<blockquote>
<p>代码清单2.8 容器拥有完整的文件系统</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@44d76963e8e1:/<span class="comment"># ls /</span></span><br><span class="line">app.js  boot  etc   lib    media  opt   root  sbin  sys  usr</span><br><span class="line">bin dev   home  lib64  mnt    proc  run   srv   tmp  var</span><br></pre></td></tr></table></figure>
<p>其中包含app.js文件和其他系统目录，这些目录是正在使用的node:7基础镜像的一部分。可以使用exit命令来退出容器返回宿主机（类似于登出ssh session）。</p>
<blockquote>
<p>提示 进入容器对于调试容器内运行的应用来说是非常有用的。出错时，需要做的第一件事是查看应用运行的系统的真实状态。需要记住的是，应用不仅拥有独立的文件系统，还有进程、用户、主机名和网络接口。</p>
</blockquote>
<h2 id="停止和删除容器"><a href="#停止和删除容器" class="headerlink" title="停止和删除容器"></a><span style="color:#00ACC1;">停止和删除容器<span></span></span></h2><p>可以通过告知Docker停止kubia-container容器来停止应用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop kubia-container</span><br></pre></td></tr></table></figure></p>
<p>因为没有其他的进程在容器内运行，这会停止容器内运行的主进程。容器本身仍然存在并且可以通过<code>docker ps -a</code>来查看。<code>-a</code>选项打印出所有的容器，包括运行中的和已经停止的。想要真正地删除一个容器，需要运行<code>docker rm</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm kubia-container</span><br></pre></td></tr></table></figure></p>
<p>这会删除容器，所有的内容会被删除并且无法再次启动。</p>
<h2 id="向镜像仓库推送镜像"><a href="#向镜像仓库推送镜像" class="headerlink" title="向镜像仓库推送镜像"></a><span style="color:#00ACC1;">向镜像仓库推送镜像<span></span></span></h2><p>现在构建的镜像只可以在本机使用。为了在任何机器上都可以使用，可以把镜像推送到一个外部的镜像仓库。为了简单起见，不需要搭建一个私有的镜像仓库，而是可以推送镜像到公开可用的Docker Hub镜像中心。另外还有其他广泛使用的镜像中心，如Quay.io和Google Container Registry。</p>
<p>在推送之前，需要重新根据Docker Hub的规则标注镜像。Docker Hub允许向以你的Docker Hub ID开头的镜像仓库推送镜像。可以注册Docker Hub ID。下面的例子中会使用笔者自己的ID（luksa），请在每次出现时替换自己的ID。</p>
<p><strong><font size="4">使用附加标签标注镜像</font></strong></p>
<p>一旦知道了自己的ID，就可以重命名镜像，现在镜像由kubia改为luksa/kubia（用自己的Docker Hub ID代替luksa）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag kubia luksa/kubia</span><br></pre></td></tr></table></figure></p>
<p>这不会重命名标签，而是给同一个镜像创建一个额外的标签。可以通过<code>docker images</code>命令列出本机存储的镜像来加以确认，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单2.9 一个容器镜像可以有多个标签</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | head</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">kubia        latest    f058203c866a   5 hours ago   660MB</span><br><span class="line">luksa/kubia  latest    f058203c866a   5 hours ago   660MB</span><br><span class="line">docker.io/node 7.0     04c0ca2a8dad   2 days ago    660MB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>正如所看到的，kubia和luksa/kubia指向同一个镜像ID，所以实际上是同一个镜像的两个标签。</p>
<p><strong><font size="4">向Docker Hub推送镜像</font></strong></p>
<p>在向Docker Hub推送镜像之前，先需要使用<code>docker login</code>命令和自己的用户ID登录，然后就可以像这样向Docker Hub推送yourid/kubia镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push luksa/kubia</span><br></pre></td></tr></table></figure></p>
<p><strong><font size="4">在不同机器上运行镜像</font></strong></p>
<p>在推送完成之后，镜像便可以给任何人使用。可以在任何机器上运行下面的命令来运行镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 8080:8080 -d luksa/kubia</span><br></pre></td></tr></table></figure></p>
<p>这非常简单。最棒的是应用每次都运行在完全一致的环境中。如果在你的机器上正常运行，也会在所有的Linux机器上正常运行。无须担心主机是否安装了Node.js。事实上，就算安装了，应用也并不会使用，因为它使用的是镜像内部安装的。</p>
<h1 id="配置Kubernetes集群"><a href="#配置Kubernetes集群" class="headerlink" title="配置Kubernetes集群"></a><span style="color:#339AFF;">配置Kubernetes集群<span></span></span></h1><p>现在，应用被打包在一个容器镜像中，并通过Docker Hub给大家使用，可以将它部署到Kubernetes集群中，而不是直接在Docker中运行。但是需要先设置集群。</p>
<p>设置一个完整的、多节点的Kubernetes集群并不是一项简单的工作，特别是如果你不精通Linux和网络管理的话。一个适当的Kubernetes安装需要包含多个物理或虚拟机，并需要正确地设置网络，以便在Kubernetes集群内运行的所有容器都可以在相同的扁平网络环境内相互连通。</p>
<p>安装Kubernetes集群的方法有许多。这些方法在<a href="https://kubernetes.io/docs/home/" target="_blank" rel="noopener">文档</a>中有详细描述。我们不会在这里列出所有，因为内容在不断变化，但Kubernetes可以在本地的开发机器、自己组织的机器集群或是虚拟机提供商（Google Compute Engine、Amazon EC2、Microsoft Azure等）上运行，或者使用托管的Kubernetes集群，如Google Kubernetes Engine（以前称为Google Container Engine）。</p>
<p>在这一章中，将介绍用两种简单的方法构建可运行的Kubernetes集群，你将会看到如何在本地机器上运行单节点Kubernetes集群，以及如何访问运行在Google Kubernetes Engine（GKE）上的托管集群。</p>
<p>第三个选项是使用kubeadm工具安装一个集群，这会在附录B中介绍，这里的说明向你展示了如何使用虚拟机建立一个三节点的Kubernetes集群，但是建议你在阅读本书的前11章之后再尝试。</p>
<p>另一个选择是在亚马逊的AWS（Amazon Web Services）上安装Kubernetes。为此，可以查看kops工具，它是在前面一段提到的kubeadm基础之上构建的，可以在<a href="http://github.com/kubernetes/kops" target="_blank" rel="noopener">github</a>中找到。它帮助你在AWS上部署生产级、高可用的Kubernetes集群，并最终会支持其他平台（Google Kubernetes Engine、VMware、vSphere等）。</p>
<h2 id="用Minikube运行一个本地单节点Kubernetes集群"><a href="#用Minikube运行一个本地单节点Kubernetes集群" class="headerlink" title="用Minikube运行一个本地单节点Kubernetes集群"></a><span style="color:#00ACC1;">用Minikube运行一个本地单节点Kubernetes集群</span></h2><p>使用Minikube是运行Kubernetes集群最简单、最快捷的途径。Minikube是一个构建单节点集群的工具，对于测试Kubernetes和本地开发应用都非常有用。</p>
<p>虽然我们不能展示与管理多节点应用相关的一些Kubermetes特性，但是单节点集群足以探索本书中讨论的大多数主题。</p>
<p><strong><font size="4">安装Minikube</font></strong></p>
<p>Minikube是一个需要下载并放到路径中的二进制文件。它适用于OSX、Linux和Windows系统。最好访问GitHub上的<a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">Minikube代码仓库</a>，按照说明来安装它。</p>
<p>例如，在OSX和Linux系统上，可以使用一个命令下载Minikube并进行设置。对于OSX系统，命令是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-darwin-amd64 </span><br><span class="line">&amp;&amp; chmod +x minikube </span><br><span class="line">&amp;&amp; sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></p>
<p>在Linux系统中，可以下载另一个版本（将URL中的“darwin”替换为“linux”）。在Windows系统中，可以手动下载文件，将其重命名为minikube.exe，并把它加到路径中。Minikube在VM中通过VirtualBox或KVM运行Kubenetes，所以在启动Minikube集群之前，还需要安装VM。</p>
<p><strong><font size="4">使用Minikue启动一个Kubernetes集群</font></strong></p>
<p>当你在本地安装了Minikube之后，可以立即使用下面的命令启动Kubermetes集群。</p>
<blockquote>
<p>代码清单2.10 启动一个Minikube虚拟机</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ minikube start</span><br><span class="line">Starting <span class="built_in">local</span> Kubernetes v1.8.0 cluster...</span><br><span class="line">Starting VM...</span><br><span class="line">SSH-ing files into VM...</span><br><span class="line">...</span><br><span class="line">Kubectl is now configured to use the cluster.</span><br></pre></td></tr></table></figure>
<p>启动集群需要花费超过一分钟的时间，所以在命令完成之前不要中断它。</p>
<p><strong><font size="4">安装Kubernetes客户端（kubectl）</font></strong></p>
<p>要与Kubernetes进行交互，还需要kubectl CLI客户端。同样，需要做的就是下载它，并放在路径中。例如，OSX系统的最新稳定版本可以通过以下命令下载并安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl-L0https://storage.googleapis.com/kubernetes-release/release</span><br><span class="line">-LO</span><br><span class="line">/$(curl-shttps://storage.googleapis.com/kubernetes-release/release /stable.txt)/bin/darwin/amd64/kubectl</span><br><span class="line">&amp;&amp; chmod +x kubectl</span><br><span class="line">&amp;&amp; sudo mv kubectl /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></p>
<p>要下载用于Linux或Windows系统的kubectl，用linux或windows替换URL中的darwin。</p>
<blockquote>
<p>注意 如果你需要使用多个Kubemetes集群（例如，Minikube和GKE），请参考附录A，了解如何在不同的kubectl上下文中设置和切换。</p>
</blockquote>
<p><strong><font size="4">使用kubectl查看集群是否正常工作</font></strong></p>
<p>要验证集群是否正常工作，可以使用以下所示的<code>kubectl cluster-info</code>命令。</p>
<blockquote>
<p>代码清单2.11 展示集群信息</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl cluster-info</span><br><span class="line">Kubernetes masterisrunningathttps://192.168.99.100:8443</span><br><span class="line">KubeDNS is running athttps://192.168.99 .100:8443/api/v1/proxy</span><br><span class="line">kubernetes -dashboard is running at https ://192.168.99.100:8443/pi/v1/...</span><br></pre></td></tr></table></figure>
<p>这里显示集群已经启动。它显示了各种Kubernetes组件的URL，包括API服务器和Web控制台。</p>
<blockquote>
<p>提示 可以运行<code>minikube ssh</code>登录到Minikube VM并从内部探索它。例如，可以查看在节点上运行的进程。</p>
</blockquote>
<h2 id="使用Google-Kubernetes-Engine托管Kubernetes集群"><a href="#使用Google-Kubernetes-Engine托管Kubernetes集群" class="headerlink" title="使用Google Kubernetes Engine托管Kubernetes集群"></a><span style="color:#00ACC1;">使用Google Kubernetes Engine托管Kubernetes集群</span></h2><p>如果你想探索一个完善的多节点Kubernetes集群，可以使用托管的Google Kubernetes Engine（GKE）集群。这样，无须手动设置所有的集群节点和网络，因为这对于刚开始使用Kubernetes的人来说太复杂了。使用例如GKE这样的托管解决方案可以确保不会出现配置错误、不工作或部分工作的集群。</p>
<p><strong><font size="4">配置一个Google Cloud项目并且下载必需的客户端二进制</font></strong></p>
<p>在设置新的Kubernetes集群之前，需要设置GKE环境。因为这个过程可能会改变，所以不在这里列出具体的说明。阅读<a href="https://cloud.google.com/containerenginddocs/before-begin" target="_blank" rel="noopener">说明</a>后就可以开始了。</p>
<p>整个过程大致包括：</p>
<p>1，注册谷歌账户，如果你还没有注册过。</p>
<p>2，在GoogleCloudPlatform控制台中创建-一个项目。</p>
<p>3，开启账单。这会需要你的信用卡信息，但是谷歌提供了为期12个月的免费试用。而且在免费试用结束后不会自动续费。</p>
<p>4，开启KubernetesEngineAPI。</p>
<p>5，下载安装GoogleCloudSDK（这包含gcloud命令行工具，需要创建一个Kubernetes集群）。</p>
<p>6，使用gcloudcomponentsinstallkubectl安装kubectl命令行工具。</p>
<p>注意某些操作（例如步骤2中的操作）可能需要几分钟才能完成，所以在此期间可以喝杯咖啡放松一下。</p>
<p>创建一个三节点Kubernetes集群</p>
<p>完成安装后，可以使用下面代码清单中的命令创建一个包含三个工作节点的Kubernetes集群。</p>
<blockquote>
<p>代码清单2.12 在GKE上创建一个三节点集群</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ gcloud container clusters create kubia --num-nodes 3</span><br><span class="line">--machine-typ e f1-micro</span><br><span class="line">Creating cluster kubia...done.</span><br><span class="line">Created [https: / /container.googleapis.com/v1/projects/kubia1- </span><br><span class="line">1227/zones/ europe-west1<span class="_">-d</span>/clusters/kubia].</span><br><span class="line">kubeconfig entry generated forkubia. </span><br><span class="line">NAME ZONE MS T VER MASTER IP</span><br><span class="line">TYPE</span><br><span class="line">NODE_VER NUM NODES STATUS</span><br><span class="line">kubia eu-w1d 1. 5.3 104.155.92.30 f1-micro 1.5.3</span><br><span class="line">3</span><br><span class="line">RUNNING</span><br></pre></td></tr></table></figure>
<p>现在已经有一个正在运行的Kubernetes集群，包含了三个工作节点，如图2.4所示。你在使用三个节点来更好地演示适用于多节点的特性，如果需要的话可以使用较少数量的节点。</p>
<p>获取集群概览</p>
<p>图2.4能够让你对集群，以及如何与集群交互有一个初步的认识。每个节点运行着Docker、Kubelet和kube-proxy。可以通过kubectl命令行客户端向运行在主节点上的KubernetesAPI服务器发出REST请求以与集群交互。</p>
<blockquote>
<p>图2.4 如何与三节点Kubernetes集群进行交互</p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/4.png">
<p>通过列出集群节点查看集群是否在运行</p>
<p>现在可以使用kubectl命令列出集群中的所有节点，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单2.13 使用kubect1列出集群节点</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>kubectl get</code>命令可以列出各种Kubernetes对象。你将会经常使用到它，但它通常只会显示对象最基本的信息。</p>
<p>提示可以使用<code>gcloudcomputessh&lt;node-name&gt;</code>登录到其中一个节点，查看节点上运行了什么。</p>
<p>查看对象的更多信息</p>
<p>要查看关于对象的更详细的信息，可以使用kubectldescribe命令，它显了更多信息：</p>
<p>这里省略了describe命令的实际输出，因为内容非常多且在书中是完全不可读的。输出显示了节点的状态、CPU和内存数据、系统信息、运行容器的节点等。</p>
<p>在前面的<code>kubectl describe</code>示例中，显式地指定了节点的名称，但也可以执行一个简单的<code>kubectl describe node</code>命令，而无须指定节点名，它将打印出所有节点的描述信息。</p>
<p>提示当只有一个给定类型的对象存在时，不指定对象名就运行description和get命令是很提倡的，这样不会浪费时间输入或复制、粘贴对象的名称。</p>
<p>当我们讨论减少输入的时候，开始在Kubernetes运行第一个应用程序之前，先学习如何让kubectl命令的使用变得更容易。</p>
<h2 id="为kubectl配置别名和命令行补齐"><a href="#为kubectl配置别名和命令行补齐" class="headerlink" title="为kubectl配置别名和命令行补齐"></a><span style="color:#00ACC1;">为kubectl配置别名和命令行补齐</span></h2><p>kubectl会被经常使用。很快你就会发现每次不得不打全命令是非常痛苦的。在继续之前，花一分钟为kubectl设置别名和tab命令补全可让使用变得简单。</p>
<p>创建别名</p>
<p>在整本书中，一直会使用kubectl可执行文件的全名，但是你可以添加一个较短的别名，如k，这样就不用每次都输入kubectl了。如果还没有设置别名，这里会告诉你如何定义。将下面的代码添加到~/.bashrc或类似的文件中：</p>
<p>注意如果你已经在用gcloud配置集群，就已经有可执行文件k了。</p>
<p>为kuebctl配置tab补全</p>
<p>即使使用短别名k，仍然需要输入许多内容。幸运的是，kubectl命令还可以配置bash和zshshell的代码补全。tab补全不仅可以补全命令名，还能补全对象名。例如，无须在前面的示例中输入整个节点名，只需输入</p>
<p>需要先安装一个叫作bashcompletion的包来启用bash中的tab命令补全，然后可以运行接下来的命令（也需要加到~/.bashrc或类似的文件中）：</p>
<p>但是需要注意的是，tab命令行补全只在使用完整的kubectl命令时会起作用（当使用别名k时不会起作用）。需要改变kubectlcompletion的输出来修复：</p>
<p>注意不幸的是，在写作本书之时，别名的shell命令补全在MacOS系统上并不起作用。如果需要使用命令行补全，就需要使用完整的kubectl命令。</p>
<p>现在你已经准备好无须输入太多就可以与集群进行交互。现在终于可以在Kubernetes上运行第一个应用了。</p>
<h1 id="在Kubernetes上运行第一个应用"><a href="#在Kubernetes上运行第一个应用" class="headerlink" title="在Kubernetes上运行第一个应用"></a><span style="color:#339AFF;">在Kubernetes上运行第一个应用</span></h1><p>因为这可能是第一次，所以会使用最简单的方法在Kubernetes上运行应用程序。通常，需要准备一个JSON或YAML，包含想要部署的所有组件描述的配置文件，但是因为还没有介绍可以在Kubernetes中创建的组件类型，所以这里将使用一个简单的单行命令来运行应用。</p>
<h2 id="部署Node-js应用"><a href="#部署Node-js应用" class="headerlink" title="部署Node.js应用"></a><span style="color:#00ACC1;">部署Node.js应用</span></h2><p>部署应用程序最简单的方式是使用<code>kubectl run</code>命令，该命令可以创建所有必要的组件而无需JSON或YAML文件。这样的话，我们就不需要深入了解每个组件对象的结构。试着运行之前创建、推送到Docker Hub的镜像。下面是在Kubernetes中运行的代码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl run kubia --image=luksa/kubia --port=8080 --generator=run/v1</span></span><br><span class="line">replicationcontroller "kubia" created</span><br></pre></td></tr></table></figure></p>
<p><code>--image=luksa/kubia</code>显示的是指定要运行的容器镜像，<code>--port=8080</code>选项告诉Kubernetes应用正在监听8080端口。最后一个标志（<code>--generator</code>）需要解释一下，通常并不会使用到它，它让Kubernetes创建一个ReplicationController，而不是Deployment。稍后你将在本章中了解到什么是ReplicationController，但是直到<a href="/2022/10/01/9-Deployment：声明式地升级应用/" title="第9章">第9章</a>才会介绍Deployment，所以不会在这里创建Deployment。</p>
<p>正如前面命令的输出所示，已经创建了一个名为kubia的ReplicationController。如前所述，我们将在本章的后面看到。从底层开始，把注意力放在创建的容器上（可以假设已经创建了一个容器，因为在run命令中指定了一个容器镜像）。</p>
<p><strong><font size="4">介绍pod</font></strong></p>
<p>你或许在想，是否有一个列表显示所有正在运行的容器，可以通过类似于<code>kuberctl get containers</code>的命令获取。这并不是Kubernetes的工作，它不直接处理单个容器。相反，它使用多个共存容器的理念。这组容器就叫作pod。</p>
<p>一个pod是一组紧密相关的容器，它们总是一起运行在同一个工作节点上，以及同一个Linux命名空间中。每个pod就像一个独立的逻辑机器，拥有自己的IP、主机名、进程等，运行一个独立的应用程序。应用程序可以是单个进程，运行在单个容器中，也可以是一个主应用进程或者其他支持进程，每个进程都在自己的容器中运行。一个pod的所有容器都运行在同一个逻辑机器上，而其他pod中的容器，即使运行在同一个工作节点上，也会出现在不同的节点上。</p>
<p>为了更好地理解容器、pod和节点之间的关系，请查看图2.5。如你所见，每个pod都有自己的IP，并包含一个或多个容器，每个容器都运行一个应用进程。pod分布在不同的工作节点上。</p>
<blockquote>
<p>图2.5 容器、pod及物理工作节点之间的关系</p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/5.png">
<p><strong><font size="4">列出pod</font></strong></p>
<p>不能列出单个容器，因为它们不是独立的Kubernetes对象，但是可以列出pod。让我们看看如何使用kubectl在下面的代码清单中列出pod。</p>
<blockquote>
<p>代码清单2.14 列出pod</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME           READY  STATUS   RESTARTS  AGE</span><br><span class="line">kubia-4jfyf     0/1   Pending   0         1m</span><br></pre></td></tr></table></figure>
<p>pod仍然处于挂起状态，pod的单个容器显示为还未就绪的状态（这是READY列中的0/1的含义）。pod还没有运行的原因是：该pod被分配到的工作节点正在下载容器镜像，完成之后才可以运行。下载完成后，将创建pod的容器，然后pod会变为运行状态，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单2.15 再次列出pod查看pod的状态是否变化</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME           READY  STATUS   RESTARTS  AGE</span><br><span class="line">kubia-4jfyf     1/1   Running   0         5m</span><br></pre></td></tr></table></figure>
<p>要查看有关pod的更多信息，还可以使用<code>kubectl describe pod</code>命令，就像之前查看工作节点一样。如果pod停留在挂起状态，那么可能是Kubernetes无法从镜像中心拉取镜像。如果你正在使用自己的镜像，确保它在Docker Hub上是公开的。为了确保能够成功地拉取镜像，可以试着在另一台机器上使用<code>docker pull</code>命令手动拉取镜像。</p>
<p><strong><font size="4">幕后发生的事情</font></strong></p>
<p>为了可视化所发生的事情，请看图2.6。它显示了在Kubernetes中运行容器镜像所必需的两个步骤。首先，构建镜像并将其推送到Docker Hub。这是必要的，因为在本地机器上构建的镜像只能在本地机器上可用，但是需要使它可以访问运行在工作节点上的Docker守护进程。</p>
<p>当运行kubectl命令时，它通过向Kubernetes API服务器发送一个REST HTTP请求，在集群中创建一个新的ReplicationController对象。然后，ReplicationController创建了一个新的pod，调度器将其调度到一个工作节点上。Kubelet看到pod被调度到节点上，就告知Docker从镜像中心中拉取指定的镜像，因为本地没有该镜像。下载镜像后，Docker创建并运行容器。</p>
<p>展示另外两个节点是为了显示上下文。它们没有在这个过程中扮演任何角色，因为pod没有调度到它们上面。</p>
<blockquote>
<p>定义 术语调度（scheduling）的意思是将pod分配给一个节点。pod会立即运行，而不是将要运行。</p>
<p>图2.6 在Kubernetes中运行luksa/kubia容器镜像</p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/6.png">
<h2 id="访问Web应用"><a href="#访问Web应用" class="headerlink" title="访问Web应用"></a><span style="color:#00ACC1;">访问Web应用</span></h2><p>如何访问正在运行的pod？我们提到过每个pod都有自己的IP地址，但是这个地址是集群内部的，不能从集群外部访问。要让pod能够从外部访问，需要通过服务对象公开它，要创建一个特殊的LoadBalancer类型的服务。因为如果你创建一个常规服务（一个ClusterIP服务），比如pod，它也只能从集群内部访问。通过创建LoadBalancer类型的服务，将创建一个外部的负载均衡，可以通过负载均衡的公共IP访问pod.</p>
<p><strong><font size="4">创建一个服务对象</font></strong></p>
<p>要创建服务，需要告知Kubernetes对外暴露之前创建的ReplicationController：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 我们这里用的是ReplicationController的缩写rc。大多数资源类型都有这样的缩写，所以不必输入全名（例如，pods的缩写是po，service的缩写是svc，等等）。 </p>
</blockquote>
<p><strong><font size="4">列出服务</font></strong></p>
<p>expose命令的输出中提到一个名为kubian-http的服务。服务是类似于pod和Node的对象，因此可以通过运行kubectlgetservices命令查看新创建的服务对象，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单2.16 列出服务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该列表显示了两个服务。暂时忽略kubernetes服务，仔细查看创建的kubian-http服务。它还没有外部IP地址，因为Kubernetes运行的云基础设施创建负载均衡需要—段时间。负载均衡启动后，应该会显示服务的外部IP地址。让我们等待-段时间并再次列出服务，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单2.17 再次列出服务并查看是否分配了外部IP</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在有外部IP了，应用就可以从任何地方通过<code>http://104.155.74.57:8080</code>访问。注意Minikube不支持LoadBalancer类型的服务，因此服务不会有外部IP。但是可以通过外部端口访问服务。在下一节的提示中将介绍这是如何做到的。</p>
<p><strong><font size="4">使用外部IP访问服务</font></strong></p>
<p>现在可以通过服务的外部IP和端口向pod发送请求：</p>
<p>现在，应用程序在三个节点的Kubernetes集群（如果使用Minikube，则是一个单节点集群）.上运行起来了。如果你忘了建立整个集群所需的步骤，那么只需两个简单的命令就可以让你的应用运行起来，并且让全世界的用户都能访问它。</p>
<blockquote>
<p>提示 使用Minikube的时候，可以运行<code>miniåkubeservicekubia-http</code>获取可以访问服务的IP和端口。</p>
</blockquote>
<p>如果仔细观察，会发现应用将pod名称作为它的主机名。如前所述，每个pod都像一个独立的机器，具有自己的IP地址和主机名。尽管应用程序运行在工作节点的操作系统中，但对应用程序来说，它似乎是在一个独立的机器上运行，而这台机器本身就是应用程序的专用机器，没有其他的进程一同运行。</p>
<h2 id="系统的逻辑部分"><a href="#系统的逻辑部分" class="headerlink" title="系统的逻辑部分"></a><span style="color:#00ACC1;">系统的逻辑部分</span></h2><p>到目前为止，主要介绍了系统实际的物理组件。三个工作节点是运行Docker和Kubelet的VM，还有一个控制整个系统的主节点。实际上，我们并不知道主节点是否管理着Kubernetes控制层的所有组件，或者它们是否跨多个节点。这并不重要，因为你只与单点访问的API服务器进行交互。</p>
<p>除了这个系统的物理视图，还有一个单独的、逻辑的视图。之前已经提到过pod、ReplicationController和服务。所有这些都将在后面几章中介绍，但是让我们先快速地看看它们是如何组合在一起的，以及它们在应用中扮演什么角色。</p>
<p>ReplicationController、pod和服务是如何组合在一起的<br>正如前面解释过的，没有直接创建和使用容器。相反，Kubernetes的基本构件是pod。但是，你并没有真的创建出任何pod，至少不是直接创建。通过运行kubectlrun命令，创建了一个ReplicationController，它用于创建pod实例。为了使该pod能够从集群外部访问，需要让Kubernetes将该ReplicationController管理的所有pod由一个服务对外暴露。图2.7给出了这三种元素组合的大致情况。</p>
<blockquote>
<p>图2.7 由ReplicationController.pod和服务组成的系统</p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/7.png">
<p><strong><font size="4">pod和它的容器</font></strong></p>
<p>在你的系统中最重要的组件是pod.它只包含一个容器，但是通常一个pod可以包含任意数量的容器。容器内部是Node.js进程，该进程绑定到8080端口，等待HTTP请求。pod有自己独立的私有IP地址和主机名。</p>
<p><strong><font size="4">ReplicationController的角色</font></strong></p>
<p>下一个组件是kubiaReplicationController。它确保始终存在一个运行中的pod实例。通常，ReplicationController用于复制pod（即创建pod的多个副本）并让它们保持运行。示例中没有指定需要多少pod副本，所以ReplicationController创建了一个副本。如果你的pod因为任何原因消失了，那么ReplicationController将创建一个新的pod来替换消失的pod。</p>
<p><strong><font size="4">为什么需要服务</font></strong></p>
<p>系统的第三个组件是kubian-http服务。要理解为什么需要服务，需要学习有关pod的关键细节。pod的存在是短暂的，一个pod可能会在任何时候消失，或许因为它所在节点发生故障，或许因为有人删除了pod，或者因为pod被从一个健康的节点剔除了。当其中任何一种情况发生时，如前所述，消失的pod将被ReplicationController替换为新的pod。新的pod与替换它的pod具有不同的IP地址。这就是需要服务的地方-一解决不断变化的podIP地址的问题，以及在一个固定的IP和端口对上对外暴露多个pod。</p>
<p>当一个服务被创建时，它会得到一个静态的IP，在服务的生命周期中这个IP不会发生改变。客户端应该通过固定IP地址连接到服务，而不是直接连接pod。服务会确保其中一个pod接收连接，而不关心pod当前运行在哪里（以及它的IP地址是什么）。</p>
<p>服务表示一组或多组提供相同服务的pod的静态地址。到达服务IP和端口的请求将被转发到属于该服务的一个容器的IP和端口。</p>
<h2 id="水平伸缩应用"><a href="#水平伸缩应用" class="headerlink" title="水平伸缩应用"></a>水平伸缩应用</h2><p>现在有了一个正在运行的应用，由ReplicationController监控并保持运行，并通过服务暴露访问。现在让我们来创造更多魔法。<br>使用Kubernetes的一个主要好处是可以简单地扩展部署。让我们看看扩容pod有多容易。接下来要把运行实例的数量增加到三个。</p>
<p>pod由一个ReplicationController管理。让我们来查看kubectlget命令：</p>
<p>使用kubectlget列出所有类型的资源</p>
<p>一直在使用相同的基本命令kubectlget来列出集群中的资源。你已经使用此命令列出节点、pod、服务和ReplicationController对象。不指定资源类型调用kubectlget可以列出所有可能类型的对象。然后这些类型可以使用各种kubectl命令，例如get、describe等。列表还显示了前面提到的缩写。</p>
<p>该列表显示了一个名为kubia的单个ReplicationController。DESIRED列显示了希望ReplicationController保持的pod副本数，而CURRENT列显示当前运行的pod数。在示例中，希望pod副本为1，而现在就有一个副本正在运行。<br>增加期望的副本数</p>
<p>为了增加pod的副本数，需要改变ReplicationController期望的副本数，如下所示：</p>
<p>现在已经告诉Kubernetes需要确保pod始终有三个实例在运行。注意，你没有告诉Kubernetes需要采取什么行动，也没有告诉Kubernetes增加两个pod，只设置新的期望的实例数量并让Kubernetes决定需要采取哪些操作来实现期望的状态。</p>
<p>这是Kubernetes最基本的原则之一。不是告诉Kubernetes应该执行什么操作，而是声明性地改变系统的期望状态，并让Kubernetes检查当前的状态是否与期望的状态一致。在整个Kubernetes世界中都是这样的。</p>
<p>查看扩容的结果</p>
<p>前面增加了pod的副本数。再次列出ReplicationController查看更新后的副本数：</p>
<p>由于pod的实际数量已经增加到三个（从CURRENT列中可以看出），列出所有的pod时显示的应该是三个而不是一个：</p>
<p>正如你所看到的，有三个pod而不是一个。两个已经在运行，一个仍在挂起中，一旦容器镜像下载完毕并启动容器，挂起的pod会马上运行。</p>
<p>正如你所看到的，给应用扩容是非常简单的。一旦应用在生产中运行并且需要扩容，可以使用一个命令添加额外的实例，而不必手动安装和运行其他副本。</p>
<p>记住，应用本身需要支持水平伸缩。Kubenetes并不会让你的应用变得可扩展，它只是让应用的扩容或缩容变得简单。</p>
<p>当切换到服务时请求切换到所有三个pod上</p>
<p>因为现在应用的多个实例在运行，让我们看看如果再次请求服务的URL会发生什么。会不会总是切换到应用的同一个实例呢？</p>
<p>请求随机地切换到不同的pod.当pod有多个实例时Kubermetes服务就会这样做。服务作为负载均衡挡在多个pod前面。当只有一个pod时，服务为单个pod提供-个静态地址。无论服务后面是单个pod还是一组pod，这些pod在集群内创建、消失，这意味着它们的IP地址会发生变化，但服务的地址总是相同的。这使得无论有多少pod，以及它们的地址如何变化，客户端都可以很容易地连接到pod。</p>
<p>可视化系统的新状态</p>
<p>让我们可视化一下现在的系统，看看和以前相比发生了什么变化。图2.8显示了系统的新状态。仍然有一个服务和一个ReplicationController，但是现在有三个pod实例，它们都是由ReplicationController管理的。服务不再将所有请求发送到单个pod，而是将它们分散到所有三个pod中，如前面使用curl进行的实验所示。</p>
<p>作为练习，现在可以尝试通过进一步增加ReplicationController的副本数来启动附加实例，甚至可以尝试减小副本数。</p>
<blockquote>
<p>图2.8 由同一ReplicationController管理并通过服务IP和端口暴露的pod的三个实例</p>
</blockquote>
<img src="/2022/09/28/2-开始使用Kubernetes和Docker/8.png">
<h2 id="查看应用运行在哪个节点上"><a href="#查看应用运行在哪个节点上" class="headerlink" title="查看应用运行在哪个节点上"></a>查看应用运行在哪个节点上</h2><p>你可能想知道pod被调度到哪个节点上。在Kubemetes的世界中，pod运行在哪个节点.上并不重要，只要它被调度到一个可以提供pod正常运行所需的CPU和内存的节点就可以了。</p>
<p>不管调度到哪个节点，容器中运行的所有应用都具有相同类型的操作系统。每个pod都有自己的IP，并且可以与任何其他pod通信，不论其他pod是运行在同-个节点上，还是运行在另一个节点上。每个pod都被分配到所需的计算资源，因此这些资源是由一个节点提供还是由另一个节点提供，并没有任何区别。</p>
<p>列出pod时显示podIP和pod的节点</p>
<p>如果仔细观察，可能已经注意到kubectlgetpods命令甚至没有显示任何关于这些pod调度到的节点的信息。这是因为它通常不是pod最重要的信息。</p>
<p>但是可以使用-owide选项请求显示其他列。在列出pod时，该选项显示pod的IP和所运行的节点：</p>
<p>使用kubectldescribe查看pod的其他细节</p>
<p>还可以使用kubectldescribe命令来查看节点，该命令显示了pod的许多其他细节，如下面的代码清单所示。</p>
<p>这展示pod的一些其他信息，pod调度到的节点、启动的时间、pod使用的镜像，以及其他有用的信息。</p>
<h2 id="介绍Kubernetesdashboard"><a href="#介绍Kubernetesdashboard" class="headerlink" title="介绍Kubernetesdashboard"></a>介绍Kubernetesdashboard</h2><p>在结束这个初始实践的章节之前，让我们看看探索Kubemetes集群的另一种方式。</p>
<p>到目前为止，只使用了kubectl命令行工具。如果更喜欢图形化的web用户界面，你会很高兴地听到Kubemetes也提供了-个不错的（但仍在开发迭代的）webdashboard。</p>
<p>dashboard可以列出部署在集群中的所有pod、ReplicationController、服务和其他部署在集群中的对象，以及创建、修改和删除它们，如图2.9所示。</p>
<p>尽管你不会在本书中使用dashboard，在kubectl创建或修改对象之后，还是可以随时打开它，快速查看集群中部署内容的图形化视图。</p>
<p>访问GKE集群的dashboard</p>
<p>如果你正在使用GoogleKubemetesEngine，可以通过kubectlcluster-info命令找到dashboard的URL：</p>
<blockquote>
<p>图2.9 Kubernetesdashboard的页面截图</p>
</blockquote>
<p>如果在浏览器中打开这个URL，将会显示用户名和密码提示符。可以运行以下命令找到用户名和密码：</p>
<p>dashboard的用户名<br>和密码<br>访问Minikube的dashboard<br>要打开使用Minikube的Kubernetes集群的dashboard，请运行以下命令：</p>
<p>dashboard将在默认浏览器中打开。与GKE不同的是，不需要输入任何凭证来访问它。</p>
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p>希望这个初始实践章节已经向你展示了Kubernetes并不是很难上手的复杂平台，希望你已经准备好深入学习关于它的所有知识。读完这一章，你应该知道如何：拉取并且运行任何公开的镜像。</p>
<p>把应用打包成容器镜像，并且推送到远端的公开镜像仓库让大家都可以使用。</p>
<ul>
<li>进入运行中的容器并检查运行环境。</li>
<li>在GKE上创建一个多节点的K8s集群。</li>
<li>为kubectl命令行工具设置别名和tab补全。</li>
<li>在Kubernetes集群中列出查看节点、pod、服务和ReplicationController。</li>
<li>在Kubernetes中运行容器并可以在集群外访问。</li>
<li>了解pod、ReplicationController和服务是关联的基础场景。</li>
<li>通过改变ReplicationController的复本数对应用进行水平伸缩。</li>
<li>在Minikube和GKE中访问基于web的Kubernetesdashboard.</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes-in-Action/" rel="tag"># Kubernetes in Action</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/09/27/40-io包中的接口和工具（上）/" rel="next" title="40 | io包中的接口和工具（上）">
                <i class="fa fa-chevron-left"></i> 40 | io包中的接口和工具（上）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/09/29/3-pod：运行于Kubernetes中的容器/" rel="prev" title="3-pod：运行于Kubernetes中的容器">
                3-pod：运行于Kubernetes中的容器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看书不是为了学习，是为了锻炼意志力</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">896</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/01/27/47｜故障容错：如何在Worker崩溃时进行重新调度？/" title="47｜故障容错：如何在Worker崩溃时进行重新调度？" target="_blank">47｜故障容错：如何在Worker崩溃时进行重新调度？</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/46｜Master任务调度：服务发现与资源管理/" title="46｜Master任务调度：服务发现与资源管理" target="_blank">46｜Master任务调度：服务发现与资源管理</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/45｜Master高可用：怎样借助etcd实现服务选主？/" title="45｜Master高可用：怎样借助etcd实现服务选主？" target="_blank">45｜Master高可用：怎样借助etcd实现服务选主？</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/44｜一个程序多种功能：构建子命令与flags/" title="44｜一个程序多种功能：构建子命令与flags" target="_blank">44｜一个程序多种功能：构建子命令与flags</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/43｜分布式协调：etcd读写、MVCC原理与监听机制/" title="43｜分布式协调：etcd读写、MVCC原理与监听机制" target="_blank">43｜分布式协调：etcd读写、MVCC原理与监听机制</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#创建、运行及共享容器镜像"><span class="nav-number">1.</span> <span class="nav-text">创建、运行及共享容器镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装Docker并运行Hello-World容器"><span class="nav-number">1.1.</span> <span class="nav-text">安装Docker并运行Hello World容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个简单的Node-js应用"><span class="nav-number">1.2.</span> <span class="nav-text">创建一个简单的Node.js应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为镜像创建Dockerfile"><span class="nav-number">1.3.</span> <span class="nav-text">为镜像创建Dockerfile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建容器镜像"><span class="nav-number">1.4.</span> <span class="nav-text">构建容器镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行容器镜像"><span class="nav-number">1.5.</span> <span class="nav-text">运行容器镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#探索运行容器的内部"><span class="nav-number">1.6.</span> <span class="nav-text">探索运行容器的内部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止和删除容器"><span class="nav-number">1.7.</span> <span class="nav-text">停止和删除容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#向镜像仓库推送镜像"><span class="nav-number">1.8.</span> <span class="nav-text">向镜像仓库推送镜像</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#配置Kubernetes集群"><span class="nav-number">2.</span> <span class="nav-text">配置Kubernetes集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用Minikube运行一个本地单节点Kubernetes集群"><span class="nav-number">2.1.</span> <span class="nav-text">用Minikube运行一个本地单节点Kubernetes集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Google-Kubernetes-Engine托管Kubernetes集群"><span class="nav-number">2.2.</span> <span class="nav-text">使用Google Kubernetes Engine托管Kubernetes集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为kubectl配置别名和命令行补齐"><span class="nav-number">2.3.</span> <span class="nav-text">为kubectl配置别名和命令行补齐</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在Kubernetes上运行第一个应用"><span class="nav-number">3.</span> <span class="nav-text">在Kubernetes上运行第一个应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#部署Node-js应用"><span class="nav-number">3.1.</span> <span class="nav-text">部署Node.js应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问Web应用"><span class="nav-number">3.2.</span> <span class="nav-text">访问Web应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统的逻辑部分"><span class="nav-number">3.3.</span> <span class="nav-text">系统的逻辑部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#水平伸缩应用"><span class="nav-number">3.4.</span> <span class="nav-text">水平伸缩应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看应用运行在哪个节点上"><span class="nav-number">3.5.</span> <span class="nav-text">查看应用运行在哪个节点上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍Kubernetesdashboard"><span class="nav-number">3.6.</span> <span class="nav-text">介绍Kubernetesdashboard</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小结"><span class="nav-number">4.</span> <span class="nav-text">本章小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">7.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">114:03</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
