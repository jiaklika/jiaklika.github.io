<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Kubernetes进阶实战">
<meta property="og:type" content="article">
<meta property="og:title" content="第6章 Service和Ingress">
<meta property="og:url" content="http://yoursite.com/2022/10/06/第6章-Service和Ingress/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2022/10/06/第6章-Service和Ingress/1.png">
<meta property="og:image" content="http://yoursite.com/2022/10/06/第6章-Service和Ingress/2.png">
<meta property="og:updated_time" content="2022-10-12T09:32:57.086Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第6章 Service和Ingress">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://yoursite.com/2022/10/06/第6章-Service和Ingress/1.png">






  <link rel="canonical" href="http://yoursite.com/2022/10/06/第6章-Service和Ingress/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第6章 Service和Ingress | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/06/第6章-Service和Ingress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第6章 Service和Ingress

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-10-06 16:19:54" itemprop="dateCreated datePublished" datetime="2022-10-06T16:19:54+08:00">2022-10-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-10-12 17:32:57" itemprop="dateModified" datetime="2022-10-12T17:32:57+08:00">2022-10-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">28k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">26 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>运行于Pod中的部分容器化应用是向客户端提供服务的守护进程，例如，nginx、tomcat和etcd等，它们受控于控制器资源对象，存在生命周期，在自愿或非自愿中断后只能被重构的新Pod对象所取代，属于非可再生类的组件。于是，在动态、弹性的管理模型下，Service资源用于为此类Pod对象提供一个固定、统一的访问接口及负载均衡的能力，并支持借助于新一代DNS系统的服务发现功能，解决客户端发现并访问容器化应用的难题。</p>
<p>然而，Service及Pod对象的IP地址都仅在Kubernetes集群内可达，它们无法接入集群外部的访问流量。解决此类问题的办法中，除了在单一节点上做端口暴露（hostPort）及让Pod资源共享使用工作节点的网络名称空间（hostNetwork）之外，更推荐用户使用的是NodePort或LoadBalancer类型的Service资源，或者是有着七层负载均衡能力的Ingress资源。</p>
<h1 id="Service资源及其实现模型"><a href="#Service资源及其实现模型" class="headerlink" title="Service资源及其实现模型"></a>Service资源及其实现模型</h1><p>Service是Kubernetes的核心资源类型之一，通常可看作微服务的一种实现。事实上它是一种抽象：通过规则定义出由多个Pod对象组合而成的逻辑集合，以及访问这组Pod的策略。Service关联Pod资源的规则要借助于标签选择器来完成，这一点类似于第5章讲到的Pod控制器。</p>
<h2 id="Service资源概述"><a href="#Service资源概述" class="headerlink" title="Service资源概述"></a>Service资源概述</h2><p>由Deployment等控制器管理的Pod对象中断后会由新建的资源对象所取代，而扩缩容后的应用则会带来Pod对象群体的变动，随之变化的还有Pod的IP地址访问接口等，这也是编排系统之上的应用程序必然要面临的问题。例如，当图6-1中的NginxPod作为客户端访问tomcatPod中的应用时，IP的变动或应用规模的缩减会导致客户端访问错误，而Pod规模的扩容又会使得客户端无法有效地使用新增的Pod对象，从而影响达成规模扩展之目的。为此，Kubernetes特地设计了Service资源来解决此类问题。</p>
<blockquote>
<p>图6-1 Pod及其客户端示例</p>
</blockquote>
<img src="/2022/10/06/第6章-Service和Ingress/1.png">
<p>Service资源基于标签选择器将一组Pod定义成一个逻辑组合，并通过自己的IP地址和端口调度代理请求至组内的Pod对象之上，如图6-2所示，它向客户端隐藏了真实的、处理用户请求的Pod资源，使得客户端的请求看上去就像是由Service直接处理并进行响应的一样。</p>
<blockquote>
<p>图6-2 KubernetesService资源模型示意图</p>
</blockquote>
<img src="/2022/10/06/第6章-Service和Ingress/2.png">
<p>Service对象的IP地址也称为ClusterIP，它位于为Kubernetes集群配置指定专用IP地址的范围之内，而且是一种虚拟IP地址，它在Service对象创建后即保持不变，并且能够被同一集群中的Pod资源所访问。Service端口用于接收客户端请求并将其转发至其后端的Pod中应用的相应端口之上，因此，这种代理机制也称为“端口代理”（portproxy）或四层代理，它工作于TCPIP协议栈的传输层。<br>通过其标签选择器匹配到的后端Pod资源不止一个时，Service资源能够以负载均衡的方式进行流量调度，实现了请求流量的分发机制。Service与Pod对象之间的关联关系通过标签选择器以松耦合的方式建立，它可以先于Pod对象创建而不会发生错误，于是，创建Service与Pod资源的任务可由不同的用户分别完成，例如，服务架构的设计和创建由运维工程师进行，而填充其实现的Pod资源的任务则可交由开发者进行。Service、控制器与Pod之间的关系如图6-3所示。<br>Service资源会通过APIServer持续监视着（watch）标签选择器匹配到的后端Pod对</p>
<p>象，并实时跟踪各对象的变动，例如，IP地址变动、对象增加或减少等0不过，需要特别说明的是，Service并不直接链接至Pod对</p>
<p>象，它们之间还有一个中间层<br>Endpoints资源对象，它是一个由IP地址和端口组成的列表，这些IP地址和端口则来自于由Service的标签选择器匹配到的Pod资源。这也是很多场景中会使用“Service的后端端点”（Endpoints）这一术语的原因。默认情况下，创建Service资源对象时，其关联的Endpoints对象会自动创建。<br>6.1.2虚拟IP和服务代理<br>简单来讲，一个Service对象就是工作节点上的一些iptables或ipvs规则，用于将到达Service对象IP地址的流量调度</p>
<p>转发至相应的Endpoints对象指向的IP地址和端口之上。工作于每个工作节点的kube-proxy组件通过APIServer持续监控着各Service及与其关联的Pod对象，并将其创建或变动实时反映至当前工作节点上相应的iptables或ipvs规则上。客户端、Service及其Pod对象的关系如图6-4所示。<br>絷Netfilter是Linux内核中用于管理网络报文的框架，它具有网络地址转换（NAT）、<br>报文改动和报文过滤等防火墙功能，用户借助于用户空间的iptables等工具可按需自由定制规则使用其各项功能。ipvs是借助于Netfilter实现的网络请求报文调度框架，支持rr、wrr、lc、wlc、sh、sed和nq等十余种调度算法，用户空间的命令行工具是ipvsadm，用于管理工作于ipvs之上的调度规则。<br>ServiceIP事实上是用于生成iptables或ipvs规则时使用的IP地址，它仅用于实现Kubernetes集群网络的内部通信，并且仅能够将规则中定义的转发服务的请求作为目标地址予以响应，这也是它被称为虚拟IP的原因之一。kube-proxy将请求代理至相应端点的方式有三种：userspace（用户空间）、iptables和ipvs。<br>1.userspace代理模型<br>此处的userspace是指Linux操作系统的用户空间。这种模型中，kube-proxy负责跟踪APIServer上Service和Endpoints对象的变动（创建或移除），并据此调整Service资源的定义。对于每个Service对象，它会随机打开一个本地端口（运行于用户空间的kube-</p>
<p>proxy进程负责监听），任何到达此代理端口的连接请求都将被代理至当前Service资源后端的各Pod对象上，至于会挑中哪个Pod对象则取决于当前Service资源的调度方式，默认的调度算法是轮询（round-robin），其工作逻辑如图6-5所示。另外，此类的Service对象还会创建iptables规则以捕获任何到达ClusterIP和端口的流量。在Kubernetes1.1版本之前，userspace是默认的代理模型。</p>
<p>图6-5userspace代理模型<br>这种代理模型中，请求流量到达内核空间后经由套接字送往用户空间的kube-proxy，而后再由它送回内核空间，并调度至后端Pod。这种方式中，请求在内核空间和用户空间来回转发必然会导致效率不高。<br>2.iptables代理模型<br>同前一种代理模型类似，iptables代理模型中，kube-proxy负责跟踪APIServer上Service和Endpoints对象的变动（创建或移除），并据此做出Service资源定义的变动。同时，对于每个Service，它都会创建iptables规则直接捕获到达ClusterIP和Port的流量，并将其重定向至当前Service的后端，如图6-6所示。对于每个Endpoints对象，Service资源会为其创建iptables规则并关联至挑选的后端Pod资源，默认算法是随机调度（random）。iptables代理模式由Kubernetes1.1版本引入，并自1.2版开始成为默认的类型。<br>在创建Service资源时，集群中每个节点上的kube-proxy都会收到通知并将其定义为当</p>
<p>前节点上的iptables规则，用于转发工作接口接收到的与此Service资源的ClusterIP和端口的相关流量。客户端发来的请求被相关的iptables规则进行调度和目标地址转换（DNAT）后再转发至集群内的Pod对象之上。<br>相对于用户空间模型来说，iptables模型无须将流量在用户空间和内核空间来回切换，因而更加高效和可靠。不过，其缺点是iptables代理模型不会在被挑中的后端Pod资源无响应时自动进行重定向，而userspace模型</p>
<p>则可以。<br>3.ipvs代理模型<br>Kubernetes自1.9-alpha版本起引入了ipvs代理模型，且自1.11版本起成为默认设置。此种模型中，kube-proxy跟踪APIServer上Service和Endpoints对象的变动，据此来调用netlink接口创建ipvs规则，并确保与APIServer中的变动保持同步，如图6-7所示。它与iptables规则的不同之处仅在于其请求流量的调度功能由ipvs实现，余下的其他功能仍由iptables完成。<br>类似于iptables模型，ipvs构建于类似于iptables模型，ipvs构建于netfilter的钩子函数之上，但它使用hash表作为底层数据结构并工作于内核空间，因此具有流量转发速度快、规则同步性能好的特性。另外，ipvs支持众多调度算法，例如rr、lc、dh、sh、sed和nq等。<br>6.2Service资源的基础应用<br>Service资源本身并不提供任何服务，真正处理并响应客户端请求的是后端的Pod资源，这些Pod资源通常由第5章中介绍的各类控制器对象所创建和管理，因此Service资源通常要与控制器资源（最为常用的控制器之一是Deployment）协同使用以完成应用的创建和对外发布。<br>6.2.1创建Service资源<br>创建Service对象的常用方法有两种：一是直接使用“kubectlexpose”命令，这在前面第3章中已经介绍付方式；另一个是使用资源配置文件，它与此前使用资源清单文件配置其他资源的方法类似。定义Service资源对象时，spec的两个较为常用的内嵌字段分别为selector和ports，分别用于定义使用的标签选择器和要暴露的端口。下面的配置清单是一个Service 资源示例：<br>kind: Service<br>apiversion: v1<br>metadata:<br>name: myapp-svc<br>spec:<br>selector:<br>app: myapp<br>ports:</p>
<ul>
<li>protocol: TCP<br>port:80<br>targetPort:80<br>Service 资源 myapp-svc 通过标签选择器关联至标签为 “ app=myapp”的各Pod对象， 它会自动创建名为 myapp-svc 的 Endpoints 资源对象，并自动配置一个 ClusterIP，暴露的端口由 port 字段进行指定， 后端各 Pod 对象的端口则由 targetPort 给出， 也可以使用同 port 字段的默认值。myapp-svc 创建完成后， 使用下面的命令即能获取相关的信息输出以了解资源的状态：<br>~]$ kubectl get svc myapp-svc<br>NAME<br>TYPE<br>CLUSTER-IP<br>EXTERNAL-IP<br>PORT(S)<br>AGE<br>myapp-svc ClusterIP 10.107.208.93<br><none><br>80/TCP<br>56s<br>上面命令中的结果显示，myapp-svc 的类型为默认的 ClusterIP， 其使用的地址自动配置为 10.107.208.93。此类型的 Service 对象仅能通过此 IP 地址接受来自于集群内的客户端 Pod中的请求。若集群上存在标签为“app=myapp” 的 Pod 资源，则它们会被关联和创建，作 为此 Service 对象的后端 Endpoint 对象， 并负责接收相应的请求流量。 类似下面的命令可用于获取 Endpoint 资源的端点列表， 其相关的端点是由第 5 章中的 Deployment 控制器创建的Pod 对象的套接字信息组成的：<br>~]$ kubectl get endpoints myapp-svc<br>NAME<br>ENDPOINTS<br>AGE<br>myapp-svc<br>10.244.1109:80,10.244.2.249:80,10.244.3.93:80<br>2m<br>也可以不为 Service 资源指定 spec.selector属性值， 其关联的 Pod 资源可由用户手动创建 Endpoints 资源进行定义。<br>Service 对象创建完成后即可作为服务被各客户端访问， 但要真正响应这些请求，还是要依赖于各后端的资源对象。<br>6.2.2 向Service 对象请求服务<br>Service 资源的默认类型为 ClusterIP， 它仅能接收来自于集群中的 Pod 对象中的客户端</none></li>
</ul>
<p>程序的访问请求。下面创建一个专用的 Pod 对象， 利用其交互式接口完成访问测试。为了简单起见， 这里选择直接创建一个临时使用的 Pod 对象作为交互式使用的客户端进行，它使用 CirrOS 镜像，默认的命令提示符为 “/#”：<br>~]$ kubectl run cirros-$RANDOM —rm -it —image=cirros — sh<br>/#<br>農 CirrOS 是设计用来进行云计算环境测试的 Linux 微型发行版，它拥有 HTTP 客户端  工具curl等。<br>而后，在容器的交互式接口中使用 crul命令对 myapp-svc 服务的 ClusterIP（10.107. 208.93）和 Port（80/tcp）发起访问请求测试：<br>/#curl<a href="http://10.107.208.93:80/" target="_blank" rel="noopener">http://10.107.208.93:80/</a><br>Hello MyApp | Version: v1 | <a href="hostname.html">Pod Name</a><br>myapp 容器中的“/hostname.html” 页面能够输出当前容器的主机名，可反复向 myapp- svc的此URL 路径发起多次请求以验证其调度的效果：<br>/#forloopin1234;docurl<a href="http://10.107.208.93:80/hostname.html;done" target="_blank" rel="noopener">http://10.107.208.93:80/hostname.html;done</a> deploy-myapp-86b4b8c75d-rbhf1<br>deploy-myapp-86b4b8c75d-mhbkd<br>deploy-myapp-86b4b8c75d-xk8qb<br>当前 Kubernetes 集群的 Service 代理模式为 iptables，它默认使用随机调度算法， 因此 Service 会将客户端请求随机调度至与其关联的某个后端 Pod 资源上。 命令取样次数越大， 其调度效果也越接近于算法的目标效果。<br>6.2.3 Service会话粘性<br>Service 资源还支持 Session affinity （粘性会话或会话粘性）机制， 它能够将来自同一个客户端的请求始终转发至同一个后端的 Pod 对象， 这意味着它会影响调度算法的流量分发功用，进而降低其负载均衡的效果。因此， 当客户端访问 Pod 中的应用程序时， 如果有基于客户端身份保存某些私有信息， 并基于这些私有信息追踪用户的活动等一类的需求时，那么应该启用 session affinity 机制。<br>Session affinity 的效果仅会在一定时间期限内生效， 默认值为 10 800 秒，超出此时长之后， 客户端的再次访问会被调度算法重新调度。 另外，Service 资源的 Session affinity 机制仅能基于客户端 IP 地址识别客户端身份， 它会把经由同一个 NAT 服务器进行源地址转换 的所有客户端识别为同一个客户端， 调度粒度粗糙且效果不佳，因此， 实践中并不推荐使用此种方法实现粘性会话。 此节仅用于为读者介绍其功能及实现。<br>Service 资源通过 .spec.sessionAffinity 和 spec.sessionAffinityConfig 两个字段配置粘性</p>
<p>会话。spec.sessionAffinity 字段用于定义要使用的粘性会话的类型，它仅支持使用“ None”和“ClientIP”两种属性值。<br>口None：不使用sessionAffinity，默认值。<br>口ClientIP ：基于客户端IP地址识别客户端身份，把来自同一个源IP地址的请求始终调度至同一个Pod对象。<br>在启用粘性会话机制时，.spec.sessionAffinityConfig 用于配置其会话保持的时长，它是个嵌套字段，使用格式如下所示，其可用的时长范围为“1 ~ 86400”， 默认为10 800秒：spec:<br>sessior<br>SessionAffinity: C1ientIP<br>sessionA£finityConfig:<br>clientIP:M<br>t imeoutSeconds: <integer><br>例如，基于默认的10800秒的超时时长，使用下面的命令修改此前的myapp-sve使用Session affinity机制：<br>~]$ kubect1 patch services myapp-svc -口’{“spec”： {“sessionAffinity”： “ClientIP”}}’ service “ pp-svc” patched<br>而后再次于交互式客户端内测试其访问效果即可验证其会话粘性效果。<br>/#forloopin1234;docurl<a href="http://10.107.208.93:80/hostname.html;done" target="_blank" rel="noopener">http://10.107.208.93:80/hostname.html;done</a> deploy- myapp- 86b4b8c75d-rbhfl<br>depl oy -myapp- 86b4b8c75d-rbhfl<br>deploy -myapp- 86b4b8c75d- rbhfl<br>测试完成后，为了保证本章后续的其他使用效果测试不受其影响，建议将其关闭。当然，用户也可以使用“ kubectl edit”命令直接编辑活动Service对象的配置清单。<br>6.3服务发现<br>微服务意味着存在更多的独立服务，但它们并非独立的个体，而是存在着复杂的依赖关系且彼此之间通常需要进行非常频繁地交互和通信的群体。然而，建立通信之前，服务和服务之间该如何获知彼此的地址呢？在Kubernetes系统上，Service为Pod中的服务类应用提供了一个稳定的访问人口，但Pod客户端中的应用如何得知某个特定Service资源的IP和端口呢？这个时候就需要引入服务发现（Service Discovery）的机制。<br>6.3.1服务发现概述<br>简单来说，服务发现就是服务或者应用之间互相定位的过程。不过，服务发现并非新概念，传统的单体应用架构时代也会用到，只不过单体应用的动态性不强，更新和重新发布的频度较低，通常以月甚至以年计，基本上不会进行自动伸缩，因此服务发现的概念无须显</integer></p>
<p>性强调。 在传统的单体应用网络位置发生变化时 ，由IT 运维人员手工更新一下相关的配置文件基本上就能解决问题。 但在微服务应用场景中， 应用被拆分成众多的小服务，它们按需创建且变动频繁， 配置信息基本无法事先写入配置文件中并及时跟踪和反映动态变化，因此服务发现的重要性便随之凸显。<br>服务发现机制的基本实现， 一般是事先部署好一个网络位置较为稳定的服务注册中心（也称为服务总线），服务提供者 （服务端） 向注册中心注册自己的位置信息， 并在变动后及时予以更新，相应地， 服务消费者则周期性地从注册中心获取服务提供者的最新位置信息从而“发现”要访问的目标服务资源。 复杂的服务发现机制还能够让服务提供者提供其描述信息、状态信息及资源使用信息等， 以供消费者实现更为复杂的服务选择逻辑。<br>实践中，根据服务发现过程的实现方式， 服务发现还可分为两种类型： 客户端发现和服务端发现。<br>口客户端发现：由客户端到服务注册中心发现其依赖到的服务的相关信息 ，因此，它需要内置特定的服务发现程序和发现逻辑。<br>口服务端发现： 这种方式需要额外用到一个称为中央路由器或服务均衡器的组件；服务消费者将请求发往 中央路由器或者负载均衡器， 由它们负责查询服务注册中心获取服务提供者的位置信息， 并将服务消费者的请求转发给服务提供者。<br>由此可见，服务注册中心是服务发现得以落地的核心组件。事实上， DNS 可以算是最为原始的服务发现系统之一，不过， 在服务的动态性很强的场景中，DNS 记录的传播速度可能会跟不上服务的变更速度， 因此它并不适用于微服务环境。另外， 传统实践中，常见的服务注册中心是 ZooKeeper和 etcd 等分布式键值存储系统，不过， 它们只能提供基本的数据存储功能， 距离实现完整的服务发现机制还有大量的二次开发任务需要完成。另外，它们更注重数据的一致性，这 与有着更高的服务可用性要求的微服务发现场景中的需求不太相符。<br>Netflix的Eureka 是目前较为流行的服务发现系统之一， 它是专门开发用来实现服务发现的系统，以可用性目的为先，可以在多种故障期间保持服务发现和服务注册的功能可用，其设计原则遵从“存在少量的错误数据， 总比完全不可用要好”。 另一个同级别的实现是 Consul，它是由 HashiCorp 公司提供的商业产品 ，不过该公司还提供了一个开源基础版本。  它于服务发现的基础功能之外还提供了多数据中 心的部署能力等一众出色的特性。<br>尽管传统的 DNS 系统不适于微服务环境中的服务发现， 但 SkyDNS 项目（后来称 kubedns）却是一个有趣的实现， 它结合了古老的 DNS 技术和时髦的 Go 语言 Raft算法，并构建于 etcd 存储系统之上，为 Kubernetes 系统实现了一种服务发现机制。Service 资源为 Kubernetes 提供了一个较为稳定的抽象层， 这有点类似于服务端发现的方式， 于是也就不存在 DNS 服务的时间窗口的问题。<br>Kubernetes 自 1.3 版本开始，其用于服务发现的 DNS 更新为了 kubeDNS，而类似的另  一个基于较新的 DNS 的服务发现项目是由 CNCF（Cloud Native Computing Foundation） 孵</p>
<p>化的CoreDNS，它基于Go语言开发，通过串接一组实现DNS功能的插件的插件链进行工作。自Kubernetes 1.11版本起，CoreDNS取代kubeDNS成为默认的DNS附件。不过，Kubernetes依然支持使用环境变量进行服务发现。<br>6.3.2服务发现方式：环境变量<br>创建Pod资源时，kubelet会将其所属名称空间内的每个活动的Service对象以一系列环境变量的形式注人其中。它支持使用Kubernetes Service环境变量以及与Docker的links兼容的变量。<br>（1） Kubernetes Service环境变量<br>Kubernetes为每个Service资源生成包括以下形式的环境变量在内的一系列环境变量， 在同一名称空间中创建的Pod对象都会自动拥有这些变量。<br>O {SVCNAME} _SERVICE HOST<br>O {SVCNAME} SERVICE PORT<br>注意如果SVCNAME中使用了连接线，那么Kubernetes会在定义为环境变量时将其转换为下划线。<br>（2） Docker Link形式的环境变量<br>Docker使用—link选项实现容器连接时所设置的环境变量形式，具体使用方式请参考Docker的相关文档。在创建Pod对象时，Kubernetes也会将与此形式兼容的一系列环境变量注人Pod对象中。<br>例如，在Service资源myapp-svc创建后创建的Pod对象中查看可用的环境变量，其中以MYAPP_SVC_SERVICE开头的表示Kubernetes Service环境变量，名称中不包含“SERVICE”字符串的环境变量为Docker Link形式的环境变量：<br>/# printenv I grep MYAPP<br>MYAPP_SVC_PORT_80_TCP_ADDR=10.107.208.93<br>MYAPP<strong>SVC_PORT</strong>80_TCP_PORT=80<br>MYAPP<strong>SVC</strong>PORT<strong>80</strong>TCP<strong>PROTO=tcp<br>MYAPP_SVC_PORT</strong>80_TCP=tcp://10.107.208.93:80<br>MYAPP_SVC_SERVICE_HOST=10.107.208.93<br>MYAPP_SVC_SERVICE_PORT=80<br>MYAPP_SVC_PORT=tcp://10.107.208.93:80<br>基于环境变量的服务发现其功能简单、易用，但存在一定的局限，例如，仅有那些与创建的Pod对象在同一名称空间中且事先存在的Service对象的信息才会以环境变量的形式注人，那些处于非同一名称空间，或者是在Pod资源创建之后才创建的Service对象的相关环境变量则不会被添加。幸而，基于DNS的发现机制并不存在此类限制。</p>
<p>6.3.3 ClusterDNS 和服务发现<br>Kubernetes 系统之上用于名称解析和服务发现的 ClusterDNS 是集群的核心附件之一， 集群中创建的每个 Service 对象， 都会由其自动生成相关的资源记录。 默认情况下，集群内各 Pod 资源会自动配置其作为名称解析服务器 ，并在其 DNS 搜索列表中包含它所属名称空 间的域名后缀。<br>无论是使用 kubeDNS 还是 CoreDNS， 它们提供的基于 DNS 的服务发现解决方案都会负责解析以下资源记录（Resource Record） 类型以实现服务发现。<br>（1）拥有 ClusterIP 的 Service 资源， 需要具有以下类型的资源记录。<br>A 记录： <service>.<ns>.svc.<zone>. <ttl> IN A <cluster-ip><br>口 SRV 记录： _<port>._<proto>.<service>.<ns>. svc.<zone>. <ttl> IN SRV <weight> <priority> <port-number> <service>.<ns>.svc.<zone><br>口 PTR 记录： <d>.<c>.<b>.<a>.in-addr.arpa. <ttl> IN PTR <service>.<ns>.svc.<zone> （2）Headless 类型的 Service 资源， 需要具有以下类型的资源记录。<br>口A 记录： <service>.<ns>.svc.<zone>.<ttl> IN A<endpoint-ip><br>口 SRV 记录： _<port>.<proto>.<sservice>.<ns>. svc.<zone>. <ttl> IN SRV <weight> <priority> <port-number> <hostname>.<service>.<ns>.svc.<zone><br>口 PTR 记录：<d>.<c>.<b>.<a>.in-addr.arpa. <ttl> IN PTR <hostname>.<service>.<ns>.svc.<zone> （3）ExternalName 类型的 Service 资源， 需要具有CNAME 类型的资源记录。<br>口CNAME 记录： <service>.<ns>.svc.<zone>. <ttl> IN CNAME <extname><br>名称解析和服务发现是 Kubernetes 系统许多功能得以实现的基础服务， 它通常是集群安装完成后应该立即部署的附加组件。使用 kubeadm 初始化一个集群时， 它甚至会自动进行部署。<br>6.3.4 服务发现方式：DNS<br>创建 Service 资源对象时，ClusterDNS 会为它自动创建资源记录用于名称解析和服务注册，于是，Pod 资源可直接使用标准的 DNS名称来访问这些 Service 资源。每个 Service对象相关的 DNS 记录包含如下两个。<br>[SVCNAME}. {NAMESPACE}.{CLUSTER_DOMAIN}<br>{SVCNAME}.{NAMESPACE} svc.{CLUSTER_DOMAIN}<br>另外，在前面第 2 章的部署参数中， “—cluster-dns”指定了集群 DNS 服务的工作地址， “ —cluster-domain” 定义了集群使用的本地域名，因此， 系统初始化时默认会将“cluster. local.”和主机所在的域“ilinux.io.” 作为 DNS 的本地域使用，这些信息会在 Pod 创建时以 DNS 配置的相关信息注入它的 /etc/resolv.conf 配置文件中。例如， 在此前创建的用于交互式 Pod 资源的客户端中查看其配置，命令如下：<br>/ # cat /etc/resolv.conf</extname></ttl></zone></ns></service></zone></ns></service></hostname></ttl></a></b></c></d></zone></ns></service></hostname></port-number></priority></weight></ttl></zone></ns></sservice></proto></port></endpoint-ip></ttl></zone></ns></service></zone></ns></service></ttl></a></b></c></d></zone></ns></service></port-number></priority></weight></ttl></zone></ns></service></proto></port></cluster-ip></ttl></zone></ns></service></p>
<p>nameserver 10.96.0.10<br>search default.svc.cluster.local svc.cluster.local cluster.local ilinux.io<br>上述search参数中指定的DNS各搜索域，是以次序指定的几个域名后缀，具体如下所示。D{NAMESPACE}.svC.{CLUSTER DOMAIN}：如default.svc.cluster.local。<br>O svc.{CLUSTER DOMAIN}：如svc.cluster.local。<br>O{CLUSTER DOMAIN}：如cluster.local.<br>D {WORK_ NODE DOMAIN}：如ilinux.io。<br>例如，在此前创建的用于交互式Pod客户端中尝试请求解析myapp-svc的相关DNS记录：/# nslookup myapp-svc.default<br>Server:<br>10.96.0.10<br>Address1:10.96.0.10kube-dns.kube-system.svc.cluster.local<br>Name:<br>myapp-svc<br>Address 1:10.107.208.93myapp-svc.default.svc.cluster.local<br>解析时，“myapp-svc”服务名称的搜索次序依次是default.svc.cluster.local、svc.cluster.local、 cluster.local和ilinux.io，因此基于DNS的服务发现不受Service资源所在的名称空间和创建时间的限制。上面的解析结果也正是默认的default名称空间中创建的myapp-svc服务的IP地址。<br>6.4服务暴露<br>Service的IP地址仅在集群内可达，然而，总会有些服务需要暴露到外部网络中接受各类客户端的访问，例如分层架构应用中的前端Web应用程序等。此时，就需要在集群的边缘为其添加一层转发机制，以实现将外部请求流量接人到集群的Service资源之上，这种操作也称为发布服务到外部网络中。<br>6.4.1 Service类型<br>Kubernetes的Service共有四种类型：ClusterIP、NodePort、LoadBalancer和ExternalName。D ClusterIP：通过集群内部IP地址暴露服务，此地址仅在集群内部可达，而无法被集群外部的客户端访问，如图6-8所示。此为默认的Service类型。<br>O NodePort：这种类型建立在ClusterIP类型之上，其在每个节点的IP地址的某静态端口（NodePort）暴露服务，因此，它依然会为Service分配集群IP地址，并将此作为NodePort的路由目标。简单来说，NodePort类型就是在工作节点的IP地址上选择一个端口用于将集群外部的用户请求转发至目标Service的ClusterIP和Port，因此，这种类型的Service既可如ClusterIP一样受到集群内部客户端Pod的访问，也会受到集群外部客户端通过套接字<nodelp>：<nodeport>进行的请求。</nodeport></nodelp></p>
<p>图6-8NodePort Service类型<br>O LoadBalancer：这种类型建构在NodePort类型之上，其通过cloud provider提供的负载均衡器将服务暴露到集群外部，因此LoadBalancer一样具有NodePort和ClusterIP。简而言之，一个LoadBalancer类型的Service会指向关联至Kubernetes集群外部的、切实存在的某个负载均衡设备，该设备通过工作节点之上的NodePort向集群内部发送请求流量，如图6-9所示。例如Amazon云计算环境中的ELB实例即为此类的负载均衡设备。此类型的优势在于，它能够把来自于集群外部客户端的请求调度至所有节点（或部分节点）的NodePort之上，而不是依赖于客户端自行决定连接至哪个节点，从而避免了因客户端指定的节点故障而导致的服务不可用。<br>O ExternalName：其通过将Service映射至由externalName字段的内容指定的主机名来暴露服务，此主机名需要被DNS服务解析至CNAME类型的记录。换言之，此种类型并非定义由Kubernetes集群提供的服务，而是把集群外部的某服务以DNS CNAME记录的方式映射到集群内，从而让集群内的Pod资源能够访问外部的Service的一种实现方式，如图6-10所示。因此，这种类型的Service没有ClusterIP和NodePort，也没有标签选择器用于选择Pod资源，因此也不会有Endpoints存在。<br>前面章节中创建的myapp-svc即为默认的ClusterIP类型Service资源，它仅能接收来自于集群中的Pod对象中的客户端程序的访问请求。如若需要将Service资源发布至网络外部，应该将其配置为NodePort或LoadBalancer类型，而若要把外部的服务发布于集群内容供Pod对象使用，则需要定义一个ExternalName类型的Service资源。如若使用kube-dns，那么这种类型的实现将依赖于1.7及其以上版本的Kubernetes版本。</p>
<p>图6-10 ExternalName 类型的Service<br>6.4.2 NodePort 类型的Service资源<br>NodePort即节点Port，通常在安装部署Kubernetes集群系统时会预留一个端口范围用于NodePort，默认为30000 ~ 32767之间的端口。与ClusterIP类型的可省略.spec.type属性所不同的是，定义NodePort类型的Service资源时，需要通过此属性明确指定其类型名称。例如，下面配置清单中定义的Service资源对象myapp-svc-nodeport，它使用了</p>
<p>NodePort类型，且人为指定其节点端口为32223：<br>kind: Service<br>apiVersion:v1<br>metadata:<br>name: myapp-svc-nodeport spec:<br>type:NodePort<br>selector:<br>app:myapp<br>ports:<br>-protocol: TCP<br>port:80<br>targetPort:80<br>nodePort:32223<br>实践中，并不鼓励用户自定义使用的节点端口，除非事先能够明确知道它不会与某个现存的Service资源产生冲突。无论如何，只要没有特别需求，留给系统自动配置总是较好的选择。使用创建命令创建上面的Service对象后即可了解其运行状态：<br>~]$ kubectl get services myapp-svc-nodeport<br>NAME<br>TYPE<br>CLUSTER-IPEXTERNAL-IP<br>PORT(S)<br>AGE<br>myapp-svc-nodeport NodePort 10.109.234.108<none><br>80:32223/TCP<br>3s<br>命令结果显示，NodePort类型的Service资源依然会被配置ClusterIP，事实上，它会作为节点从NodePort接入流量后转发的目标地址，目标端口则是与Service资源对应的spec.ports.port属性中定义的端口，如图6-11所示。</none></p>
<p>图6-11请求 流量转发过程<br>因此，对于集群外部的客户端来说，它们可经由任何一个节点的节点IP及端口访问 NodePort类型的Service资源，而对于集群内的Pod客户端来说，依然可以通过ClusterIP 对其进行访问。<br>6.4.3 LoadBalancer类型的Service资源<br>NodePort类型的Service资源虽然能够于集群外部访问得到，但外部客户端必须得事先得知NodePort和集群中至少一个节点的IP地址，且选定的节点发生故障时，客户端还得自行选择请求访问其他的节点。另外，集群节点很可能是某laaS云环境中使用私有IP地址的</p>
<p>VM，或者是IDC中使用私有地址的物理机，这类地址对互联网客户端不可达，因此，一般还应该在集群之外创建一个具有公网IP地址的负载均衡器，由它接人外部客户端的请求并调度至集群节点相应的NodePort之上。<br>IlaaS云计算环境通常提供了LBaaS （Load Balancer as a Service）服务，它允许租户动态地在自己的网络中创建一个负载均衡设备。那些部署于此类环境之上的Kubernetes集群在创建Service资源时可以直接调用此接口按需创建出一个软负载均衡器，而具有这种功能的 Service资源即为LoadBalancer类型。不过，如果Kubernetes部署于裸的物理服务器之上，系统管理员也可以自行手动部署一个负载均衡器（推荐使用冗余配置），并配置其将请求流量调度至各节点的NodePort之上即可。<br>下面是一个LoadBalancer类型的Service资源配置清单，若Kubernetes系统满足其使用条件，即可自行进行应用测试。需要注意的是，有些环境中可能还需要为Service资源的配置定义添加Annotations，必要时请自行参考Kubernetes文档中的说明：</p>
<p>进一步地，在 IaaS 环境支持手动指定 IP 地址时，用户还可以使用 spec.loadBalancerIP指定创建的负载均衡器使用的 IP 地址， 并可使用.spec. loadBalancerSourceRanges 指定负载均衡器允许的客户端来源的地址范围。<br>6.4.4 ExternalName Service<br>ExternalName 类型的 Service 资源用于将集群外部的服务发布到集群中以供 Pod 中的应用程序访问，因此， 它不需要使用标签选择器关联任何的 Pod 对象， 但必须要使用spec.externalName 属性定义一个 CNAME 记录用于返回外部真正提供服务的主机的别名，而后通过 CNAME 记录值获取到相关主机的 IP 地址。<br>下面是一个 ExternalName 类型的 Service 资源示例，名为 external-redis-svc， 相应的externalName 为“redis.ilinux.io”：</p>
<p>待 Service 资源 external-redis-svc 创建完成后 ，各 Pod 对象即可通过 external-redis-svc 或 其 FQDN 格式的名称 external-redis-svc.default. svc.cluster.local 访问相应的服务。 ClusterDNS会将此名称以 CNAME 格式解析为 spec.externalName 字段中的名称，而后通过 DNS服务将其解析为相应的主机的 IP地址。例如， 通过此前创建的交互 Pod 资源客户端进行服务名称解析：<br>/ # nslookup external-redis-svc<br>Server: 10.96.0.10<br>Address 1:10.96.0.10 kube-dns.kube-system.svc.cluster.local<br>Name:<br>external-redis-svc<br>Address 1: 45.54.44.100 100.44.54.45.ptr.anycast.net<br>由于ExternalName 类型的 Service 资源实现于 DNS 级别，客户端将直接接人外部的服 务而完全不需要服务代理，因此， 它也无须配置 ClusterIP， 此种类型的服务也称为HeadlessService。<br>6.5 Headless 类型的 Service 资源<br>Service 对象隐藏了各Pod 资源， 并负责将客户端的请求流量调度至该组 Pod 对象之上。不过，偶尔也会存在这样一类需求： 客户端需要直接访问 Service 资源后端的所有 Pod资源， 这时就应该向客户端暴露每个 Pod 资源的 IP地址，而不再是中间层 Service 对象的ClusterIP，这种类型的 Service） 资源便称为Headless Service。<br>Headless Service 对象没有 ClusterIP，于是 kube-proxy 便无须处理此类请求，也就更 没有了负载均衡或代理它的需要。 在前端应用拥有自有的其他服务发现机制时，HeadlessService 即可省去定义 ClusterIP 的需求。 至于如何为此类 Service 资源配置 IP 地址， 则取决于它的标签选择器的定义。<br>口具有标签选择器：端点控制器（Endpoints Controller） 会在 API 中为其创建 Endpoints </p>
<p>记录，并将ClusterDNS服务中的A记录直接解析到此Service后端的各Pod对象的IP地址上。<br>口没有标签选择器：端点控制器（ Endpoints Controller） 不会在API中为其创建Endpoints记录，ClusterDNS 的配置分为两种情形，对ExternalName类型的服务创建CNAME记录，对其他三种类型来说，为那些与当前Service共享名称的所有Endpoints 对象创建一条记录。<br>6.5.1创建 Headless Service资源<br>配置Service资源配置清单时，只需要将ClusterIP字段的值设置为“None”即可将其定义为Headless类型。下面是一个Headless Service 资源配置清单示例，它拥有标签选择器：<br>kind: Service<br>apiVersion: v1<br>metadata:<br>name: myapp- headless-svc<br>Deci<br>clusterIP: None<br>selector:<br>app: myapp<br>pOrts:<br>port: 80<br>targetPort: 80<br>name: httpport<br>使用资源创建命令“kubectl create”或“kubectl apply”完成资源创建后，使用相关的查看命令获取Service资源的相关信息便可以看出，它没有ClusterIP，不过，如果标签选择器能够匹配到相关的Pod资源，它便拥有Endpoints记录，这些Endpoints对象会作为DNS资源记录名称myapp-headless-svc查询时的A记录解析结果：<br>~]$ kubectl describe svc myapp-headless-svc<br>…..<br>Endpoints:<br>10.244.1.113:80, 10.244.2.13:80, 10.244.3.104:80<br>6.5.2 Pod 资源发现<br>根据Headless Service的工作特性可知，它记录于ClusterDNS的A记录的相关解析结果是后端Pod资源的IP地址，这就意味着客户端通过此Service资源的名称发现的是各Pod资源。下面依然选择创建一 个专用的测试Pod对象，而后通过其交互式接口进行测试：<br>~]$ kubectl run cirros-$RANDOM —rm -it — image=cirros — sh </p>
<p>规则的集合，这些规则要想真正发挥作用还需要其他功能的辅助，如监听某套接字，然后根据这些规则的匹配机制路由请求流量。这种能够为Ingress资源监听套接字并转发流量的组件称为Ingress控制器（Ingress Controller）。<br>裱不同于Deployment控制器等，Ingress控制器并不直接运行为kube-controller-manager<br>的一部分，它是Kubernetes集群的一个重要附件，类似于CoreDNS，需要在集群上单独部署。<br>Ingress控制器可以由任何具有反向代理（HTTP/HTTPS）功能的服务程序实现，如Nginx、Envoy、HAProxy、 Vulcand和Traefik等。Ingress控制器自身也是运行于集群中的Pod资源对象，它与被代理的运行为Pod资源的应用运行于同一网络中，如图6-12中ingress-nginx与pod1、pod3等的关系所示。</p>
<p>图6-12Ingress 与Ingress Controller<br>另一方面，使用Ingress资源进行流量分发时，Ingress控制器可基于某Ingress资源定义的规则将客户端的请求流量直接转发至与Service对应的后端Pod资源之上，这种转发机制会绕过Service资源，从而省去了由kube-proxy实现的端口代理开销。如图6-12所示， Ingress规则需要由一个Service资源对象辅助识别相关的所有Pod对象，但ingress-nginx控制器可经由api.ilinux.io规则的定义直接将请求流量调度至pod3或pod4，而无须经由Service对象API的再次转发，WAP相关规则的作用方式与此类同。<br>6.6.2创建Ingress资源<br>Ingress资源是基于HTTP虚拟主机或URL的转发规则，它在资源配置清单的spec字段中嵌套了rules、backend和tls等字段进行定义。下面的示例中定义了一个Ingress资源，它包含了一个转发规则，把发往www.ilinux.io的请求代理给名为myapp-svc的Service资源：</p>
<p>上面资源清单中的 annotations 用于识别其所属的 Ingress 控制器的类别， 这一点在集群上部署有多个 Ingress 控制器时尤为重要。 Ingress Spec 中的字段是定义 Ingress 资源的核心组成部分，它主要嵌套如下三个字段。<br>口rules <object>：用于定义当前 Ingress 资源的转发规则列表； 未由 rules 定义规则，或者没有匹配到任何规则时， 所有流量都会转发到由 backend 定义的默认后端。<br>D backend <object>： 默认的后端用于服务那些没有匹配到任何规则的请求；定义 Ingress 资源时，至少应该定义 backend或 rules 两者之一； 此字段用于让负载均衡器  指定一个全局默认的后端。<br>口tls <object>：TLS 配置， 目前仅支持通过默认端口 443 提供服务； 如果要配置指定的列表成员指向了不同的主机，则必须通过 SNI TLS 扩展机制来支持此功能。<br>backend 对象的定义由两个必选的内嵌字段组成：serviceName 和 servicePort， 分别用于指定流量转发的后端目标 Service 资源的名称和端口。<br>rules 对象由一系列配置 Ingress 资源的 host 规则组成，这些host 规则用于将一个主机上的某个URL 路径映射至相关的后端 Service对象，它的定义格式如下：<br>spec:<br>rules:</object></object></object></p>
<ul>
<li>host: <string><br>http:<br>paths:<br>backend:<br>serviceName: <string> servicePort: <string> path: <string><br>注意，.spec.rules.host 属性值目前不支持使用 IP 地址， 也不支持后跟“：PORT”格式的端口号， 且此字段值留空表示通配所有的主机名。<br>tls 对象由两个内嵌字段组成，仅在定义 TLS 主机的转发规则时才需要定义此类对象。</string></string></string></string></li>
</ul>
<p>口hosts：包含于使用的 TLS 证书之内的主机名称字符串列表，因此， 此处使用的主机名必须匹配 tlsSecret中的名称。<br>SecretName：用于引用 SSL会话的 secret对象名称， 在基于SNI实现多主机路由的场景中，此字段为可选。<br>6.6.3 Ingress 资源类型<br>基于 HTTP 暴露的每个 Service 资源均可发布于一个独立的 FQDN主机名之上，如 “www.ik8s.io”；也可发布于某主机的 URL 路径之上， 从而将它们整合到同一个Web 站点，如“www.ik8s.io/grafana”。 至于是否需要发布为 HTTPS类型的应用则取决于用户的业务需求。</p>
<ol>
<li>单 Service 资源型 Ingress<br>暴露单个服务的方法有很多种， 如服务类型中的 NodePort、LoadBalancer 等， 不过一样可以考虑使用 Ingress 来暴露服务， 此时只需要为Ingress 指定“default backend”即可。例如下面的示例：<br>apiVersion: extensions/v1beta1  kind: Ingress<br>metadata:<br>name: my-ingress<br>spec:<br>backend:<br>serviceName: my-svc<br>servicePort:80<br>Ingress 控制器会为其分配一个 IP 地址接入请求流量，并将它们转至示例中的 my-svc 后端。</li>
<li>基于URL 路径进行流量分发<br>垂直拆分或微服务架构中， 每个小的应用都有其专用的 Service 资源暴露服务，但在对外开放的站点上，它们可能是财经、新闻、 电商、无线端或 API 接口等一类的独立应用， 可通过主域名的URL路径（path）分别接入， 例如，www.ilinux.io/api、www.ilinux.io/wap 等，用于发布集群内名称为 API 和 WAP 的Services 资源。于是，可对应地创建一个如下 的 Ingress 资源，它将对 www.ilinux.io/api 的请求统统转发至API Service 资源，将对 www.ilinux.io/wap 的请求转发至 WAP Service 资源：<br>apiVersion: extensions/v1beta1 kind: Ingress<br>metadata:<br>name: test<br>annotations:</li>
</ol>
<p>洁目前，ingress-nginx似乎尚且不能很好地支持基于annotations进行URL映射。这就<br>意味着，在ingress-nginx上，此项功能尚且不能使用。具体信息请参考这个链接中的讨论，ttps://github.com/istio/istio/issues/585.<br>3.基于主机名称的虚拟主机<br>.上面类型2中描述的需求，也可以将每个应用分别以独立的FQDN主机名进行输出，如wap.ik8s.io和api.ik8s.io，这两个主机名解析到external LB （如图6-12所示）的IP地址之上，分别用于发布集群内部的WAP和API这两个Service资源。这种实现方案其实就是Web站点部署中的“基于主机名的虚拟主机”，将多个FQDN解析至同一个IP地址，然后根据“主机头”（ Host header）进行转发。下面是以独立FQDN主机形式发布服务的Ingress资源示例：</p>
<ol>
<li>TLS类型的Ingress资源<br>这种类型用于以HTTPS发布Service资源，基于一个含有私钥和证书的Secret对象（后面章节中会详细讲述）即可配置TLS协议的Ingress资源，目前来说，Ingress资源仅支持单TLS端口，并且还会卸载TLS会话。在Ingress资源中引用此Secret即可让Ingress控制器加载并配置为HTTPS服务。<br>下面是一个简单的TLS类型的Ingress资源示例：<br>apiversion: extens ions/v1betal<br>kind: Ingress<br>metadata:<br>男name： no-rules-map<br>TaIe<br>spec:<br>tls:</li>
</ol>
<ul>
<li>secretName: ikubernetesSecret<br>backend:<br>serviceName: homesite<br>servicePort: 80<br>6.6.4部署 Ingress控制器（ Nginx ）<br>Ingress控制器自身是运行于Pod中的容器应用，一般是Nginx或Envoy一类的具有代理及负载均衡功能的守护进程，它监视着来自于API Server 的Ingress对象状态，并以其规则生成相应的应用程序专有格式的配置文件并通过重载或重启守护进程而使新配置生效。例如，对于Nginx来说，Ingress规则需要转换为Nginx的配置信息。简单来说，Ingress控制器其实就是托管于Kubernetes系统之上的用于实现在应用层发布服务的Pod资源，它将跟踪Ingress资源并实时生成配置规则。那么，同样运行为Pod资源的Ingress 控制器进程又该如何接入外部的请求流量呢？常用的解决方案</li>
</ul>
<p>有如下两种。<br>口以Deployment控制器管理Ingress控制器的Pod资源，并通过NodePort或LoadBalancer类型的Service对象为其接人集群外部的请求流量，这就意味着，定义一个Ingress控制器时，必须在其前端定义一个专用的Service资源，如图6-13所示。<br>口借助于DaemonSet控制器，将Ingress控制器的Pod资源各自以单一实例的方式运行于集群的所有或部分工作节点之上，并配置这类Pod对象以hostPort（如</p>
<p>图6-13 使用专用的 Service 对象为Ingress 控<br>制器接入外部流量</p>
<p>图6-14a)或 hostNetwork(如图6-14b)的方式在当前节点接入外部流量。</p>
<p>图6-14以hostPort或 hostNetwork 的方式为 Ingress 控制器接入外部流量<br>以 ingress-nginx 项目为例，部署 Ingress Nginx 控制器的配置文件被切割存放在了多个不同的文件中，并集中存储于其源码 deploy子目录下，同时，为了方便用户部署， 它还将所需的资源全部集成为一个配置文件 mandatory.yaml：<br>~]$ kubectl apply-f<a href="https://raw.githubusercontentcom/kubernetes/ingress-" target="_blank" rel="noopener">https://raw.githubusercontentcom/kubernetes/ingress-</a> nginx/master/deploy/mandatory .yaml<br>因为需要下载相关的镜像文件， 因此前面部署过程中的Pod 资源的创建需要等待一段时间才能完成， 具体时长要取决于网络的可用状况。 可使用如下命令持续监控创建过程，待其状态为“Running”之后即表示运行正常：<br>~]$ kubectl get pods -n ingress-nginx  —watch<br>NAME<br>READY STATUS RESTARTS<br>AGE<br>default-http-backend-6586bc58b6-cw7c6  1/1 Running<br>0<br>3m<br>nginx-ingress-controller-7675fd6cdb-kvsh2  1/1 Running 0<br>3m<br>在线的配置清单中采用了基于 Deployment 控制器部署 Ingress Nginx 的方式，因此接入外部流量之前还需要手动为其创建相关的 NodePort或LoadBalancer 类型的 Service 资源对象，下面的配置清单示例中对类型定义了NodePort， 并明确指定了易记的端口和 IP 地址，以方便用户使用：</p>
<p>将上面的配置信息保存于文件中，如nginx-ingress-service.yaml，而后执行如下命令完成资源的创建。注意，其标签选择器应该与mandatory.yaml配置清单中的Deployment控制器nginx-ingress-controller的选择器保持一致：<br>~]$ kubectl apply -f nginx- ingress-service .yaml<br>如果读者的集群运行支持LBaaS的laaS云环境，则可以将其类型指定为LoadBalancer，这样直接就有了可用的external-LB。<br>确认Service对象nginx- ingress-controller的状态没有问题后即可于集群外部对其发起访问测试，目标URL为http://<nodeip>:30080或ttp//<nodeip>:30443，确认可接收到响应报文后即表示IngressNginx部署完成。不过，本示例中尚且缺少一个可用的外部负载均衡器，如图6-13中所示的“external-LB”，因此，访问测试时暂时还只能使用http://<nodeip>:<nodeport>进行。<br>6.7案例： 使用Ingress发布tomcat<br>假设有这样一套环境： Kubernetes 集群上的tomcat-deploy 控制器生成了两个运行于Pod资源中的tomcat实例，tomcat-svc是将它们统-暴露于集群中的访问人口。现在需要通过Ingress资源将tomcat-svc发布给集群外部的客户端访问。具体的需求和规划如图6-15所示。<br>为了便于读者理解，下面的测试操作过程将把每一步分解开来放在单独的一节中进行。6.7.1准备名称空间<br>假设本示例中创建的所有资源都位于新建的testing名称空间中，与其他的资源在逻辑.上进行隔离，以方便管理。下面的配置信息保存于testing-namespace.yaml资源清单文件中：</nodeport></nodeip></nodeip></nodeip></p>
<p>图6-15 Ingress 发布应用示例拓扑图<br>kind: Namespace apiVersion: v1 metadata:<br>name: testing labels:<br>env: testing<br>而后运行创建命令完成资源的创建， 并确认资源的存在：<br>~]$ kubectl apply -f testing-namespace.yaml  namespace “testing” created<br>~]$ kubectl get namespaces testing<br>NAME STATUS AGE<br>testing Active 8s<br>6.7.2 部署tomcat实例<br>在此示例中，tomcat 应用本身代表着运行于 tomcat 容器中的一个实际应用。具体实践中，它通常应该是包含了某应用程序的 war 文件的镜像文件。 下面的配置清单使用了 Deployment 控制器于 testing 中部署 tomcat 相关的 Pod 对象，它保存于 tomcat-deploy.yaml 文件中：</p>
<p>运行资源创建命令完成 Deployment 控制器和Pod 资源的创建，命令如下： ~]$ kubectl apply -f tomcat-deploy.yaml<br>接着运行命令以确认其成功完成，且各Pod 已经处于正常运行状态中：<br>~]$ kubectl get pods -n testing<br>NAME<br>READY<br>STATUS<br>RESTARTS<br>AGE<br>tomcat-deploy-6cf8468f7f-5d7tb<br>1/1<br>Running<br>0<br>1m<br>tomcat-deploy-6cf8468f7f-9fvxx<br>1/1<br>Running<br>0<br>1m<br>实践中，如果需要更多的 Pod 资源承载用户访问， 那么使用 Deployment 控制器的规模伸缩机制即可完成， 或者直接修改上面的配置文件并执行“ kubectl apply”命令重新进行应用。<br>6.7.3 创建 Service 资源<br>Ingress 资源仅通过 Service 资源识别相应的Pod 资源，获取其 IP和端口，而后 Ingress 控制器即可直接使用各 Pod 对象的 IP 地址与它直接进行通信， 而不经由Service 资源的代理和调度，因此 Service 资源的 ClusterIP 对 Ingress 控制器来说一无所用。不过， 若集群内的其他 Pod 客户端需要与其通信，那么保留 ClusterIP 似乎也是很有必要的。<br>下面的配置文件中定义了 Service 资源 tomcat-svc，它通过标签选择器将相关的 Pod 对象归于一组，并通过 80/TCP 端口暴露 Pod 对象的 8080/TCP 端口。 如果需要暴露容器的8009/TCP端口， 那么只需要将其以类似的格式配置于列表中即可：</p>
<p>运行资源创建命令完成Service 资源的创建：<br>~]$ kubectl apply -f tomcat-svc.yaml  接着运行命令以确认其成功完成：<br>~]$ kubectl NAME<br>get svc tomcat-svc -n testing<br>TYPE<br>CLUSTER-IP<br>EXTERNAL-IP<br>PORT(S) 80/TCP<br>AGE<br>tomcat-svc<br>ClusterIP<br>10.108.72.237</p>
<p><none><br>8s<br>6.7.4 创建Ingress 资源<br>通过 Ingress 资源的 FQDN 主机名或 URL 路径等类型发布的服务， 只有用户的访问请求能够匹配到其.spec.rules.host 字段定义的 主机时才能被相应的规则处理。 如果要明确匹配用户的处理请求，比如希望将那些发往 tomcat.ilinux.io 主机的所有请求代理至 tomcat-svc资源的后端 Pod， 则可以使用如下命令配置文件中的内容：<br>apiVersion: extensions/v1beta1<br>kind: Ingress<br>metadata:<br>name: tomcat<br>namespace: testing<br>annotations:<br>kubernetes.io/ingress.class: “nginx”  spec:<br>rules:</none></p>
<ul>
<li>host: tomcat.ilinux.io<br>http:<br>paths:</li>
<li>path:<br>backend:<br>serviceName: tomcat-svc<br>servicePort:80<br>运行资源创建命令完成Service 资源的创建：<br>~]$ kubectl apply -f tomcat-ingress.yaml<br>而后通过详细信息确认其创建成功完成， 并且已经正确关联到相应的tomcat-svc 资源上 ：</li>
</ul>
<p>接下来即可通过 Ingress 控制器的前端 Service 资源的 NodePort 来访问此服务， 在6.6.4节中，此 Service 资源的 ClusterIP 被明确定义为 10.99. 99.99，并以节点端口30080映射Ingress控制器的 80 端口。因此， 这里使用Ingress 中定义的主机名 tomcat.ilinux.io：30080 即可访问tomcat 应用，图 6-16所示的是访问页面的效果。当然， 实践中，其前端应该有一个外部的负载均衡设备接收并调度此类请求。</p>
<p>图 6-16 访问 Ingress 资源代理的 tomcat应用<br>不过，用户对 tomcat.ilinux.io 主机之外的地址发起的被此 Ingress 规则匹配到的请求将发往 Ingress 控制器的默认的后端，即 default-http-backend， 它通常只能返回一个 404 提示信息。用户也可按需自定义默认后端，例如， 如下面的配置文件片断所示，它通过 .spec. backend 定义了所有无法由此 Ingress 匹配的访问请求都由相应的后端 default-svc 这个 Service 资源来处理：<br>spec:<br>backend:<br>serviceName: default-svc servicePort: 80<br>6.7.5 配置 TLS Ingress 资源<br>一般来说，如果有基于 HTTPS 通信的需求， 那么它应该由外部的负载均衡器 （external-</p>
<p>LB）予以实现，并在SSL会话卸载后将访问请求转发到Ingress控制器。不过，如果外部负载均衡器工作于传输层而不是工作于应用层的反向代理服务器，或者存在直接通过Ingress控制器接收客户端请求的需求，又期望它们能够提供HTTPS服务时，就应该配置TLS类型的Ingress资源。<br>将此类服务公开发布到互联网时，HTTPS服务用到的证书应由公信CA签署并颁发，用户遵循其相应流程准备好相关的数字证书即可。如果出于测试或内部使用之目的，那么也可以选择自制私有证书。openssl工具程序是用于生成自签证书的常用工具，这里使用它生成用于测试的私钥和自签证书：<br>~]s openssl genrsa -out tls.key 2048<br>~]$ openssl req -new -x509-keytls.key-outtls.crt\<br>-subj/c=CN/ST=Beijing/L=Beijing/O=Dev0ps/CN=tomcat.ilinux.io-days 3650<br>注意TLS Secret中包含的证书必须以tls.crt作为其键名，私钥文件必须以tls.key为键名，<br>因此上面生成的私钥文件和证书文件名将直接保存为键名形式，以便于后面创建Secret对象时直接作为键名引用。<br>在Ingress控制器上配置HTTPS主机时，不能直接使用私钥和证书文件，而是要使用Secret资源对象来传递相关的数据。所以，接下来要根据私钥和证书生成用于配置TLS Ingress 的Secret资源，在创建Ingress规则时由其将用到的Secret资源中的信息注人Ingress控制器的Pod对象中，用于为配置的HTTPS虚拟主机提供相应的私钥和证书。下面的命令会创建一个TLS类型名为tomcat-ingress-secret的Secret资源：<br>~]$ kubectl create secret tls tomcat-ingress-secret—-cert=tls.crt —key=tls. key -n testing<br>可使用下面的命令确认Secrets资源tomcat-ingress-secret创建成功完成：<br>~]$ kubectl get secrets tomcat-ingress-secret -n testing<br>NAME<br>TYPE<br>DATA<br>AGE<br>tomcat-ingress-secret<br>kubernetes.io/tls<br>2<br>20s<br>而后去定义创建TLS类型Ingress资源的配置清单。下面的配置清单通过spec.rules定义了一组转发规则，并通过.spec.tls将此主机定义为了HTTPS类型的虚拟主机，用到的私钥和证书信息则来自于Secrets资源tomcat-ingress-secret：</p>
<p>运行资源创建命令完成 Service 资源的创建：<br>~]$ kubectl apply -f tomcat-ingress-tls.yaml<br>而后通过详细信息确认其创建成功完成， 且已经正确关联到相应的 tomcat-svc 资源： ~]$ kubectl describe ingress tomcat-ingress-tls -n testing<br>Name:<br>tomcat-ingress-tls<br>Namespace:<br>testing<br>Address:<br>Default backend:<br>default-http-backend:80 (<none>)<br>TLS:<br>tomcat-ingress-secret terminates tomcat.ilinux.io<br>Rules:<br>Host<br>Path<br>Backends<br>tomcat.ilinux.io<br>1<br>tomcat-svc:80 (<none>)<br>Annotations:<br>Events:<br>Type<br>Reason<br>Age<br>From</none></none></p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Normal<br>CREATE<br>31s<br>nginx-ingress-controller Ingress testing/tomcat-ingress-<br>tls<br>接下来即可通过 Ingress 控制器的前端 Service 资源的 NodePort 来访问此服务， 在6.6.4节中，此 Service 资源以节点端口 30443 映射控制器的 443 端口。因此， 这里使用Ingress中定义的主机名 tomcat.ilinux.io：30443 即可访问tomcat 应用， 其访问到的页面效果类似于图6-16中的内容。另外，也可以使用 curl 进行访问测试， 只要对应的主机能够正确解析tomcat.ilinux.io 主机名即可，例如， 下面的测试命令及其输出表明， TLS 类型的 Ingress已然配置成功：</p>
<p>到此为止，实践配置目标已经全部达成。 需要再次提醒的是，在实际使用中， 在集群之外应该存在一个用于调度用户 请求至各节点上 Ingress 控制器相关的 NodePort 的负载均衡器。如果不具有 LBaaS 的使用条件， 用户也可以基于 Nginx、Haproxy、 LVS 等手动构建，并通过 Keepalived 等解决方案实现其服务的高可用配置。<br>6.8 本章小结<br>本章重点讲解了 Kubernetes 的 Service 资源及其发布方式，具体如下。<br>Service 资源通过标签选择器为一组 Pod 资源创建一个统一的访问人口， 其可将客户端请求代理调度至后端的 Pod 资源。<br>Service 资源是四层调度机制， 默认调度算法为随机调度。<br>口Service 的实现模式有三种：userspace、 iptables 和 ipvs。<br>口 Service 共用四种类型：ClusterIP、 NodePort、LoadBalancer和 ExternalName， 它们用于发布服务。<br>口Headless service 是一种特殊的 Service 资源，可用于 Pod 发现。<br>口Ingress 资源是发布 Service 资源的另一种方式，它需要结合Ingress 控制器才能正常工作。<br>口Ingress Controller 的实现方式除了 Nginx 之外，还有 Envoy、HAProxy、 Traefik 等。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes进阶实战/" rel="tag"># Kubernetes进阶实战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/06/第5章-Pod控制器/" rel="next" title="第5章 Pod控制器">
                <i class="fa fa-chevron-left"></i> 第5章 Pod控制器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/06/第7章-存储卷与数据持久化/" rel="prev" title="第7章 存储卷与数据持久化">
                第7章 存储卷与数据持久化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1036</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/06/26/07丨MVCC：如何实现多版本并发控制？/" title="07丨MVCC：如何实现多版本并发控制？" target="_blank">07丨MVCC：如何实现多版本并发控制？</a>
                  </li>
                
                  <li>
                    <a href="/2023/06/19/8、精通Golang项目依赖Go-modules/" title="8、精通Golang项目依赖Go Modules" target="_blank">8、精通Golang项目依赖Go Modules</a>
                  </li>
                
                  <li>
                    <a href="/2023/06/13/Day7-错误恢复/" title="Day7 错误恢复" target="_blank">Day7 错误恢复</a>
                  </li>
                
                  <li>
                    <a href="/2023/06/13/Day6-模板Template/" title="Day6 模板Template" target="_blank">Day6 模板Template</a>
                  </li>
                
                  <li>
                    <a href="/2023/06/13/Day5-中间件/" title="Day5 中间件" target="_blank">Day5 中间件</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Service资源及其实现模型"><span class="nav-number">1.</span> <span class="nav-text">Service资源及其实现模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Service资源概述"><span class="nav-number">1.1.</span> <span class="nav-text">Service资源概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Message"><span class="nav-number">1.2.</span> <span class="nav-text">Message</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.3m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">125:57</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
