<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Kubernetes进阶实战">
<meta property="og:type" content="article">
<meta property="og:title" content="第5章 Pod控制器">
<meta property="og:url" content="http://yoursite.com/2022/10/06/第5章-Pod控制器/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-10-07T02:24:22.737Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第5章 Pod控制器">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">






  <link rel="canonical" href="http://yoursite.com/2022/10/06/第5章-Pod控制器/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第5章 Pod控制器 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">坚持就是胜利</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/06/第5章-Pod控制器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="学如逆水行舟，不进则退">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第5章 Pod控制器

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-10-06 16:19:37" itemprop="dateCreated datePublished" datetime="2022-10-06T16:19:37+08:00">2022-10-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-10-07 10:24:22" itemprop="dateModified" datetime="2022-10-07T10:24:22+08:00">2022-10-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">30k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">27 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>自主式Pod对象由调度器绑定至目标工作节点后即由相应节点上的kubelet负责监控其容器的存活性，容器主进程崩溃后，kubelet能够自动重启相应的容器。不过，kubelet对非主进程崩溃类的容器错误却无从感知，这依赖于用户为Pod资源对象自定义的存活性探测（livenessprobe）机制，以便kubelet能够探知到此类故障。然而，在Pod对象遭到意外删除，或者工作节点自身发生故障时，又该如何处理呢？<br>kubelet是Kubernetes集群节点代理程序，它在每个工作节点上都运行着一个实例。 因而，集群中的某工作节点发生故障时，其kubelet也必将不再可用，于是，节点上的Pod资源的健康状态将无从得到保证，也无法再由kubelet重启。此种场景中的Pod存活性一般要 由工作节点之外的Pod控制器来保证。事实上，遭到意外删除的Pod资源的恢复也依赖于其控制器。<br>Pod控制器由master的kube controller-manager组件提供，常见的此类控制器有ReplcationController、ReplicaSet、 Deployment、 DaemonSet、 StatefulSet、 Job 和CronJob等，它们分别以不同的方式管理Pod资源对象。实践中，对Pod对象的管理通常都是由某种控制器的特定对象来实现的，包括其创建、删除及重新调度等操作。本章将逐—讲解常用的Pod控制器资源。 5.1 关于Pod控制器<br>我们可以把API Server类比成一个存储对象的数据库系统，它向客户端提供了API，并负责存储由用户创建的各种资源对象，至于各对象的当前状态如何才能符合用户期望的状态，则需要交由另一类称为控制器的组件来负责完成。Kubernetes提供了众多的控制器来管理各种类型的资源，如Node Lifecycle Controller、Namespace Controller 、Service Controller</p>
<p>和 Deployment Controller 等， 它们的功用几乎可以做到见名知义。 创建完成后，每一个控制器对象都可以通过内部的和解循环（ reconciliation loop）， 不间断地监控着由其负责的所有资源并确保其处于或不断地逼近用户定义的 目标状态。<br>尽管能够由 kubelet 为其提供自愈能力， 但在节点宕机时， 自主式 Pod 对象的重建式自愈机制则需要由 Pod 控制器对象负责提供 ，并且由它来负责实现生命周期中的各类自动管理行为，如创建及删除等。<br>5.1.1 Pod 控制器概述<br>Master 的各组件中，API Server 仅负责将资源存储于 etcd 中， 并将其变动通知给各相关的客户端程序，如 kubelet、 kube-scheduler、kube-proxy和 kube-controller-manager 等，kube-scheduler 监控到处于未绑定状态的 Pod 对象出现时遂启动调度器为其挑选适配的工作节点，然而，Kubernetes 的核心功能之一还在于要确保各资源对象的当前状态（status）以匹配用户期望的状态（spec）， 使当前状态不断地向期望状态“和解” （reconciliation）来完成容器应用管理，而这些则是 kube-controller-manager 的任务。 kube-controller-manager 是一个独立的单体守护进程，然而它包含了众多功能不同的控制器类型分别用于各类和解任务，如图 5-1 所示。</p>
<p>图 5-1 kube-controller-manager 及其控制器<br>蔡 Kubernetes 可用的控制器有 attachdetach、 bootstrapsigner、clusterrole-aggregation、 cronjob、 csrapproving、csrcleaner、csrsigning、 daemonset、deployment、disruption、 endpoint、 garbagecollector、 horizontalpodautoscaling、job、 namespace、node、persistentvolume- binder、persistentvolume-expander、podgc 、pvc-protection、replicaset、replication-  controller、resourcequota、route、 service、serviceaccount、 serviceaccount-token、 statefulset、tokencleaner 和 t11等数十种。<br>创建为具体的控制器对象之后， 每个控制器均通过 API Server 提供的接口持续监控相关资源对象的当前状态，并在因故障、 更新或其他原因导致系统状态发生变化时， 尝试让资源的当前状态向期望状态迁移和逼近。简单来说， 每个控制器对象运行一个和解循环负责状态和解，</p>
<p>并将目标资源对象的当前状态写入到其status字段中。控制器的“和解”循环如图5-2所示。List- Watch是Kubernetes实现的核心机制之一，<br>在资源对象的状态发生变动时，由APIServer负责</p>
<p>写人etcd并通过水平触发（level-triggered）机制主动通知给相关的客户端程序以确保其不会错过任何一个事件。控制器通过API Server的watch接口实时监控目标资源对象的变动并执行和解操作，但并不会与其他控制器进行任何交互，甚至彼此之间根本就意识不到对方的存在。</p>
<p>工作负载（workload） 一类的控制器资源类型包括 ReplicationController、ReplicaSet、Deployment、DaemonSet、StatefulSet、Job 和 CronJob等，它们分别代表了一种类型的 Pod控制器资源，各类型的功用在3.1.1 节中已经给出过说明。 本章后面的篇幅主要介绍各控制器的特性及其应用，不过 StatefulSet 控制器依赖于存储卷资源， 因此它将单独在存储卷之后的章节中给予介绍。 5.1.2 控制器与Pod对象<br>Pod 控制器资源通过持续性地监控集群中运行着的 Pod 资源对象来确保受其管控的资源严格符合用户期望的状态， 例如资源副本的数量要精确符合期望等。 通常，一个 Pod 控制器资源至少应该包含三个基本的组成部分。<br>口标签选择器：匹配并关联 Pod 资源对象， 并据此完成受其管控的Pod 资源计数。 口期望的副本数： 期望在集群中精确运行着的 Pod 资源的对象数量。<br>口Pod 模板： 用于新建 Pod 资源对象的 Pod 模板资源。<br>注意DaemonSet 用于确保集群中的每个工作节点或符合条件的每个节点上都运行着一个Pod 副本，而不是某个精确的数量值， 因此不具有上面组成部分中的第二项。<br>例如，一个如图 5-3 所示的 Deployment控制器资源使用的标签选择器为“role=be- eshop”，它期望相关的 Pod 资源副本数量精确为3个， 少于此数量的缺失部分将由控制器通过 Pod 模板予以创建，而多出的副本也将由控制器负责终止及删除。 </p>
<p>5.1.3 Pod模板资源<br>PodTemplate 是 Kubernetes API 的常用资源类型， 常用于为控制器指定自动创建 Pod 资源对象时所需的配置信息。 因为要内嵌于控制器中使用，所以 Pod 模板的配置信息中不需要 apiVersion 和 kind 字段， 但除此之外的其他内容与定义自主式 Pod 对象所支持的字段几乎完全相同，这包括 metadata 和 spec 及其内嵌的其他各个字段。 Pod 控制器类资源的 spec字段通常都要内嵌 replicas、selector和 template 字段，其中 template 即为 Pod 模板的定义。下面是一个定义在 ReplicaSet 资源中的模板资源示例： </p>
<p>如上示例中，spec.template字段在定义时仅给出了metadata和spec两个字段，它的使用方法与自主式Pod资源完全相同。后面讲到控制器的章节时会反复用到Pod模板资源。<br>5.2ReplicaSet控制器<br>Kubernetes较早期的版本中仅有ReplicationController一种类型的Pod控制器，后来的版本中陆续引入了更多的控制器实现，这其中就包括用来取代ReplicationController的新一代实现ReplicaSet。事实上，除了额外支持基于集合（set-based）的标签选择器，以及它的滚动更新（Rolling-Update）机制要基于更高级的控制Deployment实现之外，目前的ReplicaSet的其余功能基本上与ReplicationController相同。考虑到Kubernetes强烈推荐使用ReplicaSet控制器，且表示ReplicationController不久后即将废弃，这里就重点介绍</p>
<p>ReplicaSet控制器。<br>5.2.1 ReplicaSet概述<br>ReplicaSet（简称 RS） 是 Pod 控制器类型的一种实现， 用于确保由其管控的 Pod 对象副本数在任一时刻都能精确满足期望的数量。如图 5-4 所示，ReplicaSet 控制器资源启动后会查找集群中匹配其标签选择器的 Pod 资源对象， 当前活动对象的数量与期望的数量不吻合时，多则删除， 少则通过 Pod 模板创建以补足，等 Pod 资源副本数量符合期望值后即进入下一轮和解循环。</p>
<p>图5-4ReplicaSet的控制循环（图片来源：《Kubernetes in action》）<br>ReplicaSet的副本数量、标签选择器甚至是Pod模板都可以随时按需进行修改，不过仅改动期望的副本数量会对现存的Pod副本产生直接影响。修改标签选择器可能会使得现有的Pod副本的标签变得不再匹配，此时ReplicaSet控制器要做的不过是不再计人它们而已。另外，在创建完成后，ReplicaSet也不会再关注Pod对象中的实际内容，因此Pod模板的改动也只会对后来新建的Pod副本产生影响。<br>相比较于手动创建和管理Pod资源来说，ReplicaSet能够实现以下功能。<br>口确保Pod资源对象的数量精确反映期望值：ReplicaSet需要确保由其控制运行的Pod副本数量精确吻合配置中定义的期望值，否则就会自动补足所缺或终止所余。<br>口确保Pod健康运行：探测到由其管控的Pod对象因其所在的工作节点故障而不可用</p>
<p>时，自动请求由调度器于其他工作节点创建缺失的Pod副本。<br>口弹性伸缩：业务规模因各种原因时常存在明显波动，在波峰或波谷期间，可以通过ReplicaSet控制器动态调整相关Pod资源对象的数量。此外，在必要时还可以通过HPA （HroizontalPodAutoscaler） 控制器实现Pod资源规模的自动伸缩。<br>5.2.2创建 ReplicaSet<br>类似于Pod资源，创建ReplicaSet控制器对象同样可以使用YAML或JSON格式的清单文件定义其配置，而后使用相关的创建命令来完成资源创建。前面5.1.3节中给出的示例清单就是一个简单的ReplicaSet的定义。它也由kind、apiVersion 、metadata、 spec 和status这5个—级字段组成，其中status为只读字段，因此需要在清单文件中配置的仅为前4个字段。它的spec字段一般嵌套使用以下几个属性字段。<br>口replicas <integer>： 期望的Pod对象副本数。<br>口selector <object> ：当前控制器匹配Pod对象副本的标签选择器，支持matchLabels和matchExpressions两种匹配机制。<br>口template <object>： 用于补足Pod副本数量时使用的Pod模板资源。<br>口minReadySeconds <integer>：新建的Pod对象，在启动后的多长时间内如果其容器未发生崩溃等异常情况即被视为“就绪”；默认为0秒，表示一旦就绪性探测成功，即被视作可用。<br>将5.1.3节中的示例保存于资源清单文件中，例如rs-example.yaml， 而后即可使用如下命令将其创建： .<br>] kubectl apply -f rs-example.yaml<br>replicaset.apps “rs-example” created<br>集群中当前没有标签为“app： rs-demo”的Pod资源存在，因此rs-example需要按照replicas字段的定义创建它们，名称以其所属的控制器名称为前缀。这两个Pod资源目前都处于ContainerCreating状态，即处于容器创建过程中，待创建过程完成后，其状态即转为Running， Pod也将转变为“ READY “：<br>]# kubectl get pods -1 app=rs-demo<br>READY STATUS<br>RESTARTS AGB<br>rs-example-p66nv<br>ContainerCreating<br>g。</integer></object></object></integer></p>
<ul>
<li>example-rdm7q<br>Containercreating<br>接下来可以使用“kubectl get replicaset” 命令查看ReplicaSet控制器资源的相关状态。下面的命令结果显示出它已经根据清单中配置的Pod模板创建了2个Pod资源，不过这时它们尚未创建完成，因此仍为“REREADY’</li>
</ul>
<p>经由控制器创建与用户自主创建的Pod对象的功能并无二致，但其自动和解的功能在很大程度上能为用户省去不少的管理精力，这也是使得Kubernetes系统之上的应用程序变得拥有自愈能力的主要保障。<br>5.2.3ReplicaSet管控下的Pod对象<br>5.2.2节中创建的rc-example通过标签选择器将拥有“app=rs-demo”标签的Pod资源收归于麾下，并确保其数量精确符合所期望的数目，使用标签选择器显示出的Pod资源列表也能验证这一点。然而，实际中存在着不少可能导致Pod对象数目与期望值不符合的可能性，如Pod对象的意外删除、Pod对象标签的变动（已有的Pod资源变得不匹配控制器的标签选择器，或者外部的Pod资源标签变得匹配到了控制器的标签选择器）、控制器的标签选择器变动，甚至是工作节点故障等。ReplicaSet控制器的和解循环过程能够实时监控到这类异常，并及时启动和解操作。<br>1.缺少Pod副本<br>任何原因导致的相关Pod对象丢失，都会由ReplicaSet控制器自动补足。例如，手动删除上面列出的一个Pod对象，命令如下：<br>] kubectl delete pods rs-example-rdm7q<br>pod “rs-example-rdm7q” deleted<br>再次列出相关Pod对象的信息，可以看到被删除的rs-example-rdm7q进入了终止过程，而新的Pod对象rs-example-l4gkp正在被rs-example控制器创建：<br>] kubectl get pods -l app=rs-demo -o wide<br>NAME<br>READY<br>STATUS<br>RESTARTS<br>AGE<br>rs-example-l4gkp<br>0/1<br>ContainerCreating<br>0<br>1s<br>rs-example-p66nv<br>1/1<br>Running<br>0<br>39m<br>rs-example-rdm7q<br>0/1<br>Terminating<br>n<br>39m<br>另外，强行修改隶属于控制器rs-example的某Pod资源（匹配于标签控制器）的标签，会导致它不再被控制器作为副本计数，这也将触发控制器的Pod对象副本缺失补足机制。例如，将rs-example-p66nv的标签app的值置空：<br>] kubectl label pods rs-example-p66nv app= —overwrite<br>pod “rs-example-p66nv” labeled<br>列出rs-example相关Pod对象的信息，发现rs-example-p66nv已经消失不见，并且正在创建新的对象副本。</p>
<p>由此可见，修改Pod资源的标签即可将其从控制器的管控之下移出，当然，修改后的标签如果又能被其他控制器资源的标签选择器所命中，则此时它又成了隶属于另一控制器的副本。如果修改其标签后的Pod对象不再隶属于任何控制器，那么它就将成为自主式Pod，与此前手动直接创建的Pod对象的特性相同，即误删除或所在的工作节点故障都会造成其永久性的消失。<br>2.多出Pod副本<br>一旦被标签选择器匹配到的Pod资源数量因任何原因超出期望值，多余的部分都将被控制器自动删除。例如，为pod-example手动为其添加“app：rs-demo”标签：<br>] kubectl label pods pod-example app=rs-demo<br>pod “pod-example” labeled<br>再次列出相关的Pod资源，可以看到rs-example控制器启动了删除多余Pod的操作，pod-example正处于终止过程中：<br>] kubectl get pods -l app=rs-demo<br>NAME<br>READY<br>STATUS<br>RESTARTS<br>AGE<br>pod-example<br>1/1<br>Terminating<br>0<br>2m<br>rs-example-4bqzv<br>1/1<br>Running<br>0<br>17m<br>rs-example-l4gkp<br>1/1<br>Running<br>0<br>22m<br>这就意味着，任何自主式的或本隶属于其他控制器的Pod资源其标签变动的结果一旦匹配到了其他的副本数足额的控制器，就会导致这类Pod资源被删除。<br>3.查看Pod资源变动的相关事件<br>“kubectl describe replicasets”命令可打印出ReplicaSet控制器的详细状态，从下面命令结果中Events一段也可以看出，rs-example执行了Pod资源的创建和删除操作，为的就是确保其数量的精确性。</p>
<p>事实上，ReplicaSet控制器能对Pod对象数目的异常及时做出响应，是因为它向APIServer注册监听（watch）了相关资源及其列表的变动信息，于是API Server会在变动发生时立即通知给相关的监听客户端。<br>而因节点自身故障而导致的Pod对象丢失，ReplicaSet控制器一样会使用补足资源的方式进行处理，这里不再详细说明其过程。有兴趣的读者可通过直接关掉类似上面Pod对象运行所在的某一个节点来检验其处理过程。<br>5.2.4更新ReplicaSet控制器<br>ReplicaSet控制器的核心组成部分是标签选择器、副本数量及Pod模板，但更新操作一般是围绕replicas和template两个字段值进行的，毕竟改变标签选择器的需求几乎不存在。改动Pod模板的定义对已经创建完成的活动对象无效，但在用户逐个手动关闭其旧版本的Pod资源后就能以新代旧，实现控制器下应用版本的滚动升级。另外，修改副本的数量也就意味着应用规模的扩展（提升期望的副本数量）或收缩（降低期望的副本数量）。这两种操作也是系统运维人员日常维护工作的重要组成部分。<br>1.更改Pod模板：升级应用<br>ReplicaSet控制器的Pod模板可随时按需修改，但它仅影响这之后由其新建的Pod对象，对已有的副本不会产生作用。大多数情况下，用户需要改变的通常是模板中的容器镜像文件及其相关的配置以实现应用的版本升级。下面的示例清单文件片断（rs-example-v2.yaml）中的内容与之前版本（rs-example.yaml）的唯一不同之处也仅在于镜像文件的改动：<br>containers:</p>
<ul>
<li>name: nginx<br>image: ikubernetes/myapp:v2 ports:</li>
<li>name:http<br>containerPort:80<br>对新版本的清单文件执行“kubectl apply”或“kubet replace”命令即可完成rs-example控制器资源的修改操作：<br>] kubectl replace -f rs-example-v2.yaml<br>replicaset.apps “rs-example” replaced<br>不过，控制器rs-example管控的现存Pod对象使用的仍然是原来版本中定义的镜像：</li>
</ul>
<p>此时，手动删除控制器现有的 Pod 对象（或修改与其匹配的控制器标签选择器的标签），并由控制器基于新的Pod模板自动创建出足额的 Pod 副本， 即可完成一次应用的升级。新旧更替的过程支持如下两类操作方式。<br>口一次性删除控制器相关的所有 Pod 副本或更改相关的标签：剧烈更替， 可能会导致Pod 中的应用短时间不可访问（如图 5-5 所示）；生产实践中，此种做法不可取。 </p>
<p>图5-5 直接更替所有Pod 资源<br>口分批次删除旧有的 Pod 副本或更改其标签 （待控制器补足后再删除另一批）：滚动更替，更替期间新旧版本共存（如图 5-6 所示）。 </p>
<p>图5-6 滚动更替<br>例如，这里采用第一种方式进行操作， 一次性删除 rs-example 相关的所有 Pod 副本：] kubectl delete pods -1 app=rs-demo<br>pod “rs-example-4bqzv” deleted<br>pod “rs-example-l4gkp” deleted<br>再次列出 rc-example 控制器相关的 Pod 及其容器镜像版本时可以发现， 使用新版本镜像的Pod已经创建完成：<br>] kubectl get pods -l app=rs-demo -o \<br>custom-columns=Name:metadataname,Image:spec.containers[0]. image Name<br>Image<br>rs-example-4bwqq<br>ikubernetes/myapp:v2<br>rs-example-hqgnh<br>ikubernetes/myapp:v2</p>
<p>必要时，用户还可以将Pod模板改回旧的版本进行应用的“降级”或“回滚”，它的操作过程与上述过程基本类似。事实上，修改Pod模板时，不仅仅能替换镜像文件的版本，甚至还可以将其替换成其他正在运行着的、完全不同应用的镜像，只不过此类需求并不多见。若同时改动的还有Pod模板中的其他字段，那么在新旧更替的过程中，它们也将随之被应用。<br>以上操作只为说明应用部署的方式，实际使用时还需要更为完善的机制。即便是仅执行了一到多次删除操作，手动执行更替操作也并非一项轻松的任务，幸运的是，更高级别的Pod控制器Deployment能够自动实现更完善的滚动更新和回滚，并为用户提供自定义更新策略的接口。而且，经过精心组织的更新操作还可以实现诸如蓝绿部署（Blue/GreenDeployment）、金丝雀部署（Canary Deployment）和灰度部署等，这些内容将在后面章节中详细展开说明。<br>2.扩容和缩容<br>改动ReplicaSet控制器对象配置中期望的Pod副本数量（replicas字段）会由控制器实时做出响应，从而实现应用规模的水平伸缩。replicas的修改及应用方式同Pod模板，不过，kubectl还提供了一个专用的子命令scale用于实现应用规模的伸缩，它支持从资源清单文件中获取新的目标副本数量，也可以直接在命令行通过“—replicas”选项进行读取，例如将rs-example控制器的Pod副本数量提升至5个：<br>] kubectl scale replicasets rs-example —replicas=5<br>replicaset.extensions “rs-example” scaled<br>由下面显示的rs-example资源的状态可以看出，将其Pod资源副本数量扩展至5个的操作已经成功完成：<br>] kubectl get replicasets rs-example<br>NAME<br>DESIRED CURRENT READY AGE<br>rs-example 5-<br>5<br>12h<br>收缩规模的方式与扩展相同，只需要明确指定目标副本数量即可。例如：<br>] kubectl scale replicasets rs-example —replicas=3<br>replicaset.extensions “rs-example” scaled<br>另外，kubectl scale命令还支持在现有Pod副本数量符合指定的值时才执行扩展操作，这仅需要为命令使用“-current-replicas”选项即可。例如，下面的命令表示如果rs-example目前的Pod副本数量为2，就将其扩展至4个：<br>] kubectl scale replicasets rs-example —current-replicas=2 —replicas=4 error:Expected replicas to be 2, was 3<br>但由于rs-example控制器现存的副本数量是3个，因此上面的扩展操作未执行并返回了错误提示。</p>
<p>注意如果ReplicaSet控制器管控的是有状态的应用，例如主从架构的Redis集群，那<br>么上述这些升级、降级、扩展和收缩的操作都需要精心编排和参与才能进行，不过，这也在一定程度上降低了Kubernetes容器编排的价值和意义。好在，它提供了 StatefulSet资源来应对这种需求，因此，ReplicaSet通常仅用于管理无状态的应用， 如HTTP服务程序等。<br>5.2.5删除ReplicaSet控制器资源<br>使用kubectl delete命令删除ReplicaSet对象时默认会一并删除其管控的各Pod对象。有时，考虑到这些Pod资源未必由其创建，或者即便由其创建却也并非其自身的组成部分，故而可以为命令使用“—cascade=false”选项，取消级联，删除相关的Pod对象，这在Pod资源后续可能会再次用到时尤为有用。例如，删除rs控制器rs-example：<br>] kubectl delete replicasets rs-example —cascade=false<br>replicaset.extensions “rs-exampleu deleted<br>删除操作完成后，此前由rs-example控制器管控的各Pod对象仍处于活动状态，但它们变成了自主式Pod资源，用户需要自行组织和维护好它们。<br>提后续讲到的各Pod控制器的删除方式都与ReplicaSet类似，这里就不再分别进行说示<br>明了。<br>尽管ReplicaSet控制器功能强大，但在实践中，它却并非是用户直接使用的控制器，而是要由比其更高一级抽象的Deployment控制器对象来调用。<br>5.3Deployment控制器<br>Deployment （简写为deploy）是Kubernetes控制器的又一种实现，它构建于ReplicaSet 控制器之上，可为Pod和ReplicaSet资源提供声明式</p>
<p>控制器之上，可为Pod和ReplicaSet资源提供声明式更新。相比较而言，Pod 和ReplicaSet是较低级别的资源，它们很少被直接使用。Deployment、 ReplicaSet和Pod的关系如图5-7所示。<br>Deployment控制器资源的主要职责同样是为了保证Pod资源的健康运行，其大部分功能均可通</p>
<p>过调用 ReplicaSet控制器来实现，同时还增添了部 图5-7 Deployment、 ReplicaSets 和 Pods<br>分特性。</p>
<p>口事件和状态查看：必要时可以查看Deployment对象升级的详细进度和状态。<br>口回滚：升级操作完成后发现问题时，支持使用回滚机制将应用返回到前一个或由用户指定的历史记录中的版本上。<br>口版本记录：对Deployment对象的每一次操作 都予以保存，以供后续可能执行的回滚操作使用。<br>口暂停和启动：对于每一次升级，都能够随时暂停和启动。<br>口多种自动更新方案：一是Recreate， 即重建更新机制，全面停止、删除旧有的Pod 后用新版本替代；另一个是RollingUpdate，即滚动升级机制，逐步替换旧有的Pod至新的版本。<br>5.3.1 创建Deployment<br>Deployment是标准的KubernetesAPI资源，它建构于ReplicaSet资源之上，于是其spec字段中嵌套使用的字段包含了ReplicaSet 控制器支持的replicas、selector 、template 和minReadySeconds，它也正是利用这些信息完成了其二级资源ReplicaSet对象的创建。下面是一个Deployment控制器资源的配置清单示例：</p>
<p>上面的内容显示出，除了控制器类型和名称之外，它与前面ReplicaSet控制器示例中的内容几乎没有什么不同。下面在集群中创建以了解它的工作方式：<br>] kubectl apply -f myapp-deploy .yaml —record<br>depl oyment . apps “ myapp-deploy” created<br>“kubectl get deployments”命令可以列出创建的Deployment对象myapp-deploy及其</p>
<p>相关的信息。下面显示的字段中，UP-TO-DATE表示已经达到期望状态的Pod副本数量，AVAILABLE则表示当前处于可用状态的应用程序的数量：<br>] kubectl get deployments myapp-deploy NAME<br>DESIRED<br>CURRENT<br>UP-TO-DATE<br>AVAILABLE 3<br>AGE<br>myapp-deploy<br>。<br>3<br>o<br>13s<br>Deployment控制器会自动创建相关的ReplicaSet控制器资源，并以“[DEPLOYMENT-NAME]-[POD-TEMPLATE-HASH-VALUE]”格式为其命名，其中的hash值由Deployment控制器自动生成。由Deployment创建的ReplicaSet对象会自动使用相同的标签选择器，因此，可使用类似如下的命令查看其相关的信息：<br>] kubectl get replicasets -l app=myapp<br>NAME<br>DESIRED<br>CURRENT<br>READY<br>AGE<br>myapp-deploy-86b4b8c75d<br>3<br>2<br>。<br>37s<br>相关的Pod对象的信息可以用相似的命令进行获取。下面的命令结果中，Pod对象的名称遵循ReplicaSet控制器的命名格式，它以ReplicaSet控制器的名称为前缀，后跟5位随机字符：<br>] kubectl get pods -l app=myapp<br>NAME<br>READY<br>STATUS<br>RESTARTS<br>AGE<br>myapp-deploy-86b4b8c75d-7atxn1/1<br>Running<br>0<br>46s<br>myapp-deploy-86b4b8c75d-hdw9z<br>1/1<br>Running<br>0<br>46s<br>myapp-deploy-86b4b8c75a-w4svj<br>1/1<br>Running<br>46s<br>由此印证了Deployment借助于ReplicaSet管理Pod资源的机制，于是可以得知，其大部分管理操作与ReplicaSet相同。不过，Deployment也有ReplicaSet所不具有的部分高级功能，这其中最著名的当数其自动滚动更新的机制。<br>5.3.2更新策略<br>如前所述，ReplicaSet控制器的应用更新需要手动分成多步并以特定的次序进行，过程繁杂且容易出错，而Deployment却只需要由用户指定在Pod模板中要改动的内容，例如容器镜像文件的版本，余下的步骤可交由其自动完成。同样，更新应用程序的规模也只需要修改期望的副本数量，余下的事情交给Deployment控制器即可。<br>Deployment控制器详细信息中包含了其更新策略的相关配置信息，如myapp-deploy控制器资源“kubectl describe”命令中输出的StrategyType、RollingUpdateStrategy字段等：</p>
<p>Deployment控制器支持两种更新策略：滚动更新（rolling update）和重新创建（recreate），默认为滚动更新。重新创建更新类似于前文中ReplicaSet的第一种更新方式，即首先删除现有的Pod对象，而后由控制器基于新模板重新创建出新版本资源对象。通常，只应该在应用的新旧版本不兼容（如依赖的后端数据库的schema不同且无法兼容）时运行时才会使用recreate策略，因为它会导致应用替换期间暂时不可用，好处在于它不存在中间状态，用户访问到的要么是应用的新版本，要么是旧版本。<br>滚动升级是默认的更新策略，它在删除一部分旧版本Pod资源的同时，补充创建一部分新版本的Pod对象进行应用升级，其优势是升级期间，容器中应用提供的服务不会中断，但要求应用程序能够应对新旧版本同时工作的情形，例如新旧版本兼容同一个数据库方案等。不过，更新操作期间，不同客户端得到的响应内容可能会来自不同版本的应用。<br>Deployment控制器的滚动更新操作并非在同一个ReplicaSet控制器对象下删除并创建Pod资源，而是将它们分置于两个不同的控制器之下：旧控制器的Pod对象数量不断减少的同时，新控制器的Pod对象数量不断增加，直到旧控制器不再拥有Pod对象，而新控制器的副本数量变得完全符合期望值为止，如图5-8所示。</p>
<p>图5-8 Deployment 的滚动更新<br>滚动更新时，应用升级期间还要确保可用的Pod对象数量不低于某阈值以确保可以持续处理客户端的服务请求，变动的方式和Pod对象的数量范围将通过spec.strategy.rollingUpdate.maxSurge和spec.strategy.rollingUpdate.maxUnavailable两个属性协同进行定义，它们的功</p>
<p>用如图5-9所示。<br>maxSurge：指定升级期间存在的总Pod对象数量最多可超出期望值的个数，其值可以是0或正整数，也可以是一个期望值的百分比；例如，如果期望值为3，当前的属性值为1，则表示Pod对象的总数不能超过4个。<br>D maxUnavailable：升级期间正常可用的Pod副本数（包括新旧版本）最多不能低于期望数值的个数，其值可以是0或正整数，也可以是一个期望值的百分比；默认值为1，该值意味着如果期望值是3，则升级期间至少要有两个Pod对象处于正常提供服务的状态。</p>
<p>图5-9 maxSurge 和maxUnavailable的作用方式（ 图片来源：《Kubernetes in action》）<br>maxSurge和maxUnavailable属性的值不可同时为0，否则Pod对象的副本数量在符合用户期望的数量后无法做出合理变动以进行滚动更新操作。<br>配置时，用户还可以使用Deplpoyment控制器的spec.minReadySeconds属性来控制应用升级的速度。新旧更替过程中，新创建的Pod对象一旦成功响应就绪探测即被视作可用，而后即可立即开始下一轮的替换操作。而spec.minReadySeconds能够定义在新的Pod对象创建后至少要等待多久才会将其视作就绪，在此期间，更新操作会被阻塞。因此，它可以用来让Kubermetes在每次创建出Pod资源后都要等上一段时长后再开始下一轮的更替，这个时间长度的理想值是等到Pod对象中的应用已经可以接受并处理请求流量。事实上，一个精心设计的等待时长和就绪性探测能让Kubernetes系统规避一部分因程序Bug而导致的升</p>
<p>级故障。<br>Deployment 控制器也支持用户保留其滚动更新历史中的旧 ReplicaSet 对象版本，如图 5-10 所示， 这赋予了控制器进行应用回滚的能力： 用户可按需回滚到指定的历史版本。控制器可保存的历史版本数量由“ spec.revisionHistoryLimit”属性进行定义。 当然，也只有保存于 revision 历史中的 ReplicaSet 版本可用于回滚，因此， 用户要习惯性地在更新操作时指定保留旧版本。</p>
<p>图5-10 Deployment 的版本历史记录<br>为了保存版本升级的历史，需要在创建Deployment对象时于命令中使用“—record”选项。<br>尽管滚动更新以节约系统资源著称，但它也存在一些劣势。直接改动现有环境，会使系统引入不确定性风险，而且升级过程出现问题后，执行回滚操作也会较为缓慢。有鉴于此，金丝雀部署可能是较为理想的实现方式，当然，如果不考虑系统资源的可用性，那么传统的蓝绿部署也是不错的选择。<br>5.3.3升级Deployment<br>修改Pod模板相关的配置参数便能完成Deployment控制器资源的更新。由于是声明式配置，因此对Deployment控制器资源的修改尤其适合使用apply和patch命令来进行；当然，如果仅是修改容器镜像，“set image”命令更为易用。<br>接下来通过更新此前创建的Deployment控制器deploy-example来了解更新操作过程的执行细节，为了使得升级过程更易于观测，这里先使用“kubectl patch”命令为其spec.minReadySeconds字段定义一个等待时长， 例如Ss：<br>] kubectl patch deployments myapp-deploy -P ‘{“spec”: {“minReadySeconds”: 5}’ deployment . extensions “myapp-deploy” patched<br>patch命令的补丁形式为JSON格式，以-p选项指定，上面命令中的’{“spec”： {“min ReadySeconds”： 5}}’ 表示设置spec.minReadySeconds属性的值。若要改变myapp-deploy 中myapp容器的镜像，也可使用patch命令，如’{“‘spec”： {“containers”： [“name”： “myapp”，</p>
<p>“image””ikubernetes/myapp： v2”}}’， 不过， 修改容器镜像有更为简单的专用命令“set image”。<br>修改 Deployment 控制器的 minReadySeconds、 replicas和 strategy 等字段的值并不会触发 Pod 资源的更新操作， 因为它们不属于模板的内嵌字段， 对现存的 Pod 对象不产生任何影响。<br>接着，使用“ikubernetes/myapp： v2” 镜像文件修改 Pod 模板中的 myapp 容器， 启动Deployment 控制器的滚动更新过程：<br>] kubectl set image deployments myapp-deploy myapp=ikubernetes/myapp:v2 deployment.apps “myapp-deploy” image updated<br>“kubectl rollout status” 命令可用于打印滚动更新过程中的状态信息：<br>] kubectl rollout status deployments myapp-deploy<br>另外，还可以使用“kubectl get deployments —watch”命令监控其更新过程中 Pod 对象的变动过程：<br>] kubectl get deployments myapp-deploy —watch<br>滚动更新时， myapp-deploy 控制器会创建一个新的 ReplicaSet 控制器对象来管控新版本的 Pod 对象，升级完成后，旧版本的ReplicaSet 会保留在历史记录中， 但其此前的管控Pod对象将会被删除。<br>] kubectl get replicasets -l app=myapp<br>NAME<br>DESIRED<br>CURRENT<br>READY<br>AGE<br>myapp-deploy-79859f456c<br>3<br>3<br>3<br>1m<br>myapp-deploy-86b4b8c75d<br>0<br>0<br>0<br>7m<br>myapp-deploy 控制器管控的 Pod 资源对象也将随之更新为以新版本 ReplicaSet名称“myapp-deploy-79859f456c”为前缀的 Pod 副本，命令结果如下所示：<br>] kubectl get pods -l app=myapp<br>NAME<br>READY<br>STATUS<br>RESTARTS<br>AGE<br>myapp-deploy-79859f456c-29rqw<br>1/1<br>Running<br>o<br>16m<br>myapp-deploy-79859f456c-fhhwf<br>1/1<br>Running<br>0<br>15m<br>myapp-deploy-79859f456c-h4n9d<br>1/1<br>Running 0<br>15m<br>由于已经处于 READY状态， 因此上面命令列出的任一Pod资源均可正常向用户提供相关服务，例如，在集群内任一能使用 kubect1的节点访问 myapp-deploy-79859f456c-29rqw中的Web服务，命令如下：</p>
<p>5.3.4 金丝雀发布<br>Deployment控制器还支持自定义控制更新过程中的滚动节奏，如“暂停”（ pause）或 “继续”resume） 更新操作，尤其是借助 于前文讲到的maxSurge和maxUnavailable 属性还能实现更为精巧的过程控制。比如，待第—批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一小部分新版本的应用，主体部分还是旧的版本。然后，再根据用户特征精心筛选出小部分用户的请求路由至新版本的Pod应用，并持续观察其是否能稳定地按期望的方式运行。确定没有问题后再继续完成余下Pod资源的滚动更新，否则立即回滚更新操作。这便是所谓的金丝雀发布（Canary Release），如图5-11 所示。</p>
<p>图5-11金丝雀发布（图片来源:ttp://blog.christianposta.com）<br>拓展知识：矿井中的金丝雀<br>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯气体，金丝雀也会停止歌唱；当瓦斯含量超过一定限度时，人类依旧毫无察觉，而金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为瓦斯检测工具，以便在危险状况下紧急撤离。<br>直接发布新应用版本的在线发布形式中，金丝雀发布是一种较为妥当的方式。不过，这里只涉及其部署操作的相关步骤，发布方式则通常依赖于具体的环境设置。接下来说明如何在Kubernetes 上使用Deployment控制器实现金丝雀部署。<br>为了尽可能地降低对现有系统及其容量的影响，金丝雀发布过程通常建议采用“先添加、再删除，且可用Pod资源对象总数不低于期望值”的方式进行。首次添加的Pod对象数量取决于其接人的第一批请求的规则及单个Pod的承载能力，视具体需求而定，为了能够更简单地说明问题，接下来采用首批添加1个Pod资源的方式。将Deployment控制器的maxSurge属性的值设置为1，并将maxUnavailable属性的值设置为0：</p>
<p>接下来，启动myapp-deploy控制器的更新过程，在修改相应容器的镜像版本后立即暂停更新进度，它会在启动第一批新版本Pod对象的创建操作之后转为暂停状态。需要注意的是，这里之所以能够在第—批更新启动后就暂停，有赖于此前为maxReadySeconds属性设置的时长，因此用户要在更新命令启动后的此时长指定的时间范围内启动暂停操作，其执行过程如图5-12所示。当然，对kubectl命令来说，也可以直接以“&amp;&amp;”符号在Shell中连接两个命令：</p>
<p>图5-12暂停 Deployment滚动更新<br>通过其状态查看命令可以看到，在创建完一个新版本的Pod资源后滚动更新操作“暂停”：<br>] kubectl rollout status deployments myapp-deploy<br>Waiting for rollout to finish: 1 out of 3 new replicas have been updated. . .<br>相关的Pod列表也可能显示旧版本的ReplicaSet的所有Pod副本仍在正常运行，新版本的ReplicaSet 也包含一个Pod副本，但最多不超过期望值1个，myapp-deploy 原有的期望值为3，因此总数不超过4个。此时，通过Service或Ingress资源及相关路由策略等设定，即可将一部分用户的流量引入到这些Pod之上进行发布验证。运行一段时间后，如果确认没有问题，即可使用“ kubectl rollout resume”命令继续此前的滚动更新过程：<br>] kubectl rollout resume deployments myapp-deploy<br>deployment . apps “ myapp-deploy” resumed<br>“ kubectl rollout status’命令监控到滚动更新过程完成后，即可通过myapp-deploy控制器及其ReplicaSet和Pod对象的相关信息来了解其结果状态。<br>然而，如果“金丝雀”遇险甚至遭遇不幸，那么回滚操作便成了接下来的当紧任务。</p>
<p>5.3.5 回滚Deployment 控制器下的应用发布<br>若因各种原因导致滚动更新无法正常进行， 如镜像文件获取失败、“金丝雀”遇险等， 则应该将应用回滚到之前的版本， 或者回滚到由用户指定的历史记录中的版本。 Deployment控制器的回滚操作可使用“kubectl rollout undo”命令完成，例如，下面的命令可将 my app-deploy 回滚至此前的版本：<br>] kubectl rollout undo deployments myapp-deploy<br>deployment.apps “myapp-deploy”<br>等回滚完成后，验证 myapp-deploy 的 ReplicaSet 控制器对象是否已恢复到指定的历史版本以确保其回滚正常完成。在“kubectl rollout undo” 命令上使用“—to-revision” 选项指定 revision 号码即可回滚到历史特定版本， 例如，假设 myapp-deploy 包含如下的 revision 历史记录：<br>] kubectl rollout history deployments myapp-deploy<br>deployments”myapp-deploy”<br>REVISION CHANGE-CAUSE<br>1<br>kubectl patch deployments myapp-deploy —patch={“spec”: {“minReady-<br>Seconds”: 5}}<br>2<br>kubectl patch deployments myapp-deploy —patch={“spec”: {“strategy”:<br>{“rollingUpdate”: {“maxSurge”: 1, “maxUnavailable”: 0}}}}<br>3<br>kubectl set image deployments myapp-deploy myapp=ikubernetes/myapp:v3<br>4<br>kubectl set image deployments myapp-deploy myapp=ikubernetes/myapp:v4<br>若要回滚到号码为2 的 revision 记录， 则使用如下命令即可完成：<br>] kubectl rollout undo deployments myapp-deploy —to-revision=2<br>deployment.apps”myapp-deploy”<br>回滚操作中，其 revision 记录中的信息会发生变动， 回滚操作会被当作一次滚动更新追加进历史记录中，而被回滚的条目则会被删除 。需要注意的是， 如果此前的滚动更新过程处于“暂停”状态， 那么回滚操作就需要先将 Pod 模板的版本改回到之前的版本，然后“继续”更新，否则， 其将一直处于暂停状态而无法回滚。<br>5.3.6 扩容和缩容<br>通过修改.spec.replicas 即可修改 Deployment 控制器中 Pod 资源的副本数量，它将实时 作用于控制器并直接生效。Deployment 控制器是声明式配置，replicas 属性的值可直接修改资源配置文件，然后使用“kubectl apply” 进行应用，也可以使用“kubectl edit” 对其进行实时修改。 而前一种方式能够将修改结果予以长期留存。<br>另外，“ kubect1 scale” 是专用于扩展某些控制器类型的应用规模的命令， 包括Deployment 和 Job 等。而 Deployment通过 ReplicaSet 控制其 Pod 资源， 因此扩缩容的方式是相同的， 除了命令直接作用的资源对象有所不同之外 ，这里不再对其进行展开说明。</p>
<p>5.4 DaemonSet 控制器<br>DaemonSet是Pod控制器的又一种实现，用于在集群中的全部节点上同时运行一份指定的Pod资源副本，后续新加人集群的工作节点也会自动创建一个相关的Pod对象，当从集群移除节点时，此类Pod对象也将被自动回收而无须重建。管理员也可以使用节点选择器及节点标签指定仅在部分具有特定特征的节点上运行指定的Pod对象。<br>DaemonSet是一种特殊的控制器，它有特定的应用场景，通常运行那些执行系统级操作任务的应用，其应用场景具体如下。<br>口运行集群存储的守护进程，如在各个节点上运行glusterd或ceph。<br>口在各个节点上运行日志收集守护进程，如fluentd和logstash.<br>口在各个节点上运行监控系统的代理守护进程， 如Prometheus Node Exporter、collectd.、Datadog agent、New Relic agent或Ganglia gmond等。<br>当然，既然是需要运行于集群内的每个节点或部分节点，于是很多场景中也可以把应用直接运行为工作节点上的系统级守护进程，不过，这样一来就失去了运用Kubernetes管理所带来的便捷性。另外，也只有必须将Pod对象运行于固定的几个节点并且需要先于其他Pod启动时，才有必要使用DaemonSet控制器，否则就应该使用Deployment控制器。<br>5.4.1创建 DaemonSet资源对象<br>DaemonSet控制器的spec字段中嵌套使用的字段同样主要包了前面讲到的Pod控制器资源支持的selector、template 和minReadySeconds，并且功能和用法基本相同，但它不支持使用replicas，毕竟DaemonSet并不是基于期望的副本数来控制Pod资源数量，而是基于节点数量，但template是必选字段。<br>下面的资源清单文件（ filebeat-ds.yaml） 示例中定义了一个名为filebeat-ds的DaemonSet控制器，它将在每个节点上运行一个filebeat进程以收集容器相关的日志数据：</p>
<p>通过清单文件创建 DaemonSet 资源的命令 与其他资源的创建并无二致： ] kubectl apply -f filebeat-ds.yaml<br>daemonset.apps “filebeat-ds” created<br>自 Kubernetes 1.8 版本起， DaemonSet 也必须使用 selector 来匹配 Pod 模板中指定的标签，而且它也支持matchLabels 和 matchExpressions 两种标签选择器。<br>与其他资源对象相同，用户也可以使用 “ kubectl describe”命令查看 DaemonSet 对象的详细信息。下面命令的结果信息中， Node-Selector 字段的值为空， 表示它需要运行于集群中的每个节点之上。 而当前集群的节点数量为 3，因此， 其期望的 Pod 副本数（DesiredNumber of Nodes Scheduled）为 3， 而当前也已经成功创建了3个相关的 Pod对象：<br>] kubectl describe daemonsets  filebeat-ds Name:<br>filebeat-ds<br>Selector:<br>app=filebeat<br>Node-Selector:</p>
<p><none><br>Desired Number of Nodes Scheduled: 3<br>Current Number of Nodes Scheduled:3<br>Number of Nodes Scheduled with Up-to-date Pods: 3<br>Number of Nodes Scheduled with Available Pods: 3<br>Number of Nodes Misscheduled: 0<br>Pods Status: 3 Running / 0 Waiting / 0 Succeeded / 0 Failed<br>根据 DaemonSet 资源本身的意义， filebeat-ds 控制器成功创建的3个 Pod 对象应该分别运行于集群中的每个节点之上， 这一点可以通过如下命令进行验证：<br>] kubectl get pods -l app=filebeat \<br>-0 custom-columns=NAME:metadata. name,NODE:spec.nodeName<br>NAME<br>NODE<br>filebeat-ds-sjrvb<br>node01.ilinux.io<br>filebeat-ds-swd47<br>node03.ilinux.io<br>filebeat-ds-z7r97<br>node02.ilinux.io<br>集群中的部分工作节点偶尔也存在需要将 Pod 对象以单一实例形式运行的情况， 例如</none></p>
<p>对于拥有特殊硬件的节点来说，可能会需要为其运行特定的监控代理（agent）程序，等等。其实现方式与前面讲到的Pod资源的节点绑定机制类似，只需要在Pod模板的spec字段中嵌套使用nodeSelector字段，并确保其值定义的标签选择器与部分特定工作节点的标签匹配即可。<br>5.4.2更新DaemonSet对象<br>DaemonSet自Kubernetes 1.6版本起也开始支持更新机制，相关配置定义在spec.update- Strategy嵌套字段中。目前，它支持RollingUpdate（滚动更新）和OnDelete（删除时更新）两种更新策略，滚动更新为默认的更新策略，工作逻辑类似于Deployment控制，不过仅支持使用maxUnavailabe属性定义最大不可用Pod资源副本数（默认值为1），而删除时更新的方式则是在删除相应节点的Pod资源后重建并更新为新版本。<br>例如，将此前创建的filebeat-ds中Pod模板中的容器镜像升级为“ikubernetes/filebeat：5.6.6-alpine”，使用“kubectl set image”命令即可实现：<br>] kubectl set image daemonsets filebeat-ds filebeat=ikubernetes/filebeat:5.6.6- alpine<br>daemonset .apps “filebeat-ds” image updated<br>由下面命令的返回结果可以看出，filebeat-ds控制器Pod模板中的容器镜像文件已经完成更新，对滚动更新策略来说，它会自动触发更新操作。用户也可以通过filebeat-ds控制器的详细信息中的Events字段等来了解滚动更新的操作过程。由下面的命令结果可以看出，默认的滚动更新策略是一次删除一个工作节点上的Pod资源，待其新版本Pod资源重建完成后再开始操作另一个工作节点上的Pod资源：</p>
<p>必要时可以执行暂停和继续操作， 因此它也能够设计为金丝雀发布机制。 另外，故障的更新操作也可以进行回滚，包括回滚至 revision 历史记录中的任何一个指定的版本。 鉴于篇幅，这里不再给出其详细过程， 感兴趣的读者可参考Deployment 控制器的步骤测试其实现。<br>5.5 Job控制器<br>与 Deployment 及 DaemonSet 控制器管理的守护进程类的服务应用不同的是，Job控制器用于调配 Pod 对象运行一次性任务， 容器中的进程在正常运行结束后不会对其进行重启，而是将 Pod 对象置于“Completed”（完成） 状态。若容器中的进程因错误而终止， 则需要依配置确定重启与否，未运行完成的Pod 对象因其所在的节点故障而意外终 止后会被重新调度。Job控制器的 Pod 对象的状态转换如图 5-13所示。 </p>
<p>图5-13Job管理下Pod资源的运行方式<br>实践中，有的作业任务可能需要运行不止一次，用户可以配置它们以串行或并行的方式运行。总结起来，这种类型的Job控制器对象有两种，具体如下。<br>口单工作队列（work queue）的串行式Job：即以多个一次性的作业方式串行执行多次作业，直至满足期望的次数，如图5-14所示；这次Job也可以理解为并行度为1的作业执行方式，在某个时刻仅存在一个Pod资源对象。</p>
<p>图5-14串行式多任务<br>口多工作队列的并行式Job：这种方式可以设置工作队列数，即作业数，每个队列仅负责运行一个作业，如图5-15a所示；也可以用有限的工作队列运行较多的作业，即工作队列数少于总作业数，相当于运行多个串行作业队列。如图5-15b所示，工作队</p>
<p>图5-15多队列并行式多任务<br>Job 控制器常用于管理那些运行一段时间便可 “完成”的任务，例如计算或备份操作。<br>创建 Job对象<br>Job 控制器的 spec 字段内嵌的必要字段仅为 template，它的使用方式与 Deployment 等 控制器并无不同。 Job 会为其 Pod 对象自动添加“ job-name=JOB_NAME”和“controller- uid=UID”标签，并使用标签选择器完成对 controller-uid 标签的关联。需要注意的是， Job位于 API 群组“batch/v1”之内。 下面的资源清单文件（job-example.yaml） 中定义了一个Job 控制器：</p>
<p>注意Pod 模板中的 spec.restartPolicy 默认为 “Always”，这对 Job控制器来说并不适用，<br>因此必须在Pod模板中显式设定 restartPolicy 属性的值为“Never”或 “OnFailure”。使用“kubectl create”或“kubect1 apply” 命令完成创建后即可查看相关的任务状态，</p>
<p>器隅舜9Of明纽现S熙业串一普业‘年业4纱串Y1器胖舜9or平舞鵑闺孙智uo！aIduos’ods.骤班贸甚# ‘I 乐萬识恥月us！PIIIed’sds’科善丝#休<br>qorE排z’S’S<br>。.0，， K量业骅去骤卵去<br>InISSIDDnS 7骓‘貿斯关畔阴ogduexs-qo！”当否 u sqo！ 18 ！ooqnx，， 出承凿听‘阳打<br>pasat duos<br>T /0 6cog-<br>urexa-qc<br>94oauos<br>T/0 8DSD9-aTauexe-qo!<br>39V SidVISa snItis AQVEH<br>e- atdurexe-qof=aweu-qof t- spod 2a6 Iaoeqnxy [<br>..B-，， 5阳乒<br>器東盟質u IIP-MOuS—，近联出斛茸￥非判‘ 睢中命典. spod 18 I10aqn，，上业耳#‘罕乐paoiduos乐诉转唱靴摄pod‘当吊歌在骅共④业称期daaIs载‘当特f坠<br>:suotarduos isuo48Lauos :wsttottered :suoraegouuy</p>
<p><auou><br>aTdurexa -qo[=aueu-qo! actnaeszor o76 arr-Teat- i<br>”eu-4o<br>:sTagen stege 1 ：x07日TS : eoedsauren : eueN<br>qsJ0qe62D000-L926-89TI-T89T-J96bbe8b=P h-ettorguos qSFOqP620000-L926-88TT-T8I-F96285=PT0-xOTTOIRUOO<br>7Tnegep at durexe-qoc<br>a tdue exa-qof sqof qTIDsap<br>saoC actTsst T2aqnx [<br>v ern<br>i业听中首‘蓠些卵亟摄pod卵湿动I諾蚌裂剄些卵幽阐幽些查旦中貿影略期算<br>soz<br>butuung T/T 86so9 -aTdurexo-qo!<br>apy siavL Lsax saivis<br>aNVN<br>DV Suatusaa Slutus AGVad<br>aTduexa-qof=oueu-qof I- spod 2a5 T1Daqnx l ：湿刘些采蕊些乐牲&amp;器胖瀦9Of Y乘骐艱摄pOd卵关胖<br>eTdurex=-qof<br>aov Inassassas GaxT saa<br>wVN<br>1nassaDDns daarsad cNVN eTduexe-qof sqof 2a5 T?Deqnx [<br>：淼9or印骅祭在骅些挲的I0ISS3DOnS业‘ 吾孫齦摄pOd卵客！其聶睢些锋古adISaq</auou></p>
<p>在创建之后或者创建之前，可以于另一终端启动Pod资源的列出命令“kubectl get pods-1 job- name=job-multi —watch” 来监控其变动，以了解其执行过程。<br>.spec.parallelism能够定义作业执行的并行度，将其设置为2或者以上的值即可实现并行多队列作业运行。同时，如果.spec.completions使用的是默认值1，则表示并行度即作业总数，如图5-15a所示；而如果将.spec.completions属性值设置为大于.spec.parallelism 的属性值，则表示使用多队列串行任务作业模式，如图5-15b所示。例如，某Job控制器配置中的spec字段嵌套了如下属性，表示以2个队列并行的方式，总共运行5次的作业：<br>spec: completions:<br>parallelism:<br>5.5.3 Job扩容<br>Job控制器的.spec.parallelism 定义的并行度表示同时运行的Pod对象数，此属性值支持运行时调整从而改变其队列总数，实现扩容和缩容。使用的命令与此前的Deployment对象相同，即“kubectl scale —replicas”命令，例如在其运行过程中（未完成之前）将job-multi的并行度扩展为两路：<br>] kubectl scale jobs job-multi —replicas=2<br>job .apps “job-multi” scaled<br>执行命令后可以看到，其同时运行的Pod对象副本数量立即扩展到了两个：<br>] kubectl get pods -1 job-name=job-multi<br>VAME<br>READY<br>STATUS<br>RESTARTS AGE<br>:n<br>contsir<br>job-multi-c26rh 0/1 job-multi-tfj9k 1/1<br>ContainerCreating<br>Running<br>26s<br>根据工作节点及其资源可用量，适度提高Job的并行度，能够大大提升其完成效率，缩短运行时间。<br>5.5.4 删除Job<br>Job控制器待其Pod资源运行完成后，将不再占用系统资源。用户可按需保留或使用资源删除命令将其删除。不过，如果某Job控制器的容器应用总是无法正常结束运行，而其</p>
<p>restartPolicy又定为了重启，则它可能会一直处于不停地重启和错误的循环当中。所幸的是， Job控制器提供了两个属性用于抑制这种情况的发生，具体如下。<br>口.spec.activeDeadlineSeconds <integer> ： Job的deadline， 用于为其指定最大活动时间长度，超出此时长的作业将被终止。<br>口.spec.backofflimit <integer>：将作业标记为失败状态之前的重试次数，默认值为6。例如，下面的配置片断表示其失败重试的次数为5，并且如果超出100秒的时间仍未运行完成，那么其将被终止：<br>pec:n<br>backoffLimit: 5<br>activeDeadl ineSeconds: 100<br>ea<br>5.6 CronJob控制器<br>CronJob控制器用于管理Job控制器资源的运行时间。Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划（crontab） 的方式控制其运行的时间点及重复运行的方式，具体如下。<br>口在未来某时间点运行作业一次。<br>口在指定的时间点重复运行作业。<br>CronJob对象支持使用的时间格式类似于Crontab，略有不同的是，CronJob 控制器在指定的时间点时，“？” 和“*”的意义相同，都表示任何可用的有效值。<br>5.6.1创建 CronJob对象<br>CronJob控制器的spec字段可嵌套使用以下字段。<br>口jobTemplate <object>： Job控制器模板，用于为CronJob控制器生成Job对象；必选字段。<br>口schedule <string>： Cron格式的作业调度运行时间点；必选字段。<br>口concurrencyPolicy <string>：并发执行策略，可用值有“ Allow”（允许）、“Forbid”（禁止）和“Replace”（替换），用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业。<br>口failedJobHistoryLimit <integer>： 为失败的任务执行保留的历史记录数，默认为1。口successfulJosHistoryLimit <integer>：为成功的任务执行保留的历史记录数，默认为3。口startingDeadlineSeconds <integer> ：因各种原因缺乏执行作业的时间点所导致的启动作业错误的超时时长，会被记入错误历史记录。<br>口suspend <boolean> ：是否挂起后续的任务执行，默认为false， 对运行中的作业不会产生影响。</boolean></integer></integer></integer></string></string></object></integer></integer></p>
<p>下面是一个定义在资源清单文件（cronjob-example.yaml）中的CronJob资源对象示例，它每隔2分钟运行一次由jobTemplate定义的简单任务：</p>
<p>运行资源创建命令创建上述CronJob资源对象，而后再通过资源对象的相关信息了解运行状态。下面命令结果中的SCHEDULE是指其调度时间点，SUSPEND表示后续任务是否处于挂起状态，即暂停任务的调度和运行，ACTIVE表示活动状态的Job对象的数量，而LAST SCHEDULE则表示上次调度运行至此刻的时长：<br>1.8起，CronJob资源所在的API资源组从batch/v2alpha1移至batch/<br>v1beta1中，并且查看其资源格式时也要使用—api-version选项指定其所在的资源组， 即“kubectl explain cronjob —api-version=’batch/vlbetal’”。<br>5.6.2CronJob的控制机制<br>CronJob控制器是一个更高级别的资源，它以Job控制器资源为其管控对象，并借助它管理Pod资源对象。因此，要使用类似如下命令来查看某CronJob控制器创建的Job资源</p>
<p>对象，其中的标签“mycronjob-jobs”是在创建cronjob-example时为其指定。不过，只有相关的Job对象被调度执行时，此命令才能将其正常列出。可列出的Job对象的数量取决于CronJob资源的.spec.succesfulJobsHistoryLimit的属性值，默认为3。<br>] kubectl get jobs -1 app=mycronjob-jobs<br>NAME<br>DESIRED sucCESSFUL AGE<br>cronjob-example- 1520057880 cnone&gt;<br>croniob- example- 1520058000 s none&gt;<br>2n<br>c工onoD-exanpt-上s：<br>UUS8UUU <none><br>cronjob- example- 1520058120 <none><br>如果作业重复执行时指定的时间点较近，而作业执行时长（普遍或偶尔）跨过了其两次执行的时间长度，则会出现两个Job对象同时存在的情形。有些Job对象可能会存在无法或不能同时运行的情况，这个时候就要通过.spec.concurrencyPolicy属性控制作业并存的机制，其默认值为“ Allow”，即允许前后Job，甚至属于同一个CronJob的更多Job同时运行。其他两个可用值中，“Forbid”用于禁止前后两个Job同时运行，如果前一个尚未结束，后一个则不予启动（跳过），“Replace”用于让后一个Job取代前一个，即终止前一个并启动后<br>5.7 ReplicationController<br>ReplicationController （简称rc或RC）是Kubernetes较早实现的Pod控制器，用于确保Pod资源的不间断运行。不过，Kubernetes 后来设计了ReplicaSet 及其更高一级的控制器Deployment来取ReplicationController，并表示在后来的版本中可能会废弃RC。因此，这里不再对ReplicationController 做过多的介绍。事实上，它的使用方式与ReplicaSet相同，一旦用到时，绝大多数操作都可以迁移使用，感兴趣的读者可以自行测试。<br>5.8 Pod 中断预算<br>尽管Deployment或ReplicaSet一类的控制器能够确保相应Pod对象的副本数量不断逼近期望的数量，但它却无法保证在某一时刻一定会存在指定数量或比例的Pod对象，然而这种需求在某些强调服务可用性的场景中却是必备的。于是，Kubernetes自1.4版本起开始引入Pod中断预算（ PodDisruptionBudget，简称PDB）类型的资源，用于为那些自愿的（ Voluntary） 中断做好预算方案（ Budget）， 限制可自愿中断的最大Pod副本数或确保最少可用的Pod副本数，以确保服务的高可用性。<br>Pod对象会一直存在，除非有意将其销毁，或者出现了不可避免的硬件或系统软件错误。非自愿中断是指那些由不可控外界因素导致的Pod中断退出操作，例如，硬件或系统内核故障、网络故障以及节点资源不足导致Pod对象被驱逐等；而那些由用户特地执行的管理操作导致的Pod中断则称为“自愿中断”，例如排空节点、人为删除Pod对象、由更新操</none></none></p>
<p>作触发的Pod对象重建等。部署在Kubernetes的每个应用程序都可以创建一个对应的PDB对象以限制自愿中断时最大可以中断的副本数或者最少应该保持可用的副本数，从而保证应用自身的高可用性。<br>PDB资源可以用来保护由控制器管理的应用，此时几乎必然意味着PDB使用等同于相关控制器对象的标签选择器以精确关联至目标Pod对象，支持的控制器类型包括Deployment、ReplicaSet和StatefulSet等。同时，PDB对象也可以用来保护那些纯粹是由定制的标签选择器自由选择的Pod对象。<br>定义PDB资源时，其spec字段主要嵌套使用以下三个字段。<br>D selector <object>：当前PDB对象使用的标签选择器，一般是与相关的Pod控制器使用同一个选择器。<br>O minAvailable <string>：Pod自愿中断的场景中，至少要保证可用的Pod对象数量或比例，要阻止任何Pod对象发生自愿中断，可将其设置为100%。<br>D maxUnavailable <string>：Pod自愿中断的场景中，最多可转换为不可用状态的Pod对象数量或比例，0值意味着不允许Pod对象进行自愿中断；此字段与minAvailable互斥。<br>下面的示例定义了一个PDB对象，它对5.3.1节中由Deployment控制器myapp-deploy创建的Pod对象设置了Pod中断预算，要求其最少可用的Pod对象数量为2个：<br>apiVersion: policy/v1beta1 kind: PodDisruptionBudget metadata:<br>name: myapp-pdb<br>spec:<br>minAvailable: 2<br>selector:<br>matchLabels:<br>app:myapp<br>PDB资源对象创建完成后，在它的简要信息输出中也标明了最少可用的Pod对象个数， 以及允许中断的Pod对象个数：<br>] kubectl get pdb<br>NAME<br>MIN AVAILABLE MAX UNAVAILABLE  ALLOWED DISRUPTIONS AGE<br>myapp-pdb 2<br>N/A<br>1<br>24s<br>接下来可通过命令手动删除myapp-deploy控制器下的所有Pod对象模拟自愿中断过程，并监控各Pod对象被终止的过程来验证PDB资源对象的控制功效。<br>5.9 本章小结<br>本章主要讲解了Kubernetes的Pod控制器，它们是“工作负载”类资源的核心组成部</string></string></object></p>
<p>分，是基于Kubernetes运行应用的最重要的资源类型之一，具体如下。<br>口工作负载类型的控制器根据业务需求管控Pod资源的生命周期。<br>口 ReplicaSet可以确保守护进程型的Pod资源始终具有精确的、处于运行状态的副本数量，并支持Pod规模的伸缩机制；它是新一代的ReplicationController控制器，不过用户通常不应该直接使用ReplicaSet，而是要使用Deployment。<br>口 Deployment是建构在ReplicaSet上的更加抽象的工作负载型控制器，支持多种更新策略及发布机制。<br>口Job控制器能够控制相应的作业任务得以正常完成并退出，支持并行式多任务。<br>口 CronJob控制器用于控制周期性作业任务，其功能类似于Linux操作系统上的Crontab。<br>口 PodDisruptionBudget资源对象为Kubernetes系统上的容器化应用提供了高可用能力。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes进阶实战/" rel="tag"># Kubernetes进阶实战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/06/第4章-管理Pod资源对象/" rel="next" title="第4章 管理Pod资源对象">
                <i class="fa fa-chevron-left"></i> 第4章 管理Pod资源对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/06/第6章-Service和Ingress/" rel="prev" title="第6章 Service和Ingress">
                第6章 Service和Ingress <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">学如逆水行舟，不进则退</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">821</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">62</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2022/12/06/25-运筹帷幄-协程的运行机制与调度器原理/" title="25 | 运筹帷幄: 协程的运行机制与调度器原理" target="_blank">25 | 运筹帷幄: 协程的运行机制与调度器原理</a>
                  </li>
                
                  <li>
                    <a href="/2022/12/06/24｜日志处理：日志规范与最佳实践/" title="24｜日志处理：日志规范与最佳实践" target="_blank">24｜日志处理：日志规范与最佳实践</a>
                  </li>
                
                  <li>
                    <a href="/2022/12/01/23｜偷梁换柱：为爬虫安上代理的翅膀/" title="23｜偷梁换柱：为爬虫安上代理的翅膀" target="_blank">23｜偷梁换柱：为爬虫安上代理的翅膀</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/29/22｜优雅的离场-Context超时控制与原理/" title="22｜优雅的离场：Context超时控制与原理" target="_blank">22｜优雅的离场：Context超时控制与原理</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/26/21｜采集引擎：实战接口抽象与模拟浏览器访问/" title="21｜采集引擎：实战接口抽象与模拟浏览器访问" target="_blank">21｜采集引擎：实战接口抽象与模拟浏览器访问</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">7.1m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">108:15</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
