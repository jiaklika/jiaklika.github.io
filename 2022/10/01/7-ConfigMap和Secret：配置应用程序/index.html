<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Kubernetes in Action">
<meta property="og:type" content="article">
<meta property="og:title" content="7-ConfigMap和Secret：配置应用程序">
<meta property="og:url" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/2.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/3.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/4.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/5.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/6.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/7.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/8.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/10.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/11.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/12.png">
<meta property="og:updated_time" content="2022-10-01T07:48:12.560Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7-ConfigMap和Secret：配置应用程序">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/2.png">






  <link rel="canonical" href="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>7-ConfigMap和Secret：配置应用程序 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/01/7-ConfigMap和Secret：配置应用程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="学如逆水行舟，不进则退">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">7-ConfigMap和Secret：配置应用程序

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-10-01 09:59:15 / 修改时间：15:48:12" itemprop="dateCreated datePublished" datetime="2022-10-01T09:59:15+08:00">2022-10-01</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>【本章内容涵盖】</p>
<ul>
<li>更改容器的主进程</li>
<li>将命令行选项传递给应用程序</li>
<li>设置暴露给应用程序的环境变量</li>
<li>通过ConfigMap配置应用程序</li>
<li>通过Secret传递敏感配置信息</li>
</ul>
<p>到目前为止尚未传递过任何配置数据给本书示例中的应用。几乎所有的应用都需要配置信息（不同部署示例间的区分设置、访问外部系统的证书等），并且这些配置数据不应该被嵌入应用本身。让我们来看一下如何传递配置选项给运行在Kubernetes上的应用程序。</p>
<h1 id="配置容器化应用程序"><a href="#配置容器化应用程序" class="headerlink" title="配置容器化应用程序"></a>配置容器化应用程序</h1><p>回顾如何传递配置数据给运行在Kubernetes中的应用程序之前，首先来看一下容器化应用通常是如何被配置的。</p>
<p>开发一款新应用程序的初期，除了将配置嵌入应用本身，通常会以命令行参数的形式配置应用。随着配置选项数量的逐渐增多，将配置文件化。</p>
<p>另一种通用的传递配置选项给容器化应用程序的方法是借助环境变量。应用程序主动查找某一特定环境变量的值，而非读取配置文件或者解析命令行参数。例如，MySQL官方镜像内部通过环境变量MYSQLROOTPASSWORD设置超级用户root的密码。</p>
<p>为何环境变量的方案会在容器环境下如此常见？通常直接在Docker容器中采用配置文件的方式是有些许困难的，往往需要将配置文件打入容器镜像，抑或是挂载包含该文件的卷。显然，前者类似于在应用程序源代码中硬编码配置，每次修改完配置之后需要重新构建镜像。除此之外，任何拥有镜像访问权限的人可以看到配置文件中包含的敏感信息，如证书和密钥。相比之下，挂载卷的方式更好，然而在容器启动之前需确保配置文件已写入响应的卷中。</p>
<p>如果你已经阅读过前面的章节，可能会想到采用gitRepo卷作为配置源。这并不是一个坏主意，通过它可以保持配置的版本化，并且能比较容易地按需回滚配置。然而有一种更加简便的方法能将配置数据置于Kubermetes的顶级资源对象中，并可与其他资源定义存入同一Git仓库或者基于文件的存储系统中。用以存储配置数据的Kubernetes资源称为ConfigMap。我们将会在本章学习如何使用它。</p>
<p>无论你是否在使用ConfigMap存储配置数据，以下方法均可被用作配置你的应用程序；</p>
<ul>
<li>向容器传递命令行参数</li>
<li>为每个容器设置自定义环境变量</li>
<li>通过特殊类型的卷将配置文件挂载到容器中</li>
</ul>
<p>接下来的几节中将会介绍这些方法。开始介绍之前，首先从安全角度观察一下配置选项。尽管绝大多数配置选项并未包含敏感信息，少量配置依旧可能含有证书、私钥，以及其他需要保持安全的相似数据。该类型数据需要被特殊对待。这也是为何Kubernetes提供另一种称作Secret的一级对象的原因。我们将在本章节末尾学习到它。</p>
<h1 id="向容器传递命令行参数"><a href="#向容器传递命令行参数" class="headerlink" title="向容器传递命令行参数"></a>向容器传递命令行参数</h1><p>迄今为止所有示例中容器运行的命令都是镜像中默认定义的。Kubernetes可在pod的容器中定义并覆盖命令以满足运行不同的可执行程序，或者是以不同的命令Kubemetes可在pod的容器中定义并覆盖命令来运行不同的可执行程序，或者是以不同的命令行参数集运行。现在我们来看一下应该如何操作。</p>
<h2 id="在Docker中定义命令与参数"><a href="#在Docker中定义命令与参数" class="headerlink" title="在Docker中定义命令与参数"></a>在Docker中定义命令与参数</h2><p>首先需要阐明的是，容器中运行的完整指令由两部分组成：命令与参数。</p>
<p>了解ENTRYPOINT与CMD</p>
<p>Dockerfle中的两种指令分别定义命令与参数这两个部分：</p>
<ul>
<li>ENTRYPOINT定义容器启动时被调用的可执行程序。</li>
<li>CMD指定传递给ENTRYPOINT的参数。</li>
</ul>
<p>尽管可以直接使用CMD指令指定镜像运行时想要执行的命令，正确的做法依旧是借助ENTRYPOINT指令，仅仅用CMD指定所需的默认参数。这样，镜像可以直接运行，无须添加任何参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run &lt;image&gt;</span><br></pre></td></tr></table></figure></p>
<p>或者是添加一些参数，覆盖Dockerile中任何由CMD指定的默认参数值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> run &lt;image&gt; &lt;arguments&gt;</span><br></pre></td></tr></table></figure></p>
<p>了解shell与exec形式的区别</p>
<p>上述两条指令均支持以下两种形式：</p>
<ul>
<li>shell形式一如ENTRYPOINTnodeapp.js。</li>
<li>exec形式一如ENTRYPOINT[“node”，”app.js”].</li>
</ul>
<p>两者的区别在于指定的命令是否是在shell中被调用。</p>
<p>对于第2章中创建的kubia镜像，如果使用exec形式的ENTRYPOINT指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT[<span class="string">"node"</span>,<span class="string">"app.js"</span>]</span><br></pre></td></tr></table></figure></p>
<p>可以从容器中的运行进程列表看出：这里是直接运行node进程，而并非在shell中执行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dockerexec4675dPBx</span><br><span class="line">PIDTTYSTATTIMECOMMAND</span><br><span class="line">ssl0:00nodeapp.js</span><br><span class="line">12?</span><br><span class="line">o:00psx</span><br><span class="line">00PS2</span><br></pre></td></tr></table></figure></p>
<p>如果采用shell形式（ENTRYPOINTnodeapp.js），容器进程如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dockerexec-ite4badps2</span><br><span class="line">PIDTTYSTATTIMBcOMMAND</span><br><span class="line">1?ss0:00/bin/sh-cnodeapp.js</span><br><span class="line">o:00node</span><br><span class="line">0:00nodeaPP.js13?Rs+</span><br><span class="line">0:00psX</span><br></pre></td></tr></table></figure></p>
<p>可以看出，主进程（PID1）是shell进程而非node进程，node进程（PID7）于shell中启动。shell进程往往是多余的，因此通常可以直接采用exec形式的ENTRYPOINT指令。</p>
<p>可配置化fortune镜像中的间隔参数</p>
<p>让我们通过修改fortune脚本与镜像Dockerfle使循环的延迟间隔可配置。如下面这段代码所示，在fortune脚本中添加VARIABLE变量并用第一个命令行参数对其初始化。</p>
<blockquote>
<p>代码清单7.1 通过参数可配置化fortune脚本中的循环间隔：fortune-argslfortuneloop.sh</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">trap</span><span class="string">"exituSIGINr</span></span><br><span class="line"><span class="string">INTERVAL=<span class="variable">$1</span></span></span><br><span class="line"><span class="string">echoConfiguredtogeneratenewfortuneevery<span class="variable">$INTERVALseconds</span></span></span><br><span class="line"><span class="string">mkdir-p/var/htdocs</span></span><br><span class="line"><span class="string">while:</span></span><br><span class="line"><span class="string">dc</span></span><br><span class="line"><span class="string">echo<span class="variable">$(date)</span>Writingfortuneto/var/htdocs/index.html</span></span><br><span class="line"><span class="string">/usr/games/fortune&gt;/var/htdocs/index.html</span></span><br><span class="line"><span class="string">gleep<span class="variable">$INTERVAL</span></span></span><br><span class="line"><span class="string">done</span></span><br></pre></td></tr></table></figure>
<p>你应该已经添加或修改了以粗体显示行。现在修改Dockerfile，采用exec形式的ENTRYPOINT指令，以及利用CMD设置间隔的默认值为10，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.2修改fortune镜像的Dockerfile：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fortune-args/Dockerile</span><br><span class="line">FROMubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span>形式的ENTRYPOIN指令</span><br><span class="line">RUNapt-getupdate;apt-get-yinstallfortuneADDfortuneloop.sh/bin/fortuneloop.sh</span><br><span class="line">可执行程序的默认参数</span><br><span class="line">ENTRYPOINT[<span class="string">"/bin/fortuneloop.sh"</span>]</span><br><span class="line">CMD[<span class="string">"10"</span>]</span><br></pre></td></tr></table></figure>
<p>现在可以重新构建镜像并推送至DockerHub。这里将镜像的tag由latest修改为args：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$dockerbuild-tdocker.io/luksa/fortune:argg$dockerpushdocker.io/luksa/fortune:arga</span><br></pre></td></tr></table></figure></p>
<p>可以用Docker在本地启动该镜像并进行测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$dockerrun</span>-itdocker.io/luksa/fortune:args</span><br><span class="line">Configuredtogeneratenewfortuneeveryloseconds</span><br><span class="line">FriMay1910:39:44UrC2017Writingfortuneto/var/htdocs/index.html</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 可以通过Ctrl+C组合键来停止脚本。</p>
</blockquote>
<p>也可以传递一个间隔参数覆盖默认睡眠间隔值：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$dockerrun</span>-itdocker.io/luksa/fortune:args15</span><br><span class="line">Configuredtogeneratenewfortuneevery15seconds</span><br></pre></td></tr></table></figure></p>
<p>现在可以确保镜像能够正确应用传递给它的参数。让我们来看一下在pod中如何使用它。</p>
<h2 id="在Kubernetes中覆盖命令和参数"><a href="#在Kubernetes中覆盖命令和参数" class="headerlink" title="在Kubernetes中覆盖命令和参数"></a>在Kubernetes中覆盖命令和参数</h2><p>在Kubernetes中定义容器时，镜像的ENTRYPOINT和CMD均可以被覆盖，仅需在容器定义中设置属性command和args的值，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.3 指定自定义命令与参数的pod定义</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kind:Pod</span><br><span class="line">spec:</span><br><span class="line">containers:</span><br><span class="line">-image:some/image</span><br><span class="line"><span class="built_in">command</span>:[<span class="string">"/bin/command"</span>]</span><br><span class="line">args:[<span class="string">"arg1"</span>,<span class="string">"arg2"</span>,<span class="string">"arg3"</span>]</span><br></pre></td></tr></table></figure>
<p>绝大多数情况下，只需要设置自定义参数。命令一般很少被覆盖，除非针对一些未定义ENTRYPOINT的通用镜像，例如busybox。</p>
<blockquote>
<p>注意 command和args字段在pod创建后无法被修改。</p>
</blockquote>
<p>上述的两条Dockerfile指令与等同的pod规格字段如表7.1所示。</p>
<blockquote>
<p>表7.1在 Docker与Kubernetes中指定可执行程序及其参数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong><center>Docker</center></strong></th>
<th style="text-align:left"><strong><center>Kubernetes</center></strong></th>
<th style="text-align:left"><strong><center>描述</center></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ENTRYPOINT</td>
<td style="text-align:left">command</td>
<td style="text-align:left">容器中运行的可执行文件</td>
</tr>
<tr>
<td style="text-align:left">CMD</td>
<td style="text-align:left">args</td>
<td style="text-align:left">传给可执行文件的参数</td>
</tr>
</tbody>
</table>
</div>
<p>用自定义间隔值运行fortunepod</p>
<p>为了能够用自定义的延迟间隔值运行fortunepod，首先复制文件fortune-pod.yaml并重命名为fortune-pod-args.yaml，然后修改它，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.4 在pod定义中传递参数值：fortune-pod_args.yaml</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiversion:v1</span><br><span class="line"></span><br><span class="line">kind:Pod</span><br><span class="line">metadata:</span><br><span class="line">修改pod名称</span><br><span class="line">name:fortune2g</span><br><span class="line">。</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">fortune：latest替换为fortune:args</span><br><span class="line">containers:</span><br><span class="line">-image:luksa/fortune:arggarg8:[<span class="string">"2"</span>]</span><br><span class="line">该参数值使得脚本每隔两秒生成一个新fortune</span><br><span class="line">name:html-generatorvolumeMounts:</span><br><span class="line">-name:html</span><br><span class="line">mountPath:/var/htdocs</span><br></pre></td></tr></table></figure>
<p>现在你已经在容器定义中添加了args数组参数，可以尝试创建该pod。数组值会在pod运行时作为命令行参数传递给容器。</p>
<p>少量参数值的设置可以使用上述的数组表示。多参数值情况下可以采用如下标记：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args:_foo-bar1151</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示 字符串值无须用引号标记，数值需要。</p>
</blockquote>
<p>通过命令行参数指定参数值是给容器传递配置选项的其中一种手段。接下来将学习如何通过环境变量完成配置。</p>
<h1 id="为容器设置环境变量"><a href="#为容器设置环境变量" class="headerlink" title="为容器设置环境变量"></a>为容器设置环境变量</h1><p>如前所述，容器化应用通常会使用环境变量作为配置源。Kubemetes允许为pod中的每一个容器都指定自定义的环境变量集合，如图7.1所示。尽管从pod层面定义环境变量同样有效，然而当前并未提供该选项。</p>
<blockquote>
<p>注意 与容器的命令和参数设置相同，环境变量列表无法在pod创建后被修改。</p>
</blockquote>
<p>通过环境变量配置化fortune镜像中的间隔值</p>
<p>让我们再来看一下如何通过环境变量使fortuneloop.sh脚本中的睡眠间隔值可配置化，具体如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.5 通过环境变量配置化fortune脚本中的间隔值：fortuneenv/<br>fortuneloop.sh</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/b1n/bash</span></span><br><span class="line"><span class="built_in">trap</span><span class="string">"exit"</span>sIGINT</span><br><span class="line">echoConfiguredtogeneratenewfortuneevery<span class="variable">$INTERVALsecondsmkdir</span>-p/var/htdocs</span><br><span class="line">IRCLE</span><br><span class="line">ar/htdocs</span><br><span class="line"><span class="keyword">while</span></span><br><span class="line">lo</span><br><span class="line"><span class="built_in">echo</span>$(date)writingfortuneto/var/htdocs/index.html</span><br><span class="line">/usr/games/fortune&gt;&gt;/var/ncaocsr1naex.nctm-</span><br><span class="line">/var/htdocs/index.html</span><br><span class="line">alcensTNmRRyAT.</span><br><span class="line">sleepSINTERVAI</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>当前的应用仅是一个简单的bash脚本，只需要移除脚本中INTERVAL初始化所在的行即可。如果应用由Java编写，需要使用System.getenv（“INTERVAL”），同样地，对应到Node.JS与Python中分别是process.env.INTERVAL与os.environ[‘INTERVAL’]。</p>
<h2 id="在容器定义中指定环境变量"><a href="#在容器定义中指定环境变量" class="headerlink" title="在容器定义中指定环境变量"></a>在容器定义中指定环境变量</h2><p>构建完新镜像（镜像的tag变更为luksa/fortune：env）并推送至DockerHub之后，可以通过创建一个新pod来运行它。如下面的代码清单所示，在容器定义中写，入环境变量以传递给脚本。</p>
<blockquote>
<p>代码清单7.6 在pod中指定环境变量：fortunepodenv.yaml</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kind:Pod</span><br><span class="line">Spec:,</span><br><span class="line">containers:</span><br><span class="line">image:luksa/fortune:env</span><br><span class="line">在环境变量列表中添</span><br><span class="line">-name:INTBRVAL</span><br><span class="line">加一个新变量</span><br><span class="line">value:<span class="string">"30"</span></span><br><span class="line">name:html-generator</span><br></pre></td></tr></table></figure>
<p>正如前面提到的，环境变量被设置在pod的容器定义中，并非是pod级别。</p>
<p>注意不要忘记在每个容器中，Kubemetes会自动暴露相同命名空间下每个service对应的环境变量。这些环境变量基本上可以被看作自动注入的配置。</p>
<h2 id="在环境变量值中引用其他环境变量"><a href="#在环境变量值中引用其他环境变量" class="headerlink" title="在环境变量值中引用其他环境变量"></a>在环境变量值中引用其他环境变量</h2><p>在前面的示例中，环境变量的值是固定的。可以采用$（VAR）语法在环境变量值中引用其他的环境变量。假设定义了两个环境变量，第二个变量定义中可包含第一个环境变量的值，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.7 在环境变量值中引用另一个变量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">env:</span><br><span class="line">-name:FIRST_VAR</span><br><span class="line">value:<span class="string">"foo"</span></span><br><span class="line">-name:SECOND_VAR</span><br><span class="line">value:<span class="string">"<span class="variable">$(FIRST_VAR)</span>bar"</span></span><br></pre></td></tr></table></figure>
<p>SECOND_VAR的值是”foobar”。7.2节中介绍的command和args属性值同样可以像这样引用环境变量，这将在7.4.5节中被使用到。</p>
<h2 id="了解硬编码环境变量的不足之处"><a href="#了解硬编码环境变量的不足之处" class="headerlink" title="了解硬编码环境变量的不足之处"></a>了解硬编码环境变量的不足之处</h2><p>pod定义硬编码意味着需要有效区分生产环境与开发过程中的pod定义。为了能在多个环境下复用pod的定义，需要将配置从pod定义描述中解耦出来。幸运的是，你可以通过一种叫作ConfigMap的资源对象完成解耦，用valueFrom字段替代value字段使ConfigMap成为环境变量值的来源。接下来将学习到这一用法。</p>
<h1 id="利用ConfigMap解耦配置"><a href="#利用ConfigMap解耦配置" class="headerlink" title="利用ConfigMap解耦配置"></a>利用ConfigMap解耦配置</h1><p>应用配置的关键在于能够在多个环境中区分配置选项，将配置从应用程序源码中分离，可频繁变更配置值。如果将pod定义描述看作是应用程序源代码，显然需要将配置移出pod定义。微服务架构下正是如此，该架构定义了如何将多个个体组件组合成功能系统。</p>
<h2 id="ConfigMap介绍"><a href="#ConfigMap介绍" class="headerlink" title="ConfigMap介绍"></a>ConfigMap介绍</h2><p>Kubernetes允许将配置选项分离到单独的资源对象ConfigMap中，本质上就是一个键/值对映射，值可以是短字面量，也可以是完整的配置文件。</p>
<p>应用无须直接读取ConfigMap，甚至根本不需要知道其是否存在。映射的内容通过环境变量或者卷文件（如图7.2所示）的形式传递给容器，而并非直接传递给容器。命令行参数的定义中可以通过$（ENV_VAR）语法引用环境变量，因而可以达到将ConfigMap的条目当作命令行参数传递给进程的效果。</p>
<blockquote>
<p>图7.2 pod通过环境变量与ConfigMap卷使用ConfigMap</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/2.png">
<p>当然，应用程序同样可以通过KubernetesRestAPI按需直接读取ConfigMap的内容。不过除非是需求如此，应尽可能使你的应用保持对Kubernetes的无感知。<br>不管应用具体是如何使用ConfigMap的，将配置存放在独立的资源对象中有助于在不同环境（开发、测试、质量保障和生产等，下拥有多份同名配置清单。pod是通过名称引用ConfigMap的，因此可以在多环境下使用相同的pod定义描述，同时保持不同的配置值以适应不同环境（如图7.3所示）。</p>
<blockquote>
<p>图7.3 同环境下的同名ConfigMap</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/3.png">
<h2 id="创建ConfigMap"><a href="#创建ConfigMap" class="headerlink" title="创建ConfigMap"></a>创建ConfigMap</h2><p>了解一下如何在pod中使用ConfigMap。首先从最简单的例子开始，先创建一个仅包含单一键的映射，并用它填充之前示例中的环境变量INTERVAL。这里将使用指令kubectlcreateconfigmap创建ConfigMap，而非通用指令kubectlcreate-f。</p>
<p>使用指令kubectl创建ConfigMap</p>
<p>利用kubectl创建ConfigMap的映射条目时可以指定字面量或者存储在磁盘上的文件。先创建一个简单的字面量条目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlcreateconfigmapfortune</span>-config--from-literal=sleep-interval=25configmap<span class="string">"fortune-config"</span>created</span><br></pre></td></tr></table></figure></p>
<p>注意ConfigMap中的键名必须是一个合法的DNS子域，仅包含数字字母、破折号、下画线以及圆点。首位的圆点符号是可选的。</p>
<p>通过这条命令创建了一个叫作fortune-config的ConfigMap，仅包含单映射条目sleep-interval=25（如图7.4所示）。</p>
<blockquote>
<p>图7.4 ConfigMapfortune-config包含单映射条目</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/4.png">
<p>ConfigMap一般包含多个映射条目。通过添加多个—from-literal参数可创建包含多条目的ConfigMap：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlcreateconfigmapmyconfigmap</span></span><br><span class="line">》--from-literal=foo=bar--from-literal=bar=baz--from-literal=one=two</span><br></pre></td></tr></table></figure></p>
<p>让我们观察一下通过kubectl创建的ConfigMap的YAML格式的定义描述，如下所示。</p>
<blockquote>
<p>代码清单7.8 ConfigMap定义</p>
</blockquote>
<p>这没有什么特别的。编写这个YAML文件很容易，除了metadata中的名称无须指定其他字段，然后通过KubernetesAPI创建对应的ConfigMap：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlcreate</span>-ffortune-config.yaml</span><br></pre></td></tr></table></figure></p>
<p>从文件内容创建ConfigMap条目</p>
<p>ConfigMap同样可以存储粗粒度的配置数据，比如完整的配置文件。kubectlcreateconfigmap命令支持从磁盘上读取文件，并将文件内容单独存储为ConfigMap中的条目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlcreateconfigmapmy</span>-config--from-file=config-file.conf</span><br></pre></td></tr></table></figure></p>
<p>运行上述命令时，kubectl会在当前目录下查找config-file.conf文件，并将文件内容存储在ConfigMap中以config-file.conf为键名的条目下。当然也可以手动指定键名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlcreateconfigmapmy</span>-config--from-file=customkey=config-file.conf</span><br></pre></td></tr></table></figure></p>
<p>这条命令会将文件内容存在键名为customkey的条目下。与使用字面量时相同，多次使用—from-file参数可增加多个文件条目。</p>
<p>从文件夹创建ConfigMap</p>
<p>除单独引入每个文件外，甚至可以引入某一文件夹中的所有文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubect1createconfigmapmy</span>-config--from-file=/path/to/dir</span><br></pre></td></tr></table></figure></p>
<p>这种情况下，kubectl会为文件夹中的每个文件单独创建条目，仅限于那些文件名可作为合法ConfigMap键名的文件。</p>
<p>合并不同选项</p>
<p>创建ConfigMap时可以混合使用这里提到的所有选项（注意这里的文件并未包含在本书的代码归档中一如果想要尝试这条命令需自行创建）：</p>
<p>这里的ConfigMap创建自多种选项：完整文件夹、单独文件、自定义键名的条目下的文件（替代文件名作键名）以及字面量。图7.5显示了所有源选项以及最终的ConfigMap。</p>
<blockquote>
<p>图7.5 从文件、文件夹以及字面量创建ConfigMap</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/5.png">
<h2 id="给容器传递ConfigMap条目作为环境变量"><a href="#给容器传递ConfigMap条目作为环境变量" class="headerlink" title="给容器传递ConfigMap条目作为环境变量"></a>给容器传递ConfigMap条目作为环境变量</h2><p>如何将映射中的值传递给pod的容器？有三种方法。首先尝试最为简单的一种一设置环境变量，将会使用到7.5.3节中提到的valueFrom字段。pod的定义描述如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.9 通过配置文件注入环境变量的pod：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fortune-pod-env-configmap.yaml</span><br></pre></td></tr></table></figure>
<p>这里定义了一个环境变量INTERVAL，并将其值设置为fortune-configConfigMap中键名为sleep-interval对应的值。运行在html-generator容器中的进程读取到环境变量INTERVAL的值为25（如图7.6所示）。</p>
<blockquote>
<p>图7.6 给容器的环境变量传递ConfigMap的条目</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/6.png">
<p>在pod中引用不存在的ConfigMap</p>
<p>你可能会好奇如果创建pod时引用的ConfgMap不存在会发生什么？Kubernetes会正常调度pod并尝试运行所有的容器。然而引用不存在的ConfigMap的容器会启动失败，其余容器能正常启动。如果之后创建了这个缺失的ConfigMap，失败容器会自动启动，无须重新创建pod。</p>
<blockquote>
<p>注意 可以标记对ConfigMap的引用是可选的（设置configMapKeyRef.optional：true）。这样，即便ConfigMap不存在，容器也能正常启动。</p>
</blockquote>
<p>这个例子展示了如何将配置从pod定义中分离。这样能使所有的配置项较为集中（甚至多个pod也是如此），而不是分散在各处（或者冗余复制于多个pod定义清单）。</p>
<h2 id="一次性传递ConfigMap的所有条目作为环境变量"><a href="#一次性传递ConfigMap的所有条目作为环境变量" class="headerlink" title="一次性传递ConfigMap的所有条目作为环境变量"></a>一次性传递ConfigMap的所有条目作为环境变量</h2><p>如果ConfigMap包含不少条目，为每个条目单独设置环境变量的过程是单调乏味且容易出错的。幸运的是，1.6版本的Kubernetes提供了暴露ConfigMap的所有条目作为环境变量的手段。</p>
<p>假设一个ConfigMap包含FOO、BAR和FOO-BAR三个键。可以通过envFrom属性字段将所有条目暴露作为环境变量，而非使用前面例子中的env字段。示例代码如下所示。</p>
<blockquote>
<p>代码清单7.10 pod包含来源于ConfigMap所有条目的环境变量</p>
</blockquote>
<p>如你所见，可以为所有的环境变量设置前缀，如本例中的CONFIG_，容器中两个环境变量的名称为：CONFIG_FO0与CONFIG_BAR。</p>
<blockquote>
<p>注意 前缀设置是可选的，若不设置前缀值，环境变量的名称与ConfigMap中的键名相同。</p>
</blockquote>
<p>是否注意到前面说的是两个环境变量，然而ConfigMap拥有三个条目（F0O、BAR和FOO-BAR）？为何没有对应FOO-BAR条目的环境变量呢？</p>
<p>原因在于CONFIGFOO-BAR包含破折号，这并不是一个合法的环境变量名称。Kubernetes不会主动转换键名（例如不会将破折号转换为下画线）。如果ConfigMap的某键名格式不正确，创建环境变量时会忽略对应的条目（忽略时不会发出事件通知）。</p>
<h2 id="传递ConfigMap条目作为命令行参数"><a href="#传递ConfigMap条目作为命令行参数" class="headerlink" title="传递ConfigMap条目作为命令行参数"></a>传递ConfigMap条目作为命令行参数</h2><p>现在让我们来看一下如何将ConfigMap中的值作为参数值传递给运行在容器中的主进程。在字段pod.spec.containers.args中无法直接引用ConfigMap的条目，但是可以利用ConfigMap条目初始化某个环境变量，然后再在参数字段中引用该环境变量，具体如图7.7所示。</p>
<blockquote>
<p>图7.7传递ConfigMap的条目作为命令行参数</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/7.png">
<p>代码清单7.11展示了如何在YAML文件中做到这一点。</p>
<blockquote>
<p>代码清单7.11 使用ConfigMap条目作为参数值：fortune-pod-args-configmap.yaml</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>环境变量的定义与之前相同，需通过$（ENV_VARIABLE_NAME）将环境变量的值注入参数值。</p>
<h2 id="使用configMap卷将条目暴露为文件"><a href="#使用configMap卷将条目暴露为文件" class="headerlink" title="使用configMap卷将条目暴露为文件"></a>使用configMap卷将条目暴露为文件</h2><p>环境变量或者命令行参数值作为配置值通常适用于变量值较短的场景。由于ConfigMap中可以包含完整的配置文件内容，当你想要将其暴露给容器时，可以借助前面章节提到过的一种称为configMap卷的特殊卷格式。</p>
<p>configMap卷会将ConfigMap中的每个条目均暴露成一个文件。运行在容器中的进程可通过读取文件内容获得对应的条目值。</p>
<p>尽管这种方法主要适用于传递较大的配置文件给容器，同样可以用于传递较短的变量值。</p>
<p>创建ConfigMap</p>
<p>这里不再修改脚本fortuneloop.sh，将尝试另一个不同的示例，使用配置文件配置运行在fortunepod的Web服务器容器中的Nginxweb服务器。如果想要让Nginx服务器压缩传递给客户端的响应，Nginx的配置文件需开启压缩配置，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.12 开启gzip压缩的Nginx配置文件：my-nginx-config.conf</p>
</blockquote>
<p>现在首先通过kubectldeleteconfigmapfortune-config删除现有的ConfigMapfortune-config，然后用存储在本地磁盘上的Nginx配置文件创建一个新的ConfigMap。</p>
<p>创建一个新文件夹confimap-files并将上面的配置文件存储于configmap-files/my-nginx-config.conf中。另外在该文件夹中添加一个名为sleep-interval的文本文件，写入值为25，使ConfigMap同样包含条目sleep-interval，如图7.8所示。</p>
<blockquote>
<p>图7.8 configmap-files文件夹及文件的内容</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/8.png">
<p>从文件夹创建ConfigMap：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlcreateconfigmapfortune</span>-config--from-file=configmap-filesconfigmap<span class="string">"fortune-config"</span>created</span><br></pre></td></tr></table></figure></p>
<p>下面的代码清单展示了ConfigMap的YAML格式内容。</p>
<blockquote>
<p>代码清单7.13 从文件创建的ConfigMap的YAML格式定义</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 所有条目第一行最后的管道符号表示后续的条目值是多行字面量。</p>
</blockquote>
<p>ConfigMap包含两个条目，条目的键名与文件名相同。接下来将在pod的容器中使用该ConfigMap。</p>
<p>在卷内使用ConfigMap的条目</p>
<p>创建包含ConfigMap条目内容的卷只需要创建一个引用ConfigMap名称的卷并挂载到容器中。已经学会了如何创建及挂载卷，接下来要学习的仅是如何用ConfigMap的条目初始化卷。</p>
<p>Nginx需读取配置文件/etc/nginx/nginx.conf，而Nginx镜像内的这个文件包含默认配置，并不想完全覆盖这个配置文件。幸运的是，默认配置文件会自动嵌入子文件夹/etc/nginx/conf.d/下的所有.conf文件，因此只需要将你的配置文件置于该子文件夹中即可。图7.9展示了如何做到这一点。</p>
<p>pod的定义描述如代码清单7.14所示（省略无关部分，完整文件可以在代码归档中找到）。</p>
<p>pod定义中包含了引用fortune-configConfigMap的卷，需要被挂载到文件夹/etc/nginx/conf.d下让Nginx服务器使用它。</p>
<p>检查Nginx是否使用被挂载的配置文件</p>
<p>现在的web服务器应该已经被配置为会压缩响应，可以将localhost：8080转发到pod的80端口，利用curl检查服务器响应来验证配置是否生效，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.15 观察nginx响应是否被压缩</p>
</blockquote>
<p>检查被挂载的configMap卷的内容</p>
<p>服务器响应说明配置成功生效。现在来看一下文件夹/etc/nginx/conf.d下的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlexecfortune</span>-configmap-volume-cweb-serverl8/etc/nginx/conf.d</span><br><span class="line">my-nginx-config.conf</span><br><span class="line">sleep-interval</span><br></pre></td></tr></table></figure></p>
<p>ConfigMap的两个条目均作为文件置于这一文件夹下。条目sleep-interval对应的文件也被包含在内，然而它只会被fortuneloop容器所使用。可以创建两个不同的ConfigMap，—个用以配置容器fortuneloop，另一个用来配置web-server，然而采用多个ConfigMap去分别配置同一pod中的不同容器的做法是不好的。毕竟同一pod中的容器是紧密联系的，需要被当作整体单元来配置。</p>
<p>卷内暴露指定的ConfigMap条目</p>
<p>幸运的是，可以创建仅包含ConfigMap中部分条目的configMap卷一本示例中的条目my-nginx-config.conf。这样容器fortuneloop不会受到影响，条目sleep-interval会作为环境变量传递给容器而不是以卷的方式。</p>
<p>通过卷的items属性能够指定哪些条目会被暴露作为configMap卷中的文件，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.16 ConfigMap的指定条目挂载至pod的文件夹：fortunepod-configmap-volume-with-tmes.yaml</p>
</blockquote>
<p>指定单个条目时需同时设置条目的键名称以及对应的文件名。如果采用上面的配置文件创建pod，/etc/nginx/conf.d文件夹是比较千净的，仅包含所需的gzip.conf文件。</p>
<p>挂载某一文件夹会隐藏该文件夹中已存在的文件</p>
<p>这里有一件重要的事情需要讨论。在当前与此前的示例中，将卷挂载至某个文件夹，意味着容器镜像中/etc/nginx/conf.d文件夹下原本存在的任何文件都会被隐藏。</p>
<p>Linux系统挂载文件系统至非空文件夹时通常表现如此。文件夹中只会包含被挂载文件系统中的文件，即便文件夹中原本的文件是不可访问的也是同样如此。</p>
<p>本示例中，这种现象并不会带来比较糟糕的副作用。不过假设挂载文件夹是letc，该文件夹通常包含不少重要文件。由于letc下的所有文件不存在，容器极大可能会损坏。如果你希望添加文件至某个文件夹如/etc，绝不能采用这种方法。</p>
<p>ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的其他文件</p>
<p>顺理成章，你会好奇如何能挂载ConfigMap对应文件至现有文件夹的同时不会隐藏现有文件。volumeMount额外的subPath字段可以被用作挂载卷中的某个独立文件或者是文件夹，无须挂载完整卷。图7.10的形象化解释可能更加容易理解。</p>
<p>假设拥有一个包含文件myconfig.conf的configMap卷，希望能将其添加为/etc文件夹下的文件someconfig.conf。通过属性subPath可以将该文件挂载的同时又不影响文件夹中的其他文件。pod定义中的相关部分如下面的代码清单所示。</p>
<blockquote>
<p>图7.10 挂载卷中的单独文件</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/10.png">
<blockquote>
<p>代码清单7.17 pod挂载ConfigMap的指定条目至特定文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">挂载至某一文件，</span><br><span class="line">containers:</span><br><span class="line">而不是文件夹</span><br><span class="line">-image:some/image</span><br><span class="line">volumeMounts:</span><br><span class="line">-name:myvolume</span><br><span class="line"></span><br><span class="line">仅挂载指定的条目myconfig.conf，并非完整的卷</span><br><span class="line">mountPath:/etc/someconfig.conf&lt;subPath:myconfig.conf</span><br></pre></td></tr></table></figure>
<p>挂载任意一种卷时均可以使用subPath属性。可以选择挂载部分卷而不是挂载完整的卷。不过这种独立文件的挂载方式会带来文件更新上的缺陷，你会在接下来的小节中学习到更多的相关知识，在这里还是先要说一些文件权限问题对configMap卷的讨论进行收尾。</p>
<p>为configMap卷中的文件设置权限</p>
<p>configMap卷中所有文件的权限默认被设置为644（-rw-r-r—）。可以通过卷规格定义中的defaultMode属性改变默认权限，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.18设置权限：fortune-pod-configmap-volume-defaultMode.yaml</p>
</blockquote>
<p>ConfigMap通常被用作存储非敏感数据，不过依旧可能希望仅限于文件拥有者的用户和组可读写，正如上面的例子所示。</p>
<h2 id="更新应用配置且不重启应用程序"><a href="#更新应用配置且不重启应用程序" class="headerlink" title="更新应用配置且不重启应用程序"></a>更新应用配置且不重启应用程序</h2><p>在此之前提到过，使用环境变量或者命令行参数作为配置源的弊端在于无法在进程运行时更新配置。将ConfigMap暴露为卷可以达到配置热更新的效果，无须重新创建pod或者重启容器。</p>
<p>ConfigMap被更新之后，卷中引用它的所有文件也会相应更新，进程发现文件被改变之后进行重载。Kubernetes同样支持文件更新之后手动通知容器。</p>
<p>警告请注意笔者在写这段的时候，更新ConfigMap之后对应文件的更新耗时会出人意料地长（往往需要数分钟）。</p>
<p>修改ConfigMap</p>
<p>现在来瞧一瞧如何修改ConfigMap，同时运行在pod中的进程会重载configMap卷中对应的文件。你需要修改前面示例中的Nginx配置文件，使得Nginx能够在不重启pod的前提下应用新配置。尝试用kubectledit命令修改ConfigMapfortune-config来关闭gzip压缩：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectleditconfigmapfortune</span>-config</span><br></pre></td></tr></table></figure></p>
<p>编辑器打开，行gzipon改为gzipoff，保存文件后关闭编辑器。ConfigMap被更新不久之后会自动更新卷中的对应文件。用kubectlexec命令打印出该文件内容进行确认：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlexecfortune</span>-configmap-volume-cweb-server</span><br><span class="line">cat/etc/nginx/conf.d/my-nginx-config.conf</span><br></pre></td></tr></table></figure></p>
<p>若尚未看到文件内容被更新，可稍等一会儿后重试。文件更新过程需要一段时间。最终你会看到配置文件的变化，然而发现这对Nginx并没有什么影响，这是因为Nginx不会去监听文件的变化并自动重载。</p>
<p>通知Nginx重载配置</p>
<p>Nginx会持续压缩响应直到你通过以下命令主动通知它：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlexecfortune</span>-configmap-volume-cweb-server--nginx-sreload</span><br></pre></td></tr></table></figure></p>
<p>现在再次用curl命令访问服务器后会发现响应不再被压缩（响应头中未包含Content-Encoding：gzip）。在无须重启容器或者重建pod的同时有效修改了应用配置。</p>
<p>了解文件被自动更新的过程</p>
<p>你可能会疑惑在Kubernetes更新完configMap卷中的所有文件之前，应用是否会监听到文件变化并主动进行重载。幸运的是，这不会发生，所有的文件会被自动一次性更新。Kubernetes通过符号链接做到这一点。如果尝试列出configMap卷挂载位置的所有文件，会看到如下内容。</p>
<blockquote>
<p>代码清单7.19 被挂载的configMap卷中的文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlexec</span>-itfortune-configmap-volume-cweb-server--ls-lA</span><br><span class="line">/etc/nginx/conf.d</span><br><span class="line">total4</span><br><span class="line">drwxr-xr-x</span><br><span class="line">...12:15..4984_09_04_12_15_06.865837643</span><br><span class="line">lrwXrwXrwX</span><br><span class="line">...12:15..data-&gt;..4984_09_04_12_15_06.865837643</span><br><span class="line">1rwxrwxrwx</span><br><span class="line">12:15my-nginx-config.conf-&gt;.data/my-nginx-config.conf</span><br><span class="line">1rwxrwxrwx...12:15sleep-interval-&gt;.data/sleep-interval</span><br></pre></td></tr></table></figure>
<p>可以看到，被挂载的configMap卷中的文件是..data文件夹中文件的符号链接，而..data文件夹同样是..4984_09_04_something的符号链接。每当ConfigMap被更新后，Kubernetes会创建一个这样的文件夹，写入所有文件并重新将符号..data链接至新文件夹，通过这种方式可以一次性修改所有文件。</p>
<p>挂载至已存在文件夹的文件不会被更新</p>
<p>涉及到更新configMap卷需要提出一个警告：如果挂载的是容器中的单个文件而不是完整的卷，ConfigMap更新之后对应的文件不会被更新！至少在写本章节的时候表现如此。</p>
<p>如果现在你需要挂载单个文件并且在修改源ConfigMap的同时会自动修改这个文件，一种方案是挂载完整卷至不同的文件夹并创建指向所需文件的符号链接。符号链接可以原生创建在容器镜像中，也可以在容器启动时创建。</p>
<p>了解更新ConfigMap的影响</p>
<p>容器的一个比较重要的特性是其不变性，从同一镜像启动的多个容器之间不存在任何差异。那么通过修改被运行容器所使用的ConfigMap来打破这种不变性的行为是否是错误的？</p>
<p>关键点在于应用是否支持重载配置。ConfigMap更新之后创建的pod会使用新配置，而之前的pod依旧使用旧配置，这会导致运行中的不同实例的配置不同。这也不仅限于新pod，如果pod中的容器因为某种原因重启了，新进程同样会使用新配置。因此，如果应用不支持主动重载配置，那么修改某些运行pod所使用的ConfigMap并不是一个好主意。</p>
<p>如果应用支持主动重载配置，那么修改ConfigMap的行为就算不了什么。不过有一点仍需注意，由于configMap卷中文件的更新行为对于所有运行中示例而言不是同步的，因此不同pod中的文件可能会在长达一分钟的时间内出现不一致的情况。</p>
<h1 id="使用Secret给容器传递敏感数据"><a href="#使用Secret给容器传递敏感数据" class="headerlink" title="使用Secret给容器传递敏感数据"></a>使用Secret给容器传递敏感数据</h1><p>到目前为止传递给容器的所有信息都是比较常规的非敏感数据。然而正如本章开头提到的，配置通常会包含-些敏感数据，如证书和私钥，需要确保其安全性。</p>
<h2 id="介绍Secret"><a href="#介绍Secret" class="headerlink" title="介绍Secret"></a>介绍Secret</h2><p>为了存储与分发此类信息，Kubermetes提供了一种称为Secret的单独资源对象。Secret结构与ConfigMap类似，均是键/值对的映射。Secret的使用方法也与ConfigMap相同，可以</p>
<ul>
<li>将Secret条目作为环境变量传递给容器</li>
<li>将Secret条目暴露为卷中的文件</li>
</ul>
<p>Kubemetes通过仅仅将Secret分发到需要访问Secret的pod所在的机器节点来保障其安全性。另外，Secret只会存储在节点的内存中，永不写入物理存储，这样从节点上删除Secret时就不需要擦除磁盘了。</p>
<p>对于主节点本身（尤其是etcd），Secret通常以非加密形式存储，这就需要保障主节点的安全从而确保存储在Secret中的敏感数据的安全性。这种保障不仅仅是对etcd存储的安全性保障，同样包括防止未授权用户对API服务器的访问，这是因为任何人都能通过创建pod并将Secret挂载来获得此类敏感数据。从Kubermetes1.7开始，etcd会以加密形式存储Secret，某种程度提高了系统的安全性。正因为如此，从Secret与ConfigMap中做出正确选择是势在必行的，选择依据相对简单：</p>
<ul>
<li>采用ConfigMap存储非敏感的文本配置数据。</li>
<li>采用Secret存储天生敏感的数据，通过键来引用。如果一个配置文件同时包含敏感与非敏感数据，该文件应该被存储在Secret中。</li>
</ul>
<p>第5章中已经使用过Secret以存储Ingress资源的TLS证书。接下来将更深入地探讨Secret的细节。</p>
<h2 id="默认令牌Secret介绍"><a href="#默认令牌Secret介绍" class="headerlink" title="默认令牌Secret介绍"></a>默认令牌Secret介绍</h2><p>首先来分析一种默认被挂载至所有容器的Secret，对任意一个pod使用命令kubectldescribepod，输出往往包含如下信息：</p>
<p>每个pod都会被自动挂载上一个secret卷，这个卷引用的是前面kubectldescribe输出中的一个叫作default-token-cfee9的Secret。由于Secret也是资源对象，因此可以通过kubectlgetsecrets命令从Secret列表中找到这个default-tokenSecret：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlgetsecrets</span></span><br><span class="line">NAME</span><br><span class="line">TYPE</span><br><span class="line">DATAAGE</span><br><span class="line">default-token-cfee9kubernetes.io/service-account-token</span><br><span class="line">39d</span><br></pre></td></tr></table></figure>
<p>同样可以使用kubectldescribe多了解一下这个Secret，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.20 描述一个Secret</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectldescribesecrets</span></span><br><span class="line">Name:default-token-cfee9</span><br><span class="line">Namespace:default</span><br><span class="line">Labels:</span><br><span class="line">Annota</span><br><span class="line">ations:kubernetes.io/service-account.name=default</span><br><span class="line">kubern</span><br><span class="line">kubernetes.io/service-account.uid=cc04bb39-b53f-42010af00237</span><br><span class="line">TYpe:</span><br><span class="line">kubernetes.io/service-account-token</span><br><span class="line">Data</span><br><span class="line">ca.crt:1139bytes</span><br><span class="line">包含三个</span><br><span class="line">namespace:7bytes</span><br><span class="line">条目</span><br><span class="line">token:eyJhbGci0iJSUzIlNiIsInR5cCI6IkpXVCJ9...</span><br></pre></td></tr></table></figure>
<p>可以看出这个Secret包含三个条目一ca.crt、namespace与token，包含了从pod内部安全访问KubemetesAPI服务器所需的全部信息。尽管你希望做到应用程序对Kubemetes的完全无感知，然而在除了直连Kubemetes别无他法的情况下，你将会使用到secret卷提供的文件。</p>
<p>kubectldescribepod命令会显示secret卷被挂载的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mounts:</span><br><span class="line">/var/run/secrets/kubernetes.io/serviceaccountfromdefault-token-cfee9</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 default-tokenSecret默认会被挂载至每个容器。可以通过设置pod定义中的automountServiceAccountToken字段为false，或者设置pod使用的服务账户中的相同字段为false来关闭这种默认行为（本书后面会对服务账户进行讲解）。</p>
</blockquote>
<p>图7.11能够帮助你更形象地理解默认令牌Secret的挂载行为。</p>
<p>我们已经说过Secret类似于ConfigMap，由于该Secret包含三个条目，可通过kubectlexec观察到被secret卷挂载的文件夹下包含三个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlexecmypodls</span>/var/run/secrets/kubernetes.io/serviceaccount/</span><br><span class="line">ca.crt</span><br><span class="line">namespace</span><br><span class="line">token</span><br></pre></td></tr></table></figure></p>
<p>下一章中将会看到应用程序是如何使用这些文件来访问API服务器的。</p>
<blockquote>
<p>图7.11 default-tokenSecret被自动创建且对应的卷被自动挂载到每个pod上</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/11.png">
<h2 id="创建Secret"><a href="#创建Secret" class="headerlink" title="创建Secret"></a>创建Secret</h2><p>现在你将创建自己地小型Secret。改进fortune-serving的Nginx容器的配置，使其能够服务于HTTPS流量。你需要创建私钥和证书，由于需要确保私钥的安全性，可将其与证书同时存入Secret。</p>
<p>首先在本地机器上生成证书与私钥文件，当然也可以直接使用本书代码归档中的相应文件（fortune-https文件夹下的证书与密钥文件）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$opensalgenrsa</span>-outhttps.key2048</span><br><span class="line"><span class="variable">$opensalreq</span>-new-x509-keyhttps.key-outhttps.cert-days3650-subj</span><br><span class="line">/CN=www.kubia-example.com</span><br></pre></td></tr></table></figure></p>
<p>现在为了帮助你更好地理解Secret，额外创建一个内容为字符串bar的虚拟文件foo。过会儿你就会理解为何要这样做：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$echobar</span>&gt;foo</span><br></pre></td></tr></table></figure></p>
<p>现在使用kubectlcreatesecret命令由这三个文件创建Secret：</p>
<p>与创建ConfigMap的过程类似，这里创建了一个名为fortune-https的genericSecret，它包含有两个条目：https.key和https.cert，分别对应于两个同名文件的内容。如前所述，同样可以用—from-file=fortune-https囊括整个文件夹中的所有文件，替代单独指定每个文件的创建方式。</p>
<blockquote>
<p>注意 这里创建了一个genericSecret，在此之前你可能在第5章通过kubectlcreatesecrettls创建过一个tlsSecret。两种方式创建的Secret的条目名称不同。</p>
</blockquote>
<h2 id="对比ConfigMap与Secret"><a href="#对比ConfigMap与Secret" class="headerlink" title="对比ConfigMap与Secret"></a>对比ConfigMap与Secret</h2><p>Secret与ConfigMap仍有比较大的差别，这也是为何Kubernetes开发者们在支持了Secret一段时间之后仍会选择创建ConfigMap。创建的Secret的YAML格式定义如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.21 Secret的YAML格式定义</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlgetsecretfortune</span>-https-oyaml</span><br><span class="line">apiVersion:vl</span><br><span class="line">data:</span><br><span class="line">foo:YmFyCg==</span><br><span class="line">https.cert:LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...https.key:LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSU1FcE...kind:Secret</span><br></pre></td></tr></table></figure>
<p>将其与之前创建的ConfigMap的YAML格式定义做对比：</p>
<blockquote>
<p>代码清单7.22Config的YAML格式定义</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意到两者的区别了吗？Secre备目的内容会被以Base64格式编码，而ConfigMap直接以纯文本展示。这种区别导致在处理YAML和JSON格式的Secret时会稍许有些麻烦，需要在设置和读取相关条目时对内容进行编解码。</p>
<p>为二进制数据创建Secret</p>
<p>采用Base64编码的原因很简单Secret的条目可以涵盖二进制数据，而不仅仅是纯文本。Base64编码可以将二进制数据转换为纯文本以YAML或JSON格式展示。</p>
<p>提示Secret甚至可以被用来存储非敏感二进制数据。不过值得注意的是Secret的大很于1MB。<br>stringData字段介绍</p>
<p>由于并非所有的敏感数据都是二进制形式，Kubernetes允许通过Secret的stringData字段设置条目的纯文本值，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.23 通过stringData字段向Secret添加纯文本条目值</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span><span class="string">Secret</span></span><br><span class="line"><span class="string">stringData可被用来设置</span></span><br><span class="line"><span class="attr">apiVersion:</span><span class="string">v1</span></span><br><span class="line"><span class="string">非二进制数据</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line"><span class="string">可以看出值未被Base64编码</span></span><br><span class="line"><span class="attr">foo:</span><span class="string">plaintext</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="string">https.cert:LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURCekNDQ...</span></span><br><span class="line"><span class="string">https.key:LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcE...</span></span><br></pre></td></tr></table></figure>
<p>stringData字段是只写的（注意：是只写，非只读），可以被用来设置条目值。通过kubectlget-oyaml获取Secret的YAML格式定义时，不会显示stringData字段。相反，stringData字段中的所有条目（如上面示例中的foo条目）会被Base64编码之展示在data字段下。</p>
<p>在pod中读取Secret条目</p>
<p>通过secret卷将Secret暴露给容器之后，Secret条目的值会被解码镇实形式（纯文本或二进制）写入对应的文件。通过环境变量暴露Secret条目亦是如此。在这两种情况下，应用程序均无须主动解码，可直接读取文件内容或者查找环境变量。</p>
<h2 id="在pod中使用Secret"><a href="#在pod中使用Secret" class="headerlink" title="在pod中使用Secret"></a>在pod中使用Secret</h2><p>fortune-ht8pscre已经包含了证书与密钥文件，接下来需要做的是配置Nginx服务器去使用它们。</p>
<p>修改fortune-configConfigMap以开启HTTPS</p>
<p>为了开启HTTPS，需要再次修改这个ConfigMap对应的配置条目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectleditconfigmapfortune</span>-config</span><br></pre></td></tr></table></figure></p>
<p>文本编辑器打开后，修改条目my-nginx-config.con的内容，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.24 修改fortune-configConfigMap的数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面配置了服务器从/etc/nginx/certs中读取证书与密钥文件，因此之后需要将secret卷挂载于此。</p>
<p>挂载fortune-secret至pod</p>
<p>接下来需要创建一个新的fortune-httpspod，将含有证书与密钥的secret卷挂载至pod中的web-server容器，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.25 fortune-httpspod的YAML格式定义：fortune-pod-https.yaml</p>
</blockquote>
<p>图7.12形象化地展示了上述YAML格式定义中的各组件及其相互关系。Secretdefault-token以及卷、卷挂载并不包含在这一定义中，因为这些组件被自动加入pod定义，图中不予展示。</p>
<blockquote>
<p>注意 与configMap卷相同，secret卷同样支持通过defaultModes属性指定卷中文件的默认权限。</p>
</blockquote>
<p>测试Nginx是否正使用Secret中的证书与密钥</p>
<p>pod运行之后，开启端口转发隧道将HTTPS流量转发至pod的443端口，并用curl向服务器发送请求：</p>
<blockquote>
<p>图7.12 组合了ConligMap录密钥运行tortune-heapspod</p>
</blockquote>
<img src="/2022/10/01/7-ConfigMap和Secret：配置应用程序/12.png">
<p>若服务器配置正确，会得到一个响应，检查响应中服务器证书是否与之前生成的证书匹配。curl命令添加选项-v开启详细日志，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.26 显示Nginx发送的服务器证书</p>
</blockquote>
<p>Secret卷存储于内存</p>
<p>通过挂载secret卷至文件夹/etc/nginx/certs将证书与私钥成功传递给容器。secret卷采用内存文件系统列出容器的挂载点，如下面的代码清单所示。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlexecfortune</span>-https-cweb-server--mountIgrepcerts</span><br><span class="line">tmpfson/etc/nginx/certstypetmpfs(ro,relatime)</span><br></pre></td></tr></table></figure></p>
<p>由于使用的是tmpfs，存储在Secret中的数据不会写入磁盘，这样就无法被窃取。</p>
<p>通过环境变量暴露Secret条目</p>
<p>除卷之外，Secret的独立条目可作为环境变量被暴露，就像ConfigMap中sleep-interval条目做的那样。举个例子，若想将Secret中的键foo暴露为环境变量FOO_SECRET，需要在容器定义中添加如下片段。</p>
<p>代码清单7.27Secret条目暴露为环境变量</p>
<p>上面片段与设置INTERVAL环境变量的基本一致，除了这里是使用secretKeyRef字段来引用Secret，而非configMapKeyRef，后者用以引用ConfigMap.</p>
<p>Kubernetes允许通过环境变量暴露Secret，然而此特性的使用往往不是一个好主意。应用程序通常会在错误报告时转储环境变量，或者是启动时打印在应用日志中，无意中暴露了Secret信息。另外，子进程会继承父进程的所有环境变量，如果是通过第三方二进制程序启动应用，你并不知道它使用敏感数据做了什么。</p>
<p>提示由于敏感数据可能在无意中被暴露，通过环境变量暴露Secret给容器之前请再三思考。为了确保安全性，请始终采用secret卷的方式暴露Secret。</p>
<p>了解镜像拉取Secret</p>
<p>你已经学会了如何传递Secret给应用程序并使用它们包含的数据。Kubernetes自身在有些时候希望我们能够传递证书给它，比如从某个私有镜像仓库拉取镜像时。这一点同样需通过Secret来做到。</p>
<p>到目前为止所使用的容器镜像均存储在公共仓库，从上面拉取镜像时无须任何特殊的证书。不过大部分组织机构不希望它们的镜像开放给所有人，因此会使用私有镜像仓库。部署一个pod时，如果容器镜像位于私有仓库，Kubernetes需拥有拉取镜像所需的证书。让我们看一下该怎么做。</p>
<p>在DockerHub上使用私有镜像仓库</p>
<p>DockerHub除了是一个公共镜像仓库，还支持在上面创建私有仓库。通过浏览器登录<code>https://hub.docker.com</code>，找到对应的镜像仓库，勾选指定的复选框，将仓库标记为私有。</p>
<p>运行一个镜像来源于私有仓库的pod时，需要做以下两件事：</p>
<ul>
<li>创建包含Docker镜像仓库证书的Secret。</li>
<li>pod定义中的imagePullSecrets字段引用该Secret。</li>
</ul>
<p>创建用于Docker镜像仓库鉴权的Secret</p>
<p>创建一个包含Docker镜像仓库鉴权证书的Secret与7.5.3节中创建genericSecret并没有什么不同。同样使用kubectlcreatesecret命令，仅仅是类型与参数选项的不同：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlcreatesecretdocker</span>-registrymydockerhubsecret\</span><br><span class="line">--docker-username=myusername--docker-password=mypassword\</span><br><span class="line">--docker-email=my.email@provider..com</span><br></pre></td></tr></table></figure></p>
<p>这里创建了一个docker-registry类型的mydockerhubsecretSecret，创建时需指定DockerHub的用户名、密码以及邮箱。通过kubectldescribe观察新建Secret的内容时会发现仅有一个条目.dockercfg，相当于用户主目录下的.dockercfg文件。该文件通常在运行dockerlogin命令时由Docker自动创建。</p>
<p>在pod定义中使用docker-registrySecret</p>
<p>为了Kubernetes从私有镜像仓库拉取镜像时能够使用Secret，需要在pod定义中指定docker-registrySecret的名称，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单7.28 指定镜像拉取Secret的pod定义：pod-with-private-image.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述pod定义中，字段imagePullSecrets引用了mydockerhubsecretSecret。建议你尝试一下这个特性，因为很可能在不久之后就会与私有镜像打交道。</p>
<p>不需要为每个pod指定镜像拉取Secret</p>
<p>假设某系统中通常运行大量pod，你可能会好奇是否需要为每个pod都添加相同的镜像拉取Secret。幸运的是，情况并非如此。第12章中将会学习到如何通过添加Secret至ServiceAccount使所有pod都能自动添加上镜像拉取Secret。</p>
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p>本章向你展示了如何向容器传递配置数据。读完这一章，你应该知道如何：</p>
<ul>
<li>在pod定义中覆盖容器镜像定义的默认命令</li>
<li>传递命令行参数给容器主进程</li>
<li>为容器设置环境变量</li>
<li>将配置从pod定义中分离并放入ConfigMap</li>
<li>通过Secret存储敏感数据并安全分发至容器</li>
<li>创建docker-registrySecret用以从私有镜像仓库拉取镜像<br>下一章中你将会学习到如何传递pod和容器的元数据给运行于其中的应用程序，会了解到本章的默认令牌Secret是如何在pod中被用来访问API服务器的。</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes-in-Action/" rel="tag"># Kubernetes in Action</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/01/6-卷：将磁盘挂载到容器/" rel="next" title="6-卷：将磁盘挂载到容器">
                <i class="fa fa-chevron-left"></i> 6-卷：将磁盘挂载到容器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/01/8-从应用访问pod元数据以及其他资源/" rel="prev" title="8-从应用访问pod元数据以及其他资源">
                8-从应用访问pod元数据以及其他资源 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">学如逆水行舟，不进则退</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">810</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">61</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2022/11/10/Swoole-Hyperf/" title="Swoole + Hyperf" target="_blank">Swoole + Hyperf</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/07/使用Redis实现一个分布式锁/" title="使用Redis实现一个分布式锁" target="_blank">使用Redis实现一个分布式锁</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/06/14-隔离性：实现悲观协议，除了锁还有别的办法吗？/" title="14 | 隔离性：实现悲观协议，除了锁还有别的办法吗？" target="_blank">14 | 隔离性：实现悲观协议，除了锁还有别的办法吗？</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/06/13-隔离性：为什么使用乐观协议的分布式数据库越来越少/" title="13 | 隔离性：为什么使用乐观协议的分布式数据库越来越少?" target="_blank">13 | 隔离性：为什么使用乐观协议的分布式数据库越来越少?</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/06/12-隔离性：看不见的读写冲突，要怎么处理？/" title="12 | 隔离性：看不见的读写冲突，要怎么处理？" target="_blank">12 | 隔离性：看不见的读写冲突，要怎么处理？</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#配置容器化应用程序"><span class="nav-number">1.</span> <span class="nav-text">配置容器化应用程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#向容器传递命令行参数"><span class="nav-number">2.</span> <span class="nav-text">向容器传递命令行参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在Docker中定义命令与参数"><span class="nav-number">2.1.</span> <span class="nav-text">在Docker中定义命令与参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在Kubernetes中覆盖命令和参数"><span class="nav-number">2.2.</span> <span class="nav-text">在Kubernetes中覆盖命令和参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为容器设置环境变量"><span class="nav-number">3.</span> <span class="nav-text">为容器设置环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在容器定义中指定环境变量"><span class="nav-number">3.1.</span> <span class="nav-text">在容器定义中指定环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在环境变量值中引用其他环境变量"><span class="nav-number">3.2.</span> <span class="nav-text">在环境变量值中引用其他环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解硬编码环境变量的不足之处"><span class="nav-number">3.3.</span> <span class="nav-text">了解硬编码环境变量的不足之处</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#利用ConfigMap解耦配置"><span class="nav-number">4.</span> <span class="nav-text">利用ConfigMap解耦配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ConfigMap介绍"><span class="nav-number">4.1.</span> <span class="nav-text">ConfigMap介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建ConfigMap"><span class="nav-number">4.2.</span> <span class="nav-text">创建ConfigMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给容器传递ConfigMap条目作为环境变量"><span class="nav-number">4.3.</span> <span class="nav-text">给容器传递ConfigMap条目作为环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一次性传递ConfigMap的所有条目作为环境变量"><span class="nav-number">4.4.</span> <span class="nav-text">一次性传递ConfigMap的所有条目作为环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传递ConfigMap条目作为命令行参数"><span class="nav-number">4.5.</span> <span class="nav-text">传递ConfigMap条目作为命令行参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用configMap卷将条目暴露为文件"><span class="nav-number">4.6.</span> <span class="nav-text">使用configMap卷将条目暴露为文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新应用配置且不重启应用程序"><span class="nav-number">4.7.</span> <span class="nav-text">更新应用配置且不重启应用程序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Secret给容器传递敏感数据"><span class="nav-number">5.</span> <span class="nav-text">使用Secret给容器传递敏感数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍Secret"><span class="nav-number">5.1.</span> <span class="nav-text">介绍Secret</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认令牌Secret介绍"><span class="nav-number">5.2.</span> <span class="nav-text">默认令牌Secret介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建Secret"><span class="nav-number">5.3.</span> <span class="nav-text">创建Secret</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对比ConfigMap与Secret"><span class="nav-number">5.4.</span> <span class="nav-text">对比ConfigMap与Secret</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在pod中使用Secret"><span class="nav-number">5.5.</span> <span class="nav-text">在pod中使用Secret</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小结"><span class="nav-number">6.</span> <span class="nav-text">本章小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">7m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">105:50</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
