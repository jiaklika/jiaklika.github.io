<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Kubernetes in Action">
<meta property="og:type" content="article">
<meta property="og:title" content="11-了解Kubernetes机理">
<meta property="og:url" content="http://yoursite.com/2022/10/01/11-了解Kubernetes机理/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-10-05T06:05:54.211Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="11-了解Kubernetes机理">
<meta name="twitter:description" content="思考并回答以下问题：">






  <link rel="canonical" href="http://yoursite.com/2022/10/01/11-了解Kubernetes机理/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>11-了解Kubernetes机理 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/01/11-了解Kubernetes机理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">11-了解Kubernetes机理

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-10-01 10:10:25" itemprop="dateCreated datePublished" datetime="2022-10-01T10:10:25+08:00">2022-10-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-10-05 14:05:54" itemprop="dateModified" datetime="2022-10-05T14:05:54+08:00">2022-10-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">25k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">23 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>【本章内容涵盖】</p>
<ul>
<li>Kubernetes集群包含哪些组件</li>
<li>每个组件的作用以及它们是如何工作的</li>
<li>运行的pod是如何创建一个部署对象的</li>
<li>运行的pod是什么</li>
<li>pod之间的网络如何工作</li>
<li>Kubernetes服务如何工作</li>
<li>如何保证高可用性</li>
</ul>
<p>本书读至此处，读者应该已经熟悉Kubermetes能提供什么以及做了什么。不过到目前为止，笔者有意没有花太多时间具体去阐述它是如何达成这些功能的，在笔者看来，在对系统能做什么有较好的理解之前，钻系统实现细节没有意义。这就是为什么还没有讨论过pod是如何调度的，以及控制器管理器中的各种控制器如何让部署的资源运行起来。知道了大多数可以部署到Kubernetes的资源，现在是时候了解下它们是怎么被实现的了。</p>
<h1 id="了解架构"><a href="#了解架构" class="headerlink" title="了解架构"></a>了解架构</h1><p>在研究Kubernetes如何实现其功能之前，先具体了解下Kubernetes集群有哪些组件。在第一章中，可以看到，Kubernetes集群分为两部分：</p>
<ul>
<li>Kubernetes控制平面</li>
<li>（工作）节点</li>
</ul>
<p>让我们具体看下这两个部分做了什么，以及内部运行的内容。</p>
<p>控制平面的组件</p>
<p>控制平面负责控制并使得整个集群正常运转。回顾一下，控制平面包含如下组件：</p>
<ul>
<li>etcd分布式持久化存储</li>
<li>API服务器</li>
<li>调度器</li>
<li>控制器管理器</li>
</ul>
<p>这些组件用来存储、管理集群状态，但它们不是运行应用的容器。</p>
<p>工作节点上运行的组件</p>
<p>运行容器的任务依赖于每个工作节点上运行的组件：</p>
<ul>
<li>Kubelet</li>
<li>Kubelet服务代理（kube-proxy）</li>
<li>容器运行时（Docker、rkt或者其他）</li>
</ul>
<p>附加组件</p>
<p>除了控制平面（和运行在节点上的组件，还要有几个附加组件，这样才能提供所有之前讨论的功能。包含：</p>
<ul>
<li>KuberetesDNS服务器</li>
<li>仪表板</li>
<li>Ingress控制器</li>
<li>Heapster（容器集群监控），将在第14章讨论</li>
<li>容器网络接口插件（本章后面会做讨论）</li>
</ul>
<h2 id="Kubernetes组件的分布式特性"><a href="#Kubernetes组件的分布式特性" class="headerlink" title="Kubernetes组件的分布式特性"></a>Kubernetes组件的分布式特性</h2><p>之前提到的组件都是作为单独进程运行的。图11.1描述了各个组件及它们之间的依赖关系。</p>
<p>若要启用Kubernetes提供的所有特性，需要运行所有的这些组件。但是有几个组件无须其他组件，单独运行也能提供非常有用的工作。接下来会详细查看每一个组件。</p>
<blockquote>
<p>图11.1 Kubernetes控制平面以及工作节点的组件</p>
<p>检查控制平面组件的状态<br><br>API服务器对外暴露了一个名为ComponentStatus的API资源，用来显示每个控制平面组件的健康状态。可以通过kubectl列出各个组件以及它们的状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get componentstatuses</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>组件间如何通信</p>
<p>Kubemetes系统组件间只能通过API服务器通信，它们之间不会直接通信。API服务器是和etcd通信的唯一组件。其他组件不会直接和etcd通信，而是通过API服务器来修改集群状态。</p>
<p>API服务器和其他组件的连接基本都是由组件发起的，如图11.1所示。但是，当你使用kubectl获取日志、使用kubectlattach连接到一个运行中的容器或运行kubectlport-forward命令时，API服务器会向Kubelet发起连接。</p>
<blockquote>
<p>注意 kubectlattach命令和kubectlexec命令类似，区别是：前者会附属到容器中运行着的主进程上，而后者是重新运行一个进程。</p>
</blockquote>
<p>单组件运行多实例</p>
<p>尽管工作节点上的组件都需要运行在同一个节点上，控制平面的组件可以被简单地分割在多台服务器上。为了保证高可用性，控制平面的每个组件可以有多个实例。etcd和API服务器的多个实例可以同时并行工作，但是，调度器和控制器管理器在给定时间内只能有一个实例起作用，其他实例处于待命模式。</p>
<p>组件是如何运行的</p>
<p>控制平面的组件以及kube-proxy可以直接部署在系统上或者作为pod来运行（如图11.1所示）。听到这个你可能比较惊讶，不过后面我们讨论Kubelet时就都说得通了。</p>
<p>Kubelet是唯一直作为常规系统组件来运行的组件，它把其他组件作为pod来运行。为了将控制平面作为pod来运行，Kubelet被部署在master上。下面的代码清单展示了通过kubeadm（在附录B中阐述）创建的集群里的kube-system命名空间里的pod。</p>
<blockquote>
<p>代码清单11.1 作为pod运行的Kubernetes组件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如代码清单所示，所有的控制平面组件在主节点上作为pod运行。这里有三个工作节点，每一个节点运行kube-proxy和一个Flannelpod，用来为pod提供重叠网络（后面我们会再讨论Flannel）。</p>
<blockquote>
<p>提示 如代码清单所示，可以通过-ocustom-columns选项自定义展示的列以及—sort-by对资源列表进行排序。</p>
</blockquote>
<p>现在，让我们对每一个组件进行研究，从控制平面的底层组件——持久化存储组件开始。</p>
<h2 id="Kubernetes如何使用etcd"><a href="#Kubernetes如何使用etcd" class="headerlink" title="Kubernetes如何使用etcd"></a>Kubernetes如何使用etcd</h2><p>本书让你创建的所有对象——pod、ReplicationController、服务和私密凭据等，需要以持久化方式存储到某个地方，这样它们的manifest在API服务器重启和失败的时候才不会丢失。为此，Kubernetes使用了etcd。etcd是一个响应快、分布式、一致的key-value存储。因为它是分布式的，故可以运行多个etcd实例来获取高可用性和更好的性能。</p>
<p>唯一能直接和etcd通信的是Kubernetes的API服务器。所有其他组件通过API服务器间接地读取、写入数据到etcd。这带来一些好处，其中之一就是增强乐观锁系统、验证系统的健壮性；并且，通过把实际存储机制从其他组件抽离，未来替换起来也更容易。值得强调的是，etcd是Kubernetes存储集群状态和元数据的唯一的地方。</p>
<blockquote>
<p>关于乐观并发控制<br><br>乐观并发控制（有时候指乐观锁）是指一段数据包含一个版本数字，而不是锁住该段数据并阻止读写操作。每当更新数据，版本数就会增加。当更新数据时，就会检查版本值是否在客户端读取数据时间和提交时间之间被增加过。如果增加过，那么更新会被拒绝，客户端必须重新读取新数据，重新尝试更新。<br><br>两个客户端尝试更新同一个数据条目，只有第一个会成功。<br><br>所有的Kuberetes包含一个metadata.resourceVersion字段，当更新对象时，客户端需要返回该值到API服务器。如果版本值与etcd中存储的不匹配，API服务器会拒绝该更新。</p>
</blockquote>
<p>资源如何存储在etcd中</p>
<p>当笔者撰写此书时，Kubernetes既可以用etcd版本2也可以用版本3，但目前更推荐版本3，它的性能更好。etcdv2把key存储在一个层级键空间中，这使得键值对类似文件系统的文件。etcd中每个key要么是一个目录，包含其他key，要么是一个常规key，对应一个值。etcdv3不支持目录，但是由于key格式保持不变（键可以包含斜杠），仍然可以认为它们可以被组织为目录。Kubernetes存储所有数据到etcd的/registry下。下面的代码清单显示/registry下存储的一系列key。</p>
<blockquote>
<p>代码清单11.2 etcd中存储的Kubernetes的顶层条目</p>
</blockquote>
<p>你可能会发现，这些key和之前几章中学习到的资源类型对应。</p>
<blockquote>
<p>注意 如果使用etcdv3的API，就无法使用ls命令来查看目录的内容。但是，可以通过etcdctlget/registry—prefix=true列出所有以给定前缀开始的key。</p>
</blockquote>
<p>下面的代码清单显示了/registry/pods目录的内容。</p>
<blockquote>
<p>代码清单11.3/registry/pods目录下的key</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从名称可以看出，这两个条目对应default和kube-system命名空间，意味着pod按命名空间存储。下面的代码清单显示/registry/pods/default目录下的条目。</p>
<blockquote>
<p>代码清单11.4 default命名空间中pod的etcd条目</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每个条目对应一个单独的pod。这些不是目录，而是键值对。下面的代码清单展示了其中一条存储的内容。</p>
<blockquote>
<p>代码清单11.5 一个etcd条目代表一个pod</p>
</blockquote>
<p>你可能发现了，这就是一个JSON格式的pod定义。API服务器将资源的完整JSON形式存储到etcd中。由于etcd的层级键空间，可以想象成把资源以JSON文件格式存储到文件系统中。简单易懂，对吧？</p>
<blockquote>
<p>警告 Kubernetes1.7之前的版本，密钥凭据的JSON内容也像上面一样存储（没有加密）。如果有人有权限直接访问etcd，那么可以获取所有的密钥凭据。从1.7版本开始，密钥凭据会被加密，这样存储起来更加安全。</p>
</blockquote>
<p>确保存储对象的一致性和可验证性</p>
<p>还记得第1章中提到的Kubernetes所依赖的谷歌的Borg和Omega系统吗？和Kubernetes类似，Omega使用一个集中存储模块保存集群状态。不同之处是，多个控制平面组件可以直接访问存储模块。所有这些组件需要确保它们都遵循同一个乐观锁机制，来保证能正确处理冲突。只要有一个组件没有完全遵循该机制就可能导致数据不一致。</p>
<p>Kubemetes对此做了改进，要求所有控制平面组件只能通过API服务器操作存储模块。使用这种方式更新集群状态总是一致的，因为API服务器实现了乐观锁机制，如果有错误的话，也会更少。API服务器同时确保写入存储的数据总是有效的，只有授权的客户端才能更改数据。</p>
<p>确保etcd集群一致性</p>
<p>为保证高可用性，常常会运行多个etcd实例。多个etcd实例需要保持一致。这种分布式系统需要对系统的实际状态达成一致。etcd使用RAFT一致性算法来保证这一点，确保在任何时间点，每个节点的状态要么是大部分节点的当前状态，要么是之前确认过的状态。</p>
<p>连接到etcd集群不同节点的客户端，得到的要么是当前的实际状态，要么是之前的状态（在Kubernetes中，etcd的唯一客户端是API服务器，但有可能有多个实例）。</p>
<p>一致性算法要求集群大部分（法定数量）节点参与才能进行到下一个状态。结果就是，如果集群分裂为两个不互联的节点组，两个组的状态不可能不一致，因为要从之前状态变化到新状态，需要有过半的节点参与状态变更。如果一个组包含了大部分节点，那么另外一组只有少量节点成员。第一个组就可以更改集群状态，后者则不可以。当两个组重新恢复连接，第二个组的节点会更新为第一个组的节点的状态。</p>
<blockquote>
<p>图11.2 在脑裂场景中，只有拥有大部分（法定数量）节点的组会接受状态变更</p>
</blockquote>
<p>为什么etcd实例数量应该是奇数</p>
<p>etcd通常部署奇数个实例。你一定想知道为什么。让我们比较有一个实例和有两个实例的情况时。有两个实例时，要求另一个实例必须在线，这样才能符合超过半数的数量要求。如果有一个宕机，那么etcd集群就不能转换到新状态，因为没有超过半数。两个实例的情况比一个实例的情况更糟。对比单节点宕机，在有两个实例的情况下，整个集群挂掉的概率增加了100%。</p>
<p>比较3节点和4节点也是同样的情况。3节点情况下，一个实例宕机，但超过半数（2个）的节点仍然运行着。对于4节点情况，需要3个节点才能超过半数（2个不够）。对于3节点和4节点，假设只有一个实例会宕机。当以4节点运行时，一个节点失败后，剩余节点宕机的可能性会更大（对比3节点集群，一个节点宕机还剩两个节点的情况）。</p>
<p>通常，对于大集群，etcd集群有5个或7个节点就足够了。可以允许2~3个节点宕机，这对于大多数场景来说足够了。</p>
<h2 id="API服务器做了什么"><a href="#API服务器做了什么" class="headerlink" title="API服务器做了什么"></a>API服务器做了什么</h2><p>KubemetesAPI服务器作为中心组件，其他组件或者客户端（如kubectl）都会去调用它。以RESTfulAPI的形式提供了可以查询、修改集群状态的CRUD（Create、Read、Update、Delete）接口。它将状态存储到etcd中。</p>
<p>API服务器除了提供一种一致的方式将对象存储到etcd，也对这些对象做校验，这样客户端就无法存入非法的对象（直接写入存储的话是有可能的）。除了校验，还会处理乐观锁，这样对于并发更新的情况，对对象做更改就不会被其他客户端覆盖。</p>
<p>API服务器的客户端之一就是本书一开始就介绍使用的命令行工具kubectl。举个例子，当以JSON文件创建一个资源，kubectl通过一个HTTPPOST请求将文件内容发布到API服务器。图11.3显示了接收到请求后API服务器内部发生了什么，后面会做更详细的介绍。</p>
<p>通过认证插件认证客户端</p>
<p>首先，API服务器需要认证发送请求的客户端。这是通过配置在API服务器上的一个或多个认证插件来实现的。API服务器会轮流调用这些插件，直到有一个能确认是谁发送了该请求。这是通过检查HTTP请求实现的。<br>根据认证方式，用户信息可以从客户端证书或者第8章使用的HTTP标头（例如Authorization）获取。插件抽取客户端的用户名、用户ID和归属组。这些数据在下一阶段，认证的时候会用到。<br>通过授权插件授权客户端<br>除了认证插件，API服务器还可以配置使用一个或多个授权插件。它们的作用是决定认证的用户是否可以对请求资源执行请求操作。例如，当创建pod时，API服务器会轮询所有的授权插件，来确认该用户是否可以在请求命名空间创建pod。-旦插件确认了用户可以执行该操作，API服务器会继续下一步操作。<br>通过准入控制插件验证AND/OR修改资源请求<br>如果请求尝试创建、修改或者删除一个资源，请求需要经过准入控制插件的验证。同理，服务器会配置多个准入控制插件。这些插件会因为各种原因修改资源，可能会初始化资源定义中漏配的字段为默认值甚至重写它们。插件甚至会去修改并不在请求中的相关资源，同时也会因为某些原因拒绝一个请求。资源需要经过所有准入控制插件的验证。<br>注意如果请求只是尝试读取数据，则不会做准入控制的验证。<br>准入控制插件包括<br>AlwaysPullImages—重写pod的imagePullPolicy为Always，强制每次部署pod时拉取镜像。<br>serviceAccount-未明确定义服务账户的使用默认账户。<br>·NamespaceLifecycle-防止在命名空间中创建正在被删除的pod，或在不存在的命名空间中创建pod.<br>ResourceQuota—保证特定命名空间中的pod只能使用该命名空间分配数量的资源，如CPU和内存。我们将会在第14章做深入了解。<br>更多的准入控制插件可以在ttps://kubemetes.io/docs/admin/admission-controllers/<br>中查看Kubenetes文档。<br>验证资源以及持久化存储<br>请求通过了所有的准入控制插件后，API服务器会验证存储到etcd的对象，然后返回一个响应给客户端。</p>
<p>11.1.4API服务器如何通知客户端资源变更<br>除了前面讨论的，API服务器没有做其他额外的工作。例如，当你创建一个ReplicaSet资源时，它不会去创建pod，同时它不会去管理服务的端点。那是控制器管理器的工作。<br>API服务器甚至也没有告诉这些控制器去做什么。它做的就是，启动这些控制器，以及其他一些组件来监控已部署资源的变更。控制平面可以请求订阅资源被创建、修改或删除的通知。这使得组件可以在集群元数据变化时候执行任何需要做的任务。<br>客户端通过创建到API服务器的HTTP连接来监听变更。通过此连接，客户端会接收到监听对象的一系列变更通知。每当更新对象，服务器把新版本对象发送至所有监听该对象的客户端。图11.4显示客户端如何监听pod的变更，以及如何将pod的变更存储到etcd，然后通知所有监听该pod的客户端。</p>
<p>图11.4更新对象时，API服务器给所有监听者发送更新过的对象<br>kubectl工具作为API服务器的客户端之一，也支持监听资源。例如，当部署pod时，不需要重复执行kubectlgetpods来定期查询pod列表。可以使用—watch标志，每当创建、修改、删除pod时就会通知你，如下面的代码清单所示。代码清单11.6监听创建删除pod事件</p>
<p>甚至可以让kubectl打印出整个监听事件的YAML文件，如下：<br>$kubectlgetpods-oyaml—watch<br>监听机制同样也可以用于调度器。调度器是下一个要着重讲解的控制平面组件。<br>11.1.5了解调度器<br>前面已经学习过，我们通常不会去指定pod应该运行在哪个集群节点上，这项工作交给调度器。宏观来看，调度器的操作比较简单。就是利用API服务器的监听机制等待新创建的pod，然后给每个新的、没有节点集的pod分配节点。<br>调度器不会命令选中的节点（或者节点上运行的Kubelet）去运行pod。调度器做的就是通过API服务器更新pod的定义。然后API服务器再去通知Kubelet（同样，通过之前描述的监听机制）该pod已经被调度过。当目标节点上的Kubelet发现该pod被调度到本节点，它就会创建并且运行pod的容器。<br>尽管宏观上调度的过程看起来比较简单，但实际上为pod选择最佳节点的任务并不简单。当然，最简单的调度方式是不关心节点上已经运行的pod，随机选择一个节点。另一方面，调度器可以利用高级技术，例如机器学习，来预测接下来几分钟或几小时哪种类型的pod将会被调度，然后以最大的硬件利用率、无须重新调度已运行pod的方式来调度。Kubernetes的默认调度器实现方式处于最简单和最复杂程度之间。<br>默认的调度算法<br>选择节点操作可以分解为两部分，如图11.5所示：<br>过滤所有节点，找出能分配给pod的可用节点列表。<br>对可用节点按优先级排序，找出最优节点。如果多个节点都有最高的优先级分数，那么则循环分配，确保平均分配给pod。</p>
<p>图11.5调度器为pod找到可用节点，然后选择最优节点<br>查找可用节点<br>为了决定哪些节点对pod可用，调度器会给每个节点下发一组配置好的预测函</p>
<p>数。这些函数检查<br>节点是否能满足pod对硬件资源的请求。第14章会学习如何定义它们。节点是否耗尽资源（是否报告过内存/硬盘压力参数）？<br>pod是否要求被调度到指定节点（通过名字），是否是当前节点？<br>节点是否有和pod规格定义里的节点选择器一致的标签（如果定义了的话）？如果pod要求绑定指定的主机端口（第13章中讨论）那么这个节点上的这个端口是否已经被占用？<br>如果pod要求有特定类型的卷，该节点是否能为此pod加载此卷，或者说该节点上是否已经有pod在使用该卷了？<br>pod是否能够容忍节点的污点。污点以及容忍度在第16章讲解。<br>pod是否定义了节点、pod的亲缘性以及非亲缘性规则？如果是，那么调度节点给该pod是否会违反规则？这个也会在第16章介绍。<br>所有这些测试都必须通过，节点才有资格调度给pod。在对每个节点做过这些检查后，调度器得到节点集的一个子集。任何这些节点都可以运行pod，因为它们都有足够的可用资源，也确认过满足pod定义的所有要求。<br>为pod选择最佳节点<br>尽管所有这些节点都能运行pod，其中的一些可能还是优于另外一些。假设有一个2节点集群，两个节点都可用，但是其中一个运行10个pod，而另一个，不知道什么原因，当前没有运行任何pod。本例中，明显调度器应该选第二个节点。<br>或者说，如果两个节点是由云平台提供的服务，那么更好的方式是，pod调度给第一个节点，将第二个节点释放回云服务商以节省资金。<br>pod高级调度<br>考虑另外一个例子。假设一个pod有多个副本。理想情况下，你会期望副本能够分散在尽可能多的节点上，而不是全部分配到单独一个节点上。该节点的宕机会导致pod支持的服务不可用。但是如果pod分散在不同的节点上，单个节点宕机，并不会对服务造成什么影响。<br>默认情况下，归属同一服务和ReplicaSet的pod会分散在多个节点上。但不保证每次都是这样。不过可以通过定义pod的亲缘性、非亲缘规则强制pod分散在集群内或者集中在一起，相关内容会在第16章中介绍。<br>仅通过这两个简单的例子就说明了调度有多复杂，因为它依赖于大量的因子。因此，调度器既可以配置成满足特定的需要或者基础设施特性，也可以整体替换为一个定制的实现。可以抛开调度器运行一个Kubernetes，不过那样的话，就需要手动实现调度了。</p>
<p>使用多个调度器<br>可以在集群中运行多个调度器而非单个。然后，对每一个pod，可以通过在pod特性中设置schedulerName）属性指定调度器来调度特定的pod。<br>未设置该属性的pod由默认调度器调度，因此其schedulerName被设置为default-scheduler。其他设置了该属性的pod会被默认调度器忽略掉，它们要么是手动调用，要么被监听这类pod的调度器调用。<br>可以实现自己的调度器，部署到集群，或者可以部署有不同配置项的额外Kubernetes调度器实例。<br>11.1.6介绍控制器管理器中运行的控制器<br>如前面提到的，API服务器只做了存储资源到etcd和通知客户端有变更的工作。调度器则只是给pod分配节点，所以需要有活跃的组件确保系统真实状态朝API服务器定义的期望的状态收敛。这个工作由控制器管理器里的控制器来实现。<br>单个控制器、管理器进程当前组合了多个执行不同非冲突任务的控制器。这些控制器最终会被分解到不同的进程，如果需要的话，我们能够用自定义实现替换它们每一个。控制器包括<br>Replication管理器（ReplicationController资源的管理器）<br>ReplicaSet、DaemonSet以及Job控制器<br>Deployment控制器<br>StatefulSet控制器<br>Node控制器<br>Service控制器<br>Endpoints控制器<br>Namespace控制器<br>PersistentVolume控制器<br>·其他<br>每个控制器做什么通过名字显而易见。通过上述列表，几乎可以知道创建每个资源对应的控制器是什么。资源描述了集群中应该运行什么，而控制器就是活跃的Kubernetes组件，去做具体工作部署资源。<br>了解控制器做了什么以及如何做的<br>控制器做了许多不同的事情，但是它们都通过API服务器监听资源（部署、服务等）变更，并且不论是创建新对象还是更新、删除已有对象，都对变更执行相应操作。大多数情况下，这些操作涵盖了新建其他资源或者更新监听的资源本身（例如，更新对象的status）。</p>
<p>总的来说，控制器执行一个“调和”循环，将实际状态调整为期望状态（在资源spec部分定义），然后将新的实际状态写入资源的status部分。控制器利用监听机制来订阅变更，但是由于使用监听机制并不保证控制器不会漏掉时间，所以仍然需要定期执行重列举操作来确保不会丢掉什么。<br>控制器之间不会直接通信，它们甚至不知道其他控制器的存在。每个控制器都连接到API服务器，通过ll.1.3节描述的监听机制，请求订阅该控制器负责的一系列资源的变更。<br>我们概括地了解了每个控制器做了什么，但是如果你想深入了解它们做了什么，建议直接看源代码。边栏阐述了如何.上手看源代码。<br>浏览控制器源代码的几个要点<br>如果你对控制器如何运作感兴趣，强烈推荐看一遍源代码。为了更容易上手，下面有几个小建议：<br>控制器的源代码可以从https：/gthub.com/kubernetes/kubermetes/blob/master/pkg/controller获取。<br>每个控制器一般有一个构造器，内部会创建一个Informer，其实是个监听器，每次API对象有更新就会被调用。通常，Informer会监听特定类型的资源变更事件。查看构造器可以了解控制器监听的是哪个资源。<br>接下来，去看worker（）方法。其中定义了每次控制器需要工作的时候都会调用worker（）方法。实际的函数通常保存在一个叫syncHandler或类似的字段里。该字段也在构造器里初始化，可以在那里找到被调用函数名。该函数是所有魔法发生的地方。<br>Replication管理器<br>启动ReplicationController资源的控制器叫作Replication管理器。第4章我们介绍过ReplicationController是如何工作的，其实不是ReplicationController做了实际的工作，而是Replication管理器。让我们快速回顾下该控制器做了什么，这有助于你理解其他控制器。<br>在第4章中，我们说过，ReplicationController的操作可以理解为-个无限循环，每次循环，控制器都会查找符合其pod选择器定义的pod的数量，并且将该数值和期望的复制集（replica）数量做比较。<br>既然你知道了API服务器可以通过监听机制通知客户端，那么明显地，控制器不会每次循环去轮询pod，而是通过监听机制订阅可能影响期望的复制集（replica）数量或者符合条件pod数量的变更事件（见图l1.6）。任何该类型的变化，将触发控</p>
<p>制器重新检查期望的以及实际的复制集数量，然后做出相应操作。<br>你已经知道，当运行的pod实例太少时，ReplicationController会运行额外的实例，但它自己实际上不会去运行pod。它会创建新的pod清单，发布到API服务器，让调度器以及Kubelet来做调度工作并运行pod。</p>
<p>图11.6Replication管理器监听AP|对象变更<br>Replication管理器通过API服务器操纵podAPI对象来完成其工作。所有控制器就是这样运作的。<br>RerlicaSet、DaemonSet以及Job控制器<br>ReplicaSet控制器基本上做了和前面描述的Replication管理器一样的事情，所以这里不再赘述。DaemonSet以及Job控制器比较相似，从它们各自资源集中定义的pod模板创建pod资源。与Replication管理器类似，这些控制器不会运行pod，而是将pod定义到发布API服务器，让Kubelet创建容器并运行。<br>Deployment控制器<br>Deployment控制器负责使deployment的实际状态与对应DeploymentAPI对象的期望状态同步。<br>每次Deployment对象修改后（如果修改会影响到部署的pod），Deployment控制器都会滚动升级到新的版本。通过创建一个ReplicaSet，然后按照Deployment中定义的策略同时伸缩新、旧RelicaSet，直到旧pod被新的代替。并不会直接创建任何pod。<br>StatefulSet控制器<br>StatefulSet控制器，类似于ReplicaSet控制器以及其他相关控制器，根据StatefulSet资源定义创建、管理、删除pod。其他的控制器只管理pod，而</p>
<p>StatefulSet控制器会初始化并管理每个pod实例的持久卷声明字段。<br>Node控制器<br>Node控制器管理Node资源，描述了集群工作节点。其中，Node控制器使节点对象列表与集群中实际运行的机器列表保持同步。同时监控每个节点的健康状态，删除不可达节点的pod。<br>Node控制器不是唯一对Node对象做更改的组件。Kubelet也可以做更改，那么显然可以由用户通过RESTAPI调用做更改。<br>Service控制器<br>在第5章，当我们讨论服务时，你已经了解了存在不同服务类型。其中一个是LoadBalancer服务，从基础设施服务请求一个负载均衡器使得服务外部可以用。Service控制器就是用来在LoadBalancer类型服务被创建或删除时，从基础设施服务请求、释放负载均衡器的。<br>Endpoint控制器<br>你会想起来，Service不会直接连接到pod，而是包含一个端点列表（IP和端口），列表要么是手动，要么是根据Service定义的pod选择器自动创建、更新。Endpoint控制器作为活动的组件，定期根据匹配标签选择器的pod的IP、端口更新端点列表。<br>如图11.7所示，控制器同时监听了Service和pod。当Service被添加、修改，或者pod被添加、修改或删除时，控制器会选中匹配Service的pod选择器的pod，将其IP和端口添加到Endpoint资源中。请记住，Endpoint对象是个独立的对象，所以当需要的时候控制器会创建它。同样地，当删除Service时，Endpoint对象也会被删除。</p>
<p>Namespace控制器<br>想起命名空间了吗（第3章里讨论过）？大部分资源归属于某个特定命名空间。当删除—个Namespace资源时，该命名空间里的所有资源都会被删除。这就是Namespace控制器做的事情。当收到删除Namespace对象的通知时，控制器通过API服务器删除所有归属该命名空间的资源。<br>PersistentVolume控制器<br>第6章学习过持久卷以及持久卷声明。一旦用户创建了一个持久卷声明，Kubernetes必须找到一个合适的持久卷同时将其和声明绑定。这些由持久卷控制器实现<br>对于一个持久卷声明，控制器为声明查找最佳匹配项，通过选择匹配声明中的访问模式，并且声明的容量大于需求的容量的最小持久卷。实现方式是保存一份有序的持久卷列表，对于每种访问模式按照容量升序排列，返回列表的第一个卷。<br>当用户删除持久卷声明时，会解绑卷，然后根据卷的回收策略进行回收（原样保留、删除或清空）。<br>唤醒控制器<br>现在，总体来说你应该对每个控制器做了什么，以及是如何工作的有个比较好的感觉了。再一次强调，所有这些控制器是通过API服务器来操作API对象的。它们不会直接和Kubelet通信或者发送任何类型的指令。实际上，它们不知道Kubelet的存在。控制器更新API服务器的一个资源后，Kubelet和KubernetesServiceProxy（也不知道控制器的存在）会做它们的工作，例如启动pod容器、加载网络存储，或者就服务而言，创建跨pod的负载均衡。<br>控制平面处理了整个系统的一部分操作，为了完全理解Kubernetes集群的内部运作方式，还需要理解Kubelet和KubernetesServiceProxy做了什么。下面将学习这些内容。<br>11.1.7Kubelet做了什么<br>所有Kubernetes控制平面的控制器都运行在主节点上，而Kubelet以及ServiceProxy都运行在工作节点（实际pod容器运行的地方）上。Kubelet究竟做了什么事情？了解Kubelet的工作内容<br>简单地说，Kubelet就是负责所有运行在工作节点上内容的组件。它第一个任务就是在API服务器中创建一个Node资源来注册该节点。然后需要持续监控API服务器是否把该节点分配给pod，然后启动pod容器。具体实现方式是告知配置好的</p>
<p>容器运行时（Docker、CoreOS的Rkt，或者其他一些东西）来从特定容器镜像运行容器。Kubelet随后持续监控运行的容器，向API服务器报告它们的状态、事件和资源消耗。<br>Kubelet也是运行容器存活探针的组件，当探针报错时它会重启容器。最后一点，当pod从API服务器删除时，Kubelet终止容器，并通知服务器pod已经被终止了。抛开API服务器运行静态pod<br>尽管Kubelet一般会和API服务器通信并从中获取pod清单，它也可以基于本地指定目录下的pod清单来运行pod，如图11.8所示。如本章开头所示，该特性用于将容器化版本的控制平面组件以pod形式运行。<br>不但可以按照原有的方式运行Kubernetes系统组件，也可以将pod清单放到Kubelet的清单目录中，让Kubelet运行和管理它们。</p>
<p>图11.8Kubelet基于API服务器/本地文件目录中的pod定义运行pod<br>也可以同样的方式运行自定义的系统容器，不过推荐用DaemonSet来做这项工作。<br>11.1.8KubernetesServiceProxy的作用<br>除了Kubelet，每个工作节点还会运行kube-proxy，用于确保客户端可以通过KubernetesAPI连接到你定义的服务。kube-proxy确保对服务IP和端口的连接最终能到达支持服务（或者其他，非pod服务终端）的某个pod处。如果有多个pod支撑一个服务，那么代理会发挥对pod的负载均衡作用。</p>
<p>为什么被叫作代理<br>kube-proxy最初实现为userspace代理。利用实际的服务器集成接收连接，同时代理给pod。为了拦截发往服务IP的连接，代理配置了iptables规则（iptables是一个管理Linux内核数据包过滤功能的工具），重定向连接到代理服务器。userspace代理模式大致如图11.9所示。</p>
<p>图11.9userspace代理模式<br>kube-proxy之所以叫这个名字是因为它确实就是一个代理器，不过当前性能更好的实现方式仅仅通过iptables规则重定向数据包到一个随机选择的后端pod，而不会传递到一个实际的代理服务器。这个模式称为iptables代理模式，如图11.10所示。</p>
<p>图11.10iptables代理模式<br>两种模式的主要区别是：数据包是否会传递给kube-proxy，是否必须在用户空间处理，或者数据包只会在内核处理（内核空间）。这对性能有巨大的影响。<br>另外一个小的区别是：userspace代理模式以轮询模式对连接做负载均衡，而iptables代理模式不会，它随机选择pod。当只有少数客户端使用一个服务时，可能不会平均分布在pod中。例如，如果一个服务有两个pod支持，但有5个左右的客户端，如果你看到4个连接到podA，而只有一个连接到podB，不必惊讶。对于客户端数量更多的pod，这个问题就不会特别明显。<br>在11.5节你会学习iptables代理模式具体是如何工作的。<br>11.1.9介绍Kubernetes插件<br>我们已经讨论了Kubernetes集群正常工作所需要的一些核心组件。但在开头的几章中，我们也罗列了一些插件，它们不是必需的；这些插件用于启用Kubernetes</p>
<p>服务的DNS查询，通过单个外部IP地址暴露多个HTTP服务、Kubernetesweb仪表板等特性。<br>如何部署插件<br>通过提交YAML清单文件到API服务器（本书的通用做法），这些组件会成为插件并作为pod部署。有些组件是通过Deployment资源或者ReplicationController资源部署的，有些是通过DaemonSeto<br>例如，写作本书时，在Minikube中，Ingress控制器和仪表板插件按照ReplicationController部署，如下面的代码清单所示。<br>代码清单11.7插件在Minikube中作为ReplicationController部署</p>
<p>DNS插件作为Deployment部署，如下面的代码清单所示。<br>代码清单11.8<br>kube-dnsDeployment<br>$kubectlgetdeploy-nkube-system<br>NAME<br>DESIREDCURRENTUP-TO-DATEAVAILABLEAGE<br>kube-dns1<br>1<br>1<br>1<br>6d<br>让我们看看DNS和Ingress控制器是如何工作的。<br>DNS服务器如何工作<br>集群中的所有pod默认配置使用集群内部DNS服务器。这使得pod能够轻松地通过名称查询到服务，甚至是无头服务pod的IP地址。<br>DNS服务pod通过kube-dns服务对外暴露，使得该pod能够像其他pod一样在集群中移动。服务的IP地址在集群每个容器的/etc/reslv.conf文件的nameserver中定义。kube-dnspod利用API服务器的监控机制来订阅Service和Endpoint的变动，以及DNS记录的变更，使得其客户端（相对地）总是能够获取到最新的DNS信息。客观地说，在Service和Endpoint资源发生变化到DNSpod收到订阅通知时间点之间，DNS记录可能会无效。<br>Ingress控制器如何工作<br>和DNS插件相比，Ingress控制器的实现有点不同，但它们大部分的工作方式相同。Ingress控制器运行一个反向代理服务器（例如，类似Nginx），根据集群中定</p>
<p>义的Ingress、Service以及Endpoint资源来配置该控制器。所以需要订阅这些资源（通过监听机制），然后每次其中一个发生变化则更新代理服务器的配置。<br>尽管Ingress资源的定义指向一个Service，Ingress控制器会直接将流量转到服务的pod而不经过服务IP。当外部客户端通过Ingress控制器连接时，会对客户端IP进行保存，这使得在某些用例中，控制器比Service更受欢迎。<br>使用其他插件<br>你已经了解了DNS服务器和Ingress控制器插件同控制器管理器中运行的控制器比较相似，除了它们不会仅通过API服务器监听、修改资源，也会接收客户端的连接。<br>其他插件也类似。它们都需要监听集群状态，当有变更时执行相应动作。我们会在剩余的章节中介绍一些其他的插件。<br>11.1.10总结概览<br>你已经了解了整个Kubemetes系统由相对小的、完善功能划分的松耦合组件构成。API服务器、调度器、控制器管理器中运行的控制器、Kubelet以及kube-proxy一起合作来保证实际的状态和你定义的期望状态一致。<br>例如，向API服务器提交一个pod配置会触发Kubemetes组件间的协作，这会导致pod的容器运行。这里的细节将会在接下来的部分详细说明。<br>11.2控制器如何协作<br>现在你了解了Kubernetes集群包含哪些组件。为了强化对Kubernetes工作方式的理解，让我们看一下当一个pod资源被创建时会发生什么。因为一般不会直接创建pod，所以创建Deployment资源作为替代，然后观察启动pod的容器会发生什么。<br>11.2.1了解涉及哪些组件<br>在你启动整个流程之前，控制器、调度器、Kubelet就已经通过API服务器监听它们各自资源类型的变化了。如图11.11所示。图中描画的每个组件在即将触发的流程中都起到一定的作用。图表中不包含etcd，因为它被隐藏在API服务器之后，可以想象成API服务器就是对象存储的地方。</p>
<p>图11.11Kubernetes组件通过API服务器监听API对象<br>11.2.2事件链<br>准备包含Deployment清单的YAML文件，通过kubetctl提交到Kubenetes。kubectl通过HTTPPOST请求发送清单到KubernetesAPI服务器。API服务器检查Deployment定义，存储到etcd，返回响应给kubectl。现在事件链开始被揭示出来，如图11.12所示。</p>
<p>Deployment控制器生成ReplicaSet<br>当新创建Deployment资源时，所有通过API服务器监听机制监听Deployment列表的客户端马上会收到通知。其中有个客户端叫Deployment控制器，之前讨论过，该控制器是一个负责处理部署事务的活动组件。<br>回忆一下第9章的内容，一个Deployment由一个或多个Replicaset支持，ReplicaSet后面会创建实际的pod。当Deployment控制器检查到有一个新的Deployment对象时，会按照Deploymnet当前定义创建ReplicaSet。这包括通过KubemetesAPI创建一个新的ReplicaSet资源。Deployment控制器完全不会去处理单个pod。<br>ReplicaSet控制器创建pod资源<br>新创建的ReplicaSet由ReplicaSet控制器（通过API服务器创建、修改、删除ReplicaSet资源）接收。控制器会考虑replica数量、ReplicaSet中定义的pod选择器，然后检查是否有足够的满足选择器的pod。<br>然后控制器会基于ReplicatSet的pod模板创建pod资源（当Deployment控制器创建ReplicaSet时，会从Deployment复制pod模板）。<br>调度器分配节点给新创建的pod<br>新创建的pod目前保存在etcd中，但是它们每个都缺少一个重要的东西一它们还没有任何关联节点。它们的nodeName属性还未被设置。调度器会监控像这样的pod，发现一个，就会为pod选择最佳节点，并将节点分配给pod。pod的定义现在就会包含它应该运行在哪个节点。<br>目前，所有的一切都发生在Kubernetes控制平面中。参与这个全过程的控制器没有做其他具体的事情，除了通过API服务器更新资源。<br>Kubelet运行pod容器<br>目前，工作节点还没做任何事情，pod容器还没有被启动起来，pod容器的图片还没有下载。<br>随着pod目前分配给了特定的节点，节点上的Kubelet终于可以工作了。Kubelet通过API服务器监听pod变更，发现有新的pod分配到本节点后，会去检查pod定义，然后命令Docker或者任何使用的容器运行时来启动pod容器，容器运行时就会去运行容器。<br>11.2.3观察集群事件<br>控制平面组件和Kubelet执行动作时，都会发送事件给API服务器。发送事件</p>
<p>是通过创建事件资源来实现的，事件资源和其他的Kuberetes资源类似。每次使用kubectldescribe来检查资源的时候，就能看到资源相关的事件，也可以直接用kubectlgetevents获取事件。<br>可能是个人的感受，使用kubectlget检查事件比较痛苦，因为不是以合适的时间顺序显示的。当一个事件发生了多次，该事件只会被显示一次，显示首次出现时间、最后一次出现时间以及发生次数。幸运的是，利用—watch选项监听事件肉眼看起来更简单，对于观察集群发生了什么也更有用。<br>下面的代码清单展示了前述过程中发出的事件（由于页面空间有限，有些列被删掉了，输出也做了改动）。<br>代码清单11.9观察控制器发出的事件</p>
<p>如你所见，SOURCE列显示执行动作的控制器，NAME和KIND列显示控制器用的资源。REASON列以及MESSAGE列（显示在每一项的第二行）提供控制器做的更详细的信息。<br>11.3了解运行中的pod是什么<br>33<br>11.3<br>了解运行中的pod是什么<br>当pod运行时，让我们仔细看一下，运行的pod到底是什么。如果pod包含单个容器，你认为Kubelet会只运行单个容器，还是更多？<br>读本书的过程中，你已经运行过多个pod了。如果你是个喜欢深究的人，那么你可能已经看过，当你创建一个pod时实际运行的Docker。如果没有，让笔者为你解释。<br>想象你运行单个容器的pod，假设创建了一个Nginxpod：<br>$kubectlrunnginx—image=nginx<br>deployment”nginx”created<br>此时，可以ssh到运行pod的工作节点，检查一系列运行的Docker容器。笔者用的是Minikube，所以使用minikubessh来ssh到单个节点。如果你用GKE，可以通过gcloudcomputessh<nodename>来ssh到一个节点。<br>一旦进入节点内部，可以通过dockerps命令列出所有运行的容器，如下面的代码清单所示。<br>代码清单11.10列出运行的Docker容器</nodename></p>
<p>注意笔者已经把不相关的信息（包含列和行）从前面的代码清单中删除了，也删除了所有其他运行的容器。如果你自己尝试该命令，注意几秒前创建的两个容器，<br>如你所望，你看到了Nginx容器，以及一个附加容器。从cOMMAND列判断，附加容器没有做任何事情（容器命令是”pause”）。如果仔细观察，你会发现容器是在Nginx容器前几秒创建的。它的作用是什么？<br>被暂停的容器将一个pod所有的容器收纳到一起。还记得一个pod的所有容器是如何共享同一个网络和Linux命名空间的吗？暂停的容器是一个基础容器，它的唯一目的就是保存所有的命名空间。所有pod的其他用户定义容器使用pod的该基础容器的命名空间（见图11.13）。</p>
<p>图11.13一个双容器pod有3个运行的容器，共享同一个Linux命名空间<br>实际的应用容器可能会挂掉并重启。当容器重启，容器需要处于与之前相同的Linux命名空间中。基础容器使这成为可能，因为它的生命周期和pod绑定，基础容器pod被调度直到被删除一直会运行。如果基础pod在这期间被关闭，Kubelet会重新创建它，以及pod的所有容器。<br>11.4跨pod网络<br>现在，你知道每个pod有自己唯一的IP地址，可以通过一个扁平的、非NAT网络和其他pod通信。Kubemetes是如何做到这一点的？简单来说，Kubemetes不负责这块。网络是由系统管理员或者ContainerNetworkInterface（CNI）插件建立的，而非Kuberetes本身。<br>11.4.1网络应该是什么样的<br>Kubemetes并不会要求你使用特定的网络技术，但是授权pod（或者更准确地说，其容器）不论是否运行在同一个工作节点上，可以互相通信。pod用于通信的网络必须是：pod自己认为的IP地址一定和所有其他节点认为该pod拥有的IP地址一致。<br>查看图11.14。当podA连接（发送网络包）到podB时，podB获取到的源IP地址必须和podA自己认为的IP地址一致。其间应该没有网络地址转换（NAT）操作一podA发送到podB的包必须保持源和目的地址不变。<br>这很重要，保证运行在pod内部的应用网络的简洁性，就像运行在同一个网关机上一样。pod没有NAT使得运行在其中的应用可以自己注册在其他pod中。</p>
<p>图11.14Kubernetes规定pod必须通过非NAT网络进行连接<br>例如，有客户端podX和podY，为所有通过它们注册的pod提供通知服务。podX连接到podY并且告诉podY，“你好，我是podX，IP地址为1.2.3.4.清把更新发送到这个IP地址”。提供服务的pod可以通过收到的IP地址连接第一个pod。<br>pod到节点及节点到pod通信也应用了无NAT通信。但是当pod和internet上的服务通信时，pod发送包的源IP不需要改变，因为pod的IP是私有的。向外发送包的源IP地址会被改成主机工作节点的IP地址。<br>构建一个像样的Kubernetes集群包含按照这些要求建立网络。有不同的方法和技术来建立，在给定场景中它们都有其优点和缺点。因此，我们不会深入探究特定的技术，会阐述跨pod网络通用的工作原理。<br>11.4.2深入了解网络工作原理<br>在11.3节，我们看到创建了pod的IP地址以及网络命名空间，由基础设施容器（暂停容器）来保存这些信息，然后pod容器就可以使用网络命名空间了。pod网络接口就是生成在基础设施容器的一些东西。让我们看一下接口是如何被创建的，以及如何连接到其他pod的接口，如图11.15所示。</p>
<p>图11.15同一节点上pod通过虚拟Ethernet接口对连接到同-个桥接<br>同节点pod通信<br>基础设施容器启动之前，会为容器创建一个虚拟Ethemet接口对（一个vethpair），其中一个对的接口保留在主机的命名空间中（在节点上运行ifconfig命令时可以看到vethXXX的条目），而其他的对被移入容器网络命名空间，并重命名为eth0。两个虚拟接口就像管道的两端（或者说像Ethernet电缆连接的两个网络设备）从一端进入，另一端出来，等等。<br>主机网络命名空间的接口会绑定到容器运行时配置使用的网络桥接上。从网桥的地址段中取IP地址赋值给容器内的ethO接口。应用的任何运行在容器内部的程序都会发送数据到ethO网络接口（在容器命名空间中的那一个），数据从主机命名空间的另一个veth接口出来，然后发送给网桥。这意味着任何连接到网桥的网络接口都可以接收该数据。<br>如果podA发送网络包到podB，报文首先会经过podA的veth对到网桥然后经过podB的veth对。所有节点上的容器都会连接到同-个网桥，意味着它们都能够互相通信。但是要让运行在不同节点上的容器之间能够通信，这些节点的网桥需要以某种方式连接起来。<br>不同节点上的pod通信<br>有多种连接不同节点上的网桥的方式。可以通过overlay或underlay网络，或者常规的三层路由，我们会在后面看到。<br>跨整个集群的pod的IP地址必须是唯一的，所以跨节点的网桥必须使用非重叠地址段，防止不同节点上的pod拿到同一个IP。如图11.16所示的例子，节点A上的网桥使用10.1.1.0/24IP段，节点B.上的网桥使用10.1.2.0/24IP段，确保没有IP地址冲突的可能性。<br>图11.16显示了通过三层网络支持跨两个节点pod通信，节点的物理网络接口</p>
<p>也需要连接到网桥。节点A的路由表需要被配置成图中所示，这样所有目的地为10.1.2.0/24的报文会被路由到节点B，同时节点B的路由表需要被配置成图中所示，这样发送到10.1.1.0/24的包会被发送到节点A。</p>
<p>图11.16为了让不同节点上的pod能够通信，网桥需要以某种方式连接<br>按照该配置，当报文从一个节点上容器发送到其他节点上的容器，报文先通过vethpair，通过网桥到节点物理适配器，然后通过网线传到其他节点的物理适配器，再通过其他节点的网桥，最终经过vethpair到达目标容器。<br>仅当节点连接到相同网关、之间没有任何路由时上述方案有效。否则，路由器会扔包因为它们所涉及的podIP是私有的。当然，也可以配置路由使其在节点间能够路由报文，但是随着节点数量增加，配置会变得更困难，也更容易出错。因此，使用SDN（软件定义网络）技术可以简化问题，SDN可以让节点忽略底层网络拓扑，无论多复杂，结果就像连接到同一个网关上。从pod发出的报文会被封装，通过网络发送给运行其他pod的网络，然后被解封装、以原始格式传递给pod。<br>11.4.3<br>引入容器网络接口<br>为了让连接容器到网络更加方便，启动一个项目容器网络接口（CNI）。CNI允许Kubernetes可配置使用任何CNI插件。这些插件包含<br>●Calico<br>●Flannel<br>Romana<br>WeaveNet<br>·其他<br>我们不会去深入探究这些插件的细节，如果想要了解更多，可以参考https://</p>
<p>kubemetes.io/docs/concepts/cluster-administration/addons/.<br>安装一个网络插件并不难，只需要部署一个包含DaemonSet以及其他支持资源的YAML。每个插件项目首页都会提供这样一个YAML文件。如你所想，DaemonSet用于往所有集群节点部署一个网络代理，然后会绑定CNI接口到节点。但是，注意Kubetlet需要用—network-plugin=cni命令启动才能使用CNI.11.5服务是如何实现的<br>在第5章中学习过Service，Service允许长时间对外暴露一系列pod、稳定的IP地址以及端口。为了聚焦Service的目的以及它们如何被使用，我们当时并没有深入探究其工作原理。但是，要真正理解服务，并更好地了解当事情的行为与预期不一致时应该从哪着手，就需要了解服务的实现原理。<br>11.5.1引入kube-proxy<br>和Service相关的任何事情都由每个节点上运行的kube-proxy进程处理。开始的时候，kube-proxy确实是一个proxy，等待连接，对每个进来的连接，连接到一个pod。这称为userspace（用户空间）代理模式。后来，性能更好的iptables代理模式取代了它。iptables代理模式目前是默认的模式，如果你有需要也仍然可以配置Kubemetes使用旧模式。<br>在我们继续之前，先快速回顾一下Service的几个知识点，对理解下面几段有帮助。<br>我们之前了解过，每个Service有其自己稳定的IP地址和端口。客户端（通常为pod）通过连接该IP和端口使用服务。IP地址是虚拟的，没有被分配给任何网络接口，当数据包离开节点时也不会列为数据包的源或目的IP地址。Service的一个关键细节是，它们包含一个IP、端口对（或者针对多端口Service有多个IP、端口对），所以服务IP本身并不代表任何东西。这就是为什么你不能够ping它们。<br>11.5.2kube-proxy如何使用iptables<br>当在API服务器中创建一个服务时，虚拟IP地址立刻就会分配给它。之后很短时间内，API服务器会通知所有运行在工作节点上的kube-proxy客户端有一个新服务已经被创建了。然后，每个kube-proxy都会让该服务在自己的运行节点上可寻址。原理是通过建立一些iptables规则，确保每个目的地为服务的IP/端口对的数据包被解析，目的地址被修改，这样数据包就会被重定向到支持服务的一个pod.<br>除了监控API对Service的更改，kube-proxy也监控对Endpoint对象的更改。</p>
<p>我们在第5章讨论过，下面回顾一下，因为你基本上不会去手动创建它们，所以比较容易忘记它们的存在。Endpoint对象保存所有支持服务的pod的IP/端口对（一个IP/端口对也可以指向除pod之外的其他对象）。这就是为什么kube-proxy必须监听所有Endpoint对象。毕竟Endpoint对象在每次新创建或删除支持pod时都会发生变更，当pod的就绪状态发生变化或者pod的标签发生变化，就会落入或超出服务的范畴。<br>现在让我们了解一下kube-proxy如何让客户端能够通过Service连接到这些pod，如图11.17所示。</p>
<p>图11.17发送到服务虚拟IP/端口对的网络包会被修改、重定向到一个随机选择的后端pod<br>图中描述kube-proxy做了什么，以及数据包如何通过客户端pod发送到支持服务的一个pod.上。让我们检查一下当通过客户端pod（图中的podA）发送数据包时发生了什么。<br>包目的地初始设置为服务的IP和端口（在本例中，Service是在172.30.0.1:80）。发送到网络之前，节点A的内核会根据配置在该节点上的iptables规则处理数据包。</p>
<p>内核会检查数据包是否匹配任何这些iptables规则。其中有个规则规定如果有任何数据包的目的地IP等于172.30.0、1目的地端口等于80，那么数据包的目的地IP和端口应该被替换为随机选中的pod的IP和端口。<br>本例中的数据包满足规则，故而它的IP/端口被改变了。在本例中，podB2被随机选中了，所有数据包的目的地IP变更为10.1.2.（podB2的IP），端口改为8080（Service中定义的目标端口）。就好像是，客户端pod直接发送数据包给podB而不是通过Service。<br>实际上可能比描述的要更复杂一点儿，但是上述内容是你需要理解的最重要的内容。<br>11.6<br>运行高可用集群<br>在Kubemetes上运行应用的一个理由就是，保证运行不被中断，或者说尽量少地人工介入基础设施导致的宕机。为了能够不中断地运行服务，不仅应用要一直运行，Kubemetes控制平面的组件也要不间断运行。接下来我们了解一下达到高可用性需要做到什么。<br>11.6.1让你的应用变得高可用<br>当在Kubernetes运行应用时，有不同的控制器来保证你的应用平滑运行，即使节点宕机也能够保持特定的规模。为了保证你的应用的高可用性，只需通过Deployment资源运行应用，配置合适数量的复制集，其他的交给Kubernetes处理。运行多实例来减少宕机可能性<br>需要你的应用可以水平扩展，不过即使不可以，仍然可以使用Deployment，将复制集数量设为1。如果复制集不可用，会快速替换为一个新的，尽管不会同时发生。让所有相关控制器都发现有节点宕机、创建新的pod复制集、启动pod容器可能需要一些时间。不可避免中间会有小段宕机时间。<br>对不能水平扩展的应用使用领导选举机制<br>为了避免宕机，需要在运行一个活跃的应用的同时再运行一个附加的非活跃复制集，通过一个快速起效租约或者领导选举机制来确保只有一个是有效的。以防你不熟悉领导者选举算法，提一下，它是一种分布式环境中多应用实例对谁是领导者达成一致的方式。例如，领导者要么是唯一执行任务的那个，其他所有节点都在等待该领导者宕机，然后自己变成领导者；或者是都是活跃的，但是领导者是唯一能够执行写操作的，而其他的只能读数据。这样能保证两个实例不会做同一个任务，</p>
<p>否则会因为竞争条件导致不可预测的系统行为。<br>该机制自身不需要集成到应用中，可以使用一个sidecar容器来执行所有的领导选举操作，通知主容器什么时候它应该活跃起来。一个Kubernetes中领导选举的例子：<a href="https://github.com/kubernetes/contrib/tree/master/election。" target="_blank" rel="noopener">https://github.com/kubernetes/contrib/tree/master/election。</a><br>保证应用高可用相对简单，因为Kubernetes几乎替你完成所有事情。但是假如Kubernetes自身宕机了呢？如果是运行Kubernetes控制平面组件的服务器挂了呢？这些组件是如何做到高可用的呢？<br>11.6.2让Kubernetes控制平面变得高可用<br>本章一开始，学习了Kubernetes控制平面的一些组件。为了使得Kubernetes高可用，需要运行多个主节点，即运行下述组件的多个实例：<br>etcd分布式数据存储，所有API对象存于此处<br>API服务器<br>·控制器管理器，所有控制器运行的进程<br>调度器<br>不需要深入了解如何安装和运行这些组件的细节。让我们看一下如何让这些组件高可用。图11.18显示了一个高可用集群的概览。</p>
<p>图11.18三节点高可用集群<br>运行etcd集群<br>因为etcd被设计为一个分布式系统，其核心特性之一就是可以运行多个etcd实例，所以它做到高可用并非难事。你要做的就是将其运行在合适数量的机器上（3个、</p>
<p>5个或者7个，如章节刚开始所述），使得它们能够互相感知。实现方式通过在每个实例的配置中包含其他实例的列表。例如，当启动一个实例时，指定其他etcd实例可达的IP和端口。<br>etcd会跨实例复制数据，所以三节点中其中一个宕机并不会影响处理读写操作。为了增加错误容忍度不仅仅支持一台机器宕机，需要运行5个或者7个etcd节点，这样集群可以分别容忍2个或者3个节点宕机。拥有超过7个实例基本上没有必要，并且会影响性能。<br>运行多实例API服务器<br>保证API服务器高可用甚至更简单，因为API服务器是（几乎全部）无状态的（所有数据存储在etcd中，API服务器不做缓存），你需要多少就能运行多少API服务器，它们直接不需要感知对方存在。通常，一个API服务器会和每个etcd实例搭配。这样做，etcd实例之前就不需要任何负载均衡器，因为每个API服务器只和本地etcd实例通信。<br>而API服务器确实需要一个负载均衡器，这样客户端（kubectl，也有可能是控制器管理器、调度器以及所有Kubelet）总是只连接到健康的API服务器实例。确保控制器和调度器的高可用性<br>对比API服务器可以同时运行多个复制集，运行控制器管理器或者调度器的多实例情况就没那么简单了。因为控制器和调度器都会积极地监听集群状态，发生变更时做出相应操作，可能未来还会修改集群状态（例如，当ReplicaSet上期望的复制集数量增加1时，ReplicaSet控制器会额外创建一个pod），多实例运行这些组件会导致它们执行同一个操作，会导致产生竞争状态，从而造成非预期影响（如前例提到的，创建了两个新pod而非一个）。<br>由于这个原因，当运行这些组件的多个实例时，给定时间内只有一个实例有效。幸运的是，这些工作组件自己都做了（由—leader-elect选项控制，默认为true）。只有当成为选定的领导者时，组件才可能有效。只有领导者才会执行实际的工作，而其他实例都处于待命状态，等待当前领导者宕机。当领导者宕机，剩余实例会选举新的领导者，接管工作。这种机制确保不会出现同一时间有两个有效组件做同样的工作（见图11.19）。<br>控制器管理器和调度器可以和API服务器、etcd搭配运行，或者也可以运行在不同的机器上。当搭配运行时，可以直接跟本地API服务器通信；否则就是通过负载均衡器连接到API服务器。</p>
<p>图11.19只有一个控制器管理器和一个调度器有效其他的待机<br>控制平面组件使用的领导选举机制<br>我发现最有趣的是：选举领导时这些组件不需要互相通信。领导选举机制的实现方式是在API服务器中创建一个资源，而且甚至不是什么特殊种类的资源Endpoint资源就可以拿来用于达到目的（滥用更贴切一点）。<br>使用Endpoint对象来完成该工作没有什么特别之处。使用Endpoint对象的原因是只要没有同名Service存在，就没有副作用。也可以使用任何其他资源（事实上，领导选举机制不就会使用ConfigMap来替代Endpoint）。<br>你一定对资源如何被应用于该目的感兴趣。让我们以调度器为例。所有调度器实例都会尝试创建（之后更新）一个Endpoint资源，称为kube-scheduler。可以在kube-system命名空间中找到它，如下面的代码清单所示。<br>代码清单11.11用于领导选举的kube-schedulerEndpoint资源</p>
<p>分。如你所见，其中包含了一个叫作holderIdentity的字段，包含了当前领导者的名字。第一个成功将姓名填入该字段的实例成为领导者。实例之间会竞争，但是最终只有一个胜出。<br>还记得之前讨论过的乐观并发概念吗？乐观并发保证如果有多个实例尝试写名字到资源，只有一个会成功。根据是否写成功，每个实例就知道自己是否是领导者。<br>一旦成为领导者，必须顶起更新资源（默认每2秒），这样所有其他的实例就知道它是否还存活。当领导者宕机，其他实例会发现资源有一阵没被更新了，就会尝试将自己的名字写到资源中尝试成为领导者。简单吧，对吧？<br>11.7本章小结<br>期望这么有趣的一章能够增加你对Kubernetes内部机制的理解。本章讲述了Kubernetes由哪些组件构成，以及每个组件的责任是什么<br>•API服务器、调度器、运行在控制器管理器中的各种控制器，以及Kubelet是如何协同工作让pod运行起来的<br>基础设施容器是如何将同一个pod的容器联系在一起的<br>相同节点上的pod如何通过网桥通信？不同节点上的网桥是如何连接的？运行在不同的节点上的pod是如何通信的？<br>如何通过配置各个节点上iptables规则，让Kube-proxy在同一服务中跨pod发挥负载均衡功能的。<br>控制平面每个组件的多个实例是如何运行来保证集群的高可用性的<br>接下来，让我们了解一下如何确保API服务器的安全性，乃至整个集群的安全性。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes-in-Action/" rel="tag"># Kubernetes in Action</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/" rel="next" title="10-StatefulSet：部署有姿态的多副本应用">
                <i class="fa fa-chevron-left"></i> 10-StatefulSet：部署有姿态的多副本应用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/01/12-Kubernetes-API服务器的安全防护/" rel="prev" title="12-Kubernetes API服务器的安全防护">
                12-Kubernetes API服务器的安全防护 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#了解架构"><span class="nav-number">1.</span> <span class="nav-text">了解架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes组件的分布式特性"><span class="nav-number">1.1.</span> <span class="nav-text">Kubernetes组件的分布式特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes如何使用etcd"><span class="nav-number">1.2.</span> <span class="nav-text">Kubernetes如何使用etcd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API服务器做了什么"><span class="nav-number">1.3.</span> <span class="nav-text">API服务器做了什么</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
