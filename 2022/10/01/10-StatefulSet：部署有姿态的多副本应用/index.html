<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Kubernetes in Action">
<meta property="og:type" content="article">
<meta property="og:title" content="10-StatefulSet：部署有姿态的多副本应用">
<meta property="og:url" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/1.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/2.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/3.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/4.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/5.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/6.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/7.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/8.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/9.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/10.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/11.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/12.png">
<meta property="og:updated_time" content="2022-10-05T02:16:29.900Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="10-StatefulSet：部署有姿态的多副本应用">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/1.png">






  <link rel="canonical" href="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>10-StatefulSet：部署有姿态的多副本应用 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看书不是为了学习，是为了锻炼意志力">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">10-StatefulSet：部署有姿态的多副本应用

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-10-01 10:09:41" itemprop="dateCreated datePublished" datetime="2022-10-01T10:09:41+08:00">2022-10-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-10-05 10:16:29" itemprop="dateModified" datetime="2022-10-05T10:16:29+08:00">2022-10-05</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">18k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">16 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>【本章内容涵盖】</p>
<ul>
<li>部署有状态集群应用</li>
<li>为每个副本pod实例提供独立存储</li>
<li>保证pod副本有固定的名字和主机名</li>
<li>按预期顺序启停pod副本</li>
<li>通过DNSSRV记录查询伙伴节点</li>
</ul>
<p>现在你知道了如何运行一个单实例pod和无状态的多副本pod，还有如何通过持久化存储运行一个有状态pod。可以运行几个多副本的web-serverpod实例，运行一个提供持久化存储的单数据库pod实例，这个持久化存储可以是简单的pod卷，也可以是一个绑定到持久卷上的持久卷声明。。但是是否可以通过ReplicaSet来复制数据库pod呢？</p>
<h1 id="复制有状态pod"><a href="#复制有状态pod" class="headerlink" title="复制有状态pod"></a>复制有状态pod</h1><p>ReplicaSet通过一个pod模板创建多个pod副本。这些副本除了它们的名字和IP地址不同外，没有别的差异。如果pod模板里描述了一个关联到特定持久卷声明的数据卷，那么ReplicaSet的所有副本都将共享这个持久卷声明，也就是绑定到同持久卷声明，也就是绑到同一个声明的持久卷(如下图10.1所示)。</p>
<blockquote>
<p>图10.1 ReplicaSet里的所有pod共享相同的持久卷声明和持久卷</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/1.png">
<p>因为是在pod模板里关联声明的，又会依据pod模板创建多个pod副本，则不能对每个副本都指定独立的持久卷声明。所以也不能通过一个ReplicaSet来运行一个每个实例都需要独立存储的分布式数据存储服务，至少通过单个ReplicaSet是做不到的。老实说，之前你学习到的所有API对象都不能提供这样的数据存储服务，还需要其他的对象。</p>
<h2 id="运行每个实例都有单独存储的多副本"><a href="#运行每个实例都有单独存储的多副本" class="headerlink" title="运行每个实例都有单独存储的多副本"></a>运行每个实例都有单独存储的多副本</h2><p>那如何运行一个pod的多个副本，让每个pod都有独立的存储卷呢？ReplicaSet会依据一个pod创建一致的副本，所以不能通过它们来达到目的，那你可以使用什么呢？</p>
<p>手动创建pod</p>
<p>可以手动创建多个pod，每个pod使用一个独立的持久卷声明，但是因为没有一个ReplicaSet在后面对应它们，所以需要手动管理它们。当有的pod消失后（比如节点故障），需要手动创建它们。因此这不是一个好的选择。</p>
<p>一个pod实例对应一个ReplicaSet</p>
<p>与直接创建不同，可以创建多个ReplicaSet，每个ReplicaSet的副本数设为！，做到pod和ReplicaSet的一对应，为每个ReplicaSet的pod模板关联一个专属的持久卷声明（如图10.2所示）。</p>
<p>尽管这种方法能保证在节点故障或者pod误删时能自动重新调度创建，但是与单个ReplicaSet相比，它还是显得比较笨重的。例如，在这种情况下要如何伸缩pod？扩容的话，必须重新创建新的ReplicaSet。</p>
<blockquote>
<p>图10.2 每个pod实例对应一个ReplicaSet</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/2.png">
<p>所以说使用多个ReplicaSet也不是最好的方案。那是否可以创建一个ReplicaSet，即使在共享一个存储卷的情况下，让每个pod实例都独立保持自己的持久化状态呢？</p>
<p>使用同一数据卷中的不同目录</p>
<p>一个比较取巧的做法是：所有pod共享同一数据卷，但是每个pod在数据卷中使用不同的数据目录（如图10.3所示）。</p>
<blockquote>
<p>图10.3 每个pod中的应用使用同一数据卷中的不同目录</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/3.png">
<p>因为不能在一个pod模板中差异化配置pod副本，所以不能指定一个实例使用哪个特定目录！但是可以让每个实例自动选择（或创建）一个别的实例还没有使用的数据目录。这种方案要求实例之间相互协作，其正确性很难保证，同时共享存储也会成为整个应用的性能瓶颈。</p>
<h2 id="每个pod都提供稳定的标识"><a href="#每个pod都提供稳定的标识" class="headerlink" title="每个pod都提供稳定的标识"></a>每个pod都提供稳定的标识</h2><p>除了上面说的存储需求，集群应用也会要求每一个实例拥有生命周期内唯一标识。pod可以随时被删掉，然后被新的pod替代。当一个ReplicaSet中的pod被替换时，尽管新的pod也可能使用被删掉pod数据卷中的数据，但它却是拥有全新主机名和IP的崭新pod。在一些应用中，当启动的实例拥有完全新的网络标识，但还使用旧实例的数据时，很可能引起问题。</p>
<p>为什么一些应用需要维护一个稳定的网络标识呢？这个需求在有状态的分布式应用中很普遍。这类应用要求管理者在每个集群成员的配置文件中列出所有其他集群成员和它们的IP地址（或主机名）。但是在Kubermetes中，每次重新调度一个pod，这个新的pod就有一个新的主机名和IP地址，这样就要求当集群中任何一个成员被重新调度后，整个应用集群都需要重新配置。</p>
<p>每个pod实例配置单独的Service</p>
<p>一个比较取巧的做法是：针对集群中的每个成员实例，都创建一个独立的KubermetesService来提供稳定的网络地址。因为服务IP是固定的，可以在配置文件中指定集群成员对应的服务IP（而不是podIP）。</p>
<p>这种做法跟之前提到的一种方法类似：为每个成员创建一个ReplicaSet，并配置独立存储。把这两种方法结合起来就构成如图10.4所示的结构（额外添加一个访问集群所有成员的服务，因为需要它来服务集群中的客户端）。</p>
<blockquote>
<p>图10.4 每个pod对应一个Service和ReplicaSet提供稳定的网络地址，每个pod配置一个独立的数据卷</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/4.png">
<p>这种解决方案不仅令人厌恶，而且它也不是一个完美的解决办法。每个单独的pod没法知道它对应的Service（所以也无法知道对应的稳定IP），所以它们不能在别的pod里通过服务IP自行注册。</p>
<p>幸运的是，Kubermetes为我们提供了这类需求的完美解决方案。在Kubemetes中运行这类特定需求应用的最简单的办法就是通过Statefiulset。</p>
<h1 id="了解Statefulset"><a href="#了解Statefulset" class="headerlink" title="了解Statefulset"></a>了解Statefulset</h1><p>可以创建一个Statefulset资源替代ReplicaSet来运行这类pod。它是专门定制的一类应用，这类应用中每一个实例都是不可替代的个体，都拥有稳定的名字和状态。</p>
<h2 id="对比Statefulset和ReplicaSet"><a href="#对比Statefulset和ReplicaSet" class="headerlink" title="对比Statefulset和ReplicaSet"></a>对比Statefulset和ReplicaSet</h2><p>要很好地理解Statefulset的用途，最好先与ReplicaSet或ReplicationControllers对比一下。首先拿一个通用的类比来解释它们。</p>
<p>通过宠物与牛的类比来理解有状态</p>
<p>你可能已经听说过宠物与牛的类比。如果没有，先简单介绍一下。可以把我们的应用看作宠物或牛。</p>
<blockquote>
<p>注意 Statefulset最初被称为PetSet，这个名字来源于宠物与牛的类比。</p>
</blockquote>
<p>我们倾向于把应用看作宠物，给每个实例起一个名字，细心照顾每个实例。但是也许把它们看成牛更为合适，并不需要对单独的实例有太多关心。这样就可以非常方便地替换掉不健康的实例，就跟农场主替换掉一头生病的牛一样。</p>
<p>对于无状态的应用实例来说，行为非常像农场里的牛。一个实例挂掉后并没什么影响，可以创建一个新实例，而让用户完全无感知。</p>
<p>另一方面，有状态的应用的一个实例更像一个宠物。若一只宠物死掉，不能买到一只完全一样的，而不让用户感知到。若要替换掉这只宠物，需要找到一只行为举止与之完全一致的宠物。对应用来说，意味着新的实例需要拥有跟旧的案例完全一致的状态和标识。</p>
<p>Statefulset与ReplicaSet或ReplicationController的对比</p>
<p>RelicaSet或ReplicationController管理的pod副本比较像牛，这是因为它们都是无状态的，任何时候它们都可以被一个全新的pod替换。然而有状态的pod需要不同的方法，当一个有状态的pod挂掉后（或者它所在的节点故障），这个pod实例需要在别的节点上重建，但是新的实例必须与被替换的实例拥有相同的名称、网络标识和状态。这就是StatefulSet如何管理pod的。</p>
<p>Statefulset保证了pod在重新调度后保留它们的标识和状态。它让你方便地扩容、缩容。与ReplicaSet类似，Statefulset也会指定期望的副本个数，它决定了在同一时间内运行的宠物的数量。与ReplicaSet类似，pod也是依据Statefulset的pod模板创建的（想象一下曲奇饼干模板）。与ReplicaSet不同的是，Statefulset创建的pod副本并不是完全一样的。每个pod都可以拥有一组独立的数据卷（持久化状态）而有所区别。另外“宠物”pod的名字都是规律的（固定的），而不是每个新pod都随机获取一个名字。</p>
<h2 id="提供稳定的网络标识"><a href="#提供稳定的网络标识" class="headerlink" title="提供稳定的网络标识"></a>提供稳定的网络标识</h2><p>一个Statefulset创建的每个pod都有一个从零开始的顺序索引，这个会体现在pod的名称和主机名上，同样还会体现在pod对应的固定存储上。这些pod的名称则是可预知的，因为它是由Statefulset的名称加该实例的顺序索引值组成的。不同于pod随机生成一个名称，这样有规则的pod名称是很方便管理的，如图10.5所示。</p>
<blockquote>
<p>图10.5 与ReplicaSet不同，由Statefulset创建的pod拥有规则的名称（和主机名）</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/5.png">
<p>控制服务介绍</p>
<p>让pod拥有可预知的名称和主机名并不是全部，与普通的pod不一样的是，有状态的pod有时候需要通过其主机名来定位，而无状态的pod则不需要，因为每个无状态的pod都是一样的，在需要的时候随便选择一个即可。但对于有状态的pod来说，因为它们都是彼此不同的（比如拥有不同的状态），通常希望操作的是其中特定的一个。</p>
<p>基于以.上原因，-个Statefulset通常要求你创建一个用来记录每个pod网络标记的headlessService。通过这个Service，每个pod将拥有独立的DNS记录，这样集群里它的伙伴或者客户端可以通过主机名方便地找到它。比如说，一个属于default命名空间，名为foo的控制服务，它的一个pod名称为A-0，那么可以通过下面的完整域名来访问它：a-0.foo.default.svc.cluster.local。而在ReplicaSet中这样是行不通的。</p>
<p>另外，也可以通过DNS服务，查找域名foo.default.svc.cluster.local对应的所有SRV记录，获取一个Statefulset中所有pod的名称。我们将在10.4节中介绍SRV记录，解释如何通过它来发现一个Statefulset中的所有成员。</p>
<p>替换消失的宠物</p>
<p>当一个Statefulst管理的一个pod实例消失后（pod所在节点发生故障，或有人手动删除pod),Statefulset会保证重启一个新的pod实例替换它，这与ReplicaSet<br>类似。但与ReplicaSet不同的是，新的pod会拥有与之前pod完全一致的名称和主<br>机名（ReplicaSet和Statefulset的差异如图10.6所示)。</p>
<blockquote>
<p>图10.6 Statefulset使用标识完全一致的新的pod替换，ReplicaSet则是使用一个不相干的新的pod替换</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/6.png">
<p>如你之前了解的那样，pod运行在哪个节点上并不重要，新的pod并不一定会调度到相同的节点上。对于有状态的pod来说也是这样，即使新的pod被调度到一个不同的节点，也同样可以通过主机名来访问。</p>
<p>扩缩容Statefulset</p>
<p>扩容一个Statefulset会使用下一个还没用到的顺序索引值创建一个新的pod实例。比如，要把一个Statefulset从两个实例扩容到三个实例，那么新实例的索引值就会是2（现有实例使用的索引值为0和1）。</p>
<p>当缩容一个Statefulset时，比较好的是很明确哪个pod将要被删除。作为对比，ReplicaSet的缩容操作则不同，不知道哪个实例会被删除，也不能指定先删除哪个实例（也许这个功能会在将来实现）。缩容一个Statefulset将会最先删除最高索引值的实例（如图10.7所示），所以缩容的结果是可预知的。</p>
<blockquote>
<p>图10.7 缩容一个Statefulset将会最先删除最高索引值的实例</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/7.png">
<p>因为Statefulset缩容任何时候只会操作一个pod实例，所以有状态应用的缩容不会很迅速。举例来说，一个分布式存储应用若同时下线多个节点，则可能导致其数据丢失。比如说一个数据项副本数设置为2的数据存储应用，若同时有两个节点下线，一份数据记录就会丢失，如果它正好保存在这两个节点上。若缩容是线性的，则分布式存储应用就有时间把丢失的副本复制到其他节点，保证数据不会丢失。</p>
<p>基于以上原因，Statefulset在有实例不健康的情况下是不允许做缩容操作的。若一个实例是不健康的，而这时再缩容一个实例的话，也就意味着你实际上同时失去了两个集群成员。</p>
<h2 id="为每个有状态实例提供稳定的专属存储"><a href="#为每个有状态实例提供稳定的专属存储" class="headerlink" title="为每个有状态实例提供稳定的专属存储"></a>为每个有状态实例提供稳定的专属存储</h2><p>你已经知道了Statefulset如何保证一个有状态的pod拥有稳定的标识，那存储呢？一个有状态的pod需要拥有自己的存储，即使该有状态的pod被重新调度（新的pod与之前pod的标识完全一致），新的实例也必须挂载着相同的存储。那Statefulset是如何做到这一点的呢？</p>
<p>很明显，有状态的pod的存储必须是持久的，并且与pod解耦。在第6章中学习了持久卷和持久卷声明，通过在pod中关联一个持久卷声明的名称，就可以为pod提供持久化存储。因为持久卷声明与持久卷是一对一的关系，所以每个Statefulset的pod都需要关联到不同的持久卷声明，与独自的持久卷相对应。因为所有的pod实例都是依据一个相同的pod模板创建的，那它们是如何关联到不同的持久卷是的呢？并且由谁来创建这些持久卷是呢？当然你肯定不想手在动创建Statefulset之前，依据pod的个数创建相同数量的持久卷量。当然不用这么做！</p>
<p>在pod模板中添加卷声明模板</p>
<p>像Statefulset创建pod一样，Statefulset也需要创建持久卷声明。所以一个Statefulset可以拥有一个或多个卷声明模板，这些持久卷声明会在创建pod前创建出来，绑定到一个pod实例上（如图10.8所示）。</p>
<blockquote>
<p>图10.8 一个Statefulset创建pod和持久卷声明</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/8.png">
<p>声明的持久卷既可以通过administrator用户预先创建出来，也可以如第6章所述，由持久卷的动态供应机制实时创建出来。</p>
<p>持久卷的创建和删除</p>
<p>扩容StatefulSet增加一个副本数时，会创建两个或更多的API对象（一个pod和与之关联的一个或多个持久卷声明）。但是对缩容来说，则只会删除一个pod，而遗留下之前创建的声明。当你知道一个声明被删除会发生什么的话，你就明白为什么这么做了。当一个声明被删除后，与之绑定的持久卷就会被回收或删除，则其上面的数据就会丢失。</p>
<p>因为有状态的pod是用来运行有状态应用的，所以其在数据卷上存储的数据非常重要，在Statefulset缩容时删除这个声明将是灾难性的，特别是对于Statefulset来说，缩容就像减少其replicas数值一样简单。基于这个原因，当你需要释放特定的持久卷时，需要手动删除对应的持久卷声明。</p>
<p>重新挂载持久卷声明到相同pod的新实例上</p>
<p>因为缩容Statefulset时会保留持久卷声明，所以在随后的扩容操作中，新的pod实例会使用绑定在持久卷上的相同声明和其上的数据（如图10.9所示）。当你因为误操作而缩容一个Statefiulset后，可以做一次扩容来弥补自己的过失，新的pod实例会运行到与之前完全一致的状态（名字也是一样的）。</p>
<blockquote>
<p>图10.9 Statefulset缩容时不删除持久卷声明，扩容时会重新挂载上</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/9.png">
<h2 id="Statefulset的保障"><a href="#Statefulset的保障" class="headerlink" title="Statefulset的保障"></a>Statefulset的保障</h2><p>如之前描述的，Statefulset的行为与ReplicaSet或ReplicationController是不一样的。Statefulset不仅拥有稳定的标记和独立的存储，它的pod还有其他的一些保障。</p>
<p>稳定标识和独立存储的影响</p>
<p>通常来说，无状态的pod是可以替代的，而有状态的pod则不行。我们之前已经描述了一个有状态的pod总是会被一个完全一致的pod替换（两者有相同的名称、主机名和存储等）。这个替换发生在Kubernetes发现旧的pod不存在时（例如手动删除这个pod）。</p>
<p>那么当Kubernetes不能确定一个pod的状态时呢？如果它创建一个完全一致的pod，那系统中就会有两个完全一致的pod在同时运行。这两个pod会绑定到相同的存储，所以这两个相同标记的进程会同时写相同的文件。对于ReplicaSet的pod来说，这不是问题，因为应用本来就是设计为在相同的文件上工作的。并且我们知道ReplicaSet会以一个随机的标识来创建pod，所以不可能存在两个相同标识的进程同时运行。</p>
<p>介绍Statefulset的at-most-one的语义</p>
<p>Kubernetes必须保证两个拥有相同标记和绑定相同持久卷声明的有状态的pod实例不会同时运行。一个Statefulset必须保证有状态的pod实例的at-most-one语义。</p>
<p>也就是说一个Statefulset必须在准确确认一个pod不再运行后，才会去创建它的替换pod。这对如何处理节点故障有很大的影响，我们会在本章后面详细介绍。在我们做这些之前，需要先创建一个Statefulset，看看它是如何工作的。在这个过程中，你会学到更多的知识。</p>
<h1 id="使用Statefulset"><a href="#使用Statefulset" class="headerlink" title="使用Statefulset"></a>使用Statefulset</h1><p>为了恰当地展示Statefulset的行为，将会创建一个小的集群数据存储。没有太多功能，就像石器时代的一个数据存储。</p>
<h2 id="创建应用和容器镜像"><a href="#创建应用和容器镜像" class="headerlink" title="创建应用和容器镜像"></a>创建应用和容器镜像</h2><p>你将使用书中一直使用的kubia应用作为你的基础来扩展它，达到它的每个pod实例都能用来存储和接收一个数据项。</p>
<p>下面列举了你的数据存储的关键代码。</p>
<blockquote>
<p>代码清单10.1 一个简单的有状态应用：kubia-pet-image/app.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当应用接收到一个POST请求时，它把请求中的body数据内容写入/var/data/kubia.txt文件中。而在收到GET请求时，它返回主机名和存储数据（文件中的内容）。是不是很简单呢？这是你的应用的第一版本。它还不是一个集群应用，但它足够让你可以开始工作。在本章的后面，你会来扩展这个应用。</p>
<p>用来构建这个容器镜像的Dockerfile文件与之前的一样，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单10.2 有状态应用的Dockerfile：kubia-pet-image/Dockerfile</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在来构建容器镜像，或者使用笔者上传的镜像：docker.io/luksa/kubia-pet。</p>
<h2 id="通过Statefulset部署应用"><a href="#通过Statefulset部署应用" class="headerlink" title="通过Statefulset部署应用"></a>通过Statefulset部署应用</h2><p>为了部署你的应用，需要创建两个（或三个）不同类型的对象：</p>
<ul>
<li>存储你数据文件的持久卷（当集群不支持持久卷的动态供应时，需要手动创建）</li>
<li>Statefulset必需的一个控制Service</li>
<li>Statefulset本身</li>
</ul>
<p>对于每一个pod实例，Statefulset都会创建一个绑定到一个持久卷上的持久卷声明。如果你的集群支持动态供应，就不需要手动创建持久卷（可跳过下一节）。如果不支持的话，可以按照下一节所述创建它们。</p>
<p>创建持久化存储卷</p>
<p>因为你会调度Statefulset创建三个副本，所以这里需要三个持久卷。如果你计划调度创建更多副本，那么需要创建更多持久卷。</p>
<p>如果你使用Minikube，请参考本书代码附件中的Chapter06/persistent-volumes-hostpath.yaml来部署持久卷。</p>
<p>如果你在使用谷歌的Kubemetes引擎，需要首先创建实际的GCE持久磁盘：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 保证创建的持久磁盘和运行的节点在同一区域。</p>
</blockquote>
<p>然后通过persistent-volumes-gcepd.yaml文件创建需要的持久卷，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单10.3 三个持久卷：persistent-volumes-gcepd.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 在上一节通过在同一YAML文件中添加三个横杠（—-）来区分定义多个资源，这里使用另外一种方法，定义一个List对象，然后把各个资源作为List对象的各个项目。上述两种方法的效果是一样的。</p>
</blockquote>
<p>通过上诉文件创建了pv-a、pv-b和pv-c三个持久卷。它们使用GCE持久磁盘和指定的存储策略，所以它们并不适合没有运行在谷歌Kubernetes引擎（GoogleKubernetesEngine）或谷歌计算引擎（GoogleComputeEngine）上的集群。如果你的集群运行在其他地方，必须修改持久卷的定义，使用正确的卷类型，比如NFS（网络文件系统）或其他类似的类型。</p>
<p>创建控制Service</p>
<p>如我们之前所述，在部署一个Statefulset之前，需要创建一个用于在有状态的pod之间提供网络标识的headlessService。下面的代码显示了Service的详细信息。</p>
<blockquote>
<p>代码清单10.4 在Statefulset中使用的headless service：kubia-service-headless.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面指定了clusterIP为None，这就标记了公是一个headlessService。它使得你的pod之间可以彼此发现（后续会用到这个功能）。创建完这个Service之后，就可以继续往下创建实际的Statefulset了。</p>
<p>创建Statefulset详单</p>
<p>最后可以创建Statefulset了，下面的代码清单显示了其详细信息。</p>
<blockquote>
<p>代码清单10.5 Statefulset详单：kubia-statefulset.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个Statefulset详单与之前创建的ReplicaSet和Deployment的详单没太多区别，这里使用的新组件是volumeClaimTemplates列表。其中仅仅定义了一个名为data的卷声明，会依据这个模板为每个pod都创建一个持久卷声明。如之前在第6章中介绍的，pod通过在其详单中包含一个PersistentVolumeClaim卷来关联一个声明。但在上面的pod模板中并没有这样的卷，这是因为在Statefiulset创建指定pod时，会自动将PersistentVolumeClaim卷添加到pod详述中，然后将这个卷关联到一个声明上。</p>
<p>创建Statefulset</p>
<p>现在就要创建Statefulset了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>现在列出你的pod：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>有没有发现不同之处？是否记得-个ReplicationController或ReplicaSet会同时创建所有的pod实例？你的Statefulset配置去创建两个副本，但是它仅仅创建了单个pod。</p>
<p>不要担心，这里没有出错。第二个pod会在第一个pod运行并且处于就绪状态后创建。Statefulset这样的行为是因为：状态明确的集群应用对同时有两个集群成员启动引起的竞争情况是非常敏感的。所以依次启动每个成员是比较安全可靠的。特定的有状态应用集群在两个或多个集群成员同时启动时引起的竞态条件是非常敏感的，所以在每个成员完全启动后再启动剩下的会更加安全。</p>
<p>再次列出pod并查看pod的创建过程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>可以看到，第一个启动的pod状态是running，第二个pod已经创建并在启动过程中。</p>
<p>检查生成的有状态pod</p>
<p>现在让我们看一下第一个pod的详细参数，看一下Statefulset如何从pod模板和持久卷声明模板来构建pod，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单10.6 Statefulset创建的有状态pod</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过持久卷声明模板来创建持久卷声明和pod中使用的与持久卷声明相关的数据卷。</p>
<p>检查生成的持久卷声明</p>
<p>现在列出生成的持久卷声明来确定它们被创建了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>生成的持久卷声明的名称由在volumeClaimTemplate字段中定义的名称和每个pod的名称组成。可以检查声明的YAML文件来确认它们符合模板的定义。</p>
<h2 id="使用你的pod"><a href="#使用你的pod" class="headerlink" title="使用你的pod"></a>使用你的pod</h2><p>现在你的数据存储集群的节点都已经运行，可以开始使用它们了。因为之前创建的Service处于headless模式，所以不能通过它来访问你的pod。需要直接连接每个单独的pod来访问（或者创建一个普通的Service，但是这样还是不允许你访问指定的pod）。</p>
<p>前面已经介绍过如何直接访问pod：借助另一个pod，然后在里面运行curl命令或者使用端口转发。这次来介绍另外一种方法，通过API服务器作为代理。</p>
<p>通过API服务器与pod通信</p>
<p>API服务器的一个很有用的功能就是通过代理直接连接到指定的pod。如果想请求当前的kubia-0pod，可以通过如下URL：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;apiServerHost&gt;:&lt;port&gt;/api/v1/namespaces/default/pods/kubia-0/proxy/&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<p>因为API服务器是有安全保障的，所以通过API服务器发送请求到pod是烦琐的（需要额外在每次请求中添加授权令牌）。幸运的是，在第8章中已经学习了如何使用kubectlproxy来与API服务器通信，而不必使用麻烦的授权和SSL证书。再次运行代理如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>现在，因为要通过kubectl代理来与API服务器通信，将使用localhost：8001来代替实际的API服务器主机地址和端口。你将发送一个如下所示的请求到kubia-0pod:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>返回的消息表明你的请求被正确收到，并在kubia-0pod的应用中被正确处理。</p>
<blockquote>
<p>注意 如果你收到一个空的回应，请确保在URL的最后没有忘记输入/符号（或者用curl的-L选项来允许重定向）</p>
</blockquote>
<p>因为你正在使用代理的方式，通过API服务器与pod通信，每个请求都会经过两个代理（第一个是kubectl代理，第二个是把请求代理到pod的API服务器）。详细的描述如图10.10所示。</p>
<blockquote>
<p>图10.10 通过kubectl代理和API服务器代理来与一个pod通信</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/10.png">
<p>上面介绍的是发送一个GET请求到pod，也可以通过API服务器发送POST请求。发送POST请求使用的代理URL与发送GET请求一致。</p>
<p>当你的应用收到一个POST请求时，它把请求的主体内容保存到本地一个文件中。发送一个POST请求到kubia-0pod的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>你发送的数据现在已经保存到pod中，那让我们检查一下当你再次发送一个GET请求时，它是否返回存储的数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>挺好的，到目前为止都工作正常。现在让我们看看集群其他节点（kubia-1pod):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>与期望的一致，每个节点拥有独自的状态。那这些状态是否是持久的呢？让我们进一步验证。</p>
<p>删除一个有状态pod来检查重新调度的pod是否关联了相同的存储</p>
<p>你将会删除kubia-0pod，等待它被重新调度，然后就可以检查它是否会返回与之前-致的数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>如果你列出当前pod，可以看到该pod正在终止运行：</p>
<p>当它一旦成功终止，Statefulset会重新创建一个具有相同名称的新的pod：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>请记住，新的pod可能会被调度到集群中的任何一个节点，并不一定保持与旧的pod所在的节点一致。旧的pod的全部标记（名称、主机名和存储）实际上都会转移到新的pod上（如图10.11所示）。如果你在使用Minikube，你将看不到这些，因为它仅仅运行在单个节点上，但是对于多个节点的集群来说，可以看到新的pod会被调度到与之前pod不一样的节点上。</p>
<blockquote>
<p>图10.11 一个有状态pod会被重新调度到新的节点，但会保留它的名称、主机名和存储</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/11.png">
<p>现在新的pod已经运行了，那让我们检查一下它是否拥有与之前的pod一样的标记。pod 的名称是一样的，那它的主机名和持久化数据呢？可以通过访问pod来确认：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>从pod返回的信息表明它的主机名和持久化数据与之前pod是完全一致的，所以可以确认Statefulset会使用一个完全一致的pod来替换被删除的pod。</p>
<p>扩缩容Statefulset</p>
<p>缩容一个Statefulset，然后在完成后再扩容它，与删除一个pod，后让Statefulset立马重新创建它的表现是没有区别的。需要记住的是，缩容一个Statefulset只会删除对应的pod，留下卸载后的持久卷声明。可以尝试缩容一个Statefulset来进行确认。</p>
<p>需要明确的关键点是，缩容/扩容都是逐步进行的，与Statefulset最初被创建时会创建各自的pod一样。当缩容超过一个实例的时候，会首先删除拥有最高索引值的pod。只有当这个pod被完全终止后，才会开始删除拥有次高索引值的pod。</p>
<p>通过一个普通的非headless的Service暴露Statefulset的pod</p>
<p>在阅读这一章的最后一部分之前，需要为你的pod添加一个适当的非headlessService，这是因为客户端通常不会直接连接pod，而是通过一个服务。</p>
<p>你应该知道了如何创建Service，如果不知道的话，请看下面的代码清单。</p>
<blockquote>
<p>代码清单10.7 一个用来访问有状态pod的常规Service：kubia-service-public.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为它不是外部暴露的Service（它是一个常规的ClusterIPService，不是一个NodePort或LoadBalancer-typeService），只能在你的集群内部访问它。那是否需要一个pod来访问它呢？答案是不需要。</p>
<p>通过API服务器访问集群内部的服务</p>
<p>不通过额外的pod来访问集群内部的服务的话，与之前使用访问单独pod的方法一样，可以使用API服务器提供的相同代理属性来访问。</p>
<p>代理请求到Service的URL路径格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/vl/namespaces/&lt;namespace&gt;/services/&lt;servicename&gt;/proxy/&lt;path&gt;</span><br></pre></td></tr></table></figure></p>
<p>因此可以在本地机器上运行curl命令，通过kubectl代理来访问服务（之前启动过kubectlprcxy，现在它应该还在运行着）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cur1localhost</span>:8001/api/v1/namespaces/default/services/kubia-</span><br><span class="line">public/proxy/</span><br><span class="line">You<span class="string">'vehitkubia-1</span></span><br><span class="line"><span class="string">Datastoredonthispod:Nodatapostedyet</span></span><br></pre></td></tr></table></figure></p>
<p>客户端（集群内部）同样可以通过kubia-public服务来存储或者读取你的集群中的数据。当然，每个请求会随机分配到一个集群节点上，所以每次都会随机获取一个节点上的数据。后面我们会改进它。</p>
<h1 id="在Statefulset中发现伙伴节点"><a href="#在Statefulset中发现伙伴节点" class="headerlink" title="在Statefulset中发现伙伴节点"></a>在Statefulset中发现伙伴节点</h1><p>我们仍然需要弄清楚一件很重要的事情。集群应用中很重要的一个需求是伙伴节点彼此能发现一这样才可以找到集群中的其他成员。一个Statefulset中的成员需要很容易地找到其他的所有成员。当然它可以通过与API服务器通信来获取，但是Kubernetes的一个目标是设计功能来帮助应用完全感觉不到Kubemetes的存在。因此让应用与API服务器通信的设计是不允许的。</p>
<p>那如何使得一个pod可以不通过API与其他伙伴通信呢？是否有已知的广泛存在的技术来帮助你达到目的呢？那使用域名系统（DNS）如何？这依赖于你对DNS系统有多熟悉，你可能理解什么是A、CNAME或MX记录的用处是什么。DNS记录里还有其他一些不是那么知名的类型，SRV记录就是其中的一个。</p>
<p>介绍sRV记录</p>
<p>SRV记录用来指向提供指定服务的服务器的主机名和端口号。Kubernetes通过一个headlessservice创建SRV记录来指向pod的主机名。</p>
<p>可以在一个临时pod里运行DNS查询工具一dig命令，列出你的有状态pod的SRV记录。示例命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$kubectlrun</span>-itsrvlookup--image=tutum/dnsutils--rm</span><br><span class="line">--restart=Never--diqSRVkubia.default.svc.cluster.local</span><br></pre></td></tr></table></figure></p>
<p>上面的命令运行一个名为srvlookup的一次性pod（—restart=Never），它会关联控制台（-it）并且在终止后立即删除（—rm）。这个pod依据tutum/dnsutils镜像启动单独的容器，然后运行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">digSRVkubia.default.svc.cluster.local</span><br></pre></td></tr></table></figure></p>
<p>下面的代码清单显示了这个命令的输出结果。</p>
<blockquote>
<p>代码清单10.8 列出你的headlessService的DNSSRV记录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">;;ANSWERSECTION:</span><br><span class="line">k.d.s.c.l.30INSRV</span><br><span class="line">10330kubia-0.kubia.defaultsvc.cluster.local.</span><br><span class="line">k.d.s.c.l.30INSRV</span><br><span class="line">10330kubia-1.kubia.defaultsvc.cluster.local.</span><br><span class="line">;ADDITIONALSECTION:</span><br><span class="line">kubia-0.kubia.defaultsvc.cluster.local.30INA172.17.0.4</span><br><span class="line">kubia-1.kubiadefault.svc.cluster.local.30INA172.17.0.6</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意为了让记录可以在一行里显示，对真实名称做了缩减，对应kubia.d.s.c.l.的全称是kubia.defaultsvc.cluster.local。</p>
</blockquote>
<p>上面的ANSWERSECTION显示了两条指向后台headlessservice的SRV记录。同时如ADDITIONALSECTION所示，每个pod都拥有独自的一条记录。</p>
<p>当一个pod要获取一个Statefulset里的其他pod列表时，你需要做的就是触发一次SRVDNS查询。例如，在Node.is中查询命令为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns.resolveSrv(<span class="string">"kubia.defaultsvc.cluster.local"</span>,callBackFunction);</span><br></pre></td></tr></table></figure></p>
<p>可以在你的应用中使用上述命令让每个pod发现它的伙伴pod。</p>
<blockquote>
<p>注意 返回的SRV记录顺序是随机的，因为它们拥有相同的优先级。所以不要期望总是看到kubia-0会排在kubia-1前面。</p>
</blockquote>
<h2 id="通过DNS实现伙伴间彼此发现"><a href="#通过DNS实现伙伴间彼此发现" class="headerlink" title="通过DNS实现伙伴间彼此发现"></a>通过DNS实现伙伴间彼此发现</h2><p>原始的数据存储服务还不是集群级别的，每个数据存储节点都是完全独立于其他节点的它们彼此之间没有通信。下一步你要做的就是让它们彼此通信。</p>
<p>客户端通过kubia-publicService连接你的数据存储服务，并且会到达集群里随机的一个节点。集群可以存储多条数据项，但是客户端当前却不能看到所有的数据项。因为服务把请求随机地送达一个pod，所以若客户端想获取所有pod的数据，必须发送很多次请求，一直到它的请求发送到所有的pod为止。</p>
<p>可以通过让节点返回所有集群节点数据的方式来改进这个行为。为了达到目的，节点需要能找到它所有的伙伴节点。可以使用之前学习到的Statefulset和SRV记录来实现这个功能。</p>
<p>可以如下面的代码清单所示修改你的应用源码（完整的代码在本书的代码附件中，这里仅展示其中重要的一段）。</p>
<blockquote>
<p>代码清单10.9 在简单应用中发现伙伴节点:kubia-pet-peers-imagelapp.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>图10.12展示了一个GET请求到达你的应用后的处理过程。首先收到请求的服务器会触发一次headlesskubia服务的SRV记录查询，然后发送GET请求到服务背后的每一个pod（也会发送给自己，虽说没有必要，这里只是为了保证代码简单易懂），然后返回所有节点和它们的数据信息的列表。</p>
<blockquote>
<p>图10.12 简单的分布式数据存储服务的操作流程</p>
</blockquote>
<img src="/2022/10/01/10-StatefulSet：部署有姿态的多副本应用/12.png">
<p>包含最新版本内容的应用对应的容器镜像链接为：docker.io/luksa/kubia-pet-peers。</p>
<h2 id="更新Statefulset"><a href="#更新Statefulset" class="headerlink" title="更新Statefulset"></a>更新Statefulset</h2><p>现在你的Statefulset已经运行起来，那让我们看一下如何更新它的pod模板，让它使用新的镜像。同时你也会修改副本数为3。通常会使用kubectledit命令来更新Statefulset（另一个选择是patch命令）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上面的命令会使用默认的编辑器打开Statefulset的定义。在定义中，修改spec.replicas为3，修改spec.template.spec.containers.image属性指向新的镜像（使用luksa/kubia-pet-peers替换luksa/kubia-pet）。然后保存文件并退出，Statefulset就会更新。之前Statefulset有两个副本，现在应该可以看到一个新的名叫kubia-2的副本启动了。通过下面的代码列出pod来确认：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>新的pod实例会使用新的镜像运行，那已经存在的两个副本呢？通过它们的寿命可以看出它们并没有更新。这是符合预期的。因为，首先Statefulset更像ReplicaSet，而不是Deployment，所以在模板被修改后，它们不会重启更新。需要手动删除这些副本，然后Statefulset会依据新的模板重新调度启动它们。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 从Kubernetes1.7版本开始，Statefulset支持与Deployment和DaemonSet一样的滚动升级。通过kubectlexplain获取Statefulset的spec.updateStrategy相关文档来获取更多信息。</p>
</blockquote>
<h2 id="尝试集群数据存储"><a href="#尝试集群数据存储" class="headerlink" title="尝试集群数据存储"></a>尝试集群数据存储</h2><p>当两个pod都启动后，即可测试你的崭新的新石器时代的数据存储是否按预期一样工作了。如下面的代码清单所示，发送一些请求到集群。</p>
<blockquote>
<p>代码清单10.10 通过service往集群数据存储中写入数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，读取存储的数据，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单10.11 从数据存储中读取数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非常棒！当一个客户端请求到达集群中任意一个节点后，它会发现它的所有伙伴节点，然后通过它们收集数据，然后把收集到的所有数据返回给客户端。即使你扩容或缩容Statefulset，服务于客户端请求的pod都会找到所有的伙伴节点。</p>
<p>这个应用本身也许没太多用处，但笔者希望你觉得这是一种有趣的方式，一个多副本Statefulset应用的实例如何发现它的伙伴，并且随需求做到横向扩展。</p>
<h1 id="了解Statefulset如何处理节点失效"><a href="#了解Statefulset如何处理节点失效" class="headerlink" title="了解Statefulset如何处理节点失效"></a>了解Statefulset如何处理节点失效</h1><p>在10.2.4节中，我们阐述了Kubernetes必须完全保证：一个有状态pod在创建它的代替者之前已经不再运行，当一个节点突然失效，Kubernetes并不知道节点或者它上面的pod的状态。它并不知道这些pod是否还在运行，或者它们是否还存在，甚至是否还能被客户端访问到，或者仅仅是Kubelet停止向主节点上报本节点状态。</p>
<p>因为一个Statefulset要保证不会有两个拥有相同标记和存储的pod同时运行，当一个节点似乎失效时，Statefulset在明确知道一个pod不再运行之前，它不能或者不应该创建一个替换pod。</p>
<p>只有当集群的管理者告诉它这些信息的时候，它才能明确知道。为了做到这一点，管理者需要删除这个pod，或者删除整个节点（这么做会删除所有调度到该节点上的pod）。</p>
<p>作为这一章中的最后一个练习，你会看到当一个集群节点网络断开后，Statefulset和节点上的pod都会发生些什么。</p>
<h2 id="模拟一个节点的网络断开"><a href="#模拟一个节点的网络断开" class="headerlink" title="模拟一个节点的网络断开"></a>模拟一个节点的网络断开</h2><p>与第4章中一致，可以通过关闭节点的eth0网络接口来模拟节点的网络断开。因为这个例子需要多个节点，所以不能在Minikube上运行，可以使用谷歌的Kubernetes引擎来运行。</p>
<p>关闭节点的网络适配器</p>
<p>为了关闭一个节点的网络接口，需要通过ssh登录一个节点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>然后在节点内部运行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>之后你的ssh链接就会中断，所以需要开启一个新的终端来继续执行。</p>
<p>通过Kubernetes管理节点检查节点的状态</p>
<p>当这个节点的网络接口关闭以后，运行在这个节点上的Kubelet服务就无法与KubernetesAPI服务器通信，无法汇报本节点和上面的pod都在正常运行。</p>
<p>过了一段时间后，控制台就会标记该节点状态为NotReady。如下面的代码清单所示，当列出节点时可以看到这些。</p>
<blockquote>
<p>代码清单10.12 观察到一个失效的节点状态变为NotReady</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为控制台不会再收到该节点发送的状态更新，该节点上面的所有pod状态都会变为Unknown。如下面的代码清单所示，列举pod信息就可以看到。</p>
<blockquote>
<p>代码清单10.13 观察到节点变为NotReady后，其上的pod状态就会改变</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正如你看到的这样，kubia-0pod的状态不再已知，这是因为你关闭了这个pod之前运行（也许正在运行）的节点的网络接口。</p>
<p>当一个pod状态为Unknow时会发生什么</p>
<p>若该节点过段时间正常连通，并且重新汇报它上面的pod状态，那这个pod就会重新被标记为Runing。但如果这个pod的未知状态持续几分钟后（这个时间是可以配置的），这个pod就会自动从节点上驱逐。这是由主节点（Kubernetes的控制组件）处理的。它通过删除pod的资源来把它从节点上驱逐。</p>
<p>当Kubelet发现这个pod被标记为删除状态后，它开始终止运行该pod。在上面的示例中，Kubelet已不能与主节点通信（因为你断开了这个节点的网络），这也就意味着这个pod会一直运行着。</p>
<p>让我们解释一下当前的状况。通过kubectldescribe命令查看kubia-0pod的详细信息，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单10.14 显示未知状态的pod的详情</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到这个pod的状态为Terminating，原因是NodeLost。在信息中说明的是节点不回应导致的不可达。</p>
<p>注意这里展示的是控制组件看到的信息。实际上这个pod对应的容器并被没有被终止，还在正常运行。</p>
<h2 id="手动删除pod"><a href="#手动删除pod" class="headerlink" title="手动删除pod"></a>手动删除pod</h2><p>你已经明确这个节点不会再回来，但是所有处理客户端请求的三个pod都必须是正常运行的。所以需要把kubia-0pod重新调度到一个健康的节点上。如之前提到的那样，需要手动删除整个节点或者这个pod。</p>
<p>正常删除pod</p>
<p>使用你一直使用的方式删除该pod：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>是不是所有的都做完了？删除pod后，Statefulset应该会立刻创建一个替换的pod，这个pod会被调度到剩下可用的节点上。再次列举pod信息来确认：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>非常奇怪，你刚刚删除了这个pod，kubectl也返回说它已经被删除。那为什么这个pod还在呢？</p>
<blockquote>
<p>注意 列表中的kubia-0pod不是一个有相同名字的新pod，在从它的AGE列中就可以看出。如果它是一个新pod，它的“年龄”只会是几秒钟。</p>
</blockquote>
<p>为什么pod没有被删除</p>
<p>在删除pod之前，这个pod已经被标记为删除。这是因为控制组件已经删除了它（把它从节点驱逐）。</p>
<p>如果再次检查一下代码清单10.14，可以看出这个pod的状态是Terminating。这个pod之前已经被标记为删除，只要它所在节点上的Kubelet通知API服务器说这个pod的容器已经终止，那么它就会被清除掉。但是因为这个节点上的网络断开了，所以上述情况永远不会发生。</p>
<p>强制删除pod</p>
<p>现在你唯—可以做的是告诉API服务器不用等待kubelet来确认这个pod已经不再运行，而是直接删除它。可以按照下面所述执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>你需要同时使用—force和—grace-period0两个选项。然后kubectl会对你做的事情发出警告信息。如果你再次列举pod，就可以看到一个新的kubia-0pod被创建出来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>警告除非你确认节点不再运行或者不会再可以访问（永远不会再可以访问），否则不要强制删除有状态的pod.</p>
<p>在继续操作之前，你可能希望把之前断掉连接的节点恢复正常。可以通过GCEweb控制台或在一个终端上执行下面的命令来重启该节点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p>本章描述了如何使用Statefulset来部署有状态应用，具体有如下几点：</p>
<ul>
<li>给副本pod配置单独的存储</li>
<li>给一个pod提供稳定的标识</li>
<li>创建一个Statefulset，并且配置一个相关的headless控制服务</li>
<li>扩缩容、更新一个Statefiulset</li>
<li>通过DNS发现Statefulset的其他成员</li>
<li>通过其他成员的主机名与之建立连接</li>
<li>强制删除有状态pod</li>
</ul>
<p>现在你已经知道了如何使用主要构件来运行Kubernetes和管理你的应用，后续我们会更深入地了解它是如何工作的。在下一章，你会学习如何使用独立的组件来控制Kubernetes集群，并保证你的应用正常运行。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes-in-Action/" rel="tag"># Kubernetes in Action</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/01/9-Deployment：声明式地升级应用/" rel="next" title="9-Deployment：声明式地升级应用">
                <i class="fa fa-chevron-left"></i> 9-Deployment：声明式地升级应用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/01/11-了解Kubernetes机理/" rel="prev" title="11-了解Kubernetes机理">
                11-了解Kubernetes机理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看书不是为了学习，是为了锻炼意志力</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">944</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">65</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/02/27/03｜从Rollup到Vite：如何用Vite构建你的Vue-3项目？/" title="03｜从Rollup到Vite：如何用Vite构建你的Vue 3项目？" target="_blank">03｜从Rollup到Vite：如何用Vite构建你的Vue 3项目？</a>
                  </li>
                
                  <li>
                    <a href="/2023/02/27/02｜Webpack编译搭建：如何用Webpack初构建Vue-3项目？/" title="02｜Webpack编译搭建：如何用Webpack初构建Vue 3项目？" target="_blank">02｜Webpack编译搭建：如何用Webpack初构建Vue 3项目？</a>
                  </li>
                
                  <li>
                    <a href="/2023/02/27/01｜编译和非编译模式：离开Vue工具，你还知道怎么用Vue-3吗？/" title="01｜编译和非编译模式：离开Vue工具，你还知道怎么用Vue 3吗？" target="_blank">01｜编译和非编译模式：离开Vue工具，你还知道怎么用Vue 3吗？</a>
                  </li>
                
                  <li>
                    <a href="/2023/02/27/开篇词｜为何掌握了技术API，依然在项目中处处掣肘？/" title="开篇词｜为何掌握了技术API，依然在项目中处处掣肘？" target="_blank">开篇词｜为何掌握了技术API，依然在项目中处处掣肘？</a>
                  </li>
                
                  <li>
                    <a href="/2023/02/26/13｜JSX：如何利用JSX应对更灵活的开发场景？/" title="13｜JSX：如何利用JSX应对更灵活的开发场景？" target="_blank">13｜JSX：如何利用JSX应对更灵活的开发场景？</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#复制有状态pod"><span class="nav-number">1.</span> <span class="nav-text">复制有状态pod</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行每个实例都有单独存储的多副本"><span class="nav-number">1.1.</span> <span class="nav-text">运行每个实例都有单独存储的多副本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每个pod都提供稳定的标识"><span class="nav-number">1.2.</span> <span class="nav-text">每个pod都提供稳定的标识</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#了解Statefulset"><span class="nav-number">2.</span> <span class="nav-text">了解Statefulset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对比Statefulset和ReplicaSet"><span class="nav-number">2.1.</span> <span class="nav-text">对比Statefulset和ReplicaSet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提供稳定的网络标识"><span class="nav-number">2.2.</span> <span class="nav-text">提供稳定的网络标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为每个有状态实例提供稳定的专属存储"><span class="nav-number">2.3.</span> <span class="nav-text">为每个有状态实例提供稳定的专属存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Statefulset的保障"><span class="nav-number">2.4.</span> <span class="nav-text">Statefulset的保障</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用Statefulset"><span class="nav-number">3.</span> <span class="nav-text">使用Statefulset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建应用和容器镜像"><span class="nav-number">3.1.</span> <span class="nav-text">创建应用和容器镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过Statefulset部署应用"><span class="nav-number">3.2.</span> <span class="nav-text">通过Statefulset部署应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用你的pod"><span class="nav-number">3.3.</span> <span class="nav-text">使用你的pod</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在Statefulset中发现伙伴节点"><span class="nav-number">4.</span> <span class="nav-text">在Statefulset中发现伙伴节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通过DNS实现伙伴间彼此发现"><span class="nav-number">4.1.</span> <span class="nav-text">通过DNS实现伙伴间彼此发现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新Statefulset"><span class="nav-number">4.2.</span> <span class="nav-text">更新Statefulset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尝试集群数据存储"><span class="nav-number">4.3.</span> <span class="nav-text">尝试集群数据存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#了解Statefulset如何处理节点失效"><span class="nav-number">5.</span> <span class="nav-text">了解Statefulset如何处理节点失效</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模拟一个节点的网络断开"><span class="nav-number">5.1.</span> <span class="nav-text">模拟一个节点的网络断开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#手动删除pod"><span class="nav-number">5.2.</span> <span class="nav-text">手动删除pod</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小结"><span class="nav-number">6.</span> <span class="nav-text">本章小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">7.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">119:03</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
