<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Kubernetes in Action">
<meta property="og:type" content="article">
<meta property="og:title" content="17-开发应用的最佳实践">
<meta property="og:url" content="http://yoursite.com/2022/10/01/17-开发应用的最佳实践/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-10-04T01:40:38.637Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="17-开发应用的最佳实践">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">






  <link rel="canonical" href="http://yoursite.com/2022/10/01/17-开发应用的最佳实践/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>17-开发应用的最佳实践 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/01/17-开发应用的最佳实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="什么是强迫自己？就是不想去干什么，就去干什么">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">17-开发应用的最佳实践

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-10-01 10:12:12" itemprop="dateCreated datePublished" datetime="2022-10-01T10:12:12+08:00">2022-10-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-10-04 09:40:38" itemprop="dateModified" datetime="2022-10-04T09:40:38+08:00">2022-10-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">26k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">24 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>本章内容涵盖<br>■了解在一个典型应用中会出现哪些Kubernetes<br>的资源<br>■添加 pod启动后和停止前的生命周期钩子<br>■在不断开客 户端连接的情况下妥善地停止应用<br>■在Kubernetes中如何方便地管理应用<br>■在pod中使用init容器<br>■使用Minikube在本地进行应用开发<br>到目前为止，我们已经介绍了大部分你需要了解的知识来让你可以在 Kubermetes中运行应用。我们已经探索了每个单独的资源的功能以及其使用方法。现在我们来看看如何将它们和运行在Kubermetes，上面的一个典型的应用结合在一起。我们也将看看如何让一个应用可以顺利运行。毕竟，这是使用Kubernetes的重点，不是吗？<br>希望本章将有助于澄清任何误解，以及解释尚未明确说明的事情。在这个过程中，我们还会介绍一些 其他尚未提及的概念。</p>
<p>17.1集中一切资源<br>我们首先看看一个实际应用程序的各个组成部分。这也会让你有机会看看你是否记得迄今为止所学到的一切，并且能够从全局来审视它们。图17.1显示了一个典型应用中所使用的各个Kubernetes组件。</p>
<p>图17.1一个典型应用中的资源<br>一个典型的应用manifest包含了一个或者多个Deployment和StatefulSet对象。这些对象中包含了一个或者多个容器的pod模板，每个容器都有一个存活探针， 并且为容器提供的服务（如果有的话）提供就绪探针。提供服务的pod是通过一个或者多个服务来暴露自己的。当需要从集群外访问这些服务的时候，要么将这些服务配置为LoadBalancer或者NodePort类型的服务，要么通过Ingress资源来开放服务。<br>pod模板（从中创建pod的配置文件）通常会引用两种类型的私密凭据（Secret）。一种是从私有镜像仓库拉取镜像时使用的；另一种是pod中运行的进程直接使用的。私密凭据本身通常不是应用manifest的一部分， 因为它们不是由应用开发者来配置，而是由运维团队来配置的。私密凭据通常会被分配给ServiceAccount，然后ServiceAccount会被分配给每个单独的pod.<br>一个应用还包含一个或者多个ConfigMap对象，可以用它们来初始化环境变量，或者在pod中以configMap卷来挂载。有一些pod会使用额外</p>
<p>的卷，例如emptyDir或gitRepo卷，而需要持久化存储的pod则需要persistentvolumeClaim卷。PersistentVolumeClaim也是一个应用manifest的一部分，而被PersistentVolumeClaim所引用的StorageClass则是由系统管理员事先创建的。<br>在某些情况下，一个应用还需要使用任务（Jobs）和定时任务（CronJobs）。守护进程集（DaemonSet）通常不是应用部署的一部分，但是通常由系统管理员创建，以在全部或者部分节点上运行系统服务。水平pod扩容器（HorizontalpodAutoscaler）可以由开发者包含在应用manifest中或者后续由运维团队添加到系统中。集群管理员还会创建LimitRange和ResourceQuota对象，以控制每个pod和所有的pod（作为一个整体）的计算资源使用情况。<br>在应用部署后，各种Kubernetes控制器会自动创建其他的对象。其中包括端点控制器（Endpoint controller）创建的服务端点（Endpoint）对象，部署控制器（Deployment controller）创建的ReplicaSet对象，以及由ReplicaSet（或者Job、CronJob、 StatefulSet、 DaemonSet）创建的实际的pod对象。<br>资源通常通过一个或者多个标签来组织。这不仅仅适用于pod，同时也适用于其他的资源。除了标签，大多数的资源还包含一个描述资源的注解，列出负责该资源的人员或者团队的联系信息，或者为管理者和其他的工具提供额外的元数据。<br>pod是所有一切资源的中心，毫无疑问是Kubernetes中最重要的资源。毕竟，你的每个应用都运行在pod中。为了确保你知道如何开发能充分利用应用所在环境资源的应用，我们最后再从应用的角度来仔细看一下pod。<br>17.2了解pod的生命周期<br>我们之前说过，可以将pod比作只运行单个应用的虚拟机。尽管在pod中运行的应用和虚拟机中运行的应用没什么不同，但是还是存在显著的差异。其中一个例子就是pod中运行的应用随时可能会被杀死，因为Kubernetes需要将这个pod调度到另外一个节点，或者是请求缩容。我们接下来将探讨这方面的内容。<br>17.2.1应用必须预料到会被杀死或者重新调度<br>在Kubernetes之外，运行在虚拟机中的应用很少会被从一台机器迁移到另外一台。当一个操作者迁移应用的时候，他们可以重新配置应用并且手动检查应用是否在新的位置正常运行。借助于Kubernetes，应用可以更加频繁地进行自动迁移而无须人工介入，也就是说没有人会再对应用进行配置并且确保它们在迁移之后能够正常运行。这就意味着应用开发者必须允许他们的应用可以被相对频繁地迁移。</p>
<p>预料到本地 IP 和主机名会发生变化<br>当一个 pod 被杀死并且在其他地方运行之后 （技术上来讲是一个新的 pod 替换 了旧的 pod，旧 pod 没有被迁移）， 它不仅拥有了一个新的 IP 地址还有了一个新的名称和主机名。大部分无状态的应用都可以处理这种场景同时不会有不利的影响， 但是有状态服务通常不能。 我们已经了解到有状态应用可以通过一个 StatefulSet 来运行，StatefulSet 会保证在将应用调度到新的节点并启动之后， 它可以看到和之前一样的主机名和持久化状态。当然 pod 的 IP 还是会发生变化，应用必须能够应对这 种变化。因此应用开发者在一个集群应用中不应该依赖成员的 IP 地址来构建彼此的 关系，另外如果使用主机名来构建关系， 必须使用 StatefulSet。<br>预料到写入磁盘的数据会消失<br>还有一件事情需要记住的是， 在应用往磁盘写入数据的情况下， 当应用在新的 pod 中启动后这些数据可能会丢失， 除非你将持久化的存储挂载到应用的数据写入 路径。在 pod 被重新调度的时候，数据丢失是一定的，但是即使在没有调度的情况下，写入磁盘的文件仍然会丢失。甚至是在单个 pod 的生命周期过程中，pod 中的应用 写入磁盘的文件也会丢失。 我们通过一个例子来解释一下这个问题。<br>假设有个应用，它的启动过程是比较耗时的而且需要很多的计算操作。为了能 够让这个应用在后续的启动中更快， 开发者一般会把 启动过程中的一些计算结果缓存到磁盘上 （例如启动时扫描所有的用作注解的 Java类然后把结果写入到索引文件）。由于在 Kubernetes 中应用默认运行在容器中， 这些文件会被写入到容器的文件系统中。如果这个时候容器重启了， 这些文件都会丢失， 因为新的容器启动的时候会使用一个全新的可写入层（参考图 17.2）。<br>不要忘了， 单个容器可能因为各种原因被重启， 例如进程崩溃了，例如存活探针返回失败了， 或者是因为节点内存逐步耗尽， 进程被 OOMKiller 杀死了。当上述情况发生的时候，pod 还是一样， 但是容器却是全新的了。 Kubelet不会一个容器运行多次，而是会重新创建一个容器。<br>使用存储卷来跨容器持久化数据<br>当 pod 的容器重启后， 本例中的应用仍然需要执行有大量计算过程的启动程序。这个或许不是你所期望的。 为了保证这种情况下数据不丢失， 你需要至少使用一个 pod 级别的卷。因为卷的存在和销毁与 pod 生命周期是一致的，所以新的容器将可  以重用之前容器写到卷上的数据（见图 17.3）。</p>
<p>图 17.3 使用存储卷来跨入化数据<br>有时候使用存储卷来跨容器存储数据是个好办法， 但是也不总是如此。万一由于数据损坏而导致新创建的进程再次崩溃呢？这会导致一个持续性的循环崩溃（ pod</p>
<p>会提示CrashLoopBackOff状态）。如果不使用存储卷的话，新的容器会从零开始启动，并且很可能不会崩溃。使用存储卷来跨容器存储数据是把双刃剑。你需要仔细思考是否使用它们。<br>17.2.2重新调度死亡的或者部分死亡的pod<br>如果一个pod的容器一直处于崩溃状态，Kubelet将会一直不停地重启它们。每次重启的时间间隔将会以指数级增加，直到达到5分钟。在这个5分钟的时间间隔中，pod基本上是死亡了，因为它们的容器进程没有运行。公平来讲，如果是个多容器的pod，其中的一些容器可能是正常运行的，所以这个pod只是部分死亡了。但是如果pod中仅包含一个容器，那么这个pod是完全死亡的而且已经毫无用处了，因为里面已经没有进程在运行了。<br>你或许会奇怪，为什么这些pod不会被自动移除或者重新调度，尽管它们是ReplicaSet或者相似控制器的一部分。如果你创建了一个期望副本数是3的ReplicaSet，当那些pod中的一个容器开始崩溃，Kubernetes将不会删除或者替换这个pod。结果就是这个ReplicaSet只剩下了两个正确运行的副本，而不是你期望的三个（见图17.4）。</p>
<p>图17.4ReplicaSet控制器没有重新调度死亡的pod<br>你或许期望能够删除这个pod然后重新启动一个可以在其他节点上成功运行的pod。毕竟这个容器可能是因为一个节点相关的问题而导致的崩溃，这个问题在其他的节点上不会出现。很遗憾，并不是这样的。ReplicaSet本身并不关心pod是否处于死亡状态，它只关心pod的数量是否匹配期望的副本数量，在这种情况下，副本数量确实是匹配的。<br>如果你想自己研究一下，这里有一个ReplicaSet的YAML manifest文件，它里面定义的pod会不停地崩溃（这个文件是代码归档中的replicaset-rashingpods.yaml）。如</p>
<p>果创建了这个ReplicaSet然后检查一下创建的pod， 你会看到如下的代码清单。<br>代码清单17.1 ReplicaSet 和 持续崩溃的pod</p>
<p>在某种程度.上，可以理解为什么Kubemetes会这样做。容器将会每5分钟重启一次，在这个过程中Kubemetes期望崩溃的底层原因会被解决。这个机制依据的基本原理就是将pod重新调度到其他节点通常并不会解决崩溃的问题，因为应用运行在容器的内部，所有的节点理论上应该都是相同的。虽然上面的情况并不总是如此，但是大多数情况下都是这样。<br>17.2.3 以固定顺序启动pod<br>pod中运行的应用和手动运行的应用之间的另外一个不同就是运维人员在手动部署应用的时候知道应用之间的依赖关系，这样他们就可以按照顺序来启动应用。了解pod是如何启动的<br>当你使用Kubemetes来运行多个pod的应用的时候，Kubemetes没有内置的方法来先运行某些pod然后等这些pod运行成功后再运行其他pod。当然你也可以先发布第一个应用的配置，然后等待pod启动完毕再发布第二个应用的配置。但是你的整个系统通常都是定义在一个单独的YAML或者JSON文件中，这些文件包含了多个pod、服务或者其他对象的定义。<br>KubemetesAPI服务器确实是按照YAML/JSON文件中定义的对象的顺序来进行处理的，但是仅仅意味着它们在被写入到etcd的时候是有顺序的。无法确保pod</p>
<p>会按照那个顺序启动。<br>但是你可以阻止一个主容器的启动，直到它的预置条件被满足。这个是通过在pod中包含一个叫作init的容器来实现的。<br>init容器介绍<br>除了常规的容器，pod还可以包括init容器。如容器名所示，它们可以用来初始化pod，这通常意味着向容器的存储卷中写入数据，然后将这个存储卷挂载到主容器中。<br>一个pod可以拥有任意数量的init容器。init容器是顺序执行的，并且仅当最后一个init容器执行完毕才会去启动主容器。换句话说，init容器也可以用来延迟pod的主容器的启动一例如，直到满足某一个条件的时候。init容器可以一直等待直<br>一<br>到主容器所依赖的服务启动完成并可以提供服务。当这个服务启动并且可以提供服务之后，init容器就执行结束了，然后主容器就可以启动了。这样主容器就不会发生在所依赖服务准备好之前使用它的情况了。<br>下面让我们来看一个pod使用init容器来延迟主容器启动的例子。还记得第7章中你创建的名叫fortune的pod吗？它是一个能够返回给客户端请求一个人生格言作为响应的web服务。现在假设你有一个叫作fortune-client的pod，它的主容器需要依赖fortune服务先启动并且运行之后才能启动。可以给for-tune-client的pod添加一个init容器，这个容器主要检查发送给fortune服务的请求是否被响应。如果没有响应，那么这个init容器将一直重试。当这个init容器获得响应之后，它的执行就结束了然后让主容器启动。<br>将init容器加入pod<br>init容器可以在podspec文件中像主容器那样定义，不过是通过字段spec.initcontainers来定义的。可以在本书的代码归档中找到fortune-cl ientpod完整的YAML定义文件。下面的代码清单展示了init容器定义的部分。<br>代码清单17.2pod中定义的init容器：fortune-client.yaml</p>
<p>当你部署这个pod的时候，只有pod的init容器会启动起来。这个可以通过命令kubectl get查看pod的状态来展示：<br>$ kubectI get Po<br>NAME RBADY STATUS RESTARTS AGE<br>fortune-client 0/1 Init:0/1<br>Im<br>STATUS列展示了目前没有init 容器执行完毕。可以通过kubectl logs 命令来查看init容器的日志：<br>$ kubect1 logs fortune-client -c init<br>Waiting for fortune service to come up. ..<br>当运行kubectl logs 命令的时候，需要通过选项-c来指定init容器的名称（在这个例子中，pod的init容器的名称就叫作init，如代码清单17.2所示）。<br>主容器直到你部署的fortune服务和fortune-server pod启动之后才会运行。这些配置内容都在文件fortune-server.yaml中。<br>处理pod内部依赖的最佳实践<br>你已经了解如何通过init容器来延迟pod主容器的启动，直到预置的条件被满足（例如，为了确保pod所依赖的服务已经准备好），但是更佳的情况是构建一个不需要它所依赖的服务都准备好后才能启动的应用。毕竟，这些服务在后面也有可能下线，但是这个时候应用已经在运行中了。<br>应用需要自身能够应对它所依赖的服务没有准备好的情况。另外不要忘了Readiness探针。如果-个应用在其中一个依赖缺失的情况下无法工作，那么它需要通过它的Readiness探针来通知这个情况，这样Kubernetes也会知道这个应用没有准备好。需要这样做的原因不仅仅是因为这个就绪探针收到的信号会阻止应用成为一个服务端点，另外还因为Deployment控制器在滚动升级的时候会使用应用的就绪探针，因此可以避免错误版本的出现。<br>17.2.4 增加生命周期钩子<br>我们已经讨论了如果使用init容器来介入pod的启动过程，另外pod还允许你定义两种类型的生命周期钩子：<br>启动后 （Post-start） 钩子<br>·停止前（Pre-stop） 钩子<br>这些生命周期的钩子是基于每个容器来指定的，和init容器不同的是，init容器是应用到整个pod。这些钩子，如它们的名字所示，是在容器启动后和停止前执行的。生命周期钩子与存活探针和就绪探针相似的是它们都可以：</p>
<p>·在容器内部执行一个命令<br>· 向一个 URL 发送 HTTP GET 请求<br>让我们分别来看一下这两个钩子， 看看它们是如何在容器的生命周期中起作用的。<br>使用启动后容器生命周期钩子<br>启动后钩子是在容器的主进程启动之后立即执行的。 可以用它在应用启动时做一些额外的工作。当然， 如果你是容器中运行的应用的开发者， 可以在应用的代码中加入这些操作。但是， 如果你在运行一个其他人开发的应用， 大部分情况下并不想（或者无法）修改它的源代码。 启动后钩子可以让你在不改动应用的情况下，运行一些额外的命令。这些命令可能包括向外部监听器发送应用已启动的信号， 或者是初始化应用以使得应用能够顺利运行。<br>这个钩子和主进程是并行执行的。 钩子的名称或许有误导性， 因为它并不是等到主进程完全启动后 （如果这个进程有一个初始化的过程， Kubelet显然不会等待这个过程完成， 因为它并不知道什么时候会完成）才执行的 。<br>即使钩子是以异步方式运行的， 它确实通过两种方式来影响容器。 在钩子执行完毕之前， 容器会一直停留在 Waiting 状态， 其原因是ContainerCreating。因此，pod 的状态会是 Pending 而不是 Running。如果钩子运行失败或者返回了 非零的状态码，主容器会被杀死。<br>一个包含启动后钩子的 pod manifest 内容如下面的代码清单所示。<br>start-hook.yamiz<br>包含启动后生命周期钩子的 pod：post-</p>
<p>在这个例子中，命令echo, sleep 和exit是在容器创建时和容器的主进程<br>一起执行的。典型情况下，我们并不会像这样来执行命令，而是通过存储在容器镜</p>
<p>像中的shell脚本或者二进制可执行文件来运行。<br>遗憾的是，如果钩子程序启动的进程将日志输出到标准输出终端，你将无法在任何地方看到它们。这样就会导致调试生命周期钩子程序非常痛苦。如果钩子程序失败了，你仅仅会在pod的事件中看到一个FailedPostStartHook的告警信息（可以通过命令kubectl describe pod来查看）。稍等一会儿，你就可以看到更多关于钩子为什么失败的信息，如下面的代码清单所示。<br>代码清单17.4pod的事件显示了基于命令的钩子程序的退出码<br>FailedSync Error syncing pod, skipping: failed to “Startcontainer” for<br>“kubia” with Poststart handler: command Ish -c echo ‘hook will fail with exit code 1s’;sleep s ;exit l5’exited with15::Poststart Hook Failed”<br>最后一行的数字15就是命令的退出码。当使用HTTPGET请求作为钩子的时候，失败原因可能类似于如下代码清单（可以从本书的代码归档中找到文件post-start-hook-httpget.yaml并部署一下）。<br>代码清单17.5pod的事件显示了基于HTTPGET的钩子程序的失败原因FailedSync<br>Error syncing pod, skipping: failed to “Startcontainer” for “kubia” with Poststart handler: Get<br><a href="http://10.32.0.2:9090/poststart:dialtcp10.32.0.2:9090" target="_blank" rel="noopener">http://10.32.0.2:9090/poststart:dialtcp10.32.0.2:9090</a>: getsockopt: connection refused: “Poststart Hook Failed”<br>注意这个启动后钩子是故意地使用错误的端口9090而不是正确的端口8080来演示钩子失败时会发生什么情况的。<br>基于命令的启动后钩子输出到标准输出终端和错误输出终端的内容在任何地方都不会记录，因此你或许想把钩子程序的进程输出记录到容器的文件系统文件中，这样你可以通过如下的命令来查看文件的内容：<br>$ kubectl exec my-pod cat logfile.txt<br>如果容器因为各种原因重启了（包括由于钩子执行失败导致的），这个文件在你能够查看之前就消失了。这种情况下，可以通过给容器挂载一个emptyDir卷，并且让钩子程序向这个存储卷写入内容来解决。<br>使用停止前容器生命周期钩子<br>停止前钩子是在容器被终止之前立即执行的。当一个容器需要终止运行的时候，Kubelet在配置了停止前钩子的时候就会执行这个停止前钩子，并且仅在执行完钩子程序后才会向容器进程发送SIGTERM信号（如果这个进程没有优雅地终止运行，</p>
<p>则会被杀死）。<br>停止前钩子在容器收到 SIGTERM 信号后没有优雅地关闭的时候， 可以利用它来触发容器以优雅的方式关闭。 这些钩子也可以在容器终 止之前执行任意的操作，并且并不需要在应用内部实现这些操作 （当你在运行一个第三方应用，并且在无法 访问应用或者修改应用源码的情况下很有用 ）。<br>在 pod 的 manifest 中配置停止前钩子和增加一个启动后钩子方法差不多。上面 的例子演示了执行命令的启动后钩子， 这里我们来看看执行一个 HTTP GET 请求的停止前钩子。下面的代码清单演示了如何在 pod 中定义一个停止前 HTTP GET 的钩 子。<br>代码清单 17.6停止前钩子的YAML配置片段：pre-stop-hooks<br>httpget.yaml<br>lifecycle:<br>这是一个执行 HTTP GET 请求<br>preStop:<br>的停止前钩子<br>httpGet:<br>port: 8080<br>这个请求发送到<a href="http://POD_" target="_blank" rel="noopener">http://POD_</a><br>path: shutdown<br>IP:8080/shutdown<br>这个代码清单中定义的停止前钩子在 Kubelet 开始终止容器的时候就立即执行 到<a href="http://podIP:8080/shutdown的HTTPGET请求。除了代码清单中所示的port和path，还可以设置" target="_blank" rel="noopener">http://podIP:8080/shutdown的HTTPGET请求。除了代码清单中所示的port和path，还可以设置</a> scheme （HTTP 或HTTPS）和 host， 当然也可以设置发送出去的请求的 httpHeaders。默认情况下， host 的值是 pod 的 IP 地址。确保请求 不会发送到 localhost，因为 localhost 表示节点，而不是 pod。<br>和启动后钩子不同的是， 无论钩子执行是否成功容器都会被终止。无论是HTTP 返回的错误状态码或者基于命令的钩子返回的非零退出码都不会阻止容器的终止。 如果停止前钩子执行失败了， 你会在 pod 的事件中看到一个FailedPreStopHook 的告警， 但是因为 pod 不久就会被删除了（毕竟是 pod的删除动作触发的停止前钩子的执行）， 你或许都看不到停止前钩子执行失败了。<br>提示如果停止前钩子的成功执行对系统的行为很重要， 请确认这个钩子是否成功执行了。 笔者遇到过停止前钩子根本没有执行而开发者都没有注意到的情况。<br>在应用没有收到 SIGTERM 信号时使用停止前钩子<br>很多开发者在定义停止前钩子的时候会犯错误， 他们在钩子中只向应用发送了SIGTERM 信号。 他们这样做是因为他们没有看到他们的应用接收到 Kubelet 发送的SIGTERM 信号。 应用没有接收到信号的原因并不是 Kubernetes 没有发送信号，而是因为在容器内部信号没有被传递给应用的进程。 如果你的容器镜像配置是通过执行</p>
<p>一个shell 进程，然后在shell进程内部执行应用进程，那么这个信号就被这个shell进程吞没了，这样就不会传递给子进程。<br>在这种情况下，合理的做法是让shell进程传递这个信号给应用进程，而不是添加一个停止前钩子来发送信号给应用进程。可以通过在作为主进程执行的shell进程内处理信号并把它传递给应用进程的方式来实现。或者如果你无法配置容器镜像执行shell进程，而是通过直接运行应用的二进制文件，可以通过在Docker file中使用 ENTRYPOINT或者CMD的exec方式来实现，即ENTRYPOINT [“/mybinary”] 而不是ENTRYPOINT / mybinary。<br>在通过第—种方式运行二进制文件mybinary的容器中，这个进程就是容器的主进程，而在第二种方式中，是先运行一个shell 作为主进程，然后mybinary进程作为shell进程的子进程运行。<br>了解生命周期钩子是针对容器而不是pod<br>作为对启动后和停止前钩子最后的思考，笔者会强调的是这些生命周期的钩子是针对容器而不是pod的。你不应该使用停止前钩子来运行那些需要在pod终止的时候执行的操作。原因是停止前钩子只会在容器被终止前调用（大部分可能是因为存活探针失败导致的终止）。这个过程会在pod的生命周期中发生多次，而不仅仅是在pod被关闭的时候。<br>17.2.5了 解pod的关闭<br>我们已经接触过关于pod终止的话题，所以这里我们会进一步 探讨相关细节来看看pod关闭的时候具体发生了什么。这个对理解如何干净地关闭pod中运行的应用很重要。<br>让我们从头开始，pod的关闭是通过API服务器删除pod的对象来触发的。当接收到HtTP DELETE请求后，API 服务器还没有删除pod对象，而是给pod设置一个deletionT imestamp值。拥有deletionTimestamp的pod就开始停止了。<br>当Kubelet意识到需要终止pod的时候，它开始终止pod中的每个容器。Kubelet会给每个容器一定的时间来优雅地停止。这个时间叫作终止宽限期（Terminat in Gr acePeriod），每个pod可以单独配置。在终止进程开始之后，计时器就开始计时，接着按照顺序执行以下事件：<br>1.执行停止前钩子（如果配置了的话），然后等待它执行完毕<br>2.向容器的主进程发送SIGTERM信号<br>3.等待容器优雅地关闭或者等待终止宽限期超时<br>如果容器主进程没有优雅地关闭，使用SIGKILL信号强制终止进程</p>
<p>图17.5容器停止顺序<br>指定终止宽限期<br>终 止 宽 限 期 可 以 通 过 p pec 中 的 spec.terminationGracePeriod  Periods 字段来设置。默认情况下， 值为30， 表示容器在被强制终止之前会有 30 秒的时间来自行优雅地终止。<br>提示 你应该将终止宽限时间设置得足够长， 这样你的容器进程才可以在这个时间段内完成清理工作。<br>在删除pod的时候，pod spec中指定的终止宽限时间也可以通过如下方式来覆盖：$ kubectl delete po mypod —grace-period=5<br>这个命令将会让Kubectl等待5秒钟， 让 pod 自行关闭。当 pod 所有的容器都 停止后，Kubelet 会通知 API 服务器，然后 pod 资源最终都会被删除。可以强制 API 服务器立即删除 pod 资源， 而不用等待确认。 可以通过设置宽限时间为 0，然后增加一个 —force 选项来实现：<br>$ kubectl delete po mypod . —grace-period=0 —force<br>在使用这个选项的时候需要注意，尤其是 StatefulSet 的 pod。StatefulSet 控制器 会非常小心地避免在同一时间运行相同 pod 的两个实例（两个 pod拥有相同的序号、 名称，并且挂载到相同的 PersistentVolume）。强制删除一个 pod 会导致控制器不会等待被删的 pod 里面的容器完成关闭就创建一个替代的 pod。换句话说，相同 pod的两个实例可能在同一时间运行， 这样会导致有状态的集群服务工作异常。 只有在确认 pod 不会再运行， 或者无法和集群中的其他成员通信 （可以通过托管 pod 的节点网络连接失败并且无法重连来确认） 的情况下再强制删除有状态的 pod。<br>现在你已经了解了容器关闭的方式， 接下来我们从应用的角度来看一下应用应 </p>
<p>该如何处理容器的关闭流程。<br>在应用中合理地处理容器关闭操作<br>应用应该通过启动关闭流程来响应SIGTERM信号，并且在流程结束后终止运行。除了处理SIGTERM信号，应用还可以通过停止前钩子来收到关闭通知。在这两种情况下，应用只有固定的时间来干净地终止运行。<br>但是如果你无法预测应用需要多长时间来干净地终止运行怎么办呢？例如，假设你的应用是一个分布式数据存储。在缩容的时候，其中一个pod的实例会被删除然后关闭。在这个关闭的过程中，这个pod需要将它的数据迁移到其他存活的pod上面以确保数据不会丢失。那么这个pod是否应该在接收到终止信号的时候就开始迁移数据（无论是通过SIGTERM信号还是停止前钩子）？<br>完全不是！这种做法是不推荐的，理由至少有两点：<br>，一个容器终止运行并不一定代表整个pod被终止了。<br>，你无法保证这个关闭流程能够在进程被杀死之前执行完毕。<br>第二种场景不仅会在应用在超过终止宽限期还没有优雅地关闭时发生，还会在容器关闭过程中运行pod的节点出现故障时发生。即使这个时候节点又重启了，Kubelet不会重启容器的关闭流程（甚至都不会再启动这个容器了）。这样就无法保证pod可以完成它整个关闭的流程。<br>将重要的关闭流程替换为专注于关闭流程的pod<br>如何确认一个必须运行完毕的重要的关闭流程真的运行完毕了呢（例如，确认一个pod的数据成功迁移到了另外一个pod）？<br>一个解决方案是让应用（在接收到终止信号的时候）创建一个新的Job资源，这个Job资源会运行一个新的pod，这个pod唯一的工作就是把被删除的pod的数据迁移到仍然存活的pod。但是如果你注意到的话，你就会了解你无法保证应用每次都能够成功创建这个Job对象。万一当应用要去创建Job的时候节点出现故障呢？<br>这个问题的合理的解决方案是用一个专门的持续运行中的pod来持续检查是否存在孤立的数据。当这个pod发现孤立的数据的时候，它就可以把它们迁移到仍存活的pod。当然不一定是一个持续运行的pod，也可以使用CronJob资源来周期性地运行这个pod。<br>你或许以为StatefulSet在这里会有用处，但实际上并不是这样。如你所记起的那样，给StatefulSet缩容会导致PersistentVolumeClaim处于孤立状态，这会导致存储在PersistentVolumeClaim中的数据搁浅。当然，在后续的扩容过程中，PersistentVolume会被附加到新的pod实例中，但是万一这个扩容操作永远不会发生（或者很久之后才会发生）呢？因此，当你在使用StatefulSet的时候或许想运行一个</p>
<p>数据迁移的pod（这种场景如图17.6 所示)。为了避免应用在升级过程中出现数据<br>迁移，专门用于数据迁移的pod可以在数据迁移之前配置一个等待时间，让有状态<br>的pod 有时间启动起来。</p>
<p>图17.6使用专门的 pod 来迁移数据<br>17.3 确保所有的客户端请求都得到了妥善处理<br>你已经了解清楚如何干净地关闭 pod 了。 现在，我们从 pod 的客户端角度来看 看 pod 的生命周期（使用 pod 提供的服务的客户端）。 了解这一点很重要，如果你希望pod 扩容或者缩容的时候客户端不会遇到问题的话。<br>毋庸赘言，你希望所有的客户端请求都能够得到妥善的处理。 你显然不希望pod 在启动或者关闭过程中出现断开连接的情况。 Kubernetes 本身并没有避免这种事情的发生。你的应用需要遵循一些规则来避免遇到连接断开的情况。首先，我们重点看一下如何在 pod 启动的时候， 确保所有的连接都被妥善处理了。<br>17.3.1 在 pod 启动时避免客户端连接断开<br>确保 pod 启动的时候每个连接都被妥善处理很容易 ，只要你理解了服务和服务端点是如何工作的。当一个 pod 启动的时候， 它以服务端点的方式提供给所有的服务，这些服务的标签选择器和 pod 的标签匹配。在第 5 章说过，pod 需要发送信号给 Kubernetes 通知它自己已经准备好了。 pod 在准备好之后，它才能变成一个服务 端点， 否则无法接收任何客户端的连接请求。<br>如果你在 pod spec 中没有指定就绪探针， 那么 pod 总是被认为是准备好了的。 当第一个 kube-proxy 在它的节点上面更新了 iptables 规则之后，并且第一个客户 </p>
<p>端pod开始连接服务的时候，这个默认被认为是准备好了的pod几乎会立即开始接收请求。如果你的应用这个时候还没有准备好接收连接，那么所有的客户端都会看到“连接被拒绝”-类的错误信息。<br>你需要做的是当且仅当你的应用准备好处理进来的请求的时候，才去让就绪探针返回成功。好的实践第一步是添加一个指向应用根URL的HTTPGET请求的就绪探针。在很多情况下，这样做就足够了，免得你还需要在应用中实现一个特殊的readiness endpoint.<br>17.3.2在pod关闭时避免客户端连接断开<br>现在我们来看一下在pod生命周期的另一端一当 pod被删除，pod 的容器被终止的时候会发生什么。我们已经讨论过pod的容器应该如何在它们收到SIGTERM信号的时候干净地关闭（或者容器的停止前钩子被执行的时候）。但是这就能确保所有的客户端请求都被妥善处理了吗？<br>当应用接收到终止信号的时候应该如何做呢？它应该继续接收请求么？那些已经被接收但是还没有处理完毕的请求该怎么办呢？那些打开的HTTP长连接（连接上已经没有活跃的请求了）该怎么办呢？在回答这些问题之前，我们需要详细地看一下当pod删除的时候，集群中的一连串事件是如何发生的。<br>了解pod删除时发生的一连串事件<br>在第11章中，我们深入地研究了一下Kubemetes集群的组成部分。你需要一直记住的是这些组件都是运行在不同机器上面的不同的进程。它们并不是在一个庞大的单一进程中。让集群中的所有组件同步到一致的集群状态需要时间。我们通过pod删除时集群中发生的一连串事件来探究一下真相。<br>当API服务器接收到删除pod的请求之后，它首先修改了etcd中的状态并且把删除事件通知给观察者。其中的两个观察者就是Kubelet和端点控制器（EndpointController）。图17.7展示了并行发生的两串事件（用A或B标识）。<br>在标识为A的一串事件中，当Kubelet接收到pod应该被终止的通知的时候，它初始化了17.2.5中讲解过的关闭动作序列（执行停止前钩子，发送SIGTERM信号，等待一段时间，然后在容器没有自我终止时强制杀死容器）。如果应用立即停止接收客户端的请求以作为对SIGTERM信号的响应，那么任何尝试连接到应用的请求都会收到ConnectionRefused的错误。从pod被删除到发生这个情况的时间相对来说特别短，因为这是API服务器和Kubelet之间的直接通信。</p>
<p>图17.7 pod 删除时发生的一连 串事件<br>那么，让我们再看看另外一串事件中发生了什么一就是在pod被从 iptables规则中移除之前的那些事件（图中标识为B的序列）。当端点控制器（在Kubernetes的控制面板的ControllerManager中运行）接收到pod要被删除的通知时，它从所有pod所在的服务中移除了这个pod的服务端点。它通过向API服务器发送REST请求来修改EndpointAPI对象。然后API服务器会通知所有的客户端关注这个Endpoint对象。其中的-些观察者都是运行在工作节点上面的kube-proxy服务。每个kube-proxy服务都会在自己的节点上更新iptables规则，以阻止新的连接被转发到这些处于停止状态的pod，上。这里一个重要的细节是，移除iptables规则对已存在的连接没有影响一已经连接到pod的客户端仍然可以通过这些连接向pod发送额外的请求。<br>上面的两串事件是并行发生的。最有可能的是，关闭pod中应用进程所消耗的时间比完成iptables规则更新所需要的时间稍微短一点。导致iptables规则更新的那一串事件相对比较长（见图17.8），因为这些事件必须先到达Endpoint控制器，然后Endpoint控制器向API服务器发送新的请求，然后API服务器必须修改kube-proxy，最后kube-proxy再修改iptables规则。存在-个很大的可能性是SIGTERM信号会在iptables规则更新到所有的节点之前发送出去。<br>最终的结果是，在发送终止信号给pod之后，pod 仍然可以接收客户端请求。如果应用立即关闭服务端套接字，停止接收请求的话，这会导致客户端收到“连接被拒绝”-类的错误（这个情形和pod启动时应用还无法立即接收请求，并且还没有给pod定义-个就绪探针时发生的一样）。</p>
<p>图17.8 pod 删除时事件发生的时间线<br>解决问题<br>用Google搜索这个问题的解决方案看上去就是给你的pod添加—个就绪探针来解决问题。假设你所需要做的事情就是在pod接收到SIGTERM信号的时候就绪探针开始失败。这会导致pod从服务的端点中被移除。但是这个移除动作只会在就绪探针持续性失败一段时间后才 会发生（可以在就绪探针的spec中配置），并且这个移除动作还是需要先到达kube-proxy然后iptables规则才会移除这个pod.<br>实际上，就绪探针完全不影响这个过程。端点控制器在接收到pod要被删除（当pod spec中的deletionTimestamp字段不再是null）的通知的时候就会从Endpoint中移除pod.从那个时候开始，就绪探针的结果已经无关紧要了。<br>那么这个问题的合适的解决方案是什么呢？如何保证所有的请求都被处理了呢？<br>很明显，pod必须在接收到终止信号之后仍然保持接收连接直到所有的kube-proxy完成了iptables规则的更新。当然，不仅仅是kube-proxy，这里还会有 Ingress控制器或者负载均衡器直接把请求转发给pod而不经过Service（ iptables）。这也包括使用客户端负载均衡的客户端。为了确保不会有客户端遇到连接断开的情况，需要等到它们通知你它们不会再转发请求给pod的时候。<br>这是不可能的，因为这些组件分布在不同的机器上面。即使你知道每一个组件的位，置并且可以等到它们都来通知你可以关闭pod了，万一其中有—个组件未响应呢？这个时候，你需要等待这个回复多长时间？记住，在这个时间段内，你延阻了关闭的过程。<br>你可以做的唯一的合理的事情就是等待足够长的时间让所有的kube-proxy可以</p>
<p>完成它们的工作。 那么多长时间才是足够的呢？ 在大部分场景下，几秒钟应该就足够了，但是无法保证每次都是足够的。当 API 服务器或者端点控制器过载的时候， 通知到达kube-proxy的时间会更长。 你无法完美地解决这个问题， 理解这一点很重要，但是即使增加5秒或者 10秒延迟也会极大提升用户体验。 可以用长一点的延迟时间，但是别太长， 因为这会导致容器无法正常关闭， 而且会导致 pod 被删除很长一段时间后还显示在列表里面，这个会给删除 pod 的用户带来困扰。<br>小结<br>简要概括一下，妥善关闭一个应用包括如 下步骤：<br>等待几秒钟，然后停止接收新的连接。<br>· 关闭所有没有请求过来的长连接。<br>等待所有的请求都完成。<br>● 然后完全关闭应用。<br>为了理解这个过程中连接和请求都发生了什么，请仔细看一下图17.9。 </p>
<p>图17.9 在接收到终止信号后妥善地处理已存在和建立的连接<br>这个过程不像进程接收到终止信号立即退出那么简单，不是吗？真的值得这么 做吗？这个取决于你。但是至少你可以添加一个停止前钩子来等待几秒钟再退 出，或许就像下面代码清单中所示的一样。<br>17.4 让应用在Kubernetes中方便运行和管理<br>505<br>代码清单 17.7用于避免连接断开的停止前钩子</p>
<p>这样你就不需要修改你的代码了。 如果你的应用已经能够确保所有的进来的请 求都得到了处理， 那么这个停止前钩子带来的等待已经足够了。<br>17.4 让应用在Kubernetes中方便运行和管理<br>希望你 目前已经对如何妥善处理客户端请求有 了一个更加清晰的了解。现在我们来看看其他方面的内容， 即如何构建方便在 Kubernetes 中管理的应用。<br>17.4.1 构建可管理的容器镜像<br>当你把应用打包进镜像的时候， 可以包括应用的二进制文件和它的依赖库， 或者可以将一个完整的操作系统和应用打包在一起。很多人都会这样做，尽管很多时 候并不需要这样。<br>镜像里面的操作系统中的每个文件你都需要吗？或许并不是这样。大多数文件 都不会用到而且仅仅会让你的镜像变得比需要的大。当然， 镜像的分层会让每个独立的层只会被下载一次，但是当 pod 第一次被调度到节点的时候， 你也不希望等待过长的时间。<br>部署新的 pod 或者扩展它们会很快。 这个要求镜像足够小而且不包容任何无用 的东西。如果你使用 Go语言来构建应用， 你的镜像除了应用的可执行二进制文件 外不需要任何东西。这样基于 Go 语言的容器镜像就会非常小， 很适合 Kubernetes。提示在这些镜像的 Dockerfile 中使用 FROM scratch 指令。<br>但是在实践中， 你就会发现这些最小化构建的镜像非常难以调试。当你需要运行一些工具，例如 ping、dig、 curl 或者容器中其他类似的命令的时候， 你就会意识到让容器再至少包含这些工具的最小集合有多重要。 笔者无法告诉你应该在你的镜像中包含哪些工具，不包含哪些工具， 因为一切取决于你的需求，你需要自己 发现最适合自己的方式。</p>
<p>17.4.2 合理地给镜像打标签，正确地使用ImagePullPolicy<br>你很快就会发现在podmanifest中使用latest来引用镜像会出问题，因为你无法知道每个pod副本中运行的镜像版本。即使开始的时候所有的pod副本都运行相同的镜像版本，当你再以标签latest来推送一个新的镜像版本的时候，如果 pod被重新调度了（或者你扩容了Deployment），新的pod就会运行新的镜像版本，而旧的pod还是运行旧的镜像版本。另外，使用latest标签会导致你无法回退到之前的版本（除非你重新推送了旧的镜像）。<br>必须使用能够指明具体版本的标签而不是latest。记住如果你使用的是可更改的标签（总是向相同的标签推送更改），那么你需要在podspec中将imagePullPolicy设置为Always。但是如果你在生产环境中使用这种方式，需要注意它的附加说明。如果镜像的拉取策略设置为Always的话，容器的运行时在遇到新的pod需要部署的时候都会去联系镜像注册中心。这会拖慢pod的启动速度，因为节点需要去检查镜像是否已经被修改了。更糟糕的是，当镜像注册中心无法连接到的时候，这个策略会导致新的pod无法启动。<br>17.4.3使用多维度而不是单维度的标签<br>别忘了给所有的资源都打上标签，而不仅仅是pod.确保你给每个资源添加了多个标签，这样就可以通过不同的维度来选择它们了。在资源数量飞速增长的时候，你（或者运维团队）会感激你自己的。<br>标签可以包含如下的内容<br>， 资源所属的应用（或者微服务）的名称<br>应用层级（前端、后端，等等）<br>运行环境 （开发、测试、预发布、生产，等等）<br>·版本号<br>·发布类型（稳定版、金丝雀、蓝绿开发中的绿色或者蓝色，等等）<br>·租户（如果你在每个租户中运行不同的pod而不是使用命名空间）<br>·分片（带分片的系统）<br>标签管理可以让你以组而不是隔离的方式来管理资源，从而很容易了解资源的归属。<br>17.4.4 通过注解描述每个资源<br>可以使用注解来给你的资源添加额外的信息。资源至少应该包括一个描述资源的注解和一个描述资源负责人的注解。</p>
<p>在微服务框架中，pod 应该包含一个注解来描述该 pod 依赖的其他服务的名称。这样就很容易展现 pod 之间的依赖关系了。 其他的注解可以包括构建和版本信息， 以及其他工具或者图形界面会使用到的元信息（图标名称等）。<br>标签和注解都可以让你更加容易地管理运行中的应用， 但是没有什么比应用开始崩溃而你对原因一无所知更糟糕的了。<br>17.4.5 给进程终止提供更多的信息<br>没有什么比调查容器为什么终止运行 （或者持续终止运行）更加令人沮丧的了， 尤其是在最糟糕的时候发生这个情况。 对运维人员好一点吧， 把所有必需的调试信息都写到日志文件中。<br>为了让诊断过程更容易，可以使用 Kubernetes 的另一个特性，这个特性可以在  pod 状态中很容易地显示出容器终止的原因。 可以让容器中的进程向容器的文件系 统中指定文件写入一个终止消息。 这个文件的内容会在容器终止后被 Kubelet 读取， 然后显示在 kubectl describe pod 中。 如果一个应用使用这种机制的话，操 作人员无须去查看容器的 日志就可以很快地看到应用为什么终止了。<br>这个进程需要写入终止消息的文件默认路径是 /dev/termination-log，当然这个路径也可以在 pod spec 中容器定义的部分设置 terminationMessagePath字段来自定义。<br>可以通过运行一个容器会立即死亡的 pod 来实际看一下这个过程，如下面的代 码清单所示。<br>代码清单 17.8<br>写终止消息的 pod：termination-message. yaml </p>
<p>当运行这个pod的时候，你会很快看到pod的状态变成CrashLoopBackOff。这个时候如果你使用kubectl describe， 你会看到容器为什么死亡了，而不需要去深入到它的日志中，如下面的代码清单所示。<br>508<br>17开发 应用的最佳实践<br>代码清单17.9使用 kubectl describe 来查看容器的终止消息</p>
<p>如你所见，容器进程写入文件/var/ter minat ion-r eas呻h的终止消息“I’vehad enough”显示在了容器的Last State中。注意，这个机制并不仅仅适用于崩溃的容器。它也可以用在那些运行一个可完成的任务并且成功终止的容器中（可以在文件teminat ion-message-succegsaml中找到示例）。<br>这种机制对已终止运行的容器非常有用，然而你或许会同意类似的机制对于显示运行中的应用的特定状态信息（不仅仅是已终止的容器）也很有用。Kubernet es暂时不提供类似功能，而且笔者也不清楚是否有计划引入。<br>注意如果容器没有向任何文件写入消息，可以将terminationMessagePolicy字段的值设置为FallbackToLogsOnError。在这种情况下，容器的最后几行日志会被当作终止消息（当然仅当容器没有成功终止的情况下）。<br>17.4.6处理应用日志<br>当我们讨论应用的日志记录时，我们再次强调应用应该将日志写到标准输出终端而不是文件中。这样可以很容易地通过kubectllogs命令来查看应用日志。<br>提示如果一个容器崩溃了，然后使用一个新的容器替代它，你就会看到新的容器的日志。如果希望看到之前容器的日志，那么在使用kubectllogs命令的时候，加上选项—previous。<br>如果应用把日志写到了文件而不是标准输出终端，那么可以使用另外一种方法来查看日志：</p>
<p>这个命令会在容器内部执行cat命令，把日志流返回给kubectl，然后kubectl将它们显示在你的终端。<br>将日志或者其他文件复制到容器或者从容器中复制出来<br>也可以使用kubectlcp命令将日志文件复制到本地机器，这个我们目前还没有介绍过。这个命令允许你从容器中复制文件或者将文件复制到容器中。例如，如果一个pod名叫foo-pod，它只有一个容器，并且这个容器有个文件叫作/var/1og/foo.log，那么可以使用下面的命令将这个文件传送到本地机器：<br>$ kubectl cp foo-pod:/var/log/foo.logfoo.log<br>将文件从你的本地机器复制到pod中，可以指定pod的名字作为第二个参数：$ kubectl cp localfile foo-pod:/etc/remotefile<br>这个命令把本地文件localfile复制到了pod的容器里面，路径是/etc/remotefle.如果pod中有多个容器，可以使用-ccontainerName选项来指定具体的容器。使用集中式日志记录<br>在一个生产环境系统中，你希望使用一个集中式的面向集群的日志解决方案，所以你所有的日志都会被收集并且（永久地）存储在一个中心化的位置。这样你可以查看历史日志，分析趋势。如果没有这个系统，pod的日志只有在pod存在的时候才存在。当pod被删除之后，它的日志也会被删除。<br>Kubermetes本身并不提供任何集中式的日志记录，必须通过其他的组件来支持所有容器日志的集中式的存储和分析，这些组件通常在集群中以普通的pod方式运行。<br>部署集中式的日志记录方案很简单。你需要做的就是部署几个YAML/JSON的manifest文件，这样就可以了。在Google的Kubemetes引擎上，这个就更加简单了。在设置集群的时候选中“Enable Stackdriver Logging”选项即可。在一个预置的Kubemetes集群上配置一个集中式的日志记录功能已经超出了本书的范畴，但是会给你大致介绍一下常见的方式。<br>你或许已经听说过由ElasticSearch、Logstash和Kibana组成的ELK栈。一个稍微更改的变种是EFK栈，其中Logstash被FluentD替换了。<br>当使用EFK作为集中式日志记录的时候，每个Kubemetes集群节点都会运行一个FluentD的代理（通过使用DaemonSet作为pod来部署），这个代理负责从容器搜集日志，给日志打上和pod相关的信息，然后把它们发送给ElasticSearch，然后由ElasticSearch来永久地存储它们。ElasticSearch在集群中也是作为pod部署的。这些日志可以通过Kibana在Web浏览器中查看和分析，Kibana是一个可视化</p>
<p>ElasticSearch 数据的工具。它经常也是作为pod来运行的，并且通过一个服务暴露<br>出来。EFK的三个组件如下图所示。</p>
<p>图17.10使用FluentD、ElasticSearch和Kibana的集中式日志记录<br>注意在下一章，你会学习到Helm图表。可以使用Kubemetes社区创造的图表来部署EFK栈，不用再自己创建YAML manifest文件了。<br>处理多行日志输出<br>FluentD代理将日志文件的每一行当作一个条目存储在ElasticSearch数据存储中。这里就会有一个问题。当日志输出跨越多行的时候，例如Java的异常堆栈，就会以不同条目存储在集中式的日志记录系统中。<br>为了解决这个问题，可以让应用日志输出JSON格式的内容而不是纯文本。这样的话，一个多行的日志输出就可以作为一个条目进行存储了，也可以在Ki bana中以一个条目的方式显示出来。但是这种做法会让通过kubectllogs命令查看日志变得不太人性化了。<br>解决方案或许是输出到标准输出终端的日志仍然是用户可读的日志，但是写入日志文件供FluentD处理的日志是JSON格式。这就要求在节点级别合理地配置FluentD代理或者给每一个pod增加一个轻量级的日志记录容器。<br>17.5开发和测试的最佳实践<br>我们已经讲解了开发应用时需要注意的事项，但是我们还没有谈到帮助你简化这些过程的开发和测试流程。这里笔者不打算讲得太详细，因为每个人都需要找到适合他们自己的最佳方式，但是这里有几个方案的基本出发点供参考。<br>17.5.1开发过程中在Kubernetes之外运行应用<br>当你在开发一个即将在生产环境的Kubemetes中运行的应用时，是否意味着你需要在开发的时候就在Kubernetes中运行它呢？并不一定。如果一定需要在每次小</p>
<p>的修改后构建应用，构建容器镜像，然后推送到镜像中心，再重新部署pod服务，那么整个开发过程会非常缓慢而痛苦。幸运的是，你并不需要经历这些麻烦。<br>可以一直在自己的本地机器上面开发和运行应用，和过去的方式一样。毕竟， Kubernetes上面运行的应用也只是集群中某个节点上面运行的一个普通的（隔离的）进程。如果应用依赖了Kubernetes环境提供的一些功能，可以很容易地在本地开发的机器上面复制这个功能。<br>这里甚至没有讨论到在容器中运行应用的部分。大多数时间你不需要这样做，通常可以直接在你的IDE里面运行你的应用。<br>连接到后台服务<br>在生产环境中，如果应用连接到后台服务，并且使用环境变量BACKENDSERVICE_HOST和BACKEND_SERVICE PORT来查找服务的协调者，可以很容易地在本地机器上手动设置这些环境变量，并且把它们指向到后台服务，不管这个后台服务是在Kubernetes里面还是外面运行。如果这个服务在Kubernetes里面运行，总是可以（至少是临时的）把这个服务改为NodePort或者LoadBalancer类型来让这个服务对外可访问。<br>连接到API服务器<br>同样地，如果你的应用运行在Kubernetes集群中时需要访问Kubernetes的API服务器，它在开发的时候可以很容易地从集群外部访问API服务器。如果应用使用ServiceAccount凭证来验证自己，那么你可以把ServiceAccount 的Secret文件使用kubectlcp命令复制到你的本地机器。API服务器并不关心客户端的请求是来自集群内部还是外部。<br>如果应用使用ambassador container的话，就像第8章描述的那样，你甚至都不需要那些Secret文件。在你本地机器上运行kubeletproxy，然后本地运行你的应用，这个应用将很容易和这个kubeletproxy通信（只要这个应用和ambassador container 把代理绑定到同一个端口）。<br>在这种情况下，需要确保本地kubectl所使用的用户账号和应用将在某个ServiceAccount下运行的这个ServiceAccount具有相同的权限。<br>在开发过程中在容器内部运行应用<br>如果在开发过程中，你因为各种原因不可避免地要在容器中运行应用，这里有个方法，不用每次都去构建一个容器。例如，可以总是将本地文件系统通过Docker的Volume挂载到容器中。这样，当你给应用构建了一个新的二进制版本之后，你所需要做的事情就是重启这个容器（在支持热部署的情况下，甚至都不需要重启容器），不需要重新构建整个镜像。</p>
<p>17.5.2 在开发过程中使用Minikube<br>如你所见，在开发过程中并不会强迫你在Kubernetes中运行应用。但是你仍然可以这样做，来看看在Kubemetes中应用是如何运行的。<br>你或许已经使用过Minikube来运行本书中的例子。尽管Minikube集群只运行一个工作节点，它也是在Kubernetes中尝试运行你的应用（以及开发组成完整应用的资源manifest）的一个有价值的方法。Minikube没有提供一个完整的多节点Kubernetes集群的功能，但是在大多数的场景下，这并不影响什么。<br>将本地文件挂载到Minikube VM然后再挂载到容器中<br>如果你正在使用Minikube进行开发，并且希望在Kubernetes集群中试验应用的每个更改，可以使用minikubemount命令将本地的文件系统挂载到MinikubeVM中，然后通过一个hostPath卷挂载到容器中。可以在Minikube文档中找到更多的使用说明，文档链接在ttp://github.com/kubernetes/minikube/tree/ master/docs上。<br>在Minikube VM中使用Docker Daemon来构建镜像<br>如果你正在使用Minikube开发应用，并且计划在每个更改之后都构建一个镜像，可以在Minikube VM中使用Docker Daemon来进行镜像构建，而不是通过本地的Docker Daemon构建然后再推送到镜像中心，最后拉取到Minikube VM中。为了使用Minikube 的Docker Daemon，只需要将你的DOCKER_HOST环境变量指向它。幸运的是，这个做起来实际上比听上去容易多了，只需要在本地机器上运行下面的命令：<br>$ eval$(minikube docker-env)<br>这个命令会帮你设置所有需要的环境变量，然后你就可以像Docker Daemon运行在你本地的时候那样构建镜像了。构建完镜像之后，不需要再去推送镜像，因为它已经存储在Minikube VM中了，这样新的pod就可以立即使用这个镜像了。如果你的pod已经在运行了，那么可以删除它们或者杀死容器让它们重启。<br>在本地构建镜像然后直接复制到Minikube VM中<br>如果你无法使用Minikube VM内部的Docker Daemon来构建镜像，这里仍然有方法来避免将镜像推送到镜像中心，然后使用运行在Minikube VM内部的Kubelet拉取镜像这样的流程。如果你在本地机器构建好了镜像，可以使用下面的命令将镜像直接复制到Minikube VM中：<br>$ docker save <image>| (eval $(minikube docker-env) &amp;&amp; docker load)</image></p>
<p>和之前一样， 这个镜像也可以在 pod 中立即使用了。 这里注意确保 pod spec 中的 imagePullPolicy不要设置为 Always， 因为这会导致从外部镜像中心拉取镜像， 从而导致你复制过去的镜像的更改丢失 。<br>将 Minikube 和 Kubernetes 集群结合起来<br>你在使用 Minikube 开发应用的时候几乎没有任何限制， 甚至可以将 Minikube集群和一个 Kubernetes 集群结合起来。 笔者有的时候在本地的 Minikube 集群运行开发中的服务， 然后让它们和部署在千里之外的远程多节点 Kubernetes 集群中的其他服务进行通信。<br>当笔者完成开发工作之后，可以几乎不用修改什么就将本地的服务迁移到远程集群中，并且由于Kubernetes 将底层基础框架的复杂性进行抽象和应用独立开来，所以运行过程也没有什么问题。<br>17.5.3 发布版本和自动部署资源清单<br>因为 Kubemetes 采用的是指令式模型， 你不必判断出部署的资源的当前状 态，然后向它们发送命令来将资源状态切换到你期望的那样。 你需要做的就是告诉 Kubernetes 你希望的状态，然后 Kubemetes 会采取相关的必要措施来将集群的状态  切换到你期望的样子。<br>可以将资源的 manifest 存放到一个版本控制系统中， 这样可以方便做代码审查，审计跟踪， 或者任何需要的时候回退更改。 在每次提交更改之后，可以使用kubectl apply 命令将更改反映到部署的资源中。<br>如果你运行了一个定时代理 （或者是代理检测到新的提交的时候） 来从版本控制系统（VCS）中检出资源 manifest， 然后调用 apply 命令应用更改， 那么你可以简单通过向VCS 提交更改来管理你运行中 的应用，这样就不需要手动和Kubernetes API 服务器进行通信了。幸运的是 Box 公司 （碰巧也是托管本书手稿和其他材料的地方）的人开发并发布了一个叫作 kube-applier的工具， 恰好可以用来完成笔者所描述的功能。这个工具的源代码在<a href="https://github.com/box/kube-applier上。" target="_blank" rel="noopener">https://github.com/box/kube-applier上。</a><br>你可以使用不同的代码分支来部署开发，测试， 预发布和生产集群等环境（或者是同一个集群中不同的命名空间） 下的资源 manifest。<br>17.5.4<br>使用Ksonnet 作为编写 YAML/JSON manifest 文件的额<br>外选择<br>我们在本书中已经看到了许许多多的 YAML 配置文件。对于笔者来说，编写 YAML 文件不是个大问题， 尤其是当你学会如何使用 kubectl explain 来查看</p>
<p>可用选项的时候，但是对于有些人来说却是个问题。<br>就在笔者完成本书的手稿的时候，一个新的工具Ksonnet发布了。它是基于Jsonnet开发的一个库，Jsonnet 是一个用来创建JSON数据结构的模板语言。它可以让你定义一些参数化的JSON片段，给这些片段起一个名称，然后通过名称来引用这些片段以构建一个完整的JSON配置文件，这样就不需要在多个地方重复编写相同的JSON代码了。这个过程很像你在编程语言中调用函数或者方法。<br>Ksonnet定义了Kubemetes中资源配置的片段，可以让你以很少的代码快速创建一个完整的Kubemets资源JSON配置文件。下面的代码清单展示了-个例子。代码清单17.10使用Ksonnet编写的kubia配置： kubia .ksonnet</p>
<p>上面展示的 kubia.ksonnet 文件可以通过下面的命令转换为一个完整的 JSON 格式的 Deployment配置文件：<br>$ jsonnet kubia.ksonnet<br>当你意识到可以自己定义高级别的片段， 并且让你的配置保持一致性和可复 用性的时候，你就会了解Ksonnet和Jsonnet的强大了。可以在<a href="https://github.com/ksonnet/ksonnet-lib" target="_blank" rel="noopener">https://github.com/ksonnet/ksonnet-lib</a> 上找到更多安装和使用 Ksonnet 和 Jsonnet的信息。<br>17.5.5 利用持续集成和持续交付<br>我们之前讨论过Kubemetes 资源的自动部署， 但是或许你希望能够建立一个完 整的CI/CD 工作流来构建应用的二进制文件、 容器镜像以及资源配置，然后部署到一个或者多个 Kubernetes 集群中。<br>可以在网上找到很多讨论这方面的资源。 这里特别向你介绍一个叫作 Fabric8 的项目(<a href="http://fabric8.io)，这是一个Kubemetes的集成开发平台。这个平台包括著名的自动化集成系统" target="_blank" rel="noopener">http://fabric8.io)，这是一个Kubemetes的集成开发平台。这个平台包括著名的自动化集成系统</a> Jenkins， 以及其他很多提供完整的 CI/CD 工作流的工具，这些</p>
<p>工具面向DevOps风格的开发、部署，以及Kubernetes上微服务的管理。<br>如果你希望构建自己的解决方案，建议你看看一个讨论这个话题的Google Cloud平台的在线实验室。它的地址在<a href="https://github.com/GogleCloudPlatform/" target="_blank" rel="noopener">https://github.com/GogleCloudPlatform/</a> continuous-deployment-on-kubermetes 上。<br>17.6<br>本章小结<br>希望本章的内容已经帮助你更加深入地了解了Kubermetes是如何工作的，并且能够帮助你自如地构建应用并部署到Kubernetes集群。本章的目标是：<br>，向你展示本书中覆盖的所有的资源是如何组织在一起，构成一个运行在Kubernetes上的典型的应用的。<br>。促使你思考很少在机器间进行迁移的应用和运行在pod中经常会被调度的应用之间的区别。<br>帮助你理解为什么拥有多组件的应用（或者微服务）不应该依赖具体的服务启动顺序。<br>·介绍init容器，它可以帮助你初始化一个pod或者延迟pod主容器的启动直到预置的条件被满足。<br>，讲解容器生命周期钩子并且应该在何时使用它们。<br>·对Kubermetes组件的分布式特性所引发的结果，以及Kubermetes的最终一致性模型进行深入的了解。<br>，学习如何在不断开客户端连接的情况下，妥善地关闭你的应用。<br>·给你几个让应用方便管理的小提示，包括控制镜像大小、给资源添加注解以及多维度的标签，以及方便查看应用终止的原因。<br>·讲解如何开发Kuberetes应用，以及如何在本地或者Minikube中运行，然后再部署到多节点的集群中。<br>在下一章，也是最后一章，我们将学习如何通过自定义的API对象和控制器来扩展Kubemetes，以及其他人是如何基于此在Kubernetes 上创建完整的平台即服务解决方案的。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes-in-Action/" rel="tag"># Kubernetes in Action</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/01/16-高级调度/" rel="next" title="16-高级调度">
                <i class="fa fa-chevron-left"></i> 16-高级调度
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/01/18-Kubernetes应用扩展/" rel="prev" title="18-Kubernetes应用扩展">
                18-Kubernetes应用扩展 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">什么是强迫自己？就是不想去干什么，就去干什么</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1017</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">72</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/04/04/结束语｜秒杀系统之上的业务协同思考/" title="结束语｜秒杀系统之上的业务协同思考" target="_blank">结束语｜秒杀系统之上的业务协同思考</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/14｜百万级流量秒杀系统的关键总结/" title="14｜百万级流量秒杀系统的关键总结" target="_blank">14｜百万级流量秒杀系统的关键总结</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/13｜优化番外篇：Vertx介绍及快速入门/" title="13｜优化番外篇：Vertx介绍及快速入门" target="_blank">13｜优化番外篇：Vertx介绍及快速入门</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/12｜高性能优化：单机Java极致优化/" title="12｜高性能优化：单机Java极致优化" target="_blank">12｜高性能优化：单机Java极致优化</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/11｜高性能优化：物理机极致优化/" title="11｜高性能优化：物理机极致优化" target="_blank">11｜高性能优化：物理机极致优化</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.2m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">124:29</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
