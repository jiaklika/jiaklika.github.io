<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第四章 日内各时段交易思路与策略]]></title>
    <url>%2F2021%2F03%2F14%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%97%A5%E5%86%85%E5%90%84%E6%97%B6%E6%AE%B5%E4%BA%A4%E6%98%93%E6%80%9D%E8%B7%AF%E4%B8%8E%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货日内短线复利密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章 日内短线出场技巧]]></title>
    <url>%2F2021%2F03%2F14%2F%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%97%A5%E5%86%85%E7%9F%AD%E7%BA%BF%E5%87%BA%E5%9C%BA%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 波浪理论对等出场技巧什么是波浪理论？美国证券分析家拉尔夫·纳尔逊·艾略特道·.斯工业指数平均进行研究，发现不在市场上这些形不断变化的股价结构性形态反映了自然和谐之美。定具有再现性。 出现的时间间隔及幅度大小并不一对此提出了一套市场分析理论，用一系列权威性的演绎法则来解释市场的行为，这就是久负盛名的艾略特波浪理论。在交易圈里有这么一句话：道氏理论告诉投资者何谓大海，而波浪理论指导你如何在大海上冲浪。 艾略特波浪理论股票技术分析的理论，在期货市场上一样适用。艾略特认为市场走势不断重复一种模式，每次上涨或下跌周期都是由5个上升浪或者5个下降浪完成的。这个理论的前提是：股价随主趋势运行时，依五波的顺序波动，逆主趋势运行时，则依三波的顺序波动。这句话怎么理解呢？说直白一点就是，如果顺大势的上涨，一般会有三波的上涨走势，那么三波上涨之后一般都会有两波下跌回调。 而且在这三波的上涨中，从起点涨到1的空间经常和从2涨到3以及从4涨到5的空间同等。但是一定要记住一点，无论是在股票市场还是期货市场中的多头或者空头行情，第三浪也就是第二波，在图8-1就是2-3这一波可能是最长的，即上升时升幅最大，下降时跌幅也最大，即使幅度不是最长的，也不可能是最短的。 图8-1 波浪理论的原理 接下来我们所要讲的波浪对等出场技巧，依据就是艾略特波浪理论，无论是在股票市场还是期货市场中的多头空头行情，三波上涨或者下跌的运行时间及上涨或下跌的幅度会趋于一致，如图8-2所示。 图8-2 菜粕1709合约2017年3月30日5分钟K线走势 在图8-2菜粕1709合约2017年3月30日5分钟K线走势中，价格从前期高点2365下跌到前期低点附近后没有再次下跌，行情开始进入了横盘整理，这个时候我们要做的一件事就是在横盘整理的上下沿各画一条水平线，当价格再次跌破横盘整理的下沿，我们要积极大胆进场做空。那么我们这次进场后的第一止盈点位在哪里呢？这个时候我们测量一下，从2365点下跌到横盘整理的下沿之间有多少个点位，比如是50点，那么这次下跌应该从上沿开始算起往下数50个点，就是这次盘整后再次下跌的第一目标点位。比如从这次横盘整理的上沿往下数50个点正好是2300点，那么假如我们进场时的点位是2340点，也就是说我们这笔空单进场后最低会有40个点的盈利空间。用艾略特波浪理论简单地去判断目标价位是非常可行的。但是记住，笔者现在教给大家的只是怎么通过波浪理论寻找第一目标价位，而不是这波行情的终点，如果是单边行情，有可能走出N波上涨或者下跌，接下来笔者会用均线系统给大家讲解如何把一笔单子拿到天荒地老。 波浪理论对等出场经典案例1解析： 在图8-3沪铜1705合约2017年3月30日5分钟K线走势中，价格经过了一个时期的盘整后上涨，上涨后又出现了横盘整理，此时我们第一时间要做的事就是画出这段盘整期间的上下沿，如图8-3所示。如果行情经过一段时间的横盘整理后再次上涨，那么这次上涨的空间基本和这段盘整前上涨的空间相等，但是任何事情都不是绝对的，期货市场中没有绝对一说。而且记住笔者现在讲的止盈方法是所谓的“第一止盈点”，也是说，如果我们进场完全可以用上面的方法判断一个初步的止盈点位，但并不是最终的止盈出场点，请大家清楚笔者的意思。 波浪理论对等出场经典案例2解析： 图8-4 黄金1706合约2017年3月28日5分钟K线走势 在图8-4黄金1706合约2017年3月28日5分钟K线走势中，价格在经过一轮下跌后，出现了横盘整理。横盘整理过后只要价格再次下，那么再可以利用期的E间基本和盘整前的下跌空间差不多，我们终这段下跌行个规律来判断我们的第一止盈点位。但是最点，我们接下来会给大家做一个讲解。 黄金分割线出场技巧什么是黄金分割线？黄金分割是一种古老的数学方法，其创始人是古希腊的毕达哥拉斯，他在当时十分有限的科学条件下大胆断言，如果一条线段的某一部分与另一部分之比，将1分割为0.618和0.382，那么，这样的比例会给人一种美感。后来，这一神奇的比例关系被古希腊著名哲学家、美学家柏拉图誉为“黄金分割律”。黄金分割的神奇和魔力，在数学界上还没有明确定论，但它屡屡在实际中发挥着意想不到的作用。0.618和0.382这两个神奇的数字后来被运用到期货行情分析中。 黄金分割线是在期货中最常见、最受欢迎的切线分析工具之，实际操作中主要运用黄金分割线来揭示上涨行情中的调整支撑位或下跌行情中的反弹压力位。不过，黄金分割线没有考虑到时间变化对期货价格的影响，所揭示出来的支撑位与压力位较为固定，投资者不知道什么时候会到达支撑位与压力位。因此，如果期货价将在顶部或底部横盘运行的时间过长，则其参考作用要打一定的折加，与江恩角度线相比略有逊色，但这丝毫不影响黄金分割线作为读用切线工具的地位 黄金分割线是利用黄金分割比率进行的切线画法，在行情发生转势后，无论是止跌转升或止升转跌，以近期走势中重要的高点和低点之间的涨跌额作为计量的基数，将原涨跌幅按0.236，0.382，0.5、0.618，0.809分割为5个黄金点，股价在反转后的走势将可能在这些黄金分割点上遇到暂时的阻力或支撑。黄金分割的原理源自非波纳奇神奇数字，即大自然数字， 0.618339 是众所周知的黄金分割比率，是相邻的菲波纳奇级数的比率，反映了菲波纳奇级数的增长，反映了大自然的静态美与动态美。据此又推算出0.236.0.382， 0.809等，其中运用最经典的数字为0.382，0.618黄金分割线为什么那么有效呢？因为它是世界上最美的比例关系，在市场中有极强的共识度。0.618， 0.5， 0.382分别代表的是强中、弱级别回调和反弹，这对于期货交易员来说是很有意义的。因此笔者的建议是，盘前、盘中、盘后都要经常画画黄金分割线和大势线，有助对行情的认识和理解。如果你对市场运用极其频繁且共识度的极高精准工具都置若罔闻，如果你对市场中运用黄金分割线描绘出来的高低点都置之不理，你将会失去很多机会，有可能你也将失去未来。 黄金分割线0.382是一种非常重要的分割线，能够为投资者提供不错的操作机会，帮助投资者提前一步发现潜在的盈利点，如果一波上涨中的回调跌破了黄金分割线0.382，那笔者就建议投资者此时应多单出场或者是减仓了，如果连0.618都跌破，那么不用在犹豫了，多单立马出局。做空则反之。 图8-5 螺纹1710合约2017年3月31日5分钟K线走势 在图8-5螺纹1710合约2017年3月31日5分钟K线走势中，价格一路上涨，如果此时我们持有多单，价格回落跌破这波上涨行情的38.2%，我们可以做出减仓的处理，比如你此时持有10手螺纹多单，当价格跌破这次上涨行情起点到最高点的38.2%时，我们可以平仓螺纹多单3-5手，当价格跌破这次上涨行情从起点到最高点的50%时，再平掉2-3手，也就是当这次上涨行情已经回落了50%，手上大部分的单子基本都已经出局了。如果价格再次跌破这次上涨行情从起点到最高点的61.8%时，剩余单子全部出局，这是根据黄金分割率的三个值来硬性分批出场。 在实际交易过程中，上涨行情一般回落到38.2%的时候这笔多单基本要出来50%-80%了，跌破50%后基本全部都清仓了，一般不会等到价格回撤到61.8%以下再出局。但是记住， 61.8%的跌破是这波多头行情终结的标志，一波上涨行情价格回落到61.8%之下，基本意味着这波上涨行情彻底结束。 黄金分割线出场经典案例1解析： 图8-6沪線1705合约2017年3月28日5分钟K线走势 在图8-6沪镇1705合约2017年3月28日5分钟K线走势中，我们发现先前的行情走势出现了急跌，然后出现了反弹，一般价格反弹到38.2%、S0%和1.8%附近都会受到这三个值的阻挡。在沪镍1705合约2017年3月28日5分钟K线走势中价格反弹到38.2%时明显看出受到了强烈的阻挡，一度围绕着38.2%附近进行多番争夺，当价格完全突破38.2时，我们此时应空单减仓。减仓多少完全看个人意愿，笔者基本上会把大部分都获利了结出局，留少量仓位即可。 黄金分割线出场经典案例2解析： 在图8-7玉米淀粉1709合约2017年3月23日5分钟K线走势中，价格经过了一波上涨后出现了回落，当我们发现价格跌破了38.2%，多单减仓，当价格跌破50%全部清仓出来。当价格跌破61.8%时也就意味着这波上涨行情彻底结束了。38.2%和50%这两个值对价格起到的支撑作用是非常强烈的，这两个值的失守，意味着空头能力较强。以上是根据黄金分割率的三个值为大家讲解了如何利用黄金分割率进行的出场，这是一个非常传统的山场方法。但是这里有的投资者会有一个疑惑，价格都回撤38.2%了再止盈出场是不是盈利回吐得太厉害了？所以现在的黄金分割率在原有的基础上围绕着0.382和0.618这两个重要的值发生了各种变化，从而衍生出其他的数字，如1.618，2.618， 0.236.…其中23.6%在我们实际交易中也起到类似于38.2%、50%、61.8%这三个值对价格支撑和阻挡的作用，如图8-8所示。|沪铝1706 （010106）5分0.00% 1484514800 图8-8沪铝1706合约2017年4月20日5分钟K线走势 在图8-8沪铝1706合约2017年4月20日5分钟K线走势中，当一波行情上涨后出现了回落，价格跌破黄金分割率的23.6%之后我们就可以做出减仓的动作。其实在实际交易中，到底是选择23.6%还是选择38.2或者是50%甚至是61.88出场，并没有一个固定的模式。具体选挥哪个值作为自己出场的依据，完全取决于每个投资者的心理承受能力。 例如，交易者A有100万本金用10万资金买了N手沪铝1706，交易都只有10万本金，也用10万资金买了N手沪铝1706，交易者C只有3万本金去配资公司配到7万，也是10万资金买了N手沪铝1706。 同样都是10万资金，但是三个人的心理承受能力却不同，交易者A本金大，根本不在平10万资金，他可能对行情回调的心理承受能力大得多，可能价格回落到50%左右再出局，交易者B全部家当只有10万本金，那他最大的心理承受能力可能只能到38.2%了。交易者C只有本金3万，其余的7万都是在配资公司配的，他的心理承受能力应该是最差的，没有那么大的底气承受太大的回撤，那么他的这笔多单回撤的底线可就是23.6%。笔者这么一比喻大家就明白了吧？每个投资者的期货资金在全部资金的占比不同，就会导致每个投资者对行情回撤的心理承受底线不同。 其实，这个和止损的大小是一样的道理。资金大、仓位小，止损自然就放得大一些，资金小、仓位重，止损自然会小很多了。在平时的交易中投资者如果用黄金分割率的值去做止盈或者止损的话，笔者建议用23.6%和38.2%已经足够了。 破均线出场技巧期货行情的走势看似杂乱无章、没有任何规律，但是请大家记住一点，宇宙万物都有它们自己的特定规律，期货交易不单单要凭技术和运气，更需要有一盏明灯为我们指引方向，而移动平均线的走势就是我们手中的这盏明灯。 因为移动平均线的走势是综合因素的集成和简化，它包含了对应时间段内的一切信息。为此，看移动平均线就能把握主力方向的脉搏，用好了移动平均线，你就牵住了趋势的牛鼻子。20日均线是期货市场往前20天的平均收盘价格，其意义在于它反映了20天的平均成本，有人称它为“操盘线”。也就是说，很多人通过20日均线来进行买卖。笔者这里就不用过多的篇幅来讲解了，根据它进场的方法，这里主要给大家讲解如何通过20日均线来进行获利了结。如图8-9所示。 图8-9沪铝1706合约2017年3月近期5分钟K线走势，上涨行情中如果我们持有多单，只要价格回落跌破20日均线（圆圈处），我们就可以对手上的多单进行减仓或者清仓处理。下跌行情中如果我们持有空单，只要价格反弹到20日均线（方框处）以上，我们就可以对手上的空单进行减仓或者清仓处理。我们可以用这种方法把手上的多单或者空单的盈利空间尽量最大化。 图8-9 沪铝1706合约2017年3月近期5分钟K线走势 破均线出场经典案例1解析：图8-10螺纹1710合约2017年3月近期5分钟K线走势，价格从3111这个点位开始上涨，只要价格不跌破20日均线我们就一直持有这笔多单。当价格回落跌破了20日均线（圆圈处），我们就可以选择出部分仓位，或者全出。 图8-10 螺纹1710合约2017年3月近期5分钟K线走势 图8-11 玻璃1705合约2017年3月近期5分钟K线走势 图8-11玻璃1705合约2017年3月近期5分钟k线走势，无论此时我们是多单还是空单，如果做多单，那么当价格跌破20日均线（圆圈处）我们多单止盈出场，如果做空单，那么当价格突破20日均线（方框处）我们空单止盈出场。 20日均线被称为“生命线”， 20日均线向上， K线在20日均线上方运行，此时如果我们有多单，无论K线怎么走，多单都是安全的相反20日均线向下， K线在20日均线下方运行，我们此时如果有空单，无论K线怎么走，我们的空单都不会有太大的风险。 20日均线在行情中对价格有一个吸引的作用。在多头行情中，K线就是依附在20日均线向上攀爬。偶尔跳空上冲，但终究还要回来。所以20日均线附近是很好的加仓点。跌破20日均线是一个非常好的出场点。高手通常都是埋伏这里，只有新手才会追在远离20日均线的高点上。在空头行情中， K线就是在20日均线的下方向下运行。远离20日均线下跌太多时，就会发生反弹，此时，当价格反弹到20日线附近是最好的加仓点。当我们发现K线与20日均线反复穿插纠缠的时候，你就会失去方向感，如图8-12所示。 商品加期回 图8-12 沪铝1706合约2017年4月20日5分钟K线走势 在图8-12沪铝1706合约2017年4月20日5分钟K线走势中，当我们发现K线与20日均线反复穿插纠缠的时候（圆圈处），我们就应该知道目前的沪铝1706合约5分钟K线走势中行情失去了方向。20日均线在低位开始走平时，空单随时打算获利了结，当20日均线在高位开始走平时，多单就要警惕了，当发现价格跌破20日均线时，多单立即出场。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货日内短线复利密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 日内短线交易高胜算空单进场方法]]></title>
    <url>%2F2021%2F03%2F13%2F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%97%A5%E5%86%85%E7%9F%AD%E7%BA%BF%E4%BA%A4%E6%98%93%E9%AB%98%E8%83%9C%E7%AE%97%E7%A9%BA%E5%8D%95%E8%BF%9B%E5%9C%BA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 断头铡刀做空技巧断头铡刀的形态是，一根大阴线将短期均线（5日均线）、中期均线（10日均线）、长期均线（30日均线）从上往下完全击穿。断头铡刀形态多出现在价格的顶部或阶段性顶部，是一种典型的卖出信号。该形态具有爆发突然、下跌迅速等特点。笔者参加历届实盘大赛多次获奖，经常用的做空手法就是这个断头铡刀，而且屡试不爽，经常能拿到大的盈利，并且获得好的名次。 当我们发现价格在高位盘整后渐渐下滑，此时5日、10日和30日均线形成的均线系统呈现收敛状态。此时如出现一根阴线从上往下拦腰斩断三条均线，形成一阴断三线的“断头铡刀”，则应警惕可能会有一波下跌行情的出现。特别是带有较大成交量的阴线，则更有下跌的可能，如图7-1所示。 在图7-1黄豆一号1705合约2017年3月29日5分钟K线走势中，我们看到5日、10日和30日均线形成的长中短期均线系统开始收敛，此时出现了一根阴线从上往下拦腰斩断三条均线，这根阴线就是我们要找的断头铡刀做空进场点，当这根断头铡刀走完后，只要价格能站在断头铡刀的下方，我们就可以依据这根断头铡刀的阴线进场做空，如果断头铡刀出现的同时有量能的配合就更好了。但是在做空的行情中有时也可以做到无量下跌，不要一味追求它的完美性。在任何下跌行情中进场做空单，都不用太过在意量能的配合。当然，有量能的配合肯定比没有的效果和动能要好很多。 图7-1 黄豆一号1705合约2017年3月29日5分钟K线走势 这个断头铡刀的进场方法一定要练熟，它和做多行情的“一箭三雕”是姊妹篇，但是要比做多行情的“一箭三雕”胜算大很多，一般空头行情启动后比较流畅，如瀑布一样行云流水，短时间就能下跌很大的空间，而多头行情经常是三步一回头，走势比较黏，可能多头行情走一天的空间还不如空头行情5分钟下跌的空间大，所以笔者做期货17个年头，基本是以做空单为主，大部分盈利都是在空单中产生的。 断头铡刀做空经典案例1解析： 在图7-2玉米淀粉1709合约2017年4月6日5分钟K线走势中，我们看到5日、10日和30日均线形成的长中短期均线系统开始收敛，最后绞在一起，而且此时的价格波动也越来越窄，基本是没了方向的横向运行。当我们发现某天某一品种合约的走势出现上述情况，我们就要留意了。此时如出现一根阴线（圆圈处）从上往下拦腰斩断三条均线形成一阴断三线的“断头铡刀”，只要价格收在了这根断头铡刀下方我们就可以积极进场做空。一般在出现断头铡刀时都会出现一波很大的下跌行情。断头铡刀前期盘整的时间越久，则这次断头铡刀后的下跌空间就越大。特别是带有较大成交量的断头铡刀，下跌的可能和空间会更大。 图7-2 玉米淀粉1709合约2017年4月6日5分钟K线走势 断头铡刀做空经典案例2解析： 在图7-3沪锌1706合约2017年4月6日5分钟K线走势中，断头铡刀前期的行情算是一个震荡上行的走势，这是典型的上涨行情特征，不温不火地往上爬，这也是笔者不喜欢做多的主要原因，走势拖泥带水，走一天可能都涨不了几个点，分分钟钟一根大阴线跌回起点。此时5日、10日和30日均线形成的长中短期均线系统开始收敛，突然一根阴线从上往下拦腰砍断5日、10日和30日均线形成的长中短期均线系统，断头铡刀出现的同时我们还发现下面的成交量急剧放大，只要断头铡刀过后，价格能站在这根阴线之下，此时就是一次绝佳的进场做空的机会，我们一定要第一时间进去，大胆进不要犹豫，如果大势也比较配合，那么我们就更应该毫不犹豫地进场。机会来了不能等，机会错过不能追。一定要明白这个道理，机不可失，时不再来。 图7-3 沪1706合约2017年4月6日5分钟K线走势 断头铡刀在实际行情中非常多，而且在任何品种的任何周期都适用，并且几乎天天都会出现，只要大家能够用心去学去用，哪怕只学会这一招都会让你屡试不爽，稳定获利。图7-4是一天中出现的断头铡刀部分品种的图例，供大家学习参考。 断头铡刀做空经典案例3解析： 图7-5是2017年3月30日一天国内商品期货中的四个品种出现断头铡刀的实例，其实，如果你用心去找，用心去学，几乎每天都会发现很多如图7-5的翻版，只要我们发现它，然后第一时间进场就行了，长期去做基本可以稳定获利，前提是必须发现就进，不犹豫，不手软，我们对验证可行的交易方法一定要有足够的信任，这样才能做好期货。期货就是“简单的动作，不断正确重复的过程”，交易期间尽量克服人性的弱点，把自己看作一个机器就好了，出现特定的进场图形，机械地进场即可。 金牛断角做空技巧我们之前讲了金牛断角做多的技巧，下面再给大家讲一下金牛g断角做空的技巧，顶部的K线反转形态中我们知道得最多的可能就g是双顶了，双顶俗称M头，它是当价格在某时段内连续两次上涨至相同高点而形成的走势图形。当出现双顶时，通常是上涨行情转为下跌行情的一个信号。金牛断角做空技巧是一个双顶的变异，但是它的信号强度要明显大于双顶。双顶是第二次的高点涨到第一次的高点附近，形成两个价位相同的一个形态，而顶部的金牛断角是第二个高点还没涨到前期的高点附近就出现了拐头向下的走势，这个拐头处通常会出现典型的K线反转组合的配合，比如射击之星、黄昏之星、顶部的穿头破脚阴线、倾盆大雨、好友反攻等。从金牛断角的形态上我们就能看出，多头主力打算再次上涨，但是量能明显不足，价格还没涨到前高附近就被空头打压下来，如图7-6所示。 图7-6 PTA1709合约2017年3月30日5分钟K线走势 在图7-6PTA1709合约2017年3月30日5分钟K线走势中，我们看到前期价格一度上涨到5106后出现回落，当价格再次上涨时还没涨到前期高点5106附近，就出现了典型的顶部K线反转组合，即两阴夹一阳。两阴夹一阳是由三根K组成的K线组合。第一根k线和第三根K线为阴线，第二根k线为阳线。阴k线实体要略长一些。处在高位的两阴夹一阳，阴线的开盘价和阳线的收盘价接近。高位的两阴夹一阳属于卖出信号。尤其处于顶部的两阴夹一阳是很重要的卖出信号。所以当行情再次上涨且还没涨到前期的高点附近就拐头向下，并且出现了典型的顶部K线反转组合时，我们应该坚决做空。 金牛断角做空经典案例1解析： 在图7-7[C1704合约2017年3月29日5分钟飞线走势中，我们看到多头打算再次上涨，但是还没涨到前期的高点就出现了典型的一个变异的顶部K线反转组合黄昏之星（圆圈处），我们就可以这个金牛断角中的黄昏之星为依据进场做空。大家一定要记住，在我们日常 图7-7 1C1704合约2017年3月29日5分钟K线走势 既然这里涉及黄昏之星，那么笔者就给大家简单地讲解一下。 黄昏之星形态是由一根阴线和一根阳线中间夹着一个十字线三根k线组成，其形态和早晨之星刚好相反，价格上涨过程中，顶部出现一根长长的阳线，第二根为向上跳空小实体线（或十字星），第三根是一根阴线，且收盘价显著地向下，则形成黄昏之星，黄昏之星被视为见顶反转的信号。 黄昏之星的走势意味着上涨行情的结束，行情开始见顶回落，所以第一根线必须是阳线，承接前面的涨势，而第三根线必须是阴线，表明下跌行情开始，而中间的那一根K线可以是阳线，也可以是阴线。当第三根K线收盘价超过第一根K线实体的一半以上时，黄昏之星的见顶反转信号更加强烈，黄昏之星和早晨之星是“姊妹”。 图7-8 PTA1705合约2017年3月30日5分钟K线走势 在图7-8PTA1705合约2017年3月30日5分钟k线走势中，价格涨到5020高点后出现回落，经过了一个短暂的整理再次上涨，价格还没达到前期的高点5020附近就出现了典型的顶部K线反转组合穿头破脚（圆圈处），我们就可以穿头破脚为依据进场做空。 穿头破脚形态是，价格上涨（下跌）时，第二根K线将第一根K线从头到脚全部穿在里面了。穿头破脚分为顶部穿头破脚和底部穿头破脚，穿头破脚是阳包阴和阴包阳的一种特殊形态，它只针对相邻两根K线的包含来定义。顶部穿头破脚是在上升趋势中出现。第二根K线，即阴线的长度必须足以吞掉第一根K线，即阳线的全部（上、下影线不算）。 顶部长阴做空技巧顶部长阴线的特征是几乎以最高价开盘、最低价收盘，顶部长阴线的力度大小与其实体长短成正比，即阴线实体越长，则力度越大；反之，则力度越小。顶部长阴线的出现对多方行情来说是非常不利的。顶部长阴线通常发生在上升趋势末期，是空头量能在高位重创多头的典型标志，也可能是多头主力在行情顶部大量获利了结的结果。如果这根大阴线与其之前的K线构成某种看跌型K线组合，则顶部反转信号更加可信。 在图7-9沪铅1705合约2017年3月29日5分钟K线走势中，价格一度上涨到历史的高点17700，之后突然出现一根顶部长阴线，我们可以这根顶部长阴线为依据进场做空，当然，这根顶部长阴线实体越长，行情由多转空的可能性越大。在顶部的大阴线运用中，可以忽略掉影线，我们只留意顶部长阴线的实体即可，当然不是说顶部长阴线的影线毫无技术含义，只是在这里笔者暂时不做太多的讲解，以后会针对裸K线交易技巧为大家做深度技术讲解。 顶部长阴做空经典案例1解析： 图7-10 L1705合约2017年3月30日5分钟K线走势 在图7-10L1705合约2017年3月30日5分钟K线走势中，这根顶部长阴线是开盘5分钟K线走势行情里的第一根线，属于一个高开急跌行情。类似于这种行情，开盘后先一根长阴线开局，然后多头基本毫无反抗能力，只要这根顶部长阴线走完后多头无法收复失地，我们就可以这根开盘顶部长阴线实体低点为依据进场做空。 图7-11 PVC1705合约2017年3月30日5分钟K线走势 在图7-11PVC1705合约2017年3月30日5分钟K线走势中，同样是开盘后第一根K线就是顶部长阴线，这种开盘方式是非常好应对的，也是在开盘后两三根K线进场的方法之一。开盘即出顶部长阴线，只要接下来的价格能收在这根顶部长阴线实体下方，我们就可以依据这根顶部长阴线进场做空。 记住一点，这根顶部长阴线一般都比前期行情走势中的K线整体要大两倍以上，三倍以上的顶部长阴线更有杀伤力。大阴线代表空方占据绝对优势，空方向多方疯狂攻击，多方溃退。如果最高价接近开盘价及最低价接近收盘价，即光头光脚顶部长阴线，说明力道非常强大，市场供求失衡，导致多头疯狂出逃。 在一波拉升行情的后期，即波段顶部出现顶部长阴线，是价格波段见顶的重要特征之一，价格反转下行的概率极大。顶部长阴线形成后，如果多头不能在短时间内收复失地，也就是向上攻击时不能有效收复顶部长阴线的开盘价，价格则会就此展开一轮疯狂的下跌。 水下死叉做空技巧之前为大家讲解了水上金叉做多技巧，下面为大家讲解它的姊妹篇水下死叉做空技巧。使用方法正好和水上金叉做多技巧相反，但是记住一点，任何做多、做空都适用的进场方法，空单的胜算和获利空间普遍大于多单。 在图7-12棕桐油1709合约2017年3月30日5分钟K线走势中，我们看到在5分钟k线走势，30日均线的方向已经倾斜向下了，这时候我们可以通过30日均线的方法简单判断目前是多头行情还是空头行情，当我们发现30日均线倾斜向下运行，此时的交易思路就是逢高沽空为主，切勿抄底。 方法确定了之后就要找精准的行情启动点了，这时当我们发现MACD在零轴下交死叉的同时， K线中的短期均线由上往下下穿长期均线，这个下穿可以有多种组合，比如5日均线下穿10日均线、5日均线下穿30日均线、10日均线下穿30日均线，或者5日均线和10日均线同时下穿30日均线都可以。此时就是我们进场做空的最佳时机。 图7-12 棕桐油1709合约2017年3月30日5分钟K线走势 水下死叉做空经典案例1解析： 在图7-13豆油1709合约2017年3月29日5分钟K线走势中，我们先是发现了30日均线的运行方向，也就是我们做单的方向后，开始等待机会的来临。此时MACD零轴下交一死叉，几乎同时上面K线中的均线也出现了死叉。大家发现没有，在K线走势中价格一度向上突破了30日均线，一般下降行情中的30日均线被突破是行情由空转多的信号，但是突破后短时间又回到30日均线之下的这种情况，就应了期货里的一句话：“假突破防真跌破。”这种假突破反而加大了行情再次下跌的可能性。此时当MACD和均线同时出现死叉，就是我们进场做空的一次绝佳时机。 水下死叉做空经典案例2解析： 在图7-14油1709合约2017年3月30日5分钟K线走势中，30日均线倾斜向下，先让我们确定了做单的方向。这次先是K线图中的5日均线和10日均线在30日均线下出现了一个死叉后，下面的MACD才在零轴下交死叉，我们等MACD交死叉后立马进场做空即可。水下死叉做空技巧是一个顺势交易的方法，胜算非常大，不用太过犹豫。 图7-15 沪铝1706合约2017年4月14日5分钟K线走势 水下双死叉升级版水下三死进场做空技巧经典案例解析： 在图7-15沪铝1706合约2017年4月14日5分钟K线走势中，当茫图中的均线、随机指标KD中的K值和D值，以及MACD几乎同时出现死叉时，如果此时日线上的30日均线也是倾斜向下的，也就是大趋势也为下跌趋势，我们日内就可以通过三死叉大胆进场做空，顺势交易才能加大我们的胜算。 同样这个三死叉进场做空的技巧我们也把它在交易软件中编写出来了，只要把编写好的指标导入我们的交易软件中，当主图中的均线、随机指标KD中的K值和D值，以及MACD同时出现死叉时，并且价格能站到5日均线下，我们的软件中就会出现提示“三死做空”的进场信号，如图7-16所示。 在图7-16黄豆一号1709合约2017年3月30日5分钟K线走势中，主图中的均线、随机指标KD中的K值和D值，以及MACD同时出现死叉时，并且价格能站到5日均线下，交易软件上就立刻跳出四个字“三死做空”。这样的提示大大节省了广大投资者的看盘及分析时间，可以做到轻松交易，事半功倍。 这个指标也是我们公司操盘手经常用的，笔者在这儿声明一下，任何指标公式都不可能达到百分之百的成功率，但笔者保证如果你每次都严格按照信号提示进场做单肯定赚钱。希望大家不要只用这一个指标来进出场，还要结合其他自己熟悉的指标共振买入，这样可以过滤掉很多的假信号。如果期望值过高的投资者请不要索取，请大家理性参考指标，盈亏自负。 以逸待劳做空技巧大家还记得笔者之前讲过多空一线做多技巧吗？以逸待劳做空技巧就是多空一线做多技巧的姊妹篇。还记不记得笔者曾经讲过的一波完美的上涨行情是什么样子吗？任何一波完美的上涨中的回调，一般都不会回调到前期高点的下方，即使跌破了前期高点也会在很短的时间就回到前期高点之上，如果跌破前期高点长时间回不到前期高点之上，那么行情有可能真的就上不去了。一波比较流畅的上涨通常是价格上涨、回调到前期的高点附近、受到前期高点的支撑再次借力上涨。 图7-17甲醇1705合约2017年4月5日5分钟K线走势 这个道理在上涨行情中适用，在下跌行情中也同样适用，但它们也有点不同，不同点在哪里呢？上涨行情一般比较黏，怎么理解笔者所说的这个“黏”呢？就是行情上涨通常是“三步一回头式”的上涨，同样是100个点，如果上涨需要1个小时，下跌可能几分钟就搞定了，在上涨行情中通常每次上涨后的回调都要寻找一个支撑点，比如我们之前讲的多空一线做多技巧。而下跌行情很多时候是下跌后的反弹经常反弹不到一个阻力位就开始了新一轮的下跌，而且下跌走势通常非常流畅，行云流水，这也是笔者为什么做单偏向做空的原因，历届实盘大赛或者指导学员实盘大赛能让资金翻倍的单子基本都是空单做出来的。 在图7-18白银1706合约2017年3月30日5分钟K线走势中，我们发现前期出现了两个低点，大家一定要记住，在实际行情中，价格多次跌到一个点位下不来，就意味着这个点位在实际行情中的支撑作用非常大，一旦这个点位被跌破，那么它就不再起到支撑的作用了，而是由原来的支撑变为阻挡。那么当价格反弹到白银1706合约2017年3月30日5分钟K线走势中前期两个低点附近时，都会受到这两个低点的阻挡。所以我们在实际行情中就可以通过行情前期低点为依据来进场做空。这种做空的方法也是非常稳妥的，而且是顺势行情，胜算也非常大，它的胜算大于多空一线做多技巧，可大胆进场交易。 以逸待劳做空经典案例1解析： 在图7-19黄金1706合约2017年3月30日5分钟K线走势中，当日的行情开盘低开低走后，多头进行了多次上攻，但每次反弹到前一日的低点附近上不去，也就意味着前一日的低点作为阻力位的作用非常强烈。只要价格上不去前一日的低点，每次反弹到前一日的低点受到阻挡都是一次进场做空的机会。记住一点，如果我们空单已经进场，只要价格不突破前期高点就一直持有这笔空单，只有价格彻底突破了前一日的低点之后，我们才能从形态上认为这次进场做空的机会失败了，这时我们要毫不犹豫的空单止损出局。 以逸待劳做空经典案例2解析： 图7-20 豆油1709合约2017年3月29日5分钟K线走势 在图7-20豆油1709合约2017年3月29日5分钟K线走势中，我们看到价格曾经三次到一个低点（圆圈处）无法跌破，也就意味着这次跌到的低点对价格下跌起到了强烈的支撑作用。一旦这个重要的支撑位被跌破，它原来起到的支撑作用就转变为阻挡作用了。那么就变成了价格涨到这个点位的时候，这个点位会起到阻挡价格上涨的作用。 这个案例中，价格曾经一度涨到了前期的低点上方，但是没能站稳就被空头又打了下来。我们之前讲过的那句话还记得吧？突破防真跌破。”当我们发现价格涨到了前期的低点压力位后，短时间内又回到了前期的低点下方的时候，就是我们进场做空的最佳良机。 空头行情中途进场技巧在讲空头行情中途进场技巧之前，我们先要知道怎么确定现在的行情是空头行情，我们在讲多头行情中途进场技巧中已经讲过了如何判断确定多头行情，在这里笔者再简单地给大家讲一下空头行情如何分辨。 所谓空头行情，就是在行情中两个以上的高点不断下移，这两个高点的连线我们称为“下降趋势线”。下降趋势线的主要功能在于能够显示出期货价格下跌过程中阻力位，当我们发现一波行情的高点不断下移，那么就认为此时的空头行情已经开始了，如图7-21所示。 图7-21 棕榈油1709合约2017年4月18日5分钟K线走势 在图7-21棕桐油1709合约2017年4月18日5分钟K线走势中，当发现在行情走势中出现了两个阶段性的高点时，我们要第一时间在这两个高点（前两个圆圈处）之间做一个连线，这条连线就是我们上面所说的“下降趋势线”。下降趋势线的作用就是价格向其固定方向移动时，它非常有可能沿着这条下降趋势线移动。当价格反弹到趋势线附近时（最后一个圆圈处），经常是受到这根下降趋势线的阻挡而迎来新一轮的下跌行情。如图所示，现在价格又反弹到了下降趋势线附近，那么它接下来的方向很大概率是受到这条下降趋势线的阻挡再次奔着箭头的方向跌下去。 还有一种更简单的判断空头趋势的方法：看行情中30日均线的运行方向，如果开口向下，那么我们就可以判断目前的行情为空头行情，我们所讲的空头行情中途进场技巧，就是根据30日均线在行情中的表现来进场的，如图7-22所示。 图7-22玉米淀粉1709合约2017年3月29日5分钟K线走势 在图7-22玉米淀粉1709合约2017年3月29日5分钟K线走势中，当看到30日均线向下角度运行时，我们就可以判断目前的行情为空头行情，这个时候只要出现了价格反弹（圆圈处），受到了5日、10日、30日均线中任何一条均线的阻挡后，重新收在了5日均线之下就是一次空头行情进场的绝佳时机。 记住一点，只要价格不突破30日均线，每次反弹到任何一条均线附近又回到5日均线下，都是一次进场做空的绝佳机会，这个时候千万不要害怕价格是不是到底了，无论期货市场还是股票市场都有这么一句话： “熊市不言底，牛市不言顶!”只要价格不突破30口均线就意味着空头行情存在。利用30日均线空头行情中途进场技巧的要点就是，30日均线的方向判断空头趋势是否存在，价格回落到5日均线之下是进场依据。即使价格短暂地突破30日均线，只要能短时间内回到5日均线下都可以进场做空。 图7-23棕榈油1709合约2017年3月30日5分钟K线走势 在图7-23棕桐油1709合约2017年3月30日5分钟k线走势中，根据前期走势和30日均线的运行方向我们已经能看出来当前的行情是下跌趋势，此时价格出现了一个横盘中的反弹，上涨到30日均线附近后其阻挡再次下跌，当价格再次跌到5日均线下的时候就是一次进场做空的机会。如果棕榈油1709合约2017年3月30日日线的走势也是下跌趋势，那么当日做空将会有一次不错的收益，大胆进场，机不可失，时不再来。 空头行情中途进场经典案例2解析： 在图7-24沪铅1705合约2017年3月27日5分钟K线走势中，30日均线已经倾斜向下运行了，价格反弹到10日均线附近就上不去了，大家记住一点，这种趋势已经明朗的行情，价格反弹到10日均线受到阻挡后的再次下跌，要比价格反弹到30日均线受到阻挡后的再次下跌更具杀伤力，而且是顺势的单子，如果打算日内交易的话，仓位重一点没事，笔者曾经遇见这种趋势非常明显的行情，在胜算非常大的进场点满仓过。但是大家要明白，无论你仓位有多重，到了止损点位一定立马出场，做期货该胆大的时候就要胆大，该保守的时候就要保守，这样才能赚到钱。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货日内短线复利密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章 日内短线交易高胜算多单进场方法]]></title>
    <url>%2F2021%2F03%2F13%2F%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%97%A5%E5%86%85%E7%9F%AD%E7%BA%BF%E4%BA%A4%E6%98%93%E9%AB%98%E8%83%9C%E7%AE%97%E5%A4%9A%E5%8D%95%E8%BF%9B%E5%9C%BA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 一箭三雕做多技巧一箭三雕，俗称一阳穿三线，往往以为着多方强势非常明显，尤其是一根带量的阳线，从下往上一举突破由5日、10日、30日均价线组成的短中长期均价线系统。具体特征是价格经过下跌和充分整理后，均价线系统的下跌斜率开始趋缓，并逐渐靠拢，价格波幅日益收窄，突然一根放量阳线向上同时突破5日、10日、30日均线，且收盘在30日均线上方。这种情形大有过五关斩六将的气概，是典型的上升信号。这是主力展开大反攻的突出标志，做多意图明显，是一次难得的进场良机（图6-1）。 这里总结一下进场要领：（1）一根阳线从下往上上穿5日、10日、30日短中长期均价线系统。 （2）上穿的同时一定要有量能的配合。 （3）上穿后价格站上5日均线。 在图6-1沪锌1705合约2017年3月30日5分钟K线走势中，我们看到一根5分钟K线从下往上一举突破由5日、10日、30日均价线组成的短中长期均价线系统，同时下面的成交量急剧放大，在日常行情中，只要同时出现这两个特征就意味着一箭三雕做多的时机出现，之后行情企稳，可大胆进场做多。还有就是要顺势交易，否则也很难成功。 图6-1 沪锌1705合约2017年3月30日5分钟K线走势 一箭三雕做多经典案例1解析： 在图6-2橡胶1709合约2017年3月30日5分钟K线走势中，价格也出现了下跌后的横盘震荡，行情横盘整理的特征在之前的章节中笔者都做了讲解，希望大家能够吸收掌握，这里就不做过多的讲解了。这时出现了一根5分钟K线从下往上一举突破由5日、10日、30日均价线所组成的短中长期均价线系统，并且下面的成交量能够配合地放大，这里所说的放大是和盘整期间的成交量相比较而言的。如果这根K线走完后价格能够企稳，我们就可以积极进场做多，但还是要记住顺势操作。 图6-2 橡胶1709合约2017年3月30日5分钟K线走势 一箭三雕做多经典案例2解析： 在图6-3沪锌1705合约2017年3月30日5分钟K线走势中，同样出现了一根5分钟K线从下往上一举突破由5日、10日、30日均价线组成的短中长期均价线系统，并且下面的成交量出现了巨量，随后行情企稳在5日均线上，这时我们就可以立即进场做多。这种一阳穿三线的信号，可以出现在下跌行情的末端，也可以出现在上涨行情的中途，出现在上涨行情中途比出现在下跌行情末端其可靠性强很多，而且更容易成功。 图6-3 沪锌1705合约2017年3月30日5分钟K线走势 一箭三雕做多失败案例解析： 通过图6-1至6-3，分别给大家讲解了一箭三雕做多的技巧。下面通过一个案例和大家一起分析一个一箭三雕做多失败的情况，总结它失败的原因到底在哪里。 在图6-4棕榈油1709合约2017年3月29日5分钟K线走势中，我们看到一根5分钟K线从下往上一举突破由5日、10日、30日均价线组成的短中长期均价线系统，但是下面的成交量却不能有效地放大，如果我们遇见这种成交量和行情不能匹配的情况，即使价格企稳在5日均线上也很难走出上涨行情。任何做多的信号如果没有量能的配合基本都走不出流畅的上涨行情，即使上涨也是昙花一现，很难持续。 一箭三雕做多买卖提示指标公式： 为了广大投资者能更好地识别一箭三雕的进场买卖提示信号，笔者特意为大家在博易大师和文华财经看盘软件上编写了这个买卖提示指标公式，有了这个指标操作就更简单了。只要符合一箭三雕的条件，我们看盘软件上就会第一时间出现代表买入的红色箭头，甚至可以做出预警提示。当我们发现看盘软件上出现了红色的箭头，就知道目前的行情走势出现了符合一箭三雕的条件，可以积极买入，不会错过了进场的最佳时机。 金牛断角做多技巧底部长阳做多技巧水上双金叉做多技巧多空一线做多技巧多头行情中途进场技巧]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货日内短线复利密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 期货交易的几大类型]]></title>
    <url>%2F2021%2F03%2F09%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9C%9F%E8%B4%A7%E4%BA%A4%E6%98%93%E7%9A%84%E5%87%A0%E5%A4%A7%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货日内短线复利密码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十章 我是如何应用蜡烛图的]]></title>
    <url>%2F2021%2F03%2F06%2F%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%E8%9C%A1%E7%83%9B%E5%9B%BE%E7%9A%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“狡兔三窟”。 下面介绍的实例，是我在一个多月的时间中为梅里尔.林奇系统提供的一部分交易建议。在所有这些实例中，均或多或少地涉及到了蜡烛图技术。因为我研究的是期货市场，所以本章列举的实例以期货市场为取向。另外，我侧重于短期的市场分析，因此，这些实例都是从日内图表和逐日图表中采摘的。每位市场参与者都有自己独特的交易风格。您的交易方式不会等同于我的交易方式。所以在这些实例中，我并不指望您会经历与我一样的思考过程，或者采取与我相同的行动。 本章的目的，不是要为您提供一大套交易规则，其主旨是说明如何将蜡烛图技术融合到自己的交易方法之中。我希望通过这一章的示范。能够起到抛砖引玉的作用，促使您开步前进，走上将蜡烛图技术同自己的市场研究相结合的道路。 如图20.1所示，市场在 5月 29日向下跌破了一个头肩形形态的颈线。于是，市场趋势转而向下，根据西方技术分析理论，一旦某个头肩形形态的颈线被向下突破了，那么我们预期，首先有一个回向颈线的反扑过程然后，市场再恢复向下的压力。在6月11日所在的一周，市场便处在向上趋近这条颈线的过程中。6月11日，是一根坚挺的白色蜡烛线。在这一点上，卖出做空的主意并不大有说眼力。我需要证据，说明当前的上涨行情已经步入困境。下一天，是一根小的黑色实体，市场凭着这根蜡烛线发出了遇到麻烦的暗示。这就标志着前一天坚挺的白色蜡烛线可能难以为继了。 6月13日，我建议在6.27美元的水平卖出做空。其止损水平设置在颈线上方的6.35美元。我们的价格目标是 5.90美元（这是根据当年早些时候形成的一个支撑水平作出的判断）。在这一星期余下的几个交易日中，随着市场的下滑，这笔空头头寸看上去挺不错。但是到了6月18日，市场发出明显的信号，显示当务之急是平回空头头寸。这些信号如下所列： 1、6月18日是一根高高的白色蜡烛线，它向上吞没了前一根黑色实体。于是，这两根蜡烛线组成了一个看涨吞没形态。 2、6月18日的开市价向下跌过了6月初的低点，为当前趋势创出了新低水平。然而，市场不久就重新回到了6月初的低点之上。这样一来，就形成了一个破低反涨形态。过去的低点虽然一度被跌破，但是市场不能维持这样的局面，根据这个破低反涨形态，我预期市场将向上重新尝试当前交易区间的上边界，即大约6.30美元的水平。 3、6月18日的蜡烛线是一根强劲的看涨捉腰带线。 4、当前的新低价位在随机指数曲线上没有得到相应的验证。这就形成了一个正面相互背离信号，表明熊方已经丧失了对市场的控制。 6月18日的价格变化显示，当前市场环境并不适合做空。第二天，我便在 6.12美元的水平平回了原来的空头头寸。在上述这一实例中，在开立头寸时我主要依据西方技术分析方法，但也采用了一些蜡烛图指标，并根据它们调整了自己对市场的看法。 如图20.2所示，从 5月下旬开始，我们看到了一系列逐步降低的高点，它们均处于图示的向下倾斜的阻挡线下方。这就表明当前的主要趋势是下跌的。0.92美元是一个支撑水平，这个支撑水平的形成一直可以回溯到3月底和5月初。6月14日，当图示的咖啡市场向下跌过了这些低点之后，正是寻找适当价位卖出做空的时候。6月14日是一根长长的黑色蜡烛线，它显示市场的抛售压力很沉重。但是，市场此时正处于严重超卖状态，不宜马上卖出做主。 有一根小实体出现在这根长长的黑色蜡烛线之后，由此构成了一个孕线形态.这个孕线形态告诉我，之前的下降趋势已经转化为中性行情，所以不可以鲁莽地建立空头头寸。现在，市场既有可能形成一个水平交易区间，也有可能发生上涨行情。结果，咖啡市场形成了一段小规模的上涨行情。这段上进行情恰巧终止于我们所预期的水平——0.92美元附近。为什么0.92美元的水平如此特别，能够成为阻挡水平呢？请回忆这样一条定理：过去的支撑水平能够转化为新的阻挡水平。3月底和5月初的低点位于0.92美元。这一水平现在转化为阻挡水平。在上述短暂的上涨行情中，一旦市场从0.92美元附近向下折回。我就了解到，熊方依旧把持若市场的控制权。6月20日的价格变化向下打开了一个窗口，这意味着市场将形成另一阶段的下降行情。6月21日，当我看到市场无力向上运动到这个窗口的阻挡区之上后，建议在0.9015美元卖出做空，并把止损水平安排在6月20日的高点处，即O.9175美元，其价格目标在 0 8675美元（这是根据同一年早些时候的支撑水平提出来的）。后来，市场便开始回落。 在如图20.3所示的时间，原油市场正处于熊市之中。因此，我正在寻找市场回升的机会卖出做空。6月21日，当图示的锤子线出现后，市场开始了一段上升行情（请注意，我并没有采用这根锤子线来作为买进的信号。为什么呢？因为当前的主要趋势是向下的）。在这根锤子线的数日之后，接连出现了两个看跌吞没形态。在这种情况下，我建议卖出做空.在6月15日和6月18日之间，市场曾经打开了一个小窗口。因为我确位这个窗口将起到阻挡作用，所以把止损水平设置在稍高于这个窗口的水平，即 17.65美元.我的价格目标是，市场将重新向下试探前面的锤子线处的低点。后来在6月25日，市场又一次向上试探由上述吞没形态和窗口所形成的阻挡水平，但是很快由此向下反弹。 如图20.4所示，6月4日市场形成了一根锤子线，并且它的收市价成功地维持于在 4月底和 5月中的低点，即 2.65美元的水平之上。因为当日市场本来已经向下创出了当前趋势的新低水平，但是未能维持这样的战果，所以也构成了一个看涨的破低反涨形态。 虽然这是一根看涨的锤子线，但是我井没有立即建议买进，因为市场仅仅以细微的差距维持在2.65美元的支撑水平之上，所以，我还需要下一天进一步的验证信号。在这根锤子线的次日，市场开市于较高的价位，由此证实了上述信号。于是，我建议在2.68美元的水平买入，止报水平设在比上述支撑水平稍低的2.64美元。价格目标是，市场向上试探图示的向下倾斜的阻挡线，即2.79美元。锤子线之后的这根坚挺的蜡烛线完成了一个启明星形态。 尽管在图20.5所示的实例中我们并未获取利润，但是这是一个很好的例子，说明了蜡烛图如何能够帮助我们识别良好的出、入市点。3月2日是星期五，这一天的价格变化发出了一些买入信号。首先，这是一根锤子线。其次，这根锤子线的小实体处于前一根高高的实体之内，形成了一个孕线形态。这个孕线形态意味着之前较小规模的下降趋势已经告终。最后，这根锤子线的低点已经向下跌破了2月初形成的支撑水平，但是这一新低水平未能维持下去。换句话说，熊方曾经力图向下突破，但是未能如愿以偿。这就构成了一个入市买进的良机。 3月5日，星期一，我建议在 21.38美元买入。其价格目标是一个非常近期的价格水平，即市场向上重新试探2月底的高点，22美元的水平。既然价格目标如此接近，那么止损指令的水平也应当成比例地位于很接近的水平。我把它安排在锤子线的低点稍下方，为21.10美元。在3月5日和6日，市场上升到了2月28日和3月1日的高点，21.75美元附近。市场未能向上超越这个近期的阻挡区。当我看到这一失败过程后，便将止损指令的水平向上调整到盈亏平衡点上。在3月7日市场的回抽过程中，这个头寸被止损平仓。一旦价格向下推进到了这根锤子线的低点之下，市场的下跌进程便势如破竹。 结语经过多年的学习研究和实际的历练，本书终于完成了，衷心希望本书能够为市场分析开辟一条新的道路。我确信，您同我一样，只要在蜡烛图技术上花上一些功夫.那么在日后的交易实践中，就再也离不开它所提供的独特的市场视野了。我早已不再采用线图形式了，仅仅使用蜡烛图。但是，这并不意味着我仅仅使用蜡烛图的技术措标。虽然蜡烛图是不可或缺的市场分析媒介，但是我总是竭尽所能地采用手里掌握的所有的各种技术分析工具。这正是蜡烛图的一大优势。如果选择了蜡烛图，那么您既可以应用蜡烛图分析技术，也可以应用西方技术分析技巧，或者干脆将它们两者兼收并蓄。如果您是一位技术分析老手，那么您马上会发觉，东方和西方技术的融合，造就了一条精彩纷呈、令人兴奋的合成的市场研究之道。 研读图表，需要灵活的头脑。认清您的立足之处在市场技术分析的总体格局中所处的位置，比识别单独的某个蜡烛图形态重要得多。举例来说，在主要趋势为熊市的市场环境下，一个看涨的蜡烛图信号是不应当看作买入信号的。而在牛市环境下，一个看涨的蜡烛图形态，特别是当得到了其它技术信号的验证的时侯，则构成了一个买入点。 即使许多读者朋友选用本书为参考（这当然是我所希望的！），但是，这并不意味着每个人都会按同一个方式来应用蜡烛图技术。因此我并不担心，如果大家都学会了这门古老的投资技巧，就会使之失去效力。这是因为，蜡烛图技术与所有其它的各种图表分析方法一样，需要分析者的主观取舍。 两位蜡烛图分析师就像从同一所医科大学毕业的两位医生。也许他们对于人体的工作机理具有完全相同的知识、然而，由于每一位医生有他自己的治疗经验、医疗哲学和个人们好，所以，对同一位病人，他们会作出不同的诊断，采取不同的医治方案。甚至在患者的症状完全一样的情况下，也是如此。在上述诊断过程中，不可避免地带进了每位医生特有的个性和个人对医术的领悟。您与技术分析之间的关系与上述情况是一样的道理。您就是市场的医生。您通过蜡烛图技术对市场健康状况作出诊断，并据之实行应对措施，另一位蜡烛图研究者的做法未必同您的一致。您到底如何依据蜡烛图来进行交易，取决于您的市场哲学、您曾遭受的市场风险的困厄，以及您的情绪等各个方面。这些因素都具有极其强烈的个人色彩。 另一方面，每个市场也具有其自身独特的个性。正如日本分析者们所说，“市场的价格形态如同人的睑，没有两张脸是完全一样的。”举例来讲，在原油市场的日蜡烛线图上，乌云盖须形态似乎效果良好，而在锡市场的周蜡烛线图上，锤子线出现得相对较为频繁。通过对市场个性的研究，您就能揭开该市场在蜡烛图形态上的特点，正确识别它们的各种变体，从而发现哪些蜡烛图形态在本市场出现得最多，哪些在本市场最有效。 俗语说得好，“送我一条鱼只能吃今天一顿；但是教我捕鱼的方法，一辈子都有鱼吃。”我期望本书能够教给您一点取鱼经。希望您从本书所读到的，能够帮助您略窥蜡烛图技术的门径。 蜡烛图技术已经经历了数百年的锤炼.因此，无论我们将之单独运用，还是将之与其它技术分析手段参照着使用，它的分析能力都是无可匹敌的。这就是说，从初入门的技术分析新手倒久经沙场的职业技术分析师，每个人都能够从蜡烛图技术中汲取力量。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十九章 利用蜡烛图进行保值交易]]></title>
    <url>%2F2021%2F03%2F06%2F%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E5%88%A9%E7%94%A8%E8%9C%A1%E7%83%9B%E5%9B%BE%E8%BF%9B%E8%A1%8C%E4%BF%9D%E5%80%BC%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 过去，当人们需要保值避险的时候，在安排好保值交易的头寸后，往往将之抛到脑后。现在，这样的日子已经一去不返了。由于很容易获得大量的市场信息，保值商的操作手法越来越老练，对技术分析也越来越得心应手。自然，保值商越来越有能力作出合理的决策，选择恰当的时机，恰当的数量，对他们的现货头寸风险进行对冲。归根结底，这些决策的出发点，是以利润为中心的。这一章，我们要探讨如何在这样的决策过程中充分利用蜡烛图技术，使之成为一门极有价值的辅助工具。这是因为，许多蜡烛图指标均属于趋势反转信号，所以，它们能够提供可贵的线索，帮助我们抉择进行保值交易，取消保值交易，以及调整保值头寸的不同时机。保值商为了冲抵现有现货头寸的价格风险，或者冲抵可预见的未来现货头寸的价格风险，需要在相应的期货市场或期权市场上建立相反方向的头寸。所谓空头保值商指的是，保值商所承担的现货头寸的价格风险来自价格下跌这一边。举例来说，一位铜冶炼商可能是银市场的空头保值商，而一位农场主则可能是农作物市场的空头保值商。为了规避由于价格下跌所带来的风险，空头保值商既可以卖出期货合约，也可以买人卖权期权，从而建立相应的空头头寸。一旦市场价格下跌，那么他在现货头寸上蒙受的亏损，从期货头寸或期权头寸的对应利润中至少能够得到部分的补偿。现货商品的最终用户可能成为一位多头保值商。对于多头保值商来说，基本的现货头寸的风险来自价格上升这一边。举例而言，一位衬衫制造商在生产衬衫的过程中必须买入棉花，那么，他就可能成为棉花市场的多头保值商。为了规避由于价格上涨所引起的风险，这位衬衫制造商既可以通过买入期货合约，也可以通过买入买权期权来建立保值头寸。万一价格上升，那么，虽然他在现货商品市场必须付出较高的代价，但是同时至少能够从期货头寸或用权头寸的盈利中得到部分的补偿。在很多情况下，如果仅仅在一个价位上建立保值头寸，还不足以完全冲抵相应现货头寸的风险。在这种情况下，保值有可能希望按照一定的比例、梯次，逐步建立保值头寸。如此一来，保值商就会经常碰上下面这个问题：在当前市场状况下，应当对风险总额的多大百分比例进行保值。蜡烛图技术能够帮助我们解决这道难题。通过研究以下列举的各个实例，您就能够从中体味到，如何借助蜡烛图来取得丰富的线索，从而决定何时应当调整现货头寸的保值比例。对于实行100％保值的保值商来说，蜡烛图技术也是实用的、举个例子，假定您是一位种植玉米的农场主，当前玉米市场的趋势正与您的现货头寸方向相反（就是说，玉米价格正在下跌）。这就意味着，作为一个空头保值商，您的期货保值头寸是盈利的。如果市场上出现了一个坚挺的看涨蜡烛图反转形态，并且您确估价格即将上涨，那么，您也许打算平回一部分保值头寸、减小保值比例。在某些情况下，及时了结一个盈利的保值头寸也许有助于改善当前的现金状况。不过话说回头，绝不可以把保值头寸视为一种创造利润的市场策略。 如图19．1所示，1988年该市场发生了一轮爆炸式的上冲行情。价格从6美元飚升到11美元，几乎翻了一番。1988年年中，在这场上涨行情的顶部附近，蜡烛图给出了一个反转信号，即图示的看跌吞没形态。如果我们成一个顶部反转形态。根据西方理论，在这个顶部反转形态中，既要求第二根蜡烛线为当前趋势创出新高，也要求它的收市价低于前一周的收市价。但是，该吞没形态第二天的黑色蜡烛线并没有形成新高水平。于是，从西方观点看，这不属于顶部反转形态；而从蜡烛图来看，却是一个顶部反转形态。对于种植大豆的农场主来说，当这个看跌的吞没形态出现时，可以利用它作为警告信号，建立一个空头保值头寸，或者在没有对现货头寸进行完全保值的憎况下，增加保值的百分比例。1989年，又有一个看跌吞没形态警示着市场顶部的到来（在这一例中，如果我们采用西方的技十分析工具。也不会把它看成一个顶部反转形态）。空头保值商可以利用这个机会，建立保值头寸。几周以后出现的窗口，是另一个看跌的蜡烛图信号。这个信号告诉空头保值商，增加他们持有的空头保值头寸（如果他们还没有100％保值的话）。10月里形成了一个看涨的刺透形态，我们可以利用这一信号了结一部分空头保值头寸，减少保值比例。对于寻找机会设立多头保值头寸的人来说，可以以这个刺透形态为信号，建立保值头寸。 如图19．2所示，在1988年9月的最后一周，以及在10月的头一周，市场上集中发生了一群看涨的蜡烛图信号。其中最显眼的，是一个看涨吞没形态。这两个星期同时也组成了一个平头底部形态。另外，其中的白色蜡烛线是一根坚挺的捉腰带线，并且它的收市价位于最高点。这根白色蜡烛线还一口气向上吞没了之前5根蜡烛线。对于多头保值商来说，这是一个很好的信号，既可以借此设立保值头寸，也可以增大现有的保值头寸。在1989年初，出现了一个十字孕线形态（这是一种重要的反转信号），多头保值者不妨据此减小保值比例，平回一部分保值头寸。另一方面，这个十字孕线形态是由一根长长的白色蜡烛线和一根十字线组成的。这一事实可能意味着市场已经陷入了困境。正如我们在第八章中所讨论的，出现在一根长长的白色实体之后的十字线，常常是市场顶部的标志。图19．3所示为原油市场。本例探讨了该市场的保值商，如何通过蜡烛图信号来获得一个及早的底部反转信号，然后再利用西方的技术分析工具对之加以验证，进而增持多头保值头寸。第一个尝试性的底部反转线索，出自7月5日的一根锤子线。考虑到这根锤子线从前一天的最低点向下跳空，我们就不应当草率地视之为看涨信号，除非在今后的几天中还有其它看涨指标对它进行了验证。下一个线索，是图示的看涨吞没形态，它为这根锤子线提供了验证信号。与此同时，这个吞没形态本身也是一个非常重要的底部反转信号。这是因为，其中7月9日的白色蜡烛线不只向上吞没了前一根蜡烛线，而是吞没了前两根蜡烛线。在这个时刻，原油市场的最终用户（即多头保值商）应当郑重地考虑是否建立保值头寸，或者增持已有的保值头寸。接下来的一条线索是，点A、B（所示的价格低点，没有得到下半日的动力指数的验证。这就揭示出如下事实：价格下跌的速度正在放缓（也就是说，市场向下的动力正在减退）。 上面所列举的各项理由已经非常充分地预示，价格即将向上反弹。但是，本例还有其它以外的特征。紧接着上述底部反转信号，动力指数向上穿越零线，进入了正值区（请看着箭头所指处）；就在同一时刻，根据传统的西方技术分析理论，图示的下降楔换形也向上突破了上边界。根据下降楔形形态的理论，下一轮上进行用的价格目标应该在换形的起点处。对于这个问题，取决于您如何看待这个楔形形态的起点。其价格目标既可能设在6月的高点，即19美元的水平上下，也可能设在5月18日的高点，即20美元附近。当市场向上突破这个换形形态时，我们应当增持多头保值头寸。从本例中我们可以看到，蜡烛图技术能够比西方技术分析工具更早地发出趋势反转警告信号。此处我们还可以看到，将蜡烛图技术同西方的技术分析方法结合起来，恰似如虎添翼一般，能够创造出一种强大的合成工具。相互验证的技术分析信号越多，那么准确地揭示趋势变化的把握也就越大。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十七章 蜡烛图与市场剖面图]]></title>
    <url>%2F2021%2F03%2F06%2F%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E5%B8%82%E5%9C%BA%E5%89%96%E9%9D%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“相得益彰”。 在期货市场上，很多市场参与者使用市场剖面图。以前，只有亲临交易所内交易现场的人才能得到这种图表所提供的市场信息。市场剖面图有助于技术分析者理解市场的内在结构。它为我们分析市场的价格、时间、交易量三要素，提供了一种符合逻辑的、以统计科学为基础的研究方式。在市场剖面图上，人们采用了各种各样的分析工具。本部分，我们只准备探讨其中少数几种方法。关于不同类型的剖面图日（即所谓常规日、趋势日、中性日、长期市场活动图等情况），以及市场流动性资料库方面的题目，这里就不打算讨论了。我们的目的是提醒读者朋友，注意市场剖面图独特的市场分析视角，以及如何将它同蜡烛图相互参照。 下列几项基本要素构筑了市场剖面图的理论基础： 1、所有市场都是以便利和促进交易活动为目的的。 2、市场有一套自我调节机制。这种内在调节机制制约着价格、时间、交易量的相互关系。 3、市场为了便利和促进交易活动，往往以价格作为探针，尽力招揽卖出者和买进者。市场参与者对价格探针的反应，为我们判断市场的坚挺程度或疲弱程度，提供了极有价值的线索。 市场剖面图将每个交易日划分为以半小时为单位的若干时段，每个时段分配一个不同的字母，以组织每日的价格活动。因此十“A”所代表的，就是从上午8：00到8：30的交易时段（芝加哥时间），“B”代表的就是从上午8：30到9：00的交易时段，依此类推。对于那些开市时间早于上午8：00的市场（比如长期国债市场、货币市场、金属市场等），它们的头半个小时通常用“y”、“Z”表示。每一个字母称为一个TPO（即一个时间一价格机会点）。每个半小时时段的字母，代表了这半小时市场的价格区间。上述情况如图17.1所示。 我们把每个交易日头一个小时所形成的价格区间标为初始平衡区。正是在这个时间段里，市场初步探索了当日的交易区间。换句话说，这是市场为了发现价值而进行的最初尝试。在头一个小时的初始平衡区之后，如果市场又形成了新的高点或新的低点，则它们称为区间扩展。如图17.1所示，市场形成了卖出区间扩展，但由于在初始平衡区之后没有出现新高，本例没有形成买入区间扩展。 对于市场剖面图的分析者来说，价值的定义是，在一定时间范围内市场所接受的价格水平，市场接受的程度反映在有关的价格水平上成交量的多寡。由此一来，在决定价值的因素中，时间和交易量就成了两项关键的成分。如果市场在某一价格水平仅仅有短暂的交易，则表明市场排斥这一价格水平。也就是说，市场在这里没有发现“价值”。如是市场在某一价格水平持续了相对充分的交易时间，并且达成了较多的交易量，就意味着市场接受了这一价格水平。在这种情况下，市场就发现了价值。市场所接受的价格，处于一个交易量之和占据全日交易量70％的价格区间之内（对于熟悉统计学的朋友来说，这是一种取值范围为70％的标准分布）。这样的价格区间就定义为当日的价值区、举例来说，如果某日小麦市场70％的交易量发生在从3.30美元到3.33美元的区间中，那么这个区间就是当日的价值区。所谓价格探针是指市场探求价值区范围的行为。从投机商到投资者，市场参与者群体对这种价格探针的反应，为市场剖面图的应用者提供了重要的信息来源。每当市场伸出一个价格探针后，都可能发生某种变化。一种可能性是，市场重新返回到既定价值区之内去；另一种可能性是，市场在这个新的价格水平重新确定价值区.市场对这一新价格是否接受，是否使之构成新的价值，可以通过这一价格水平上的交易量的增长情况。以及市场在这一价格水平处维待的时间长短来加以验证。 如果价格重新返回到既定的价值区，则表明市场否决了这一新的价格，认为这是一个不公平的过高水平或过低水平，在市场很快使否决某一价格水平的情况下，结果可能造成了一个极端点，我们把极端点定义为位于当日市场剖面图（除了最后半小时的时段之外）顶部或底部的2个或更多的TPO。一般地，市场剖面图顶部的极端点，是由于卖出者受到此处高价位的吸引而竟相卖出、但同时买进者数量不足所造成的。底部的极端点，则是由于买进者受到此处低价位的吸引蜂拥而至、但同时卖出者数量缺乏所造成的。在图17.1中，我们分别标出了买进极端点和卖出极端点。 另一方面，当日价值区与前一日价值区的相对位置，也为我们提供了极有意义的市场信息。市场剖面图的信奉者密切监视是否出现了所谓的发起性买进或卖出信号，还是出现了所谓回应性买进或卖出信号。这些信号是通过比较当日极端点和区间扩展发生的位置同前一日价值区的关系来判定的。具体说来，在前一日价值区之下发生的买进行为，就称为回应性买进。因为此处价格低于既定的价值，买入者判断这是低于价值的价格，并且采取了回应性行动。这些买入者预期价格将返回到价值上来。 在前一日价值区之下卖出的行为被说成是发起性卖出。因为这些卖出者愿意在低于既定价值的价格水平卖出，这就说明他们是大胆、积极的。这种情况意味着，他们相信价值区将向下运动。在前一日价值区之上的买进行为属于发起性买进。这些大胆、积极的买入者断定，价值区将向上运动到新的价格水平。否则，为什么要在现存的价值区之上买进呢？在前一日价值区之上的价格水平卖出者，称为回应性卖出者。他们预期价格将返回既定价值区，因此对偏高的价格水平采取了回应性行动。 我们应当顺着发起性买进或发起性卖出的方向交易，除非此处的价格很快将为市场否定。因此，如果在前一日的价值区之下，市场上出现了发起性卖出活动（即形成了极端点或者区间扩展），并且此处的交易量呈上升态势，这样的局面就具备看跌的意味。 市场剖面图与蜡烛图如图17.2所示，7月2日是一根十字线，下一天是一根上吊线，这是蜡烛图的顶部警告信号。那么，在同一期间，市场剖面图发出了什么样的信号呢？7月2日的剖面图同前一天相比，具有较小的价值区。而目，这一天的交易量也比较轻（当天的交易量为32000张合约，而前一天为303000张合约）。这一情形暗示，这里的价格水平过高，难以为市场所接受。换个说法，这样的价格水平对交易活动缺乏促进作用。另一方面，这一天的剖面图在上下两个方向均发生了区间扩展。这就显示出牛方和熊方的拔河赛正僵持不下。 7月3日也是一个交易量较轻的交易日（109000张合约）。这就给当日市场种种坚挺的表现打了很大的折扣——这一天，不仅发生了向上的区间扩展，而且收市价位于全日的最高点。下一天，即7月5日，市场的疲弱性质表露无遗。在当日较早的交易时间中，市场曾经为当前趋势创出了新高。在这个过程中，也形成了向上的区间扩展。市场通过这一区间扩展过程，试图吸引卖出者入市。结果，他们果然来了。在当日较晚的几个时段中（J、K、L上时段），市场上形成了一段抛售行情，使得收市价接近全日的最低点。7月6日，当市场开市时就出现了发起性卖出，因为当日的开市价处在前一日的价值区之下。这就表明，当日的抛售活动自开市即刻开始。另一方面，7月6日的交易量呈现出增长的态势，并且在“Y”时段内，形成了发起性卖出极端点（也就是说，位于当日剖面图顶部的单个的TPO）。这就证实当前市场已经陷入困境。 通过本实例，我们也能够看出上吊线的一个重要方面，有关内容我们过去有过介绍。仅在上吊线之后出现了看跌验证信号的条件下，上吊线才真正构成一个看跌信号。7月3日，是一根上吊线。从这一天的市场剖面图来看，它甚至还为市场发出了一些正面的信号。只有通过之后的几个交易日，即7月5日和7月6日，特别是7月6日的早晨，我们才从市场剖面图上得到了这个市场顶部的确认信号。 如图17.3所示，7月5日是一根赫然醒目的流星线。在这根蜡烛线出现后，本图所示的棉花市场连续狂跌了三个交易日。那么，在这根流星线出现之前，市场剖面图是否发出了什么明显的不良征兆呢？是的。的确如此。从6月29日到7月3日，虽然价格一路上涨，但是价值区却一路收窄。这就意味在当前的较高价位上，市场对交易活动的便利、促进作用有所减弱。市场在将这些高的价格水平接受为价值的过程中，遇上了困难。另一方面，如果我们统计每一天的TPO总数，以此衡量当日的交易量的话，那么，这几天的交易量也显现出日益下降的态势（这些交易日的真实交易量也是小的。无论如何，因为交易量的数据要迟一天才公布，所以我们需要统计TPO的总数，以估算当日的交易量）。请注意，7月5日的流星线标志着一个市场顶部。在当日的市场剖面图上，价值区接近当日价格范围的上端，但是未能招来跟进买入者。相反，由于受到这些高价位的吸引，卖出者纷纷入市，驱使市场下跌。结果，形成了图示的向下的区间扩展，以及一个疲软的收市价。这些情况构成了看跌的信号。如果您觉得还需要更多的证据才能说明问题，那么，只要等到7月6日一开市，就真相大白了。在这一天开市时，市场在前一日的价值区之下形成了发起性卖出极端点。这就证实卖出者已经登台，市场前景堪忧。综上所述，通过市场剖面图的各种工具，图示流星线的看跌意义得到了验证。 在市场剖面图的思路与蜡烛图技术之间，存在着某些有趣的相似之处。如果市场剖面图的价值区较宽，则通常代表着市场对交易活动的促进，因此，这就增加了当前价格趋势持续发展的可能性。由此看来，在上升趋势中，我们期望看到逐步扩张的价值区。与此相似的是，在蜡烛图上，我们希望在上涨行情中看到一系列越来越长的白色实体，以证实当前价格运动背后的市场力量。 如果市场剖面图的价值区呈现出逐步收窄的局面，则反映了市场对交易活动的促进作用的减小，因此，判断当前价格运动能否持续发展，就少了几分把握。在蜡烛图的前方受阻形态和停顿形态中，情况与上述也是一样的。在这两种蜡烛图形态中，虽然价格趋势依然是上升的，但是在此过程中，白色实体的高度却在逐步缩小。这两类形态显示，当前的市场动力正在逐步衰减。 至于蜡烛图的星线，情况又怎么样呢？这是出现在上升趋势或下降趋势中的一种短实体的蜡烛线。它的出现，标志着牛方（上升趋势中的星线）斗志的消退，或者熊方（下降趋势中的星线）动力的减弱。在市场剖面图上，如果在一轮强烈的上涨行情（或下跌行情）之后，出现了一个小价值区，则说明了与上述相同的道理。这里的小价值区反映出市场对交易活动缺乏促进作用。这种情况可能是趋势即将生变的先兆。再看蜡烛图的锤子线。在剖面图上，由于低价位吸引了大量的买入者.从而产生了买入极端点，这种情况反应在蜡烛图上，可能就形成了一根锤子线长长的下影线。流星线呢？由于高价位吸引了强烈的抛售行为，造成了卖出极端点，这种情况反映在蜡烛图上，可能构成某个流星线长长的上影线。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十六章 蜡烛图与艾略特波浪理论]]></title>
    <url>%2F2021%2F03%2F06%2F%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E8%89%BE%E7%95%A5%E7%89%B9%E6%B3%A2%E6%B5%AA%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“两条腿走路”。 应用艾略特波浪理论的技术分析师为数众多，广泛分布在各种市场领域内。这一理论既适用于日内价格图表，也适用于以年为时间单位的超长期图表。在本章，我们只准备对艾略特波浪理论作一点粗浅的入门性介绍。如果详细介绍艾略特波浪理论的市场分析方法，恐怕非得专门写一本书不可。 艾略特波浪理论的基本概念艾略特波浪理论是R.N.艾略特在本世纪初发现的。他从市场各个方面的特性中注意到，价格运动是通过下述基本过程形成的：先是五浪上涨，然后跟着调整性的三浪下跌。如图16.1所示，上述八浪组成了一个完整的市场周期。其中，1浪、3浪、5浪称为主浪（也称推进浪），2浪和4浪称为调整浪（也称次浪）。虽然在图16.1中，艾略特波浪的数浪情况反映出一个上涨的市场，但是，同样的概念也适用于下跌的市场。于是，在下降趋势的市场上，主浪的方向将是向下倾斜的，而调整浪则向上倾斜，与主要趋势方向相反。 图16.1 基本的艾略特波浪结构 艾略特另一方面的重大贡献是，将菲波纳奇数列引入了市场预测研究。因为菲波纳奇比数可以用来推算下一浪的价格目标，所以数浪技术与菲波纳奇比数是相辅相成的。举例来说，我们可以将1浪的高度乘以1.618，由此推测3浪的高度；4浪可能将3浪的运动幅度往回调整38.2％，或者50％；如此等等。 艾略特波浪理论与蜡烛图本章所要说明的是，从蜡烛图上能够取得旁证，有助于确认艾略特波浪的终止点。在实际交易中，最重要的波浪是3浪和5浪。3浪通常是最强劲的一段行情；而在5浪的顶部，我们必须及时掉转头寸方向。在以下各例的数浪中，我从我的同组约翰.甘比诺那里获益良多，他对艾略特理论有专门的研究。艾略特波浪的数浪分析具有主观性（至少在波浪最终完成之前是这样的），因此，以下的数浪结论同其它分析者也许不一定相同。 如图16.2（a）所示，我们在本例中标数出一个五浪结构，以下将对每一浪作一番分析。推进浪①是从2月下旬的乌云盖顶形态开始的。3月中旬，出现了一个孕线形态，于是推进浪①结束。这一孕线形态出现，意味着之前市场向下的压力正在消退。随后，形成了一段向上反弹行情。这段反弹行情就是调整浪②，它结束于另一个小规模的乌云盖顶形态。推进浪③构成了主要的下跌过程。这段价格运动的范围，可以通过一个菲波纳奇比数和1浪的高度推算出来。估算的结果是，③浪的价格目标在17.60美元。在17.60美元的水平上，我们期望市场形成某种蜡烛图信号，以验证我们标数的③浪的底部。这一信号发生在4月11日。关于4月11日价格变化的详细情况，请看图16.2（b），这是上述原油市场的日内图表。 图16.2 原油——1990年6月：（a）日蜡烛图；（b）日蜡烛图（艾略特波浪理论与蜡烛图） 在4月11日的头一个小时内，原油市场从前一天的收市价起，向下狂泻了1美元。在这一时刻看来，这场抛售行情似乎还未终结。但是后来，出现了一些有趣的价格变化。这场抛售行情在17.35美元处突然中断——这与艾略特理论预测的17.60美元非常接近。其次，在这张小时线图表上［请看图16.2（b）]，随着这轮抛售行情的结束，当天的头一小时最后形成了一根经典的锤子线。在这个潜在的看涨指标之后，立即出现了一系列坚挺的长长白色实体。在这张小时图表上，这根看涨的锤子线，以及之后的这些白色蜡烛线，验证了我们标数的③浪的底部。在上面的日蜡烛线图上，也提供了一个底部反转信号。4月10日和11日的价格变化组成了一个刺透形态。接下来，我们预期市场将产生4浪的上涨行情。 根据艾略特波浪理论，④浪应当构成上涨行情，但是④浪的顶部不应当向上超过1浪的底部。在这个实例中，这个水平大约为19.95美元。当市场接近这一水平的时候，我们希望看到看跌的蜡烛图线索。结果，这种情况果然出现了。5月14日和15日，市场在20美元之下形成了一个十字孕线形态，以及一个平头顶部形态。于是，上涨过程陷入停顿，④浪达到了顶部。 有趣的是，如果我们将④浪进一步细分为（a）、（b）、（c）成分浪，则它们与蜡烛图信号相互印证的情形就更加一目了然了。在（a）处，是一根流星线，它的高点止于4月初出现的窗口的水平上。在（b）处，一个启明星形态标志着市场底部的形成。成分浪（c）浪的顶部也是④浪的顶部，此处出现的看跌蜡烛图指标计有：一个十字孕线形态、一个平头顶部形态。 如图16.3所示，⑤浪推进浪的方向向下，它们是从1989年12月的100.16美元的水平开始的。波浪标数的情况如图所示。在①浪的底部，市场形成了一个孕线形态。在②浪的顶部，形成了一个乌云盖顶形态。③浪底部没有出现蜡烛图指标。④浪的顶部构成了一个孕线形态。在本例的艾略特五浪形态中，最吸人的地方是其第⑤浪，即最后一个下跌浪。我们根据第③浪的高度和一个菲波纳奇比数，推导出了第⑤浪的价格目标。由此得到的目标价格水平为88.08美元。4月底，这段下跌行情的低点位于88.07美元。在这个低点处，蜡烛图发出了一组强烈的看涨信号：一个平头底部形态，以及这个平头底部形态内部的两根十字线。交易量的变化也验证了这一底部的形成。请参见图15.1，在那里，我们曾经详细讨论了在这个低点处蜡烛图与交易量相互印证的具体情况。 图16.3 美国长期国债——1990年6月，日蜡烛图（艾略特波浪理论与蜡烛图）]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五章 蜡烛图与交易量、持仓量]]></title>
    <url>%2F2021%2F03%2F06%2F%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E4%BA%A4%E6%98%93%E9%87%8F%E3%80%81%E6%8C%81%E4%BB%93%E9%87%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“一箭易折，十箭难断”。 交易量的技术意义是，一段行情的交易量越重，则这段行情背后的市场力量越强大。只要交易量保持增长的态势，那么，当前的价格趋势就将持续下去。但是如果在价格趋势发展时，交易量不增反降，那么，判断当前趋势仍将继续发展的理由就不充分了。另外，我们还可以通过交易量来验证市场的顶部或底部过程。当市场向下试探某一支撑水平时，如果交易量较轻，则意味着卖出压力减弱了，因此构成了一个看涨信号。反过来，当市场向上试探先前的高点时，如果交易量较轻，则证明买进力量减弱了，构成了一个看跌信号。 虽然我们可以利用交易量来作为一项有力的辅助手段，衡量价格运动背后的市场强度，但是，有一些不利的因素在一定的程度上给交易量的技术意义打了折扣，特别是在期货市场上，这个问题尤为突出。首先，在期货市场上，交易量的数据是延迟一天后公布的。其次，差价套利交易有可能扭曲交易量的数字——特别是扭曲个别合约月份的交易量。另外，随着许多期货市场的期权交易日益盛行，交易量数据也可能被相应的期权套利交易所扭曲。尽管存在上述各种不利因素，交易量分析依然是一种很有价值的研究工具。在这一章中，我们来探讨将交易量与蜡烛图技术相结合的一些办法。 交易量与蜡烛图如图15.1所示，将交易量与蜡烛图技术结合起来，有助于确认双重顶形态或双重底形态的形成。3月22日（即蜡烛线①），市场向上推进至2月底的高点的水平（在94美元附近）。蜡烛线①这一天的交易量为504000张合约（本章所列举的所有的交易量数据都是该品种所有合约月份的交易量的总和）。在接下来的几天中，市场曾经力图将价格推升到94美元的水平之上。但是，这些交易日的实体都比较小，反映出牛方的激情已经不足。在这些小蜡烛线处，较低的交易量也为上述看法提供了佐证。一周以后，牛方终于举手投降。3月下旬，市场在2个交易日之内下跌了两个整点。 图15.1 美国长期国债——1990年6月，日蜡烛图（交易量与蜡烛图） 下面，我们把注意力转向4月4日的高高的白色蜡烛线（蜡烛线②）。这根坚挺的蜡烛线是否预示着牛方已经重新聚积起力量了呢？答案很可能是否定的。首先我们注意到，这个上涨交易日的交易量相对来说是较轻的，仅有300000张合约。在此之前数日，有两根长长的黑色蜡烛线（即3月29日和30日），反而具有较大的交易量。其次，在蜡烛线②之后的价格变化中，还出现了其它的不良征兆。它的下一个交易日（蜡烛线③）具有较小的实体。蜡烛线②和③共同组成了一个孕线形态。它的技术含义是，先前的上升趋势已经结束了。还请注意，这根小实体蜡烛线也是一个看跌的上吊线的变体（理想的上吊线应当出现在水平交易区间的顶部，或者出现在上升趋势的顶部）。下一天（蜡烛线④），市场最后一次对94美元的水平发起冲击，结果形成了一根兆头不祥的黄包车夫线。另一方面，在这一轮上冲行情的背后，市场的支撑力量相对是较弱的。这一点反映在当天较少的交易量（370000张合约）上，与此形成对照的是，3月22日的交易量为504000张合约。当市场以较轻的交易量向上试探过去的高点时，就增加了下述可能性：可能形成一个双重顶。当价格运动到3月30日的低点之下时，就证实了该双重顶形态的形成。根据这个双重顶形态，市场最近的价格目标位于90美元。 从上述讨论可见，当市场向上试探过去的高点时，如果交易量较轻，则可能标志着市场顶部的形成；如果同时还发生了蜡烛图的看跌信号，那么可能性更大。在这张图例中，我们还可以看到一个交易量/蜡烛图的复合市场底部信号的实例。4月27日，是一根十字线。根据我们在第八章的介绍，十字线在上升趋势中比在下降趋势中更有可能形成反转信号。不过，只要得到了其它技术信号的验证，它们也能够充当底部反转信号。这一点在本图所示的长期国债市场也得到了体现。在4月27日十字线的3天之后，又出现了一根十字线，这就增加了前面这根十字线的重要性。相继出现的两根十字线已经不可小视了，但是请注意，这两天还发生了其它方面的技术现象。首先，两根十字线组成了一个平头底部形态（这就是说，两根十字线的低点基本上处于同一水平）。其次，请看这两天的交易量。4月27日的交易量是448000张合约。5月2日，即第二根十字线，其交量量几乎只有前者的一半，为234000张合约。当市场以较轻的交易量向下试探某一支撑水平时，构成一个看涨信号。后来的结局再明白不过了。 如图15.2所示，在4月底出现的看涨的吞没形态中，白色蜡烛线的交易量在最近的几个月内都是最多的。这一点有力地证明了牛方坚定的决心。后来，有一根类似于锤子线的蜡烛线重新向下试探了这一低点，它的交易量较轻，从而证实了一个坚实的市场底部的形成。 图15.2 欧洲美元——1990年6月，日蜡烛图（交易量与蜡烛图） 有很多种建立在交易量基础上的特殊技术分析工具。其中两个最常用的分别为权衡交易量（OBV）和即时交易量（TM）。 权衡交易量（OBV）权衡交易量（OBV）是一种交易量的累计净值。从一个基准日开始，当某一天的收市价高于前一天的收市价时，则将该日的交易量数值加到前一天的权衡交易量数值上；如果某一天的收市价低于前一日的收市价，则该日的交易量就从前一天累计的权衡交易量数值中减去。 可以按照几种不同的方式来应用权衡交易量。一个办法是，用它来验证一个趋势。OBV应当朝着当前主要趋势的方向运动。如果价格与OBV双双上涨，则说明由买方引起的交易量正在上升，即便在较高的价位上，也能达成较高的交易量。这可能构成一个看涨信号。 如果情况与上述方向相反，价格与OBV一齐下跌，就反映出在较低的价位上，由卖方引起的交易量也在增长，说明价格下降的过程仍将持续。 在横向交易区间中，也可以应用OBV。如果在价格保持稳定时（最好是在较低的价位上保持稳定），OBV开始升高，这可能揭示了一个筹码搜集的过程。这种局面预示着上涨行情的到来。如果价格持平运动，而OBV正在下跌，则反映出一个筹码派发的过程。这种局面可能具有看跌的意义，特别是当它发生在高价格水平时。 OBV与蜡烛图图15.3所示为白银市场。在6月13日沉重的抛售行情之后，跟着出现了一个小小的实体。这就形成了一个孕线形态，它将强烈的下降趋势转化为横向延伸趋势。此后数周，市场就处在该水平交易区间中。在这个期间，OBV在上升，反映了一个看涨的筹码搜集过程。6月25日，市场创出了新低，但是这一新低水平未能维持下去，结果形成了一根锤子线。OBV的正面背离现象、熊方无力维持新低水平，以及这根锤子线，三个方面归纳起来，标志着一个近期市场底部的形成。 图15.3 白银——1990年7月，日蜡烛图（OBV与蜡烛图） 即时交易量（TM）在期货市场上，交易量要迟一天才能发布。为了规避这个障碍，许多技术分析者采取即时交易量TM作为一种替代品，以在日内时间单位的基础上找着几分交易量的“感觉”。即时交易量TM体现的是每个日内时间段内的成交笔数之和。它并不反映每笔交易成交的合约张数。举例来说，即时交易量可能显示在某一小时内共成交50笔买卖。在这50笔交易中，我们无从知道每笔到底有多少张合约。它们既可能是50笔单手的小额交易，也可能是50笔50~100手的大额交易。从这个意义上说，即时交易量不是真正的交易量。话说回来，即时交易量还是实用的，因为这是我们现场估量交易量的唯一手段，虽然较不精确，但更为及时。 即时交易量（TM）与蜡烛图图15.4所示为一张日内的小时蜡烛线图，从中可以体会到即时交易量TM的用处。当5月4日形成了一根看涨的锤子线之后，价格开始上扬。但是，这一轮上涨行情却伴随着下降的即时交易量TM。这是一个迹象，表明牛方的信心不足。还有其它的迹象，那便是这些小小的白色实体。在5月8日的头3个小时里，发生了急剧的价格下滑，为当前的趋势创出了新低。5月8日后来的日内价格变化提供了一些线索，显示早晨的抛售行情可能持续不下去。在第三个小时的长长的黑色蜡烛线之后，出现了一根十字线。这两根蜡烛线组成了一个十字孕线形态。几个小时之后，出现了一根白色实体，它向上覆盖了之前的两根黑色实体。这就形成了一个看涨的吞没形态，并且由于它向上吞没了两个黑色实体，从而具备了额外的份量。另外，这根白色的吞没线的低点与之前的一个低点还构成了一个平头底部形态。 图15.4 可可——1990年7月，日蜡烛图（即时交易量与蜡烛图） 要是您认为上述各方面线索还不足以构成一个底部反转信号的话，那么此处的即时交易量提供了进一步的证据，证实买方已经占据了上风。在上述的看涨吞没形态之后，价格开始上涨。在这一轮上涨行情中，交易量逐步扩张，并且各个蜡烛线实体的高度也呈逐步放大的态势。后来，当市场达到前一周形成的阻挡水平1340美元附近时，形成了一根流星线，这根流星线，加上上述阻挡水平，使当前的价格上涨暂时平息了下来。一旦市场以窗口的形式向上突破了1340美元的阻挡水平，则所有的疑虑一扫而光：牛方牢牢地把握着主动权。 如图15.5所示，6月19日的一个锤子线是一个标志，说明市场可能正在探寻底部。在 6月20日的头一个小时，市场达到了16.62美元的新低水平（蜡烛线①）。这一小时的即时交易量TM仅有区区的324笔交易。同一天晚些时候，市场再度向下尝试这一水平，并形成了一根长长的黑色蜡烛线（蜡烛线②）。这一次，即时交易量TM仅有262笔交易。下一天，即6月21日，最有意思。在这个交易日的第三个小时，价格向下开创了当前趋势的新低水平，16.57美元。创造这个新低时的即时交易量TM（249笔交易）比前两次向下试探时（蜡烛线①和蜡烛线②）来得更轻。这就意味着抛售压力正在减弱。于是，价格向上反弹，并形成了一根锤子线。（根据第十一章对破低反涨形态的有关介绍，我们现在预期市场将向上试探前一个高点，即17.24美元附近的水平。） 图15.5 原油——1990年8月，日蜡烛图（即时交易量TM与蜡烛图） 持仓量在期货市场上，当一位新的买入者与一位新的卖出者达成买卖协议时，就产生了一张新合约。因为这一原因，期货市场里流通的合约总额，可能超过相应的实物商品的实际供给量。持仓量是所有的敞口多头头寸或所有的敞口空头头寸单边的总和，而不是它们双边的总和。 持仓量的作用与交易量有些类似，也有助于衡量价格运动背后的市场力度。根据持仓量的增减，我们就可以判断资金是流入某一市场，还是流出某一市场，因此，它就具备了上述用途。持仓量的上升或下降，取决于两方面因素的消长对比：新入市的买入者或卖出者的数额，与新出市的原有交易者的数额。 价格趋势的发展应当伴随着逐步增长的持仓量，这一部分的焦点就是要交代清楚这一点的重要性。我们必须牢记以下重要原则，如果在价格趋势的演进过程中，持仓量呈上升态势，则有助于验证当前的价格趋势。举例来说，如果市场正在上涨，而持仓量也在增长，就说明新的多头比新的空头更为主动积极。上升的持仓量显示，既有新的买进者入市，也有新的卖出者入市，但是其中新的多头更为积极，大胆，因为尽管价格不断上扬，这群新的多头者依然继续买进。 另一种情形是，价格下跌，而持仓量逐步积累，这就反映出熊方的信念很坚定。这是因为，上升的持仓量表明，既有新的多头者入市，也有新的空头者入市，但是尽管是在不断下降的价格水平上，这群新的空头者仍然愿意卖出。综合上述，如果在上升趋势中持仓量是上升的，则一般说来，牛方占据主动，上涨行情仍将持续；如果在下降趋势中持仓量是上升的，则说明熊方占据主动，下跌行情仍将持续。 与上述情况相反，如果在市场趋势的发展过程中，持仓量下降，则构成了一个表示趋势或许难以为继的信号。为什么呢？因为持仓量的下降说明，原来持有头寸的市场参与者必定正在平仓出市，放弃这个市场。在理论上，一旦这些旧的头寸平仓完毕，则当前市场运动的驱动力量就将烟消云散。从这个意义上说，如果在市场上扬时，持仓量下降，那么这段上涨行情是由于空头买入平仓行为所引起的（以及原来的多头者趁机对冲头寸）。等到原有的这群空头者逃离了该市场，那么上述上涨行情（即空头买进平仓行情）背后的驱动力也随之瓦解，这就意味着当前的市场较为脆弱，容易诱发进一步的疲弱行情。 我们不妨打个比方，假定有一根水管接在自来水干线上。在自来水干线与这条水管之间安装了一个水龙头。上升的持仓量相当于打开了水龙头，从自来水干线向水管里输入自来水。那么，只要水龙头是开着的，就会不断地从水管里面流出水来（这就相当于上升的持仓量将价格进一步推高或推低）。下降的持仓量好像是关上了水龙头。开始，还有水从水管子里面流出来（因为水管子里面还有一些剩水），但是一旦剩水全部滴出来了，就不再有新的来源维持水流了。结果，水流（相当于价格趋势）就会枯竭。 关于持仓量，还应当考虑其它因素（比如季节性因素等），不过我们此处又打算对持仓量作一点简要的说明，不可能面面俱到。 持仓量与蜡烛图图15.1所示为长期国债市场，其中显示出丰富的交易量信息。本图还展示了上升的持仓量在验证价格趋势方面的重要性。现在我们回头再来看看这张图表，不过，这一回请把注意力放在持仓量图线上。对图15.1，我们可以进行以下几个方面的分析。 从3月13日开始，长期国债市场形成了一轮较小的上冲行情，一直持续到3月22日。在这轮上涨行情的演化过程中，持仓量是下降的。这就意味着这一轮上涨行情是由于空头者买进平仓引起的。一旦空头者买进平仓的过程结束，这轮上涨行情也就结束了。这段上涨行情终止于蜡烛线①。这一天形成了一根黄包车夫线，并且标志着市场对2月底位于94美元附近的高点的试探的失败。4月9日，当图示的抛售行情开始的时候，持仓量也随之上升。上升的持仓量意味着新的多头者和新的空头者入市买卖。不过，熊方显然更为积极大胆，因为他们在逐步下降的价格水平上依然愿意卖出。在整个4月份的下跌过程中持仓量持续增长。4月27日和5月2日，市场形成了两根十字线（在88.5的水平上）。从这时起，持仓量开始水平伸展。这反映出能方卖出压力的衰减。 如图15.6所示，在整个5月里，价格上涨，持仓量也上涨，形成了一种健康的组合。但是在6月份，虽然价格继续上涨，持仓量却在下降，这种反差就显得不太正常了。这就说明，6月份的上涨行情在很大程度上是由于空头买进平仓所引起的。就上涨行情的进一步发展来说，这样的局面不是一个好的征兆。图示的流星线标志着市场顶部的形成，在接下来的4个交易日里，市场一下子便抹消了过去花费了约一个月积累起来的价格上涨。 图15.6 棉花——1990年12月，日蜡烛图（持仓量与蜡烛图） 当市场处于新高水平时，如果持仓量恰巧也达到了异乎寻常的高水平，可能预示着市场即将陷入困境。这是因为，上升的持仓量意味着新的空头者和新的多头者正在进入市场。如果市场处于稳步上涨的上升趋势中，那么，这些新的多头者将会随着价格水平的逐步上升，逐步提高卖出止损指令的水平。万一价格突然下滑，将引发执行止损指令的连锁反应，有可能导致价格的狂泻。图15.7所示的实例很好地体现了上述道理。该图选自原糖市场。从3月初开始，在2个月之内，市场始终在从0.15美元到0.16美元的区间中波动。在4月下旬发生的最后一段上涨行情中，持仓量发生了显著的增长。到5月初，持仓量已经达到了很不寻常的高水平。随着这个上涨行情的发展，新的多头者的卖出止损水平也就水涨船高，逐步抬升到较高的价位。这时出现了一系列十字线，它们暗示市场已经转入犹豫不决的状态，可能形成一个顶部。5月4日，市场受到打压，于是，一个止损指令接着一个止损指令被触发，如同多米诺骨牌，结果，市场直线下跌。 图15.7 原糖——1990年7月，日蜡烛图（持仓量与蜡烛图） 这种高水平的持仓量还有另一方面的特点。有一部分新的多头没有能够止损出市，被套牢在较高的价格水平上。这是因为随着持仓量的累积，新的多头和新的空头不断涌入市场。但是，由于这场急转直下的下跌行情，价格已经回落到了2个月内的最低水平。凡是在过去两个月中买进者，现在都处于亏损状态。那些在接近价格高点处买进的多头者更是备受“煎熬”。从接近0.16美元的高水平处的高额持仓量来判断，很可能有不少多头处在这种“备受煎熬”状况中。那么，他们将利用一切可能的上涨行情来平仓出市。这种情景展现在5月中旬。当时市场曾经形成了一段较小的上涨行值，达到了0.15美元，于是马上招致了沉重的抛售压力。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四章 蜡烛图与摆动指数]]></title>
    <url>%2F2021%2F03%2F06%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E6%91%86%E5%8A%A8%E6%8C%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“寸有所长，尺有所短”。 图表形态识别技术常常带有主观色彩（这当然也包括蜡烛图技术）。不过，摆动指数是经过数学运算得出的一种技术工具，利用它来分析市场，能够得出更加客观的结论。人们广泛地应用了这类工具，它们也构成了很多计算机化交易系统的基础。 摆动指数所谓摆动指数，包括下列各种技术分析工具相对力度指数，随机指数，以及动力指数等。 摆动指数能够从如下三个方面为交易者提供帮助。本章后面的内容将要对这些内容展开深入的探讨。 1、摆动指数可以用作相互验证/相互背离指标（这就是说，当价格运动方向与摆动指数变化方向不一致时，就构成了一个相互背离信号）。摆动指数能够发出警告信号，说明当前价格趋势也许即将陷入停顿。摆动指数与价格有两种相互背离的情况。一种是负面相互背离，或者说看跌相互背离，指当价格创出新高的时候，相应的摆动指数却没有达到新高，这意味着市场在本质上是疲弱的。另一种是正面相互背离，或者说看涨相互背离，指当价格处于新低的时候，相应的摆动指数却没有形成新低，这意味着当前市场的抛售压力正在衰退。 2、摆动指数也可以用作超买/超卖指标。摆动指数能够告诉交易者，当前市场行情是不是向某一方向伸展得太过分了，因而容易引起调整行情。不过，当我们采用摆动指数来作为超买/超卖指标时，必须谨慎从事，因为摆动指数在构造方法上的原因，它们主要适用于水平延伸的市场环境。在某个新的主要趋势刚刚开头的时候，如果我们只靠摆动指数来作为起买/越卖指标，则可能引出问题。举例来说，如果市场向上突破了一个水平调整的区间，这可能意味着新的牛市阶段的开端，但是与此同时，摆动指数可能总是维持在超买状态下。 3、摆动指数还能够用来衡量市场运动的力度。因此，可以利用它们检验一轮趋势性运动背后市场力量的大小。例如，动力指数通过对价格变化幅度的比较，显示了价格运动的速度。从理论上说，随着趋势的发展，价格变化速度也应当逐步加快。如果在趋势发展过程中，动力指数变成水平伸展，可能构成了一个早期的警告信号，说明当前价格运动正在减速。 在顺应当前主流趋势方向的条件下，我们可以采用摆动指数的信号来建立头寸。于是，当看涨的摆动指数信号出现时，如果当前主要趋势是上升的，则应当买进做多；如果当前主要趋势是下降的，则应当平回空头头寸。对于相反的摆动指数信号，我们应当采取与上述相同的应对办法，只是方向相反。绝不可仅仅因为出现了一个看跌的摆动指数信号，就卖出做空，除非当前的主流趋势方向向下。如果没有这样的先决条件，那么我们只能够利用这个看跌的摆动指数信号来出清多头头寸。 相对力度指数在期货交易商中，相对力度指数（RSI）是最流行的技术工具之一。许多图表服务机构提供RSI的图表，很多交易者密切关注这项技术指标。RSI比较了一段时间内价格的上涨与下跌之间的相对力度。在RSI研究中9天和14天是最常用的两种时间参数。 如何计算RSI RSI的计算方法是，首先分别累加出一定时间之内上涨的价格幅度之和与下跌的价格幅度之和，然后再求得两者的比值。在计算过程中，一般仅采用收市价作为价格数据。它的计算公式是：RSI=100-（100/（1+RS）） 其中，RS=该时期上涨价格幅度的平均值/该时期内下跌价格幅度的平均值。因此，当我们计算14天的RSI的时候，首先将这14天内上涨了的收市价的上涨幅度相加（按照收市价对收市价的方式），再将所得的和除以14。然后，对其中下跌的日子进行同样的计算，从这两个数值就得到了相对力度的值RS。最后，我们把RS的值代人到RSI的公式中去。RSI公式将RS的值转化为指数形式，并且使得该指数的取值范围在0到100之间。 如何运用RSIRSI的两个主要的用途是，构成超买/超卖指标，作为监测相互背离现象的工具。RSI作为超买/超卖指标的使用方法是，当RSI向上趋近其取值范围的上边界时（即，当它高于70或80时），表明市场处于超买状态。在这样的情况下，市场也许变得比较脆弱，容易引发向下回落的过程，或者即将转入横向调整阶段。与此相反，当RSI处于其取值范围的下边界时（通常低于30或20），则认为RSI反映了超卖状态。在这样的环境下，市场有可能形成空头买入平仓行情。 利用RSI揭示相互背离现象的具体方法是，当价格向上创出当前趋势的新高时。RSI却没有形成新高，未能与之配合，这就构成了一个负面相互背离信号，可能是一个看跌信号；当价格向下跌出当前趋势的新低时，RSI却没有形成新低，则构成了正面的相互背离现象，在相互背离现象出现时，如果RSI摆动指数的数值正处在超买区或超卖区，则相互背离现象具有更强的技术意义。 在图14.1中，既显示了一个看涨的正面RSI相互背离现象的例子，也显示了一个看跌的负面RSI相互背离现象的例子，两者分别为蜡烛图分析提供了参考依据。在1月24日的低点处，RSI的数值为28％、二月31日，市场形成了当前趋势的新低点。此时。RSI的数值是39％、这个数字明显高于1月24日的28％，新低价格水平对应着较高的RSI水平，构成一个看涨的正面相互背离信号。除了该正面相互背离信号之外，1月31日的白色蜡烛线覆盖了前一根黑色蜡烛线，产生了一个看涨的吞没形态。 如图所示，3月14日是一根十字星线。次日，市场又形成了一根近似于上吊线的蜡烛线（这一天的下影线不够长。因此不能算作一个标准的上吊线）。就在上述潜在的看跌蜡烛图信号出现的同时，RSI也发出了一个警告信号。具体来说就是，对应于3月15日和16日的价格新高峰，RSI图线却呈现出逐步降低的局面。这就形成了一个看跌的负面相互背离信号。3月21日，市场又发动了另一轮向上的冲击，尽管这里也形成了价格新高，但是RSI的水平依然持续下降。结果，市场向下回落，一直达到了 3月形成的位于1.11美元处的支撑区。 图14.2所示为从一个看跌吞没形态开始的下跌行情终止于一个刺透形态。从这个刺透形态看，市场的前景具有建设性。这一技术意义得到了RSI的正面相互背离现象的支持。有些技术分析师也对RSI的图线进行趋势线分析。在这一实例中，尽管3月29日价格创出了新低，但图示的RSI上升趋势的支撑线却维持着它的有效地位。 图14.2解释了我们将蜡烛图与 RSI结合起来的另一个理由。有时候，RSI需要得到进一步的验证才能构成交易信号，而蜡烛图也许能抢先第三者一步，发出这样的看涨或看跌验证信号，具体说来，如果RSI先后满足了下列二个条件，有些技术分析者就将之归结为一个看涨信号。首先，RSI必须与价格形成正面相互背离；其次，RSI必须向上涨过前一个高点。在这一实例中，这就意味着RSI必须向上超过4月20日的数值（如点A所示）。根据上述要求，只有等到点B处，RSI的看涨信号才能够最后完成。然而，通过前面讨论的看涨蜡烛图指标（那根刺透线）与RSI正面相互背离信号的综合分析，早在点B几天之前，我们就有可能得出这个看涨信号。 在上升趋势的发展过程中，十字线的出现是一个警告信号。但是，同所有的技术线索一样，这也可能使我们误入歧途。如果我们要把这种误导的技术信号过滤掉，那么，参照其它的技术分析工具是一个办法。图14.3显示了利用 RSI作为其验证工具的一个实例。5月中旬，市场形成了一根看跌的流星线，以及一系列十字线（点A所示的期间人这些信号标志当前的上升趋势已经结束，因此至少在此后的数周里，市场暂时转入一个水平的交易区内中.经过这个调整阶段后，市场在自B处形成了一轮上涨行情，将价格推到了新高水平。此处的新高价格水平，比A点处高点的水平高100个点.不过，在点B处,RSI的值却还处在点A处的水平。这反映出市场内部的上升动力已经有所不济。在点B处，还有一个孕线形态，这又为我们拉响了一次警报。 在点B所示的期间，市场从高位向下回落了100点。经过这一段调整，市场再度形成一段上涨行情。经过这一次上涨，市场在点C处向上触及了3000点的水平。此时的新高价位已经向上急剧地超越了点B处的市场价位，但是与此形成鲜明对照的是，RSI的水平却明显降低了。在点C处，除了上述看跌背离信号之外，市场还形成了图示的一根流星线一根十字线以及一根上吊线。这些蜡烛线的出现说明，尽管价格达到了新，但是市场的内部架构已经摇摇欲坠了。 随机指数对期货市场的技术分析者来说，随机（摆动）指数也是一种常用工具。作为一种摆动指数，它既提供了超买和超卖状态的读数指示，也能够揭示相互背离现象，还提供了一套比较短期趋势与长期趋势的机制。随机指数把最近的收市价格，同一定时间范围内市场的总的价格范围进行比较。随机指数的数值处在0到100之间。当随机指数的读数较高时，就意味着当前的收市价格在一定时期的整个价格范围中接近上端的水平。当随机指数读数较低时，就意味着当前的收市价格在一定时期的整个价格范围中接近下端的水平。随机指数的设计思想是，当市场向上运动时，收市价格倾向于接近上述价格区间的高点；当市场向下运动时，价格往往集中在上述价格区间的低点附近。 如何计算随机指数随机指数的图表由两根曲线组成，它们分别是％K线和％D线。其中，％K线称为原始随机线，或者称为快％K线。这条曲线最为灵敏，％K线值的计算公式是：（收市价-N天内的最低价）/（N天内的最高价-N天内的最低价）*100%＝％K其中，收市价=当前收市价；N天内的最低价=N天内总的价格范围的最低价N天内的最高价=N天内总的价格范围的最高价 公式中的数值‘100”将公式的数值转化为一个百分数值。因此，如果今天的收市价与我们所研究的时间范围内最高价一致，那么快％K值就等于100。上述的时间范围既可以选择为若干天，也可以选择为若干星期，甚至可以选择为若干个日内时间单位（比如若干小时）。9、14、21个时间单位是几个较为常见的时间参数。 因为快％K线十分起伏不定，所以通常我们以这条线为基础，每三个数值计算出一个移动平均值，得出一条较为平滑的三时间单位移动平均线。这条％K线的三时间单位移动平均线就称为慢％K线。绝大多数技术分析师用这条慢％K线代替那条变化无常的快％K线。下一步，我们对这条慢％K线再进行一次三时间单位的移动平均。得到了慢％K线的三时间单位移动平均线，称为％D线。实质上，这条％D线是移动平均线的移动平均线。如果想要弄清楚上述％K线与％D线之间的区别，那么我们不妨把它们设想为一个双移动平均线组合，其中慢％K线相当于一条较短期的移动平均线，而％D线相当于一条较长期的移动平均线。 如何应用随机指数前面曾经说过，我们可以按照几种不同的方式来使用随机指数。其中最为常见的用法是将它用来揭示相互背离现象。绝大多数技术分析师在应用随机指数时，既从相互背离这一方面来跟踪随机指数的变化，也注意其读数是否显示了市场的超买/超卖状态。 有些技术分析师还采用了另一种研读随机指数的方法。这种方法约定，当慢％K线向下穿过％D线时，构成卖出信号；当慢％K线向上穿过％D线时，构成买入信号。这一点与双移动平均线的用法有相似之处。在双移动平均线系统中，当较快的移动平均线向上穿越（或向下穿越）较慢的移动平均线时，就形成了买入信号（卖出信号）。具体说来，为了构成一个买入信号，需要满足以下三个条件；首先，市场必须处在超卖状态（随机指数的％D值为25％或更低）；其次，市场已经发生了正面相互背离现象；最后，慢％K线向上穿越了％D线。 请看图14.4所示的实例。1月3日是一根十字线，应当引起我们的警惕。如果一根十字线跟随在一根长长的白色蜡烛线之后，则显示“苗头不对”。在该十字线当天，市场向上推过了12月的高点，创出了新高水平。但是在其随机指数曲线上，并没有相应地形成新高，未能呼应价格的新高。这样一来，就形成了一个看跌的负面相互背离现象。对于蜡烛图十字线的看跌信号来说，这是一个重要的验证信号。有些技术分析者不满足于上述背离现象，还进一步期待％K线向上穿过％D线。请看图14.5。1989年年中，铜市场通过一根锤子线形成了底部反转。1990年初，市场上又出现了一系列的锤子线。这批锤子线是否标志着另一个市场底部的形成呢？答案很可能是肯定的，因为随机指数为我们提供了新的证据。锤子线B向下突破了锤子线A的低位，形成了新低水平。但是，在锤子线B处，随机指数的读数却高于锤子线A处的读数。这是一个正面相互背离信号。它的技术含义是，市场的卖出压力正在减弱。 另一方面，在随机指数上还发出了一个正面的交叉信号，即波动较频繁的实线——％K线——向上穿越了虚线％D线（如箭头所指）。一般认为，如果这类交叉信号发生在随机指数处于超卖读数的情况下，即当它低于25％时，则其技术意义更为重要。综上所述，在1990年初，市场出现了一系列近似的锤子线，形成了一个正面相互背离信号。最后还有一个发生在超卖市场状态下的随机指数正面交叉信号。上述技术指标汇聚在一起，构成了说服力极强的技术线索，表明之前的下降趋势已经完结。 如图14.6所示，4月12日和16日形成了一个乌云盖顶形态。在4月16日的黑色蜡烛线上，市场将价格推到了前一个高点，即3月的最高点之上。于是，价格创出了新高水平，但是，其随机指数却没有形成新高。上述乌云盖顶形态，加上这个负面相互背离现象，两个信号均要求我们在面对市场进一步的上涨行情时必须谨慎从事。当下一步的下降行情开始时，较快的％K线向下穿越了较慢的％D线（如图示的话号所指），形成了一个负面交叉信号，从而验证了当前的下跌趋势。我不经常使用蜡烛图来研究英镑期货市场，因为它的许多交易日都具有较小的实体，或者干脆就是十字线。如图14.7所示，我们不难看出这一点。此外，在期货市场夜间关闭的时候，外汇市场仍然继续交易，因此，在这张图表上经常形成价格跳空（其它几种汇率期货也存在类似的问题）。尽管如此，在某些情况下，有些蜡烛图信号还是值得重视的，特别是当这些信号得到了其它方面技术指标的验证的时候，要得慎重。 在3月19日所在的一星期中，市场上出现了一个启明星形态的变体。通常情况下，启明星形态的第三根白色蜡烛线最好能够显著地向上推进到第一天的黑色蜡烛线的实体之内。这里的第三根白色蜡烛线不符合这样的理想状况。如果要判断某个形态的一种变体到底具有多大的份量，就应当扫描一下其它方面的技术证据。就在这个启明星形态（准确地说，是启明星形态的变体）出现的时候，价格向下触及了新低水平，但随机指数没有达到新低。这就构成了一个看涨的正面相互背离信号。此后不久，％K线便向上穿越了％D线，证实了这个背离信号。这样一来，虽然这个启明星形态并不符合理想条件，但是这一点欠缺只不过使我们稍稍推迟了市场底部已经形成的结论。随机指数为上述分析提供了充分的旁证。 动力指数动力指数又称为价格速度指数。该指数度量的是，当前的收市价格与一定天数之前的收市价格之差。如果我们研究10日动力指数，那么我们比较的就是今天的收市价与10日之前的收市价。如果今天的收市价高于10天前的收市价，那么在动力指数的数轴上，今天的动力指数数值就是一个正值。如果今天的收市价低于10天之前的收市价，那么今天的动力指数值就取负值。从动力指数的角度来看，在上升趋势的发展过程中，上述价格差（今天的收市价与我们选择的天数之前的收市价之差）应当以逐步加快的速度增长。这样的情况显示了该上升趋势具有逐步增长的驱动力。换句话说，价格变化的速度也在加快。如果价格上涨，而动力指数转为持平，那么说明阶格趋势处于减速状态。这可能构成了一个早期的警告信号，说明当前的价格趋势可能会结束。如果动力指数向下越过零线，则形成了一个看跌信号；而当它向上穿越零线时，则是一个看涨信号。动力指数也是一种现成的超买/超卖指标。举例来说，当动力指数为一个相对较大的正值时，市场可能就处在超买状态，容易发生回落行情。动力指数通常在价格达到顶峰之前预先达到顶点。根据这一特点，当动力指数处于极为超买的读数状况时，可能预示着一个价格高峰的形成。 在图14.8中，1月的长腿十字线是一个警告信号，此时多头者应当留神了。这里还有其它因素也令人担心。在这根十字线上，价格创出了新高水平，但是相应的动力指数却显著地低于去年11月形成的前一个高点（如点A所示）的水平。2月初，动力指数明显地向下跌过了零线，这是进一步的证据，表明下降趋势可能即将来临。 动力指数的另一种用途是，它能够为市场的超买或超卖状态提供一个具体尺度（如图14.9所示）。在这张取暖油市场的图表上，请注意数值为十200左右的动力指数读数（这就是说，当前的收市价比10天前的收市价高0.02美元）是如何代表着市场的超买状态的。对于这个市场来说，当动力指数处于一400点时，或者说在当前收市价比10天前的收市价低0.04美元的情况下，代表着市场的超卖状态。在200点的超买水平上，之前的上涨行情不可能继续发展，市场要么转入横向交易区间，要么形成回落行情。如果当动力指数处于超买状况时。同时出现了看跌的蜡烛图验证信号，那么出现顶部反转过程的机会就大为增加了。从这一点来看，2月份动力指标的超买状况恰巧与先后出现的一个黄昏星形态、一个孕线形态不期而遇。4月初，动力指数的超买状况与另一个黄昏星形态不谋而合。锤子线A和锤子线B分别伴随着3月份和4月份的动力指数超卖水平的出现。在这两点处，出现进一步的抛售行情的可能性甚微，市场要么通过横向延伸的价格行为，要么通过上涨行情来消解当前的超卖状态。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三章 蜡烛图与移动平均线]]></title>
    <url>%2F2021%2F03%2F05%2F%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“十个人十个口味”。 移动平均线是最早采用的、也是最流行的技术分析工具之一。这种工具的长处就在于，它构成了一套追踪趋势的机制，使得技术分析者有能力捕获主要的市场运动。因此，当市场处在趋势明显的状态时，这种工具最能发挥效能。无论如何，因为移动平均线是一种滞后的技术指标，所以只有在趋势形成之后，它才能捕捉到这种市场变化。 简单移动平均线名符其实，最基本的移动平均线是所谓简单移动平均线。计算出有关价格数据的算术平均值，就得到了这样的平均线。举例来说，假定黄金市场最近的5个收市价格分别为380美元、383美元、394美元、390美元、382美元，那么，上述收市价的5日移动平均值就是： $$\frac{($380+$383+$394+$390+$382)}{5}=$385.8$$其一般公式为： $$\frac{(P1+P2+P3+P4+P5)}{N}$$其中，P1=最近的收市价；P2=最近的收市价的前一个收市价，余者依此类推；N=移动平均的数据点数。 在“移动平均线”术语中，“移动”的意思是，当我们计算新的平均值时，一般先从前一个移动平均值中减去最早的那个价格数据，然后再把最新的价格数据加到这个数值上。如此一来，随着新的数据的不断加入，平均值也就向前移动了。 从上述关于简单移动平均线的例子中我们可以看到，每一天的黄金价格在总的移动平均值中占有1/5的份额（因为这是5天移动线平均的例子）。在9天移动平均值中，每一天的价格在总的移动平均值中仅占1/9的份额。由此可见，移动平均线的时间参数越大，则单个的价格数据对平均值的影响越小。 移动平均线的时间参数越短，则移动平均线越“贴近’价格图线。这类平均线对当前的价格变化更为敏感，从这个意义说，这是其有利的一面。它也有不利的一面，那就是引发“拉锯现象”的可能性也同时加大了。长期的移动平均线提供了较强的平滑效果，但是它们对当前的价格变化较为迟钝。 在比较流行的移动平均线中，对短线的交易商来说，包括4天、9天、18天移动平均线；对操作长期头寸的市场参与者来说，包括13周、26周、40周移动平均线。在日本，13周和40周移动平均线最为常用。使用移动平均线的市场参与者范围极广，其中既有日内交易商，也有保值交易商。前者对实时的交易数据应用移动平均方法，而后者眼里的移动平均线可能是按月、乃至按年来计算的。 在移动平均线的研究方法中，除了选择不同的时间参数之外，还有可能选择不同的价格数据来计算平均值。正如我们在前面的例子中所介绍，绝大多数移动平均线系统采用收市价格进行计算。不过，利用最高价、最低价，以及最高价与最低价之间的中间价来计算移动平均线的也大有人在。有时候，人们甚至用上了移动平均线的移动平均线。 加权移动平均线在加权移动平均线的计算方法中，先对每一个有关的价格数据分配一个不同的权重，再计算它们的平均值。几乎所有的加权移动平均线都采取“前沿加重”的方式。这就是说，最近价格数据的权重显著大于过去价格数据的权重。分配权重的具体做法，取决于研究者个人的偏好。 指数加权移动平均线与MACD摆动指数指数加权移动平均线是一种特殊的加权移动平均线。与一般的加权移动平均线一样，指数加权移动平均线也采取前沿加重方式。不过，与其它移动平均方法不同的是，在指数加权移动平均值的计算方法中，包括的不是一段数据，而是所有历史数据。在这种移动平均方法中，对全部历史价格数据分配了逐步减少的权重，每一个价格数据的权重都对后来的一个价格数据的权重按照指数形式递减。因此，这种方法就得到了所谓指数加权移动平均线的名称。 指数加权移动平均线最常见的用处之一，是应用在MACD方法中（移动平均线相互验证／相互背离交易法）。MACD方法由两条曲线组成。第一条曲线表示的是两条指数加权移动平均线的差（通常采用26个时间单位和12个时间单位的两条指数加权移动平均线）。第二条曲线，是第一条曲线的指数加权移动平均线（通常采用9个时间单位作为时间参数），即第一根曲线所表示的两根指数加权平均线之差的指数加权平均线。第二条曲线称为信号线。在讨论图13.7和13.8所示的实例时，我们还要进一步探讨MACD方法。 移动平均线的用法移动平均线能够为我们提供客观的交易策略，其中包括定义明确的交易规则。许多计算机化的技术型交易系统主要建筑在移动平均线的基础之上。怎样应用移动平均线呢？这个问题的答案多种多样，从不同的交易风格和交易哲学出发，就有不同的取舍。以下，我们列出了移动平均线的一些常见的用法。 1、通过比较价格与移动平均线的相对位置，构成一个趋势指标。举例来说，如果我们判断市场正处于中期的上升趋势中，那么有一个很好的衡量标准，就看价格是不是居于65天移动平均线的上方。而对于更长期的上升趋势来说，价格必须高于40周移动平均线。 2、利用移动平均线构成支撑水平或阻挡水平。当收市价向上超越某一条特定的移动平均线时，可能构成看涨的信号。而当收市价向下低于某个移动平均线时，构成看跌的信号。 3、跟踪移动平均线波幅带（也称为包络线）。这些波幅带是将移动平均线向上或向下平移一定的百分比后形成的，它们也起到支撑或阻挡作用。 4、观察移动平均线的斜率。举例来讲，如果移动平均线在一段持续稳步的上升之后转向水平发展，乃至开始下降，那么可能构成了一个看跌信号。在移动平均线上作趋势线，是监测其斜率变化的一个简单易行的办法。 5、利用双移动平均线系统来交易。这一方法本章稍后还要详细讨论。 在下面介绍的实例中，我们采用了各种移动平均线。它们的时间参数并不是按照最优化的要求选择的。今天最优的移动平均线，明天未必还是最优的移动平均线。这里既选用了一些人们广泛使用的移动平均线。也选用了一些不那么流行的移动平均线，不过，后者是以诸如菲波纳奇数字这样的工具为基础的。具体应当采用什么样的移动平均线。并不是我们这里的核心问题。我们真正关心的是，如何将移动平均线与蜡烛图技术综合起来。 我喜欢选用65天的移动平均线作为一种广谱的移动平均线。从我个人的经验来看，这种平均线似乎在许多期货市场上都有良好的表现。如图13.1所示，在①、②、③点所示的区域，一条65天移动平均线数度为市场提供了支撑。在这几处，除了该移动平均线为市场提供了支撑作用以外，我们在点①处看到了一个看涨吞没形态，在点②处还看到了一根锤子线和一个孕线形态，在点③处则是另一个锤子线。 图13.1 大豆——1990年7月，日蜡烛图（简单移动平均线与蜡烛图） 如图13.2所示，4月2日和3日，若干技术因素汇集在一起。明眼的朋友由此可以得到一个警告信号：危机就在眼前。我们不妨具体分析一下这些技术因素。 图13.2 原油——1990年6月，日蜡烛图（简单移动平均线与蜡烛图） 1、早在3月初，价格已经向下跌破了65天移动平均线。从这一点看，这条移动平均线已经转化为一条阻挡线。 2、4月2日和3日的两根蜡烛线形成了一个乌云盖顶形态。同时，这个乌云盖顶形态也标志着市场向上试探由这条移动平均线构成的阻挡水平的失败。 3、4月3日不只是完成了上述乌云盖顶形态，也不仅是对该移动平均线的试探的失败，它与从A到B的下跌行情的50％回撤水平仅有7个基本价格单位的差距。 如图13.3所示，市场在2月份对65天移动平均线进行了试探，并形成了一根锤子线，从而验证了由该平均线形成的支撑水平。几天之后，市场重新向下试探了这些低点，进而形成了一个平头底部形态。 图13.3 原糖——1990年5月，日蜡烛图（简单移动平均线与蜡烛图） 双移动平均线两根移动平均线组合在一起的用法有很多种类，其中之一，是将它们构造成一个超买/超卖指标，也就是摆动指数。把较短期的移动平均线减去较长期的移动平均线，就得到了这个摆动指数的值。该指数既可以是正值，也可以为负值。当它的数值大于0时，就意味着较短期的移动平均线处在较长期的移动平均线的上方。当它的数值小于0时，就意味着较短期的移动平均线处在较长期的移动平均线的下方。这类做法的实质，是将短期的市场力度同长期的市场力度进行比较。正如我们前面所讨论的，因为短期移动平均线对最近的价格变化更加敏感，如果短期移动平均线相对来说较大幅度地高于（或低于）长期移动平均线，那么我们就认为市场处于超买状态（或超卖状态）。 双移动平均线的第二种用法是，通过观察短期移动平均线与长期移动平均线的交叉，获得交易信号。如果短期的移动平均线向上或向下穿越了长期移动平均线，可能就是趋势变化的一个早期警告信号。举例来说如果短期移动平均线向上穿越了长期移动平均线，这就是一个看涨信号。在日本，这样的移动平均线交叉信号称为黄金交叉。于是，如果3天移动平均线向上穿越了9天移动平均线，则构成了一个黄金交叉，与上述相反的情形，在日本的术语中称作死亡交叉。当短期移动平均线向下穿越长期移动平均线时，就构成了一个看跌的死亡交叉信号。 有些技术分析者监测当前的收市价与5天移动平均线之间的相互关系，以此构成一个短期的超买/超卖指标，如图13.4所示。举个例子。如果铜的5天移动平均值为1.10美元，当日的收市价为1.14美元，那么，铜市场就具有0.04美元的超买程度。在本图所示的实例中，下半图的曲线就是由当前的收市价与5天移动平均线的差构成的。从这张图表可以看到，通过这种双移动平均线方法（可以将收市价看成时间参数为1的移动平均线——译者注）我们就能够了解，当它达到400点的超买水平（也就是说0.04美元）时，市场就变得较为脆弱——特别是在同时具备看跌的蜡烛图验证信号的情况下。在点①所示的期间，下图的数值处于超买状态，同时上图有一个孕线形态。在点②所示的期间，下图的超买状态撞上了另一个孕线形态；在点③所示的期间，超买状态碰到了一根十字线；在点④处，超买状态又遇到了一个孕线形态。市场既可以通过抛售行情，也可以通过横向伸展行情来释放其超买状态。在本例中，在点①和③所示的期间，超买状态是通过横向伸展行情而得以释放的。在点②和④所示的期间，则分别借助了两段抛售行情。通常，当市场处于超买状态时，不应当卖出做空。当然，多头者面对这种市场状态，应当采取保护性措施。在超卖的市场上，则应当采取与上述相反的应对措施。 图13.4 铜——1990年9月，日蜡烛图（双移动平均线与蜡烛图） 我们也可以把两条移动平均线同时绘制在相应的价格图表上。正如前面所说的，当较短期的移动平均线向上穿越了较长期的移动平均线时，构成了一个看涨信号，日本分析师称之为黄金交叉。在图13.5中，既有一个看涨的黄金交叉，也有一个平底锅底部形态。这个平底锅底部形态得到了7月2日的窗口的验证。请注意，这个窗口在7月上半个月是如何起到支撑作用的，还请注意，图示的较短期移动平均线是如何在市场的上涨行情中起到支撑作用的。 图13.5 德国马克——1990年9月，日蜡烛图（双移动平均线与蜡烛图） 我们还可以利用两条移动平均线之差作为寻找相互验证/相互背离信号的工具。当价格上升时，技术分析师希望看到，短期移动平均线与长期移动平均线之间的距离也不断地扩大。这就意味着，表示两条移动平均线之差的曲线处于正值区内，并且其数值逐步增大。如果价格上涨，而短期移动平均线与长期移动平均线之间的差距却在缩小，那就表明，短期的市场力度正难以为继。这个迹象暗示上涨行情可能行将结束。 在图13.6中，我们利用刷形图的形式显示了两条移动平均线之差。在点1和2所示的期间里，一方面价格在上涨，另一方面短、长期移动平均线的差距也在扩张，从而呼应了市场趋势。这就说明，较短期的移动平均线比较长期的移动平均线上升得更快。这是个好的征兆，显示当前的上升趋势仍将持续。在点3所示的期间内，市场碰到了问题。从2月23日开始，市场形成了一轮幅度达0.50美元的上涨行情，但是与此相对照，其移动平均线之差却处在收缩过程中。这就反映出短期市场力度的减弱。雪上添霜的是，此处还形成了一个乌云盖顶形态，因此市场已经较为脆弱，容易酿成价格回抽行情。 图13.6 原油——1990年6月，日蜡烛图（双移动平均线与蜡烛图） 这张刷形图也能够揭示短期移动平均线向上或向下穿越长期移动平均线的交叉信号。当刷形图处于零线之下时，短期移动平均线位于长期移动平均线的下方。当刷形图处于零线之上时，短期移动平均线位于长期移动平均线的上方。因此，当摆动指数向下穿越零线时，代表了一个看跌的死亡交叉信号；当它向上穿越零线时，代表了一个看涨的黄金交叉信号。 在A点所示的时间上，出现了一个黄金交叉信号。在形成该黄金交叉数日之前，市场还产生了一根看涨的倒锤子线。在B点处，发生了一个死亡交叉信号。在点C所示的期间，价格曾有所上涨，但是短期移动平均线却不能穿越到长期移动平均线的上方（这就是说，该摆动指数维持在零线之下）。另外，4月2日和3日，还形成了一个乌云盖顶形态，它也发出了看跌信号。 在MACD方法中，也用到两条曲线。在图13.7的下半图上，显示了这样的两条曲线。其中的实线起伏较为频繁，这是信号线。当这条信号线向下穿越图示的较平缓的虚线时，构成卖出信号。在这一实例中，有两个看跌的吞没形态，它们的看跌意义都得到了对应的MACD指标看跌交叉信号的进一步印证（请看箭号所指之处）。 图13.7 美国长期国债——1990年9月，日蜡烛图（MACD与蜡烛图） 如图13.8所示。在这张MACD图上，7月初（请看剪号所指之处），信号线向上推过了另一条较平缓的曲线。这就给出了一条引人注目的线索，说明市场也许正形成一个底部。再看看蜡烛图。第一个启明星形态的看涨意义被之后的乌云盖顶形态抵销了。由该乌云盖顶形态开始的下跌过程终止于另一个启明星形态。后来，虽然由于图示的上吊线的出现，市场形成了短暂的回落，但是市场的上升力度很快就恢复了。 图13.8 咖啡——1990年9月，日蜡烛图（MACD与蜡烛图）]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二章 蜡烛图与百分比回撤水平]]></title>
    <url>%2F2021%2F03%2F05%2F%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E7%99%BE%E5%88%86%E6%AF%94%E5%9B%9E%E6%92%A4%E6%B0%B4%E5%B9%B3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“功到自然成”。 通常，市场既不会直线上升，也不会竖直跌落，而是进两步、退一步。在当前趋势继续发展之前，市场通常先要对已经形成的上涨进程或下跌进程作出一定程度的回撤。在这类回撤水平中，较为常用的是50％回撤水平，以及38％和62％的菲波纳奇回撤水平（如图12.1和12.2所示）。菲波纳奇是13世纪的一位数学家，他推导出一组特殊的数列。用不着太深的研究，只要我们把这些数字相互除一下，就能够推算出一组比例数——毫不奇怪，这当然就是菲波纳奇比率。 在这组比率中，包括61.8％（或者它的倒数1.618）和38.2％（或者它的倒数2.618）。这正是62％（61.8％取整）回撤水平和38％（38.2％取整）回撤水平之所以广为流行的原因。常见的50％回撤水平也属于菲波纳奇比率。50％回撤水平可能是最受人关注的一个价格水平。这是因为，不论是信奉江恩理论者，还是奉行艾略持波理论者，或者道氏理论的拥护者，统统应用了50％回撤水平。 如图12.3所示，百分比回撤水平能够有效地帮助我们预测一轮熊市中的阻挡区域。在图示的黄金市场上，在过去的数年中，50％回撤水平一直是一个重要的阻挡水平。下面我们就来看看本图中3个具体的实例。在这些例子中，50％回撤水平同蜡烛图技术融为一体，为我们提供了重要的顶部反转信号。 图12.3 黄金——周蜡烛图（蜡烛图上的百分比回撤水平） 50％回撤实例1——点A所示的高点（位于502美元）出现在1987年，是在一个看跌吞没形态中形成的。从1987年底开始的抛售行情终止于B点所示的刺透形态，此处为425美元。根据从A到B所示的这段抛售行情的50％回撤水平，市场在464美元处应当遭遇一个阻挡水平（首先将A处高点的价格减去B处低点的价格，再把其差除以2，然后把这个结果加到B处低点的价格上，就得了这个数字）。因此，在464美元处，我们将仔细观察阻挡作用的发生，并且密切关注看跌的蜡烛图指标的出现，以验证这一阻挡水平。在点C处，果真形成了一个看跌吞没形态。同时，C处最高点的价格是469美元，换言之，它与50％回撤水平仅有5美元之差。之后，市场开始了下一阶段的下跌行情。 50％回做实例2——从C处开始的抛售行情，终止于D处的一个启明星形态。从C处的高点469美元的水平出发，到D处的低点392美元的水平，其50％回撤水平在430美元，这是一个阻挡区。由此看来，在这一水平附近应当出现看跌的蜡烛图验证信号。在点E所示的区域，黄金市场达到了433美元的水平。在这两根蜡烛线上（11月28日所在的一周和12月5日所在的一周，后者即点E处），只差0.50美元，黄金市场就可以形成一个看跌的吞没形态。从E点开始，又发生了一轮下跌行情。 50％回撤实例3——从E处的高点，到1989年F处的低点（为357美元），价格下跌幅度为76美元。（有意思的是，在上述三段抛售行情中，即从A到B、从C到D、从E到F的三段行情，价格下跌的幅度差不多都是77美元。）在6月5日的低点处，事先没有出现显示底部反转的蜡烛图指标。9月份，市场第二次向下尝试了这个低点，并形成了一根近似锤子线的蜡烛线。 下一个阻挡水平，也就是从E到F的下跌过程的50％回撤水平，是395美元。黄金市场价格后来向上超越了这一水平。不过，这一点并不太值得吃惊。为什么呢？这是因为，在1989年底，黄金市场向上突破了一条为期2年的阻挡线。另一方面，1989年黄金市场还在357美元的水平处形成了一个双重底反转形态，建筑了一个坚实的底部。如此一来，我们就不得不从更大规模上着眼，寻找更大价格运动的50％回撤水平。这就意味着，我们应当计算自1987年的高点A处到1989年的低点F处的整个下跌过程的50％回撤水平。由此提供了一个位于430美元的阻挡水平。在430美元附近，在11月20日所在的一周（点G处），市场发出了两个信号，标志着当前的上升趋势已经陷入重围.这两个信号就发生在425美元的水平上。其中一个是孕线形态，另一个是一根上吊线，并且后者是该孕线形态的一部分。几周之后，即在1月22日所在的一周，市场达到了当前趋势的顶峰，425美元。接下来一周的价格变化形成了另一根上吊线。从这里起，黄金市场开始下跌。 请看图12.4。位于18美元（点A处）的一个平头底部形态，与一个孕线底部形态结合在一起，构成了一轮幅度达3.50美元的上涨行情的起点。这轮上涨行情在22.15美元（点B处）以一个看跌的吞没形态收场。从A到B的上冲过程的50％回撤水平是20.36美元，意味着这将是一个支撑水平。在点C处，一个看涨的刺透形态形成于20.15美元。从C点开始，市场形成了一度较小的上升行情。因为点D处的乌云盖顶形态的出现，这段上升行情出了问题。有趣的是，点D处的最高点为21.25美元，它与从 B到C的下跌行情的50％回撤水平仅有10个基本价格单位的差距。 图12.4 原油——1990年5月，日蜡烛图（蜡烛图上的百分比回撤水平） 如图12.5所示，从A到B的上涨行情的62％菲波纳奇回撤水平为5.97美元。这一水平恰巧与市场当初在1月和2月形成的5.95美元的阻挡水平非常接近。现在，5.95美元的阻挡水平已经转化为新的支撑水平。4月2日和3日，当市场向下回落时，5.97美元的价格水平起到了支撑作用，并经受住了考验。这两天的价格变化形成了一个孕线形态，标志着之前的较小的下跌行情的终结。此后，市场似乎为了证明这一回撤水平的可靠性，在4月中旬对这一支撑水平再次进行了成功的试探，然后图示的大豆市场便掉头而去！ 图12.5 大豆——1990年7月，日蜡烛图（蜡烛图上的百分比回撤水平） 如图12.6a所示为原油市场，从7月L处的低点，到10月H处的高点，形成了一段幅度达21.70美元的上涨行情。这段上涨行情的50％回撤水平大致在29.05美元。于是，根据上升行情的50％回撤水平将构成支撑水平的理论，当10月的高点后发生了一轮快速的抛售行情的时候，我们应注意29.05美元上下的位置，这里可能出现看涨的蜡烛图指标。后来的情况果如所料。10月23日，一方面价格向下触及了28.30美元的低点，另一方面，在日蜡烛图上形成了一根锤子线。从这根锤子线起，市场上涨了5美元以上。在包含上述价格变化的日内图表上（如图12.6b所示），我们可以看到，10月23日的第一个小时也形成了一根锤子线。如此一来。在日蜡烛线图上，10月23日是一根锤子线，在日内蜡烛线图上，10月23日的的第一个小时也是一根锤子线。如图所示，这是一种罕见的、而且很有意义的巧合。请注意，在这张日内图表上，从上述锤子线开始，市场形成了一段较快的上升行情。后来当10月26日出现了一根上吊线时，这轮上涨行情才走上了末路。 图12.6（a） 原油——1990年12月，日蜡烛图 图12.6（b） 原油——1990年12月，日蜡烛图]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 善始更要善终-期货投资如何选择出市点]]></title>
    <url>%2F2021%2F01%2F28%2F%E7%AC%AC6%E7%AB%A0-%E5%96%84%E5%A7%8B%E6%9B%B4%E8%A6%81%E5%96%84%E7%BB%88-%E6%9C%9F%E8%B4%A7%E6%8A%95%E8%B5%84%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%87%BA%E5%B8%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 期货价格惯性是指当期货价格上涨（或下跌）一定幅度之后，期货价格继续上涨（或继续下跌）这个幅度的可能性大于反向下跌（或反向上涨）这个幅度的可能性。怎么理解？ 期货价格变化为什么会有惯性呢？从供求关系，人的思维，资金的角度，跟风效应分析。 利润的产生不是由交易方向、入市点的选择和资金管理带来的，而是由持仓方法带来的。怎么理解？ 移动止损怎么做？ 傻子都知道如何进入市场，但只有真正的智者才知道如何退出市场。这句话是否有道理？ 前言在交易方向和入市点的选择上，许多期货投资者都做得不错，甚至可以说无可挑剔，买完就涨或卖完就跌是常有的事，而在出市点的选择上往往不尽如人意，不是平早了，就是平晚了。 为什么会这样呢？那是因为开仓时，投资者只要关注价格趋势就行，旁观者清，但一旦开仓以后，就会有浮动盈亏，而且盈亏的大小会随着价格变化而变化，此时投资者除了关注价格变化趋势，还要关注盈亏及其变化，后者往往成为投资者选择是否平仓的主要依据。也就是说开仓和平仓时，投资者关注的交易理由和心态是完全不一样的。 关于这一点，我们将在后面进行详细讨论，本章重点讨论具体的平仓原则和方法。 故事老李今天很郁闷，因为他前几天做空的天然橡胶今天又快要跌停板了。 他的朋友老王非常不解地问：“你做的空还郁闷，我的多单还套在里面，一开始我还浮盈不少钱，前几天变成亏点儿小钱，觉得不对，想出来看看，但犹豫了一下就没砍，今天亏大了。砍吧，不忍心；不砍吧，万一明天接着跌怎么办？该郁闷的应该是我。” 老李不好意思地说：“我是做空了，但昨天赚了点儿小钱就平了。要留到今天就赚大了，真是鼠目寸光。我现在也不知道该怎么办。接着空进去吧，又怕明天反弹；不空吧，很可能还要跌，到时更后悔。” 老李和老张的郁闷也是大部分期货投资者常有的郁闷。 在探讨如何选择出市点前（如何持有头寸之前），我想先与大家讨论期货价格变化的一个非常重要的特性—价格惯性。期货价格惯性是指当期货价格上涨（或下跌）一定幅度之后，期货价格继续上涨（或继续下跌）这个幅度的可能性大于反向下跌（或反向上涨）这个幅度的可能性。就像运动的物体有运动惯性一样，期货价格变化也有惯性，也具有持续性的特点。 期货价格惯性期货价格变化为什么会有惯性呢？众所周知，期货价格的上涨或下跌总是有其内在的动力，不管这种动力来自哪个方面，甚至只是人为因素。这些因素对期货价格的影响作用大部分应该是相对长期和持续性的：第一，影响期货价格波动最内在、最根本的因素—供求关系具有一定的时间性和周期性，供求关系一般不可能在非常短的时间内发生变化；第二，人的思维是有惯性的，比如对价格看涨的人，让其转变为看跌需要有个过程，一般不会轻易改变；第三，从资金的角度，价格上涨了，多头浮动赢利增加（或浮动亏损减少），空头亏损增加（或赢利减少），资金优势上有利于多头，不利于空头；同样道理，价格下跌了，资金优势上有利于空头，不利于多头；第四，“墙倒众人推，树倒猢狲散”的跟风效应，也有利于期货价格继续朝原来方向发展，技术分析是期货价格分析的重要手段，技术派的重要特点就是顺应趋势。随便打开任何一个期货交易品种的走势图，我们都能看到其已经走过的明显趋势，不是上涨就是下跌，价格在一个小范围内上下振荡只是暂时性的。这就是期货价格走势的持续性，我们可以形象地把它们称为价格惯性。 通过统计发现：上涨（或下跌）一个标准幅度（设为1A）的头寸，在下跌（或上涨）一个标准幅度（A）之前，50%以上会继续上涨（或下跌）到第二个标准幅度（2A），在下跌（或上涨）第二个标准幅度（2A）之前，80%以上会先上涨（或下跌）到第二个标准幅度（2A），即原来上涨的行情继续上涨的可能性大于反转下跌的可能性，原来下跌的行情继续下跌的可能性大于反转上涨的可能性，也就是说，如果某一品种期货价格上涨（或下跌）了一定幅度，那么它继续上涨（或下跌）这个幅度的可能性应该大于它反转下跌（或上涨）这个幅度的可能性。图6-1为期货价格走势的持续性示意图，它形象地反应了这种趋向性。 图6-1 期货价格走势的持续性示意图 我对上海四个月期货铜进行的统计发现，上涨（或下跌）300点的头寸，其中53.2%继续上涨（或下跌）300点，只有46.8%会反转下跌（或上涨）300点；对大连大豆期货进行的统计结果发现：上涨（或下跌）30点的头寸，其中59%会继续上涨（或下跌）30点，只有41%会反转下跌（或上涨）30点；对2010年4月16日~2011年12月16日一年半沪深300指数期货进行的统计结果发现：在739次取样中上涨（或下跌）30点的头寸，其中411次即55.6%会继续上涨（或下跌）30点，只有44.4%会反转下跌（或上涨）30点。 外盘的期货品种也同样有这个特性，我通过统计发现，伦敦金属交易所（LME）三个月期货铜30点的持续性比率约为59.5%，芝加哥交易所（CBOT）大豆期货5个点的持续性比率约为53.3%，纽约商业交易所（NYMEX）原油期货0.5个点的持续性比率约为63.3%。其他交易品种，有兴趣的读者不妨自己去统计，总之，期货价格走势的持续性是普遍存在的。 虽然总的来说，期货价格变化具有明显的惯性，但某一段时间，以某一价格波动幅度作为标准，可能不具有持续性特点，所以设置相同的止损幅度（或交易策略）并不能保证在任何价格波动情形下都有好的交易结果，但可以通过调整止损幅度或同时采用多种交易策略的方式，使得交易结果具有较好的稳定性，这一点非常重要。 图6-2、图6-3、图6-4分别为以A作为标准涨跌幅度时，各种持续性比率，X=0；0&lt;X&lt;50%；X&ge;50%所做的示意图。从图中我们可以看出如下几点：通过调整涨跌幅标准（扩大或缩小），就能改变持续性比率，使其大于50%，且理论上越小越好，但实际操作中还要考虑到滑点（不能及时成交）、交易成本（交易手续费）等问题，因为止损幅度太小，即使持续性比率大于50%，理论上交易结果也是赢利的，但由于进出市太频繁，大部分的赢利都因为滑点或交了手续费而损失掉了，甚至还有可能发生亏损。 图6-2 图6-3 图6-4 我们知道不同的价位区（如高价区与低价区），其最好的止损幅度应该会有所不同，但由于持续性比率X&gt;50%的标准涨跌幅并不是唯一的，使得我们可以在不同的价位区选择相同的止损幅度成为可能。一般情况下，合约价格的1%左右作为止损幅度或跟踪止损幅度是比较合理的，具体要根据各期货品种的走势特点和统计结果来定。 在图6-2中，若以A作为标准涨跌幅，其价格走势的持续性比率X=0，为完全不持续。若以0.5A作为标准涨跌幅，显然其持续性比率就会大于0，约为50%。如果以A作为跟踪止损幅度进行连续交易，其交易结果显然是亏损的；以0.5A作为跟踪止损幅度进行连续交易，其交易结果就是零。 在图6-3中，若以A作为标准涨跌幅，其价格走势的持续性比率0&lt;X&lt;50%；若以0.5A作为标准涨跌幅，显然其持续性比率X就会大于50%；若以2A作为标准涨跌幅，其持续性比率就会&gt;50%；若以4A作为标准涨跌幅，其持续性比率X又会小于50%。如果以A作为跟踪止损幅度进行连续交易，其交易结果是亏损的；以2A作为跟踪止损幅度进行连续交易，其交易结果则是赢利的；以4A作为跟踪止损幅度进行连续交易，其交易结果显然又是亏损的；但如果以0.5A作为跟踪止损幅度进行连续交易，其交易结果显然又是赢利的。 在图6-4中，若以A作为标准涨跌幅，其价格走势的持续性比率X就大于约等于50%；若以0.5A作为标准涨跌幅，显然其持续性比率X就会更大；如果以A作为跟踪止损幅度进行连续交易，其交易结果显然就是赢利的；以0.5A作为跟踪止损幅度进行连续交易，其交易结果显然赢利会更多。 实际上，期货价格的走势不可能像上面各图那样有规律，图6-2~图6-4只是为了说明问题而设计的。 理解了期货价格变化的惯性后，我们就能自然而然地得出这样的结论：赢利头寸应该尽可能持有，亏损头寸应该及时止损，这是期货操作的基本原则，那么我们如何在实际操作中实现呢？这就是本章要重点讨论的如何选择出市点的问题。 出市点的选择我们前面曾经谈到，对于每一次交易来说，期货的高风险与高收益是完全对等、无法分开的，但对不同的交易次数来说，我们则可以根据期货价格走势的持续性特点，对赢利头寸和亏损头寸分别采取不同的处理方式，让赢利头寸的赢利点数尽可能大，让亏损头寸的亏损点数尽可能小，以实现平均赢利幅度大于平均亏损幅度和控制风险。 经过研究和总结，我设计了如下五种简易的持仓方法，供投资者参考： ①像选择入市点一样选择出市点，把平仓当开仓来做； ②设置跟踪止损； ③让赢利目标远大于止损幅度； ④亏损时及时止损，赢利头寸一直持有到不得不平仓（比如交割或快进入交割时）； ⑤顺势开仓之后一直持有，直到趋势发生变化才平仓。 投资者可以根据自己的经验总结出其他持仓方法，其都是为了实现赢利时的平均赢利幅度大于亏损时的平均亏损幅度。下面就这几种持仓方法加以说明。 像选择入市点一样选择出市点，把平仓当开仓来做对于交易经验非常丰富和心态非常稳定的投资者，可以用选择交易方向和入市点的办法来选择出市点，把平仓当开仓来做，比如当其持有多头头寸，经分析认为价格将要下跌时，就可以考虑平仓。只要其分析判断的准确性高，出市点的选择自然会比较合理，平均赢利幅度也就自然比平均亏损幅度要大。但是，对于绝大部分期货投资者来说，包括像我这样有近20年期货交易经验的人，很难做到这一点，因为平仓时的心态与开仓时有天壤之别。开仓时没有头寸，无论价格上涨还是下跌，都不会有盈亏得失，人们往往能以旁观者清的态度相对客观和理智地分析、对待期货的价格变化，在交易方向和入市点的选择上往往就比较满意，而一旦开仓之后，价格的上涨或下跌就会产生浮动盈亏，浮动盈亏的大小又会随着价格的波动而不断变化，投资期货的目的是博取赢利，防止亏损，而要博取更大的赢利就要冒失去赢利甚至赢利变亏损的风险，因此盈亏的变化（而不仅仅是价格的变化）也就自然而然成为期货投资者最关心的核心内容，它时时刻刻都在影响投资者的操作心态和决策，影响投资者对价格走势的判断，使其很难客观理智地分析和对待期货的价格变化。投资者往往会以盈亏及其大小变化来决定是否平仓或持有，而不是更多地专注于对价格变化的分析与判断， 自然对最终的平仓点位不会特别满意。这就好比走独木桥一样，开仓时独木桥是在低处，平仓时独木桥是在高空，此时能否走过去，并不取决于你的平衡能力（分析判断水平）。当然对于交易经验丰富，风险承受能力强，心态非常稳定的期货投资者而言，这不失为一种好的出市点选择方法，具体方法可参见交易方向和入市点的选择的有关内容。 正是因为绝大部分投资者都无法像选择交易方向和入市点一样来选择出市点，于是我们就可以利用期货价格变化的持续性特点，选择一些程序化的持仓方法，这也是目前许多投资者开始利用计算机进行程序化交易的一个重要原因。 设置跟踪止损所谓设置跟踪止损是指开仓后，所持头寸不管一开始是赢利还是亏损，只要向亏损方向波动一定止损幅度就即刻平仓，否则一直持有至不得不平仓时。也就是随着所持头寸浮动赢利的提高，止损点也相应发生变化。这种持仓方法赢利的基本原理就是期货价格惯性，比如做多时，既然上涨一定幅度之后继续上涨这个幅度的可能性更大，我们就应该继续持有，而当价格一旦下跌了这个幅度时，既然继续下跌这个幅度的可能性大，就应该平仓，但是否做空，还要考虑基本面等其他因素，如图6-5、图6-6所示。 图6-5 做多设置跟踪止损示意图，多单一直持有直到即时价格下跌设定的跟踪止损幅度A才平仓 图6-6 做空设置跟踪止损示意图，空单一直持有直到即时价格上涨设定的跟踪止损幅度A才平仓 这种持仓方式使平均赢利幅度得到大幅度提高，但赢利次数因盈亏标准的不对称而减少，交易和统计结果显示，这种为获取更大的赢利幅度而牺牲赢利次数的做法是值得的，我对2000年1月~2002年12月3年间上海铜和大连大豆分别进行了大量的模拟交易，每5个自然日（约4个交易日）开仓一次，同一价位同时买进、同时卖出，目的是想使交易结果不受交易方向和入市点的影响，而只与持仓方法有关，上海铜设置300点跟踪止损，大连大豆设置30点跟踪止损，得到表6-1所示交易结果，从表中我们看到，虽然赢利次数由50%降到了40%左右，但因赢利幅度的提高、亏损幅度的降低使得平均赢利幅度是平均亏损的2倍，最终产生了利润，显然，利润的产生不是由交易方向、入市点的选择和资金管理带来的，而是由持仓方法带来的。 表6-1 同一价位同买、同卖设置跟踪止损的交易结果 我又对2010年4月16日~2012年2月17日间沪深300指数期货进行了大量的模拟交易，每个交易日开仓一次（开盘15分钟后开始交易），同一价位同时买进、同时卖出，目的是想使交易结果不受交易方向和入市点的影响，而只与持仓方法有关，设置30点跟踪止损，得到表6-2所示交易结果，从表中我们看到，虽然赢利次数由50%降到了36%左右，但因赢利幅度的提高、亏损幅度的降低使得平均赢利幅度是平均亏损的2.1倍，最终产生了年理论回报89.2%的利润。 表6-2 沪深300指数期货采用30点跟踪止损交易结果统计 从表6-2中我们还能看出，这种持仓方法虽然总的交易结果是赢利的，但不能保证每个月都是赢利的，甚至可能连续几个月亏损，也就是说这种持仓方法不适应任何行情，如图6-7所示。 图6-7 沪深300指数期货采用30点跟踪止损交易结果（回报率%）走势图 另外，我们还注意到这种持仓方法每次持仓时间较短，平均只有1.4个交易日，交易频率较高，就不得不考虑手续费和滑点对交易结果的影响，尤其是滑点。滑点是指价格触发之后因市场流动性不好或网络、交易系统等原因而无法及时成交而导致的价格损失，在交易频率较高时，滑点的影响非常明显，比如在上述沪深300指数期货采用30点跟踪止损交易中，如果考虑到交易手续费和滑点，理论回报率就会大幅度下降，如表6-3所示。（根据我实际交易结果统计，目前沪深300指数期货的滑点每次交易约为1.6点，表中交易所手续费按0.5/万，期货公司手续费按1/万计算）。表中显示年理论回报率因滑点由89.2%降至25.7%，降低幅度高达63.5个点，因交易所手续费降至77.5%，降幅为11.7点，因交易所和期货公司手续费降至65.8%，降幅为23.4点，因滑点和手续费而降至2.6%，降幅合计高达86.6点。 表6-3 沪深300指数期货采用30点跟踪止损，考虑滑点和手续费回报率 为了突出持仓方法的作用，上述沪深300指数期货统计中没有考虑交易方向和入市点的选择，如果结合交易方向和入市点的选择，这种持仓方法的效果应该会更好。在上述交易结果统计中，如果我们只选择与目前技术趋势一致的交易方向，就会得到表6-4、表6-5所示的交易结果，其明显好于表6-2、表6-3的统计结果，理论年回报率由89.2%上升至211.3%，上升幅度高达122.1点，从交易结果走势图6-7中也能看出赢利能力的明显提高，如果再考虑入市点的选择，效果应该会更加理想。 表6-4 沪深300指数期货顺目前技术趋势方向交易、采用30点跟踪止损交易结果统计 表6-5 沪深300指数期货采用30点跟踪止损，考虑滑点和手续费，顺趋势交易回报率 国际市场上外盘品种是否也有同样的规律呢？我对2006年1月9日~6月16日间NYMEX原油期货连续图进行了235次连续交易，跟踪止损幅度0.5点，即如果价格上涨，则多头一直持有，直到价格从当前最高点下跌0.5点时卖出平仓，同时在该价位开立一个空头头寸，并一直持有，直到价格从当前最低点上涨0.5点时才平仓买进，同时在该价位开立一个多头头寸，如此一直连续交易下去。我也对2005年5月25日~11月24日LME三个月期货铜进行了247次连续交易，方法同上，设置30点跟踪止损。在不考虑滑点和手续费的情况下得到表6-6统计结果。 表6-6 从表中统计结果我们发现：①虽然交易期间原油和铜的净上涨幅度分别为6.3个点和1121个点，但采用跟踪止损进行连续交易的赢利总幅度则分别高达45.59点和1557点，远大于净波动幅度，就像把一根弯弯曲曲的绳子拉直了，这说明即使交易方向与大的走势不一致，采用跟踪止损的持仓方法也是可以赢利的；②采用跟踪止损的方法，虽然赢利次数所占的比率有所降低，但平均赢利幅度的提高和平均亏损幅度的降低，使得总的交易结果是赢利的。 让赢利目标远大于止损幅度这种持仓方式，就是开仓后，所持头寸亏损至一定止损幅度或赢利至一定目标幅度时都即刻平仓，赢利目标一般为止损幅度的两倍以上，要远大于止损幅度，否则继续持有至不得不平仓时。这种持仓方式赢利的基本原理是：仍然假设一年中进行100次上海铜的期货交易，开仓是完全随机的，止损幅度为A点，赢利目标为2A点，根据概率统计原理，一开始，赢利A点和亏损A点的次数应该各为50次，又假设赢利A点的头寸一定比率（设为X）即50X次在回到赢利0点之前，能够继续赢利至2A点，50（1-X）次则回到赢利0点，其中一定比率X，即50（1-X）X次变为亏损A点，另一部分即50（1-X）2次又回到赢利A点，其中一定比率X，即50（1-X）2X次继续赢利至2A点，依此类推，则赢利总额为：2A[50X + 50（1-x）2X + 50（1-X）4X + … + 50（1-X）2nX]，亏损总额：A[50 + 50（1-X）2X + 50（1-X）3X+ … + 50（1-X）2n-1X]。通过数学运算我们知道，当x大于0.5（50%）时，赢利总额就大于亏损总额，根据期货价格走势的持续性，X一般大于0.5（50%），这就是这种持仓方法获利的基本原理，图6-8为这种持仓方法的获利示意图，图中假定期货价格走势的持续性比率为60%。 图6-8 让盈利目标远大于止损幅度获利示意图 我对2000~2002年3年间上海铜和大连大豆分别进行了大量的模拟交易，每5个自然日（约4个交易日）开仓一次，同一价位同时买进、同时卖出，目的是想使交易结果不受交易方向的影响，而只与持仓方法有关，上海铜止损幅度100点，赢利目标1500点，大连大豆止损幅度30点，赢利目标100点，得到表6-7所示交易结果，从表中我们看到，虽然赢利次数由50%降到了20%左右，但因赢利幅度的大幅提高，亏损幅度的相对不变，却最终产生了利润。为了争取更大的赢利幅度，原来赢利的头寸有一部分转变为亏损，使得赢利次数所占比率减少，统计结果显示，这样的牺牲也是值得的。 表6-7 同一价位同买，同卖让盈利目标远大于止损幅度的交易结果 从表6-7中数据可以看出，虽然总的交易结果是赢利的，但赢利次数所占比例较小，仅为20%左右，赢利的不确定性较高，绝大部分时候都在亏损，如果一开始就赶上好几次连续亏损，不仅影响到可用资金，而且会严重影响投资者的心态，让其不敢坚持原定的交易策略和计划。 我又对2010年4月16日~2012年2月17日间沪深300指数期货进行了大量的模拟交易，每个交易日开仓一次（开盘15分钟后开始交易），同一价位同时买进、同时卖出，目的是想使交易结果不受交易方向和入市点的影响，而只与持仓方法有关，设置30点止损，赢利目标60点，得到表6-8所示交易结果，从表中我们看到，虽然赢利次数由50%降到了36%左右，但因赢利幅度的提高、亏损幅度的降低使得平均赢利幅度是平均亏损的1.9倍，最终产生了年理论回报40%左右的利润。 表6-8 沪深300指数期货采用30止损，60点止盈交易结果统计 从表6-8中我们还能看出，这种持仓方法虽然总的交易结果是赢利的，但不能保证每个月都是赢利的，甚至连续几个月亏损，也就是说这种持仓方法也不适应任何行情，赢利能力也具有不稳定性，从统计结果看，稳定性还不如采用跟踪止损的持仓方法，如图6-9所示。 图6-9 沪深300指数期货采用30点止损，60点止盈交易结果走势图 另外，我们还注意到这种持仓方法每次持仓时间较短，平均只有1.9个交易日，交易频率也较高，同样不得不考虑手续费和滑点对交易结果的影响，尤其是滑点。在上述沪深300指数期货采用30点止损、60点止盈的交易中，如果考虑到交易手续费和滑点，理论回报率就会大幅度下降，如表6-9所示。（根据实际交易结果统计，沪深300指数期货的滑点目前每次交易约为1.6点，表中交易所手续费按0.5/万，期货公司手续费按1/万计算。）表中显示年理论回报率因滑点由39.9%降至-6.8%，下降幅度高达46.7点，因交易所手续费降至31.4%，下降幅度为8.5点，因交易所和期货公司手续费降至22.8%，下降幅度为17.1点，因滑点和手续费而降至-24%，下降幅度合计高达63.9点。 表6-9 沪深300指数期货采用30点止损、60点止盈，考虑滑点和手续费回报率 同样，为了突出持仓方法的作用，上述沪深300指数期货统计中没有考虑交易方向和入市点的选择，如果结合交易方向和入市点的选择，这种持仓方法的效果应该会更好。在上述交易结果统计中，如果我们只选择与目前技术趋势一致的交易方向，就会得到表6-10、表6-11所示交易结果，其明显好于表6-8、表6-9的统计结果，理论年回报率由39.9%上升至125.3%，上升幅度高达85.4点，从交易结果走势图6-9中也能看出赢利能力的明显提高，如果再考虑入市点的选择，效果应该会更加理想。 表6-10 沪深300指数期货采用30止损，60点止盈交易结果统计-顺势 表6-10 沪深300指数期货采用30止损，60点止盈，考虑滑点和手续费，顺趋势交易回报率 亏损时及时止损，赢利头寸一直持有到不得不平仓下面我们来看一组非常有意思的统计数据。为了排除人为因素的干扰，我对大连大豆（1995年12月~2000年7月）和上海铜期货（1995年11月~2000年10月）分别进行了280次和291次随机交易试验，即交易的方向完全是随机的，不进行任何分析，上海铜开仓之后只要赢利达到某一目标（150或300点）就马上平仓，否则就死扛（不止损），直至快要进入交割月（交割月前月的最后交易日）才不得不平仓，大连大豆开仓之后只要赢利达到某一目标（15或30点）就马上平仓，否则就死扛（不止损），直至快要进入交割月（交割月前月的最后交易日）才不得不平仓，得到如表6-12所示的交易结果。 表6-12 随机开仓情况下，上海铜、大连大豆不止损（死扛）的交易结果统计表 从表6-12中，我们可以发现如下有趣的现象：虽然这种持仓方法赢利次数所占比例非常之高（约80%），亏损次数所占比例很低，但总的交易结果出现了较大的亏损。于是我们马上会联想到，如果反过来操作，亏损至一定幅度就马上平仓止损，赢利时就一直持有到不得不平仓（比如进入交割或快进入交割时），这样虽然赢利次数所占比例较低（约20%），亏损次数所占比例很高（80%），但最终的交易结果会有较大的赢利。于是，我对2000年1月~2006年6月间上海铜期货和大连大豆期货最活跃月份做了模拟交易，每10个自然日、约8个交易日开一次仓，同一价位，开一个多头头寸和一个空头头寸，等于交易两次， 目的是排除交易方向所起的影响，相当于随机交易，上海铜总共交易478次，大连大豆共交易458次，采用持仓方法即亏损及时止损，赢利就一直持有到交割月前第二个月的最后交易日，得到表6-13所示的统计结果。 表6-13 亏损及时止损，赢利一直持有至交割月前第二个月的最后交易日 从表中我们看出，采用上述持仓方法，虽然赢利次数所占比率很低（15%~20%），但赢利总点数远大于亏损总点数。 我又对2010年4月16日~2012年2月17日间沪深300指数期货进行了大量的模拟交易，每个交易日开仓一次（开盘15分钟后开始交易），同一价位同时买进、同时卖出，目的是想使交易结果不受交易方向和入市点的影响，而只与持仓方法有关，设置30点止损，赢利就一直持有到交割，得到表6-14所示交易结果，从表中我们看到，虽然赢利次数由50%降到了25%左右，但因赢利幅度的大幅度提高、亏损幅度的降低使得平均赢利幅度是平均亏损的4.8倍，最终产生了年理论回报高达187.4%左右的利润。 表6-14 沪深300指数期货采用30止损，盈利一直持有直到不得不平仓交易结果统计 从表6-14中我们也能看出，这种持仓方法具有很好的赢利能力，在不考虑交易方向和入市点的情况下就有高达187.4%的理论年回报率，但同样也不能保证每个月都是赢利的，甚至也有连续几个月亏损，也就是说这种持仓方法也不适应任何行情，赢利能力同样具有不稳定性，而且赢利次数所占比例只有25%左右，大部分时候都在赔钱，赢利的不确定性较高，投资者需要有很好的心态才能坚持，如图6-10所示。 图6-10 沪深300指数期货采用30点止损赢利一直持有直到交割交易结果走势图 另外，我们还注意到这种持仓方法每次持仓时间较长，平均有4.2个交易日，交易频率适中，手续费和滑点对交易结果的影响有限。在上述沪深300指数期货采用30点止损、赢利一直持有直到交割的交易中，如果考虑到交易手续费和滑点，理论回报率没有大幅度下降，如表6-15所示。（根据我实际交易结果统计，目前沪深300指数期货的滑点目前每次交易约为1.6点，表中交易所手续费按0.5/万，期货公司手续费按1/万计算。）表中显示年理论回报率因滑点由187.4%降至165.9%，下降幅度为21.5点，因交易所手续费降至183.5%，下降幅度为3.9点，因交易所和期货公司手续费降至179.6%，下降幅度为7.8点，因滑点和手续费而降至158%，下降幅度合计为29.4点，不到前几种方法的一半，比较适中。 表6-15 沪深300指数期货采用30点止损，盈利一直持有到交割，考虑滑点和手续费回报率 同样，为了突出持仓方法的作用，上述沪深300指数期货统计中没有考虑交易方向和入市点的选择，如果结合交易方向和入市点的选择，这种持仓方法的效果应该会更好。在上述交易结果统计中，如果我们只选择与目前技术趋势一致的交易方向，就会得到表6-16、表6-17所示交易结果，其明显好于表6-14、表6-15的统计结果，理论年回报率由187.4%上升至263.9%，上升幅度高达76.5点，从交易结果走势图6-10中也能看出赢利能力的明显提高。不过虽然赢利能力有较大提高，但赢利的稳定性有所下降。如果再考虑入市点的选择，效果应该会更加理想。 表6-16 沪深300指数期货采用30止损，赢利一直持有直到不得不平仓交易结果统计-顺势 表6-17 沪深300指数期货采用30止损，赢利一直持有到交割，考虑滑点和手续费顺趋势交易回报率 几个月以前，我接到一个客户的投诉电话，怀疑我们期货公司的结算系统有问题。我知道这是不可能的，因为中国的期货市场实行的是一户一码制，期货公司的结算与交易所的结算是完全一样的。客户告诉我说，他的交易结果怎么可能是亏损的，因为他只有赚钱才会平仓，亏损时他会一直持有直到保证金不足或快要进入交割月时才不得不平仓。在没有查看他的交易记录前我就告诉他这样操作长期下来肯定是亏损的，查看结果当然也不会出乎我所料，下面是他的交易结果：300，180，600，240，800，120，-3000，70。他的持仓方法正好与我们上述方法完全相反，所以亏损也是必然的。 为了使赢利幅度尽可能大于亏损幅度，实现平均赢利幅度大于平均亏损幅度，以上3种持仓方式都是分别对赢利和亏损头寸采取的不同处理方式，让赢利时赢利的幅度尽可能大，亏损时亏损的幅度尽可能小，以牺牲赢利次数为代价，且统计结果证明这种牺牲是值得的。在讨论以上几种持仓方法时都没有考虑平仓之后如何再接回头寸的问题，如果平仓之后不能及时补回头寸，往往会错过许多大的行情，不能把行情尽可能做满，使得资金因行情踏空而被闲置，时间价值得不到充分发挥，尤其是当补回头寸时的价位不如平仓价位时，重新买入开仓时的价位高于前面平仓卖出时的价位，或重新卖出开仓时的价位低于前面平仓买入时的价位，一般投资者在心理上都难以接受。 我们可以通过如下3种方式重新补进头寸：①按交易方向和入市点的选择原则重新入市；②按一定幅度跟踪补进，在决定了交易方向后，只要价格从当前的最低点或最高点向该交易方向波动了这个幅度就入市补进头寸；③也可以根据日内短线图形重新选择入市点。 为了防止平仓后没有及时补回头寸而错过大的投资机会，没有尽可能把行情做满的情形，于是我设计了第5种持仓方式：顺势开仓之后一直持有，直到趋势发生变化才平仓。显然，这种持仓方法已经考虑了交易方向的判定和选择问题，下面我们将对这种持仓方法进行讨论。 顺势开仓之后一直持有，直到趋势发生变化才平仓这种持仓方式是指：如果目前技术趋势是涨势，就开仓买入，并一直持有直到技术趋势变为跌势才平仓卖出；如果目前技术趋势为跌势，就开仓卖出，并一直持有直到技术趋势变为涨势才平仓买入。 问题是对于目前技术趋势的判定，即目前走势技术上是涨势还是跌势，不同的交易者往往有不同的标准。有的交易者根据移动平均线来确定，有的则根据通道来判断，由于标准不同，所得结论也会有所不同，没有一个完全客观的标准。 我一般是根据收盘时日K线图中价格是否上破前期高点（而不是历史高点）或下破前期低点（而不是历史低点）来判定目前技术走势是涨势或跌势，详见第3章期货投资如何通过技术分析选择交易方向的相关内容。 按照这个判定，运用这种持仓方法，我对1996年3月1日~2003年12月3日的上海铜和大连大豆进行了连续的模拟交易，共计1880个交易日，得到表6-18所示交易结果。从交易结果可以看出，这也是一种很好的持仓方法，它回避了上面两种持仓方法因没有及时补回头寸而可能导致的行情踏空。在实际操作中，运用这种交易方式（因为它已经包含交易方向的选择，而不是单纯的持仓问题）还应考虑到其他方面（如基本面）等因素。 表6-18 顺势开仓之后一直持有，直到趋势发生变化才平仓的交易结果 我又对2010年4月16日~2012年2月17日间沪深300指数期货进行了连续的模拟交易，如果目前技术趋势是涨势，就开仓买入，并一直持有直到技术趋势变为跌势（或交割）才平仓卖出，如果目前技术趋势为跌势，就开仓卖出，并一直持有直到技术趋势变为涨势（或交割）才平仓买入。得到表6-19所示交易结果，从表中我们看到，赢利次数所占比例较高，为44%左右，且平均赢利幅度是平均亏损的2.1倍，最终产生了年理论回报高达156.4%左右的利润，但有时亏损幅度也很大。 表6-19 沪深300指数期货采用顺技术趋势交易结果统计 同样，从表6-19中我们也能看出，这种持仓方法虽然也具有很好的赢利能力，在考虑交易方向和入市点的情况下也有高达156.4%的理论年回报率，但也不能保证每个月都是赢利的，甚至也有连续几个月亏损，有的月份亏损幅度还很大，也就是说这种持仓方法也不适应任何行情，赢利能力同样具有不稳定性，有大起大落的特点，但赢利次数所占比例高达44%左右，因交易频率较低，赢利的不可确定性较大。如图6-11所示。 图6-11 沪深300指数期货顺技术趋势交易结果走势图 另外，我们还注意到这种持仓方法每次持仓时间最长，平均有8.4个交易日，交易频率很低，手续费和滑点对交易结果的影响非常有限。上述持仓方法，如果考虑到交易手续费和滑点，理论回报率下降幅度很小，如表6-20所示。（根据我实际交易结果统计，目前沪深300指数期货的滑点目前每次交易约为1.6点，表中交易所手续费按0.5/万，期货公司手续费按1/万计算。）表中显示年理论回报率因滑点由156.4%降至145.9%，下降幅度为10.8点，因交易所手续费降至154.7%，下降幅度为1.7点，因交易所和期货公司手续费降至152.7%，下降幅度为3.7点，因滑点和手续费而降至141.9%，下降幅度合计为14.5点，是几种持仓方法中影响最低的。 表6-20 沪深300指数期货顺趋势交易，考虑滑点和手续费回报率 几种持仓方法的对比投资者可以根据自己的操作经验总结出其他持仓方式，其目的都是实现赢利时平均赢利幅度尽可能大于亏损时平均亏损幅度。我认为好的持仓方法应该同时考虑以下几个方面，虽然有时候这几个方面是相互矛盾的。 （1）赢利能力。在排除交易方向所起的作用时，好的持仓方法其总的交易结果应该是赢利的，且赢利越多越好。也就是说通过统计总结出的持仓方法，赢利次数所占百分比（A%）乘以平均赢利幅度（M）应该大于亏损次数所占百分比（a%）乘以平均亏损幅度（m）。在对持仓方法进行统计和总结时，应该尽可能排除交易方向所起的作用，这样才能充分反映持仓方法本身所起的作用。应该说上述5种持仓方法都有较好的赢利能力。 （2）风险的可控性。好的持仓方法其长期的交易结果不仅是赢利的，而且平均亏损幅度和最大持续亏损幅度都不应该太大，否则交易风险难以控制，有的持仓方法虽然长期看也有很好的收益率，但属于大盈大亏型，如果一开始交易就赶上了较大亏损，由于资金的原因可能就没有机会大盈了。理论上平均亏损幅度和最大持续亏损幅度越小越好，但在实际操作时，止损幅度太小往往会使赢利次数所占比例大幅度减少，亏损次数所占比例大幅度提高，赢利的不确定性增加，同时由于出入市的频率太高，滑点和交易成本对交易结果的影响很大，且如果不能及时补回头寸，往往会错过大的投资机会，得不偿失。另外，由于价格有时不可避免地跳空，客观上给风险控制带来了一定的难度。 （3）赢利的可确定性。好的持仓方法其赢利次数所占的百分比不能太低，否则赢利的不确定性就会增加，同时，好的持仓方法其持仓时间也不能太长，因为交易次数的大幅度减少也会带来赢利的不确定性，这就好比扔硬币，扔两次很难确保一次正面，一次反面，也有可能两次都是正面或两次都是反面，如果扔许多次，就能保证正反两面各占50%左右。另外，因资金长期被占用，还会影响资金的使用效率。 （4）滑点和交易成本的问题。不同的持仓方法，其出入市的频率是不一样的，出入市越频繁，滑点和交易成本就越高。在上面各种持仓方法的统计中我们已经知道，交易频率高的方法，滑点的影响非常大，甚至可以将理论上百分之几百的收益在实际操作过程中全部化为乌有。在我国现阶段，不同的投资者有不同的手续费标准，大户的手续费标准一般要低于普通中小散户，网上交易的投资者一般要低于现场客户，自营会员的手续费标准就更低了，只是交易所的手续费，有时交易所还能返还部分手续费。手续费标准不同，所选择的持仓方法也可能不同，例如100万元资金，采用某种持仓方法交易一年后，变成了80万元，由于止损幅度小，出入市较频繁，交了100万元手续费，对于普通客户来说，这种持仓方法显然不可取，因为亏损了20万元；但对于自营会员来说，这也许是一种非常好的持仓方法，因为还有100万手续费，100万减去20万亏损，还有80万赢利，再减去交易所费用（约一半），自营会员就有40万左右赢利，即手续费收入。 （5）对投资者交易经验和心态的要求。不同的持仓方法对交易者的操作水平和心态要求是不同的，有的持仓方法虽然有很好的交易结果，但由于投资者经验不足而无法采用或心态不好而不敢采用。 （6）如何补进头寸，即尽可能把行情做满的问题。有的持仓方法虽然有很好的赢利能力，风险控制得也很好，赢利的可确定性也很高，但运用该持仓方法平仓之后，如果投资者不能及时补进头寸，往往容易错过大的投资机会。 （7）价格跳空的影响。价格跳空往往是由突发事件引起的，而突发事件一般很少发生，因此在国际期货市场上，价格跳空是较少发生的事。然而在我国现阶段期货市场上，价格跳空却是家常便饭，随着我国经济的高速发展，我国的许多商品对外依存度越来越高，如铜、天然橡胶、大豆70%以上要倚赖国际市场，这些商品在国际期货市场价格的变化会直接导致其在国内期货市场的价格变化，仿佛国内期货是国际期货相关品种的影子。由于时差的原因，国际期货市场开市交易时，国内期货市场往往已经闭市，相关品种国际期货价格的变化往往第二天才直接反映在国内期货价格的变化上，这种滞后的影子效应，往往就会导致国内期货价格的跳空高开或跳空低开，使得国内期货价格走势常常断开而不连续，存在大量的跳空缺口，增加了国内期货操作的难度，如不能及时止损，比如对上海期货铜分别设置100点、500点止损，由于经常性的价格跳空，平均下来，止损幅度往往不止100点，而是130点左右和530点左右。显然价格跳空对设置100点止损的影响要远大于设置500点止损。 （8）资金的使用效率。不同的持仓方法，其平均持仓时间也不同，持仓时间越短，资金的使用效率一般越高，但其因不能及时补进头寸错过大行情的可能性也越大。 （9）做错了大方向时。由于期货价格走势本身所具有的不确定性，投资者在实际操作时看反了大方向而做错了方向是经常和不可避免的事。方向有大方向和小方向之分，不同的持仓方法在做错了大方向时所产生的后果也不一样，有的持仓方法有时即使做错了大方向也可能赢利，因为做对了小方向。 （10）震荡市的影响。震荡市是期货市场中常见的一种价格走势，因其价格上下交替波动，缺乏方向性且事先难以判定而最难操作，在对待震荡市上，不同的持仓方法效果也不相同。 运用“像选择入市点一样选择出市点，把平仓当开仓来做”这种持仓方法时，投资者操作水平越高，市场感觉越好，对价格走势判断越准确，其赢利的可确性就越高，这种方法对投资者经验和心态的要求最高，因为其平仓的依据就是投资的经验本身。这种持仓方法的风险可控性也完全取决于投资者的操作水平。 下面就赢利能力、风险可控性、赢利可确定性、滑点和交易成本四个方面对“设置跟踪止损”、“赢利目标大于止损幅度”、“一定止损幅度、赢利一直持有”、“顺技术趋势交易直到趋势发生变化”4种持仓方法进行比较（见表6-21），虽然没有一种方法在各方面表现都很优秀，但投资者可以从中选择适合自己操作风格的持仓方法或认为相对较好的方法。 表6-21 沪深300指数期货顺趋势交易各种持仓方法优劣势对比 从表中统计结果看，“设置跟踪止损”具有很好的赢利能力和风险可控性，赢利的可确定性也较高，但滑点和交易成本也最大。“赢利目标大于止损幅度”虽然也是好的持仓方法，但相比其他持仓方法，各项指标都有所逊色。“一定止损幅度、赢利一直持有”的持仓方法，赢利能力最强，滑点和交易成本也较小，但赢利次数所占比例较小，有时可能会出现较大亏损。“顺技术趋势交易直到趋势发生变化”这种持仓方法也有较好的赢利能力，赢利次数所占比例最高，受滑点影响和交易成本最小，但有时也会出现较大亏损。 在进行实际操作时，需要根据不同的交易品种、不同的走势特点选择不同的持仓方法，对于价格跳空比较频繁、大趋势比较明确且持续时间相对较长的交易品种，如上海铜，一般不采用“设置跟踪止损”、“赢利目标大于止损幅度”这两种持仓方式，而采用“一定止损幅度、赢利一直持有”、“顺技术趋势交易直到趋势发生变化”等其他持仓方法。而对于价格跳空相对较少、价格上下波动相对频繁、投机性强、大趋势持续时间相对较短的交易品种，如大连大豆，“设置跟踪止损”则效果比较理想，关键是平仓之后如何及时补回头寸的问题。许多时候，需要将几种持仓方法结合起来使用，比如一部分头寸采用一种持仓方法，另一部分头寸采用另一种持仓方法，即部分做短线，部分做长线。还比如在设置止损时，可以把止损设在前期高点或前期低点附近（阻力位或支撑位），且在止损幅度范围附近。 总的来说，以上各种持仓方法都还不错，且在赢利能力、风险可控性、盈利可确定性、滑点和交易成本的影响等方面各有千秋，但没有发现一种持仓方法适应各种行情，这也是期货投资无法确保赢利的根本原因。我们无法保证不亏损，但我们可以把每次交易的亏损控制在一个相对较小的范围，我们也无法确保赢利，但我们可以让每次交易的赢利幅度尽可能大些。好的持仓方法虽然无法适应任何行情，也无法保证每次交易都是赢利的，但只要长期坚持下去，其交易结果一定是赢利的，这就好比扔硬币，虽然理论上正反面出现的概率各占50% ，如果只扔2次，我们不能保证一次是正面，一次是反面，扔10次也可能出现9次正面，1次反面。这种不确定性是无法避免的，但如果扔的次数很多，正反面各占50%的规律就会显现出来，这就是不确定中的确定性。 20世纪70年代，发展心理学有一个经典的“延迟满足”实验。美国斯坦福大学附属幼儿园基地内，实验人员给每个4岁的孩子一颗好吃的软糖，并告诉孩子们如果马上吃掉的话，那么只能吃一颗软糖；如果等20分钟后再吃的话，就能吃到两颗。然后，实验人员离开，留下孩子和极具诱惑的软糖。实验人员通过单面镜对实验室中的幼儿进行观察，发现有些孩子只等了一会儿就不耐烦了，迫不及待地吃掉了软糖，是“不等者”；有些孩子却很有耐心，还想出各种办法拖延时间，比如闭上眼睛不看糖、头枕双臂、自言自语、或唱歌或讲故事成功地转移了自己的注意力，顺利等待了20分钟后再吃软糖，是“延迟者”。研究人员跟踪观察发现，那些以坚忍的毅力获得两颗软糖的孩子，长大后表现出更强的适应性、自信心和独立自主精神，事业上更容易获得成功；而那些经不住软糖诱惑的孩子则往往屈服于压力而逃避挑战。 通过我多年的观察，在赢利面前，绝大部分期货投资者都是“不等者”而不是“延迟者”，赚点儿小钱就急于平仓，生怕到嘴的鸭子飞了（因为期货市场到嘴的鸭子真有可能飞走）；恰恰相反，在亏损面前，绝大部分投资者都是“延迟者”而不是“不等者”，亏损时往往不懂得及时止损，而是抱着侥幸心理，任由风险不断扩大（因为确实有许多亏损是可以扛回来的）；更有意思的是，在赢利面前的“不等者”往往是亏损面前的“延迟者”，这就是期货市场上大部分投资者都赔钱的主要原因！ 有人说，“傻子都知道如何进入市场，但只有真正的智者才知道如何退出市场”，你是否觉得这话很有道理呢？ 本章关键内容提示不管期货价格如何变化，有一点是永远不变的，那就是期货价格的波动惯性，即价格上涨（或下跌）一定幅度之后，继续上涨（或下跌）这个幅度的可能性大于下跌（或上涨）这个幅度的可能性，这主要是因为：①供求关系的变化需要时间；②投资者看涨或看跌的思维也有惯性，改变也需要时间；③价格上涨，多头的资金优势增强，价格下跌，空头的资金优势增强；④跟风效应。 我们可以通过如下几种方法来选择出市点：①像选择入市点一样选择出市点，把平仓当开仓来做；②设置跟踪止损；③让赢利目标远大于止损幅度；④亏损时及时止损，赢利头寸一直持有到不得不平仓（比如交割或快进入交割时）；⑤顺势开仓之后一直持有，直到趋势发生变化才平仓。但一般投资者很难采用第①种方法，因为开仓与平仓时投资者的心态完全不同。统计和研究发现方法②、④、⑤有较好的交易结果，但各有优缺点。 投资者可以根据自己的操作经验总结出适合自己的持仓方法，好的持仓方法主要综合考虑如下几个方面：①赢利能力；②风险的可控性；③赢利的可确定性；④滑点和交易成本（手续费）的影响。 通过我多年的观察，在赢利面前，绝大部分期货投资者都是“不等者”而不是“延迟者”，赚点小钱就急于平仓，生怕到嘴的鸭子飞了（因为期货市场到嘴的鸭子真有可能飞走）；恰恰相反，在亏损面前，绝大部分投资者都是“延迟者”而不是“不等者”，亏损时往往不懂得及时止损，而是抱着侥幸心理，任由风险不断扩大（因为确实有许多亏损是可以扛回来的）；更有意思的是，在赢利面前的“不等者”往往是亏损面前的“延迟者”，这就是期货市场上大部分投资者都赔钱的主要原因！]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货投资艺术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 来得早不如来得巧-期货投资如何选择入市点]]></title>
    <url>%2F2021%2F01%2F28%2F%E7%AC%AC4%E7%AB%A0-%E6%9D%A5%E5%BE%97%E6%97%A9%E4%B8%8D%E5%A6%82%E6%9D%A5%E5%BE%97%E5%B7%A7-%E6%9C%9F%E8%B4%A7%E6%8A%95%E8%B5%84%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%85%A5%E5%B8%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 不应该在支撑位附近追空。为什么？ 前言统计和研究发现，即使交易方向相同，不同的入市点位，其赢利的可能性也不相同，有的相差很大。即使做对了方向，如果入市点选择不好，也很容易被止损出局。 因此，要想提高赢利的可能性，使平均赢利幅度尽可能大，平均亏损幅度尽可能小，实现赢利时平均单量大于亏损时平均单量，除了进行基本面、技术面分析，看基本面与技术面是否一致，还要看目前价格所处的点位，并根据不同入市点位赢利的可能性大小决定此次交易资金运用量（单量）的大小。 故事炒期货的陈总一想到橡胶价格今天跌到了22000元/吨左右，就越想越生气。 由于对宏观经济的不看好，陈总对橡胶后市非常看空，于是在2012年3月8日那天当橡胶价格跌破27500元/吨时做空1209橡胶200手（此时价格已接近前期低点27000元/吨左右的支撑位），没想到第二天价格就开始大幅度反弹，当价格反弹至28200元/吨以上时，按事先设定的止损原则平仓出局，损失15万元，他并不后悔自己在28200元/吨的止损，因为随后价格又继续上涨至29000元/吨以上，而且及时止损也是他做期货多年来一直坚守的操作原则，而是后悔自己当初不应该在支撑位附近追空，更后悔自己没有在阻力位29300元/吨左右或下破支撑位27500元/吨左右继续做空，否则自己现在应该是赢利100万元以上，而不是亏损15万元多，如图4-1所示。 图4-1 上海橡胶1209合约2012年2~6月走势图 陈总深有感触地对朋友说，做期货看对了方向还远远不够，还得把握好入市时机，过早看对等于看错。 正文投资者可以根据自己的经验和操作习惯来选择入市点，在实际操作时，我一般通过支撑位、阻力位、量价配合等因素的综合考虑来选择入市点。为便于判断和操作，我把入市点位分为如下6种类型，投资者可以根据自己的操作习惯和主要参考的技术指标进行分类。 （1）遇正向支撑或阻力。如果目前技术趋势为涨势，价格上涨之后回调到日K线图前期低点，即支撑位附近（价格的1%左右）即是遇正向支撑，如图4-2所示。 图4-2 沪深300指数期货遇正向支撑点位实例，目前技术趋势为涨势，价格调整到前期低点（支撑位）附近即为遇正向支撑点位。此支撑有利于价格的继续上涨，所以称为遇正向支撑 如果目前技术趋势为跌势，价格下跌之后反弹到日K线图前期高点，即阻力位附近（价格的1%左右）即是遇正向阻力，如图4-3所示。 图4-3 沪深300指数期货遇正向阻力实例，目前技术趋势为跌势，价格反弹到前期高点（阻力位）附近即为遇正向阻力点位。此阻力有利于价格的继续下跌，所以称为遇正向阻力 比如沪深300指数期货，日K线图目前技术趋势是涨势，前期低点为2800点，以30点（价格的1%左右）作为权衡标准，当价格回调至2830~2800时即为遇正向支撑。相反，如果日K线图目前技术趋势是跌势，前期高点为2800点，以30点（价格的1%左右）作为权衡标准，当价格反弹至2770~2800时即为遇正向阻力。 （2）遇反向支撑或阻力。如果目前技术趋势为涨势，价格回调后又上涨到日K线图前期高点，即阻力位附近（价格的1%左右）即是遇反向阻力，如图4-4所示。 图4-4 沪深300指数期货遇反向阻力点位实例，目前技术趋势为涨势，价格下跌之后又反弹至前期高点（阻力位）附近即为遇反向阻力点位。此阻力不利于价格的继续上涨，所以称为遇反向阻力 如果目前技术趋势为跌势，价格反弹之后回落到日K线图前期低点，即支撑位附近（1%左右）即是遇反向支撑，如图4-5所示。 图4-5 沪深300指数期货遇反向支撑点位实例，目前技术趋势为跌势，价格反弹之后又下跌至前期低点（支撑位）附近即为遇反向支撑点位。此支撑不利于价格的继续下跌，所以称为遇反向支撑 比如沪深300指数期货，日K线图目前技术趋势是涨势，前期高点为2800点，以30点（1%左右）作为权衡标准，当价格回调之后又反弹至2770~2800时即为遇反向阻力。相反，如果日K线图目前技术趋势是跌势，前期低点为2800点，以30点（1%左右）作为权衡标准，当价格反弹之后又回落至2830~2800时即为遇反向支撑。 （3）正向破支撑或阻力。如果目前技术趋势为涨势，当价格上涨到前期高点，即阻力位之上时即为正向破阻力，如图4-6所示。 图4-6 沪深300指数期货正向破阻力点位实例，目前技术趋势为涨势，价格回调之后又上涨且涨破前期高点（阻力位）即为正向破阻力点位。破此阻力点位有利于价格的继续上涨，所以称为正向破阻力点位 如果目前技术趋势为跌势，当价格下跌到前期低点，即支撑位之下时即为正向破支撑，如图4-7所示。 图4-7 沪深300指数期货正向破支撑点位实例，目前技术趋势为跌势，价格反弹之后又下跌且跌破前期低点（支撑位）即为正向破支撑点位。破此支撑点位有利于价格的继续下跌，所以称为正向破支撑点位 比如沪深300指数期货，日K线图目前技术趋势是涨势，前期高点为2800点，当价格回调之后又上涨到2800之上时即为正向破阻力。相反，如果日K线图目前技术趋势是跌势，前期低点为2800点，当价格反弹之后又下跌至2800以下时即为正向破支撑。 （4）反向破支撑或阻力。如果目前技术趋势为涨势，当价格下跌到前期低点，即支撑位以下时即为反向破支撑，按技术趋势的判定标准，此时技术趋势由原来的涨转变成跌势，如图4-8所示。 图4-8 沪深300指数期货反向破支撑点位实例，目前技术趋势为涨势，当价格跌破前期低点（支撑位）即为反向破支撑点位。破此支撑点位意味着目前技术趋势由涨势转变成了跌势，交易方向由做多转变为做空，所以称为反向破支撑点位 如果目前技术趋势为跌势，当价格上涨到前期高点，即阻力位之上时即为反向破阻力，此时技术趋势转变为涨势，如图4-9所示。 图4-9 沪深300指数期货反向破阻力点位实例，目前技术趋势为跌势，当价格涨破前期高点（阻力位）即为反向破阻力点位。破此阻力点位意味着目前技术趋势由跌势转变成了涨势，交易方向由做空转变为做多，所以称为反向破阻力点位 比如沪深300指数期货，日K线图目前技术趋势是涨势，前期低点为2800点，当价格下跌到2800以下时即为反向破支撑，此时技术趋势转变为跌势。相反，如果日K线图目前技术趋势是跌势，前期高点为2800点，当价格上涨至2800之上时即为反向破阻力，此时技术趋势转变为涨势。 （5）牛皮市突破点位。牛皮市突破是指期货价格经过较大幅度的上涨或下跌后，开始横盘整理，价格变化幅度较小（甚至基本不变），成交量大幅萎缩，并持续数个交易日（至少2个交易日）之后，价格又开始大幅度上涨或下跌（不管是否与原来价格走势方向一致），且成交量明显放大。这是我根据自己交易经验总结的一种点位，由于出现这种点位跟进交易赢利概率较高，所以我特意单独列出，如图4-10所示，下一章我们还将详细讨论此种点位。 图4-10 沪深300指数期货牛皮市突破点位实例，突破前价格波动较小，成交量萎缩，突破时价格相对上一交易日上涨或下跌幅度较大，且成交量明显放大，此时跟进交易赢利概率较高 （6）其他一般点位。是除了上述特殊点位之外的其他点位，如图4-11所示。 图4-11 沪深300指数期货各种入市点位实例，有的点位可能同时属于两种点位 同一交易方向，不同点位入市交易，其赢利的可能性不同，甚至相差很大。 表4-1、表4-2分别为上海期货铜和大连大豆顺着目前技术趋势方向进行交易，各种点位下跟进交易赢利的可能性大小。 表4-1 上海铜顺着目前技术趋势，各种点位及价格波动形式下跟进交易盈利的可能性对比 表4-2 大连大豆顺着目前价格趋势，各种点位及价格波动形式下跟进交易盈利的可能性对比 从表中我们能非常明显地看出，有的点位赢利概率较高，有的点位却很低，在赢利概率高的点位，我们可以单量大些（投入的资金量多些），在赢利概率低时，我们可以单量小些或离场观望，甚至少量逆势反向短线交易。对其他交易品种的统计结果也能得到非常相似的结论。同时，我们也发现成交量的放大会强化该价格的波动，比如，如果当日价格是上涨或低开高走且成交量放大，则价格继续上涨的概率会有所增加，如果当日价格下跌或高开低走，则成交量放大会使价格继续下跌的可能性增加。 在以上6种入市点位中，如果顺着目前技术趋势方向进行交易，遇正向支撑或阻力、正向破支撑或阻力、反向破支撑或阻力、牛皮市突破点位属于高概率赢利点位，在这些点位入市，赢利的可能性较大，单量可以相对大一些，可以是一般点位的2倍；遇反向支撑或阻力时入市赢利概率较低，小于50%，在此点位一般不入市或反向短线交易（交易方向与目前技术趋势相反），单量也应该相对小些，可以是上述高概率点位的1/3；在其他一般点位进行入市交易，赢利概率虽然比高概率点位低一点，但大于50%，可以入市，但单量应该比高概率点位小，可以是上述高概率点位的1/2。 其他交易品种是否也有同样的规律，投资者不妨自己进行统计和总结。总的来说，同样的交易方向，不同的入市点位，其赢利的概率是不一样的，这对交易时的资金管理和单量控制具有非常重要的意义，高概率的入市点位，单量应该大些，低概率的入市点位，单量也应该相对小些，或者观望。 本章关键内容提示相同的交易方向，不同的入市点位，赢利的可能性会不相同，甚至相差很大，即使做对了方向，如果入市点选择不好，也会因破止损而造成亏损，因此，选择好入市点与选择交易方向同样重要。 统计发现，遇正向支撑或阻力、正向破支撑或阻力、反向破支撑或阻力、牛皮市突破点位，属于高概率赢利点位，在这些点位入市，赢利的可能性较大，单量可以相对大一些，可以是一般点位的2倍；遇反向支撑或阻力时入市赢利概率较低，小于50%，在此点位一般不入市或反向短线交易（交易方向与目前技术趋势相反），单量也应该相对小些，可以是上述高概率点位的1/3；在其他一般点位进行入市交易，赢利概率虽然比高概率点位低一点，但大于50%，可以入市，但单量应该比高概率点位小，可以是上述高概率点位的1/2。 一般情况下，成交量的放大有利于价格继续向该方向波动。当价格上涨或低开高走，且有成交量的配合时，价格继续上涨的可能性会增加，同样，当价格下跌或高开低走，且有成交量的配合时，价格继续下跌的可能性会增加。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货投资艺术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章 蜡烛图与趋势线]]></title>
    <url>%2F2021%2F01%2F27%2F%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E8%B6%8B%E5%8A%BF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章将把蜡烛图技术与趋势线市场对趋势线的突破以及过去的支撑区和阻挡区等放到一起，进行综合的研究。我们可以通过许多方法来确定市场趋势，趋势线就是其中之一。这是技术分析师一种最基本的工具。 蜡烛线图的支撑线和阻挡线图11.1所示为一条向上倾斜的支撑线。至少需要两个向上反弹的低点才能连接出这样一条直线。这根支撑线表明，在这段时间中，买方比卖方更为主动、积极，因为在逐渐提升的新低点处，还能够引致新的需求。这根线标志着市场正处于上升趋势中。图11.2所示为一根向下倾斜的阻挡线。至少需要两个向下反弹的高点才能连结出这样一条直线。这条阻挡线表明，在这段时间中，卖方比买方更为大胆、积极，因为在逐渐降低的新高点处，依然吸引了卖方的卖出意愿。这根直线反映出市场正处于下降趋势中。 支撑线或阻挡线的潜力的强弱，取决于以下几个方面： 该直线曾经成功地经受市场试探的次数； 每次试探时交易量的多寡； 该直线维持有效的时间长短。 在图11.3中，并没有值得特别关注的蜡烛图指标。虽然如此，本实例还是能够揭示出蜡烛图的一个重要优势。无论您在普通线图上进行的是什么样的分析，在蜡烛图上都可以如法炮制。从这一实例我们看到，在这张蜡烛图上，图示头肩形的基本颈线的作法，与在线图上的作法同样便利。无论如何，我们从本章往下的内容还将看到，蜡烛图为趋势线分析进一步拓展了深度。 图11.3 原油——1990年7月，日内蜡烛图（蜡烛图上的趋势线） 如图11.4所示，3月下旬的低点（在173美元附近）形成了一个支撑区。4月下旬，市场对之进行了一轮成功的试探。正是借助于蜡烛图技术，我们才从4月的这次成功的试探中，拥有了一份额外的砝码，以形成看涨的预期。具体而言，从4月20日到22日，形成了一个启明星形态。 图11.4 CBS公司——1990年，日蜡烛图（蜡烛图上的支撑线） 如图11.5所示，通过对趋势线和蜡烛图指标的综合应用，我们获得了丰富的市场信息。这些信息的内容大体有如下几个方面： 图11.5 原油——1990年6月，日蜡烛图（蜡烛图上的支撑线） 1、在图示支撑线1（从1月底到2月初）的形成过程中，最初的2个决定点分别为1月29日的最低点和31日的最低点。2月7日是市场对该线的第三次尝试，并且这一天还是一根看涨锤子线。上述两个方面的要素综合起来，就构成了一个底部反转信号。对于在该区域买进的市场参与者来说，这根锤子线的低点可以用作设置保护性止损指令的参照水平。 2、图示支撑线2（从1月中到3月初）的意义比趋势线1重要，因为这根线维持有效的时间比后者长得多。3月2日，市场对该直线进行了第3次试探，并且形成了一根看涨锤子线。考虑到当时的主要趋势是上升的（正如向上倾斜的支撑线2所示），还有这根看涨锤子线，以及市场对该支撑线的成功的试探，这些因素相互验证，汇聚为3月2日的买入信号。在这种情况下，保护性止损指令的水平可以安排在这根锤子线的低点之下，或者设置在这根上升趋势线的下面。如果市场向下芽越了这根支撑线，则构成了警告信号，说明先前的上升趋势可能已经陷入困境。随后的孕线形态显露了最初一点端倪：当前趋势造上麻烦了。 本实例说明了采取止损措施的重要性。正如上述所讨论的，当市场以锤子线的形式试探支撑线2时，有不少理由可以推断市场还将进一步上涨。然而，市场却向下回落了。当我们人市交易时，一方面应当树立信心，但是另一方面，也应当始终留有几分余地，考虑到一定的不确定性。在市场操作中，尤其是在期货交易中，其中一个最重要的概念就是风险控制。采用保护性止损指令实际上是风险控制的同义词。 如图11.6所示，乌云盖顶形态1和2构成了一条阻挡线。乌云盖顶形态3恰好碰上了这条阻挡线，从而验证了这条线的技术意义：在这根线上，市场有充足的供给。 在图11.7中A点之前曾有过一段上涨行情（本图来显示），这段行情就结束于A点。这里大约为0.6419美元，为市场准备了一个初步的阻挡区。在点B处，出现了一根长腿十字线。此外，还有一点理由也值得我们多加小心，这根十字线刚好出现在A点所形成的阻挡水平的附近。通过点A和点B两个初始点，就确定了图示的阻挡线。本图是一张小时蜡烛线图，如果您使用了这样的日内图表，自然就会注意，在该线附近，市场的上冲行情可能将失败，因而采取相应的对策——尤其是在您同时还看到了验证性的看跌蜡烛图指标的情况下。在点C，也有一根长腿十字线（与B点处的相像），而且这里也接近这条阻挡线。结果，市场掉头回落。在点D处，是一根具备长长的上影线的白色蜡烛线，这是一个流星形态。市场在这根阻挡线处再次遭遇失败。在这根白色蜡烛线之后，紧随着一根黑色蜡烛线，并且后者覆盖了前者。这两根蜡烛线组成了一个看跌吞没形态。 采取保护性止损措施的重要性我们应当利用技术分析来用定风险／报偿的比例值。只有这样，才能为分析者提供一种行之有效的控制机制。由此形成以风险与盈利管理为基础的交易方式。所谓风险的确定，意味着通过设置保护性止损指令，帮助我们防范意料之外的不利价格变化。如果某位技术分析者没有采取止损措施，那么，他就白白地舍弃了技术分析最强有力的一部分长处。 我们应当在最初建立交易头寸的时候，就设置好止损水平：只有在这个时候，我们才是最冷静、客观的。只有在市场的演变符合我们本来的预期的条件下才能继续持有当初的交易头寸。如果后来的价格变化与我们的预期相反，或者哪怕只是未能证实我们的预期，届应当当机立断，平仓出市。如果市场的运动与您的头寸方向相反，您也许会认为，们必多此一举。实施止损措施呢——这不过是一段短暂的反方向变化。”这么一来，你就顽固地守着这个头寸不放，一心指望市场终将回到您的方向上来。请不要忘记下列两项事实： 1、所有的长期趋势都是由短期趋势开头的； 2、市场上绝无一厢情愿的余地，市场自行其是，既不在意您的想法，也不关心您的头寸。 市场并不在乎您是不是顺从了它的趋势。有一件事比犯错误还要命，那便是坚持错误。宁可放弃您的高见，不要丧失您的金钱。有能力及早地纠正自己的错误，其实是一件值得自豪的事。被市场落实了止损指令，就意味着认错服输。人们对承认错误深恶痛绝，因为这里面往往牵扯上了个人的自尊心和名声等。优秀的交易商从不过于固执己见。据说，著名的私人投资家汪伦．巴菲特信奉两项原则： 1、保全资本金； 2、绝不可忘记原因1。 采取止损措施与原则1实质上是相同的。我们的资源是有限的。因此，这些资源应尽最大可能地增长，至少，也应当妥善地加以维护。如果您在某个市场上遇到了市场方向与自己的头寸相反的情况，以这正是止损出市的时候也正是另寻好机会的时侯．想一想，何不将止损带来的损失看成您投资事业的成本。 既然如此之多的日本蜡烛图术语都发端于军事行话，我们不妨从这方面的意义上来看待止损这件事。每一笔交易都是一场战斗。在战场上即使是最伟大的将军，也不得不做出暂时的战术撤退；在市场上，我们同样不得不暂时地退却，战场上，统帅撤退的目的是要保存兵员和军火。我们的目的是挽救资金，保持心态的平衡。有时，你必须先输掉几仗，才能赢得最后的胜利。拿日本人的话来说，“只要钓得上鲑鱼，丢个把鱼钩是值得的。”如果您被止损出市，那就当失去一把鱼钩吧、没准，下一钩您就能钓上一条大家伙。 图11.8显示了两个吞没形态，其中吞没形态1对多头来说是个警告信号。几周过后又出现了其中第二个看跌的吞没形态。另一方面，吞没形态2的高点也是市场在图示阻挡线处的一次失败。图11.9所示为一根向上倾斜的阻挡线。这是一种连接逐渐上升的高点而成的趋势线。虽然这种趋势线不如在图11.1中所示的向上倾斜的支撑线流行但是对于多头者来说，这也是一种很有价值的研究手段。当市场向上逼近这类直线的时侯，多头者应当采取防范性措施，以防市场在此处向下回落。在这些防范性措施中，包括平回一部分多头头寸，实现部分利润，或者提高止损指令的水平，还可以卖出买权期权。尽管上述回落过程应该是暂时现象（因为主要趋势的方向是向上的），但是如果市场在此处遭到了失败，则可能构成了一个初步的、带有试验性质的指标，暗示市场可能从此开始新的下降趋势。 图11.10所示为一根向下倾斜的支撑线、这类直线人们也不经常使用，但是在某些场合下，对卖出做空者而言是极有用途的。具体来讲，这类向下倾斜的支撑线是下降趋势的一个标志（它的向下倾斜的坡度说明了这一点）。不过，如果市场能够成功地维持于这类支撑线之上，那么空头者就应当采取防范性的措施，以防备价格向上反弹。 在观察图11.11的时候，我们的注意力首先放在图示的向下倾斜的支撑线上（直线A）这条线与图11.10所示的基本一致。连接低点L1和L2，就得到了这条试验性的支撑线。在L3所示的那蜡烛线上，起初市场已经差不多触及了这条直线，而后又从此向上反弹。这就证明这条支撑线是有效的。L4所示的低点，不仅标志着市场对这条向下倾斜的支撑线的试探成功，而且形成了一个着深刺透形态。这个时刻正是平回空头的大好时机——或者，至少也应当采取一定的保护性措施，比如降低止损指令的水平，或者卖出卖权期权。不过，此时还不是买进做多的良机，因为主要趋势依然是向下的（这一点就反映在当前两条疲软的管道线上，一条是向下倾斜的支撑线A，另一条是位于直线A上方的阻挡线,以虚线表示）。在本实例中，后来的结局表明，L4所示的低点正是一轮强劲的牛市行情的起点。这段上涨行情持续了几个月，直到出现了一个长腿十字线（这是一根黄包车夫线，因为它的开市价和收市价居于当日价格区间的中点），以及一根上吊线才结束。请注意，1O月19日和20日还组成了另一个刺透形态。 往下，我们还是研究图11.11所示的实例，再看一看图示的向上倾斜的阻挡线（直线B）。这根直线的轮廓与图11.9所示的基本一致。从1月15日开始，市场形成了一系列逐渐抬升的高点。根据这根直线（以及图上用虚线表示的那条支撑线），我们可以看出，市场当时正处于上升趋势中。3月6日，当市场在这条向上倾斜的阻挡线上遭到失败时，就对多头者发出了一个警告信号，要求他们采取防范性措施。请注意，市场在对该阻挡线的第三次试探过程中，还构成了一条流星线。它具有很长的上影线和小小的实体。在这条流星线之后，三根蜡烛线都是上吊线，或者是上吊线的变体．把上述各方面因素综合起来（市场从阻挡线上向下回落、流星线、相继出现的几根上吊线），就得到了一个明确的警告信号；市场将很快进入调整状态。 破低反涨形态与破高反跌形态在绝大部分时间内，市场并不处于趋势状态，而是处在水平的波动区间中。在这样的情况下，市场就达到了某种相对和谐的状态，牛方和熊方相安无事、平分秋色。在日文中，用来描述安宁和平静的词是“和”。当市场处于横向的交易区间中时，我喜欢将这种状态看成一种“和”的状态。根据一份研究抽测，大约有70％的时间市场是处在非趋势状态的。如此一来，如果哪种工具能够在这种环境下提供有利可图的入市点。那么，这种交易工具将是极有实用价值的。事实上，针对这样的市场状况，我们有一套行之有效的技术工具。这就是所谓的“破高反跌形态”和“破低反涨形态”。如果将这两个概念应用在蜡烛图上，那么更是大有用武之地。破高反跌形态与破低反涨形态最初是根据理查德．威科夫的有关思想发展起来的，他于20世纪早期推广了这一思想。 正如前面所介绍，当市场处于“和”状态的时候，交易活动集中在一个平静的水平区间中。然而，即便在这样的水平区间中，熊方或牛方有时候也会不甘寂寞，企图冲击前一个高点或低点的水平。在这种情况下，交易机会就出现了。具体而言，如果市场向上暂时突破了某一阻挡水平，或者向下暂时突破了某一支撑水平，但又无力维持战果（也就是所谓的“伪突破”），那么，这种场合就为我们提供了一个颇有吸引力的交易良机、在这样的局面下，很可能将发生以下的价格变化：市场将从水平整理区间的这个边界回到与之相对的那个边界。 如图11.12所示，市场一度向上突破了一个阻挡水平，但无力维持这一局面，于是价格重新跌回过去的高点之下，形成了一个“伪突破”。在这样的情况下，我们应当卖出做空．并且将保护性止损指令的水平安排在当前的新高水平以上。价格目标是，市场再度向下试探这个水平整理区间的下边界。这类虚假的向上突破，就构成了所谓的“破高反跌形态”。如果在破高反跌形态的形成过程中，同时形成了某种看跌的蜡烛图指标，就实在是卖出做空的大好机会了。 同破高反跌形态相反的是破低反涨形态。在破低反涨形态中，价格起先曾经向下突破了以前的低点水平。后来，价格反弹回来，返回到曾被突破的支撑区的上方（如图11.13所示）。换句话说，这个新低水平是不能维持住的。在这种情况下，一旦价格向上推回到过去的低点水平以上，则应当买进。我们的价格目标是，市场将重新向上试探这个水平整理区间的上边界。止损指令的水平可以放置在破低反涨形态当日的最低点附近。利用破高反跌形态和破低反涨形态来进行交易是充分可行的，因为它们既提供了一个清晰的价格目标（即横向交易区间的另外一个边界），也提供了一个清晰的保护止损指令的参考水平（即“伪突破”当日所形成的新高或新低水平）。 图11.14是一个很好的实例，显示了一个蜡烛图上的破高反跌形态。A所示的这一天标志着整个水平交易区间的高点，这是一个阻挡水平（请注意它的前一天是一根上吊线，这根上吊线发出了警告信号，表明之前的上升趋势已经结束）。L1和L2所示的两个位于同一水平的低点，界定了这个水平交易区间的下边界。在B所示的这一天，出现一个破高反跌形态。这就是说，当日市场曾经向上突破了先前A处的高点，但是这个新高水平未能维持住。在B处，牛方无力维持这个新高水平，由此构成了一个看跌的信号。另处还有一项负面的因素，B所示的这一天同时也形成了一个流星线。有时候，流星线是破高反跌形态的一个组成部分。在这种情况下，就构成了我们卖出做空的有力动机。在本实例中，似乎一个看跌的破高反跌形态加上一根流星线还不足以让个方的脊梁骨浸透寒气，更有甚者，在B所示的日子之后，又出现了一根上吊线！通过B处的破高反跌形态，我们得出了一个价格目标，那就是该水平区间的下边界，即L1和L2所示低点的水平。 如图11.15所示，在5月1日，CRB指数向上触及248.44点，创出了当前上涨行情的新高。5月10日，个方使尽招数，使币场一度蹭到比这个水平高25个基本价格单位的位置。但是，他们不能够维持住这一新高水平。这一次失败的尝试构成了一个破高反跌形态。同时，5月10日也是一根流星线，标志着之前小规模上升趋势的终结。于是，我们有充分的理由卖出做空，并且把相应的保护止损指令设置在5月10日最高点附近。价格目标是，市场将重新向下试探当前交易区间的下边界，即大约245.00的水平附近。 如图11.16所示，4月5日的最高点向上超过了3月初形成的高点，它位于5.40美元附近的水平。然而，牛方却来能守住这块新高地。这就形成了一个破高反跌形态。在这个破后反跌形态的次日，是一根上吊线，由此证实了这个破高反跌形态的看跌意义。如图11.17所示，1987年7月，CRB指数在220点附近建立了一个底部，是通过一个孕线形态形成的。尔后一周的长长的白色蜡烛线对由这个孕线形态的低点进行了成功的试探。同时，这根白色蜡烛线也是一根坚挺的捉腰带线。在当年的第三季度，220.00的水平曾经被短暂地向下突破，但不久，市场剧烈地向上反弹，并且在向上反弹的过程中，产生了一根锤子线和一个破低反涨形态。根据这一破低反涨形态，这轮行情的价格目标是，市场重新向上试探先前的高点，即235点附近。 如图11.18所示，1月初的低点曾在2月下旬一度为市场向下穿破。但市场未能维持住这一新低水平，这就意味着这里形成了一个破低反涨形态。另一方面，该破低反涨形态当日也是一根锤子线。两个方面的看涨信号结合在一起，为技术分析者提供了充分的警告信号：市场即将回头向上，重新尝试1月、2月形成的价格区间上边界，即大约位于78美元的水平。有趣的是，后来的上涨行情果然于3月中旬时在接近78美元的位置告终，其反转形态是一个十字黄昏星形态。 如图11.19所示，在图示的孕线形态出现后，市场开始下滑。后来，市场在锤子线1处恢复了稳定。同时，这根锤子线也是市场对位于0.50美元附近的旧支撑水平的成功试探。在锤子线2处，又发生了一段小规模的向上反抽行情。在这根看涨锤子线上，市场如螨蜒点水，向下掠过位于夏天的低点之下的一个水平（比该低点低25个基本价格单位），但是熊方未能够坚守住这个新低水平。于是，形成了一个破低反涨形态，再加上一根锤子线、一个平头底部形态，汇聚成不容忽视的看涨的证据。如图11.20所示，在3月12日所在的一星期中，大豆市场向下触及了一个处于5.96美元的低点，形成了一个看涨吞没形态，然后便开始上涨。4月3日，价格曾向下跌破这个低点，创造了一个新低水平。不过，这一新低水平未能维持住，导致了图示破低反涨形态的诞生。更有甚者，这一天市场还构造了一个看涨吞没形态。 为什么破低反涨形态与破高反跌形态具有如此神奇的效用？要回答这个问题，就得诙到拿破仑的一段话．有人问他，他认为什么样的军队是最好的军队。他的回答简明扼要“获胜的军队。”。我们不妨把市场看作两支部队——牛方和熊方——拼杀的战场。当市场处于水平的交易区间中时，双方拼力争夺的地盘特别明确，就是这块水平区间。其上方的水平阻挡线是熊方必守的最后防线。下方的水平支撑线是牛方必守的最后防线。 有时候，交战的一方，比如大户交易商、商业帐户经理，甚至可能是自营交易商，会派出小股的“侦察兵”（这是我的说法，不是蜡烛图本来的术语），前去试探对方部队守土的决心。举例来说，牛方可能向上推一推。企图使价格上升到一条阻挡线之上。在这样的交火中，我们就得密切关注明方表现出的坚定程度。如果牛方这支侦察部队能够在敌方的土地上安营扎寨（这就是说，在数日内，市场的收市价都处于该阻挡线的上方），那么牛方的向上突破就成功了。牛方的新生力军将要增援这支先头部队，市场就将向上运动。只要这块滩头阵地掌握在牛方的手中（就是说，市场已经把这个旧的阻挡区转化为新的支撑区，并维持其支撑作用），那么牛方的部队就会控制着市场的局势。在图11.21中，显示了这种“火力侦察兵”现象的一个实例。 在5月下旬，市场曾在3.54美元处形成了高点。后来，牛方的多支侦察部队都企图在3.54美元之上的熊方领土上抢占一块立足点。但他们仅仅能够在日内价格变化过程中，将市场暂时推升到3.54美元之上、牛方未能建立滩头阵地，也就是说，没有收市价进入熊方的势力范围。于是，牛方开始后撤，结果怎么样？市场重新回到了该水平区间的下边界，即3.45美元左右的水平。6月初，市场曾经形成过一个看跌吞没形态，这个蜡烛图信号说明，熊方依然控制若市场的动向。6月12日和13日的流星线同样也为上述景象增添了疲弱的气氛。在本实例中，4月初也曾经发生了另一个“牛方侦察兵事件”。由于牛方未能维持在3月中旬的高点之上，他们不得不后撤。结果是，市场重新向下试探3月下旬的低点。上述失败过程也得到了一根看跌的流星线的验证。 极性转换原则日本人有句谚语：“大红的真漆盘子毋需另加装饰”这种“简单的就是美好的”的概念，道破了市场技术分析理论的真谛。在蜡烛图表分析的实践中，我常常对这一原则身体力行。这一原则既简单明白。又犀利、得力——过去的支撑水平演化为新的阻挡水平；过去的阻挡水平演化为新的支撑水平。这，就是我所说的“极性转换原则”。图11.22就是支撑水平转化为阻挡水平的情形。图11.23是过去的阻挡水平转化为新的支撑水平的情形。这种极性转换现象的技术潜力的大小与以下几个方面成正比： 1、市场对过去的支撑／阻挡水平曾进行试探的次数； 2、每次试探时的交易量、持仓量的大小。 关于极性转换原则（在传统的用语中，这个概念不是这样描述的），在各种介绍技术分析基础知识的书籍中，都是作为一条基本原理来讨论的。虽然如此，这块技术分析的瑰宝并没有得到充分的重视。为了讲清楚这条规则如何具有普遍适用性、如何能够发挥其良好的功效，下面我们简要地研究一些实例。这些实例既覆盖了不同的市场，也照顾到不同的时间单位。 如图11.24所示，旧的阻挡水平转化为新的支撑水平的情况共有四处。如图11.25所示，1987年底和1988年中的几个低点后来演变成1989年全年的一个重要阻挡区。如图11.26所示，1987年位于27000点附近的阻挡水平一旦被向上突破，就转化成了1988年的一个重要支撑水平。 为了兼顾各种不同的时间尺度（在上述几个实例中，我们已经从日图、周图、月图上看到了这一原则的各种实例），我们还要研究一番日内图表，如图11.27所示。从本图明显可以看出，从7月初到7月中，市场的阻挡水平位于0．72美元。这个0．72美元的水平一旦在7月23日被向上突破，立即转变为支撑水平。而当7月24日和25日的高点0．7290美元被向上突破后，也转儿为一个支撑水平。 通过图11.28，我们可以体会到极性转换原则的实用价值。从1989年底到1990年，本市场发生了一轮毫不含糊的上涨行情。199O年上半年，市场一直处于图示的水平波动区间中，其支撑水平如虚线所示，位于1.85美元附近。1990年6月，当这个水平被市场向下突破后，下一个支撑水平在什么地方呢？在1989年底到1990年初的上涨行情中，从1.25美元到2.05美元的价格变化一蹴而就，基本上是直线上升，因此在这段行情中找不到明显的支撑水平。不过，当这里的1.85美元的水平被突破后，我们预期下一个支撑水平在1.65美元附近。我是从何处得出这一数字的呢？有两条理由。第一，上述幅度达0.80美元的上涨行情的50％回撤水平在1.65美元上下。第二，这条理由更加重要，在点A所示的区域，前一个阻挡水平大约也在1.65美元左右。这就意味着现在这里将构成支撑水平。如图所示，一系列跌停板构成了6月的抛售行情。这个抛售行情果然在1.66美元收场。 随意拿起任何一张图表，日内的、逐日的、逐周的，或者更长时间单位的，都极有可能看得到极性转换原则的实例。为什么这一原则既如此简单、又极其有效呢？连本溯源，其原因在于技术分析之所以成立的根本道理：技术分析估量了交易圈和投资界的人群情绪，研究了市场参与者的群体行为。由此可见，一种技术分析工具越是能够有效地估量市场的群体行为，那么这种技术工具就越是能够发挥市场研究功效。极性转换原则之所以如此成效卓著，正是因为它建立在坚实的市场心理学原理之上。什么样的交易心理学原理呢？这关系到下面两种心理过程；当市场的变化与自己的头寸方向相反时，人们作何反应当人们判断自己可能会坐失市场运动的良机时，作何反应。 请您自问一下，在您的市场图表上，什么样的价格最重要？是当前趋势的最高价吗？是当前趋势的最低价吗？还是昨日的收市价？都不是。在任何市场上，最重要的价格就是您在开立头寸时的交易水平。人们与自己曾经买进或卖出的价格水平结下了强烈的、切身的、情绪化的不解之缘。 如此一来，在某个价格区域发生的交易活动越多，则越是有更多的市场参与者对这一水平牵扯上深深的情绪。上述心理过程与旧的阻挡水平演变为支撑水平、旧的支撑水平演化为阻挡水平这一事实有什么关系呢？让我们来看一看如图11.29所示的实例，找一找问题的答案。12月下旬，一场陡峭的抛售行情结束于5．53美元的水平（在点A处）。当市场再一次向下试探这个水平的时候，至少有三类市场参与者可能要考虑买进。 第一群市场参与者可能是那些在12月下旬的抛售行情中一直等待市场稳定下来的人。现在，他们发现市场在这里受到了支撑，于是得到了一个入市参考点——5．33美元的水平（点A所示的12月28日的低点）。几天以后，该支撑水平成功地经受住市场的试探，在这个过程中，很可能市场已经吸引了新的多头者加盟。 第二群市场参与者可能是那些原来持有多头头寸、但是在12月下旬的抛售行情中被止损平仓的人。在这些被止损出市的老多头中，当他们看到2月中旬从点B到点B1的上涨行情时，可能有一部分人会觉得当初判断白银市场为牛市是正确的，只不过买进的时机没有选择好。现在，是买进的时候了。他们希望借此机会，证明自己当初的看法是有道理的．于是，等到市场再度向下回落到点C的时候，他们便重新买进，建立多头头寸。 第三群市场参与者可能是那些曾经在A处和B处买进的人。他们也注意到了从B到B1的上涨行情，因此，如果有“合适的”价位，他们就可能为已有的头寸加码．在C处，市场返回了支撑水平，他们自然就得到了一个合适的价位。于是在C处，又出现了更多的买进者。依此类推，当市场再度向下撤回到D点的时候，自然还能吸引更多的多头者入市。 但是不久，多头者的烦恼就开始了、在2月下旬，价格向下突破了A、B、C和D处形成的支撑水平。曾经在这些旧的支撑区域买进的人，现在无一例外地处于亏损状态。他们当然希望以最小的代价来摆脱这些亏损的交易。当市场上冲到这些多头者买进的区域（在5.53美元附近）时，他们谢天谢地，赶紧乘机平回手上的多头头寸。这么一来，当初在A、B、C、D处买进的市场参与者，也许现在就变成了卖出者。这一点，正是过去的支撑水平演化成新的阻挡水平的主要缘由。 在过去的多头中，凡是在3月初较小的上涨行任中没有下决心出清亏损头寸的人，后来就不得不忍受煎熬，眼睁睁看着市场下跌到5美元左右。于是，他们便利用市场的下一轮上进行情平仓了事，求解脱。这一行情发生在4月初（E处）。图11.29显示了支撑水平是如何转化为阻挡水平的。阻挡水平转化为支撑水平的道理，与上面讨论的内容是一致的，只是方向相反而已。千万不要因为这一原则着似简单，就忽视了它的重要性。这一原则是行之有效的——如果将它与蜡烛图指标综合起来，则尤其得力。我们不妨拿E处的情况作个例子。请注意，这里有一根十字线，它出现在一条高高的白色蜡烛线之后，这就意味着，市场前途不容乐观。这一蜡烛图信号与图示的阻挡线不约而同地出现在同一个位置上。在点F处，市场再度上演了相同的一幕。 如图11.30所示，点A和B所示的高点在1986年底，以及在1989年内转化为一个支撑水平。请注意这条支撑线的力量是如何体现出来的。在1989年的低点处，市场在这个支撑水平上接连形成了两根锤子线。 如图11.31所示，点A和点B分别出现在9月里和10月初，市场在这两处维持了一个位于1230美元上下的支作水平。1O月9日，一旦熊方将市场拖换到这一水平以下，1230美元附近就转化为一个阻挡区域。在点C处，市场对这个新的阻挡水平的第一次试探失败了，随后价格开始下跌。直至图示的看涨吞没形态出现，这段下跌行情才告一段落。在这个形态之后，跟随着一段小规模的上涨行情。但是，这个上涨行情在1230美元的水平上同样陷入了停顿。此外，市场在这里还形成了一个乌云盖顶形态。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十章 蜡烛图信号的汇聚]]></title>
    <url>%2F2021%2F01%2F27%2F%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%B1%87%E8%81%9A%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言“慎之又慎”。 本章将要研究，如果在同一个价格区域内汇聚了一群蜡烛图形态，或者一些特别的蜡烛线，那么，此处将构成一个重要的市场转折点。如图10.1所示，起先有些蜡烛图指标汇聚在一起，预示了价格的回落；后来又有一群蜡烛图信号一起出现，标志着抛售行情的结束。 6月初，首先出现的是一根上吊线，紧随其后的是另一个负面技术信号——一根十字线。从此，价格开始下跌，直至另一系列蜡烛图指标揭示出一个重要的市场底部。在后面这群指标中，首先是一根锤子线。次日，是一根坚挺的吞没蜡烛线。几天之后，市场通过一场小规模的下跌行情证实了这个支撑水平的坚固性。在这轮下跌行情中，该锤子线的低点维持得很好。于是，市场对该低点的上述第二次尝试造就了一个平头底部形态。 在图10.2中，9月的锤子线引发了一段上涨行情。11月下旬，在图示的长期国债市场上，构筑了三个蜡烛图顶部反转指标，它们终结了这段上涨行情。这三个指标分别是： 一根上吊线；一根十字线；一根流星线，这是最后的一击。 图10.3说明单独一根蜡烛线也可能发出多方面的技术信号。 4月初，先有一根长长的白色实体，后面跟着一个小实体，并且这个小实体蜡烛线具有长长的上影线。从后面这根蜡烛线的外形看，这是一根疲软的流星线。其次，这根线的小小的实体（处于前一天的实体的内部）还完成了一个孕线形态。最后，在这根流星线上，上影线的顶端（即，当日的最高点）恰好标志着市场向上试探2月的高点1600点的失败。 如图10.4所示，在几周的时间范围内，该市场先后形成了一个平头底部形态、一个看涨吞没形态，以及一根锤子线。 图10.5显示，从7月中到7月底，出现了一系列看跌的蜡烛图指标.其中包括一个十字星形态，其后跟着三根上吊线（在图中我们用数字1、2、3作了标记）。在上吊线1和2之间，还有一根流星线。 如图10.6所示，在一个看跌蜡烛图信号内部，还包含着另一个看跌蜡烛图信号。12月上进行情的高峰是通过一根上吊线形成的。这根上吊线同时充当了一个黄昏星形态的星线的角色。 图10.7显示，从5月9日到11日，在1.12美元的区域，产生了一系列蜡烛图顶部反转信号。 5月9日是一根高高的白色蜡烛线，它的后面跟着一个小实体蜡烛线。后面这根蜡烛线又是一根上吊线。另外，这根蜡烛线还与它前面的那根蜡烛线一起完成了一个孕线形态。5月11日，市场再度向上冲击1.12美元的水平。这次冲击还是失败了。并形成了一根流星线。上述三天的最高点差不多都处在同一个水平。通过这群蜡烛线，市场构造了一个短期的顶部。于是，三天之内，出现了四类看跌指标： 一根上吊线；一个孕线形态；一个流星形态；一个平头顶部形态。 市场从上述高位向下回落。1.12美元的水平演变为一个重要阻挡水平。在6月中旬的向上反弹行情中，牛方未能向上突破这一水平，从而证实了它的重要性。1.12美元的价格水平之所以重要，还有另外的原因。当6月28日市场向上突破这一水平以后，它就转化为一个关键的支撑水平。请注意观察6月28日长长的白色蜡烛线之后的那根十字星线、我们知道，十字线出现在长长的白色蜡烛线之后，就构成了顶部反转信号。这就意味着之前的上升趋势即将结束。在这根十字线之后的两天里，市场显露出一副上气不接下气的模样，两根黑色的蜡烛线团在一个水平区域里。市场已经耗尽了上涨的动力——或者说从市场的表面看来，似乎已经耗尽了上升力量。然而，还记得从5月9日到11日形成的那个阻挡区吗？ 7月2日和3日的两个黑色蜡烛线的最低点，恰恰以这个旧的阻挡水平为支撑水平，维持在该水平之上。熊方使尽浑身解数，企图打破这一支撑水平，但是终究未能如愿。除非这个支撑水平被跌破，否则，就打不断自从6月26日以来的短期牛市的脊梁骨。在本实例中，从5月9日到11日汇聚起来的蜡烛图信号，形成了如此重要的一个市场顶部，甚至在几个月以后，它仍然能够作为新的重要支撑水平而发挥作用。 如图10.8所示，1987年年中，一系列蜡烛图信号宣告了一个市场顶部的到来。 具体说来，在一个月的时间里，市场先后形成了一根上吊线、一根十字线，以及一个乌云盖顶形态。当这个乌云盖顶形态出现后，就发生了一轮抛售行情。并且在其发展进程中，形成了一个窗口。在市场形成另一轮下跌行情之前，曾有短暂的向上反弹，但该窗口起到了阻挡作用。这段抛售行情最后以一个平头底部形态和一根看涨捉腰带线收场（虽然这根白色蜡烛线有一点下影线，但其下影线微不足道，足以将它看成一个看涨捉腰带形态）。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章 蜡烛图技术汇总]]></title>
    <url>%2F2021%2F01%2F27%2F%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E6%8A%80%E6%9C%AF%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： “抔土虽小，聚之成山” 图9.1 小麦——1990年5月，日蜡烛图（蜡烛图技术汇总） 图9.1体现了以下各方面内容。 1、这是一根看涨的倒锤子线。下一天的开市价较高，并且形成了一根白色蜡烛线，从而验证了倒锤子线的信号。2、这是一个停顿形态，意味着当前市场向上的努力已经限入困境。3、在上述停顿形态中，最后一根蜡烛线还是一根上吊线，这就为该形态抹上了更深的疲弱色彩。4、序号4处的黑色蜡烛线证实了上述上吊线的信号。综合3、4两处，既组成了一个平头顶部形态，也构成了一个看跌吞没形态。5、这里又是一根上吊线。6、这是一个看涨吞没形态，并且其中后一根蜡烛线是一根坚挺的白色捉腰带线。两方面均意味着上涨行情即将到来。7、上述上涨行情一直发展到这根上吊线出现的时候。这几乎是一个理想的上吊线，它具有极长的下影线、小小的实体、几乎没有上影线。在下一天的价格变化中，没有向上的运动，由此验证了这根上吊线的看跌性质。8、这是一根倒锤子线，并且下一天的行情验证了它的信号。这根蜡烛线同时也是一个启明星形态的组成部分。9、从8处的倒锤子线开始，市场形成了一轮历时三天的上涨行情，到了此处，便为这个孕线形态所中止。10、这是一根锤子线，象征着市场底部可能来临了。11、这里出现了一个看涨刺透形态的变体。其中第二根白色蜡烛线的开市价本应低于前一天的最低价，但是这里仅低于前一天的收市价。在第二根蜡烛线上，市场开始上涨，其收市价明显地向上穿入到前一天黑色蜡烛线实体的内部。12、这里又是一根上吊线。但是这根线的信号在下一天没有得到验证，因为市场在开市时已经向上跳出。13、此处出现了一个看跌的吞没形态。14、这里形成了一个经典的刺透形态。在本形态中，第二天还是一根坚挺的捉腰带线，并且其收市价位于当日最高点。另外，这根线还成功地向下试探了11处低点的水平。15、十字星形态标志着当前上涨行情的结束。这轮上涨行情开始于14处。16、这是一个孕线形态，它导致了之前价格下跌过程的终结。 图9.2 原油——1990年6月，日蜡烛图（蜡烛图技术汇总） 图9.2体现了以下各个方面的内容。 1、这是一个平头底部形态，并且其中还有一根白色的看涨捉腰带线。2、此处为乌云盖顶形态。3、一个窗口，意味着此处将构成一个阻挡区。4、后来出现了一个启明星形态。这个启明星形态有一个不同寻常之处，其中第三天不是一根长长的白色实体。尽管如此，这根蜡烛线还是明显地向上推进到了第一天的白色蜡烛线之内。另一方面，本启明星形态也是对前一周低点的成功的试探。5、从4处开始的上涨行情为此处一个小型平头顶部形态所终结，这个平头顶部形态恰好停止在3处窗口的位置上。6、这是一根倒锤子线，它得到了下一天的验证。从这个倒锤子线出发的上涨行情向上推过了上述窗口的阻挡水平。7、一个孕线形态。它暂时中断了先前的趋势（在本例中，先前的趋势就是那段上涨行情）。8、此处，前一天是一根很大的黑色蜡烛线，但它的疲弱意味已经被后一天的小实体中和掉了。这两根线组成了一个孕线形态。这就表示之前的市场运动（在本例中是一个下降趋势）已经失去了动力。9、这是一根锤子线。它出现在8处的孕线形态之后，进一步证明之前的下降趋势已经完结。10、此处是一个十字星形态，警告我们顶部就要降临了。11 这里是一个孕线形态，构成了另一个警告信号，说明之前的上升趋势已经到头了。12、这是一个乌云盖顶形态。字母X（在2月初）、Y（在2月中）、 Z（在2月底）所标出的价格变化过程形成了一个三尊顶部形态。13、一根锤子线。14、又是一个孕线形态。该形态之前的短期上升趋势起源于13处的锤子线，本形态一出现，这段上涨行情就短路了。15、这里有两个窗口，它们应起到阻挡作用。16、一根倒锤子线。同时，这里也组成了一个平头底部形态。17、由上述倒锤子线引发的上涨行情遭到了由15处的窗口形成的阻挡水平的拦截，于是这段行情夭折了。18、一个孕线形态，它暗示着当前的下降趋势可能已经终结。19、这是一个乌云盖顶形态。 图9.3 美国长期国债——1990年6月，日蜡烛图（蜡烛图技术汇总——顶部反转形态） 在图9.3中显示了一系列顶部反转形态。 1、在5月中旬，出现了一个孕线形态，这就加大了当前上升趋势已经结束的可能性。2、6月1日是一根高高的白色蜡烛线，在它后面，是一根较小的白色蜡烛线。于是形成了一个停顿形态。3、一个看跌的吞没形态。4和5、前头是一根十字线，后头是一根上吊线——当然不是一种健康的组合。6、这也是一根上吊线。7、此处的孕线形态表明，市场已经从上升趋势转入一个犹豫不决的转折点。8、紧随着上述孕线形态，出现了一个看跌吞没形态。由此可见，市场的犹豫心理很快就被卖方坚定的信心打消了。这个实例还说明了另一个问题。在这个吞没形态中，因为第二天的黑色蜡烛线并未向上创出新高，所以按照西方技术分析方法，这一天不属于反转日。然而，在蜡烛图技术中，这里却发出了一个很扎眼的反转信号。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 持续形态]]></title>
    <url>%2F2021%2F01%2F27%2F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%8C%81%E7%BB%AD%E5%BD%A2%E6%80%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是窗口？窗口意味着什么？ 市场参与者应当顺着窗口形成的方向建立头寸，窗口还将演化为支撑区或阻挡区。怎么理解？ 前言“勇敢者，天助之”。 绝大多数蜡烛图信号都属于趋势反转信号。不过，还是有一群蜡烛图形态构成持续性技术指标的。拿日本人的话来说，“有时当买进，有时当卖出，有时当休战”。在这类持续性形态中，大多意味着市场正处于休整阶段，需要喘息一下，然后，市场仍将恢复先前的趋势。本章将要讨论的持续形态有：窗口（以及含有窗口的一些蜡烛图形态）、上升三法和下降三法，以及白色三兵形态。 窗口我们曾有过介绍，日本技术分析师一般把价格跳空称为窗口。按照西方的表达方式，我们说“回填跳空”；在日本，人们则说：“关上窗口”。这一部分，我们先来阐述窗口的基本概念，然后还要探讨包含窗口（价格跳空）的其它一些形态。在这样的蜡烛图形态中，跳空包括并列黑白线、跳空突破形态，以及跳空并列白色蜡烛线。 所谓窗口，是指在前一根蜡烛线的端点与后一根蜡烛线的端点之间存在着一个价格缺口。如图7.1所示，是在上升趋势中形成的一个“打开的”窗口。在图示的前一根蜡烛线的上影线与后一根蜡烛线的下影线之间，存在一段价格缺口。如图7.2所示，是下降趋势中的一个窗口。从中可以看到，在前一天的下影线和当日的上影线之间，未曾发生任何价格活动。根据日本技术分析师的观点，市场参与者应当顺着窗口形成的方向建立头寸。同时，窗口还将演化为支撑区或阻挡区。因此，在上涨行情中，如果出现了一个窗口，则意味着价格将进一步上升。并且，今后当市场向下回撤时，这个窗口将形成其底部支撑水平。如果市场在向下回撤时关闭了这个窗口，并且在窗口关闭后，市场的抛售压力依然存在，那么，先前的上升趋势就不复成立了。类似地，在下跌的价格环境中，如果出现了一个窗口，则意味着市场还将进一步下降。此后形成的任何向上价格反弹，都会在这个窗口处遭遇阻挡。如果该窗口被关闭，并且在窗口关闭后，上涨行情继续发展，那么，原来的下降趋势就完结了。 传统的日本技术分析理论（也就是蜡烛图技术）确信，当一个窗口形成后如果市场开始调整，那么，价格将回到该窗口处。换言之，市场很可能回头试探一个打开的窗口。因此，在上升趋势中，我们可以把窗口看作买进的参考点，乘市场回撤到这里时入市。另一方面，如果在窗口关闭后，市场的抛售压力仍然不消退的活，那么，就应当把多头头寸平仓出清，甚而可以考虑建立空头头寸。如果在下降趋势中出现了一个窗口，就应当采取与上述相反的对策。 在图7.3中我们看到，自图示的看涨吞没形态开始，市场形成了一轮上涨行情，在其演进过程中，出现了窗口1和窗口2。在窗口2之后，市场上“掉下”了一颗流星。在流星线的下一个交易日里，市场以较低的价格开市，关闭了这个窗口（也就是说，填回了这个价格跳空）。请记住如下概念：窗口之后发生的市场回撤，将重新返回窗口。从这一点来看，在本例中市场向下回落到该窗口处，正是意料中事。如果在这个窗口被关闭以后，市场的抛售压力仍然持续着，那就标志着上升趋势已经终结了。不过，这里并未形成这样的局面。一旦该窗口被关闭，市场的抛售压力就消解了。另外，市场在窗口1所形成的支撑区维持得很好。在2月20日所在的一个星期中，市场徘徊不前。后来，市场曾再度向下试探窗口2处的支撑水平。这次试探又成功了，于是市场返身向上推进，打开了窗口3。这个窗口的意义非同一般，因为它标志着市场以跳空形式向上突破了1.10美元的重要阻挡水平。1.10美元的价格水平，过去曾经构成了一个阻挡区域，现在被向上突破了，应当转变为一个支撑区。这里一方面受到上述支撑作用，另一方面还受到由窗口3构成的支撑作用，因此，我们有两方面的理由来预期1.10美元将提供坚实的底部支撑。后来，在整个3月，该区域的确为牛方提供了一个扎扎实实的立足点。 图7.3 铜——1990年5月，日蜡烛图（窗口作为支撑区） 日本人相信，从横向整固区间中跳起的窗口，以及从新高价位上跳起的窗口，值得特别注意。请看图7.4。3月初的窗口向上突破了0.15美元的水平，这是市场对为期3个月的横向调整区间的重要突破。于是，0.15美元附近的这个窗口就具备了双重的支撑作用。这种支撑作用首先来自该窗口本身，其次，因为这里过去是阻挡区，现在已经转化为支撑区了。请注意，在随后的几个月中，这个窗口为市场提供了有力的支撑。4月2日和3日组成了一个孕线形态。这一形态表明，先前的趋势（在本例中，为下降趋势）已经耗尽了能量。数日后，市场又形成了一个看涨吞没形态。4月16日，出现了一根倒锤子线。上述这些看涨信号统统发生在本窗口所在的0.15美元的水平附近。 图7.4 原糖——1990年7月，日蜡烛图（窗口作为支撑区） 如图7.5所示，1988年 3月，一个看涨吞没形态预示着上冲行用的到来。在这轮上冲行情中，市场打开了一个窗口。之后，上涨行情继续发展，直至图示的看跌反击线形态出现。后来，该窗口维持了5个星期的支撑作用。但是在窗口关闭后，抛售压力依然如故，因此上升趋势宣告破产。 图7.5 原油——周蜡烛图（窗口作为支撑区） 到此为止，我们一直把窗口看作一种持续形态，研究的焦点是，怎样利用窗口作为支撑区域或阻挡区域。窗口还有其它用途（参见图7.6）。一个窗口，可能构成一个极有意义的向上突破信号，特别是当这个窗口是从较低的横向整理区间向上跳起，而且形成窗口的是一根小的黑色蜡烛线的时候。如日7.6所示的实例正体现了上述原则。 图7.6 国际标准纸——日蜡烛图，1990年（从低价位的横向整理区间向上跳空形成的窗口） 在这个例子中，市场在整个2月里的价格活动，都局限在一个相对狭小的横向整理区间内。2月24日和25日，市场形成了一个向上的小窗口，而且形成窗口的是一根非常小的黑色蜡烛线。次日的交易过程证实了这个窗口的支撑作用。就在这一天（2月26日），市场不仅坚守住了本窗口形成的支撑区，而且产生了一根同于最坚挺类型的蜡烛线——一根长长的白色蜡烛线，其开市价位于当日最低点（这就是说，是一根看涨捉腰带线），其收市价位于当日最高点（全秃大阳线）。 如图7.7所示，1月中旬出现了一个大窗口。从1月底到2月底．市场一再地向上回升到这个窗口附近（窗口之后发生的市场回撤，将重新返回窗口）。但是，在每一次向上反弹过程中，只要价格接近了由该窗口形成的阻挡水平，上涨行情就短路了。 图7.7 欧洲美元——1990年6月，日蜡烛图（窗口作为阻挡区） 请看如图7.8所示的道·琼斯指数的实例。在“87股市大崩溃”中，该市场在2150点到2200点之间形成了一个窗口。那么，这场下跌趋势何时才算到头了呢？需要满足两个条件；第一，市场必须把这个巨大的窗口向上关闭掉；第二，在窗口关闭后，市场上的买进压力依然如故。到1989年初，上述两个条件都实现了。 图7.8 道·琼斯工业股票平均指数——周蜡烛图（窗口作为阻挡区） 如图7.9所示，是另一个说明窗口形成阻挡区域的实例。窗口1发生在5月下旬，是个较小的窗口。这个窗口的出现，意味着当前下跌行情将继续发展。在之后的数周内，这个窗口也演变成了一个阻挡区域。讲到窗口2的时候，我们就有机会强调趋势的重要性了。下面这句话常常挂在房地产经纪人的嘴边：“对房地产最有影响力的三项因素是：地点、地点、地点。”如果我们把这句话借用到我们这个行业来，那就是，市场最重要的三个方面是：趋势、趋势、趋势。从图7.9中我们看到，该市场的主要趋势方向是向下的。 图7.9 原糖——1990年10月，日蜡烛图（窗口作为阻挡区） 在这样的大环境下，市场形成了一个看涨的启明星形态。那么，我们应当买进吗？不，因为主要趋势方向是向下的！如果先平回一部分既有的空头头寸，或许更为稳妥。到底什么时候才可以一点点买入、逐步建立多头头寸呢？具体到本例来回答，就是在市场向上推过0.1164美元的水平、并旦在该水平以上市场继续维持买进压力的情况下。这是因为，在7月中旬，市场形成了另一个窗口（窗口2）。该窗口的顶部位于0.1164美元。我们的立场是，除非牛方有能力向上推进到这个窗口之上，从而证明多头一边充满活力，否则，即使前面有一个启明星形态，开立多头头寸也是一种风险极高的策略。在该启明星形态形成之后的数日内，当市场向下试探其低点时，该形态确实起到了支撑作用。然而，牛方努力了一周，企图向上关闭窗口2，却始终未能如愿以偿。这就告诉我们，目前不可能发生新的上涨行情。通过上述讨论，我们得到了如下的教训：蜡烛图信号与任何技术工具一样，必须在当前主要趋势的大前提下进行研究。 在图7.10中我们看到，自从9月份的一根上吊线以及后面的一根黑色吞没蜡烛线（覆盖的就是这根上吊线）出现后，市场便一路下跌。9月末，市场形成了一个窗口，它表明下跌行情还将继续。后来，这个窗口被关闭了，但是买进的动力随即烟消云散。这一点从图示的流星形态上得到了证实。 图7.10 美元指数——周蜡烛图（窗口作为阻挡区） 在图7.11中，我们要讨论3个窗口。窗口1形成于1989年3月，是向下打开的。在随后的几个星朋中，该窗口演变为一个阻挡水平。窗口2也是向下打开的，从它身上可以感受到，市场上还有进一步的抛售压力。在该窗口一周之后，出现了一根长长的白色蜡烛线，并由此形成了一个看涨吞没形态。这是市场见底的第一个迹向。下一周，市场的收市价急剧上扬到这一窗口之上。这构成了另一个理由．让我们相信市场上的抛售压力已经耗尽。窗口3处于上升行情中，这就意味着市场将更上一层楼。在10月的第二个星期，市场关闭了该窗口，但此后不久，买方就将价格推高，并且在推升过程中，形成了一根锤子线。一般说来，只有处在下降趋势中，锤子线才具有重要意义（因为它属于底部反转信号）。但是在这一实例中，这条锤子线很有意义，因为它反映出市场对窗口处支撑水平的一次成功的试探。在这根锤子线后，如果市场继续走低，就说明上升趋势已经不复存在了。 图7.11 瑞士法郎——周蜡烛图（窗口作为支撑区和阻挡区） 如图7.12所示，3个窗口组成了一个窗口系列。在窗口1出现后，几天之内便形成了一段抛售行情，但该窗口构成了一个支撑区域。窗口2的出现，结束了一轮为期1个月的上冲行情。在窗口3打开之后的一个星期中，该窗口就像房顶的天花板，挡住了所有的上冲试探。9月份的上冲行情在窗口2的位置上碰了壁，除此之外，这段行情还有一个有趣的地方。这段上升行情总共形成了8个依次上升的新高，如图所示，我们用数字1到8分别标出了这8根蜡烛线。根据蜡烛图理论，在一段行情接连续形成了8个到10个新高或者新低之后，如果市场还没有经过任何有意义的调整过程，那么，即将发生重大调整的可能性就非常大。在这样的行情中，日本分析师把每一个新高或新低都称作一个“新记录高点”，或者“新记录低点”。因此，当日本分析师称已有10个新记录高点，或者已有10个新记录低点的时候，指的就是，市场一口气形成了10个逐步升高的新高点，或者10个逐步下降的新低点，组成了一个新高或新低的系列。举例来说，如果连续出现了8个新高而没有发生任何有意义的调整，那么，日本分析师便将这种市场状况描述为“胃口已经填满了八成”。在本图所示的黄金市场上，其有趣之处正是在这段上涨行情中总共出现了8个新记录高点。这一现象发出了一个警告信号，说明市场的顶部可能即将来临。与此同时，在这8个新记录高点之后，市场已经达到了由窗口2形成的阻挡区。这一事实构成了另一个强烈的信号，提醒我们，现在对市场的多头一边要慎之又慎了。 在图7.13中，令人心醉的数字3又以另外一种方式出台了。传统的日本技术分析理论断言：在一个趋势中，如果已经出现了3个向上的或向下的窗口（即所谓三空形态），那么，市场即将形成顶部（如果这三个窗口发生在上升趋势中）或底部（如果这三个窗口发生在下降趋势中）的机会是极大的；特别是在第三个窗口之后，如果出现了某种转折性的蜡烛图形态或蜡烛线（比如说十字线，刺透形态，或者乌云盖须形态等），那么市场见顶或见底的机会就更大了。在本例中，在第三个窗口之后，我们看到了几根上吊蜡烛线。 在下面几个部分，我们将讨论一些以窗口为一个组成部分的持续形态。在这些形态中，包括向上跳空和向下跳空并列黑白蜡烛线形态，高位跳空和低位跳空突破形态，以及跳空并列白色蜡烛线形态。 向上跳空并列黑白蜡烛线形态（或者称为向上跳空并列阴阳线形态，如图7.14所示）也是一种持续形态，它的形成过程大体是这样的。市场本处于上升趋势中。这时，出现了一根向上跳空的白色蜡烛线。在这根白色蜡烛线后，紧跟着另一根黑色的蜡烛线。这根黑色蜡烛线的开市价位于前一个白色实体之内，收市价位于前一个白色实体之下，在这样的情况下，这根黑色蜡烛线的收市价，就构成了一个买入点。如果在市场回头填补了这里的跳空（即关闭了该窗口）后．抛售压力依然很明显的话，那么这个向上跳空并列黑白蜡烛线形态的看涨意义就不再成立了。在向下跳空并列黑白蜡烛线形态（也称为向下跳空并列阴阳线形态，如图7.15所示）中．基本概念与上述形态是相同的，只不过方向相反。在向上跳空和向下跳空并列黑白蜡烛线形态中，两根蜡烛线实体的大小应当不相上下。这两种并列黑白线跳空形态都很少见。 请看图7.16，其中有一个向上跳空并列黑白蜡烛线形态的实例、在9月的最后一周，市场上出现了一个小的向上价格跳空，形成跳空的是一根白色蜡烛线。下一周是一根黑色蜡烛线，其开市价位于上述蜡烛线白色实体的内部，收市价则低于该白色实体的开市价。这样一来，就形成了一个向上跳空并列黑白蜡烛线形态。请注意，本形态的窗口虽然小，但在10月市场向下回撤的过程中依然起到了支撑作用。图示的看涨捉腰带线形态标志着当前上冲行情的发动。 高价位和低价位跳空突破形态在上升趋势中，当市场经历了一两个急剧上涨的交易日后，在正常情况下都需要一个调整消化的过程。有时，这个整理过程是通过一系列小实体来完成的。如果在一根坚挺的蜡烛线之后，出现了一群小实体的蜡烛线测，则表明市场已经变得犹豫不决了。然而，一旦后来某一天的开市价从这群小实体处向上跳空（也就是说，形成了一个窗口），那么买进的时机就成熟了。这就是一个高价位跳空突破形态（如图7.17所示）。之所以这样称呼这类形态，是因为在这类形态中，市场先是在最近形成的高价位上徘徊，后来才下定决心向上跳空。 图7.17 高价位跳空突破形态 可想而知，低价位跳空突破形态正是高价位跳空突破形态的反面角色，两者形态对等而意义相反。低价位跳空突破形态（如图7.18所示）是一个向下跳空的窗口，是从一个低价位的横向密集区处向下打开的。这个横向密集区（一系列较小的实体）发生在一两个急剧下跌的交易日之后，曾经使市场稳定下来。起初，从这群小实体蜡烛线的外观看来，似乎市场正在构筑一个底部。但是后来，市场以窗口的形式从这个密集区向下突破，打消了这种看涨的念头。 图7.18 低价位跳空突破形态 如图7.19所示，从10月底到11月初，市场上有3根小实体蜡烛线组成了一个系列，它们的前头是一根高高的白色蜡烛线，这些小实体蜡烛线有助于消化白色蜡烛线的巨幅价格上涨。本图所示为原糖市场。当市场终于从其中的三根小实体蜡烛线上向上跳空时，本例的第一个向上跳空突破形态就完成了。之后，市场继续上冲，直到11月17日和18日出现了一个乌云盖顶形态为止。在高价位跳空突破形态2中，首先出现的是一根高高的白色蜡烛线，然后是一些较小的实体，最后是一个向上打开的窗口。这个窗口后来转化为一个支撑水平。 图7.19 原糖——1990年5月，日蜡烛图（高价位跳空突破形态） 在图7.2O中，当6月29日的蜡烛线向上跳空打开窗口的时候，发出了一个看涨信号。本窗口走完了图示的向上跳空突破形态的最后一步。在这个跳空突破形态之前，即6月11日，曾经出现过另一根坚挺的白色蜡烛线。在这根线之后，也跟着一群小实体的蜡烛线。这种局面已经具备了演化为一个高价位跳空突破形态的潜力。然而，最后市场没有向上跳空，也就没有形成买入信号。 图7.20 大豆——1990年11月，日蜡烛图（高价位跳空突破形态） 如图7.21所示为标准普尔指数市场。7月20日和21日，该市场快速地下跌了18点。之后，市场在较低价位横向延伸了一星期以上（在跳空突破形态中，调整过程不应当超过11个时间单位）。当时，一位与我有来往的日本经纪人告诉我，她的一位日本客户（一位应用蜡烛图技术的基金经理）根据图示的低价位跳空突破形态，在8月2日获得了一个卖出信号（参见图中箭头所指的十字线）。 图7.21 S&amp;P指数——1990年9月，日蜡烛图（低价位跳空突破形态） 这个例子再次体现出蜡烛图技术的一个重要方面。前面我们也曾经讨论过有关问题。在我们研究蜡烛图形态时，所使用的技巧和程序都是一些分析要领，而不是固定不变的严格规则。上面的实例并不是一丝不苟地符合理想的低价位跳空突破形态的要求的，但是这位日本基金经理认为，该形态的条件已经足够成熟了，可以据之采取行动。从原则上说，如果要完成一个低价位跳空突破形态，则市场应当向下跳空。在本例中，8月1日的最低点为355.80点，而8月2日的最高点为355.90点。因此，它们之间并未发生价格跳空。话说回来，实际上这种情况与跳空相差无几，所以在8月2日，这位日本基金经理还是获得了他的卖出信号。另外，还请注意，在图示的那群小实体之前，代表价格急剧下跌的那根蜡烛线并未收市于当日的最低点。不过，在随后的几个交易日里，价格一直局限于这一天的价格区间的下半部分，它们的外形与低价位跳空突破形态十分相像，足以为这位日本蜡烛图技术的应用者提供8月2日的卖出信号了。通过本图例我们可以体会到，蜡烛图技术形态同其它所有的图表分析技术一样，为分析者的主观意志留了余地。 跳空并列白色蜡烛线形态在上升趋势中，先出现了一根向上跳空的白色蜡烛线，随后又是一根白色蜡烛线，并且后面这根线与前一根大小相当，两者的开市价也差不多处在同样的水平上，这样就形成了一种看涨的持续形态。这种二蜡烛线形态称为向上跳空并列白色蜡烛线形态（或者称为向上跳空并列阳线形态，如图7.22所示）。如果市场收市在并列白色蜡烛线的最高点之上，则意味着下一波上涨行情即将展开。 图7.22 向上跳空并列阳线形态 上面介绍的这种并列白色蜡烛线形态是很少见的。不过，更少见的还有向下跳空的两根并列白色蜡烛线。这类形态称为向下跳空并列白色蜡烛线形态（如图7.23所示）。 图7.23 向下跳空并列阳线形态 在下降趋势中，这类并列的白色蜡烛线也构成了一个持续形态。这就是说，当这类形态出现时，价格将继续走低。为什么这种形态不是看涨的（正如在向上跳空的形态中那样），而是看跌的呢？这是因为在下降的市场中，这两根白色蜡烛线是由空头平仓过程造成的。一旦空头平仓的过程完成了，价格就要进一步下跌。这类向下跳空并列白色蜡烛线形态之所以特别罕见，其原因不难理解。在下降趋势中，当出现向下跳空时，如果形成跳空的蜡烛线是一根黑色蜡烛线，当然比一根白色蜡烛线自然得多。如果在下跌的市场行情中，先出现了一根向下跳空的黑色蜡烛线，后面又跟了一根黑色蜡烛线，并且后者的收市价比前者低，那么市场将开始下一轮价格下跌过程。 如图7.24所示，3月上旬出现了一个向下跳空并列白色蜡烛线形态。在下降趋势中出现这种形态的理论解释是，空头正在进行获利平仓。由此可见，这个形态只是为市场的下降过程提供了一个短暂的休整机会。在本例中，我们见到的正是这样的情况：市场在经过了一段时间的调整以后，又恢复了下跌趋势。这个例子并不是一个理想的向下跳空并列阳线形态，因为其中两根白色蜡烛线的开市价并不处在同样的水平，而且在两根白色蜡烛线之间还间隔了一个交易日，虽然如此，它的图形与向下跳空并列白色线形态还是可以相提并论的。 图7.24 白金——1990年7月，日蜡烛图（跳空并列白色蜡烛线形态） 另外，在图7.24所示的实例中，还有两个向上跳空并列阳线形态。如果这类形态出现在较低的价位上，则具有看涨的意味。在图示的第一个向上跳空并列白色蜡烛线形态中，三根白色蜡烛线的开市价差不多都在同一个水平上。在该形态之后，市场经历了一个短暂的向下回撤过程，并且在其中的5月8日，一度稍稍向下突破了该形态中窗口处的水平，但市场立即从此处向上反弹。第二个向上跳空并列阳线形态也构成了一个看涨信号。本形态充分体现了向上跳空并列白色线形态的典型特点，为之后的市场变化提供了一个坚实的立足点。 上升三法和下降三法形态所谓三法形态，包括看涨的上升三（蜡烛线）法，以及看跌的下降三（蜡烛线）法（请注意，这里我们又与数字3不期而遇了）。这两类形态均属于持续形态。上升三法形态（如图7.25所示）的判别标准，包括以下几个方面： 图7.25 上升三法形态 1、首先出现的是一根长长的白色蜡烛线。 2、在这根白色蜡烛线之后，紧跟着一群依次下降的小实体蜡烛线。这群小实体蜡烛线的理想的数目是3根，但是如果比3根再多1、2根，也是可以接受的，条件是，这群小实体蜡烛线基本上都局限在前面那根长长的白色蜡烛线的价格范围之内。我们不妨作这样的理解：由于这群较小的蜡烛线均处于第一天的价格范围之内，它们与最前面的长蜡烛线一道，构成了一种类似于三日孕线形态的价格形态（在本形态中，所谓处于最前面的蜡烛线的价格范围之内，指的是这群小蜡烛线均处于该蜡烛线的上下影线的范围之内；而在真正的孕线形态中，仅仅是小蜡烛线的实体包含在前面那根蜡烛线的实体之内）。小蜡烛线既可以是白色的，也可以是黑色的，不过，黑色蜡烛线最常见。 3、最后一天应当是一根具有坚挺的白色实体的蜡烛线，并且它的收市价高于第一天的收市价。同时，最后这根蜡烛线的开市价也应当高于前一天的收市价。 本形态与西方技术分析理论中的看涨旗形或看涨三角旗形形态有相似之处。不过，上升三法形态的理论起源一直可以上溯到18世纪。一般认为，三法形态代表了买、卖之外的第三种交易策略——休息，也代表了牛、熊之争的一次休战。用更时髦的说法来形容，市场通过这一群小蜡烛线，获得了一次“喘息的机会”。 下降三法形态（如图7.26所示）与上升三法形态在图形上完全是对等的，只不过方向相反而已。这类形态的形成过程如下：市场应当处在下降趋势中，首先出场的是一根长长的黑色蜡烛线。在这根黑色蜡烛线之后，跟随着大约三根依次上升的小蜡烛线（通常，它们都是白色的），并且这群蜡烛线的实体统统局限在第一根蜡烛线的范围之内（包括其上、下影线）。最后一天，开市价应低于前一天的收市价，并且收市价应低于第一根黑色蜡烛线的收市价。当最后这根黑色蜡烛线形成后，市场便会向下滑落。本形态与看跌旗形或看跌三角旗形形态相似。 图7.26 下降三法形态 在图7.27中，显示了一例经典的上升三法形态。市场本处于上升趋势，这时出现了一根白色蜡烛线，它的后面跟随着三根小实体的黑色蜡烛线。基本上，这群黑色蜡烛线都处于该白色蜡烛线的价格范围之内。最后一根白色蜡烛线的收市价超过了第一根蜡烛线的收市价。在三法形态中，下面这项因素可能加强其预测意义：如果头、尾两根白色（黑色）蜡烛线的交易量超过了中间那群小蜡烛线的交易量，那么，该形态的分量就更重了。在本图所示的上升三法形态中我们看到，两根白色蜡烛线的交易量明显高于其中三根小的黑色蜡烛线的交易量。 图7.27 黄金——1990年4月，日蜡烛图（上升三法形态） 如图7.28所示，也是一个上升三法形态的实例。这是美国长期国债市场。当图示的上升三法形态完成后，该市场一路上推，一直到图示的看跌吞没形态出现才罢手。 图7.28 美国长期国债——周蜡烛图（上升三法形态） 在理想的上升三法形态中，在长长的白色蜡烛线之后跟着三根小的黑色蜡烛线。但是在如图7.29所示的实例中，只有两根小的黑色蜡烛线。1988年6月的市场变化形成了一根高高的白色蜡烛线。接下来，7月和8月是两根黑色蜡烛线，并且它们都处于6月的白色蜡烛线的价格范围以内。9月，形成了另一根白色蜡烛线，它为当前的上涨行情创出了新高，但是它的收市价未能超过6月的收市价，虽然两者的差距仅仅有3个基本价格变化单位。在通常情况下，我们本来能期望看到更高的收市价。就这个实例而言，一方面考虑到最后这根白色蜡烛线（9月份）的收市价只差3个基本价格单位便能超过6月的收市价，另一方面也考虑到下一个月的蜡烛线发出的看涨验证信号，因此，我们仍然把这个例子看作一个上升三法形态。10月的收市价创出了一个新高，提供了上述的验证信号，确保了采取看涨立场的可靠性。 图7.29 道·琼斯运输股票平均指数月蜡烛图（上升三法形态） 在图7.30所示的实例中，三根小蜡烛线明显地介于第一根蜡烛线的最高点与最低点的范围之内。在它们之后，出现了另一根白色蜡烛线。最后这根白色蜡烛线的收市价与第一根白色蜡烛线的收市价处在同一水平上，因此，我们还需要进一步的验证信号。当下一小时的开市价高于最后这根白色蜡烛线的时候，我们就得到了一个看涨的验证信号。请注意图示的上升三法形态的顶部是如何转化为支撑水平的，这一支撑区在8月1日的第一个小时经受了市场的试探。 图7.30 原油——1990年9月，日蜡烛图（上升三法形态） 在图7.31中，出现了这种看涨持续形态的两个实例。其中第一个上升三法形态发生在7月初。这一实例说明，在上升三法形态中，也可以只有两根小蜡烛线跟随在第一根高高的白色蜡烛线之后，而不一定是三根。请注意这两根黑色蜡烛线是如何局限在第一根蜡烛线的范围之内的。本形态的最后，是一根白色实体的蜡烛线，它的开市价高于前一天的收市价，收市价为这轮上涨行情创出了新高。 图7.31 埃克森公司——1990年，日蜡烛图（上升三法形态） 如图7.31所示的第二个实例显示，在上升三法形态中，第一根白色蜡烛线之后的小蜡烛线的实体并不一定非黑色不可。只要这群蜡烛线的实体维持在第一根白色蜡烛线的范围之内，就有潜力构成一个三法形态。在本实例中，随着最后一根白色蜡烛线收市于一个新高水平，上述潜力就完全发挥出来了。 如图7.32所示，1989年3月，市场形成了一个窗口。根据蜡烛图技术的格言：“窗口之后发生的市场回撤，将重新返回窗口”，我们预期市场将向上反弹到该窗口附近。从这里开始，市场将再度恢复下跌趋势。在这个窗口之后，出现了三个小实体。市场回头试探该窗口的过程发生在4月里的第一个星期。这次向上试探失败了。2周之后，也就是在其中第三根小实体的白色蜡烛线上，市场再次企图向上关闭这个窗口。这一次，还是未能成功。于是，最后一根黑色蜡烛线出现了，它的收市价低于图示的第一根黑色蜡烛线的收市价。这样就完成了这个由五根蜡烛线组成的下降三法形态。 图7.32 德国马克——1990年6月，日蜡烛图（下降三法形态） 在如图7.33所示的下降三法形态的实例中，包含着四根而不是三根小实体蜡烛线。对三法形态来说，关键在于这群小蜡烛线的实体统统维持在第一天的价格范围之内。最后是一根大的黑色蜡烛线，于是，该形态就完成了。请注意本图所示的即时交易量（TM）是怎样验证其中两条黑色蜡烛线的信号的。具体说来，两根黑色蜡烛线的即时交易量（TM）呈扩张状态，而中间的白色蜡烛线的即时交易量（TM）呈萎缩状态。在第十五章，我们还要详细介绍蜡烛线与交易量的关系，其中也包括即时交易量（TM）的有关内容。 图7.33 铜——1990年7月，日蜡烛图（一个功亏一篑的下降三法形态） 图7.34所示是一张日内图表。本例揭示了一项重要原则——不要在价格形态的演变过程中过早采取行动，只有在形态完成后才能有的放矢。本图所示，正是一个流产了的下降三法形态的实例。在4月23日的头一个小时内，市场形成了一根很长的黑色蜡烛线。随后，出现了三根上升的小实体。在这群小蜡烛线的后面，又是一根长的黑色蜡烛线。但是，在这里，第五个小时的蜡烛线的“收市价”并没有达到第一小时的‘收市价”以下的水平。因此，这个下降三法形态还没有最后确定。如果下一根蜡烛线提供了看跌验证信号，那么，我们仍然可以将上述图案归结为一个下降三法形态，因为其中第一根黑色蜡烛线与第五根黑色蜡烛线的收市价是相当接近的。然而，在接下来的一两个小时内，没有发生任何看跌的验证信号。 图7.34 在本例的最后一根黑色蜡烛线之后，出现了一根十字线。这根十字线与它前面的黑色实体结合起来，构成了一个十字孕线形态。这是一个反转形态，暗示当前的下降趋势不会再持续下去了。另外，在随后的数小时内，各条蜡烛线的低点都成功地向下试探了4月23日以来的日内最低价格水平。种种迹象显示，如果我们预料这个下降三法形态将成功，可能是猜错了。一定要等到价格形态确实已经完成时，或者得到了其它信号的验证后，才能按照其预测意义采取行动。 图7.35所示为下降三法形态的一个经典的实例。不过，其后的一根锤子线抵消了它的看跌意义。如果说仅仅凭这一根锤子线还不足以使我们确信下降趋势已经告终的话，那么，锤子线后面跟着一根白色蜡烛线。为我们提供了更多的证据。这根白色蜡烛线与锤子线一起，组成了一个看涨吞没形态。 图7.35 道·琼斯公用事业股票平均指数——1990年，日蜡烛图（下降三法形态） 前进白色三兵形态很多蜡烛图技术术语都与战争结下了不解之缘，本形态就是一个典型的例证。人们把这种形态称为前进白色三兵形态（如图7.36所示），或者更简洁一点，叫作白色三兵形态。本形态由接连出现的三根白色蜡烛线组成，它们的收市价依次上升。当市场在某个低价位稳定了一段时间后，如果出现了这样的形态，就标志着市场即将转强。 图7.36 白色三兵形态表现为一个逐渐而稳定的上升过程，其中每根白色蜡烛线的开市价都处于前一天的白色实体之内，或者处在其附近的位置上；每一根白色蜡烛线的收市价都应当位于当日的最高点或接近当日的最高点。这是一种很稳健的市场攀升方式（不过，如果这些白色蜡烛线伸展得过长，那么我们也应当对市场的超买状态有所戒备）。 如果其中第二根和第三根蜡烛线，或者仅仅是第三根蜡烛线，表现出上涨势头减弱的迹向，就构成了一个前方受阻（白色三兵）形态（如图7.37所示）。这就意味着这轮上涨行情碰到了麻烦，持有多头头寸者应当采取一些保护性措施。特别是在上升趋势已经处于晚期阶段时，如果出现了前方受阻形态，则更得多加小心。在前方受阻形态中，作为上涨势头减弱的具体表现，既可能是其中的白色实体一个比一个小，也可能是后两根白色蜡烛线具有相对较长的上影线。 如果在后两根蜡烛线中，前一根为长长的白色实体，并且向上刨出了新高，后一根只是一个小的白色蜡烛线，那么就构成了一个（白色三兵）停顿形态（如图7.38所示）。有时候，这种形态也称为（白色三兵）深思形态。当这一形态出现时，说明牛方的力量至少暂时已经消耗尽了。在本形态中，最后一根小的白色蜡烛线既可能从前一根长长的白色蜡烛线向上跳空（在这种情况，该蜡烛线就变成了一根星线），也可能如同日本分析师所描述的那样，“骑在那根长长的白色蜡烛线实体的肩上”（这就是说，位于前一根长的白色实体的上端）。这根小小的实体暴露了个方能量的衰退。当停顿形态发生时，便构成了多头头寸平仓获利的紧要时机。 虽然前方受阻形态与停顿形态在一般情况下都不属于顶部反转形态，但是有时候，它们也能引出不容忽视的下跌行情。我们应当利用前方受阻形态和停顿形态来平仓了结已有的多头头寸，或者为多头头寸采取保护措施（比如说，卖出与多头头寸相当的买权期权合约），但是不可据之开立空头头寸。一般来说，如果这两类形态出现在较高的价格水平上，则更有预测意义。 如图7.39所示，1985年，市场在较低价格水平上形成了一个白色三兵形态，它引发了一轮上涨行情。在这个形态之后，还出现了两个前方受阻形态。前方受阻形态1出现在1987年初，其中的白色实体一蟹不如一蟹，给当前的上涨行情罩上了一层阴影。在这个三蜡烛线群体中，最后那根小白色实体是一根流星线。在随后的几个月里，市场裹足不前，形成了几根十字线、在这些十字线之后，价格又开始向上推进，但是下一个前方受阻形态再度发出了警告信号。前方受阻形态2形成于1987年年中。这个三蜡烛线形态与前方受阻形态1的主要区别是，在本形态中，最后那根白色蜡烛线具有较长的上影线。这根上影线并不算非常长，但是它足以说明，市场没有力量在当前的最高点附近收市。换句话说，这群先头部队（即挺进的三兵）遭到了“阻击”。下一个月十出现了一根上吊线。于是，进攻的一方开始撤退。 在本例的前方受阻形态2出现后，我们还有其它的理由怀疑市场能否进一步上涨。1985年的白色三兵形态是从低价位出发的，但是，这个前方受阻形态的三根白色蜡烛线则出现在市场已经经历了长期的上涨过程之后。 如图7.40所示，1989年初，停顿形态1暂时中断了价格爬升的进程。另一方面，本形态也是在一个长期的白色蜡烛线系列之后出现的。 停顿形态2仅仅将当时的上涨行情阻滞了一两周。在这个深思形态中，最后那根小的白色实体是一根上吊线。两周之后，一旦市场的收市价向上超越了上吊线的最高点，市场便不太可能再下跌了。7月初，图示坚挺的白色三兵形态开始了一段气势不凡的上冲行情。在这段行情中，连续出现了7个新高（即，7个新纪录高点）。1989年第三季度，又出现了另一个白色三兵形态、这个形态与7月份的白色三兵形态类似。在其中三根白色蜡烛线上，它们的收市价均处于各自的最高点，因此，从该形态各个方面的特征来看，都预示着新的一轮强劲的上涨行情的到来。但是，实际情况并非如此。在其中第三根白色蜡烛线之后一星期，市场上出现了一个小实体，它与前一根蜡烛线组成了一个孕线形态。由此可见，当前的上升趋势已经遇上了麻烦。几周以后，又出现了一颗流星，这就证实市场在当前的高价位上的确有问题。 如图7.41所示，这里先后出现了三个停顿形态。在停顿形态 1中，同时还形成了一个孕线形态，它使当前的上冲行情短路了。停顿形态2没有使当时的上升趋势受到什么阻碍。在停顿形态3中，包含了一根流星线。停顿形态3的出现，导致了市场趋势的短暂变化，市场从上升转化为为期几个星期的横向延伸。请记住，在通常情况下，停顿形态并不是一个趋势反转信号，这类形态的出现，常常意味着市场需要一段深思熟虑的时间，以便决定下一步的方向。拿停顿形态3的情况来说，在横向调整区间完成之后，市场向上打开了一个窗口，形成了一个高价跳空突破形态。这个结果显示，市场的坚挺力道已经恢复。 分手蜡烛线形态在第六章，我们曾经研究了反击蜡烛线形态。回忆一下，反击线形态是一种二蜡烛线形态，前后两根蜡烛线颜色相反，并且后一根蜡烛线的收市价与前一根的收市价处于同一水平。这一形态属于反转信号。如图7.42所示的分手线形态也是由两根颜色相反的蜡烛线组成的，但是同反击线形态不同的是，分手线形态的两根蜡烛线具有相同的开市价。分手蜡烛线形态属于持续信号。 在市场上涨的过程中，如果出现了一个黑色实体（尤其是出现相对较长的黑色实体时），对于持有多头的市场参与者来说，可能成为一块心病。他们满腹狐疑，“熊方或许正在争得主动权？”无论如何，如果下一天开市时市场向上跳空，开市价回到了前一根黑色蜡烛线的开市价的水平，就说明熊方已经失去了对市场的控制。如果后面这根白色蜡烛线进一步向上收市在较高的水平，则说明牛方已经重新执掌了大权，先前的上涨行情将继续发展。上述情形就是如图7.42所示的看涨分手线形态的演变过程。在这类形态中，白色蜡烛线同时还应当是一根看涨捉腰带线（即，其开市价位于当日的最低点）。在图7.42中，看跌的分手线形态与上述形态完全对应，但方向相反。一般认为，这类形态属于看跌的持续形态。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 星线]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%98%9F%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是星线？和颜色有关吗？出现在顶部还是底部？ 什么是十字星线？为什么十字星线是一个警告信号？ 过去的支撑水平常常转化为新的阻挡水平。怎么理解？ 启明星，黄昏星，十字星形态都是三蜡烛线形态。十字线之后的蜡烛线，应当构成趋势反转的验证信号。怎么理解？ 前言“天下没有填得饱的胃口”。 本章要讨论另一群有趣的反转形态，它们的共同点是都包含星蜡烛线。如图5.1所示，星蜡烛线（简称星线）的实体较小，并且在它的实体与它前面的较大的蜡烛线的实体之间形成了价格跳空。只要星线的实体与前一个实体没有任何重叠，那么这个星蜡烛线就是成立的。星线本身的颜色并不重要。星线既可能出现在市场的顶部，也可能出现在市场的底部（有时候，人们又把下降趋势中的星线称为雨滴）。如果星线的实体已经缩小为十字线则称之为十字星线（如图5.2所示）。 当星线，尤其是十字星线出现时，就是一个警告信号，表明当前的趋势或许好景不长了。星线的较小的实体显示，熊方和牛方的较量已经转入僵持状态。在强劲的上升趋势中，牛方一直占握主导地位。如果在一根长长的白色蜡烛线之后出现了一根星线，则构成了警告信号：因为市场原来受买方的控制，现在转变为买方与卖方势均力敌的僵持状态。这一僵局的发生，既可能是由于买方力量的衰减所造成的，也可能是由于卖方力量的增长所造成的。但不论出于哪一个原因，星线都能告诉我们，当前上升趋势的驱动力已经瓦解，市场容易遭到卖方的攻击而向下回落。 如果在下降趋势中出现了星线，也是同样的道理，只是方向与上述相反。具体地说，在下降趋势中，如果在一根长长的黑色蜡烛线之后出现了星线，就反映出市场氛围的改变。举例而言，在下降趋势中，熊方一直占据主动，但是随着星线的出现，事情就发生了变化，此时，牛、熊双方的力量对比已经变得较为平衡了。如此一来，市场向下的能量也就减退了。这种局面当然不利于熊市的继续发展。 在下列4种反转形态中，星线都是其中的一项重要组成成分。这四种反转形态分别是： 1、黄昏星形态； 2、启明星形态； 3、十字星形态； 4、流星形态。 在这4种星形态中，星线实体的颜色都是无关紧要的，既可以是白色的，也可以是黑色的。 星线启明星黄昏星3 启明星形态启明星形态属于底部反转形态（如图5.3所示）。它的名称的由来是，这个形态预示着价格的上涨就像启明星（水星）预示着太阳的升起一样。在本形态中，先是一根长长的黑色实体，随后是一根小小的实体，并且在这两个实体之间形成了一个向下跳空（这两条蜡烛线组成了基本的星线形态）。第三天是一根白色实体，它明显地向上推进到了第一天的黑色实体之内。本形态发出的信号是，牛方已经重新夺回了主导权。为了交代清楚本形态的理论背景，我打算把这个形态分解开来，对其中的三根蜡烛线逐一加以研究。 图5.3 启明星形态 当第一条黑色实体蜡烛线出现时，市场正处于下降趋势中。到此时为止，熊方还占着上风。随后的一天，是一个较小的实体，这就意味着卖方已经失去了将市场进一步压低的能量。第三天，市场形成了一根坚挺的白色实体，这就证明牛方已经夺取了统治权。在理想的启明星形态中，中间蜡烛线（即星线）的实体，与它前、后两个实体之间均有价格跳空。后面的那个价格跳空较为少见，不过，即使没有后面这个价格跳空，似乎也不会削减启明星形态的技术效力。 如图5.4所示，从12月19日到21日，市场上形成了一个看涨的启明星形态。从这个形态开始，市场酿成了一轮上涨行情。这轮上涨行情在遇到12月26日和27日的乌云盖顶形态以后，就失去了上升的动力。 图5.4 棉花——1990年3月，日蜡烛图（启明星形态） 在图5.5中10月里的低点是市场以星线的形式创造出来的（即，10月头一个星期的小实体）。在这条星线的下一周，市场形成了一根强劲的白色实体。这条白色实体完成了图示的启明星形态。跟着这条白色蜡烛线的，是一条黑色的蜡烛线，两者一起组成了一个乌云盖顶形态。随后，市场暂时向下回落。尽管如此，该启明星形态还是构成了一个主要的底部。 图5.5 原油——周蜡烛图（启明星形态） 如图5.6所示，是一个启明星形态的变体，其中包含了好几条小星线（在本例中，是三颗“星星”）。请注意，其中第三根小实体（即第三根星线）既是一根锤子线，同时也是一根看涨的抱线。 图5.6 白银——1990年9月，日蜡烛图（启明星形态） 黄昏星形态黄昏星是启明星的顶部对等形态，是看跌的。它的名称的由来也是显而易见的。因为黄昏星（金星）恰好出现在夜幕即将降临之际。既然黄昏星是顶部反转形态，那么，它只有出现在上升趋势之后，才能发挥其技术效力。黄昏星形态是由三根蜡烛线组成的（如图5.7所示）。在前两根蜡烛线中，第一根是一根长长的白色实体，后一根是一根星线。星线的出现，是顶部形态的第一个征兆。第三根蜡烛线证实了顶部过程的发生，完成了这个三线形态的黄昏星形态。第三根蜡烛线具有黑色实体，它剧烈地向下扎入第一天的白色实体的内部。我喜欢把黄昏星比喻为交通指挥信号灯。交通信号灯从绿色（对应于坚挺的白色实体）变成黄色（对应于星线的警告信号），再从黄色变成红色（对应于黑色实体，证实先前的上升趋势已告结束）。 从原则上说，在黄昏星形态中，首先在第一根实体与第二根实体之间，应当形成价格跳空；然后在第二根实体与第三根实体之间，再形成另一个价格跳空。话说回来，根据我的经验，第二个价格跳空并不常见，而且对于本形态的成功来说，可有可无，不是必要条件。本形态的关键之处在于第三天的黑色实体向下穿入第一天的白色实体的深浅程度。 图5.7乍一看去，像是西方技术分析理论中的岛形反转形态。但仔细分析一下就会发现，这个黄昏星形态所提供的反转信号，岛形反转形态是提供不来的（参见图5.8）。在岛形反转顶部形态中，交易时段2的最低点必须同时居于交易时段1和交易时段3的最高点之上。然而，在黄昏星形态中，仅仅要求实体2的低点高于实体1的高点，就可以构成反转信号了。 如图5.9所示的黄昏星形态，出现在1987年夏的道·琼斯指数市场上，该形态标志着道·琼斯指数在当年那场暴跌之前的最高点（我很想知道，采用蜡烛图的日本技术分析师当时是否看出了这个图形！）。 图5.9 道·琼斯工业股票平均指数——周蜡烛图，1987年（黄昏星形态） 图5.10是一个很好的实例，说明了蜡烛图技术如何发出这样一个顶部反转信号，如果借助于西方技术分析工具，是不容易得到这个顶部反转信号的。9月5日的最后一小时，与次日的头两个小时一起，构成一个黄昏星形态。按照前面曾提到的西方理论，这个黄昏星形态的星线部分并不符合岛形反转顶的条件。在本例的情况下，蜡烛图就提供了一个西方岛形反转顶概念不能识别的顶部反转信号。另外，请注意这个黄昏星形态所结束的上涨行情，是从9月4日的启明星形态开始的。 图5.10 德国马克——1990年12月，日内蜡烛图（黄昏星形态） 虽然黄昏星形态在上升趋势后更为重要，但是如果它处在横向巩固区间的顶部，那么，在其它看跌信号得到确认的条件下，也可能具有重要意义（如图5.11所示）。在本例中，4月中旬所发生的正是这种情况。在这个黄昏星形态中，星线的部分（即第二天）正与一个阻挡区不约而同地重合。阻挡区底部所处的水平为413美元，这里原本是3月里的支撑水平。过去的支撑水平常常转化为新的阻挡水平。这一点，请牢记于心！这是一条很有实用价值的交易规则。第十一章将要更深入地探讨支撑和阻挡水平的问题。无论如何，413美元附近的阻挡水平恰巧与这个黄昏星形态不期而遇，由此增强了本形态的疲弱意义。 图5.11 黄金——1989年12月，日蜡烛图（黄昏星形态） 在图5.12中，12月中旬出现了一个构造良好的黄昏星形态。在星线的前面，是一根坚挺的白色实体，在星线的后面，是一根疲软的黑色实体。11月中旬，出现了一个黄昏星形态的变体。之所以称之为变体，是因为在黄昏星形态中，星线之前通常包含一根长长的白色实体，星线之后是长长的黑色实体。可是在这里，我们既没有看到长长的白色实体，也没有看到长长的黑色实体。但是，我们毕竟还是将它判断为顶部形态，这不仅因为它的外观与黄昏星形态稍有相似之处，而且因为11月21日是一根上吊线（这根线就是这个黄昏星形态的“星”）。上吊线的次日，市场开市于上吊线的实体之下，确认了顶部形态的完成。 图5.12 小麦——1990年3月，日蜡烛图（黄昏星形态） 下面开列了一些参考性因素，如果黄昏星形态或启明星形态兼具这样的特征。则有助于增加它们构成反转信号的机会。这些因素包括： 1、如果在第一根蜡烛线的实体与星蜡烛线的实体之间存在价格跳空，并且在星线的实体与第三根蜡烛线的实体之间也存在价格跳空； 2、如果第三根蜡烛线的收市价深深地向下扎入第一根蜡烛线的实体之内； 3、如果第一根蜡烛线的交易量较轻，而第三根蜡烛线的交易量较重。这一点表明了原先趋势力量的衰减，以及新趋势力量的增长。 十字启明星形态和十字黄昏星形态K线中闪亮的十字星，一旦出现，240k足金反转！ 十字启明星 K线形态：十字黄昏星和十字启明星 十字启明星 如果在上升趋势中出现了一根十字线，并且这根十字线与前一个实体之间形成了向上的价格跳空；或者在下降趋势中出现了一根十字线，并且这根十字线与前一个实体之间形成了向下的价格跳空，那么，这根十字线就称为十字星蜡烛线（简称十字星线）。图5.2所示就是一根十字星线，十字星线的出现，构成了潜在的警告信号，表明市场的当前趋势已经易于发生变化了。在这根十字线之后的蜡烛线，应当构成趋势反转的验证信号。具体说来，在上升趋势中，如果在十字星线后跟随着一根长长的黑色实体，并且它的收市价深深地向下扎入十字星线之前的白色实体的内部，那么，这根黑色实体就构成了市场顶部反转过程的验证信号。这样的形态就称为十字黄昏星形态（如图5.13所示）。十字黄昏星形态是常规黄昏星形态的一种特殊形式。在常规的黄昏星形态中，星线，即第二根蜡烛线，具有较小的实体，但是在十字黄昏星形态中，星线是一根十字线。因为十字黄昏星形态包含了一根十字线，所以具有更重要的技术意义。 在上升趋势中，十字星线的出现常常构成一个警告信号，说明市场顶部已经迫近了。但有一点非常重要，值得引起注意：如果在十字星线之后，是一根向上跳空的白色蜡烛线，那么这根十字星线的疲弱性质就不再成立了。 在下降趋势中，如果在一根黑色实体之后，跟随着一条十字星线，第三根蜡烛线是一根坚挺的白色蜡烛线，并且它的收市价显著地向上穿入第一根黑色实体之内，那么，该底部反转信号就得到了第三根蜡烛线的验证。这个三蜡烛线形态称为十字启明星形态（如图5.14所示）。这一类启明星形态能够构成有意义的市场底部过程。在下降趋势中，如果在十字星线之后出现的是一根黑色蜡烛线，并且这根黑色蜡烛线向下跳空到了十字星线之下，那么这根十字星线潜在的看涨意义就冰消瓦解了。这一点就是为什么在十字星线出现后，我们必须等待下面一、二个时间单位的验证信号的原因。 如果市场上出现了一根向上跳空的十字星线（就是说，该十字星线的下影线与前一根蜡烛线的上影线没有任何重叠之处），它的后面再跟着一条向下跳空的黑色蜡烛线，并且在这根黑色蜡烛线的上影线与十字星线的下影线之间也形成了价格跳空，那么，这根十字星线就构成了一个主要顶部反转信号。这种形态称为弃婴顶部形态（如图5.15所示）。这种形态非常罕见！ 在与上述形态对应的底部反转形态中，道理是一样的，只不过方向相反而已。具体说来，在下降趋势中，如果在一根十字星线的前后均发生了价格跳空（包括有关蜡烛线的上下影线也互不接触），那么这条十字星线就构成了一个主要底部形态。人们将这种形态称为弃婴底部形态（如图5.16所示）。这种形态也极为少见！弃婴形态与西方的岛形顶部形态或岛形底部形态类似，不过其中的孤岛还应当是一根十字线。 在图5.17中，6月初有一条十字星线，它止住了先前的价格下跌。虽然这根十字星线的影线与前一天的黑色实体有所重叠，但它依然满足星线的条件。在这条星线之后，出现了一条白色实体，这就确认了下跌行情的结束。由这条十字星线，以及它前面的黑色实体和它后面的白色实体，共同构成了一个三线形态的十字启明星形态。 图5.17 小麦——1989年12月，日蜡烛图（十字启明星形态） 在图5.18所示的十字星蜡烛线上，价格曾经一度向下突破了0.85美元的水平。这是7月初形成的支撑区。但是，市场无力维持这里的新低价位，这一事实本身就具有看涨的意义。再加上图示的十字启明星形态，我们就有了两方面的理由来推测这一市场底部。 图5.18 咖啡——1990年9月，日蜡烛图（十字启明星形态） 在图5.19所示的实例中，既有一个十字黄昏星形态，也有一个普通的黄昏星形态。从1986年3月到当年5月，市场的价格变化构成了一个十字黄昏星形态。本形态阻止了仅从一、二个月前开始的一场剧烈的上涨行情。随着这个十字黄昏星形态的出现，发生了一段抛售行情。后来，一个看涨吞没形态结束了这段下跌行情。1987年中，出现了一个黄昏星形态，成为从上述吞没形态开始的上升趋势的顶部。 图5.19 Liffe长期金边债券——月蜡烛图（十字黄昏星形态） 在图5.20中我们看到，3月17日、18日、19日的三根蜡烛线构成了一个十字黄昏星形态。本形态结束了从前一周的锤子线开始的上涨行情。本实例再次说明，在股票市场上，某些蜡烛图形态在外形上可能具有更大的灵活性。这是因为股票市场与期货市场不同，与期货市场比起来，股票市场的开市价大多可能与前一日的收币价基本一致。如此一来，在我们分析特定的某些蜡烛图形态时，本来是将当日的开市价同前一日的收市价联系在一起的，但是从这一事实出发，这样的条件就必须进行相应的调整。 图5.20 道·琼斯化工股票平均指数——日蜡烛图，1990年（十字黄昏星形态） 本图实例取自道·琼斯化工成份指数。请注意，在本例中，这根十字黄昏星线并不是一条真正的星线。根据定义，十字星线的实体（就是其开市价或者收市价，两者是相等的）应当高于前一天的实体。这里的情况并非如此。因此，在股票市场进行蜡烛线信号的研究时，允许有更大的灵活性。对于那些跟踪股票市场的朋友来说，随着蜡烛图技术分析经验的增长，终究会发现到底哪些形态必须有所调整。 如图5.21所示，我们看到，在距离1987年大股灾的几个星期以前，市场形成了一个十字黄昏星顶部形态。在这个形态中，中间的蜡烛线（即十字星线）与前一个白色蜡烛线的实体之间并没有形成向上的价格跳空，而真正的星线是应当具有这样的跳空的。无论如何，正如我们在研究图5.20时所讨论的，考虑到股票市场的开市价常常位于前一天收市价的水平或者非常接近这个水平，因此，在价格跳空的问题上，应当允许有更大的自由度。 图5.21 NYSE指数——周蜡烛图（十字黄昏星形态） 在图5.22中，显露了一个极不寻常的、兆头险恶的现象，这里竟肩并肩地接连出现了两个十字黄昏星形态。从蜡烛线1到蜡烛线3形成了第一个十字黄昏星形态。在随后的三个时间单位里，从蜡烛线4到蜡烛线6形成了另一个十字黄昏星形态。 图5.22 白银——1990年12月，日蜡烛图（十字黄昏星形态） 流星形态流星线流星线流星线流星线 流星形态是一种二蜡烛线形态，它发出警告信号，表明市场顶部就在眼前。它的外观恰如其名称，像一颗流星。本形态的技术意义不如黄昏星形态强，通常不构成主要反转信号。如图5.23所示，在流星形态中，流星线具有较小的实体，而且实体处于其价格区间的下端，同时，流垦线的上影线较长。与所有的星蜡烛线一样，流星线实体的颜色并不重要。流星线的形状形象地显示，当日市场开市于它的最低点附近，后来强烈地上冲，但最后却向下回落，收市于开市价附近。换句话说，这个交易时间单位内的上冲行情不能够维持下去。 图5.23 流星形态 在理想的流星形态中，流星线的实体与前一根蜡烛线的实体之间存在价格跳空。不过，我们将从几个实例中看到，这样的价格跳空并不是非有不可的。 在下降趋势后，如果出现了与流星线外观一致的蜡烛线，则可能构成一个看涨信号。这样的蜡烛线称为倒锤子线。本章后面有关部分将要讨论倒锤子线形态。 从图5.24我们可以看到，4月2日形成了一个看跌的流星形态，标志着当前的上升趋势前途不妙。 图5.24 日元——24小时现货市场，日蜡烛图，1990年（流星线形态） 图5.25是个精彩的实例，其中充分展示了流星形态和它的各种变体的作用。 图5.25 大豆——1990年3月，日蜡烛图（流星形态） 流星形态的变体包括下列各种情形： 1、流星形态1实际上属于流星形态的变体。其中的流星线不是一个理想的星线，因为在有关的实体之间没有价格跳空。但是从结果看，这个形态证明牛方无力维持价格上涨的势头。 2、流星形态2没有多大意义。这个形态确实符合流星线的一部分要求（即，它具有较小的实体和较长的上影线）。然而，还有一条重要的判别准则它未能满足，因为本形态既没有出现在上升趋势之后，也不是处在横向巩固区间的顶部。如此一来，我们只能将它看成具有较小实体的、意义寻常的一根普通蜡烛线。较小的实体（即一个纺锤线）反映市场进退无据、犹豫不决。而在横向交易区间的中部，市场犹豫不定自然是意料之中的事。 3、流星形态3具有流星形态的外形，却并不构成真正的星形态，因为它的实体没有从前一个实体上向上跳空。但是，我们应当把这一天的流星线放到它所处的市场大环境中考察。在流星线3的上影线的顶部，市场曾对8月上旬的高点6.18美元的水平，发起过挑战。不过，在这场交易日内的上涨行情中，牛方在尝试上述阻挡水平时精疲力竭。最后，图示的大豆市场竟以接近当日最低价的水平收市。 4、流星形态4与流星形态3极其相似。因为它的实体也没有从前一个实体上向上跳空，所以它也不是一个理想的流星形态。话说回来，在这根流星线上，市场再一次向上挑战了6.18美元的阻挡水平，但还是功亏一篑。由此证明，牛方无力夺回主动权。 （虽然流星形态3和4均算不上理想的流星形态，但是这两个例子却说明了一个重要的问题。在本书开头我就已经指出过，价格形态并不一定要十全十美才能够发出有效的交易信号。在研究蜡烛图线和蜡烛图形态的时候，我们总是应当结合其它各方面的技术线索进行综合的判断，具体情况，具体分析。因此，尽管流星形态3和4都不够理想，但是从它们所具备的流星形态的轮廓，以及它们自身的价格变化过程，结合它们所处的行情背景来看，它们就具有看跌的意义了。） 5、流星形态5又是市场向上试探阻挡水平失败的一个例子。不过，行情发展到这种地步，我们不得不对牛方企图向上推动市场的坚韧意志怀有几分敬意。随着牛方在6.18美元的阻挡水平的一次又一次碰壁，我们不禁要猜测，他们到底还要坚持多久才肯最终放弃呢？在流星形态6，我们终于得出了答案。 6、流星形态6是市场最后一次失败的向上尝试。随后，牛方终于放弃顽抗，市场开始下跌。后来，由一根锤子线结束了这段抛售行情。 图5.26所示的流星形态的实例与上述情况类似。在这个流星形态中，流星线的实体也没有从前一个实体上向上跳空。尽管如此，本形态仍然构成了重要的反转信号。这里，我们还是从有关的历史背景出发，来分析这个流星形态。在本形态处，市场对1989年第3季度的历史高点水平再一次作了向上试探，但还是无功而返。于是，这个流星形态标志着从图示的锤子线开始的上涨行情的终结。 图5.26 美国长期国债——周蜡烛线图（流星线形态） 如图5.27所示为一个经典的流星形态，它出现在5月29日的第一个小时。从此市场开始下跌，直到6月4日出现了一个看涨吞没形态，这轮行情才告完成。 图5.27 玉米——1990年12月，日内蜡烛图（流星线形态） 在图5.28中，显示了2个流星形态，在它们的身后，均出现了明显的价格下跌过程。 图5.28 巴雷特资源公司——日蜡烛图，1990年（流星形态） 在图5.29中，该流星形态同时也标志着市场向上试探1989年10月至11月期间的高点的历史水平的失败。雪上加霜的险恶征兆！ 图5.29 S&amp;P指数——周蜡烛图（流星形态） 在图5.30中，有一对流星形态。每一个流星形态都结束了先前的上涨行情。 图5.30 日经指数——周蜡烛图（流星形态） 倒锤子线倒锤子线 虽然倒锤子线不属于星线形态，但是因为它的外形与流星线相象，所以我们把它放在本章最后这个部分来讨论。如图5.31所示，倒锤子线看上去与流星线颇为相象，它也具有较长的上影线，较小的实体，并且实体居于整个价格范围的下端。但是不同的是，流星线是一根顶部反转蜡烛线，而倒锤子线却是一根底部反转蜡烛线。如果倒锤子线出现在下降趋势之后，则构成一个看涨的蜡烛图形态，这一点与普通的锤子线如出一辙。 图5.31 倒锤子线形态 让我们回头再者看前面讨论过的图例5.27。请注意6月4日的看涨吞没形态的第一根蜡烛线。它的外观与流星线并无二致（这样的蜡烛线实体的颜色是无所谓的）。在这个实例中，这根蜡烛线处于下降趋势内，因此，成为一个潜在的看涨倒锤子线。 在分析倒锤子线时，有一点非常重要：当倒锤子线出现后，必须等待下一个时间单位的看涨信号对它加以验证。倒锤子线的验证信号可能采取下面这样的形式倒锤子线次日的开市价向上跳空，超过了倒锤子线的实体。向上跳空的距离越大，验证信号就越强烈。还可能采取另外一种形式：倒锤子线次日是一根白色蜡烛线，并且它的价格均处在较高的水平。 对于倒锤子线形态，之所以说看涨验证信号非常重要，是因为形成倒锤子线的价格变化过程看起来似乎是看跌的。这就是说，在倒锤子蜡烛线当日，市场的开市价位于当日最低价处，或者接近最低价。后来，市场上涨了，但是牛方无力将上涨行情维持下去。最后，市场收市于当日最低价，或者在最低价的附近。为什么这样的蜡烛线竟然是潜在的看涨反转信号呢？其解答必须从下一天的行情中寻找。如果下一日市场开市于倒锤子线的实体之上，则意味着凡是在倒锤子线当日开市和收市时卖出做空的人现在统统处于亏损状态。市场维持在倒锤子线实体之上的时间愈久，则上述空头止损出市的可能性越大。在这种情况下，首先可能引发空头平仓上涨行情，然后，空头平仓上涨行情可能促使企图抄底做多的人跟风买入。这个过程自我循环，市场螺旋上升，结果就可能形成一段上升趋势。 在前面讨论的玉米市场的实例中，在倒锤子线后面是一条坚挺的吞没线。这根蜡烛线就充当了这条倒锤子线的验证信号。 如图5.32所示，流星线1使市场放松下来，从先前剧烈的上冲状态转化为实质上的水平交易区间。在流星线3之后，出现了一根黑色蜡烛线。这么一来，一方面完成了一个看跌吞没形态，另一方面也验证了流星线的顶部反转信号。3月27日和28日组成了一个刺透形态，它结束了从流星形态3开始的下跌过程。以这个刺透形态为基础，市场开始上涨。后来，这段上涨行情终止于流星线4。请留心观察流星线4后面的下降趋势是在何处终了的——那便是4月21日的倒锤子线。它的次日是一根较高的白色实体，由此确认了这根倒锤子线的信号。倘若这个白色实体再长一些，那么我们就可以说这里出现了一个看涨的启明星形态（如果这根白色蜡烛线的实体较长，那么，倒锤子线之前的黑色实体、倒锤子线本身、倒锤子线之后的这根白色实体，将组成一个三蜡烛线的启明星形态）。由这条看涨的倒锤子线引发的上冲行情推动了价格的上涨，直到另一个——您猜着了——流星形态出现，这段上升趋势才结束。这就是流星线5。 图5.32 LME锌——3个月，1990年（流星形态和倒锤子线形态） 在图5.33中，也有一些倒锤子线的实例。请注意，倒锤子线1和2是如何为它们次日坚挺的价格变化所验证的。再强调一下，倒锤子线必须得到进一步的验证，这一点非常重要。倒锤子线2是图示启明星形态的一个组成部分。 图5.33 咖啡——1990年3月，日蜡烛图（倒锤子线形态）]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 蜡烛图与市场的整体技术面]]></title>
    <url>%2F2021%2F01%2F25%2F%E7%AC%AC4%E7%AB%A0-%E8%9C%A1%E7%83%9B%E5%9B%BE%E4%B8%8E%E5%B8%82%E5%9C%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%8A%80%E6%9C%AF%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 我曾经翻译过的一本日文书中有言：“无视市场情况而贸然投资，必将遭受伏击，损兵折将。”日本人常将军事术语引入技术分析。这句话很形象地告诉我们：依据蜡烛图进行买卖决策前，一定要先考虑市场的整体状况，否则难免亏损。 日本技术分析师协会的一位会员曾给我来信说，在他眼中，市场整体技术面的重要性远大于一个个孤立的蜡烛图形态。我完全同意这种看法。要掌握有效的蜡烛图交易技术，不但需要对蜡烛图有正确的理解，而且要采取稳定而连贯的交易战略和策略。可惜一些交易者只懂得蜡烛图形态，却往往忽视了那些交易策略。蜡烛图必须与其他交易策略原则有机结合，才能成为一个有效的工具。从这个意义上说，蜡烛图虽然很重要，但也仅仅是我的工具箱中的诸多工具之一。 有弟子曾问孔子：他会带哪种秉性的人上战场？孔子回答说，他要的不是视死如归的莽汉，而是谨慎面对困难、以策略谋胜的战士。策略也正是本章的主题。我拟阐述几个策略原则的重要性：止损、风险与收益的权衡、以大势为背景观察个股的蜡烛图、交易后跟踪市场的变化。只有全面掌握、使用这些策略原则，你才能真正发挥蜡烛图的力量。当你认真理解本章的内容后，你将会意识到：某个蜡烛图形态形成前后所出现的因素，才是交易成败的关键因素。 止损当价格到达某个点位时，你必须承认你的判断出了错，而这个价位就是你的止损点。无论某种技术分析工具如何可靠，它总会在某个时点给出错误的信号。贯彻止损策略，就等于控制交易的风险度。事实上，止损是技术分析中一个极为重要的方面，是一种风险管理的手段。 很多蜡烛图形态组合代表着压力或者支撑，比如乌云盖顶就是一种压力形态。如果你根据这个形态进行放空操作，止损点就应该是乌云盖顶最高点的上方。在图4-1中，1月开始的上升趋势出现了停滞，形成乌云盖顶的压力区，之后的7个交易日中市场受阻于这个压力区，上升态势转为横盘。但第8天出现了跳空上行的缺口（窗口），收盘价高出压力区的高点，由此发出信号：市场将再度上行。 一旦市场实际与主观判断背道而驰，人性的弱点决定了有些交易者会变得一厢情愿的盲目。例如，在图4-1中，市价已经上穿了止损位（乌云盖顶的高点），而某些做空者只会妄想着价格重新转入下跌，但在市场中常常事与愿违。一厢情愿的成本总是太高昂，恰如一句日本俗语所说，它就像“倚靠白云的梯子”，只会导致坠落。 如图4-2所示，1993年4月，大盘出现一个向上的跳空窗口。根据蜡烛图理论，这是一个支撑缺口，在9月出现的回调中，它确实一直起着支撑作用。面对这样一个缺口，交易者可以在回调到缺口区某个点位时买入，而此前做多者则应该把止损卖出点设在缺口底部下方，在周收盘（即周五收盘价）到达该点位时卖出。读者应该注意到，虽然该缺口在周内一度被完全回补，但空头力量有限，无力把股价长期压制在缺口下方。在这个例子中，尽管这是一个支撑缺口，但股价回调到缺口下方后，它所带来的情绪压力却使很多投资者难以忍受，尽管此后在周五收盘前，股价又被拉回缺口底部之上。它昭示我们，投资者的个性和修养也是交易成败的关键因素。 图4-1 超越乌云盖顶形态：1993年3月债券 在图4-3中，Amgen股价的上升缺口体现出支撑力，在11月的回调中始终没有被回补。回抽考验确认市场状况良好，推动股价向上突破75美元的高位。到达该价位后，蜡烛图形态呈包孕状（前一个蜡烛图完全包住后一个蜡烛图），显露出危险的迹象，并在随后的几个交易周内走出典型的头肩顶（S-H-S）形态（日本人称之为“三佛形态”）。一旦股价跌破头肩顶的颈线，往往意味着多头应该离场。如果股价封闭了原先支撑上涨的缺口，到达其下方，那就是市场转弱的最后一次预警，1993年年初的情况就是如此。支撑缺口的完全封闭，是场内的多头止损卖出的信号。 图4-2 止损与风险耐受力 图4-3 止损：Amgen—日线 风险与收益的权衡“择时而攻、择时而退者胜。” 参加完我的技术分析训练后，有些学员对新学来的蜡烛图技巧跃跃欲试，一回去就急不可耐地依据它进行交易。殊不知，就像我翻译过的一本日文书（一本交易必读书）中所说：“耐心等待时间之窗的开启；耐心是交易者成功的最重要的品性。”这就是说，理想的蜡烛图形态出现时，并不意味着最佳交易时机已来临。我警示学员，在判断最佳入场时机之前，应该先权衡一下风险与收益的比率。我曾经在一个机构投资者那里做过一期特别的培训，一位听过课的交易员后来来信说：“你说得真对，对蜡烛图的零星认识只会带来危险。全办公室的人都在激动地喊着‘十字星、十字星’。” 权衡风险与收益，就意味着设定止损点，这是控制风险的手段；同时还意味着设定目标价位，也就是潜在的回报。目标价位的确定有多种方式，包括艾略特波浪理论、支撑位和压力位等。由于蜡烛图技术通常不能给出目标价位，我常常推荐人们将西方技术分析与蜡烛图结合起来使用。蜡烛图最擅长发出趋势反转或者趋势持续的信号，而西方技术分析工具中的回调幅度与趋势线等有助于设定目标位。当然，你也许已经有了自己的目标价位设定方法。 请记住，在某个蜡烛图形态完成时，除非你判定风险与回报比率很诱人，否则请放弃交易。有句日本俗语所说的极是：“勇士的潜能是一张拉满的弓，但关键在于放弦的时机。”放弦的时机就取决于对风险与收益比率的研判。 在很多情况下，你只能拉弓等待。比如，当蜡烛图形态中多头或者空头信号出现时，如果风险与收益比率并不诱人，你应该放弃交易（除非你的交易是为了对冲保值）。如市场处于长阴长阳交错出现的大幅震荡时期，交易者也该退场观望。某日本技术分析著作将此种状况描述为“像8级地震”。如果有谁试图在此时入场交易，就如同一本日本书中所说的：“这是一种无谓的牺牲，一点不好玩。” 在图4-4中，9月初出现了阴包阳、呈吞噬状的熊市蜡烛图形态。由于吞噬性阴线的高点为压力点，所以，交易者如果此时想做空，止损点可以设定在这个形态的高点465的上方，以锁定风险。而目标价位则可以参照上月中旬的（或其他）上升缺口。这样一来，止损风险相比目标价位所体现的收益潜力来说很低，这个空头吞噬蜡烛图形态就构成了一个诱人的做空时机。 图4-4 蜡烛图与风险收益比 在图4-5中，1月出现了一个多头吞噬，股价由此回升，后来出现了一个上升缺口，两个交易日后，又是一根吞噬形态的长阴线。如果依此形态卖空，交易者必须问一个问题：此时卖空，风险收益比率诱人吗？（一般来说，股市卖空相对较少，但不妨以此蜡烛图指导其他市场的买卖，如期货市场，期货中做空比较常见。）如果全面分析技术形态，权衡风险与收益，就可发现这笔交易形同鸡肋，原因在于空头吞噬前面出现的上升缺口，如在当前价位卖空，止损点应该设定在大阴线的上方，而作为目标价位的上升缺口就在下方不远处，这样，风险与收益只能打个平手，这笔交易的收益风险比率很低。几周之后，蜡烛图走出了乌云盖顶的组合，此时如果以乌云盖顶的顶部为止损点，以上升缺口的底部为目标价位进行放空交易，将是一次收益不菲的战机。 图4-5 蜡烛图与风险收益比的重要性：沃尔玛—日线 图4-5说明了一个道理：很难在多个蜡烛图技术形态中确定哪个更重要，哪个更能说明问题。这张图中有一个空头吞噬形态。一般认为，阴线吞噬部分阳线的乌云盖顶组合所显露的空头威力要大大弱于空头吞噬。但是就本例而言，依据乌云盖顶形态卖空相比依据空头吞噬卖空，能够获得更好的交易收益机会。 图4-6显示，一个看涨的蜡烛图信号并不能保证新多获利。1月8～10日，蜡烛图走出了一个启明星的看涨组合，10日（当日启明星形态完成）的收盘价为1205美元。此时的价位是否值得买入？我们来做一次风险收益比率评估。首先要确定收益潜力。我们看到，上一年11月下旬的1220美元附近曾是一个支撑位，根据两极转换原理，原先的支撑位现在（1月上旬，看多启明星形成之时）变成了压力位，交易员因此可以预计反弹会到达1220这个阻力区附近，因此目标价格也就在1220附近。其次，我们来控制风险，依据蜡烛图理论，启明星的低点1169美元应该为现在的支撑位，也就是说止损位应在启明星低点1169的下方，如果未来的某个收盘价低于这个点，做多者应止损离场。 图4-6 风险收益比：1992年3月可可 由此可见这笔交易的几个参数：买入点为1205美元（启明星形态完成时的价位），止损位为1169美元，收益目标价位为1220美元。这就意味着36美元的风险与15美元的目标收益。无论怎么解释，这个收益风险比率都太低。由此得出的结论是：不要在某个蜡烛图形态出现之时就急于下单交易。请注意，这个启明星的底部一周以后成了支撑位。由此展开的上涨又如期在1220美元区域遭遇抵抗，形成高浪线1与长黑实体2，两者构成一个空头吞噬形态。通常来说，一波小幅上涨之后出现空头吞噬不必太在意。但是，在本例这个具体情况中，它却是值得注意的一个信号，因为它确认了1220美元这个阻力区。 趋势“下坡容易上坡难。” 日本有个美丽的说法，描述某些事物间的关系“就像风与云以及花与风的关系一样”。允许我把这个表述挪用到市场交易中。在这里，风代表趋势，云与花代表价格，价格的波动取决于趋势，恰如云和花的摆动控制在风的力量与方向中。因此，在趋势中判定价格的高低是非常重要的。也就是说，在决定新建一个仓位以前，应把当前的蜡烛图组合形态放在行情走势的大背景中来考虑。 如何把蜡烛图形态结合到行情趋势中？我的建议通常是：顺着趋势的方向下单交易，反转信号出现后冲销既有头寸。举例来说，在上升趋势中如果出现空头信号，就要冲销既有的多头头寸（或采取其他保护性措施，包括卖出买入期权，调高卖出（止损）价位）。上升趋势如出现多头信号，则可以建立新的多头头寸。在大幅下降趋势中，操作恰好相反。具体来说就是，在熊市中，主要应等待空头信号，一旦出现就建立新的空头头寸；熊市中的多头信号也可辅助使用，即一旦出现也许就可以考虑平仓既有的空头头寸。 我们可以有多种方法来判断趋势（在本书的下篇中，我们将讨论日本交易员与投资者常用的一些趋势判定方法）。本节的重点不是帮助你找到判定趋势的最佳方法，而是引导你将趋势融入蜡烛图分析之中。但我会讨论西方技术分析中所包含的用来判定趋势的常用方法，例如趋势线与移动平均线等。 读者如果有兴趣学习最流行的西方技术分析工具运用的实战技巧，包括趋势判定技术，我强烈推荐一本书：《期货市场计算机分析指南》（Technical Traders Guide to Computer Analysis of the Futures Market），作者是查尔斯·勒博和大卫·卢卡斯。即使你不以计算机从事交易，也不用让这书名吓着你。这是使用西方技术分析工具从事交易者不可或缺的参考书。 趋势线是判断趋势的最基本方法之一。在图4-7中，从6月下旬到8月上旬之间构成了一条压力线，使得市场一路走熊。然后有多根蜡烛线发出正在筑底的预警信号，具体来说，它们包括：7月的锤子线、8月上旬的启明星、8月下旬的上升窗口（它使得一个岛形底部得以完成）。但是要注意，所有这些向好信号发生的背景是一个熊市市道（体现为那条向下延伸的压力斜线（下降趋势线，也是下降压力线））。只有当行情突破了这条趋势线之后，一个新的多头趋势才获得了确认，行情开始向上攀升，但受阻于9月，形成一个乌云盖顶，而这个乌云盖顶形态又成为后续走势的阻力位。 如图4-8所示，7月初形成了一个空头吞噬组合（两根蜡烛线中间出现空档是因为当时正逢假日）。如果我们看一下整体技术面状况，包括那条趋势线，可以看出，如果根据这个空头吞噬而卖空，那么收益风险比明显过低，因为平仓的目标价位理论上是上升趋势线所构成的支撑位，止损点则在空头吞噬的上端。后来的行情发展证明，一直到7月19日收盘价到达趋势线下方时，这条构成支撑的上升趋势才被确认跌破。 图4-7 确认趋势反转：1991年12月咖啡 图4-8 蜡烛图信号与趋势线：1993年9月5年期票据 图4-9用来说明一种策略：在多头趋势中，多头信号可以用于在价格回落时的买进机会。图4-9a中有一条非常确定的上升趋势支撑线（趋势线受考验的次数越多则越重要）。蜡烛线①是1993年9月15日早盘后的形态，由于当天的交易尚未结束，所以蜡烛线①还不是一条完整的蜡烛线（我们知道一条蜡烛线的完成必须等待收盘后有了收盘价才行）。在图4-9a所停顿的时间点上（9月15日上午），市场刚刚考验了一条长期的上升趋势线（支撑线）。现在让我们把目光转到图4-9b，它是一个30分钟蜡烛图，图中显示，在9月15日上午，蜡烛线构成多头吞噬形态。图中的虚线代表的是与日线图中一样的那条上升趋势线。我们发现，尽管行情不断杀跌，逼近上升趋势线，但这时却出现了一个多头蜡烛图信号。这说明了一个观念，在一个牛市市场中，市场向下修正时也会出现多头蜡烛图信号，而这正是我们需要寻找的买入时机。 图4-9 蜡烛图与趋势线 对于以移动平均线来判定趋势的投资者，我利用图4-10来说明如何利用蜡烛图信号在趋势内进行操作。由于行情运行在移动平均线之下，所以趋势是下行的。在这种市道中，可以见空头信号而卖空，而见多头信号则应该平仓空头头寸。偏好风险的交易者可能愿意在熊市中买进，那么就要将短期阻力区作为预定的获利了结目标价位。在本例中，6月的反弹起始于一个包孕形态，但行情碰到52周移动平均压力线后，蜡烛图反映卖压猛增，出现了长上影线（蜡烛线①）和长黑实体（蜡烛线②）。交易者如果在包孕形态处买进，则移动平均线构成的阻力区应该设定为卖出区域。对于喜欢跟着整体趋势顺势交易的投资者而言（在本例中就是逢反弹卖空），前述空头蜡烛图信号可以用来卖空。图中的下降窗口显示空头进一步压低了行情。7月中旬出现了长白实体，暗示市场可能转强，但由此展开的上行再度受阻，形成一个十字星，正位于移动平均线体现的压力区。这是一个特别诱人的卖空时机，因为这个十字星不但正好位处52周移动平均线，而且也正好出现在下降窗口所构成的压力区。行情由此处开始杀跌，出现9根新低蜡烛线后才发生了反弹。 做一个市场变色龙“随机应变者胜。” 下单交易，就意味着你对市场的趋势有了自己的期待和判断。但是，市场如水，瞬息万变。因此，你必须持续关注行情的演变轨迹，以确定价格的变动是否符合你的预期。如果市场的发展出乎你的意料，就必须采取恰当的对策。所谓“做一个市场变色龙”，就是要顺应市场情况调整自己。做一个市场变色龙，迅速而有效地适应新的市场环境，是成功交易的关键。数年前我听到过一个很恰当的比喻，将交易比作比剑决斗。比剑决斗的结果，有生有死；交易的结果也是有生有死。在英语中，quick一词有两个意思，一是“迅速”，一是“活着”。在比剑决斗中，你必须反应敏捷，否则就可能丧命。交易也一样。做一个市场变色龙，就是迅速地因应市场的情况，调整自己，这样才能“活下来”继续从事交易。 只要你对行情形成了某个判断，就意味着你认为行情在某个时限内不会到达某个价位。如果行情恰恰在这段时间内达到了这一价位，就证明你的预测是错误的。在这里，我用图4-11来阐明这个概念。在图4-11中，10月下旬形成了一个乌云盖顶形态，于是我看空后市，因为许多技术信号在这里交汇在一起，暗示行情不会收盘于36美元上方。而且，我有四个理由来判断此后的反弹（如果有的话）都不能越过35.50～36.00美元： ·乌云盖顶的高点35.50美元应该会成为阻力位。 ·有一个小型下降窗口在36.00美元附近构成阻力。 ·下降窗口形成之前的三个交易日的蜡烛线低点在36.00美元。按照旧支撑会转变为新阻力的理论，这个价位会成为阻力位。 ·按斐波那契折返幅度（62%反弹或回调幅度，相当于黄金分割）理论测算，市场如果反弹，反弹幅度应不超过A点与B点之间的跌幅的62%，算下来这个高度大约在35.50美元。 图4-11 寻找改变市场舆论的价格 在本例中，如果多方有足够的力量推升价格，使之收盘于35.50～36.00美元阻力区的高点以上，就会证明我的判断发生了错误，此时必须改变看空的立场。换言之，我必须改变自己的判断，以适应新的市场条件。但行情的发展验证了我的判断，多头在见到乌云盖顶形态后数周内试图上攻35.50～36.00美元的阻力区，但无功而返。 在图4-12中，12月下旬的吊颈线与空头吞噬（中间的空档是假日）确认20美元附近是个阻力位。在这个区域，价格开始下滑，1月上旬行情在前一个月形成的19美元附近支撑位试图企稳。但是，1月12日的长黑实体跌破了19美元的支撑位。至此，所有的信号都是负面的。但是，长黑实体之后的高浪线发出蜡烛图信号，提示市场可能“变脸”。下一周，盘面又形成启明星形态，再次提示应该改变此前的看空判断。此后出现上升窗口，成为市场逆转的最后一个证据。 图4-12 做个紧跟市场的变色龙：1993年3月原油 计算机与蜡烛图“最锋利的刀，最应该小心使用。” 许多技术分析师会利用计算机来测试各种交易策略。随着计算机的日益普及以及蜡烛图理论的广泛流行，交易者可能希望用计算机来筛选最可靠或最重要的蜡烛图组合形态。对这些人士，我有个忠告：除了让计算机帮你寻找、挑选蜡烛图形态以外，还有许多因素必须纳入思考。这是本节的讨论重点。 蜡烛图形态出现的位置 如前所述，任何蜡烛图信号都必须置于此前的市场技术形态这个大背景中来观察。这与人们经常问我的一个问题有关：哪些蜡烛图形态最重要？在回答这个问题时，我总是首先建议考虑形态所传达的行情信号。例如，在比较乌云盖顶与空头吞噬形态哪个更重要时，我一般会认为，空头吞噬形态似乎更重要一些，因为这个形态中的第二根黑线收盘于前一根白色实体的下方，而乌云盖顶的第二根黑线只切入第一根白线的实体内部。所以，相比乌云盖顶形态，空头吞噬显示的空方控制程度更强（见图4-13）。 图4-13 乌云盖顶与空头吞噬比较 但是，我们绝不可以孤立地看待任何一个蜡烛图组合形态的意义，交易者必须观察这个形态周围的技术面。例如，如果乌云盖顶发生在重要的阻力位，而空头吞噬并不是出现在这种位置，那么前者的空头反转信号就强于后者。孤立地看一个形态是非常危险的，前面出现过的图4-5可以表明这一点：就收益风险比率来考察，图中的乌云盖顶相比空头吞噬形态而言，是个更诱人的交易（做空）机会，而那个空头吞噬则实际上没有构成机会，是个诱人的陷阱。一位日本交易员对此有句很有道理的话：“形态的位置比形态本身更重要。”因此，当你决定测试某个蜡烛图形态的可靠性时，绝对不可以只根据这一个形态来进行买卖决策，首先必须分析形态所在的位置。 如何决定一个蜡烛图形态的具体标准 对蜡烛图形态的判读，所依据的是对市场心理的正确推断。想想看，如果出现乌云盖顶，意味着市场发生了什么变化？在一根强劲的长白实体之后，行情高开，但收盘价低于前一根白线的收盘价，这不是清晰地显示空方已经从多方手中夺取了控制权吗？但是，蜡烛图形态是形态，不是数学，不直接依据数据来做判断，这一点使其区别于移动平均线及摆动率，对后两者可以很容易地进行计算判断。以移动平均线来说，今天的数据是否高于昨天，计算机可以给出明确的判断。蜡烛图形态不是如此清晰、明确，在判断某个蜡烛图或某个蜡烛图组合是否属于某种形态时，必然依赖主观解释。 在标准的乌云盖顶中，第二根黑线必须切入第一根白线实体的中点以下，这是一个可以量化的规则。如果某个形态像乌云盖顶，但又不是非常标准，黑色实体没有切入白色实体中点的下方，那么严格按标准工作的计算机，在筛选中就会排除这个形态。但是，如果这个非标准形态发生在重要阻力位呢？在这种情况下，我会将其视为与传统乌云盖顶形态有一样的空头内涵，如果依赖计算机而忽略这个形态的空头信号，显然是危险的。图4-14就反映了这种情况，我在乌云盖顶后面加了一个问号，因为它不是一个标准的乌云盖顶，第二根黑线的收盘价未到达前一个白色实体的中点以下。尽管如此，我仍然视之为乌云盖顶，理由如下：首先，黑线的上影线非常长，显示价格迅速从高点大幅下撤；其次，这根黑线的收盘位破坏了市场的技术面，因为它把价格压制在先前的一个高点（图中标示为H）以下，这是一个上插形态，是个空头信号；最后，乌云盖顶以后，行情收低，再次确认市场的内在弱势。 因此，即使只是让计算机帮你做一些最基本的筛选工作，也可能产生问题。如果要依赖计算机进行蜡烛图形态寻找与筛选，请记住，所有的这些标准形态只是信号标杆而已。标准形态相对容易量化，可以依赖计算机进行判别，而非标准形态也不容轻易放过，因为它们往往也是重要的市场信号。在这种情况下，主观判断就非常重要了，非计算机可为。这和标准条形图的识别中所涉及的主观成分其实是一样的。 图4-14 蜡烛图与主观性：美国银行—日线 下单交易 一旦某个蜡烛图形态出现，是否意味着它发出了买进或卖出信号？当然不是。如前所述，不能根据一个孤立的形态进行交易，必须首先考察这个形态形成时的整体技术面。 以流星线为例，如果某个流星线同时形成一个上升窗口，计算机程序会根据这个形态给出不恰当的卖出信号，图3-49反映的就是这种情况，后来的发展证明了这是一个错误的卖出时机。所以，让计算机根据形态给出交易信号，然后据此交易，而忽略当时的整体技术面情况（包括重要趋势、先前的价格变动等），就可能犯下错误。 另一个要考虑的重要问题是本章讨论过的收益风险比率问题。当一个蜡烛图组合形态出现时，并不一定就意味着要根据其信号进行交易。例如，如果黄金市场出现了一个启明星形态，潜在收益目标价位是15美元，而潜在风险也是15美元，是否还要按照这个多头信号进行交易？根据这个形态建立多头头寸是否合理？在本例中，回答当然是否定的。因此，某个交易是否合理，是否合算，取决于这个形态形成时市场当时的风险度、潜在收益率参数。 再举一例，在图4-15中，有两根锤子线。锤子线通常有潜在的多头意义，但从收益风险比率考虑，图中这两根锤子线都不构成做多理由。在这两个形态发生时，潜在风险大约都是15～20点（假定在行情下行到锤子线的低点以下时进行止损交易），而潜在收益是20～25点（因为425附近是阻力位）。如果根据计算机程序自动决策进行交易，在本例中都可以获利，因为在锤子线之后果然行情上涨。但是，从理论上讲，根据合理的资金管理原则，这两个多头信号还是放弃为好，因为相对于潜在收益而言，风险度还是过大。 图4-15 一笔交易的风险收益比 何时冲销一笔头寸 在计算机上进行止损设置是很容易的事情（某些计算机程序甚至没有设定止损，完全违背风险管理的概念，是一种非常危险的操作程序），但止损目标究竟如何决定呢？某个时候，某位交易者可能会设在上周的低点，而下一次，某位交易者可能将其设在支撑线上或者50%的反弹位或回落位。每一位交易者都有自己的风格，因此利用计算机进行蜡烛图买卖操作时，要考虑自己的个性。 在图4-16中，有一个黄昏星形态和一个多头吞噬形态。多头吞噬形态出现后，可以预期价格将会反弹，但反弹的目标价位如何设定呢？必须依赖其他的技术分析工具，因为蜡烛图理论通常不提供目标价位。 图4-16 蜡烛图与价格目标：1992年12月英镑 原先的支撑可以转化为阻力。根据这个理论，某位交易者也许会将目标价位设在七八月的支撑区，大约在1.85美元处。从图4-16中可以看出，如此期待，交易显然不会成功。但是，如果有另一位交易者根据斐波那契比率理论，将反弹幅度设定为9月高点到低点之间跌幅的38%，交易就会取得成功。对于第一位交易者来说，因为所设定的目标1.85美元没有达到，他也许就会认为这个多头信号不可靠。对于第二位交易者来说，行情符合预期，实现了目标（38%的反弹），他就会认为这个多头信号很成功。因此，在判定某个蜡烛图形态是否可靠时，必须考虑交易者的风格。 如何依据蜡烛图交易，很大程度上取决于你的交易理念、风险偏好与个性，而这些都是非常个人化的因素。如果你决定测试蜡烛图形态的可靠性，或者利用计算机来帮助你进行蜡烛图交易，还需要给自己定下交易标准和规则。在将蜡烛图应用于市场时，一定要考虑自己的交易风格。只有将这三者（蜡烛图理论、市场、交易个性）有机结合在一起，才能发挥蜡烛图的巨大威力。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术新解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API在云计算中的作用]]></title>
    <url>%2F2021%2F01%2F25%2FAPI%E5%9C%A8%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
  </entry>
  <entry>
    <title><![CDATA[gRPC入门]]></title>
    <url>%2F2021%2F01%2F25%2FgRPC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
  </entry>
  <entry>
    <title><![CDATA[第四章 反转形态]]></title>
    <url>%2F2021%2F01%2F17%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%8D%E8%BD%AC%E5%BD%A2%E6%80%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是锤子线和上吊线？ 锤子线出现在下降趋势中，就是下降趋势即将结束的信号。怎么理解？ 只有把价格形态与它之前的价格变化相结合，进行通盘的考虑，才能准确把握价格形态的意义。怎么理解？ 看涨吞没形态和看跌吞没形态分别是什么样子的？ 仅当反转信号所指的方向与市场的主要趋势方向一致时，我们才可以依据这个反转信号来开立新头寸。怎么理解？ 假定在牛市的发展过程中，出现了一个顶部反转形态，该怎么办？ 当上吊线出现时，一定要等待其它看跌信号的证实，这一点特别重要。为什么呢？ 上吊线的实体与上吊线次日的开市价之间向下的缺口越大，那么上吊线就越有可能构成市场的顶部。怎么理解？ 前言“一寸光阴以后的事都难预知”。 技术分析师瞪大眼睛盯着价格的涨落，为的是及早发现市场心理变化和趋势变化的警告信号。反转价格形态就是这样的技术线索。 然而，从一定意义上来说，“反转形态”这一术语的用词是不准确的。听到反转形态这个术语，往往使人误以为现有趋势将会突兀地结束，立即反转为新的趋势。实际上，这种情况很少发生。趋势的逆转，一般都是伴随着市场心理的逐渐改变进行的，通常需要经过一个缓慢的、分阶段的演变过程。 确切地说，趋势反转信号的出现，意味着之前的市场趋势可能发生变化，但是市场并不一定就此逆转到相反的方向上。弄清楚这一点，是至关重要的。我们不妨用行驶中的汽车来打个比方。一场上升趋势就相当于一辆以时速30英里前进的汽车。汽车的刹车灯亮了，汽车随后停了下来。刹车灯相当于趋势反转信号，它表明先前的趋势（相当于汽车向前行驶）即将终止。现在，汽车静止不动，那么下一步，司机是打算调头向相反方向行驶呢？还是停在那里不动呢？亦或是继续向前行驶呢？如果没有更多的线索，我们根本无从知晓。 图4.1到图4.3分别显示的是，当同一种顶部反转形态出现后，市场可能会经历的各种不同的变化过程。在图4.1中，市场从之前的上升趋势先转化为一段横向调整的行情，然后再开始形成方向相反的新趋势。在图4.2中，市场后来重新恢复到原先的上升趋势之中。在图4.3中，市场原先的上升趋势突然掉转为下降趋势。 把反转形态理解成趋势变化形态，才是慎重可取的考虑。因此请务必留意，“反转形态”这个术语仅仅意味着之前的趋势将发生变化，但是未必一定会反转。 及时判别反转形态的发生，是一项极有实用价值的市场分析技巧。交易的成功，需要两个方面的保证，既要能够正确地把握趋势、追随趋势，也要能够正确地把握趋势即将发生变化的各种可能性。反转形态，便是市场以其特有的方式为我们提供的一种指路牌，牌子上写着：“当心！趋势正在发生变化。”也就是说，市场的心理状态正在发生变化。那么，为了适应这种新的市场环境，我们就应当及时调整自已的交易方式。当反转形态出现时，如何建立新头寸，如何了结旧头寸，存在多种多样的选择。本书从头至尾所讨论的，就是相应的各种应对方法。 这里有一条重要原则：仅当反转信号所指的方向与市场的主要趋势方向一致时，我们才可以依据这个反转信号来开立新头寸。举个例子，假定在牛市的发展过程中，出现了一个顶部反转形态。虽然这是一个看跌的信号，却并不能保证卖出做空是有把握的。这是因为，市场当前的主要趋势依然是上升的。无论如何，就这个反转形态的实质意义来说，它构成了了结既有多头头寸的交易信号。如果当前主要趋势为下降趋势，那么，虽然还是这个顶部反转形态，但是它就足以构成卖出做空的凭据了。 关于反转形态这一主题，我们将进行详细深入的探讨，因为在蜡烛图技术中，大部分形态均属于反转信号。现在，就让我们把注意力转向蜡烛图反转信号的第一种类型，锤子线和上吊线。 锤子线吊颈线流星线锤子线，吊颈线和流星线的差异以及应用 锤子线和上吊线如图4.4所示的蜡烛图线具有明显特点。它们的下影线较长，而实体较小，并且在其全天价格区间里，实体处在接近顶端的位置上。在本图上，我们同时列出了黑白两种蜡烛线。有趣的是，这两条蜡烛线都既可能是看涨的，也可能是看跌的，具体情况要由它们在趋势中所处的位置来决定。在这两种蜡烛线中，不管是哪一个，只要它出现在下降趋势中，那么，它就是下降趋势即将结束的信号。在这种情况下，这种蜡烛线称为锤子线，意思是说“市场正用锤子夯砸底部”。请看图4.5。在日语里，这类蜡烛线原来的名称是“深水竿”。这个词在日文中大体的意思是“试一下水的深浅。” 在图4.4所示的两种蜡烛线中，无论哪一种，如果出现在上冲行情之后，就表明之前的市场运动也许已经结束。显而易见，这类蜡烛线就称为上吊线（如图4.6所示）。上吊线的名字是从它的形状得来的，这类蜡烛线看上去就像吊在绞刑架上双腿晃荡的一个死人。 形状相同的蜡烛线，有时是看涨的，有时又是看跌的，取决于它在市场趋势中所处的位置。 我们可以根据三个方面的标准来识别锤子线和上吊线： 1、实体处于整个价格区间的上端。而实体本身的颜色是无所谓的。 2、下影线的长度至少达到实体高度的2倍。 3、在这类蜡烛线中，应当没有上影线，即使有上影线，其长度也是极短的。 在看涨的锤子线的情况下，或者在看跌的上吊线的情况下，其下影线越长、上影线越短、实体越小，那么，这类蜡烛线就越有意义。虽然锤子线或者上吊线的颜色既可以是白的，也可以是黑的，但是，如果锤子线的实体是白色的，其看涨的意义则更坚挺几分；如果上吊线的实体是黑的，其看跌的意义则更疲软一点。如果锤子线的实体是白色的，就意味着在当天的交易过程中，市场起先曾急剧下挫，后来却完全反弹上来，收市在当日的最高价处，或者收市在接近最高价的水平上。这一点本身就具有小小的看涨的味道。如果上吊线的实体是黑色的，就表明当日的收市价格无力向上返回到开市价的水平。这一点或许就有潜在的看跌意味。 当上吊线出现时，一定要等待其它看跌信号的证实，这一点特别重要。为什么呢？当中的缘由要从上吊线的形成过程说起。通常，在出现这种蜡烛线之前，市场充满了向上的冲劲。突然，上吊线出现了。在上吊线这一天，市场的开市价就是当日最高价（或者当日的开市价接近最高价）。之后市场一度剧烈下跌，后来再上冲，最后收市于最高价的水平，或者接近最高价的水平。从上吊线的价格演化过程本身看来，未必令人联想到顶部反转形态。然而，这个价格变化过程预示着，一旦市场遭到空方的打压，就会不堪一击，迅速引发市场的向下突破。 次日，如果市场开市在较低的水平，那么，凡是在上吊线当日的开市、收市时买进的交易商，现在统统背上了亏损的头寸，被“吊”在上面。综合上述分析，我们就得到了关于上吊线的一条普遍原则：上吊线的实体与上吊线次日的开市价之间向下的缺口越大，那么上吊线就越有可能构成市场的顶部。在上吊线之后，如果市场形成了一条黑色的实体，并且它的收市价低于上吊线的收市价，那么，这也可以看作上吊线成立的一种佐证。 图4.7所示的实例颇精采，从中我们可以看到，同样一种蜡烛线既可以是看跌的（如7月3日的上吊线），也可以是看涨的（如7月23日的锤子线）。尽管在这个实例中，上吊线和锤子线的实体都是黑色的，但是它们实体的颜色并没有太大意义。 图4.7 大豆油——1990年12月，日蜡烛线图（上吊线和锤子线） 图4.8是另一个实例，也显示出了这类蜡烛线的双重特性。如图所示，4月中旬有一个看跌的上吊线，它标志着市场先前的上涨行情的终止，而且这轮上涨行情是从4月2日的一条看涨的锤子线开始的。3月中旬，出现了另一个上吊线的变体。虽然这条变体上吊线的下影线也比较长，但未能达到实体高度的2倍。不过，另外两项标准它还是满足的（即它的实体位于当日价格区间的上端，并且它几乎没有上影线）。再往后看，次日的收市价低于这根蜡烛线的收市价，因而构成了它的验证信号。综合起来，尽管这条蜡烛线不是理想的上吊线，但它也是成立的。如图所示，这条蜡烛线确实成功地标志着起步于1个月之前的上涨行情的结束。蜡烛图技术为我们提供了一套图表分析要领，这一点与其它图表分析技术或者其它形态识别技术是一致的。然而，我们应当清楚地了解，这些要领并不是一成不变的定律。 图4.8 道琼斯工业股票平均指数——1990年，日蜡烛线图（上吊线和锤子线） 前面曾经交代，对上吊线和锤子线形态来说，特定的图形特征能够加强它们的技术意义。但是，正如本图3月中旬的上吊线所示，上吊线下影线的长度并不是非得达到实体高度的2倍不可，才足以构成反转信号。一般说来，在这类形态中，下影线越长，形态就越完美。 在图4.9所示的实例中，出现了一系列的看涨锤子线，我们用从1到4的数字给它们作了记号（锤子线2虽然有一段小小的上影线，但我们还是把它看作一根锤子线）。本例的有趣之处是这张图表于1990年初发出的那个买入信号。在锤子线3和锤子线4上，市场曾经两度向下越过了锤子线2处的7月份的低点，两度创出新的低价位（新低）。然而，熊方没能乘机扩大战果，继续把球控制在己方脚下。他们失了手，球丢了。这两条锤子线（3和4）表明，牛方重新执掌了市场的主动权。锤子线3并不是一条理想的锤子线，因为它的下影线达不到实体高度的2倍。但是，这条蜡烛线确确实实地显示，熊方没有能力维持新低价格水平。紧接着，下一周又是一根锤子蜡烛线，这就再度强调了如下的结论：很可能即将发生底部反转过程。 图4.9 铜——周蜡烛图（锤子线） 在图4.10中，锤子线1和3都属于底部形态。锤子线2标志着先前的下降趋势的结束，于是市场趋势从下降转为横向延伸。锤子线4未起作用。这条锤子线就引出了关于锤子线形态分析的一项重要的注意事项（其实，这也是我将讨论的所有其它形态的一个关键点）。只有把价格形态与它之前的价格变化相结合，进行通盘的考虑，才能准确把握价格形态的意义。带着这样的全局观，再来观察一下锤子线4。我们注意到，在这条锤子线的前一天，市场走出了一条极其疲软的蜡烛线。这是一条长长的、黑色的秃头秃脚蜡烛线（全秃蜡烛线，就是说，开市价位于当日最高处，收市价位于当日最低处）。这条蜡烛线清晰地说明，市场具有强劲的向下动力。此外，锤子线4也向下穿透了市场过去在1月24日建立起来的支撑水平。再考虑到前面所分析的看跌因素，那么，当锤子线4出现时，稳妥的做法是，先等一等其它验证信号，看看牛方是否确实已经重新占据了上风，然后见机而作。比如说，如果在锤子线4之后，再出现一根白色的蜡烛线，并且它的收市价高于锤子线4的收市价，那么，后来的这条蜡烛线就可以看作是一个验证信号。 图4.10 原木——1990年5月，日蜡烛图（锤子线） 我们也可以采用蜡烛图形式来绘制日内时间单位的图表。在这种情况下，蜡烛线显示的是相应时间段内的最高价、最低价、最初价和最后价（如图4.11所示）。举例来看，如果我们以小时为基本时间单位，那么，每根蜡烛图线将采用相应一小时的最初价和最后价来绘制其实体，而用这一小时的最高价和最低价来绘制上下影线。如果我们仔细地观察这张图表，就会看到，在4月11日的头一个小时，市场形成了一根锤子线。与图4.10中的锤子线4一样，在这根锤子线处，市场也形成了一个向下的价格跳空。但是与之不同的是，在本锤子线之后，跟随着一根白色的蜡烛线，并且这根白色蜡烛线的收市价高于本锤子线的收市价。这对证实市场底部的形成是很有帮助的。 图4.11 原油——1990年6月，日蜡烛图（锤子线） 再看4月12日的第二根小时蜡烛线。虽然它的外形同锤子线有相似之处．但它并不是一根真正的锤子蜡烛线。锤子线后于底部反转形态。在锤子线的判别准则中，其中有一条是，在锤子线之前，必定先有一段下降趋势（哪怕是较小规模的下降趋势），这样锤子线才能够逆转这个趋势。这条蜡烛线也不是上吊线，因为上吊线必须出现在一段上升趋势之后。在本图所示的情况下，如果把这根蜡烛线提高到前一根黑色蜡烛线的顶部附近，那么，我们就可以将它判定为上吊线了。 在图4.12中，4月初有一根锤子线，它成功地预示了一轮持续数月的主要下降行情的终结。这根蜡烛线下影线很长（其长度是实体高度的许多倍），实体很小，又没有上影线，于是就成了一条经典的锤线。 图4.12 日经指数——1990年，日蜡烛图（锤子线） 图4.13显示的是一例经典的上吊线形态。在上吊线出现的这一天。市场向上跳空开市，并由此创出了新的高价位（新高）。第二天，市场向下跳空，于是凡是在上吊线的开市或收市时买进的新多头，都被高高“吊起”，处于亏损状态。 图4.13 白银——1990年5月，日蜡烛图（上吊线） 在图4.14中我们看到，自2月初开始的上升行情随着两条连续的上吊线的到来而宣告破产。在上吊线出现后，还需要其它看跌信号的验证。这一原则的重要性，在本图例中也得到了体现。在上吊线的看跌验证信号中，有一种情况是，次日的开市价低于上吊线的实体，这是为上吊线求得证实的第一个办法。请注意，当第一根上吊线出现后，次日市场是以较高的价格开市的。但是，在第二根上吊线之后，第二天市场终于开市在这条上吊线的实体之下，于是，市场便掉头下行了。 图4.14 可可——1990年5月，日蜡烛图（上吊线） 如图4.15所示，如果在上吊线之后，是一条具有黑色实体的蜡烛线，并且它的收市价低于上吊线的收市价，那么，这种情况也构成了上吊线的看跌验证信号。这是我们为上吊线求得证实的第二个办法。在本图例中，蜡烛线1、2和3形成了一系列上吊线。在上吊线1和2之后，均没有发生看跌验证信号，这就意味着在这两处，上升趋势依然处在照常发展的状态之下。 图4.15 美元指数——周蜡烛图（上吊线） 请注意上吊线3。接踵而来的那条黑色蜡烛线，为这条上吊线提供了看跌验证信号。在上吊线3的次日，虽然市场的开市价几乎没有变化，但是到收市的时候，那些在上吊线的开市或收市时买进的多头，已经统统给“上吊”在亏损状态了（在本例中，在次日这根长长的黑色蜡烛线上，市场的抛售过程激烈到了白热化的程度，以致于凡是在上吊线当日买进的人，不仅仅是那些在开市和收市买进的人，统统被套牢在亏损头寸里）。 图4.16所示，是橙汁市场的一个实例。从1989年底到1990年初，在本图上出现了一段触目惊心的上涨行情。请注意这场上升行情是在何处结束的。1990年的第三周是一根上吊线，挡住了上述涨势。本实例充分说明了下面这个要点：反转形态的出现，并不意味着市场必定向相反的方向逆转。这一点，我们在第三章曾经做过研究。准确地说，反转形态的出现，预示着之前的趋势即将发生变化。本图例中的情形，正是上述分析的现实体现。在图示的上吊线反转形态形成后，之前的上升趋势就结束了，市场演变成了新的横向延伸趋势。 图4.16 橙汁——周蜡烛图（上吊线） 在本图例中，7月里出现了另一条上吊线。这一次，市场很快就从上升反转为下降。但是，正如我们前面曾经反复强调的，当遇上顶部反转形态时，我们不应当总是期待这种情景的出现。 在图4.17中，5月里显示出了一个经典的上吊线形态。从这个蜡烛线的形状来看，其实体极小、没有上影线、下影线很长。次日的黑色实体证实了这根上吊线的可靠性，提示我们，现在是出清多头头寸的时候了（请注意，在本图上，4月初有一个看涨的锤子线）。 图4.17 美洲航空公司——1989，日蜡烛图（上吊线，锤子线） 吞没形态（抱线形态）吞没形态 锤子线形态和上吊线形态是由单独的一根蜡烛线构成的。如前面所讨论，它们能够就市场的健康情况发出重要的技术信号。不过，在绝大多数情况下，蜡烛图技术信号都是由数根蜡烛线组合在一起形成的。吞没形态（或者说，抱线形态）是我们将介绍的第一类由数根蜡烛线组成的复合形态。吞没形态属于主要反转形态，是由两根颜色相反的蜡烛线实体所构成的。 图4.18显示的是看涨吞没形态（看涨抱线形态）。在本图中，市场本来处于下降趋势之中，但是后来出现了一根坚挺的白色实体，这根白色实体将它前面的那根黑色实体“抱进怀里了”，或者说把它吞没了。这种情形说明市场上买进的压力已经压倒了卖出压力。图4.19是看跌吞没形态（看跌抱线形态）的示意图。在本例中，市场原本正向着更高的价位趋升，但是当前一个白色实体被后一个黑色实体吞没后，就构成了顶部反转的信号。这种情形说明，熊方已经从牛方手中夺走了统治权。 关于吞没形态，我们有三条判别标准： 1、在吞没形态之前，市场必须处在清晰可辨的上升趋势或下降趋势中，哪怕这个趋势只是短期的。 2、吞没形态必须由2条蜡烛线组成。其中第二根蜡烛线的实体必须覆盖第一根蜡烛线的实体（但是不一定需要吞没前者的上下影线）。 3、吞没形态的第二个实体必须与第一个实体的颜色相反。这一条标准有例外的情况，条件是，第一条蜡烛线的实体必须非常小，小得几乎构成了一根十字线（或者它就是一根十字线）。如此一来，如果在长期的下降趋势之后，一个小小的白色实体为一个巨大的白色实体所吞没，那么也可能构成了底部反转形态。反之，在上升趋势中，如果一个小小的黑色实体为一个巨大的黑色实体所吞没，那么也可能构成了顶部反转形态。 在西方的技术分析理论中，与日本蜡烛图吞没形态最近似的形态是反转日形态。西方反转日形态的具体情形是，在上升趋势（或下降趋势）的发展过程中，某一日市场曾经创出了新高（或新低），然而，当日的收市价却低于（或高于）前一日的收市价。您将发现，有的时候，蜡烛图的吞没形态发出的反转信号，按照西方的反转日概念是看不出来的。凭着抱线形态的这一优势，同那些采用传统的反转日概念作为反转信号的同行相比，您就占据了上风。关于这个问题，我们在图4.21、4.22和4.23中还有进一步的探讨。 下面列出了一些参考性要素，如果吞没形态具有这样的特征，那么它们构成重要反转信号的可能性将大大地增强： 1、在吞没形态中，第一天的实体非常小，而第二天的实体非常大。这种情况可能说明原有趋势的驱动力正在消退，而新趋势的潜在力量正在壮大。 2、吞没形态出现在超长期的或非常急剧的市场运动之后。如果存在超长期的上升趋势，则增加了以下这种可能性：潜在的买家已经入市买进，持有多头。在这种情况下，市场可能缺少足够的新的多头头寸的供应，无力继续推动市场上升。如果存在非常急剧的市场运动，则市场可能已经朝一个方向走得太远，容易遭受获利平仓头寸的打击。 3、在吞没形态中，第二个实体伴有超额的交易量。这种情形可能属于胀爆现象（如何在蜡烛图上进行交易量的配合分析，我们将在第十五章讨论）。 4、在吞没形态中，第二天的实体向前吞没的实体不止一个。 如图4.20所示，5月15日和5月22日所在的两个星期组成了一个看涨吞没形态。7月的最后2个星期形成了一个看跌吞没形态。9月份有一个看涨吞没形态，在图示主要上涨行情之前，有一小段抛售行情。它是这段抛售行情的底部。 图4.20 瑞士法郎——周蜡烛图（看涨和看跌吞没形态） 图4.21是原油的月蜡烛线图，从中既可以看到看涨吞没形态，也可以发现看跌吞没形态。从1985年末开始，市场走出了一场幅度达20美元的陡直下跌行情。1986年的第3个月和第4个月，先后形成了图示看涨吞没形态的两根蜡烛线。这一形态标志着之前的下降趋势的结束。从这个看涨吞没形态起，发生了一段上涨行情，但是1987年年中的看跌吞没形态给它划上了句号。1988年2月和3月形成的较小的看涨吞没形态，又将从1987年中的看跌吞没形态开始的下降趋势终结了。在这个看涨吞没形态之后，市场从下降趋势转为横向趋势，并持续了5个月之久。 图4.21 原油——月蜡烛图（看涨和看跌吞没形态） 1990年2月是一根黑色的蜡烛线，虽然它也将1月的白色蜡烛线的实体覆盖起来了，但是它超出1月实体的幅度还不到8个基本价格变化单位。从这一点来看，这不是一个理想的看跌吞没形态。然而，在进行蜡烛图技术分析的时候，必须包括一定程度的灵活性，这一点与其它图表分析手段相比并没有什么不同。考虑到本形态内在的种种疲软的迹象，将这个形态认定为看跌吞没形态是稳妥的，如果我们仅仅因为8个基本价格变化单位的差距不够大，而排除了它们构成看跌吞没形态的可能性，那么反倒是非常危险的。所有的图表分析技术都不例外，始终为分析者留有发挥主观判断的余地。 1987年和1990年的两个看跌吞没形态，充分体现了蜡烛图吞没形态的优越之处，它们发出的反转信号，如果用西方技术分析理论的反转日的标准来判断，是得不到的。根据西方顶部反转日概念的判别准则（在本例中，实际上是反转月的情形），其中第二条图线必须创出当前行情的新高。而在上述两个看跌吞没形态的实例中，第二根黑色蜡烛线并没有为当前行情创出新高。因此，按照美国的西方反转日的标准来衡量，它们就构不成反转形态。然而，按照蜡烛图技术的标准，这两个反转形态则是成立的。 图4.22是另一个很好的实例，从中我们也能体会到，相对于常规的线图分析工具来说，蜡烛图技术可能具有更大的优势。请注意7月7日和8日这两天的价格变化。这里的情况与上例类似，第二天与第一天比较，并没有创出新高，如果我们采用西方传统的反转日概念来衡量，那么这里丝毫没有发生顶部反转的迹向。然而，以蜡烛图技术来分析，这却是一个看跌反转信号，即此时市场确实形成了一个所谓的看跌吞没形态。 图4.22 白金——1989年10月，日蜡烛图（看跌吞没形态） 6月初有两根蜡烛线，蜡烛线1和2，看上去似乎是一个看涨吞没形态。但是，看涨吞没形态属于底部反转信号。这就是说，它们只有出现在下降趋势之后（或者在有的时候，出现在横向交易区间的下边界）才是成立的。在本图例中，虽然6月初出现了这个形似的看涨吞没形态，但是由于它并不处在下降趋势之中，因此，并不具有通常的预测意义。 在图4.23中，发生了一系列看跌吞没形态。吞没形态1将市场从之前的上升趋势，拖入一段持续了数月的水平交易区间。吞没形态2仅仅为当时的上涨行情带来了短暂的喘息机会。看跌吞没形态3、4、5所发出的反转信号，统统是西方技术分析工具提供不来的（这是因为在这三个反转形态中，它们的第二周均没有创下当前行情的新高，所以三者均不符合反转周的标准）。 图4.23 大豆——周蜡烛图（看跌吞没形态） 乌云盖顶形态（乌云线形态）刺透线和乌云盖顶形态 下面我们要研究的反转形态是乌云盖顶形态（或者说乌云线形态，如图4.24所示）。 图4.24 乌云盖顶形态 这种形态也是由两根蜡烛线组成的，属于顶部反转形态。它们一般出现在上升趋势之后，在有些情况下也可能出现在水平调整区间的顶部。在这一形态中，第一天是一根坚挺的白色实体；第二天的开市价超过了第一天的最高价（这就是说超过了第一天的上影线的顶端），但是，市场却收市在接近当日的最低价的水平，并且收市价明显地向下扎入到第一天白色实体的内部。第二天的黑色实体向下穿进第一天的白色实体的程度越深，则该形态构成顶部反转过程的可能性就越大。有些日本技术分析师要求，第二天黑色实体的收市价必须向下穿过前一天白色实体的50％。如果黑色实体的收市价没有向下穿过白色蜡烛线的中点，那么，当这类乌云盖顶形态发生后，或许我们最好等一等，看看是否还有进一步的看跌验证信号。 这种看跌形态背后的道理是很容易理解的。在形态发生之前，市场本来处于上升趋势之中。有一天，出现了一根坚挺的白色蜡烛线。第二天，市场在开市时便向上跳空。到此刻为止，牛方完全掌握着主动权。然而，此后，市场却没有继续上冲！事实上，市场收市在当日的最低价处，或者在最低价附近，并且这个收市价明显地向下扎进了前一天的实体内部。在这种情况下，多头头寸持有者的信心便开始动摇。还有一些人一直在找机会卖出做空，那么现在他们就得到了一个设置止报指令的参考水平——在乌云盖顶形态的第二日形成的新高价格水平。 下面列出了一些参考性因素，如果乌云盖顶形态具有这样的特征，则有助于增强其技术分量： 1、在乌云盖顶形态中，黑色实体的收市价向下穿入前一个白色实体的程度越深测该形态构成市场顶部的机会越大。如果黑色实体覆盖了前一天的整个白色实体，那就形成了看跌吞没形态。在乌云盖顶形态中，黑色实体仅仅向下覆盖了白色实体的一部分。我们不妨把乌云盖顶形态比作日偏食，在这种情况下，月亮只遮住了太阳的一部分（换句话说，覆盖了部分白色实体）。那么，看跌吞没形态就成了日全食，在这的情况下，月亮遮住了太阳的全部（也就是说，覆盖了整个白色实体）。从这一点上说，作为顶部反转信号，看跌吞没形态比乌云盖顶形态具有更重要的技术意义。如果在乌云盖顶形态之后，或者在看跌吞没形态之后，出现了一根长长的白色实体，而且其收市价超过了这两种形态的最高价，那么这可能预示着新一轮上冲行情的到来。 2、乌云盖顶形态发生在一个超长期的上升趋势中，它的第一天是一根坚挺的白色实体，其开市价就是最低价（就是说，是秃脚的），而且其收市价就是最高价（就是说，是秃头的）；它的第二天是一根长长的黑色实体，其开市价位于最高价，而旦收市价位于最低价（这是一个秃头秃脚黑色蜡烛线）。 3、在乌云盖顶形态中，如果第二个实体（即黑色的实体）的开市价高于某个重要的阻挡水平，但是市场未能成功地坚守住，那么可能证明牛方已经无力控制市场了。 4、如果在第二天开市的时候，市场的交易量非常大，那么这里就可能发生胀爆现象。具体说来，当日开市价创出了新高。而且开市时的成交量极重，可能意味着很多新买家终于下决心入市，踏上了牛市的“船”。随后，市场却发生了抛售行情。那么，很可能用不了太久，这群人数众多的新多头（还有那些早已在上升趋势中坐了轿子的老多头）就会认识到，他们上的这条船原来是“泰坦尼克”号。对期货交易商来说，极高的持仓量也是一种警告信号。 图4.25显示了乌云盖顶形态与看跌吞没形态的区别。1989年6月，有两根蜡烛线组成了一个乌云盖顶形态。前一根具有长长的白色实体，后一根具有长长的黑色实体黑色实体的开市价为当前这轮涨势创出了新高但它的收市价则接近其最低价，并且显著地向下穿入了前一天的白色实体之中。本图例所示为市政债券市场，当这个顶部反转形态出现后，该市场就向下回落了。几个星期后，市场遭到了最后的致命一击，此时出现了一个看跌吞没形态。从本实例可以看到，在乌云盖顶形态中，黑色的实体仅仅覆盖了前一日白色实体的一部分。而在看跌吞没形态中，黑色实体则完全地覆盖了前一日的白色实体。 图4.25 市政债券——周蜡烛线图（乌云盖顶形态和看跌抱线形态） 在图4.26中，可以看到3个乌云盖顶形态。这三个形态每一个都有其它的看跌信号对它们进行了验证。下面我们依次进行单独的研究。 图4.26 原油——1990年7月，日蜡烛线图（乌云盖顶形态） 1、乌云盖顶形态1。这是理想乌云盖顶形态的一种变体。在这个乌云盖顶形态中，第二天的黑色实体的开市价与前一日的最高价一致，而不是向上超过了它。本形态仅仅足以构成警告信号，但是，我们仍然应当把它视为一项负面因素。另一方面，这个乌云盖顶形态还标志着牛方曾经企图向上突破由2月中旬的最高点形成的阻挡水平，但是这个企图已经遭到了挫败。 2、乌云盖顶形态2。在这里，除了这个乌云盖顶形态以外，还有其它的理由说明21美元的价格水平值得我们留神。在技术分析中，有一条基本的定理：原先的支撑水平一旦被突破，则转化为新的阻挡水平。这正是在21美元处发生的情况。请注意，21美元原本是一个支撑水平。但是一旦在3月9日被向下突破后，就转化为阻挡水平了。这一例乌云盖顶形态发生在4月的头两个交易日，在此期间，市场曾有过上冲的尝试，但失败了，由此证明了该阻挡水平的存在（第十一章将要研究支撑水平与阻挡水平角色变换的问题）。 3、乌云盖顶形态3。这里也显示了一个市场向上挑战阻挡区的失败过程，该阻挡区是由4月下旬的最高价形成的。 在上面这些实例中。疲弱的乌云盖顶形态恰巧都与阻挡水平不谋而合。其实这中间的关系并不简单，它揭示出一个重要的概念，其意义不仅在于一种技术指标与另一种技术指标的相互验证，而且还有更深刻的内容。有关问题是本书第二部分的核心内容。届时我们将研究如何把蜡烛图技术与其它技术分析工具结合起来。 在图4.27中，3月上旬出现了乌云盖顶形态1，它中止了之前为时2个星期的上冲行情。随后，市场展开了1个星期的调整。4月份，又形成了另外两个乌云盖顶形态。鸟云盖顶2显示，之前2天的急剧上升可能已告完成。乌云盖顶形态3发生在4月中旬，这个形态尤其疲弱。为什么这个乌云盖顶形态的结果会如此软弱呢？其中的缘由与本形态形成时市场的心理过程有关。 图4.27 S&amp;P指数——1990年6月（乌云盖顶形态） 正如过去所指出，乌云盖顶形态之所以具有负面意义，是因为以下基本原理：该形态第二根线的开市价本来已经创出了新高，但是在收币时，市场反而深深地向下穿入了前一个白色实体的内部。那么如果在某个乌云盖顶形态中，第二天的开市价不仅向上突破了前一天的最高价，同时还向上突破了数天之前的、数周之前的、甚而至于数月之前的最高价，然后当日再从这样的新高水平上失守下跌，后果会是什么样的呢？这样的局面将具有极其疲软的内涵。而这正是在本实例中4月里发生的情况。在乌云线形态3中，黑色的蜡烛线本来已经向上触及了至少过去3个月内的最高价格水平。但是，市场无力维持这样的高位，并且在收市时显著地返回到前一日的白色实体之内。 在图4.28中我们看到，自2月10日开始，市场一路上扬，但当2月中旬的乌云盖顶形态出现后，这段行情就截然地中止了。 图4.28 1990，日蜡烛线图 刺进形态（斩回线形态）在我的许多讲座中，当我介绍完看跌的乌云盖顶形态以后，过不了多会儿，就会有听众提问，有没有与乌云盖顶形态相反的形态。是的，有这样的形态，它的名称为刺透形态（或者说，斩回线形态）。乌云盖顶形态属于顶部反转信号。那么，刺透形态作为它的反面形态，当然是底部反转信号（如图4.29所示）。斩回线形态出现在下跌的市场上，也是由两根蜡烛线组成的。其中第一根蜡烛线具有黑色实体，而第二根蜡烛线则具有长长的白色实体。在白色蜡烛线这一天，市场的开市价曾急剧地下跌至前一个黑色蜡烛线的最低价之下，但是不久市场又将价格推升回来，形成了一根相对较长的白色实体，并且其收市价已经向上超越了前一天的黑色实体的中点。 图4.29 刺透形态（斩回线形态） 看涨的刺透形态与看涨吞没形态同属一个家族，在看涨吞没形态中，白色实体吞没了前面的那条黑色实体。而在看涨的刺透形态中，白色实体仅仅向上刺入了前一个黑色实体的内部。在刺透形态中，白色实体向上刺入黑色实体的程度越大，那么，该形态构成底部反转信号的可能性就越大。在理想的刺透形态中，白色实体必须向上穿入到前一个黑色实体的中点水平以上。在看涨吞没形态之后，或者在看涨的刺透形态之后，如果跟着出现了一条长长的黑色蜡烛线，并且它的收市价低于上述两种形态的最低点，则说明下降趋势已经卷土重来，新一轮下跌行情开始了。 关于刺透形态背后的心理过程，可以作如下理解：市场本来处于下降趋势中，刺透形态第一天的疲弱的黑色实体加强了这种市场预期。第二天，市场以向下跳空的形式开市。到此刻为止，熊方观察着行情的发展，感觉诸事顺遂。可是后来，到当日收市的时候，市场却涨了回去，结果收市价不仅完全回到了前一天收市价的水平，而且变本加厉地向上大大超越了这个水平。现在，熊方开始对手上的空头头寸忐忑不安起来。有些市场参与者一直在寻找买进的机会，他们据此推断，市场不能够维持这个新低价位，或许这正是入市做多的大好时机。 关于刺透形态，也有四项参考性因素，如果刺透形态兼具这些特征，那么它们的技术分量将大为增强。这四项参考因素与乌云盖顶形态的四项参考因素内容相同，而方向相反（参见前一部分的有关内容）。在讲述乌云盖顶的时候，我曾经提到，虽然有些日本交易商更愿意看到黑色实体的收市价向下穿过了前一个白色实体的中点，但是在这一条判别准则上，还是有一定的灵活余地的。然而，在斩回线形态中，却没有任何灵活的余地。在斩回线形态中，白色蜡烛线的实体必须向上推进到黑色蜡烛线实体的中点之上。之所以看涨的刺透形态不如乌云盖顶形态灵活，是因为日本人认为处理底部反转形态必须更加谨慎。他们对形状近似的价格形态做了进一步的区分，将它们分为三种情况，分别称为待入线形态、切入线形态、插入线形态（参见图4.30到图4.32）。这三种形态虽然与刺透形态在基本构造上是相似的，但是，正是由于其中的白色实体向上穿入黑色实体的程度达不到黑色实体的中点，它们被看作是看跌的信号。 综上所达，上述三类潜在的看跌信号（如图4.30到图4.32所示）与看涨的斩回线形态（如图4.29所示）在图形上统统是一样的。它们之间的区别仅仅在于，其中的白色蜡烛线实体向上穿入黑色蜡烛线实体的程度是不同的。在待入线形态中，白色蜡烛线（其外形通常是比较小的）的收市价位于前一个蜡烛线的最低价下方附近。在切入线形态中，白色蜡烛线（它也应当是较小的白色蜡烛线）的收市价稍稍进入到前一个黑色实体的范围之内。在插入线形态中，白色蜡烛线比上述两个形态的更长一些，其收市价也更多地刺入前一个黑色实体之内，但是没有达到黑色实体中点的水平。本形态同前两个形态相比，稍稍坚挺一些。 在市场形成了上述三类形态的情况下，只要价格再次下跌到其中的白色蜡烛线的最低点以下，交易商就应当明日，卖出的好机会来了（请注意，图4.32所示的插入线形态如果处在下跌行情中，是看跌的，但是，如果它处在上升行情中，则应该视为看涨信号。另外，在下跌行情中，如果市场在数天之内接连形成了两个插入线形态，那么，这种情况也属于看涨信号）。 能不能将图4.30到4.32所示的每种形态都牢记于心，并不要紧。您只要记住，在斩回线形态中，白色蜡烛线的实体必须向上推进到黑色蜡烛线实体的中点以上，才能够构成底部反转信号。 如图4.33所示，4月27日，熊方成功地将市场打庄到当前行情的新低水平，形成了一根长长的黑色实体。次日，市场以较低的价位开市，但是后来，这个开市价竟演化为当日的最低价，到收市时，图示波音公司的股票价格已经深深地向上穿进了前一日的黑色实体之内。于是，4月27日和28日的两根蜡烛线构成了一个看涨的刺透形态。 图4.33 波音公司——1990年，日蜡烛图（刺透形态） 在图4.34中，在3月26日所在的一个星期里，出现了一个经典的斩回线形态。请注意，在其中的白色实体之前，是一根非常疲软的长长的黑色实体。在白色蜡烛线当日，市场开市于当前行情的新低水平。但是，当日的收市价非常坚挺，深深地向上推进到前一个黑色实体的内部。这一事实有力地说明，熊方已经丧失了对市场的控制权。这根白色蜡烛线是一个极其坚挺的交易日。它开市于最低价（也就是说，它是秃脚的），收市于最高价（也就是说，它是秃头的）。请注意，这个坚挺的刺透形态终结了之前的那轮抛售行情。这段抛售行情是由3月19日和20日的看跌吞没形态引发的。 图4.34 小麦——1990年5月，日蜡烛图（斩回线形态） 本图例为小麦市场。在3月12日所在的那个星期里，产生了另一个变体的刺透形态。为什么说这个刺透形态是一个变体呢？因为其中的白色实体的开市价仅仅低于前一天的实体，但是没有低于前一天的最低点。尽管如此，由于该白色实体的收市价穿入了前一天黑色实体的5O％以上，本形态还是足以构成一个警告信号，说明先前的下跌行情已经是强弩之末。 图4.35表明，蜡烛图形态能够帮助分析者对市场的健康状况作出一个快速的诊断。在1990年2月后半个月里，曾经有位经纪商问我对燕麦市场怎么看。实际上，我很少留心燕麦市场。虽然如此，我还是调出了如图4.35所示的燕麦市场的蜡烛图，然后告诉他，当前的下降趋势可能已经结束了。为什么这么说呢？因为我注意到在2月20日所在的一周里，该市场出现了一个几乎堪称经典的刺透形态。另一方面我还发现，市场在形成上述刺透形态的同时，恰巧对2月上旬的低点进行了成功的试探。这种巧合，增加了市场完成双重底反转过程的机会。 图4.35 燕麦——1990年7月，日蜡烛图（刺透形态） 图4.36显示了一轮长达数年的下降趋势。该下降趋势始于1984年底的看跌吞没形态，终于1987年中的斩回线形态。尽管在这个底部反转信号出现后，市场并没有形成上冲行情，但是这个信号确实预示着卖方压力的消解。从1984年中起，至1987年中为止，这股卖方力量曾经驱使市场下跌不止。在这个刺透形态之后，市场稳定了一年，然后开始上涨。 图4.36 现货日元汇率，月蜡烛图（刺透形态）]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown1]]></title>
    <url>%2F2021%2F01%2F07%2Fmarkdown1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： \overline{R}]]></content>
  </entry>
  <entry>
    <title><![CDATA[4-我对投资行为及投资者整体修炼的认识]]></title>
    <url>%2F2021%2F01%2F01%2F4-%E6%88%91%E5%AF%B9%E6%8A%95%E8%B5%84%E8%A1%8C%E4%B8%BA%E5%8F%8A%E6%8A%95%E8%B5%84%E8%80%85%E6%95%B4%E4%BD%93%E4%BF%AE%E7%82%BC%E7%9A%84%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 主观与偏见主观一般是指人的意识、精神，客观是指人的意识以外的一切对象。客观是不依赖于主观而独立存在的，主观能动地反映客观，并对客观事物的发展具有促进或阻碍作用。客观的事物可以被测量，主观的事物不可以被测量，但可以被评估。测量是根据事物所固有的某种属性进行比较，但评估只能根据某种先验的价值观进行比较，所以具有不确定性。主观的东西虽然具有不确定性，但这个不确定性是有规律的，是可以研究的。比如菜肴是否可口虽然是主观感受，但有规律可循，因此烹任学校的存在有其意义。 经济学是研究人的经济行为，它的很多基本概念，比如价值、效用、供给、需求，都是既具有客观性又具有主观性，所以都具有不确定性，这就给认识它们的“真实情况”带来极大的困难。 如果一个人对客观事物的认识和“真实情况”经常发生明显的偏差，我们就说这个人“很主观”、“想当然”，反之，如果很少出现偏差，就说这个人能够比较“客观、全面地看问题”，最理想的就是达到了“主观与客观相统一”。不幸的是，“主观与客观相统一”几乎是一个可望不可及的极限状态，是人，就要犯错误，就要发生对客观的认知偏差。我们怎么知道自己的主观和客观已经统一了呢？我们有时自以为已经很客观了，其实根本不知道自己是多么的无知，我们的见解早已被无数的偏见、习惯、权威、利益、权力所扭曲了。 科学历来被认为是最理性的领域，科学家也被认为是看问题最客观的人。然而，科学家和普通人一样无一例外地怀有主观与偏见，所以也一样不能避免犯错误，像牛顿、爱因斯坦等杰出科学家都犯过严重错误。幸而科学是一项集体的事业，即使是最杰出的科学家犯的错误，也可以被其他不如他们的科学家去修正。科学家尚且如此，你我这等凡人更不用说了。 普通人常见的易犯的主观错误有: ①诉诸感情。人非草木，孰能无情，感情往往影响对事物的正确认识，例如有些人上世纪末在郑州绿豆的交易中吃过有争议的交易政策的大亏，到现在仍然对郑商所的交易品种一概不看好。 ②诉诸成见。一个人一旦有某种先成之见，要改变就相当困难。比如直到现在有很多人坚持认为做股票、期货交易就是赌博，是不务正业。 ③诉诸权威。在权威面前丧失了理性、反思能力。我有个朋友，在2006年，仅仅因为罗杰斯说白糖价格还要翻倍，就倾其全力买进，结果亏得一塌糊涂。 ④诉诸权力甚至暴力。 常常与主观相伴的是偏见，偏见一般是指对某人、某物、某事所持有的缺乏充分事实依据的否定态度。错误的认知或某些情绪体验容易形成偏见心理。偏见就意味着错误，是思想认识的大敌，很多人根深蒂固地认为偏见是应当消除并且可以消除的。不幸的是，这同样是一种无法达到的理想状态。偏见无处不在，即使是掌握真理的伟大的人物，也无法完全摆脱偏见的束缚，更不要说我们这些平凡人了。 偏见的几个主要特征是： ①以不充分或不正确的信息来源为基础； ②认知成分是刻板印象； ③有过度类化倾向，忽视个别差异； ④先入为主的或渗透个人感情成分的判断。 只要是人，就难免有偏见，古今中外，概莫能外。有人杀敌无数却惧怕一条毛毛虫，有人坚持不吃无鳞的鱼，有人吃炒鸡蛋却拒绝喝蛋汤，还有的人可以结伴去南极探险，却不能忍受对方吃饭的样子，还有的人刷牙讨厌用牙膏……“偏见真的是无处不在”，NEC（中国）人力资源总监认为，任何公司任何老板都有自己的特色，或者是经验沉淀，而这些特色或经验沉淀带有一定的主观色彩，在某个程度上也是一种偏见。英特尔公司的董事长安迪·葛多夫更是鼓吹“只有偏执狂才能生存”，但问题是如果事情的发展不是如他所料的，则如何区分“正确的偏执”还是“错误的偏见”呢？ 人真是一种充满了不可思议的主观与偏见的动物。 既然对任何事情我们都可能怀有主观与偏见，那么做投资恐怕也不能例外！ 我本人对中国的股市向来没有太多好感，总觉得里面“坑蒙拐骗”的事情太多了，多得令人恶心，只有实在没有期货的长线机会时，我才会去碰一碰股票。谁又能说我的这种体会不是一种偏见呢！反过来说，难道国内期货市场就真的是我一开始所想象的那么美好吗？非也！经过上世纪末连续多年的治理整顿，国内期市几乎没有明目张胆的市场操纵了，但与发达国家的期市相比，仍然是一个畸形的市场。其中最明显的是投资者的结构非常不合理，多空双方的力量严重不平衡，空方往往是财大气粗的有政府背景的现货套保商，而多方经常只是一些投机散户，这导致即使是大部分靠进口的大豆，其走势也经常和外盘发生大的背离。在目前的情况下，期货投资基金是很难发展起来的，多空双方力量的结构性失衡将长期存在，所以一个相对充分竞争的自由市场也只不过是一个遥远的梦罢了。 我曾经因为买宁波联合（600051）赚过一些钱，就对所有的浙江股喜爱有加；我曾经因为在经纬纺机（000666）上三番四次地亏钱，就比较讨厌深圳股；我曾经以为龙头股非上海本地股莫属；我曾经和很多人一样热衷于探讨上证指数最高会涨到哪里，然后坚信在涨到×××点之前是不会下跌的；我曾经以为美国的小麦涨了，中国的小麦也一定会涨上去……唉，我犯过的主观与偏见的错误数不胜数！幸运的是，绝大部分的错误我都改正过来了，我不再仅仅因为我持有多仓就坚持认为价格会上涨，我不再认为政府出台利空政策市场就一定会下跌，我不再认为美国原油涨上海燃油就跌得没有道理。我怎么改正的呢？最关键的一条，一切以走势为准绳，无论基本面、政策、消息、评论、个人看法再怎么来势汹汹，在市场走势面前它们都是不堪一击！如果市场涨了，无论是多大的利空，也都会被强行扭转为利多！反之，如果市场跌了，它们也会被强行解释为利空！当然，直到现在我也不敢说自己就没有主观与偏见了，比如说我喜欢做多胜过做空（这里面有一个原因，大多数下跌是以鸡毛盘跌的形式，这种行情不是我所擅长的），但是，只要牢牢把握住“一切以走势为准绳”，则我可以自信地说，至少在投资领域我不会再犯大的主观性错误。 行为金融学对投资偏差的揭露在2002年开始接触行为金融学之前，由于炒股的关系，我陆续看过一些标准金融学的书。不过我对标准金融学的这一套理论却不感兴趣，股价走势是纯随机性的正态分布？鬼才相信呢！任何认真做过几年股票的人都不会相信。我心里想，噢，这就是经济学教授成天摆弄的东西？怎么跟实际毫不相干呢？学物理出身的我，满脑子都是实验至上的观念，一个理论再漂亮，如果没有实验数据的支持，如果与实践不符合，也只是个花架子呀！直到有一天我看到行为金融学的文章，进而看到这方面的书籍，不禁拍案叫好：“这才是有实验数据支持的理论！这才是有生命力的、有实用价值的理论！” 下面一些内容主要引自赫什·舍夫林的《超越恐惧和贪婪—行为金融学与投资心理诠释》和饶育蕾的《行为金融学》。 行为金融学是行为经济学的一个分支，是关于心理因素如何影响金融行为的研究，它研究人们在投资决策过程中的认知、感情、态度等心理特征，以及由此而引起的市场非有效性。 与标准金融学的基本观点相反，行为金融学的五个基本观点是： ①投资者不是理性人，而是普通的正常人。实证研究表明，投资者不能理性、无偏地反映信息，不能客观、公正、无偏地加工信息。 ②投资者不同质，各个投资者由于个性气质特性不同，使得偏好、行为方式不同，所以对未来的估计也不同。 ③投资者不是风险厌恶型的，而是损失厌恶型的，当面临收益时表现为风险厌恶型，而面临损失时则表现为风险追求，所以投资者不是厌恶风险，而是厌恶损失。 ④投资者的风险态度是不一致的，不是要么保守要么冒险，而是同时兼有保守与冒险两种心理特征，例如既买保险又买股票。 ⑤金融市场不是有效的，资产价格也不是理性的，资产价格不仅仅由资产的内在价值决定，也由投资者的心理、情感因素决定。 从我个人的投资实践来看，这五个观点完全符合市场的实际情况。 行为金融学的研究内容大体上可以分为两大块，一块是关于金融市场的“异象”的研究，也即不符合标准金融学的观点的“异常现象”，实证研究表明，这些异常现象被揭示出来的已经很多，而且还在不断增多；另一大块是正好可以用来解释这些“异象”的，基于调研统计或心理实验所揭示出来的大众认知及投资行为上的偏差，我们对这一块更感兴趣，因为这些偏差与我们自身投资操作上的理念、心态、策略是息息相关的，稍有不慎，我们可能就在重犯这些严重的偏差却浑然不知，结果就是亏了钱还不知道为什么亏。下面我就列举这些偏差，并加上我自己的感悟。 一、确定性效应指的是与某种不确定性的收益相比，人们更愿意选择另一种确定性的收益。典型实验如下： 测试1： 选择A：有0.33的概率收益2500元，0.66的概率收益2400元，0.01概益0元，写成（2500，0.33；2400，0.66；0，0.01） 选择B：以1的概率收益2400元，写成（2400，1） （下同）。 测试2： 选择C：（2500，0.33；0，0.67） 选择D：（2400，0.34；0，0.66）。 结果，72个测试者中，82%的人对测试1选择B，83%的人对测试2选择C。尽管仔细推算起来，选择A比B更有利可图，大多数人面对收益时都是情绪性地选择“落袋为安”，而不愿再冒哪怕一点点风险，只有在C和D那样离确定性较远时，才愿意冒更大风险去寻求更大收益。 我以前曾经在一次大豆上涨行情中，获利200点就急于平仓出局，结果错过了2000点的大行情。我现在已经不会由于过早获利平仓而错过大行情了。 二、反射效应指的是与某种确定性的损失相比，人们更愿意选择另一种不确定性的损失，与确定性效应刚好倒过来，像镜子反射一样。典型实验如下： 测试3： 选择A：（-4000，0.80） 选择B：（-3000，1.0） 测试结果，95个受试者中，92%的人选择了A，而更理智的选择应该是B。这表明，人们面对亏损时宁愿亏得更多也要搏一搏。本来在亏损50点时就应止损的，结果一拖再拖，最后亏了300点，这样的事相信几乎每个投资者都经历过吧？ 确定性效应和反射效应表明，人们在收益范围内表现了风险厌恶，而在损失范围内表现为风险寻求，这些实验揭示了人性深处的根深蒂固的急于获利和不愿止损的弱点！一个人如果不能克服这两个弱点，就无法成为市场中最终获利的那一小部分人。 三、孤立效应指人们面对不同选择时，通常会忽略各个选择共同的部分，而只关注相互区别的部分，但对相互区别部分的不同偏好会导致似是而非的总体选择。 测试4：先给你1000元，再选择A或B。 选择A：（1000，0.5） 选择B：（500，1.0） 测试结果，70个受试者中84%选择B。 测试5：先给你2000元，再选择A或B。 选择C：（-1000，0.5） 选择D：（-500，1.0） 测试结果，68个受试者中69%选择C。仔细推敲一下，测试4与测试5其实是完全一样的，也即A=C，B=D，可是人们居然做出了完全相反的选择！可见，当一件事由若干步骤、若干部分来组成时，人们往往没有全局观念，而只是关注于眼前这一步的“落袋为安”和“不要亏损”。 四、偏好反转指人们在决策与偏好方面的选择与定价不一致的现象。下面是一个著名的实验： 测试6： 选择A：（4，35/36；-1，1/36） 选择В：（16，11/36；-1.5，25/36） 测试结果，绝大多数人选择A，即较安全的方案。但是，如果把选择A和选择B分别做成彩票出售，则哪种彩票应卖得贵些？出乎意料，被测试者大多数认为彩票B应卖得贵些。 这就怪了！按我的理解，在仅仅作选择时，人们宁愿收益小一点也要寻求更安全的A，这时他们的身份相当于买方，但当被要求定价时，他们会从卖方的角度考虑，认为卖方最高会亏16元，因此彩票要卖得贵一点才能弥补，这就是说他们的身份已经转变为卖方了！我认为偏好反转实际上反映了人类内心深处的一种根深蒂固的贪婪心理，面对同一项资产，即使双方掌握的信息完全相同，买卖双方的估价也会有明显差距，卖方仅仅由于贪婪就会不自觉地定价高些，买方也会仅仅由于贪婪而毫无根据地要求定价低些。在这种心理的支配下，很多人仅仅因为持有某种股票就无端端地认为该种股票“应该值这个价”。 五、直觉推断偏差又叫启发式偏差，或拇指原则，指的是人们并没有经过严密的推断，仅仅根据直觉或借助经验就作决策，从而产生的偏差，主要有代表性偏差、易得性偏差、锚定-调整偏差三种。这些偏差主要是因为人们缺乏可靠的知识和信息，或者没有时间，或者信息过多，或者问题不重要，才会产生。 代表性偏差，指人们在不确定条件下，会关注一个事物与另一个事物的相似之处，从而作出相似结论（之所以出现偏差是因为这种相似性不一定是普遍规律）。例如，因为日本和韩国在股指期货上市后股市都下跌一段时间，现在（2007年上半年）媒体也纷纷鼓吹HS300股指期货上市后国内股市也会下跌，其实得出这样的结论是依据不足的（从实战的角度来看，没有必要预先推测期指上市对股市是利多还是利空，到时候看走势，涨了就是利多，跌了就是利空，见机行事即可）。又例如一个股市新手有一次在KDJ的J=0时买入股票，第二天果然涨停，从此他认为J=0“很灵”，至少在一段时间内他会偏好买入J=0的股票。翻翻我在2000年之前的投资记录，里面充斥着代表性偏差。 易得性偏差，是指人们根据记忆中哪个事情最先想出来就依据它下结论。例如，对一个问题“人走在街上被车撞的机会高不高”，从来没见过车祸的人就会说机会不高，刚刚有一个熟人遇到了车祸的人就很坚定地说机会实在很高啊！再问股民一个问题，“股价放量下跌是主力洗盘还是出货”，刚刚经历过庄家对敲洗盘的人说是洗盘，而刚刚经历过股价真的放量下跌的人则会说肯定是主力出货。人们往往不去追究这些例子是否具有统计上的可靠性。投资新手由于在不断地寻找新方法，这种灵机一动的尝试也很多。 锚定-调整性偏差，指人们以最先得到的信息为参照物，来调整对整个事件的评估。最著名的一个实验是，要求一组学生在5秒之内估算8x7x6x5x4x3x2x1的值，而另一组学生估算1x2x3x4x5x6x7x8的值，结果第一组估计的平均值为2250，第二组估计的平均值为512，差别很大，并且远小于正确答案40320，这说明人们对最先得到的信息赋予过高的权重，而后对这个权重的调整又不充分。我认为锚定-调整偏差在投资领域非常普遍，人们总是以股票、期货的历史数据作为参照物，对它们赋予过高的权重，然后判断目前的价格是“太高了”，和“太低了”，从而产生非常普遍的“恐高症”和“恐低症”，眼睁睁地错过大行情。其实我们要问一问，老拿历史数据作基准有什么可靠依据？为什么不能拿未来的数据作基准？！ 六、框定偏差指人们的决策依赖于问题的形式，也即本质相同的问题仅仅因为形式不同也会导致人们做出不同的决策。一个经典的实验如下： 一位将军打了败仗，如果不撤退，则600人将被歼灭；如果走第一条路线撤退， 200名士兵可得救；如果走第二条路线，有1/3的可能600名士兵全部得救，但有2/3的可能600人都被歼灭。那么将军该选哪条路线？大多数受试者认为该走第一条路线，原因是保存能保存的生命，比冒险造成更大的损失划算。但若把问题换个说法，如果走第一条路，400名士兵将丧命；如果走第二条路，有1/3的可能全部得救，有2/3的可能600人全部被歼。这一次大多数受试者认为该走第二条路线，理由是走第一条路肯定死400人，走第二条路还有1/3可能全部得救。同样一个问题，仅仅换了一种描述方式，人们就得出相反的结论，这真是让人惊讶！ 人们往往偏好某一种类型的使心理上感到更加舒服的框定，这种现象称为“乐观编辑”。例如，如果某投资者第一笔交易赚了1000元，第二笔交易赚了600元，他会感觉很得意，但若第二笔交易亏了600元，他还不会感到痛苦，他会把第二笔的亏损和第一笔的盈利合并，认为只是少赚了点，终归还是盈利400元，心里还是美滋滋的。但若第一笔交易亏了1000元，则对第二笔交易又亏了600元感到加倍的痛苦。这种心理偏差对心态影响非常坏，它导致人们经常在大赚一笔后又很快回吐大部分利润都不感到心疼，这样账户上的资金始终不能增长，又导致人们在连亏几笔后又因过分痛苦而自暴自弃。 七、过度自信偏差即人们往往高估自己的能力而低估运气所起的作用。 例如，大部分的司机认为自己的驾驶水平高于平均水平。又如，我的朋友王毅在培训投资者时，往往先讲在期货交易中只有少数人赚钱的事实，接着请那些认为自己最终能赚钱的人举手，结果总是大部分人都举手。再如，我经过了好几年的磨练才认识到做投资至少要5-8年才能谈得上稳定盈利，可是绝大部分新手不认可这一点，他们总是低估这一行的难度，总是以为只需几个月他们就能持续盈利。 过度自信往往与“事后诸葛亮”偏差有关，在观察历史数据时，人们往往以为他们能把握住那些走势，从而产生盲目的自信，这种偏差在投资者中极其普遍。在我开发了那个杜绝引用未来数据的培训软件后，通过给定一组历史数据，受训者据以做出交易或观望的决策后，再按一下空格键，就出来一个新的数据，由于下一个数据是不知道的，这样就避免了“事后诸葛亮”的假象。在这种近似实战的环境下，所有虚妄的自信被它击得粉碎，某些自吹的高手在这个软件面前也露出了其实是新手的真面目。 过度自信也是过度交易的一个根源。 八、反应过度偏差指投资者对最近的价格变化赋予过高的权重，对最新的消息过于重视而忽视老的消息，这样他们在价格上升时变得过度乐观，而价格下跌时过度悲观。 一般来说，每天盯盘的人容易过度反应，极可能因为过于恐慌而卖出，或者头脑发热而买入，所以，和市场保持一定距离是很有必要的。在研判行情时，反应过度偏差在投资者当中是非常普遍的一种失误。 九、心理账户偏差指人们在心理上对不同来源、用途等性质的资金进行分类，进而赋予不同的使用限制。 例如，人们会同时买保险和彩票这两种风险收益比相反的资产；又如很多人宁可仅靠股利过简朴日子，也不愿卖出部分升值的股票来改善生活，因为他们觉得股票（尤其是蓝筹股）是永久资产，不卖的话忍一忍也能过日子，可是卖了股票把钱花掉了，以后就没了。心理账户对很多人的危害是，他们在日常生活中省吃俭用凑钱来投资，但在交易中大把地亏钱却不感到心疼！我就曾被这种心理偏差危害了好多年。 十、证实偏差说的是人们一旦有了一种设想后，在寻找证据时总是过度重视那些有利的证据，而忽视那些不利的证据，存在一种明显的证实而不是证伪的倾向。 这种偏差在投资中实在是太常见了！如果单凭反复观察历史行情走势而总结出一套操作策略，人们总是以为这套策略真是和历史符合得太美妙了，其实这样的设想只要用历史数据做机器测试或者人工测试，就会发现十有八九是价值不大的！原因出在哪里?出在我们的眼睛。在没有杜绝引用未来数据的情况下，眼睛会欺骗我们，我们只看见那些符合设想的情形，而对那些不符合的情形视而不见！相信每一个做过机械交易系统的人对此都有深刻体会。所以说，对任何设想都进行历史数据的机器测试或人工测试，是绝对有必要的。 十一、赌徒谬误指对那些具有确定概率的事件，人们错误地受到当前结果及历史结果的影响从而作出错误的判断。例如抛硬币，若连续8次都是正面，那么第9次最可能出现什么?大多数人认为应该是反面，因为太久没出现反面了，其实这是错误的，第9次出现正反两面的概率仍然是各50%赌徒谬误也是非常流行的，大多数人总认为“涨了那么多，是该跌一跌了”，甚至连美国的顶级分析师也逃不出这种偏差。 十二、羊群效应指投资者在决策上缺乏独立性，从众、随大流，依赖于他人或舆论来决策。 这样的人运气好时也可以赚一把，但长期做下去终归是只有亏的份。不幸的是，这样的人实在太多了。 十三、反馈效应说的是由于各种投资偏差，最终导致资产的定价偏差，而这种偏差又反过来影响投资者对这种资产的认识与判断。‘这种反馈效应，也即索罗斯所说的“反身性”，在价格上涨时会导致泡沫，泡沫越吹越大，直至突然破裂。比如1991年时的日本股市， 2000年时的美国Nasdaq市场。这个时候理智的投资者应该及时减仓，甚至清仓离场。 限于篇幅，还有些不那么重要的偏差就不讲了，有兴趣的读者请阅读相关的专著。 投资者整体修炼的五个方面前面谈了我们皆是充满了主观与偏见的几人，又谈了行为金融学揭露出来的令人触目惊心的投资偏差，在第二章还谈到了成功的投资不仅仅要求相对的、局部的优势，而且要求全局的、绝对的人性修炼上的优势。这不是我危言耸听，也不是我悲观失望，而是活生生的残酷的现实，历史一再证明投资是世界上难度最大的行业之一。 投资者要想在这场九死一生的生死游戏中长期生存，进而长期获利，需要进行哪些方面修炼?我认为需要五个方面的修炼。 这五个方面是： ①对市场规律的正确理解； ②对交易策略的正确把握； ③对交易经验的足够积累； ④对交易品性的充分培养； ⑤对理念和心态的长期修炼。 难就难在这五个方面是错综复杂地缠绕在一起的，没有很多年的磨练无法明显地区分它们。 对市场规律的正确理解，是投资成功的第一块基石。前面已经专门谈了我对金融市场运行规律的认识，讲了市场的混沌特性，在充分利用市场残留的少量确定性规律的同时要小心翼翼地注意随机性的干扰，所以仓位千万不可太重；还讲了金融市场的空间结构、时间结构，即行情框架理论，针对不同的品种、不同性质的行情走势，采取不同的交易对策。当然，这些观点只是我的一家之言，但不论投资者的个人见解如何，有一点是共同的，即我们自己的见解要尽可能地符合市场实际。尽管市场走势并不是一个纯客观的东西，但仍然有它自身的规律，如果我们的见解与市场实际偏差太远，则我们就陷入主观偏见之中了，最终得付出惨重的代价。为了修正对市场规律的不正确理解，仅仅反复观察历史走势，是远远不够的，更有效的是对历史数据进行严格测试及禁止引用未来数据的训练（即人工测试）。 对交易策略的正确把握，是投资成功的第二块基石。对一个交易模型，无论是纯客观的，纯主观的，还是半客观、半主观的，最重要的评价指标是算术期望和几何期望，只有对短线交易，追求高胜率才有意义。在良好的算术期望和几何期望的基础上，我们再寻求一个合适的但最重要的资金管理模式，最终账户的收益评价体现为年复利率。对于长线交易，我们只需做到“迅速止损，放足盈利，试探加码，轻仓长线”，就能够确保最终盈利，就算仓位不是最佳的，甚至是次次佳的，仍然能够保持长期安全获利。如果能得到正确的引导，对交易策略的正确把握并不是太难，不幸的是，一味追求高胜率似乎是人的天性，市面上的大多数书籍也是为了迎合读者的这一心理需求而写，故而谬误流传甚广就不足为怪了。 对交易经验的足够积累，是投资成功的第三块基石。但是，交易经验具有不可替代性。投资新手往往有这样一种体会：刚看了一本好书，或者听了一场投资报告，热血沸腾，以为找到了成功的秘诀，谁知第二天交易起来还是老样子，该亏的还是照样亏。这是为什么?我认为有两方面的原因，首先是人的天性并不适合做投资，而要扭转天性不是一年半载的事，其次是交易经验的不可替代性， 5-8年的磨练期是很难躲得过去的。写书的人或做投资报告的人是讲他的操作理念和交易经验，并且把这些理念和经验形成习惯落实到交易中，而新手由于临场实践经验不够，就很难把它们落实。背景知识、理论知识都可以通过看书来较快地学习，唯独这个交易经验非得亲身实践不可。投资者往往只有经历了大牛市、大熊市、大牛皮市以后，才能积累起大体足够的经验，而这一般需要5-8年的时间！这种交易经验的不可跳跃性也是横在“龙门”面前的一道极高的门槛。我的经验证明，杜绝引用未来数据的训练可以在相当程度上缩短这个积累经验的时间。另外就是，什么样的交易经历就会导致什么样的交易风格，由于交易经历和个人性格难以模仿，这种交易风格具有难以模仿性，所以说交易经验也就很难模仿了。因此，交易是个性化行为，而个性化更多地体现在交易经验上。交易经验虽然具有不可跳跃性和不可模仿性，但却是将正确的理念、心态、策略和账户盈利联系起来的纽带，是实现盈利的临门一脚，是在关键时刻最可依赖的东西。 对交易品性的充分培养，是投资成功的第四块基石。交易品性指交易习惯和行事作风，不单指行为上的习惯，还指态度上的习惯。没有什么比习惯更强大的了，长期的习惯就形成个性。重复性的行为形成习惯，习惯形成性格，性格决定命运。“把成功的操作重复一干次”，说的就是要形成成功的习惯。当投资者经历了多年的磨练后，逐渐积累了足够多的经验，其中的很多经验在重复多次后，形成习惯沉淀下来，不但具体交易上有明显的惯性，思考问题的方式及处理一切问题的行事作风也有明显惯性，所以统称交易品性，或曰个人风格。‘’有的人做了十几年投资，却始终赚不到钱，原因是多方面的，除了思维方式不够客观务实、不愿经常反省自身外，没有形成稳定的、正确的交易品性也是一个原因。有的投资者具有很多经验，可是这些经验是零碎的、分散的，区分不出哪些是成功的经验，哪些是失败的经验，成功的经验也没有形成习惯去反复执行。 交易品性不仅是指具体的交易习惯，还指交易以外的个人行事作风。成功的投资者一般勤奋、严谨和自律，而失败的投资者则往往懒惰、轻率和无纪律。许多人可以花很多时间忙忙碌碌地买进卖出，却没有时间做一个交易记录，也懒得写下交易的理由，更加谈不上总结了，而成功的投资者则事无巨细先记下来再说，然后经常进行总结和反省。许多人在日常生活中为了买一台电器而再三思虑，或者为了买一套衣服而逛好几个店，但在交易中对动不动就亏损成千上万元的买卖却是由于突发奇想，或灵机一动，或心头一热，总之是一拍脑袋就下单，完全不考虑这些交易背后有多少条理由，是否有足够的统计依据。这种轻率的、无纪律的交易在成功的投资者身上几乎绝迹，他们总是力数交易背后有多少条理由在支撑，这些理由有多大的统计依据，何时买卖及仓位多少总是按计划及纪律来进行，在没有出现交易机会时他们总是能够耐心等候。在积累交易经验的同时，对那些成功的经验有意识地总结、重复，进而形成正确的习惯，再加上勤奋、严谨、自律和自省，终会慢慢培养出良好的交易品性。这是走向最后成功的重要的一方面，没有人能随随便便成功。 对投资理念和心态的长期修炼，是投资成功的第五块也是最重要的一块基石。所谓投资理念，是指投资者对期货交易在哲学层面上的全面的、综合的理解，也即对前面所说的市场运行规律、交易策略、交易经验、交易品性等诸方面在融会贯通后，再加上主动修正认知及投资行为上的偏差，最终全面升华到哲学层面上，形成一套信念、一套思维方式，成为一切投资活动的原则性指南。投资者在这一套原则性指南的指引下，继续总结个人交易历程中积累下来的各种分析手段、操作技术和交易经验等，最终形成适合于个人性格的一整套或纯客观或兼顾主客观的交易规则，这套规则就是他整个投资事业安身立命的基础。 投资理念是思想性、原则性的东西，并不是某种具体的操作技术。例如“不要企图抄底摸顶”就是一个理念，但怎样才算不是抄底、不是摸顶，具体做法五花八门，但只要不违背这个原则，则最终结果大同小异。又如“迅速止损，放足盈利”也是一个理念，但到什么价位才算迅速止损，又到什么价位才算放足盈利，也是见仁见智，然而只要遵守这个原则，则最终结果也是殊途同归。由于投资理念涉及到交易的方方面面，所以并不能用一句话加以概括，而是分散为许许多多简短的语句。兹举若干例：赢家并不是要赢得所有交易；让止损成为一种习惯；必须主动放弃某些交易；只抓大级别机会；采取最保守的交易方式；买最强势的品种，卖最弱势的品种；强调风险收益比：重势不重价：不要试图抄底摸顶；顺势而为；不要逆势操作；迅速止损，放足盈利，试探加码，轻仓长线：保留盈利仓位，出清亏损仓位；不要让盈利仓位变成亏损仓位；无浮动盈利不能加码：交易是个性化行为；重要的不是基本面，而是市场对基本面的反应；盯住止损，不考虑利润；亏损后的首要任务不是扳平，而是重建信心。 期货投资从理念上来说，并没有什么新观点，因为“投机就像山脉一样古老”，“华尔街没有新事物” （杰西·里佛默）。如果你不重视这些华尔街上的前辈用鲜血凝成的信条，那么你就得用自己的鲜血去重新发现它们，甚至你流了血也可能发现不了它们，最终只能黯然离场。 由于人的天性并不适合做交易，为了做好交易就得把人的天性整个扭转过来，但这谈何容易！所谓“江山易改，本性难移”，所以说这是一个根深蒂固的慢性病，为了治好此病，除了天天吃药，吃上几年，毫无他法！所以我们要挑选一些理念性的好书作为枕边书，每天早晚看上几页，也即吃上几片药，吃上几个月初见成效，吃上几年彻底根治！ 投资新手往往轻视理念，认为理念是些虚无飘渺的、缺乏操作性的空洞理论。对这种情况可以采用对比排除法，也即天天看上几页，然后对比自己最近操盘有无违反这些理念的地方。其实只要认真思考，一些人很快就会发现，他们几乎天天在反反复复地违反这些正确的理念！ 投资心态，即交易时的心理状态，是决定正确的操作能否实施的关键因素。其实正确的投资心态依赖于正确的投资理念，当一个人已经把正确的投资理念修炼到深入骨髓的时候，心态自然就自信从容、恬淡平和。关于心态，我认为有一个概念很重要，即“目标感觉”，就是说要做出成功的感觉来，就像乒乓球冠军很强调“打出感觉来，打出状态来”一样，我们要刻意寻找、培养这种成功交易的感觉（一般是类比于某一件我们做得很好的不涉及金钱的事情的那种感觉），然后把这种感觉作为常规状态固定下来，每次交易前先进入这种状态。比如我做长线的稳定的目标感觉已经达到了，这就是类似于喝一杯淡淡的绿茶时那种轻松的、从容的愉悦感。 有一种观点在网络上颇为流行，就是认为交易要“快、准、狠”，我对此大惑不解。这三个字让人感觉到紧张，而我认为成功的交易，不论长短线，定是让人感觉到放松的、从容的，就像射箭一样，过于紧张肯定不行。再快的行情，在投资者的眼中也应是从容不迫的，着急什么！也不需要刻意追求太准，看不准也只有少量损失而已，更加不需要太狠，太狠了就不轻松、不安祥了。我从自己几年的实战中体会到影响投资的这几个因素，依重要程度依次为理念、心态、策略、分析。也就是说导致我们大赚或大亏的是理念、心态和策略；技术层面的东西，比如行情分析、技术指标，顶多只能算第四重要。技术层面的东西，作为知识，有两年时间就可以掌握得差不多了，然而理念和心态的整体修炼，没有5-8年的干锤百炼是不行的。 投资者整体修炼的八个阶段人们常说，投资的魅力在于，这是一个创造奇迹与制造梦想的地方，这是一个可以充分发挥自己自由意志的地方。人们相信，凭着智慧、勇气、热忱和汗水可以跻身于成功者的行列。但事实上，在通往成功的道路中等待人们更多的是迷惘、恐惧、痛苦和思索，不懈的追求和努力换来的常常是挫折和泪水。所有投资者都在无时无刻地努力跻身市场上的高手行列，可是金融市场和经济原理是一样的，无论在长期交易中还是短期交易中，输家总是大多数，赢家总是极少数。投资者依水平高低从上至下以金字塔排列，塔尖上的极少数人掌握着最大的赢利，底下的人们都在想摆脱自己所在的层位，塔尖永远都是他们的方向，但塔尖上的人也是经过重重考验，不断超越自我才站到“会当凌绝顶”的地方。 下围棋的人都知道，围棋段位的高低反映出棋手的水平高低，也反映出棋手的棋艺修炼的阶段。金融交易没有段位制，但投资者的交易水平却有着高低之分，投资者的交易水平也处于不同的修炼阶段。不同阶段的投资者，其所思所想，其所关心的问题，是差得非常远的，通常和他聊上半个钟头就能大体上判断出他的交易水平。下面我就谈谈从一个普通投资者成为投资高手必须经历的八个阶段。 第一阶段 就是新手阶段。由于听了朋友介绍，或者经纪人鼓吹，以为期货市场是容易暴富的地方，或者是“高风险高收益”的地方，又或者从媒体上看到某某某“从5万到1亿”的神话故事，于是开了个账户，跃跃欲试。新手对期货市场也有个大概了解，对日常交易操作流程也很清楚，但就是对如何交易才能赚钱一无所知，六神无主；每天看评论，根据评论或消息买卖，或者根据熟人推荐下单，或者纯粹凭感觉下单；仓位往往很重，动不动就半仓、满仓；也许会听从经纪人的忠告，留隔夜仓是万万不可的，于是只做日内短线交易，买卖极其频繁，喜欢追涨杀跌；偶然也能持仓几天，如果看对了方向，有了账面盈利就急不可耐地平仓出来，马上对这个给他带来盈利的品种产生了厌恶，急于在另一个品种上开仓。在新手的眼里，整个期货市场和交易真相是漆黑一团，他们看不到任何空间结构和时间结构，多数情况下是乱打乱撞。 我估计大约90%的新开户者还没有走出第一阶段就爆仓离开期市了，要不然期货公司怎么总是新面孔多。这批爆仓者离开后，逢人便讲期货市场如何如何黑暗，期货行业的社会形象不佳，除了媒体的宣传外，这批人功劳也不小。 第二阶段 就是疯狂学习各种投资理论的阶段。少数投资者在经历一两年毫无章法的交易并遭受巨亏之后，开始反思，进而认识到自己理论知识的不足，开始疯狂地学习。K线理论、技术指标、波浪理论、江恩理论、跟庄技巧、价值理论、成长理论，什么都学，逮到哪个就先学哪个，而且以为越高深的理论越有价值，结果就是什么都了解一点，但没有一样学到其精髓。然而感觉还是有进步，起码分析师写的文章看得懂了，能够在别人面前讲起来术语满口、头头是道了，甚至能写分析文章了！然而对这些理论根本不懂如何应用到具体操作上，买卖还是那么随意，什么样的机会都想抓，长线做，短线也做，投机做，套利也要做，大豆做，铜也要做，账户里的钱还是稳定地减少。 第三阶段 就是沉迷于技术指标的阶段。很多人在各种理论里转了一圈回来后，觉得还是指标有吸引力，最好什么样的理论、什么样的设想都能编成一个公式，进而编成一个指标在图上画出来。于是开始日夜研究各种指标，如何编指标，如何修改参数，如何优化，如何考察指标“准不准”。虽然对整个市场及交易还是感到一片迷惘，但好歹精神上有个追求，日子过得还充实。 这个阶段在交易上还是和第二阶段一样，这几天使用这个指标，下个月又改用另一个指标，如此反反复复，因为没有一个指标会让他满意的，结果还是亏多赚少。 第四阶段 就是醉心于开发高胜率的交易系统的阶段。从考察指标“准不准”，很自然地进步到要开发一套交易系统。但对高胜率的追求就像病毒一样通过网络到处传染，各财经网站、各论坛到处都有加密的公式出售，其胜率之高让人怦然心动。怎么搞的，别人能找到胜率那么高的公式，我怎么老找不到呢？真是令人泄气，我太笨了，就是找不到，干脆花钱买一个吧！于是花几千元买来几条著名的公式，谁知运行起来还是不断地亏钱。怎么回事啊？搞不明白。另外有很多人虽然不研究机械交易系统，但也在寻找高胜率的交易方法。有相当多的人停留在这一阶段而不能进步，交易结果没有任何改善。 第五阶段 开始正确理解对交易系统的评价，开始不稳定地盈利。在痛苦和迷惘中过了两三年之后，有一天忽然看到某一篇文章或一本书，里面讲了追求高胜率的误区，恍然大悟，从此不再追求高胜率，转而追求高风险收益率，进而认可“迅速止损，放足盈利”这一理念。在实践中开始重视中长线，有时候做对了猛赚一笔，可是其他时候经常时不时大亏一笔，所获利润差不多回吐精光，甚至还要倒贴，账户几起几落。投资者虽然信心有所增强，但仍然感到十分迷惘，总是在不断地反思交易理念及交易方法，希望找出解决问题的方案，但不久又有相似的问题，以新的面孔出现，于是再反思，再总结，再立志，陷入反反复复的循环之中，让人极度痛苦，甚至会对交易产生厌倦的心理。一些人停留在这个阶段，很难再取得进步。 第六阶段 开始建立一套个人的完整的交易规则（交易系统），又经过了一两年的磨练，通过不断地分析自己赚钱和亏钱的情况，不断地总结经验教训，尤其注意大亏的教训，终于初步建立了一套交易规则。开始懂得了交易和分析的区别，不再追求预测而强调跟踪，也开始能辨别哪些文章是好文章，哪些文章无甚价值。开始慢慢看清楚市场的空间结构和时间结构，看清楚了交易的真相，多年来遮盖在眼前的那层薄雾终于消退了，迷惘的问题已经很少了，自信心也建立起来了。 实际交易方面，大行情来了一般不会错过，虽然操作细节上仍有不少失误，但在有行情时总不会犯大的错误，所以一年至少能抓到一两波中级以上行情。然而，此阶段难就难在没有行情时容易犯错误。账户上的资金一般不容易大亏，更加不太可能爆仓，然而在没有行情时的错误操作导致利润大幅回吐的情况仍时有发生。虽然几乎不再感到迷惘，却还是经常过分激昂或过分沮丧，情绪不稳，此时往往发生中等幅度的亏损。这时，投资者面临的问题已经不再是认识市场运行规律和交易策略，而是其自身修养的问题，如何克服个人性格上的弱点就成了头等大事。能够修炼到这一阶段的人已经很少了，然而，如果仅仅停留在这一阶段，则账户上的资金还是难以稳步增长。 第七阶段 主要精力开始放到理念与心态的整体修炼上。经常总结、反思自己的心理状态，反复思考自己的优势、劣势分别在哪里，自己性格上的优点和缺点分别是什么，如何扬长避短，什么样的措施才具有“临床”效果，自律和约束成了主要的话题。总之，这个时候是一只眼睛盯住交易，另一只眼睛盯住自己。一个人总是要花很长时间才能克服性格上的缺点，甚至有些缺点可能永远克服不了，实在克服不了就必须想办法回避，不给它发作的机会。而要想克服或回避缺点，就必须抵制得住各种诱惑，界定好自己的能力范围，安心耕种自己所擅长的那一亩三分地，这就完全靠自律和约束了。这也是一个反反复复的过程，要想初见成效，也得好几年。体现在交易上，就是一般不会发生亏损了，但业绩却是起起落落不稳定，直到多年后，当严谨和自律渗进他的血液中的时候，他的操作业绩才会稳步增长。 第八阶段 整个人的思想修养已经达到大师级的水准。不仅仅对交易，而是对整个人生、事业、家庭、社会的所有问题都已经深入到哲学的高度，对人世间的一切问题都已经看得很开，修身养性已经达到极高的造诣，自律与约束对他来说已经显得多余，因为他的个性中已经几乎没有贪婪、恐惧、懒散、随意这些不良因素了。他已经完全与市场融为一体，与市场同呼吸共起舞，他不需要刻意去倾听就已经感受到市场跳动的脉搏了。在交易上，他早已管理着庞大的资金，并且每年有稳定的回报。达到这种阶段需要多久？我不知道，也许是几十年吧，对大多数人来说也许一辈子也达不到这个阶段。 我自己认为目前我处在刚刚跨进第七阶段的水平，还有漫长的路要走。不过我做期货才几年，阅历还是不够的，所以让我来写这些修炼阶段未免显得苍白。等以后我有更多的阅历和感悟，再来重写这一节。 我自己逐步形成的一整套投资理念框架下面是我自己逐步形成的一整套投资理念框架，目前还在使用中，它是我整个期货事业的基础。我公开它是因为觉得没有保密的必要，对于某些性格和我相近的读者可能很有帮助。 从我的亲身经历和我接触的赢家、输家，以及我广泛阅读的中外期货投资书籍来看，所有的赢家都有共同的特点，而所有的输家也都犯类似的错误，赢都赢在正确的理念和心态，输也都输在错误的理念和心态，至于具体的看盘和操作细节，其实并不是关键。下面是我归纳的最主要的几条（老生常谈，并无秘密）： (1)遵守“迅速止损，放足盈利”这一首要原则。由于我刚开始做期货就很注意止损，所以我那点本金够我亏了3年多（从而换来了宝贵的经验，一直亏到2005年春节终于开始盈利了），而我之所以连续亏了3年多，就是一直很恐惧，做对了也赶紧平仓，不敢持仓做完一波行情。2005年开始我终于做到了每一波行情都持仓到行情的尽头！单次的止损不算错误，只有连续3-4次止损才表明有什么地方出了问题，所以一定要愉快地止损！ (2)不过度交易，不做日内交易。客观上讲，能做好日内交易的人万中取一，可还是有那么多人不愿做长线，还有很多人企图长短线兼顾。我现在认识到市场机会其实是很稀缺的，一个品种一年也就2-3次入市机会，所以我做长线，只关注5-6个品种，一年下来交易的次数很少，没有行情时不开仓，一旦开仓对了就持仓到行情结束。 (3)刚开始试探开仓时的仓位为，若止损的话，损失不超过总资金的5%-8%，有了盈利才逐步加码。亏损时决不加码。开仓要顺势而为，决不逆势开仓，决不企图抄底摸顶。 (4)不每天盯盘，不过度关注，与市场保持合适的距离。行情的稀缺性和持续性是客观的，并不因为你看得更多、做得更多它就相应增多。 (5)强调自主精神，独立思考，不依靠别人。不和别人谈行情，也少看分析师的文章，偶然看也只是注意他提到了什么因素，而不重视他的结论。 (6)思维方式要客观，当走出明显的单边行情时，即使原来一直持相反看法，也要及时扭转过来，承认客观事实（即使暂时不知道行情的背后原因），并且要及时介入，即牢牢把握住以走势为核心。思维方式以跟踪而不是预测为主，当没有明显趋势时不主观猜测何时会有行情，当有明显趋势时不主观猜测何时趋势会结束（从来没有人能预知未来），当基本面和技术面矛盾时，以技术面为主，因为背后可能有我们暂时未知的其他原因在起作用，对重大政策、数据、事件不事先主观认为是利多、利空，而是以市场的反应来判断其是利多还是利空。客观地讲，任何时候多空两方面的基本面因素是平衡的，我们只需要依据技术面走势判断即可。但是，很多时候，出于恐惧或贪婪，总是忽视市场走势这个最客观的因素，而主观地以某一基本面因素作为貌似合理的借口来安慰自己，而导致眼睁睁地看着一波行情走过来又走过去，心态烦躁焦虑至极，这是一个一般人一而再、再而三地犯的老毛病！ (7)看问题要强调从大势着眼，把握全局，看盘、交易要用周线、月线，少用日线。不纠缠于细节。一波真正值得参与的中级、超级、鸡毛行情往往至少持续2个月。当整体条件满足时（尽管这些背后的条件我们可能一下子还不能完全领会，但我们只需要牢牢把握住走势即可），该是牛市就是牛市，该是熊市就是熊市，这个牛市或熊市一般要持续至少2个月左右，这是一个市场自身的运动规律，此过程并不因为某一个短期的个别事件（比如小政策、小数据、个别市场主力的进出、某突发事件）而突然扭转。所以我们不必太在意这些短期因素，我们只需要看周线、月线，看总体大趋势、做长线交易即可。从时间尺度看，天体运行的尺度为百万年，电子的尺度为纳秒，人的尺度为时、分、秒，而商品期货的尺度为月、旬！以月为单位！一振荡就是几个月，而一旦形成趋势，又是两三个月。因此，如果以日、时、分、秒这些远小于期货的时间尺度为交易时间，那一定是在和随机性做很难赢的搏斗！正因为期货市场的运动尺度远远大于人的运动尺度，耐心和纪律就成了投资中最重要的心理素质。反过来，当我们挑选一个长线交易的时间尺度时，也必须以能滤除绝大部分的突发事件、一般的小政策、小数据、随机事件（所举的这几类因素多数情况下并不能改变趋势，顶多只影响一两天走势而已）的影响为最小单位。趋势在其运行的时间尺度上，在绝大多数基本面因素尚未明朗前就能够提前对其进行正确解读，也即趋势本身会对基本面的预期提前做出反应，这种反应大多数是对的，也即仅有极少数的基本面因素会导致趋势突然改变！ (8)只专注于交易一组样本容量大小合适的投资品种。这个问题在做股票时尤为突出，因为股市的样本容量太大，又相互影响，故从全局上把握的难度很大，况且个股的走势还会受人为因素的影响，如果什么股票都想沾，一买一大把，最后结果往往很差。 (9)不混淆交易员和分析师的身份区别。作为交易员，应该把精力放在入市机会的多少、长线短线的利弊、仓位控制策略、自己性格对什么敏感对什么迟钝、如何克服浮躁、恐惧、愤怒心理、如何避免一再犯同样的错误等只有交易员才会碰到的重大问题上，而这些属于理念、心态的问题，需要花很长时间来修炼。千万不要把主要精力用在去发展一套行情研判理论上！或者把主要精力用于学习、研究这样的理论！行情研判理论固然重要，但却不是最关键的因素！在正确的理念和心态下，具体用什么理论、方法看盘和交易，并无本质上的区别，关键是你自己要清楚你这个方法的长处和短处，并主动回避短处，所以要用开放的态度看待这些理论。 (10)维护投资体系的稳定性和一致性（即对所有的投资品种都按同样的理念、心态、策略、方法去做），是至高无上的原则，坚决杜绝超越投资体系以外的一切操作！为什么有的人可以十年磨一剑，而有的人十年却磨不出一把菜刀？原因就是他今天用一把镰刀磨，明天又改用一根废铁磨，后天又改用铝合金磨。所以一定要长期坚守符合自己性格的一整套投资理念、心态、策略、方法，不断深化，直到熟能生巧。千万不可今天试试这个，明天试试那个，各不统一。“人无恒财不富”，在投资中，“恒财”即指稳定和一致的投资体系。有所为有所不为，有所舍才能有所得，有所放弃才能有所收获，坚持守株待免，而不是四面出击。 (11)人的天性并不适合做投资，要改变天性谈何容易！这就是很多人做了很久却仍然赚不到钱的原因！我做网站的经历使我发现了一个一般人不可能发现的方法：要改变天性就得长期“吃药”，像治慢性病那样，药方就是经常看理念性的文章。这些文章偶然看几次毫无效果，但长年累月看下去效果奇佳！ (12)我觉得自己终于找回了多年前的那种自信的感觉！那种终于也有了自己的“势力范围”的自信、踏实、胸有成竹的感觉！我有什么东西拿得出手？我拿什么东西来安身立命？我有！这就是我的一整套投资体系！我就靠它安身立命！它就是我的“势力范围”，我的地盘我做主！ 且看高手如是说写完上面几节，似乎还觉得想再说点什么，总有一种意犹未尽的感觉。刚好手头有一篇堪称顶级的奇文，可以代我再过一把瘾！这是一篇在网络上广为传颂的、思想极其深刻、完整的经典文章，是由一个网名叫suhui的期货高手写的，不知最早发表在哪个论坛。文章实在写得太精彩，我忍不住在这里引用一下，以解心头之痒！在这里我向这位高手致以敬意！同时希望有一天可以和他煮酒论英雄，畅谈天下投资，共探交易真谛！ 质疑期市高风险论曾经当我们怀着强烈的自信心，怀着对未来美好的憧憬来到期货这个市场时，我们为的是证明自我价值，同时也是为了在这个市场中获利，实现自己的创业之梦。当然，我们首先知道期市是一个高风险、高回报的市场，甚至于这就正是我们选择这个市场的原因。然而，数年过去了，高风险我们领略到了，可原来憧憬的高回报在哪里呢？资金亏损累累，风险却无处不在。在与期市为伍几年后，实盘经验告诉我，期市本身并不是一个高风险、高回报的市场，至少对我们散户来说，期市不应该是一个高风险、高回报的市场，由于我们先入为主地接受了高风险、高回报这样一种观念，因此在我们的操作思路中不仅期望得到很高的回报，同时也接受了期货就应当承受高风险的观念，而这正是酿成恶果的一个关键原因。 我就以我的一个朋友老徐的经历来论述这一观点吧。老徐是公司里的一个客户，资金数万，个人资质在我看来也远高于其他客户，当大多数人还在奉行短线交易时他已经在进行长线投资了，而我认识到长线投资的重要性是在两年之后。他认为要想在期货中获取高利润，付出高风险是很正常的事，在这样的思路下，他的下单量很重，曾经在大豆的一次空头行情中下重仓获利不菲，这更加让他确信下重仓承担高风险，获取巨额利润的交易思路。他经常反驳我质疑重仓交易的一句话是：仓位大小是一样的，止损大了获利也大。他在1998年曾经一次下30手空单，但终因无法承受压力而在当日平仓，但平仓之后是3个跌停板，那种懊悔之心相信大家都能体会，如果当时下15手空单，恐怕就不会因压力大而过早平仓。但这并不是最糟的，由于仓重，他的止损又大，即使遵守了顺势而为、严格止损这两大原则，期货的高杠杆率及技术上的失误再加上一点坏运气仍然迫使他连续止损十多次，这时期货的高风险就凸显出来，资金迅速降到了6000元，可是他并没有意识到自己错在哪里，而是抱怨运气太背了，怎么做怎么错，最后一笔交易就是用这6000元做的，知道他下了几手吗？ 10手（透支交易），价格先是顺着他的方向小幅下跌，接着整理，再接着反方向涨了回来，止损之后只剩下几百元了。至此，原来投入的资金全部亏光。尽管他坚持长线交易是非常正确的，但仅有的几次机会都由于各种原因错过了，而在整理时他却进场了，太大的止损与价格的大幅振荡合起来的结果就是亏损，而重仓又起到了加重损失的作用，最终没有等到期待中的大行情，资金就已经亏光了。尽管进场时机是他失败的一个直接原因，但根本原因则是他高风险、高回报的交易思路，其实期望在期市中获取高回报本来就是贪婪的表现。希望获得年收益2-3倍的超额利润，而行情是有限的，就只能通过加大仓位来实现，而这样止损产生的损失也必然会非常大，等于是不允许自己有更多犯错的机会，一旦运气不佳，遭遇连续亏损，本金就会迅速下降，直到扫地出门。 让我用数字来说明一下，以20000元本金来计算，以大豆为例，公司要求最小交易量为5手，按流行的5%止损原则，一次亏损为1000元，折合为20点/手（包括手续费），以近年的行情来看，即使你以长线的交易方式捕捉到了行情，在掐头去尾后，利润也就是300点，5手就是15000元（不包括加码在内），而且这还是在你操作完全正确的情况下，很明显这与我们期望在一轮行情中获利几倍的想法相去甚远，如果要想实现暴利，就必须加大仓位。比如10手，盈利就会变为30000元，这个结果看来还不错，那么你的止损为10%，也就是只允许你亏损不到10次。你还不要忽略一点，止损只有20点（相信多数交易者的止损要大于此，那么允许你犯错的次数将更少），这将意味着你在这个高杠杆率的市场中，在你搭上一艘船之前你会付出更多次数的亏损，还有如果你连续亏损5次，你要用剩余资金盈利100%才能恢复本金，而5次连续亏损在如此小的止损下，只要一点坏运气就会出现，可怕吧！ 重仓交易在给你一个诱人的回报的同时也隐藏了一个巨大的风险，一个你注定根本无法承受的风险。如果你坚持5%（甚至更低，我是3%~4%）的止损原则，坚持长线交易（我个人是长线交易的坚定拥护者，开始也有一个从短线到长线的转变过程），扩大赢利上采用金字塔加码方式，再辅以正确的技术分析（必须是经过验证的、有效的方法，否则即使资金管理十全十美，交易结果也会大打折扣），则结果也会非常不错，尽管并不是我们期待的巨额利润，但如果以这种操作方式长期交易下去，你的资金会越来越大，毕竟我们的目标是在期市长期生存与发展，一朝暴富可遇而不可求，在期市中为追求高回报而付出高风险是人的贪欲的表现，只会招来失败。其实归根结底期市本身只是提供了一个良好的投资工具，期市自身的风险完全可以通过良好的资金管理原则来化解，最大的风险来源于交易者内心的贪婪，高风险、高回报并不是期市的本来面目，只是投资人对期市的主观感受与评价，追逐高利润并不是最首要的，追逐低风险的交易思路，克制自己头脑中的贪欲，让自己能长期生存在这个市场，才是一切的一切的基础。 最后用一句话来概括：轻仓小量，坚守原则，降低风险，增值为首。 止损不容质疑刚刚读过谦虚谨慎老兄“我的技术感悟”一文，我有一些不同的看法。在实盘操作中，如何止损的确是技术分析所要解决的关键问题之一，我们都曾遇到过这样一种情况：明明是顺势操作，但依然连续被迫止损，以为行情又要启动了，可是设好止损跟进后，价格却又折了回来，触发了止损，接着再跟，又被止损出局，正在犹豫之时，价格却启动了，等明白过来，已经不适合进场了。因此我会想，如果我不设止损，或像谦虚谨慎老见所说的在发现做单方向错误时再止损，而不再以点位多少做止损，这样的想法对吗？我再以一些例子来论述： a是公司员工，但他有自己的一个户头，是1994年入市的老交易员了。据他人介绍，a以前操盘手法极恶劣，爆过数个户头。但从我进公司后观察，他的交易手法远高于场内绝大多数客户，我刚进公司时他刚在大豆1999年6月的盘整中下了10手空单（他在此前这轮行情中刚刚获利20000元），他正是采用谦虚谨慎老兄所说的那种手法，接着趋势转向了，发现错误后他出场了，近30000元资金只剩下5000多元，这是一次止损的大小。这位老兄久经沙场，不带一点沮丧情绪地进入了绿豆市场，接着奇迹出现了，在绿豆最后一拨牛市行情中，他坚持看多，只下2手，连续赢利13次（以波段方式），资金终于又上了20000元，是当时公司中操作最出色的。在这个过程中我一直观察他，分析他的操作方法，我发现他的思路与多数客户设好止损进场的方式截然不同，他是认准涨势，只要趋势没有改变，价格再如何波动都不出仓，绿豆尽管洗盘非常厉害，在其他客户跟对趋势后依然被迫止损的情况下，他的方法为他带来了非常好的利润。 然而事情并没有就此结束，绿豆大涨之后人们的看空情绪开始加重，a开始下空单，我不明白他有什么理由逆市交易，即使是在大涨之后。一次错了，止损，再空一次，发现又错了，第二次止损之后，2万多元的资金就只剩4000元了。尽管逆市交易是失败的直接原因，但发现错了才出场的止损方式让本来很平常的两个错误带来了巨大的损失，让之前13次的赢利化为乌有。 想必大家都知道资金管理的两大黄金原则，一是将亏损限于小额，让获利尽可能放大，也就是我们常说的盈亏比必须大于3/1。二是应限制任何部位的损失，也就是任何亏损不要超过总资金的1/20（通行的最大比率），很明显，大止损的方式完全违背了这一原则。况且，谁敢保证以这种方式入市就不会犯错，那种你认为趋势开始了，结果却又折了回来开始反方向的趋势难道不常见吗？认识到自己错了才止损，行情必然是已走了一大截，期货市场如此高的杠杆率必然会让你损失惨重，也许就此一蹶不振了，这和不设止损已没什么区别了。可以这么说，如果我以谦虚谨慎老见所说的那种手法入市，我不知死过多少回了，但只因我严守止损，我才有机会保证我的资金至今仍然存在，止损是我用无数次操作证明的期货市场第一生存法则，止损就是生存，我个人强烈反对弱化止损的地位。 谦虚谨慎老见还认为：止损一定是技术上的止损，而不是点位上的止损。我认为止损首先应符合资金管理要求，确定最大可承受的损失，才可依此来确定技术上的进场点及止损点，以技术上的点位来确定止损的大小，不仅会将亏损放大到危险程度，而且谁敢保证技术上的点位会有更高的成功概率？止损首要的一点是限制任何一次交易的损失，因为每一次进场只是假定会发生，而不是一定会发生，在这种情况下，技术上的止损点也不过是一个假设，没有任何的肯定意义。 谦虚谨慎老见还有这样一句话：“如果你的技术系统要经常止损的话，说明你的技术还不成熟，还不适合市场的生存要求。”我的看法刚好相反，经常性的止损是非常正常的，有一位投机大师曾说过：我95%的利润是由5%的交易创造的，大部分的交易是亏损的，只因我抓住了极少的获利机会并紧握不放才取得了成功。施威格的《期货交易技术分析》让我最惊诧的是其中的现实图表分析：一套成功的交易系统居然会有如此之高的止损率，失败的交易次数远远超过了获利交易，最终结果依然是盈利的。这两个例子充分说明止损次数的多少并不是最重要的，关键是你抓到了获利的交易并让它充分发展，巨大的获利足以抵御数次小额亏损所带来的损失。 我最后要说的是，散户在交易中频繁止损的确是普遍存在的。但问题的关键本身不在止损，而在于在这个高杠杆且波动剧烈的市场中，进场时机难于选择，不得要领必然导致频繁止损。但这完全是一个技巧性问题，完全可以通过观察它的走势规律来解决，至少我已经基本解决了。不好意思谦虚谨慎老兄，我几乎反对你的所有观点，但这是一个见仁见智的问题，希望你不必介意。其实我们自己的看法总是在两种相反的观点之间左右权衡得出的，不过实践是检验真理的惟一标准。 简以致胜记得我刚刚进入这个市场时，接触到了繁多的技术工具及指标，经过筛选，我选出了一些在我当时看来很好用的工具，并且我很早就意识到了系统交易的重要性，用许多不同的指标及工具相互组合，确定了进场条件、中途止损条件及出场条件，以让整个操作过程有规则可以依据，做到整个过程心里都有底。这是让我现在想起来都觉得得意的一件事。 然而，错误恰恰出现在这里，我的进场、出场及中途止损的每一个环节都依赖数个指标和工具的共同作用，虽不是一般常说的所谓共振，但却规定必须相互配合才可以动作。打个比方说，我的一般进场条件是：周期显示要有行情发生，14RSI上（下）穿70RSI均线，同时参考角度线，以确定已经止跌，还要参考持仓及成交量，总之，整个过程是非常复杂的。那么实际效果如何呢？非常不理想，最大的问题就是相互干涉造成几个指标相互矛盾，总有一些条件不会被满足，造成进出场犹豫不决，理论上似乎很完美的交易方案在实战中近乎无效，除了选择的指标及工具本身就存在巨大的缺陷外，要求各种工具相互配合是一个想象中可行，而实际上却是错误的思路。 我发现了这些问题，逐渐地剔除了一些，逐渐觉得可以了，就把所有的工具及指标还有简单的交易计划罗列到一张纸上，占满了整张信纸，我的脑海中闪现过一个念头：工具是否依然太多。可是我又觉得剩下的工具都很重要。此时正是绿豆的最后一轮空头行情，那三个跌停老期友们一定记得吧！我知道要空，但我一直信赖的周期没有发出任何信号，我错过了行情，绿豆停了，我把研究重心转向大豆（我以前没有研究过大豆），当我把绿豆中总结的方案套用到大豆时，我简直绝望了—我所谓的那套有效的技术在大豆里根本就是纸上谈兵，没有一点作用，那张曾经记录我的指标及工具的信纸形同废纸，消耗大量资金，倾注所有的精力得到的经验如此不堪检验，我懵了，我想不明白这到底是为什么。 冷静之后，我开始反思，问题出在哪里，我用如此复杂的技术无法赚钱，这么多指标放在一个新市场却没有一个可以用，那我还要它干什么？我开始大刀阔斧地削减我使用的工具及指标，将所有可有可无的指标全部删除，我推翻了自己以前几乎所有的思路，着重寻找绿豆和大豆两个市场的共同之处，结果是只剩下了k线和均线，实在是没什么可以再减了。突然间我豁然开朗，我似乎在这一刻发现了这个市场最真实的一面，原来这个市场所遵循的规律是如此简单，而我却没有发现，原因是我先入为主地认为期市是一个极为复杂及高深的市场，因此我本能地认为最终的交易方法一定也极为高深及复杂（相信现在仍然有许多期友这样想），实际上，期市是一个随机与规律共存的市场，其规律性的一面是非常显而易见的，简单到你对它视而不见的地步，而它随机的一面表现是极为复杂的，我恰恰就看到了这一面，而且错误地认为，这是一个完全规律的市场（忽视了它随机的一面），同样也一定存在一个不被大多数人掌握的交易方法，我一直在努力寻找这套方法，最终我走进了死胡同。这次突破是我技术思路的一次最重大的突破，我经过近一年苦苦寻找的方法原来一直都在我的眼前，清清楚楚地摆在我面前。对待这个本来极为复杂的市场，我们用复杂的交易思路只会越分析越糊涂，发现这个市场简单的一面，规律性的一面，然后以简单的技术手段去把握它，追随市场的主要趋势，不做任何主观上的猜测才是最终的解决方案。这个市场不需要多么高深复杂的技术分析手段，关键是你是否正确地认识了这个市场，发现了这个市场的规律，如果你对市场规律的认识本来就是错误的，那么建立在这个错误认识之上的所有交易思路及技术分析手段都是无效的，我犯的正是这个错误。 想必大家都看过《谁动了我的奶酪》，最后在分析为什么在寻找奶酪的过程中两个聪明的小矮人会输给两个头脑简单的小老鼠时指出，小矮人将本来简单的问题想得复杂了，有些问题本来是很简单的，而由于自作聪明的缘故，陷入思想的泥潭无法自拔，而小老鼠由于头脑简单，只进行简单的寻找，却最先找到了奶酪，哪唧先于哼哼发现了自己的错误，勇敢地放弃了对失去奶酪原因的思索而踏上了新的寻找之路，最终也找到了奶酪。而哼哼依然在原地思索奶酪丢失的原因。我们不可能回避我们自身自作聪明的缺点，不可能像老鼠一样简单地对待每一个问题，但我们完全可以像唧唧一样发现自己的错误，以简单的方法去应对。 简单不代表无效，复杂也不代表有效，我使用复杂的分析方法没有成功，最终成功的分析方法却是简单得不能再简单的分析工具和交易原则，这与我当初的想法完全相违背，想起来真有些不可思议。你依然在重复和我一样的错误吗？换个角度试试看，或许你也会大吃一惊。 持仓选择长线还是短线在这个市场，究竟是应该做长线还是做短线，想必是一个有较大争议的话题。当然，短线操作是绝大多数人的选择，长线操作者在这个市场是寥寥无几的。本文只是想通过我的一些思路转变过程为大家提供一个参考，或许这正是你期货操作成功之路上的一个死结，因为这个问题曾经是我的死结。 1999年绿豆曾经有过一次很强势的多头行情，那时我刚刚入市不久，由于经验不足，在涨势初期，我逆势看空，幸好及时止损，尽管数次逆势做空，但最终损失有限，然后我发现自己逆势交易的错误，开始坚决看多。此时绿豆已走完小九浪中的四浪（事后来看），我并没有耽搁太多，准备下多单，但由于我的技术分析、交易思路在那时都有严重缺陷（上一篇所提到过的问题），我看涨却仍然数次踏空，没能跟得上行情，仅有的一两次操作正确也在获小利之后匆匆出场。小九浪走完之后，行情大幅震荡，此时涨幅已经相当大了，场内几乎所有人都开始看空，我在顺势交易的原则下，仍然坚持看多，我是当时我们周围惟一看多的人。最凶悍的最后一浪大五浪开始了，尽管我坚决看涨，却由于技术上周期算錯了一天，而眼睁睁地看着行情拔地而起，等我明白过来，价格已高得让人畏惧，最终涨幅大得吓人，眼看就要到手的利润在我的眼前溜走了。行情走完了，绿豆从2000多点涨到3000多点，走势规则有节奏，这样容易捕捉的行情我最终得到的却是亏损，在这个过程中我不断地买进卖出，操作十多次，结果还是入不敷出。我发现，如果我从一开始就坚持顺势交易，如果我买进后不是短炒，而是赢利后放着，即使我只做对一次，赢利也足以抵消所有损失，而且还会有不少富余利润，而我呢？在怀疑、恐惧、犹豫中不是做反就是丢掉机会，好不容易速住一次，却又匆匆出场，频繁操作数次的结果还不如做对一次后放着让它自己发展的结果要好，哪怕是十次中只做对一次。 我把我的想法与一位客户聊起来，我最后说，看来还是得做长线。另一位经纪听到了，讥讽道：短线都做不好还想做长线。我心想，是啊，瞧瞧你赢利后急着出场的那副样子，你有做长线所需要的耐心吗？还是乖乖炒你的短线吧。曾经有那么一点长线交易的火花闪了一下就这样熄灭了。 几年过去了，我的交易思路与技术分析水平已经今非夕比了，但我仍然在做波段，我的交易利润仍然没有什么进展，我清楚地知道，一定还有什么地方不对。一天我看了一篇文章，着重强调了长线交易的重要性，我觉得有道理，开始反思自己以往的交易：我习惯的是炒波段，一次成功的操作可以赢利50-80点（熊市波段幅度大于牛市，这是掐头去尾之后的实际可得利润），我的止损通常是20个点之内，为了一次成功操作有时要付出两三次的止损，这样，通常赢利也只是补了亏损的空，这还算好的，最糟糕的是亏了两三次，行情真的开始动了，我却在怀疑与犹豫中丢掉了机会，由于在操作中亏损的次数是远大于赢利的，尽管我已经能成功地抓住赢利的机会，结果也只是打个平手，有时运气不好还会亏损。还有一个问题就是我经常会由于各种原因丢掉机会，这也是一个对行情的极大浪费，总的下来，即使遇到很好的行情，也只是断断续续地咬几口，去除亏损后也所剩无几。有些机会如果赢利后不动那会带来巨大的利润，而我却早早出场，频繁操作之后我依然是两手空空，一轮大行情后，我得到的只有遗憾和无奈。 我终于明白了，不能长线交易正是我的死结，要做一名净赢利交易者，我必须走这一步，摆在我面前的最大障碍是这一思路对耐心提出了极大的挑战，对这一点我很不自信，其次是技术上对进场后的第一轮回调我不知如何应对，但这些坎不过也得过，否则所有的努力都将白费，梦想就真的成为永远的梦了。 最终这些问题的解决并没有像我预想的那样困难，通过不断的心理暗示训练及对交易规则的修改，我最终成功了。我终于打开了最后一道门，明白了在这个市场成功所需要的所有条件。当初所有的迷团我都找到了答案。其实我相信这个市场有许多依靠短线成功的人，这一点我不否定，但大多数人依靠短线操作是没什么前途的，因为我们大多数人依然是普通人，即使你认为自己资质优于别人，请你别忘了，进入这一市场的所有人都有和你一样的自信，否则也不会选择期货。当然我或许因为我自己的经历而有些武断，你的短线技术或许比我高超很多，那你就把本文全当一个故事好了。 很久以前我曾经做过这样一个假设，我的寻找之路也是以这个假设为基础：其实我们寻找成功交易方法的过程正是一个对自己行为不断的反思及对自己心智不断完善的过程，在这个过程中，有许多的困难需要克服，有许多的规律需要发现，有许多的道理需要领悟，一切都做到之后，也就成功了，任何一个环节出错都会导致失败。当然，谁都明白这有多难，否则期货投资人也就不会有如此多的感慨。人性的弱点也制约我们很难达到这种理想中的状态，无数人在这个市场中损兵折将的原因也就在此吧。 期市最终的解决之道并不是如何的高深复杂，归结成一句话送给大家：剖析自己，剖析市场，发现问题，解决问题，仅此而已。当然还有一个关键点大家必须做到，那就是知行合一，这一点做不到，明白的道理再多也是白搭。 散户之败最近看了一位期友标题为《止损的威力》的帖子，大意是自己的15万元资金在坚持严格止损的情况下，仍然受到很大损失，我感觉到这篇文章的言语之间透露出了对止损的疑惑，其实一位网友已经解释得非常好了-“止损是成功交易的必要但不是充要条件”。说到操作失败的原因，我也有自己的一些看法，希望能够给仍然和曾经的我一样屡战屡败的期友们一些启迪。 在我入市一段时间后，我的资金开始缩水，屡战屡败的交易状态让我尝试到了期货那种不可琢磨的性格，市场似乎总是在和我作对，我感到很迷茫，在一次闲谈中，我问一位在公司成立时就开始工作的盘房工作人员：你见过有人拿着赢利走出这个市场吗？她说：早年做国债时有一个老头曾经把资金翻过数倍后离开了公司，之后就没有人能拿着赢利走出公司，公司中每年都会走掉一批老客户，又会补充进一批新人，而且周期通常是一年，多少年来不断地重复这个规律。这些话让我更加迷茫，回头看看公司里的这些客户，有谁不是抱着“我是最优秀的”心态在重复屡战屡败这个现实，而我呢，也和他们一样。难道我的命运注定是要被淘汰出局吗？为什么？难道自己以前途为代价追求的就是这样一个结果吗？难道自己选择错了吗？难道市场并不存在一种解决方案或者存在这样一种方案却不是自己的能力所及的吗？不，我坚信市场存在一种解决方案，那么我们这些自以为很聪明、很优秀，是“人中之人”的“可怜虫”究竟错在那里呢？每个人看起来都是那样聪明，可为什么在市场面前如此的不堪一击？为什么每个人都认为自己在期市中必胜，而结果都是被踢出市场呢？我无法找到答案，但我相信终有一天我会找到的。经过几年的苦苦追逐，随着一套长线交易系统的建立，无论思路还是交易手段都已经有了质的飞跃，所有的失败感都一扫而光，再回头去解答当初的疑问，一切问题都是如此的清晰。 期市中亏损的方式多种多样，绝大多数散户的共同特点是资金进一退三，最终被扫地出门（当然不包括经纪，他们的特点是经常一笔交易就将资金打光了，对待别人的资金极不负责任，希望我这么说不会伤害那些还有良知的经纪），而这些现象的背后原因是缺乏对市场的正确认识，一套正确交易理念和交易策略的建立是基于两个基础，一为对市场的正确认识，其二是对人性特征的正确认识，这两个基本条件中任意一点有问题，交易都无法成功（我指的是持续而稳定的获利）。以我自己的经历来看，是先有对市场的正确认识才会过渡到对人性特征的正确认识，交易系统正是建立于这两个基础之上，遗憾的是我所接触到的所有人，包括那个时候的自己仅仅停留在最初级的阶段，根本就谈不上对市场的正确理解，失败也就成为必然。根据这个市场的定律，绝大多数人注定无法真正认识到这两点，也注定会被淘汰出局，真的是很残酷的。 我们对期市的理解的过程和我们在成长的过程中对人生的理解过程很相似。我清楚地记得我在上三年级时觉得自己已经长大了，我已经明白了大人们的世界不过如此; 18岁时已经认为我是一个大人了，而当我从学校出来之后却发现我对社会是如此的无知，在社会中是如此的无助，我才明白我在社会这所大学中才刚上一年级。15岁时觉得14岁时的自己很幼稚，18岁时又觉得15岁时的自己很幼稚，现在的自己很“熱” 这样的想法重复了一年又一年，直到发现了自己的无知。今天只是昨天的明天，也同样是明天的昨天，自己没有变，只是自己的心在自以为是而已，我想这样的感觉存在于每一个人身上，我们的目光有很大的局限性，我们只能理解我们所经历过的。期市又何尝不是如此，每个人从进入期市开始就如同开始了自己的人生之路，每一个人都处在不同的年龄段中，但与人生不同的是绝大部分人都中途天折了，只有少数人最终迈向了辉煌。 而放眼身边的散户，与许多文章所说的散户不善止损相反，身边的同志们大多可以坚持严格止损，尽管止损的方式和依据各不相同，但在止损上都没有什么问题，都明白止损的重要，尤其是一些老期友。可是大多数散户所犯的错误恰恰不在于此，最典型的一种错误是依据基本面、持仓和成交量、持仓排行，或害人不浅的技术指标，甚至所谓的盘感等等各种方式对行情进行主观判断，却忽略掉最重要的价格，并将此做为进出场的依据，整个操作过程自我感觉良好，实际上漏洞百出，连基本的顺势交易都做不好，经常迷失在行情之中。最可悲的是谁都明白顺势的重要，只是实际操作时做不到或忘掉了（在此轮大豆行情中，我就看到许多有过出色言论的期友大建递势头寸，可见言行不一也是一个极普遍的现象），而少数能够顺势的，却又因为资金管理不善或其他原因而最终导致亏损。此外，没有完善的交易规则或有交易规则却不能严格遵守也是导致失败最普遍的一个原因。 归结起来，成功的交易过程是一个整体， “止损”、“长线”、“顺势”这些颠扑不破的真理不过是这个整体的一部分，甚至可以说只不过是正确的交易技术建立的基础而已。还是那句话，这些条件只是成功交易的必要条件，而不是充分条件，只是做好了严格止损而没有完整的技术，资金管理做得好只能保证你慢慢流血死亡，是无法带来成功的。这样说来，大多数散户失败的原因就很清晰了，缺乏对市场及自身的正确认识，缺乏完整、严密的交易规则和策略是多数散户必败的根本原因。 就我个人来说，我并不比谁聪明，也没有所谓的天赋，我想我与身边人不同的一点仅仅在于我严格遵守了被许多人认为是陈词滥调的交易戒条，而且区别仅此而已。 期货在我心中曾经是一个难解的心结，相信大家也同我一样，经历了多年执著的求索总算打开了这个结，真相是如此简单，追逐的过程却是如此艰难，每每看到论坛中曾经像我一样迷失在期市中的这些朋友就会有一种欲言又止的冲动，今天这篇文章就算是个小结吧，希望能对我的战友们一些启迪和鼓励。我应该承认的一点是，我的思路仍然受制于我自身目光和经历的局限性，但你我都应坚信总有一天我们会有机会实现自己的梦想，驾着自己的宝马车站在大海边迎着海风默默地回顾自己那艰难的奋斗历程。 交易的真相这些天看了一位网友关于这些文章的一篇帖子，“知易行难”，“会看戏和会唱戏的区别”，呵呵，大家说的我觉得都很有道理，早就想写这篇文章，可惜总是静不下心来，今天終于写完这篇文章，不知是否可以解掉大家心中的这些疑惑。 还是从我自己说起吧，我在入市前看了很多书，尽管对技术和这个市场仍然一知半解，但我却从前人的告诚中知道了两个基本的生存原则-严格止损、顺势交易。并暗下决心一定要牢记这两个原则。 一晃三个月就过去了，再回头看看自己的所做所为，止损做得还行，可是顺势交易却是做得一塌糊涂。开始时还记得要顺势，头几笔都是顺势建仓，可是从那笔重仓亏损之后，我就像中了邪一样顽固地认为行情“一定会跌”，顺势交易的原则早被抛到了脑后，所有的“分析”结果都一边倒似的认为大跌一定还在后面，我不断地放空，又不断地止损，数笔亏损后终于发现我在一轮明显的上升行情中做空。我突然想到了三个月前自己还一次又一次地告诚自己：一定要顺势而为。哈哈，我早被行情和自己的“一相情愿”搞了。现在问题清楚了，一定要再次牢记“顺势交易”，一晃又是三个月过去了，的确我尝到了顺势的甜头，可是我却同时发现，我仍然有逆势操作，而且有些时候我分不清究竟是上升趋势还是下降趋势。这个问题解决起来很容易，我使用了一条均线来作为多空的分界线，价格处在均线上方则只做多仓，价格处在均线下方则只做空仓。相信吗，逆势交易的问题就因为这一简单的规则解决了，从此之后，再没有一笔逆势交易出现，这个问题彻底解决。 还有止损的问题，在入市后很长一段时间里，我都只知道止损，却不知道止损必须是一个明确的点，为此，我有几次在发现自己可能错了时却由于犹豫而使本来应该很小的亏损扩大，付出了无谓的损失。我的性格是非常果断的那种，可是为什么会犹豫以至延误了最好的止损时机呢？总结教训，我发现是因为我只知道止损，但却没有明确的止损点，发生浮亏时还在考虑自己错了没有，是该等等看还是该认亏平仓，最终造成亏损的无谓扩大。问题明确了，解决起来也很容易，当每一次进场时就设好止损点，不管这个止损是怎么设置，但必须是一个明确的点，到了这个点就必须离场，不要去想“是不是我出来之后行情又会继续，让我错误止损”这样的问题。由于拖延而造成亏损扩大的问题也就这样轻易地解决了。 类似的问题有很多，但解决起来也并不难，为什么呢？是因为“规则”的制定贯穿参与了解决问题的整个过程，没错，我所要说的交易的真相正是———规则。 与“规则”相反的是“分析”。 “分析”本是个中性词，并无褒贬之意，但在期市中则有些不同，分析市场规律、分析自己的错误操作、分析优秀交易员的特点，等等，都是在应用分析。而我们几乎所有人都犯了一个相同的错误，将“分析行情”做为自己的基本交易方法，可以这样说，在进入期市的第一天起，我们就开始接受错误的交易习惯，我们所接触的大部分传统的技术分析手段都有其共同的缺陷—“主观性”太强，使用这种主观性很强的分析工具和人性的情緒化特点结合起来，最终造成了完全主观化的判断，判断的结果被自己当时的情绪所左右，同时会带有强烈的主观意愿偏向。这种错误的交易方法将绝大多数人挡在了成功交易的大门外，更遗憾的是我们在分析自己错误时很难想到问题竞会出在这里，以“分析行情”来做为交易手段无疑是最大的交易误区。人性的情绪化特征是交易的大敌，而制定并严格遵守规则恰恰是最好的解决办法。 与分析师经常所做的行情预测相反的是，优秀的交易员只遵守规则，而从不做任何行情预测。优秀的交易员不会是一个优秀的分析师，优秀的分析师同样不会是一个优秀的交易员，二者由于所处位置的不同，在应对市场时所采用的方法也具有本质上的区别，使用分析和使用规则在这两类人中具有很强的代表性。所谓“会说的不会做、会做的不会说”大概就是在说这个道理了。在我还是个新手时就注意到这样的一个现象：在公司里大谈“主力”，大谈“行情走向”，能够发表“精辟分析”的人通常操作是很糟糕的，而公司里经常赢利的一个客户却总是很沉默，问其怎么看行情，总回答“不知道会怎么走”，和我聊起来也总是在说一些诸如顺势之类的理念性话题，与其他人的行为形成了鲜明的对比。当时还以为他是不愿意透露自己的想法，后来自已经验渐丰才明白他没有撒谎，完全在说大实话。 大多数的散户交易者都介于分析师和优秀交易员之间，操作中既存在一些规则，但同时又充斥着大量的主观化分析和毫无正确逻辑可言的“预测”，还有对所谓“主力”动向的臆想，而主观特征极其明显的“分析”正是导致逆势操作的主要根源，抄底、摸顶的恶劣操作习惯无一不是来自“分析”的结果。错误的操作方法导致的结果必然是持续的亏损，对大多数散户而言，资金是经不起折腾的，屡战屡敗、亏多赢少，最终信心丧尽后出局也就在情理之中了。能够理解一些基本生存原则的老散户尽管可以相对长时间地留在市场，但根本上错误的交易方式仍然将其排除在成功的大门外。 再来理解“知易行难”，有一点很明显，几乎所有人，即便是个新手都知道一些正确的交易理念：顺势而为、轻仓、长线获利优于短线等等，可是与这些正确认识完全相反的是实际操作中逆势、重仓、频繁的短线操作却如此普遍，如果仅仅是“知”而无法去“行”，那么自己认为正确却依然反着做，有正确的认识又怎样，结果还不是一样。那么就真的没有任何办法将“知”与“行”对接吗？规则，仍然是规则，将自己所有对市场特征的认识都演化为客观的规则（而不是去分析预测），并严格执行，完全可以解决“知易行难”这个问题。 有位朋友问我如何来将获利放大，我就此一并作答：止损难，止盈则为难中之难。难在获利后那种害怕得而复失的复杂心态，想必每个人都有这样的经历。我的长线转变经历不是难在技术的解决，而是难在心理障碍的克服上，这自然是由自身的性格缺陷所造成的。但一旦跨越了心理障碍，技术上解决起来是很容易的，仍然是制定规则，一个简单的跟踪止损规则完全解决了问题，一些看似很难的问题，如果方法得当，解决起来并不困难。老实说，现在让我抛弃规则来长线持仓，我同样是做不到的，规则化的作用和好处是非常明显的。 规则与分析这个话题很少有人提及，但却是一个足以将普通投资人和优秀操作者这分开来的最重要的标准，系统化交易便是操作完全规则化、客观化、科学化的一个终极交易思路，并无任何神秘之处。 需要强调的有两点：一是规则的制定必须符合客观实际。我在入市三个月后就开始懂得使用规则来约束进出场，可惜我使用了“技术指标”这种本身有严重缺陷的技术方法来制定进出场规则，失败是必然的了。基于客观实际的正确交易规则的制定是非常关键的一点。二是必须严格执行自己所定的规则。如同体育比赛一样，任何体育项目都需要运动员具有基本的素质，如果连自己所定的明确的规则都不能严格执行，只能说自己连这个基本素质都不具备，选择了期市则完全是一个错误。 其实我个人在做了半年期货时就已经抛弃了绝大部分“预测和分析技术”，完全领会并开始在交易中应用亚当理论的一些重要观点（抛弃所有的主观性分析，顺势而为），在两个月后我明白了交易的简单化原则，放弃了所有的华而不实的工具，转而将所有目光集中在单一的价格特征的研究上，这也标志着我的入门阶段的结束而开始进入更漫长的晋级阶段。使用规则来解决我所遇到的问题，最初只是我思考如何解决问题时所本能使用的一个方法，当时只是按自己认为正确的方法做，完全是摸着石头过河。但系统建立后回过头才发现，原来是规则的使用使我沿着一条正确的思路到达了终点，习惯性地将自己的所有对市场规律的认识规则化并严格执行无疑起到了最关键的作用。很多经验和教训只能是事后来总结才能发现什么是对的什么是错的，当时是无法判断的，唉！现实就是这样。 此篇文章是我心得系列的最后一篇，相比前几篇而言， “含金量”最大，理解难度也是最大的，明白文章的意思很容易，但深刻理解却惡非大多數人所能，真正可以轻松理解并已经应用于交易中的朋友可能已是系统化交易者了。看戏与唱戏的确是有区别的，但别忘了，规则化是使自己从一个看戏者转变为唱戏者的一个关键也是惟一的最佳途径。 六篇文章都写完了，写个结语吧。我很高兴的是，这些最基本的交易理念，可以得到大多数朋友们的重视，这些理念没有什么是新的东西，都是前辈们的经验教训总结，对大家来说是在听身边的一个普通散户在讲对这些基本理念的认识，这应该比生硬地去理解前辈们的戒条感觉要好一些吧！对我来说，我在总结个人的经验和教训，也在总结自己从“知”到“行”的一个转化过程。从前也总是在机械地接受这些戒条，不知不觉间已经从我的口中说出，我知道这些“戒条”都已经深深扎根在我的对市场的基本认识中了。一而再、再而三地无视这些基本的操作戒条而屡错屡犯一些低级错误也算是“成功只属于少数人”的一个解释了。 记得在我第一次深刻领会“亚当理论”顺势而为的观点后，我心中窃喜，终于找到了制胜的“秘诀”。可是在偶然看到公司内部的期刊上有人大谈“顺势交易”，我的心一下子就凉了，原来“地球人都知道啊”。现在想起来真的很可笑，原来真相是-道理谁都“懂”，就是做不到。 其实在“市场”和“人”之间，真正的难点并不在市场，如果以足够客观的态度来解读市场，以一个普通人的智商，完全可以轻松找到市场的规律并制定出相应的对策，可惜问题是出在“人”身上，人性的恐惧、贪婪、一相情愿的想法等等“情绪化”特征完全覆盖了人性当中“理性”的成分，制约了自己迈向成功的脚步，成功最大的敌人正是自己。这也就解释了为什么成功的决定因素是“性格”，而不是“聪明” （其实是自作聪明）。 不能轻仓所反映的是人性中贪婪的一面，不能止损反映的是人性中恐惧失败和存在侥幸心理的一面，不能长线操作反映的是缺乏耐心和企图抓住市场所有波动的一面，不能顺势操作反映的是人性一相情愿的强烈的主观化特征，等等。“战胜自我”这样的说法不无道理，只要不是在操作中“战胜”就可以了。多数人对自己的“错误”视而不见，而将自己的失败归于“运气”、“主力”，惧怕承认自己的平庸，不愿去碰自己的痛处，用这些谎言来自欺自骗，最终的出局完全是理所当然的。缺乏自我认识，缺乏自我反省的意识也同样是多数人的通病，对自我的反省能力也可以决定其对真相的认识程度。 其实很多时候并不是知道什么是对、什么是错而不去做，更重要的是自己潜意识当中对“正确的方法”有一种本能的强烈的“抵触”心理，这就需要深刻的自我割析和反省。而这种“自我剖析”很多时候是血淋淋的：当必须承认自己并不优秀，当自己必须承认自己是个平庸的人，当自己必须承认自己的操作与身边的散户的抽劣表现并没有什么不同时，原来自信心存在的基础完全崩溃了，心痛的感觉，毕生难忘。然而这种心痛所带来的好处是彻底认清了自己的本来面目，不再抱着“我比别人优秀所以我会成功”这样幼稚的想法，不再认为“自己可以为市场把脉”，而转向“一切随势而动，顺水行舟”。亚当理论是我所有理念和操作的基础，也是我在探索阶段对市场认识最重要的一个转折点，一切的精髓只有四个字： “顺势而为”。其实我是转了很大一个图才发现经典理论的经典之处，可惜包括我在内的几乎所有人都曾忽略过、不屑过，而去寻找什么“制胜绝招”。但这似乎又是个无可奈何的现象，只有当真正深刻理解市场之后才能明白何为经典。 最近一段时间我才开始研究一些新兴的理论，比如混沌、分形、庄周的“杠杆操作法”，感觉有意思的是和自己的具体操作技术出奇地相似，很轻松就可以理解作者的意图。虽然使用的方法不同，许多专用术语也阻碍了对其方法进一步理解的耐心，但要解决的问题和解决的思路却是相同的，很明显的是庄周的操作技术是基于道氏理论的，任何市场的最终解决方案必然是简单的，至少其核心思路一定是简化的，一些“成功者”总是在找到问题的解决办法后将其细化、复杂化、延伸化和理论化并加以包装，让后来者“云里雾里”，感觉似乎很高深，人为地造成了理解上的距离，这一点上克罗做得最好-大道至简。我的感觉是成功的操作方法虽然表面有很大差异，但实质却非常近似，只是我不太喜欢这种细化和理论化的包装，几句话可以说明的问题却要用一本书和诸多“不知所云”的术语去解释，当然原因大家都心里有数。我有一个猜想，当初有人用“波浪理论”获胜时其主体思路一定是简要可靠的，只是后人对其不断理论化和细化才使得我们现在所看到的已经完全不是当初的本来面目，以致使其只能起到“解释”作用，而全无实战价值。可以轻松理解庄周的操作思路是因为我个人的操作技术同样以道氏理论为基础，可以轻松理解分形是因为我就在使用类似分形的技术来标示价格的运行轨迹，所以只是一瞥就已经明白这些技术绝非“华而不实”的技术，包括混池的鳄鱼操作法在内。虽然新的理论名词大量出现，但其技术原理均未脱离传统的经典理论， “太阳下没有新的东西”。 很多朋友在“寻找捷径”这种潜意识的驱使下盲目追随这种“潮流”，而放弃对市场的基本认识过程，其实如果不能深刻理解“交易系统”或这些新兴交易理论所要解决的核心问题，缺乏基本的市场认识，最终仍然是必败无疑的。这也就是我非常看重基础的市场理念的原因，任何想要绕过这个环节而去寻找成功的“金钥匙”都是不现实的，你是否见过某位大师是依靠别人成功的操作技术来获胜的，每一个成功者都是在深刻理解市场之后才创建出自己的一套方法，认真而耐心地去体验市场和交易的感觉，去感受失败的痛苦，最终才能够深刻地理解市场和自己。前人已提供了足够的技术方法来帮助我们解决技术问题，并不需要我们自己去“自创”什么，只要在市场理念正确的基础上依赖一些简单的技术和策略形成一套自己的方法就足够了。 其实我在反复强调“客观”、“务实”、“规则”这些词语，但我同样明白只有真正依靠自己领会了这些语言的含义，也才能真正理解我要表达的意思，这也就是认同和共鸣的区别。说到底，最终还是要靠自己。我的这些文章与前辈们所做的经验教训总结相比实在太过粗浅，我所能够做的也不过是将自己的想法说出来，对一些有缘的朋友可以起到清晰思路和启迪提示的作用，而且也仅此而已。 但凡感受过期市的人就总会有一种沧桑感，谁都无法免俗，我的文章中也本能地流露出这种感觉，期市犹如人生的浓缩，大悲大喜尽在其中。正所谓“天若有情天亦老，人间正道是沧桑”，在期市中拼搏过的朋友，无论自己最终是带着成功的自信还是失败的痛苦走出市场，有一点无需质疑：选择了期市当是人生中最无悔的一个选择，人生有期市这样一段经历已是精彩。 谨以此六篇拙文献予每一个曾经拼搏在这个市场、每一个正在艰难行进的散户投资人。朋友，一路走好！]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>从亏损到盈利</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fnext-boot%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { $(document).trigger('bootstrap:before'); /** * Register JS handlers by condition option. * Need to add config option in Front-End at 'layout/_partials/head.swig' file. */ CONFIG.fastclick && NexT.utils.isMobile() && window.FastClick.attach(document.body); CONFIG.lazyload && NexT.utils.lazyLoadPostsImages(); NexT.utils.registerESCKeyEvent(); CONFIG.back2top && NexT.utils.registerBackToTop(); // Mobile top menu bar. $('.site-nav-toggle button').on('click', function() { var $siteNav = $('.site-nav'); var ON_CLASS_NAME = 'site-nav-on'; var isSiteNavOn = $siteNav.hasClass(ON_CLASS_NAME); var animateAction = isSiteNavOn ? 'slideUp' : 'slideDown'; var animateCallback = isSiteNavOn ? 'removeClass' : 'addClass'; $siteNav.stop()[animateAction]('fast', function() { $siteNav[animateCallback](ON_CLASS_NAME); }); }); /** * Register JS handlers by condition option. * Need to add config option in Front-End at 'layout/_partials/head.swig' file. */ CONFIG.fancybox && NexT.utils.wrapImageWithFancyBox(); CONFIG.tabs && NexT.utils.registerTabsTag(); NexT.utils.embeddedVideoTransformer(); // Define Motion Sequence. NexT.motion.integrator .add(NexT.motion.middleWares.logo) .add(NexT.motion.middleWares.menu) .add(NexT.motion.middleWares.postList) .add(NexT.motion.middleWares.sidebar); $(document).trigger('motion:before'); // Bootstrap Motion. CONFIG.motion.enable && NexT.motion.integrator.bootstrap(); $(document).trigger('bootstrap:after'); });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fpost-details%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { function initScrollSpy() { var tocSelector = '.post-toc'; var $tocElement = $(tocSelector); var activeCurrentSelector = '.active-current'; function removeCurrentActiveClass() { $(tocSelector + ' ' + activeCurrentSelector) .removeClass(activeCurrentSelector.substring(1)); } $tocElement .on('activate.bs.scrollspy', function() { var $currentActiveElement = $(tocSelector + ' .active').last(); removeCurrentActiveClass(); $currentActiveElement.addClass('active-current'); // Scrolling to center active TOC element if TOC content is taller then viewport. $tocElement.scrollTop($currentActiveElement.offset().top - $tocElement.offset().top + $tocElement.scrollTop() - ($tocElement.height() / 2)); }) .on('clear.bs.scrollspy', removeCurrentActiveClass); $('body').scrollspy({ target: tocSelector }); } initScrollSpy(); }); $(document).ready(function() { var html = $('html'); var TAB_ANIMATE_DURATION = 200; var hasVelocity = $.isFunction(html.velocity); $('.sidebar-nav li').on('click', function() { var item = $(this); var activeTabClassName = 'sidebar-nav-active'; var activePanelClassName = 'sidebar-panel-active'; if (item.hasClass(activeTabClassName)) { return; } var currentTarget = $('.' + activePanelClassName); var target = $('.' + item.data('target')); hasVelocity ? currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function() { target .velocity('stop') .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION) .addClass(activePanelClassName); }) : currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function() { currentTarget.hide(); target .stop() .css({'opacity': 0, 'display': 'block'}) .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function() { currentTarget.removeClass(activePanelClassName); target.addClass(activePanelClassName); }); }); item.siblings().removeClass(activeTabClassName); item.addClass(activeTabClassName); }); // TOC item animation navigate & prevent #item selector in adress bar. $('.post-toc a').on('click', function(e) { e.preventDefault(); var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href')); var offset = $(targetSelector).offset().top; hasVelocity ? html.velocity('stop').velocity('scroll', { offset : offset + 'px', mobileHA: false }) : $('html, body').stop().animate({ scrollTop: offset }, 500); }); // Expand sidebar on post detail page by default, when post has a toc. var $tocContent = $('.post-toc-content'); var display = CONFIG.page.sidebar; if (typeof display !== 'boolean') { // There's no definition sidebar in the page front-matter var isSidebarCouldDisplay = CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always'; var hasTOC = $tocContent.length > 0 && $tocContent.html().trim().length > 0; display = isSidebarCouldDisplay && hasTOC; } if (display) { CONFIG.motion.enable ? NexT.motion.middleWares.sidebar = function() { NexT.utils.displaySidebar(); } : NexT.utils.displaySidebar(); } });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fscrollspy%2F</url>
    <content type="text"><![CDATA[/* ======================================================================== * Bootstrap: scrollspy.js v3.3.2 * http://getbootstrap.com/javascript/#scrollspy * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ /** * Customized by iissnan & Ivan.Nginx * * - Add a `clear.bs.scrollspy` event. * - Esacpe targets selector. * - Refactored with eslint-config-theme-next style. */ /* global NexT */ (function($) { 'use strict'; // SCROLLSPY CLASS DEFINITION // ========================== function ScrollSpy(element, options) { this.$body = $(document.body); this.$scrollElement = $(element).is(document.body) ? $(window) : $(element); this.options = $.extend({}, ScrollSpy.DEFAULTS, options); this.selector = (this.options.target || '') + ' .nav li > a'; this.offsets = []; this.targets = []; this.activeTarget = null; this.scrollHeight = 0; this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this)); this.refresh(); this.process(); } ScrollSpy.VERSION = '3.3.2'; ScrollSpy.DEFAULTS = { offset: 10 }; ScrollSpy.prototype.getScrollHeight = function() { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight); }; ScrollSpy.prototype.refresh = function() { var that = this; var offsetMethod = 'offset'; var offsetBase = 0; this.offsets = []; this.targets = []; this.scrollHeight = this.getScrollHeight(); if (!$.isWindow(this.$scrollElement[0])) { offsetMethod = 'position'; offsetBase = this.$scrollElement.scrollTop(); } this.$body .find(this.selector) .map(function() { var $el = $(this); var href = $el.data('target') || $el.attr('href'); var $href = /^#./.test(href) && $(NexT.utils.escapeSelector(href)); // Need to escape selector. return ($href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]]) || null; }) .sort(function(a, b) { return a[0] - b[0]; }) .each(function() { that.offsets.push(this[0]); that.targets.push(this[1]); }); }; ScrollSpy.prototype.process = function() { var scrollTop = this.$scrollElement.scrollTop() + this.options.offset; var scrollHeight = this.getScrollHeight(); var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(); var offsets = this.offsets; var targets = this.targets; var activeTarget = this.activeTarget; var i; if (this.scrollHeight !== scrollHeight) { this.refresh(); } if (scrollTop >= maxScroll) { return activeTarget !== (i = targets[targets.length - 1]) && this.activate(i); } if (activeTarget && scrollTop < offsets[0]) { $(this.selector).trigger('clear.bs.scrollspy'); // Add a custom event. this.activeTarget = null; return this.clear(); } for (i = offsets.length; i--;) { activeTarget !== targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fpisces%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { var sidebarInner = $('.sidebar-inner'); var sidebarOffset = CONFIG.sidebar.offset || 12; function getHeaderOffset() { return $('.header-inner').height() + sidebarOffset; } function getFooterOffset() { var footer = $('#footer'); var footerInner = $('.footer-inner'); var footerMargin = footer.outerHeight() - footerInner.outerHeight(); var footerOffset = footer.outerHeight() + footerMargin; return footerOffset; } function initAffix() { var headerOffset = getHeaderOffset(); var footerOffset = getFooterOffset(); var sidebarHeight = $('#sidebar').height() + NexT.utils.getSidebarb2tHeight(); var contentHeight = $('#content').height(); // Not affix if sidebar taller than content (to prevent bottom jumping). if (headerOffset + sidebarHeight < contentHeight) { sidebarInner.affix({ offset: { top : headerOffset - sidebarOffset, bottom: footerOffset } }); sidebarInner.affix('checkPosition'); } $('#sidebar').css({ 'margin-top': headerOffset, 'margin-left': 'auto' }); } function recalculateAffixPosition() { $(window).off('.affix'); sidebarInner.removeData('bs.affix').removeClass('affix affix-top affix-bottom'); initAffix(); } function resizeListener() { var mql = window.matchMedia('(min-width: 992px)'); mql.addListener(function(e) { if (e.matches) { recalculateAffixPosition(); } }); } initAffix(); resizeListener(); });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Faffix%2F</url>
    <content type="text"><![CDATA[/* ======================================================================== * Bootstrap: affix.js v3.3.5 * http://getbootstrap.com/javascript/#affix * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ /** * Customized by Ivan.Nginx * * - Refactored with eslint-config-theme-next style. */ (function($) { 'use strict'; // AFFIX CLASS DEFINITION // ====================== var Affix = function(element, options) { this.options = $.extend({}, Affix.DEFAULTS, options); this.$target = $(this.options.target) .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)) .on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this)); this.$element = $(element); this.affixed = null; this.unpin = null; this.pinnedOffset = null; this.checkPosition(); }; Affix.VERSION = '3.3.5'; Affix.RESET = 'affix affix-top affix-bottom'; Affix.DEFAULTS = { offset: 0, target: window }; Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) { var scrollTop = this.$target.scrollTop(); var position = this.$element.offset(); var targetHeight = this.$target.height(); if (offsetTop != null && this.affixed === 'top') return scrollTop < offsetTop ? 'top' : false; if (this.affixed === 'bottom') { if (offsetTop != null) return scrollTop + this.unpin]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fmotion%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { NexT.motion = {}; var sidebarToggleLines = { lines: [], push : function(line) { this.lines.push(line); }, init: function() { this.lines.forEach(function(line) { line.init(); }); }, arrow: function() { this.lines.forEach(function(line) { line.arrow(); }); }, close: function() { this.lines.forEach(function(line) { line.close(); }); } }; function SidebarToggleLine(settings) { this.el = $(settings.el); this.status = $.extend({}, { init: { width : '100%', opacity: 1, left : 0, rotateZ: 0, top : 0 } }, settings.status); } SidebarToggleLine.prototype.init = function() { this.transform('init'); }; SidebarToggleLine.prototype.arrow = function() { this.transform('arrow'); }; SidebarToggleLine.prototype.close = function() { this.transform('close'); }; SidebarToggleLine.prototype.transform = function(status) { this.el.velocity('stop').velocity(this.status[status]); }; var sidebarToggleLine1st = new SidebarToggleLine({ el : '.sidebar-toggle-line-first', status: { arrow: {width: '50%', rotateZ: '-45deg', top: '2px'}, close: {width: '100%', rotateZ: '-45deg', top: '5px'} } }); var sidebarToggleLine2nd = new SidebarToggleLine({ el : '.sidebar-toggle-line-middle', status: { arrow: {width: '90%'}, close: {opacity: 0} } }); var sidebarToggleLine3rd = new SidebarToggleLine({ el : '.sidebar-toggle-line-last', status: { arrow: {width: '50%', rotateZ: '45deg', top: '-2px'}, close: {width: '100%', rotateZ: '45deg', top: '-5px'} } }); sidebarToggleLines.push(sidebarToggleLine1st); sidebarToggleLines.push(sidebarToggleLine2nd); sidebarToggleLines.push(sidebarToggleLine3rd); var SIDEBAR_WIDTH = CONFIG.sidebar.width ? CONFIG.sidebar.width : '320px'; var SIDEBAR_DISPLAY_DURATION = 200; var xPos, yPos; var sidebarToggleMotion = { toggleEl : $('.sidebar-toggle'), dimmerEl : $('#sidebar-dimmer'), sidebarEl : $('.sidebar'), isSidebarVisible: false, init : function() { this.toggleEl.on('click', this.clickHandler.bind(this)); this.dimmerEl.on('click', this.clickHandler.bind(this)); this.toggleEl.on('mouseenter', this.mouseEnterHandler.bind(this)); this.toggleEl.on('mouseleave', this.mouseLeaveHandler.bind(this)); this.sidebarEl.on('touchstart', this.touchstartHandler.bind(this)); this.sidebarEl.on('touchend', this.touchendHandler.bind(this)); this.sidebarEl.on('touchmove', function(e) { e.preventDefault(); }); $(document) .on('sidebar.isShowing', function() { NexT.utils.isDesktop() && $('body').velocity('stop').velocity( {paddingRight: SIDEBAR_WIDTH}, SIDEBAR_DISPLAY_DURATION ); }) .on('sidebar.isHiding', function() { }); }, clickHandler: function() { this.isSidebarVisible ? this.hideSidebar() : this.showSidebar(); this.isSidebarVisible = !this.isSidebarVisible; }, mouseEnterHandler: function() { if (this.isSidebarVisible) { return; } sidebarToggleLines.arrow(); }, mouseLeaveHandler: function() { if (this.isSidebarVisible) { return; } sidebarToggleLines.init(); }, touchstartHandler: function(e) { xPos = e.originalEvent.touches[0].clientX; yPos = e.originalEvent.touches[0].clientY; }, touchendHandler: function(e) { var _xPos = e.originalEvent.changedTouches[0].clientX; var _yPos = e.originalEvent.changedTouches[0].clientY; if (_xPos - xPos > 30 && Math.abs(_yPos - yPos) < 20) { this.clickHandler(); } }, showSidebar: function() { var self = this; sidebarToggleLines.close(); this.sidebarEl.velocity('stop').velocity({ width: SIDEBAR_WIDTH }, { display : 'block', duration: SIDEBAR_DISPLAY_DURATION, begin : function() { $('.sidebar .motion-element').not('.site-state').velocity( 'transition.slideRightIn', { stagger : 50, drag : true, complete: function() { self.sidebarEl.trigger('sidebar.motion.complete'); } } ); $('.site-state').velocity( 'transition.slideRightIn', { stagger : 50, drag : true, display : 'flex' } ); }, complete: function() { self.sidebarEl.addClass('sidebar-active'); self.sidebarEl.trigger('sidebar.didShow'); } }); this.sidebarEl.trigger('sidebar.isShowing'); }, hideSidebar: function() { NexT.utils.isDesktop() && $('body').velocity('stop').velocity({paddingRight: 0}); this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none'); this.sidebarEl.velocity('stop').velocity({width: 0}, {display: 'none'}); sidebarToggleLines.init(); this.sidebarEl.removeClass('sidebar-active'); this.sidebarEl.trigger('sidebar.isHiding'); // Prevent adding TOC to Overview if Overview was selected when close & open sidebar. if ($('.post-toc-wrap')) { if ($('.site-overview-wrap').css('display') === 'block') { $('.post-toc-wrap').removeClass('motion-element'); } else { $('.post-toc-wrap').addClass('motion-element'); } } } }; sidebarToggleMotion.init(); NexT.motion.integrator = { queue : [], cursor: -1, add : function(fn) { this.queue.push(fn); return this; }, next: function() { this.cursor++; var fn = this.queue[this.cursor]; $.isFunction(fn) && fn(NexT.motion.integrator); }, bootstrap: function() { this.next(); } }; NexT.motion.middleWares = { logo: function(integrator) { var sequence = []; var $brand = $('.brand'); var $image = $('.custom-logo-image'); var $title = $('.site-title'); var $subtitle = $('.site-subtitle'); var $logoLineTop = $('.logo-line-before i'); var $logoLineBottom = $('.logo-line-after i'); $brand.length > 0 && sequence.push({ e: $brand, p: {opacity: 1}, o: {duration: 200} }); /** * Check if $elements exist. * @param {jQuery|Array} $elements * @returns {boolean} */ function hasElement($elements) { $elements = Array.isArray($elements) ? $elements : [$elements]; return $elements.every(function($element) { return $element.length > 0; }); } function getMistLineSettings(element, translateX) { return { e: $(element), p: {translateX: translateX}, o: { duration : 500, sequenceQueue: false } }; } function pushImageToSequence() { sequence.push({ e: $image, p: {opacity: 1, top: 0}, o: {duration: 200} }); } NexT.utils.isMist() && hasElement([$logoLineTop, $logoLineBottom]) && sequence.push( getMistLineSettings($logoLineTop, '100%'), getMistLineSettings($logoLineBottom, '-100%') ); NexT.utils.isMuse() && hasElement($image) && pushImageToSequence(); hasElement($title) && sequence.push({ e: $title, p: {opacity: 1, top: 0}, o: {duration: 200} }); hasElement($subtitle) && sequence.push({ e: $subtitle, p: {opacity: 1, top: 0}, o: {duration: 200} }); (NexT.utils.isPisces() || NexT.utils.isGemini()) && hasElement($image) && pushImageToSequence(); if (CONFIG.motion.async) { integrator.next(); } if (sequence.length > 0) { sequence[sequence.length - 1].o.complete = function() { integrator.next(); }; /* eslint-disable */ $.Velocity.RunSequence(sequence); /* eslint-enable */ } else { integrator.next(); } }, menu: function(integrator) { if (CONFIG.motion.async) { integrator.next(); } $('.menu-item').velocity('transition.slideDownIn', { display : null, duration: 200, complete: function() { integrator.next(); } }); }, postList: function(integrator) { //var $post = $('.post'); var $postBlock = $('.post-block, .pagination, .comments'); var $postBlockTransition = CONFIG.motion.transition.post_block; var $postHeader = $('.post-header'); var $postHeaderTransition = CONFIG.motion.transition.post_header; var $postBody = $('.post-body'); var $postBodyTransition = CONFIG.motion.transition.post_body; var $collHeader = $('.collection-title, .archive-year'); var $collHeaderTransition = CONFIG.motion.transition.coll_header; var $sidebarAffix = $('.sidebar-inner'); var $sidebarAffixTransition = CONFIG.motion.transition.sidebar; var hasPost = $postBlock.length > 0; function postMotion() { var postMotionOptions = window.postMotionOptions || { stagger: 100, drag : true }; postMotionOptions.complete = function() { // After motion complete need to remove transform from sidebar to let affix work on Pisces | Gemini. if (CONFIG.motion.transition.sidebar && (NexT.utils.isPisces() || NexT.utils.isGemini())) { $sidebarAffix.css({ 'transform': 'initial' }); } integrator.next(); }; //$post.velocity('transition.slideDownIn', postMotionOptions); if (CONFIG.motion.transition.post_block) { $postBlock.velocity('transition.' + $postBlockTransition, postMotionOptions); } if (CONFIG.motion.transition.post_header) { $postHeader.velocity('transition.' + $postHeaderTransition, postMotionOptions); } if (CONFIG.motion.transition.post_body) { $postBody.velocity('transition.' + $postBodyTransition, postMotionOptions); } if (CONFIG.motion.transition.coll_header) { $collHeader.velocity('transition.' + $collHeaderTransition, postMotionOptions); } // Only for Pisces | Gemini. if (CONFIG.motion.transition.sidebar && (NexT.utils.isPisces() || NexT.utils.isGemini())) { $sidebarAffix.velocity('transition.' + $sidebarAffixTransition, postMotionOptions); } } hasPost ? postMotion() : integrator.next(); if (CONFIG.motion.async) { integrator.next(); } }, sidebar: function(integrator) { if (CONFIG.sidebar.display === 'always') { NexT.utils.displaySidebar(); } integrator.next(); } }; });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Futils%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ NexT.utils = NexT.$u = { /** * Wrap images with fancybox support. */ wrapImageWithFancyBox: function() { $('.content img') .not(':hidden') .each(function() { var $image = $(this); var imageTitle = $image.attr('title') || $image.attr('alt'); var $imageWrapLink = $image.parent('a'); if ($imageWrapLink.length < 1) { var imageLink = $image.attr('data-original') || $image.attr('src'); $imageWrapLink = $image.wrap('').parent('a'); if ($image.is('.post-gallery img')) { $imageWrapLink.addClass('post-gallery-img'); $imageWrapLink.attr('data-fancybox', 'gallery').attr('rel', 'gallery'); } else if ($image.is('.group-picture img')) { $imageWrapLink.attr('data-fancybox', 'group').attr('rel', 'group'); } else { $imageWrapLink.attr('data-fancybox', 'default').attr('rel', 'default'); } } if (imageTitle) { $imageWrapLink.append('' + imageTitle + ''); // Make sure img title tag will show correctly in fancybox $imageWrapLink.attr('title', imageTitle).attr('data-caption', imageTitle); } }); $('.fancybox').fancybox({ loop: true, helpers: { overlay: { locked: false } } }); }, lazyLoadPostsImages: function() { $('#posts').find('img').lazyload({ //placeholder: '/images/loading.gif', effect : 'fadeIn', threshold: 0 }); }, /** * Tabs tag listener (without twitter bootstrap). */ registerTabsTag: function() { var tNav = '.tabs ul.nav-tabs '; // Binding `nav-tabs` & `tab-content` by real time permalink changing. $(function() { $(window).bind('hashchange', function() { var tHash = location.hash; if (tHash !== '' && !tHash.match(/%\S{2}/)) { $(tNav + 'li:has(a[href="' + tHash + '"])').addClass('active').siblings().removeClass('active'); $(tHash).addClass('active').siblings().removeClass('active'); } }).trigger('hashchange'); }); $(tNav + '.tab').on('click', function(href) { href.preventDefault(); // Prevent selected tab to select again. if (!$(this).hasClass('active')) { // Add & Remove active class on `nav-tabs` & `tab-content`. $(this).addClass('active').siblings().removeClass('active'); var tActive = $(this).find('a').attr('href'); $(tActive).addClass('active').siblings().removeClass('active'); // Clear location hash in browser if #permalink exists. if (location.hash !== '') { history.pushState('', document.title, window.location.pathname + window.location.search); } } }); }, registerESCKeyEvent: function() { $(document).on('keyup', function(event) { var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible'); if (shouldDismissSearchPopup) { $('.search-popup').hide(); $('.search-popup-overlay').remove(); $('body').css('overflow', ''); } }); }, registerBackToTop: function() { var THRESHOLD = 50; var $top = $('.back-to-top'); function initBackToTop() { $top.toggleClass('back-to-top-on', window.pageYOffset > THRESHOLD); var scrollTop = $(window).scrollTop(); var contentVisibilityHeight = NexT.utils.getContentVisibilityHeight(); var scrollPercent = scrollTop / contentVisibilityHeight; var scrollPercentRounded = Math.round(scrollPercent * 100); var scrollPercentMaxed = scrollPercentRounded > 100 ? 100 : scrollPercentRounded; $('#scrollpercent>span').html(scrollPercentMaxed); } // For init back to top in sidebar if page was scrolled after page refresh. $(window).on('load', function() { initBackToTop(); }); $(window).on('scroll', function() { initBackToTop(); }); $top.on('click', function() { $.isFunction($('html').velocity) ? $('body').velocity('scroll') : $('html, body').animate({ scrollTop: 0 }); }); }, /** * Transform embedded video to support responsive layout. * @see http://toddmotto.com/fluid-and-responsive-youtube-and-vimeo-videos-with-fluidvids-js/ */ embeddedVideoTransformer: function() { var $iframes = $('iframe'); // Supported Players. Extend this if you need more players. var SUPPORTED_PLAYERS = [ 'www.youtube.com', 'player.vimeo.com', 'player.youku.com', 'music.163.com', 'www.tudou.com' ]; var pattern = new RegExp(SUPPORTED_PLAYERS.join('|')); function getDimension($element) { return { width : $element.width(), height: $element.height() }; } function getAspectRadio(width, height) { return height / width * 100; } $iframes.each(function() { var iframe = this; var $iframe = $(this); var oldDimension = getDimension($iframe); var newDimension; if (this.src.search(pattern) > 0) { // Calculate the video ratio based on the iframe's w/h dimensions var videoRatio = getAspectRadio(oldDimension.width, oldDimension.height); // Replace the iframe's dimensions and position the iframe absolute // This is the trick to emulate the video ratio $iframe.width('100%').height('100%') .css({ position: 'absolute', top : '0', left : '0' }); // Wrap the iframe in a new which uses a dynamically fetched padding-top property // based on the video's w/h dimensions var wrap = document.createElement('div'); wrap.className = 'fluid-vids'; wrap.style.position = 'relative'; wrap.style.marginBottom = '20px'; wrap.style.width = '100%'; wrap.style.paddingTop = videoRatio + '%'; // Fix for appear inside tabs tag. (wrap.style.paddingTop === '') && (wrap.style.paddingTop = '50%'); // Add the iframe inside our newly created var iframeParent = iframe.parentNode; iframeParent.insertBefore(wrap, iframe); wrap.appendChild(iframe); // Additional adjustments for 163 Music if (this.src.search('music.163.com') > 0) { newDimension = getDimension($iframe); var shouldRecalculateAspect = newDimension.width > oldDimension.width || newDimension.height < oldDimension.height; // 163 Music Player has a fixed height, so we need to reset the aspect radio if (shouldRecalculateAspect) { wrap.style.paddingTop = getAspectRadio(newDimension.width, oldDimension.height) + '%'; } } } }); }, hasMobileUA: function() { var nav = window.navigator; var ua = nav.userAgent; var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g; return pa.test(ua); }, isTablet: function() { return window.screen.width < 992 && window.screen.width > 767 && this.hasMobileUA(); }, isMobile: function() { return window.screen.width < 767 && this.hasMobileUA(); }, isDesktop: function() { return !this.isTablet() && !this.isMobile(); }, /** * Escape meta symbols in jQuery selectors. * * @param selector * @returns {string|void|XML|*} */ escapeSelector: function(selector) { return selector.replace(/[!"$%&'()*+,./:;?@[\\\]^`{|}~]/g, '\\$&'); }, displaySidebar: function() { if (!this.isDesktop() || this.isPisces() || this.isGemini()) { return; } $('.sidebar-toggle').trigger('click'); }, isMuse: function() { return CONFIG.scheme === 'Muse'; }, isMist: function() { return CONFIG.scheme === 'Mist'; }, isPisces: function() { return CONFIG.scheme === 'Pisces'; }, isGemini: function() { return CONFIG.scheme === 'Gemini'; }, getScrollbarWidth: function() { var $div = $('').addClass('scrollbar-measure').prependTo('body'); var div = $div[0]; var scrollbarWidth = div.offsetWidth - div.clientWidth; $div.remove(); return scrollbarWidth; }, getContentVisibilityHeight: function() { var docHeight = $('.container').height(); var winHeight = $(window).height(); var contentVisibilityHeight = docHeight > winHeight ? docHeight - winHeight : $(document).height() - winHeight; return contentVisibilityHeight; }, getSidebarb2tHeight: function() { var sidebarb2tHeight = (CONFIG.back2top && CONFIG.back2top_sidebar) ? $('.back-to-top').height() : 0; return sidebarb2tHeight; }, getSidebarSchemePadding: function() { var sidebarNavHeight = $('.sidebar-nav').css('display') === 'block' ? $('.sidebar-nav').outerHeight(true) : 0; var sidebarInner = $('.sidebar-inner'); var sidebarPadding = sidebarInner.innerWidth() - sidebarInner.width(); var sidebarOffset = CONFIG.sidebar.offset ? CONFIG.sidebar.offset : 12; var sidebarSchemePadding = this.isPisces() || this.isGemini() ? (sidebarPadding * 2) + sidebarNavHeight + sidebarOffset + this.getSidebarb2tHeight() : (sidebarPadding * 2) + (sidebarNavHeight / 2); return sidebarSchemePadding; } }; $(document).ready(function() { function wrapTable() { $('table').not('figure table').wrap(''); } /** * Init Sidebar & TOC inner dimensions on all pages and for all schemes. * Need for Sidebar/TOC inner scrolling if content taller then viewport. */ function updateSidebarHeight(height) { height = height || 'auto'; $('.site-overview, .post-toc').css('max-height', height); } function initSidebarDimension() { var updateSidebarHeightTimer; $(window).on('resize', function() { updateSidebarHeightTimer && clearTimeout(updateSidebarHeightTimer); updateSidebarHeightTimer = setTimeout(function() { var sidebarWrapperHeight = document.body.clientHeight - NexT.utils.getSidebarSchemePadding(); updateSidebarHeight(sidebarWrapperHeight); }, 0); }); // Initialize Sidebar & TOC Width. var scrollbarWidth = NexT.utils.getScrollbarWidth(); if ($('.site-overview-wrap').height() > (document.body.clientHeight - NexT.utils.getSidebarSchemePadding())) { $('.site-overview').css('width', 'calc(100% + ' + scrollbarWidth + 'px)'); } if ($('.post-toc-wrap').height() > (document.body.clientHeight - NexT.utils.getSidebarSchemePadding())) { $('.post-toc').css('width', 'calc(100% + ' + scrollbarWidth + 'px)'); } // Initialize Sidebar & TOC Height. updateSidebarHeight(document.body.clientHeight - NexT.utils.getSidebarSchemePadding()); } initSidebarDimension(); wrapTable(); });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fvelocity.ui.min%2F</url>
    <content type="text"><![CDATA[/* VelocityJS.org UI Pack (5.0.4). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License. Portions copyright Daniel Eden, Christian Pucci. */ !function(t){"function"==typeof require&&"object"==typeof exports?module.exports=t():"function"==typeof define&&define.amd?define(["velocity"],t):t()}(function(){return function(t,a,e,r){function n(t,a){var e=[];return t&&a?($.each([t,a],function(t,a){var r=[];$.each(a,function(t,a){for(;a.toString().lengthparseFloat(e[1])):!1}if(!t.Velocity||!t.Velocity.Utilities)return void(a.console&&console.log("Velocity UI Pack: Velocity must be loaded first. Aborting."));var i=t.Velocity,$=i.Utilities,s=i.version,o={major:1,minor:1,patch:0};if(n(o,s)){var l="Velocity UI Pack: You need to update Velocity (jquery.velocity.js) to a newer version. Visit http://github.com/julianshapiro/velocity.";throw alert(l),new Error(l)}i.RegisterEffect=i.RegisterUI=function(t,a){function e(t,a,e,r){var n=0,s;$.each(t.nodeType?[t]:t,function(t,a){r&&(e+=t*r),s=a.parentNode,$.each(["height","paddingTop","paddingBottom","marginTop","marginBottom"],function(t,e){n+=parseFloat(i.CSS.getPropertyValue(a,e))})}),i.animate(s,{height:("In"===a?"+":"-")+"="+n},{queue:!1,easing:"ease-in-out",duration:e*("In"===a?.6:1)})}return i.Redirects[t]=function(n,s,o,l,c,u){function f(){s.display!==r&&"none"!==s.display||!/Out$/.test(t)||$.each(c.nodeType?[c]:c,function(t,a){i.CSS.setPropertyValue(a,"display","none")}),s.complete&&s.complete.call(c,c),u&&u.resolver(c||n)}var p=o===l-1;a.defaultDuration="function"==typeof a.defaultDuration?a.defaultDuration.call(c,c):parseFloat(a.defaultDuration);for(var d=0;d1&&($.each(a.reverse(),function(t,e){var r=a[t+1];if(r){var n=e.o||e.options,s=r.o||r.options,o=n&&n.sequenceQueue===!1?"begin":"complete",l=s&&s[o],c={};c[o]=function(){var t=r.e||r.elements,a=t.nodeType?[t]:t;l&&l.call(a,a),i(e)},r.o?r.o=$.extend({},s,c):r.options=$.extend({},s,c)}}),a.reverse()),i(a[0])}}(window.jQuery||window.Zepto||window,window,document)});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fvelocity.min%2F</url>
    <content type="text"><![CDATA[/*! VelocityJS.org (1.2.2). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */ /*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */ !function(e){function t(e){var t=e.length,r=$.type(e);return"function"===r||$.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===r||0===t||"number"==typeof t&&t>0&&t-1 in e}if(!e.jQuery){var $=function(e,t){return new $.fn.init(e,t)};$.isWindow=function(e){return null!=e&&e==e.window},$.type=function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?a[o.call(e)]||"object":typeof e},$.isArray=Array.isArray||function(e){return"array"===$.type(e)},$.isPlainObject=function(e){var t;if(!e||"object"!==$.type(e)||e.nodeType||$.isWindow(e))return!1;try{if(e.constructor&&!n.call(e,"constructor")&&!n.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}for(t in e);return void 0===t||n.call(e,t)},$.each=function(e,r,a){var n,o=0,i=e.length,s=t(e);if(a){if(s)for(;i>o&&(n=r.apply(e[o],a),n!==!1);o++);else for(o in e)if(n=r.apply(e[o],a),n===!1)break}else if(s)for(;i>o&&(n=r.call(e[o],o,e[o]),n!==!1);o++);else for(o in e)if(n=r.call(e[o],o,e[o]),n===!1)break;return e},$.data=function(e,t,a){if(void 0===a){var n=e[$.expando],o=n&&r[n];if(void 0===t)return o;if(o&&t in o)return o[t]}else if(void 0!==t){var n=e[$.expando]||(e[$.expando]=++$.uuid);return r[n]=r[n]||{},r[n][t]=a,a}},$.removeData=function(e,t){var a=e[$.expando],n=a&&r[a];n&&$.each(t,function(e,t){delete n[t]})},$.extend=function(){var e,t,r,a,n,o,i=arguments[0]||{},s=1,l=arguments.length,u=!1;for("boolean"==typeof i&&(u=i,i=arguments[s]||{},s++),"object"!=typeof i&&"function"!==$.type(i)&&(i={}),s===l&&(i=this,s--);l>s;s++)if(null!=(n=arguments[s]))for(a in n)e=i[a],r=n[a],i!==r&&(u&&r&&($.isPlainObject(r)||(t=$.isArray(r)))?(t?(t=!1,o=e&&$.isArray(e)?e:[]):o=e&&$.isPlainObject(e)?e:{},i[a]=$.extend(u,o,r)):void 0!==r&&(i[a]=r));return i},$.queue=function(e,r,a){function n(e,r){var a=r||[];return null!=e&&(t(Object(e))?!function(e,t){for(var r=+t.length,a=0,n=e.length;r>a;)e[n++]=t[a++];if(r!==r)for(;void 0!==t[a];)e[n++]=t[a++];return e.length=n,e}(a,"string"==typeof e?[e]:e):[].push.call(a,e)),a}if(e){r=(r||"fx")+"queue";var o=$.data(e,r);return a?(!o||$.isArray(a)?o=$.data(e,r,n(a)):o.push(a),o):o||[]}},$.dequeue=function(e,t){$.each(e.nodeType?[e]:e,function(e,r){t=t||"fx";var a=$.queue(r,t),n=a.shift();"inprogress"===n&&(n=a.shift()),n&&("fx"===t&&a.unshift("inprogress"),n.call(r,function(){$.dequeue(r,t)}))})},$.fn=$.prototype={init:function(e){if(e.nodeType)return this[0]=e,this;throw new Error("Not a DOM node.")},offset:function(){var t=this[0].getBoundingClientRect?this[0].getBoundingClientRect():{top:0,left:0};return{top:t.top+(e.pageYOffset||document.scrollTop||0)-(document.clientTop||0),left:t.left+(e.pageXOffset||document.scrollLeft||0)-(document.clientLeft||0)}},position:function(){function e(){for(var e=this.offsetParent||document;e&&"html"===!e.nodeType.toLowerCase&&"static"===e.style.position;)e=e.offsetParent;return e||document}var t=this[0],e=e.apply(t),r=this.offset(),a=/^(?:body|html)$/i.test(e.nodeName)?{top:0,left:0}:$(e).offset();return r.top-=parseFloat(t.style.marginTop)||0,r.left-=parseFloat(t.style.marginLeft)||0,e.style&&(a.top+=parseFloat(e.style.borderTopWidth)||0,a.left+=parseFloat(e.style.borderLeftWidth)||0),{top:r.top-a.top,left:r.left-a.left}}};var r={};$.expando="velocity"+(new Date).getTime(),$.uuid=0;for(var a={},n=a.hasOwnProperty,o=a.toString,i="Boolean Number String Function Array Date RegExp Object Error".split(" "),s=0;sn;++n){var o=u(r,e,a);if(0===o)return r;var i=l(r,e,a)-t;r-=i/o}return r}function p(){for(var t=0;b>t;++t)w[t]=l(t*x,e,a)}function f(t,r,n){var o,i,s=0;do i=r+(n-r)/2,o=l(i,e,a)-t,o>0?n=i:r=i;while(Math.abs(o)>h&&++s=y?c(t,s):0==l?s:f(t,r,r+x)}function g(){V=!0,(e!=r||a!=n)&&p()}var m=4,y=.001,h=1e-7,v=10,b=11,x=1/(b-1),S="Float32Array"in t;if(4!==arguments.length)return!1;for(var P=0;4>P;++P)if("number"!=typeof arguments[P]||isNaN(arguments[P])||!isFinite(arguments[P]))return!1;e=Math.min(e,1),a=Math.min(a,1),e=Math.max(e,0),a=Math.max(a,0);var w=S?new Float32Array(b):new Array(b),V=!1,C=function(t){return V||g(),e===r&&a===n?t:0===t?0:1===t?1:l(d(t),r,n)};C.getControlPoints=function(){return[{x:e,y:r},{x:a,y:n}]};var T="generateBezier("+[e,r,a,n]+")";return C.toString=function(){return T},C}function u(e,t){var r=e;return g.isString(e)?v.Easings[e]||(r=!1):r=g.isArray(e)&&1===e.length?s.apply(null,e):g.isArray(e)&&2===e.length?b.apply(null,e.concat([t])):g.isArray(e)&&4===e.length?l.apply(null,e):!1,r===!1&&(r=v.Easings[v.defaults.easing]?v.defaults.easing:h),r}function c(e){if(e){var t=(new Date).getTime(),r=v.State.calls.length;r>1e4&&(v.State.calls=n(v.State.calls));for(var o=0;r>o;o++)if(v.State.calls[o]){var s=v.State.calls[o],l=s[0],u=s[2],f=s[3],d=!!f,m=null;f||(f=v.State.calls[o][3]=t-16);for(var y=Math.min((t-f)/u.duration,1),h=0,b=l.length;b>h;h++){var S=l[h],w=S.element;if(i(w)){var V=!1;if(u.display!==a&&null!==u.display&&"none"!==u.display){if("flex"===u.display){var C=["-webkit-box","-moz-box","-ms-flexbox","-webkit-flex"];$.each(C,function(e,t){x.setPropertyValue(w,"display",t)})}x.setPropertyValue(w,"display",u.display)}u.visibility!==a&&"hidden"!==u.visibility&&x.setPropertyValue(w,"visibility",u.visibility);for(var T in S)if("element"!==T){var k=S[T],A,F=g.isString(k.easing)?v.Easings[k.easing]:k.easing;if(1===y)A=k.endValue;else{var E=k.endValue-k.startValue;if(A=k.startValue+E*F(y,u,E),!d&&A===k.currentValue)continue}if(k.currentValue=A,"tween"===T)m=A;else{if(x.Hooks.registered[T]){var j=x.Hooks.getRoot(T),H=i(w).rootPropertyValueCache[j];H&&(k.rootPropertyValue=H)}var N=x.setPropertyValue(w,T,k.currentValue+(0===parseFloat(A)?"":k.unitType),k.rootPropertyValue,k.scrollData);x.Hooks.registered[T]&&(i(w).rootPropertyValueCache[j]=x.Normalizations.registered[j]?x.Normalizations.registered[j]("extract",null,N[1]):N[1]),"transform"===N[0]&&(V=!0)}}u.mobileHA&&i(w).transformCache.translate3d===a&&(i(w).transformCache.translate3d="(0px, 0px, 0px)",V=!0),V&&x.flushTransformCache(w)}}u.display!==a&&"none"!==u.display&&(v.State.calls[o][2].display=!1),u.visibility!==a&&"hidden"!==u.visibility&&(v.State.calls[o][2].visibility=!1),u.progress&&u.progress.call(s[1],s[1],y,Math.max(0,f+u.duration-t),f,m),1===y&&p(o)}}v.State.isTicking&&P(c)}function p(e,t){if(!v.State.calls[e])return!1;for(var r=v.State.calls[e][0],n=v.State.calls[e][1],o=v.State.calls[e][2],s=v.State.calls[e][4],l=!1,u=0,c=r.length;c>u;u++){var p=r[u].element;if(t||o.loop||("none"===o.display&&x.setPropertyValue(p,"display",o.display),"hidden"===o.visibility&&x.setPropertyValue(p,"visibility",o.visibility)),o.loop!==!0&&($.queue(p)[1]===a||!/\.velocityQueueEntryFlag/i.test($.queue(p)[1]))&&i(p)){i(p).isAnimating=!1,i(p).rootPropertyValueCache={};var f=!1;$.each(x.Lists.transforms3D,function(e,t){var r=/^scale/.test(t)?1:0,n=i(p).transformCache[t];i(p).transformCache[t]!==a&&new RegExp("^\\("+r+"[^.]").test(n)&&(f=!0,delete i(p).transformCache[t])}),o.mobileHA&&(f=!0,delete i(p).transformCache.translate3d),f&&x.flushTransformCache(p),x.Values.removeClass(p,"velocity-animating")}if(!t&&o.complete&&!o.loop&&u===c-1)try{o.complete.call(n,n)}catch(d){setTimeout(function(){throw d},1)}s&&o.loop!==!0&&s(n),i(p)&&o.loop===!0&&!t&&($.each(i(p).tweensContainer,function(e,t){/^rotate/.test(e)&&360===parseFloat(t.endValue)&&(t.endValue=0,t.startValue=360),/^backgroundPosition/.test(e)&&100===parseFloat(t.endValue)&&"%"===t.unitType&&(t.endValue=0,t.startValue=100)}),v(p,"reverse",{loop:!0,delay:o.delay})),o.queue!==!1&&$.dequeue(p,o.queue)}v.State.calls[e]=!1;for(var g=0,m=v.State.calls.length;m>g;g++)if(v.State.calls[g]!==!1){l=!0;break}l===!1&&(v.State.isTicking=!1,delete v.State.calls,v.State.calls=[])}var f=function(){if(r.documentMode)return r.documentMode;for(var e=7;e>4;e--){var t=r.createElement("div");if(t.innerHTML="",t.getElementsByTagName("span").length)return t=null,e}return a}(),d=function(){var e=0;return t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||function(t){var r=(new Date).getTime(),a;return a=Math.max(0,16-(r-e)),e=r+a,setTimeout(function(){t(r+a)},a)}}(),g={isString:function(e){return"string"==typeof e},isArray:Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},isFunction:function(e){return"[object Function]"===Object.prototype.toString.call(e)},isNode:function(e){return e&&e.nodeType},isNodeList:function(e){return"object"==typeof e&&/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e))&&e.length!==a&&(0===e.length||"object"==typeof e[0]&&e[0].nodeType>0)},isWrapped:function(e){return e&&(e.jquery||t.Zepto&&t.Zepto.zepto.isZ(e))},isSVG:function(e){return t.SVGElement&&e instanceof t.SVGElement},isEmptyObject:function(e){for(var t in e)return!1;return!0}},$,m=!1;if(e.fn&&e.fn.jquery?($=e,m=!0):$=t.Velocity.Utilities,8>=f&&!m)throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");if(7>=f)return void(jQuery.fn.velocity=jQuery.fn.animate);var y=400,h="swing",v={State:{isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),isAndroid:/Android/i.test(navigator.userAgent),isGingerbread:/Android 2\.3\.[3-7]/i.test(navigator.userAgent),isChrome:t.chrome,isFirefox:/Firefox/i.test(navigator.userAgent),prefixElement:r.createElement("div"),prefixMatches:{},scrollAnchor:null,scrollPropertyLeft:null,scrollPropertyTop:null,isTicking:!1,calls:[]},CSS:{},Utilities:$,Redirects:{},Easings:{},Promise:t.Promise,defaults:{queue:"",duration:y,easing:h,begin:a,complete:a,progress:a,display:a,visibility:a,loop:!1,delay:!1,mobileHA:!0,_cacheValues:!0},init:function(e){$.data(e,"velocity",{isSVG:g.isSVG(e),isAnimating:!1,computedStyle:null,tweensContainer:null,rootPropertyValueCache:{},transformCache:{}})},hook:null,mock:!1,version:{major:1,minor:2,patch:2},debug:!1};t.pageYOffset!==a?(v.State.scrollAnchor=t,v.State.scrollPropertyLeft="pageXOffset",v.State.scrollPropertyTop="pageYOffset"):(v.State.scrollAnchor=r.documentElement||r.body.parentNode||r.body,v.State.scrollPropertyLeft="scrollLeft",v.State.scrollPropertyTop="scrollTop");var b=function(){function e(e){return-e.tension*e.x-e.friction*e.v}function t(t,r,a){var n={x:t.x+a.dx*r,v:t.v+a.dv*r,tension:t.tension,friction:t.friction};return{dx:n.v,dv:e(n)}}function r(r,a){var n={dx:r.v,dv:e(r)},o=t(r,.5*a,n),i=t(r,.5*a,o),s=t(r,a,i),l=1/6*(n.dx+2*(o.dx+i.dx)+s.dx),u=1/6*(n.dv+2*(o.dv+i.dv)+s.dv);return r.x=r.x+l*a,r.v=r.v+u*a,r}return function a(e,t,n){var o={x:-1,v:0,tension:null,friction:null},i=[0],s=0,l=1e-4,u=.016,c,p,f;for(e=parseFloat(e)||500,t=parseFloat(t)||20,n=n||null,o.tension=e,o.friction=t,c=null!==n,c?(s=a(e,t),p=s/n*u):p=u;;)if(f=r(f||o,p),i.push(1+f.x),s+=16,!(Math.abs(f.x)>l&&Math.abs(f.v)>l))break;return c?function(e){return i[e*(i.length-1)|0]}:s}}();v.Easings={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},spring:function(e){return 1-Math.cos(4.5*e*Math.PI)*Math.exp(6*-e)}},$.each([["ease",[.25,.1,.25,1]],["ease-in",[.42,0,1,1]],["ease-out",[0,0,.58,1]],["ease-in-out",[.42,0,.58,1]],["easeInSine",[.47,0,.745,.715]],["easeOutSine",[.39,.575,.565,1]],["easeInOutSine",[.445,.05,.55,.95]],["easeInQuad",[.55,.085,.68,.53]],["easeOutQuad",[.25,.46,.45,.94]],["easeInOutQuad",[.455,.03,.515,.955]],["easeInCubic",[.55,.055,.675,.19]],["easeOutCubic",[.215,.61,.355,1]],["easeInOutCubic",[.645,.045,.355,1]],["easeInQuart",[.895,.03,.685,.22]],["easeOutQuart",[.165,.84,.44,1]],["easeInOutQuart",[.77,0,.175,1]],["easeInQuint",[.755,.05,.855,.06]],["easeOutQuint",[.23,1,.32,1]],["easeInOutQuint",[.86,0,.07,1]],["easeInExpo",[.95,.05,.795,.035]],["easeOutExpo",[.19,1,.22,1]],["easeInOutExpo",[1,0,0,1]],["easeInCirc",[.6,.04,.98,.335]],["easeOutCirc",[.075,.82,.165,1]],["easeInOutCirc",[.785,.135,.15,.86]]],function(e,t){v.Easings[t[0]]=l.apply(null,t[1])});var x=v.CSS={RegEx:{isHex:/^#([A-f\d]{3}){1,2}$/i,valueUnwrap:/^[A-z]+\((.*)\)$/i,wrappedValueAlreadyExtracted:/[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,valueSplit:/([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi},Lists:{colors:["fill","stroke","stopColor","color","backgroundColor","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","outlineColor"],transformsBase:["translateX","translateY","scale","scaleX","scaleY","skewX","skewY","rotateZ"],transforms3D:["transformPerspective","translateZ","scaleZ","rotateX","rotateY"]},Hooks:{templates:{textShadow:["Color X Y Blur","black 0px 0px 0px"],boxShadow:["Color X Y Blur Spread","black 0px 0px 0px 0px"],clip:["Top Right Bottom Left","0px 0px 0px 0px"],backgroundPosition:["X Y","0% 0%"],transformOrigin:["X Y Z","50% 50% 0px"],perspectiveOrigin:["X Y","50% 50%"]},registered:{},register:function(){for(var e=0;e=f)switch(e){case"name":return"filter";case"extract":var a=r.toString().match(/alpha\(opacity=(.*)\)/i);return r=a?a[1]/100:1;case"inject":return t.style.zoom=1,parseFloat(r)>=1?"":"alpha(opacity="+parseInt(100*parseFloat(r),10)+")"}else switch(e){case"name":return"opacity";case"extract":return r;case"inject":return r}}},register:function(){9>=f||v.State.isGingerbread||(x.Lists.transformsBase=x.Lists.transformsBase.concat(x.Lists.transforms3D));for(var e=0;en&&(n=1),o=!/(\d)$/i.test(n);break;case"skew":o=!/(deg|\d)$/i.test(n);break;case"rotate":o=!/(deg|\d)$/i.test(n)}return o||(i(r).transformCache[t]="("+n+")"),i(r).transformCache[t]}}}();for(var e=0;e=f||3!==o.split(" ").length||(o+=" 1"),o;case"inject":return 8>=f?4===n.split(" ").length&&(n=n.split(/\s+/).slice(0,3).join(" ")):3===n.split(" ").length&&(n+=" 1"),(8>=f?"rgb":"rgba")+"("+n.replace(/\s+/g,",").replace(/\.(\d)+(?=,)/g,"")+")"}}}()}},Names:{camelCase:function(e){return e.replace(/-(\w)/g,function(e,t){return t.toUpperCase()})},SVGAttribute:function(e){var t="width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";return(f||v.State.isAndroid&&!v.State.isChrome)&&(t+="|transform"),new RegExp("^("+t+")$","i").test(e)},prefixCheck:function(e){if(v.State.prefixMatches[e])return[v.State.prefixMatches[e],!0];for(var t=["","Webkit","Moz","ms","O"],r=0,a=t.length;a>r;r++){var n;if(n=0===r?e:t[r]+e.replace(/^\w/,function(e){return e.toUpperCase()}),g.isString(v.State.prefixElement.style[n]))return v.State.prefixMatches[e]=n,[n,!0]}return[e,!1]}},Values:{hexToRgb:function(e){var t=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,a;return e=e.replace(t,function(e,t,r,a){return t+t+r+r+a+a}),a=r.exec(e),a?[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16)]:[0,0,0]},isCSSNullValue:function(e){return 0==e||/^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)},getUnitType:function(e){return/^(rotate|skew)/i.test(e)?"deg":/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e)?"":"px"},getDisplayType:function(e){var t=e&&e.tagName.toString().toLowerCase();return/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t)?"inline":/^(li)$/i.test(t)?"list-item":/^(tr)$/i.test(t)?"table-row":/^(table)$/i.test(t)?"table":/^(tbody)$/i.test(t)?"table-row-group":"block"},addClass:function(e,t){e.classList?e.classList.add(t):e.className+=(e.className.length?" ":"")+t},removeClass:function(e,t){e.classList?e.classList.remove(t):e.className=e.className.toString().replace(new RegExp("(^|\\s)"+t.split(" ").join("|")+"(\\s|$)","gi")," ")}},getPropertyValue:function(e,r,n,o){function s(e,r){function n(){u&&x.setPropertyValue(e,"display","none")}var l=0;if(8>=f)l=$.css(e,r);else{var u=!1;if(/^(width|height)$/.test(r)&&0===x.getPropertyValue(e,"display")&&(u=!0,x.setPropertyValue(e,"display",x.Values.getDisplayType(e))),!o){if("height"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var c=e.offsetHeight-(parseFloat(x.getPropertyValue(e,"borderTopWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderBottomWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingTop"))||0)-(parseFloat(x.getPropertyValue(e,"paddingBottom"))||0);return n(),c}if("width"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var p=e.offsetWidth-(parseFloat(x.getPropertyValue(e,"borderLeftWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderRightWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingLeft"))||0)-(parseFloat(x.getPropertyValue(e,"paddingRight"))||0);return n(),p}}var d;d=i(e)===a?t.getComputedStyle(e,null):i(e).computedStyle?i(e).computedStyle:i(e).computedStyle=t.getComputedStyle(e,null),"borderColor"===r&&(r="borderTopColor"),l=9===f&&"filter"===r?d.getPropertyValue(r):d[r],(""===l||null===l)&&(l=e.style[r]),n()}if("auto"===l&&/^(top|right|bottom|left)$/i.test(r)){var g=s(e,"position");("fixed"===g||"absolute"===g&&/top|left/i.test(r))&&(l=$(e).position()[r]+"px")}return l}var l;if(x.Hooks.registered[r]){var u=r,c=x.Hooks.getRoot(u);n===a&&(n=x.getPropertyValue(e,x.Names.prefixCheck(c)[0])),x.Normalizations.registered[c]&&(n=x.Normalizations.registered[c]("extract",e,n)),l=x.Hooks.extractValue(u,n)}else if(x.Normalizations.registered[r]){var p,d;p=x.Normalizations.registered[r]("name",e),"transform"!==p&&(d=s(e,x.Names.prefixCheck(p)[0]),x.Values.isCSSNullValue(d)&&x.Hooks.templates[r]&&(d=x.Hooks.templates[r][1])),l=x.Normalizations.registered[r]("extract",e,d)}if(!/^[\d-]/.test(l))if(i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r))if(/^(height|width)$/i.test(r))try{l=e.getBBox()[r]}catch(g){l=0}else l=e.getAttribute(r);else l=s(e,x.Names.prefixCheck(r)[0]);return x.Values.isCSSNullValue(l)&&(l=0),v.debug>=2&&console.log("Get "+r+": "+l),l},setPropertyValue:function(e,r,a,n,o){var s=r;if("scroll"===r)o.container?o.container["scroll"+o.direction]=a:"Left"===o.direction?t.scrollTo(a,o.alternateValue):t.scrollTo(o.alternateValue,a);else if(x.Normalizations.registered[r]&&"transform"===x.Normalizations.registered[r]("name",e))x.Normalizations.registered[r]("inject",e,a),s="transform",a=i(e).transformCache[r];else{if(x.Hooks.registered[r]){var l=r,u=x.Hooks.getRoot(r);n=n||x.getPropertyValue(e,u),a=x.Hooks.injectValue(l,a,n),r=u}if(x.Normalizations.registered[r]&&(a=x.Normalizations.registered[r]("inject",e,a),r=x.Normalizations.registered[r]("name",e)),s=x.Names.prefixCheck(r)[0],8>=f)try{e.style[s]=a}catch(c){v.debug&&console.log("Browser does not support ["+a+"] for ["+s+"]")}else i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r)?e.setAttribute(r,a):e.style[s]=a;v.debug>=2&&console.log("Set "+r+" ("+s+"): "+a)}return[s,a]},flushTransformCache:function(e){function t(t){return parseFloat(x.getPropertyValue(e,t))}var r="";if((f||v.State.isAndroid&&!v.State.isChrome)&&i(e).isSVG){var a={translate:[t("translateX"),t("translateY")],skewX:[t("skewX")],skewY:[t("skewY")],scale:1!==t("scale")?[t("scale"),t("scale")]:[t("scaleX"),t("scaleY")],rotate:[t("rotateZ"),0,0]};$.each(i(e).transformCache,function(e){/^translate/i.test(e)?e="translate":/^scale/i.test(e)?e="scale":/^rotate/i.test(e)&&(e="rotate"),a[e]&&(r+=e+"("+a[e].join(" ")+") ",delete a[e])})}else{var n,o;$.each(i(e).transformCache,function(t){return n=i(e).transformCache[t],"transformPerspective"===t?(o=n,!0):(9===f&&"rotateZ"===t&&(t="rotate"),void(r+=t+n+" "))}),o&&(r="perspective"+o+" "+r)}x.setPropertyValue(e,"transform",r)}};x.Hooks.register(),x.Normalizations.register(),v.hook=function(e,t,r){var n=a;return e=o(e),$.each(e,function(e,o){if(i(o)===a&&v.init(o),r===a)n===a&&(n=v.CSS.getPropertyValue(o,t));else{var s=v.CSS.setPropertyValue(o,t,r);"transform"===s[0]&&v.CSS.flushTransformCache(o),n=s}}),n};var S=function(){function e(){return l?T.promise||null:f}function n(){function e(e){function p(e,t){var r=a,i=a,s=a;return g.isArray(e)?(r=e[0],!g.isArray(e[1])&&/^[\d-]/.test(e[1])||g.isFunction(e[1])||x.RegEx.isHex.test(e[1])?s=e[1]:(g.isString(e[1])&&!x.RegEx.isHex.test(e[1])||g.isArray(e[1]))&&(i=t?e[1]:u(e[1],o.duration),e[2]!==a&&(s=e[2]))):r=e,t||(i=i||o.easing),g.isFunction(r)&&(r=r.call(n,w,P)),g.isFunction(s)&&(s=s.call(n,w,P)),[r||0,i,s]}function f(e,t){var r,a;return a=(t||"0").toString().toLowerCase().replace(/[%A-z]+$/,function(e){return r=e,""}),r||(r=x.Values.getUnitType(e)),[a,r]}function d(){var e={myParent:n.parentNode||r.body,position:x.getPropertyValue(n,"position"),fontSize:x.getPropertyValue(n,"fontSize")},a=e.position===N.lastPosition&&e.myParent===N.lastParent,o=e.fontSize===N.lastFontSize;N.lastParent=e.myParent,N.lastPosition=e.position,N.lastFontSize=e.fontSize;var s=100,l={};if(o&&a)l.emToPx=N.lastEmToPx,l.percentToPxWidth=N.lastPercentToPxWidth,l.percentToPxHeight=N.lastPercentToPxHeight;else{var u=i(n).isSVG?r.createElementNS("http://www.w3.org/2000/svg","rect"):r.createElement("div");v.init(u),e.myParent.appendChild(u),$.each(["overflow","overflowX","overflowY"],function(e,t){v.CSS.setPropertyValue(u,t,"hidden")}),v.CSS.setPropertyValue(u,"position",e.position),v.CSS.setPropertyValue(u,"fontSize",e.fontSize),v.CSS.setPropertyValue(u,"boxSizing","content-box"),$.each(["minWidth","maxWidth","width","minHeight","maxHeight","height"],function(e,t){v.CSS.setPropertyValue(u,t,s+"%")}),v.CSS.setPropertyValue(u,"paddingLeft",s+"em"),l.percentToPxWidth=N.lastPercentToPxWidth=(parseFloat(x.getPropertyValue(u,"width",null,!0))||1)/s,l.percentToPxHeight=N.lastPercentToPxHeight=(parseFloat(x.getPropertyValue(u,"height",null,!0))||1)/s,l.emToPx=N.lastEmToPx=(parseFloat(x.getPropertyValue(u,"paddingLeft"))||1)/s,e.myParent.removeChild(u)}return null===N.remToPx&&(N.remToPx=parseFloat(x.getPropertyValue(r.body,"fontSize"))||16),null===N.vwToPx&&(N.vwToPx=parseFloat(t.innerWidth)/100,N.vhToPx=parseFloat(t.innerHeight)/100),l.remToPx=N.remToPx,l.vwToPx=N.vwToPx,l.vhToPx=N.vhToPx,v.debug>=1&&console.log("Unit ratios: "+JSON.stringify(l),n),l}if(o.begin&&0===w)try{o.begin.call(m,m)}catch(y){setTimeout(function(){throw y},1)}if("scroll"===k){var S=/^x$/i.test(o.axis)?"Left":"Top",V=parseFloat(o.offset)||0,C,A,F;o.container?g.isWrapped(o.container)||g.isNode(o.container)?(o.container=o.container[0]||o.container,C=o.container["scroll"+S],F=C+$(n).position()[S.toLowerCase()]+V):o.container=null:(C=v.State.scrollAnchor[v.State["scrollProperty"+S]],A=v.State.scrollAnchor[v.State["scrollProperty"+("Left"===S?"Top":"Left")]],F=$(n).offset()[S.toLowerCase()]+V),s={scroll:{rootPropertyValue:!1,startValue:C,currentValue:C,endValue:F,unitType:"",easing:o.easing,scrollData:{container:o.container,direction:S,alternateValue:A}},element:n},v.debug&&console.log("tweensContainer (scroll): ",s.scroll,n)}else if("reverse"===k){if(!i(n).tweensContainer)return void $.dequeue(n,o.queue);"none"===i(n).opts.display&&(i(n).opts.display="auto"),"hidden"===i(n).opts.visibility&&(i(n).opts.visibility="visible"),i(n).opts.loop=!1,i(n).opts.begin=null,i(n).opts.complete=null,b.easing||delete o.easing,b.duration||delete o.duration,o=$.extend({},i(n).opts,o);var E=$.extend(!0,{},i(n).tweensContainer);for(var j in E)if("element"!==j){var H=E[j].startValue;E[j].startValue=E[j].currentValue=E[j].endValue,E[j].endValue=H,g.isEmptyObject(b)||(E[j].easing=o.easing),v.debug&&console.log("reverse tweensContainer ("+j+"): "+JSON.stringify(E[j]),n)}s=E}else if("start"===k){var E;i(n).tweensContainer&&i(n).isAnimating===!0&&(E=i(n).tweensContainer),$.each(h,function(e,t){if(RegExp("^"+x.Lists.colors.join("$|^")+"$").test(e)){var r=p(t,!0),n=r[0],o=r[1],i=r[2];if(x.RegEx.isHex.test(n)){for(var s=["Red","Green","Blue"],l=x.Values.hexToRgb(n),u=i?x.Values.hexToRgb(i):a,c=0;cO;O++){var z={delay:F.delay,progress:F.progress};O===R-1&&(z.display=F.display,z.visibility=F.visibility,z.complete=F.complete),S(m,"reverse",z)}return e()}};v=$.extend(S,v),v.animate=S;var P=t.requestAnimationFrame||d;return v.State.isMobile||r.hidden===a||r.addEventListener("visibilitychange",function(){r.hidden?(P=function(e){return setTimeout(function(){e(!0)},16)},c()):P=t.requestAnimationFrame||d}),e.Velocity=v,e!==t&&(e.fn.velocity=S,e.fn.velocity.defaults=v.defaults),$.each(["Down","Up"],function(e,t){v.Redirects["slide"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u=l.begin,c=l.complete,p={height:"",marginTop:"",marginBottom:"",paddingTop:"",paddingBottom:""},f={};l.display===a&&(l.display="Down"===t?"inline"===v.CSS.Values.getDisplayType(e)?"inline-block":"block":"none"),l.begin=function(){u&&u.call(i,i);for(var r in p){f[r]=e.style[r];var a=v.CSS.getPropertyValue(e,r);p[r]="Down"===t?[a,0]:[0,a]}f.overflow=e.style.overflow,e.style.overflow="hidden"},l.complete=function(){for(var t in f)e.style[t]=f[t];c&&c.call(i,i),s&&s.resolver(i)},v(e,p,l)}}),$.each(["In","Out"],function(e,t){v.Redirects["fade"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u={opacity:"In"===t?1:0},c=l.complete;l.complete=n!==o-1?l.begin=null:function(){c&&c.call(i,i),s&&s.resolver(i)},l.display===a&&(l.display="In"===t?"auto":"none"),v(this,u,l)}}),v}(window.jQuery||window.Zepto||window,window,document)});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Findex%2F</url>
    <content type="text"><![CDATA[/*! jQuery v2.1.3 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.3",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=hb(),z=hb(),A=hb(),B=function(a,b){return a===b&&(l=!0),0},C=1]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fmain%2F</url>
    <content type="text"><![CDATA[/* normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */ html { line-height: 1.15; /* 1 */ -webkit-text-size-adjust: 100%; /* 2 */ } body { margin: 0; } main { display: block; } h1 { font-size: 2em; margin: 0.67em 0; } hr { box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */ } pre { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } a { background-color: transparent; } abbr[title] { border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */ } b, strong { font-weight: bolder; } code, kbd, samp { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sub { bottom: -0.25em; } sup { top: -0.5em; } img { border-style: none; } button, input, optgroup, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */ } button, input { /* 1 */ overflow: visible; } button, select { /* 1 */ text-transform: none; } button, [type="button"], [type="reset"], [type="submit"] { -webkit-appearance: button; } button::-moz-focus-inner, [type="button"]::-moz-focus-inner, [type="reset"]::-moz-focus-inner, [type="submit"]::-moz-focus-inner { border-style: none; padding: 0; } button:-moz-focusring, [type="button"]:-moz-focusring, [type="reset"]:-moz-focusring, [type="submit"]:-moz-focusring { outline: 1px dotted ButtonText; } fieldset { padding: 0.35em 0.75em 0.625em; } legend { box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */ } progress { vertical-align: baseline; } textarea { overflow: auto; } [type="checkbox"], [type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ } [type="number"]::-webkit-inner-spin-button, [type="number"]::-webkit-outer-spin-button { height: auto; } [type="search"] { -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */ } [type="search"]::-webkit-search-decoration { -webkit-appearance: none; } ::-webkit-file-upload-button { -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */ } details { display: block; } summary { display: list-item; } template { display: none; } [hidden] { display: none; } ::selection { background: #262a30; color: #fff; } body { position: relative; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; font-size: 14px; line-height: 2; color: #555; background: #f5f7f9; } @media (max-width: 991px) { body { padding-right: 0 !important; } } @media (min-width: 1200px) { body { font-size: 16px; } } h1, h2, h3, h4, h5, h6 { margin: 20px 0 15px; padding: 0; font-weight: bold; line-height: 1.5; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; } h1 { font-size: 22px; } h1 code { font-size: 1em; } @media (max-width: 767px) { h1 { font-size: 18px; } h1 code { font-size: 1em; } } h2 { font-size: 20px; } h2 code { font-size: 1em; } @media (max-width: 767px) { h2 { font-size: 16px; } h2 code { font-size: 1em; } } h3 { font-size: 18px; } h3 code { font-size: 1em; } @media (max-width: 767px) { h3 { font-size: 14px; } h3 code { font-size: 1em; } } h4 { font-size: 16px; } h4 code { font-size: 1em; } @media (max-width: 767px) { h4 { font-size: 12px; } h4 code { font-size: 1em; } } h5 { font-size: 14px; } h5 code { font-size: 1em; } @media (max-width: 767px) { h5 { font-size: 10px; } h5 code { font-size: 1em; } } h6 { font-size: 12px; } h6 code { font-size: 1em; } @media (max-width: 767px) { h6 { font-size: 8px; } h6 code { font-size: 1em; } } p { margin: 0 0 20px 0; } a, span.exturl { overflow-wrap: break-word; word-wrap: break-word; background-color: transparent; color: #555; text-decoration: none; outline: none; border-bottom: 1px solid #999; cursor: pointer; } a:hover, span.exturl:hover { color: #222; border-bottom-color: #222; } video { max-width: 100%; display: block; margin-left: auto; margin-right: auto; } img { display: block; margin: auto; max-width: 100%; height: auto; } hr { margin: 40px 0; height: 3px; border: none; background-color: #ddd; background-image: repeating-linear-gradient(-45deg, #fff, #fff 4px, transparent 4px, transparent 8px); } blockquote { margin: 0; padding: 0 15px; color: #666; border-left: 4px solid #ddd; } blockquote cite::before { content: "-"; padding: 0 5px; } dt { font-weight: 700; } dd { margin: 0; padding: 0; } kbd { border: 1px solid #ccc; border-radius: 0.2em; box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); background-color: #f9f9f9; font-family: inherit; background-image: linear-gradient(top, #eee, #fff, #eee); padding: 0.1em 0.3em; white-space: nowrap; } .text-left { text-align: left; } .text-center { text-align: center; } .text-right { text-align: right; } .text-justify { text-align: justify; } .text-nowrap { white-space: nowrap; } .text-lowercase { text-transform: lowercase; } .text-uppercase { text-transform: uppercase; } .text-capitalize { text-transform: capitalize; } .center-block { display: block; margin-left: auto; margin-right: auto; } .clearfix:before, .clearfix:after { content: " "; display: table; } .clearfix:after { clear: both; } .pullquote { width: 45%; } .pullquote.left { float: left; margin-left: 5px; margin-right: 10px; } .pullquote.right { float: right; margin-left: 10px; margin-right: 5px; } .affix { position: fixed; } .translation { margin-top: -20px; font-size: 14px; color: #999; } .scrollbar-measure { width: 100px; height: 100px; overflow: scroll; position: absolute; top: -9999px; } .use-motion .motion-element { opacity: 0; } .table-container { margin: 20px 0; overflow: auto; -webkit-overflow-scrolling: touch; } table { width: 100%; border-collapse: collapse; border-spacing: 0; font-size: 14px; } table > tbody > tr:nth-of-type(odd) { background-color: #f9f9f9; } table > tbody > tr:hover { background-color: #f5f5f5; } caption, th, td { padding: 8px; text-align: left; vertical-align: middle; font-weight: normal; } th, td { border: 1px solid #ddd; border-bottom: 3px solid #ddd; } th { padding-bottom: 10px; font-weight: 700; } td { border-bottom-width: 1px; } html, body { height: 100%; } .container { position: relative; } .header-inner { margin: 0 auto; padding: 100px 0 70px; width: calc(100% - 20px); } @media (min-width: 1200px) { .container .header-inner { width: 1160px; } } @media (min-width: 1600px) { .container .header-inner { width: 73%; } } .main-inner { margin: 0 auto; width: calc(100% - 20px); } @media (min-width: 1200px) { .container .main-inner { width: 1160px; } } @media (min-width: 1600px) { .container .main-inner { width: 73%; } } .footer { padding: 20px 0; } .footer-inner { box-sizing: border-box; margin: 0px auto; width: calc(100% - 20px); } @media (min-width: 1200px) { .container .footer-inner { width: 1160px; } } @media (min-width: 1600px) { .container .footer-inner { width: 73%; } } pre, .highlight { overflow: auto; margin: 20px 0; padding: 0; font-size: 14px; color: #eaeaea; background: #000; line-height: 1.6; } pre, code { font-family: consolas, Menlo, "PingFang SC", "Microsoft YaHei", monospace; } code { overflow-wrap: break-word; word-wrap: break-word; padding: 2px 4px; color: #555; background: #eee; border-radius: 3px; font-size: 14px; } pre { padding: 10px; } pre code { padding: 0; color: #eaeaea; background: none; text-shadow: none; } .highlight { border-radius: 1px; } .highlight pre { border: none; margin: 0; padding: 10px 0; } .highlight table { margin: 0; width: auto; border: none; } .highlight td { border: none; padding: 0; } .highlight figcaption { font-size: 1em; color: #eaeaea; line-height: 1em; margin-bottom: 1em; margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9; } .highlight figcaption:before, .highlight figcaption:after { content: " "; display: table; } .highlight figcaption:after { clear: both; } .highlight figcaption a { float: right; color: #eaeaea; } .highlight figcaption a:hover { border-bottom-color: #eaeaea; } .highlight .gutter pre { padding-left: 10px; padding-right: 10px; color: #666; text-align: right; background-color: #292929; } .highlight .code pre { width: 100%; padding-left: 10px; padding-right: 10px; background-color: #000; } .highlight .line { height: 20px; } .gutter { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .gist table { width: auto; } .gist table td { border: none; } pre .deletion { background: #800000; } pre .addition { background: #008000; } pre .meta { color: #c397d8; } pre .comment { color: #969896; } pre .variable, pre .attribute, pre .tag, pre .name, pre .regexp, pre .ruby .constant, pre .xml .tag .title, pre .xml .pi, pre .xml .doctype, pre .html .doctype, pre .css .id, pre .css .class, pre .css .pseudo { color: #d54e53; } pre .number, pre .preprocessor, pre .built_in, pre .builtin-name, pre .literal, pre .params, pre .constant, pre .command { color: #e78c45; } pre .ruby .class .title, pre .css .rules .attribute, pre .string, pre .symbol, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata, pre .special, pre .formula { color: #b9ca4a; } pre .title, pre .css .hexcolor { color: #70c0b1; } pre .function, pre .python .decorator, pre .python .title, pre .ruby .function .title, pre .ruby .title .keyword, pre .perl .sub, pre .javascript .title, pre .coffeescript .title { color: #7aa6da; } pre .keyword, pre .javascript .function { color: #c397d8; } .posts-expand .post-body img.full-image { border: none; } .blockquote-center, .page-home .post-type-quote blockquote, .page-post-detail .post-type-quote blockquote { position: relative; margin: 40px 0; padding: 0; border-left: none; text-align: center; } .blockquote-center::before, .page-home .post-type-quote blockquote::before, .page-post-detail .post-type-quote blockquote::before, .blockquote-center::after, .page-home .post-type-quote blockquote::after, .page-post-detail .post-type-quote blockquote::after { position: absolute; content: ' '; display: block; width: 100%; height: 24px; opacity: 0.2; background-repeat: no-repeat; background-position: 0 -6px; background-size: 22px 22px; } .blockquote-center::before, .page-home .post-type-quote blockquote::before, .page-post-detail .post-type-quote blockquote::before { top: -20px; background-image: url("../images/quote-l.svg"); border-top: 1px solid #ccc; } .blockquote-center::after, .page-home .post-type-quote blockquote::after, .page-post-detail .post-type-quote blockquote::after { bottom: -20px; background-image: url("../images/quote-r.svg"); border-bottom: 1px solid #ccc; background-position: 100% 8px; } .blockquote-center p, .page-home .post-type-quote blockquote p, .page-post-detail .post-type-quote blockquote p, .blockquote-center div, .page-home .post-type-quote blockquote div, .page-post-detail .post-type-quote blockquote div { text-align: center; } .post .post-body .group-picture img { box-sizing: border-box; padding: 0 3px; border: none; } .post .group-picture-row { overflow: hidden; margin-top: 6px; } .post .group-picture-row:first-child { margin-top: 0; } .post .group-picture-column { float: left; } .page-post-detail .post-body .group-picture-column { float: none; margin-top: 10px; width: auto !important; } .page-post-detail .post-body .group-picture-column img { margin: 0 auto; } .page-archive .group-picture-container { overflow: hidden; } .page-archive .group-picture-row { float: left; } .page-archive .group-picture-row:first-child { margin-top: 6px; } .page-archive .group-picture-column { max-width: 150px; max-height: 150px; } .post-body .label { display: inline; padding: 0 2px; white-space: nowrap; } .post-body .label.default { background-color: #f0f0f0; } .post-body .label.primary { background-color: #efe6f7; } .post-body .label.info { background-color: #e5f2f8; } .post-body .label.success { background-color: #e7f4e9; } .post-body .label.warning { background-color: #fcf6e1; } .post-body .label.danger { background-color: #fae8eb; } .post-body .note { position: relative; padding: 15px; margin-bottom: 20px; border: 1px solid #eee; border-left-width: 5px; border-radius: 3px; } .post-body .note h2, .post-body .note h3, .post-body .note h4, .post-body .note h5, .post-body .note h6 { margin-top: 0; margin-bottom: 0; border-bottom: initial; padding-top: 0 !important; } .post-body .note p:first-child, .post-body .note ul:first-child, .post-body .note ol:first-child, .post-body .note table:first-child, .post-body .note pre:first-child, .post-body .note blockquote:first-child { margin-top: 0; } .post-body .note p:last-child, .post-body .note ul:last-child, .post-body .note ol:last-child, .post-body .note table:last-child, .post-body .note pre:last-child, .post-body .note blockquote:last-child { margin-bottom: 0; } .post-body .note.default { border-left-color: #777; } .post-body .note.default h2, .post-body .note.default h3, .post-body .note.default h4, .post-body .note.default h5, .post-body .note.default h6 { color: #777; } .post-body .note.primary { border-left-color: #6f42c1; } .post-body .note.primary h2, .post-body .note.primary h3, .post-body .note.primary h4, .post-body .note.primary h5, .post-body .note.primary h6 { color: #6f42c1; } .post-body .note.info { border-left-color: #428bca; } .post-body .note.info h2, .post-body .note.info h3, .post-body .note.info h4, .post-body .note.info h5, .post-body .note.info h6 { color: #428bca; } .post-body .note.success { border-left-color: #5cb85c; } .post-body .note.success h2, .post-body .note.success h3, .post-body .note.success h4, .post-body .note.success h5, .post-body .note.success h6 { color: #5cb85c; } .post-body .note.warning { border-left-color: #f0ad4e; } .post-body .note.warning h2, .post-body .note.warning h3, .post-body .note.warning h4, .post-body .note.warning h5, .post-body .note.warning h6 { color: #f0ad4e; } .post-body .note.danger { border-left-color: #d9534f; } .post-body .note.danger h2, .post-body .note.danger h3, .post-body .note.danger h4, .post-body .note.danger h5, .post-body .note.danger h6 { color: #d9534f; } .post-body .tabs { position: relative; display: block; margin-bottom: 20px; padding-top: 10px; } .post-body .tabs ul.nav-tabs { margin: 0; padding: 0; display: flex; margin-bottom: -1px; } @media (max-width: 413px) { .post-body .tabs ul.nav-tabs { display: block; margin-bottom: 5px; } } .post-body .tabs ul.nav-tabs li.tab { list-style-type: none !important; margin: 0 0.25em 0 0; border-top: 3px solid transparent; border-left: 1px solid transparent; border-right: 1px solid transparent; } @media (max-width: 413px) { .post-body .tabs ul.nav-tabs li.tab { margin: initial; border-top: 1px solid transparent; border-left: 3px solid transparent; border-right: 1px solid transparent; border-bottom: 1px solid transparent; } } .post-body .tabs ul.nav-tabs li.tab a { outline: 0; border-bottom: initial; display: block; line-height: 1.8em; padding: 0.25em 0.75em; transition-duration: 0.2s; transition-timing-function: ease-out; transition-delay: 0s; } .post-body .tabs ul.nav-tabs li.tab a i { width: 1.285714285714286em; } .post-body .tabs ul.nav-tabs li.tab.active { border-top: 3px solid #fc6423; border-left: 1px solid #ddd; border-right: 1px solid #ddd; background-color: #fff; } @media (max-width: 413px) { .post-body .tabs ul.nav-tabs li.tab.active { border-top: 1px solid #ddd; border-left: 3px solid #fc6423; border-right: 1px solid #ddd; border-bottom: 1px solid #ddd; } } .post-body .tabs ul.nav-tabs li.tab.active a { cursor: default; color: #555; } .post-body .tabs .tab-content { background-color: #fff; } .post-body .tabs .tab-content .tab-pane { border: 1px solid #ddd; padding: 20px 20px 0 20px; } .post-body .tabs .tab-content .tab-pane:not(.active) { display: none; } .post-body .tabs .tab-content .tab-pane.active { display: block; } .btn { display: inline-block; padding: 0 20px; font-size: 14px; color: #555; background: #fff; border: 2px solid #555; text-decoration: none; border-radius: 2px; transition-property: background-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; line-height: 2; } .btn:hover { border-color: #222; color: #fff; background: #222; } .btn +.btn { margin: 0 0 8px 8px; } .btn .fa-fw { width: 1.285714285714286em; text-align: left; } .btn-bar { display: block; width: 22px; height: 2px; background: #555; border-radius: 1px; } .btn-bar+.btn-bar { margin-top: 4px; } .pagination { margin: 120px 0 40px; text-align: center; border-top: 1px solid #eee; } .page-number-basic, .pagination .prev, .pagination .next, .pagination .page-number, .pagination .space { display: inline-block; position: relative; top: -1px; margin: 0 10px; padding: 0 11px; } @media (max-width: 767px) { .page-number-basic, .pagination .prev, .pagination .next, .pagination .page-number, .pagination .space { margin: 0 5px; } } .pagination .prev, .pagination .next, .pagination .page-number { border-bottom: 0; border-top: 1px solid #eee; transition-property: border-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .pagination .prev:hover, .pagination .next:hover, .pagination .page-number:hover { border-top-color: #222; } .pagination .space { padding: 0; margin: 0; } .pagination .prev { margin-left: 0; } .pagination .next { margin-right: 0; } .pagination .page-number.current { color: #fff; background: #ccc; border-top-color: #ccc; } @media (max-width: 767px) { .pagination { border-top: none; } .pagination .prev, .pagination .next, .pagination .page-number { margin-bottom: 10px; border-top: 0; border-bottom: 1px solid #eee; padding: 0 10px; } .pagination .prev:hover, .pagination .next:hover, .pagination .page-number:hover { border-bottom-color: #222; } } .comments { margin: 60px 20px 0; } .back-to-top { box-sizing: border-box; position: fixed; bottom: -100px; right: 30px; z-index: 1050; padding: 0 6px; width: initial; background: #222; font-size: 12px; opacity: 0.6; color: #fff; cursor: pointer; text-align: center; transition-property: bottom; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .back-to-top.back-to-top-on { bottom: 30px; } .back-to-top:hover { color: #fc6423; } .header { background: transparent; } .header-inner { position: relative; } .headband { height: 3px; background: #222; } .site-meta { margin: 0; text-align: center; } @media (max-width: 767px) { .site-meta { text-align: center; } } .brand { position: relative; display: inline-block; padding: 0 40px; color: #fff; background: #222; border-bottom: none; } .brand:hover { color: #fff; } .logo { display: inline-block; margin-right: 5px; line-height: 36px; vertical-align: top; } .site-title { display: inline-block; vertical-align: top; line-height: 36px; font-size: 20px; font-weight: normal; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; } .site-subtitle { margin-top: 10px; font-size: 13px; color: #ddd; } .use-motion .brand { opacity: 0; } .use-motion .logo, .use-motion .site-title, .use-motion .site-subtitle, .use-motion .custom-logo-image { opacity: 0; position: relative; top: -10px; } .site-nav-toggle { display: none; position: absolute; top: 10px; left: 10px; } @media (max-width: 767px) { .site-nav-toggle { display: block; } } .site-nav-toggle button { margin-top: 2px; padding: 9px 10px; background: transparent; border: none; } @media (max-width: 767px) { .site-nav { display: none; margin: 0 -10px; padding: 0 10px; clear: both; border-top: 1px solid #ddd; } } @media (min-width: 768px) and (max-width: 991px) { .site-nav { display: block !important; } } @media (min-width: 992px) { .site-nav { display: block !important; } } .menu { margin-top: 20px; padding-left: 0; text-align: center; } .menu .menu-item { display: inline-block; margin: 0 10px; list-style: none; } @media (max-width: 767px) { .menu .menu-item { margin-top: 10px; } } .menu .menu-item a, .menu .menu-item span.exturl { display: block; font-size: 13px; line-height: inherit; border-bottom: 1px solid transparent; transition-property: border-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .menu .menu-item a:hover, .menu .menu-item span.exturl:hover { border-bottom-color: #222; } .menu .menu-item .fa { margin-right: 5px; } .use-motion .menu-item { opacity: 0; } .post-body { overflow-wrap: break-word; word-wrap: break-word; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; } .post-body span.exturl .fa { font-size: 14px; margin-left: 4px; } .post-body .fancybox img { display: block !important; margin: 0 auto; cursor: pointer; cursor: zoom-in; } .post-body .image-caption, .post-body .figure .caption { margin: -20px auto 15px; text-align: center; font-size: 14px; color: #999; font-weight: bold; line-height: 1; } .post-sticky-flag { display: inline-block; font-size: 16px; transform: rotate(30deg); } .use-motion .post-block, .use-motion .pagination, .use-motion .comments { opacity: 0; } .use-motion .post-header { opacity: 0; } .use-motion .post-body { opacity: 0; } .use-motion .collection-title { opacity: 0; } .posts-expand { padding-top: 40px; } @media (max-width: 767px) { .posts-expand { margin: 0 20px; } .post-body pre .gutter pre { padding-right: 10px; } .post-body .highlight { margin-left: 0px; margin-right: 0px; padding: 0; } .post-body .highlight .gutter pre { padding-right: 10px; } } @media (min-width: 992px) { .posts-expand .post-body { text-align: justify; } } @media (max-width: 991px) { .posts-expand .post-body { text-align: justify; } } .posts-expand .post-body h2, .posts-expand .post-body h3, .posts-expand .post-body h4, .posts-expand .post-body h5, .posts-expand .post-body h6 { padding-top: 10px; } .posts-expand .post-body h2 .header-anchor, .posts-expand .post-body h3 .header-anchor, .posts-expand .post-body h4 .header-anchor, .posts-expand .post-body h5 .header-anchor, .posts-expand .post-body h6 .header-anchor { float: right; margin-left: 10px; color: #ccc; border-bottom-style: none; visibility: hidden; } .posts-expand .post-body h2 .header-anchor:hover, .posts-expand .post-body h3 .header-anchor:hover, .posts-expand .post-body h4 .header-anchor:hover, .posts-expand .post-body h5 .header-anchor:hover, .posts-expand .post-body h6 .header-anchor:hover { color: inherit; } .posts-expand .post-body h2:hover .header-anchor, .posts-expand .post-body h3:hover .header-anchor, .posts-expand .post-body h4:hover .header-anchor, .posts-expand .post-body h5:hover .header-anchor, .posts-expand .post-body h6:hover .header-anchor { visibility: visible; } .posts-expand .post-body img { box-sizing: border-box; margin: 0 auto 25px; padding: 3px; border: 1px solid #ddd; } @media (max-width: 767px) { .posts-collapse { margin: 0 20px; } .posts-collapse .post-title, .posts-collapse .post-meta { display: block; width: auto; text-align: left; } } .posts-collapse { position: relative; z-index: 1010; margin-left: 55px; } .posts-collapse::after { content: " "; position: absolute; top: 20px; left: 0; margin-left: -2px; width: 4px; height: 100%; background: #f5f5f5; z-index: -1; } @media (max-width: 767px) { .posts-collapse { margin: 0 20px; } } .posts-collapse .collection-title { position: relative; margin: 60px 0; } .posts-collapse .collection-title h1, .posts-collapse .collection-title h2 { margin-left: 20px; } .posts-collapse .collection-title small { color: #bbb; margin-left: 5px; } .posts-collapse .collection-title::before { content: " "; position: absolute; left: 0; top: 50%; margin-left: -4px; margin-top: -4px; width: 8px; height: 8px; background: #bbb; border-radius: 50%; } .posts-collapse .post { margin: 30px 0; } .posts-collapse .post-header { position: relative; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; transition-property: border; border-bottom: 1px dashed #ccc; } .posts-collapse .post-header::before { content: " "; position: absolute; left: 0; top: 12px; width: 6px; height: 6px; margin-left: -4px; background: #bbb; border-radius: 50%; border: 1px solid #fff; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; transition-property: background; } .posts-collapse .post-header:hover { border-bottom-color: #666; } .posts-collapse .post-header:hover::before { background: #222; } .posts-collapse .post-meta { position: absolute; font-size: 12px; left: 20px; top: 5px; } .posts-collapse .post-comments-count { display: none; } .posts-collapse .post-title { margin-left: 60px; font-size: 16px; font-weight: normal; line-height: inherit; } .posts-collapse .post-title::after { margin-left: 3px; opacity: 0.6; } .posts-collapse .post-title a, .posts-collapse .post-title span.exturl { color: #666; border-bottom: none; } .page-home .post-type-quote .post-header, .page-post-detail .post-type-quote .post-header, .page-home .post-type-quote .post-tags, .page-post-detail .post-type-quote .post-tags { display: none; } .posts-expand .post-title { overflow-wrap: break-word; word-wrap: break-word; text-align: center; font-weight: 400; } .posts-expand .post-title-link { display: inline-block; position: relative; color: #555; border-bottom: none; line-height: 1.2; vertical-align: top; } .posts-expand .post-title-link::before { content: ""; position: absolute; width: 100%; height: 2px; bottom: 0; left: 0; background-color: #000; visibility: hidden; transform: scaleX(0); transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .posts-expand .post-title-link:hover::before { visibility: visible; transform: scaleX(1); } .posts-expand .post-title-link .fa { font-size: 20px; margin-left: 5px; } .posts-expand .post-meta { margin: 3px 0 60px 0; color: #999; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; font-size: 12px; text-align: center; } .posts-expand .post-meta .post-category-list { display: inline-block; margin: 0; padding: 3px; } .posts-expand .post-meta .post-category-list-link { color: #999; } .posts-expand .post-meta .post-description { font-size: 14px; margin-top: 2px; } .posts-expand .post-meta time { border-bottom: 1px dashed #999; cursor: help; } .post-meta-divider { margin: 0 0.5em; } .post-meta-item-icon { margin-right: 3px; } @media (min-width: 768px) and (max-width: 991px) { .post-meta-item-icon { display: inline-block; } } @media (max-width: 767px) { .post-meta-item-icon { display: inline-block; } } @media (min-width: 768px) and (max-width: 991px) { .post-meta-item-text { display: none; } } @media (max-width: 767px) { .post-meta-item-text { display: none; } } .post-button { margin-top: 40px; } .posts-expand .post-tags { margin-top: 40px; text-align: center; } .posts-expand .post-tags a { display: inline-block; margin-right: 10px; font-size: 13px; } .post-nav { display: table; margin-top: 15px; width: 100%; border-top: 1px solid #eee; } .post-nav-divider { display: table-cell; width: 10%; } .post-nav-item { display: table-cell; padding: 10px 0 0 0; width: 45%; vertical-align: top; } .post-nav-item a { position: relative; display: block; line-height: 25px; font-size: 14px; color: #555; border-bottom: none; } .post-nav-item a:hover { color: #222; border-bottom: none; } .post-nav-item a:active { top: 2px; } .post-nav-item .fa { font-size: 12px; margin-right: 5px; } .post-nav-next a { padding-left: 5px; } .post-nav-prev { text-align: right; } .post-nav-prev a { padding-right: 5px; } .post-nav-prev .fa { margin-left: 5px; } .posts-expand .post-eof { display: block; margin: 80px auto 60px; width: 8%; height: 1px; background: #ccc; text-align: center; } .post:last-child .post-eof.post-eof.post-eof { display: none; } .post-gallery { display: table; table-layout: fixed; width: 100%; border-collapse: separate; } .post-gallery-row { display: table-row; } .post-gallery .post-gallery-img { display: table-cell; text-align: center; vertical-align: middle; border: none; } .post-gallery .post-gallery-img img { max-width: 100%; max-height: 100%; border: none; } .fancybox-close, .fancybox-close:hover { border: none; } .rtl.post-body p, .rtl.post-body a, .rtl.post-body h1, .rtl.post-body h2, .rtl.post-body h3, .rtl.post-body h4, .rtl.post-body h5, .rtl.post-body h6, .rtl.post-body li, .rtl.post-body ul, .rtl.post-body ol { direction: rtl; font-family: UKIJ Ekran; } .rtl.post-title { font-family: UKIJ Ekran; } .sidebar { position: fixed; right: 0; top: 0; bottom: 0; width: 0; z-index: 1040; box-shadow: inset 0 2px 6px #000; background: #222; } .sidebar a, .sidebar span.exturl { color: #999; border-bottom-color: #555; } .sidebar a:hover, .sidebar span.exturl:hover { color: #eee; border-bottom-color: #eee; } @media (max-width: 991px) { .sidebar { display: none; } } .sidebar-inner { position: relative; padding: 20px 10px; color: #999; text-align: center; } .site-overview-wrap { overflow: hidden; } .site-overview { overflow-y: auto; overflow-x: hidden; } .cc-license { margin-top: 10px; text-align: center; } .cc-license .cc-opacity { opacity: 0.7; border-bottom: none; } .cc-license .cc-opacity:hover { opacity: 0.9; } .cc-license img { display: inline-block; } .sidebar-toggle { position: fixed; right: 30px; bottom: 45px; width: 14px; height: 14px; padding: 5px; background: #222; line-height: 0; z-index: 1050; cursor: pointer; } .sidebar-toggle:hover .sidebar-toggle-line { background: #fc6423; } @media (max-width: 991px) { .sidebar-toggle { display: none; } } .sidebar-toggle-line { position: relative; display: inline-block; vertical-align: top; height: 2px; width: 100%; background: #fff; margin-top: 3px; } .sidebar-toggle-line:first-child { margin-top: 0; } .site-author-image { display: block; margin: 0 auto; padding: 2px; max-width: 120px; height: auto; border: 1px solid #eee; opacity: 1; } .site-author-name { margin: 0; text-align: center; color: #222; font-weight: 600; } .site-description { margin-top: 0; text-align: center; font-size: 13px; color: #999; } .links-of-author { margin-top: 20px; } .links-of-author a, .links-of-author span.exturl { display: inline-block; vertical-align: middle; margin-right: 10px; margin-bottom: 10px; border-bottom-color: #555; font-size: 13px; } .links-of-author a:before, .links-of-author span.exturl:before { display: inline-block; vertical-align: middle; margin-right: 3px; content: " "; width: 4px; height: 4px; border-radius: 50%; background: #30ff6f; } .feed-link, .chat { margin-top: 10px; } .feed-link a, .chat a { display: inline-block; padding: 0 15px; color: #fc6423; border: 1px solid #fc6423 !important; border-radius: 4px; } .feed-link a i, .chat a i { color: #fc6423; font-size: 14px; } .feed-link a:hover, .chat a:hover { color: #fff; background: #fc6423; } .feed-link a:hover i, .chat a:hover i { color: #fff; } .links-of-blogroll { margin-top: 10px; font-size: 13px; } .links-of-blogroll-title { margin-top: 0; font-size: 14px; font-weight: 600; } .links-of-blogroll-list { margin: 0; padding: 0; list-style: none; } .links-of-blogroll-item { padding: 2px 10px; } .links-of-blogroll-item a, .links-of-blogroll-item span.exturl { max-width: 280px; box-sizing: border-box; display: inline-block; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .sidebar-nav { margin: 0 0 20px; padding-left: 0; } .sidebar-nav li { display: inline-block; cursor: pointer; border-bottom: 1px solid transparent; font-size: 14px; color: #555; } .sidebar-nav li:hover { color: #fc6423; } .page-post-detail .sidebar-nav-toc { padding: 0 5px; } .page-post-detail .sidebar-nav-overview { margin-left: 10px; } .sidebar-nav .sidebar-nav-active { color: #fc6423; border-bottom-color: #fc6423; } .sidebar-nav .sidebar-nav-active:hover { color: #fc6423; } .sidebar-panel { display: none; } .sidebar-panel-active { display: block; } .site-state { display: flex; justify-content: center; overflow: hidden; line-height: 1.4; white-space: nowrap; text-align: center; margin-top: 10px; } .site-state-item { padding: 0 15px; border-left: 1px solid #eee; } .site-state-item:first-child { border-left: none; } .site-state-item a { border-bottom: none; } .site-state-item-count { display: block; text-align: center; color: inherit; font-weight: 600; font-size: 16px; } .site-state-item-name { font-size: 13px; color: #999; } .post-toc-empty { font-size: 14px; color: #666; } .post-toc-wrap { overflow: hidden; } .post-toc { overflow: auto; } .post-toc ol { margin: 0; padding: 0 2px 5px 10px; text-align: left; list-style: none; font-size: 14px; } .post-toc ol > ol { padding-left: 0; } .post-toc ol a { transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; transition-property: all; color: #666; border-bottom-color: #ccc; } .post-toc ol a:hover { color: #000; border-bottom-color: #000; } .post-toc .nav-item { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height: 1.8; } .post-toc .nav .nav-child { display: none; } .post-toc .nav .active > .nav-child { display: block; } .post-toc .nav .active-current > .nav-child { display: block; } .post-toc .nav .active-current > .nav-child > .nav-item { display: block; } .post-toc .nav .active > a { color: #fc6423; border-bottom-color: #fc6423; } .post-toc .nav .active-current > a { color: #fc6423; } .post-toc .nav .active-current > a:hover { color: #fc6423; } .footer { font-size: 14px; color: #999; } .footer img { border: none; } .footer-inner { text-align: center; } .with-love { display: inline-block; margin: 0 5px; color: #808080; } .powered-by, .theme-info { display: inline-block; } @-moz-keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } @-webkit-keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } @-o-keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } @keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } .local-search-pop-overlay { position: fixed; width: 100%; height: 100%; top: 0; left: 0; z-index: 2080; background-color: rgba(0,0,0,0.3); } .local-search-popup { display: none; position: fixed; top: 10%; left: 50%; margin-left: -350px; width: 700px; height: 80%; padding: 0; background: #fff; color: #333; z-index: 9999; border-radius: 5px; } @media (max-width: 767px) { .local-search-popup { padding: 0; top: 0; left: 0; margin: 0; width: 100%; height: 100%; border-radius: 0; } } .local-search-popup ul.search-result-list { padding: 0; margin: 0 5px; } .local-search-popup p.search-result { border-bottom: 1px dashed #ccc; padding: 5px 0; } .local-search-popup a.search-result-title { font-weight: bold; font-size: 16px; } .local-search-popup .search-keyword { border-bottom: 1px dashed #f00; font-weight: bold; color: #f00; } .local-search-popup .local-search-header { padding: 5px; height: 36px; background: #f5f5f5; border-top-left-radius: 5px; border-top-right-radius: 5px; } .local-search-popup #local-search-result { overflow: auto; position: relative; padding: 5px 25px; height: calc(100% - 55px); } .local-search-popup .local-search-input-wrapper { display: inline-block; width: calc(100% - 90px); height: 36px; line-height: 36px; padding: 0 5px; } .local-search-popup .local-search-input-wrapper input { padding: 8px 0; height: 20px; display: block; width: 100%; outline: none; border: none; background: transparent; vertical-align: middle; } .local-search-popup .search-icon, .local-search-popup .popup-btn-close { display: inline-block; font-size: 18px; color: #999; height: 36px; width: 18px; padding-left: 10px; padding-right: 10px; } .local-search-popup .search-icon { float: left; } .local-search-popup .popup-btn-close { border-left: 1px solid #eee; float: right; cursor: pointer; } .local-search-popup #no-result { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); color: #ccc; } .copy-btn { display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; } .highlight-wrap .copy-btn { transition: opacity 0.3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; } .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus { opacity: 1; } .highlight-wrap { position: relative; } .page-archive .archive-page-counter { position: relative; top: 3px; left: 20px; } @media (max-width: 767px) { .page-archive .archive-page-counter { top: 5px; } } .page-archive .posts-collapse .archive-move-on { position: absolute; top: 11px; left: 0; margin-left: -6px; width: 10px; height: 10px; opacity: 0.5; background: #555; border: 1px solid #fff; border-radius: 50%; } .page-archive .fa-external-link { font-size: 15px; margin-left: 5px; } .category-all-page .category-all-title { text-align: center; } .category-all-page .category-all { margin-top: 20px; } .category-all-page .category-list { margin: 0; padding: 0; list-style: none; } .category-all-page .category-list-item { margin: 5px 10px; } .category-all-page .category-list-count { color: #bbb; } .category-all-page .category-list-count:before { display: inline; content: " ("; } .category-all-page .category-list-count:after { display: inline; content: ") "; } .category-all-page .category-list-child { padding-left: 10px; } #event-list { padding-left: 30px; } #event-list hr { margin: 20px 0 45px 0 !important; background: #222; } #event-list hr:after { display: inline-block; content: 'NOW'; background: #222; color: #fff; font-weight: bold; text-align: right; padding: 0 5px; } #event-list li.event { margin: 20px 0px; background: #f9f9f9; padding-left: 10px; min-height: 40px; } #event-list li.event h2.event-summary { margin: 0; padding-bottom: 3px; } #event-list li.event h2.event-summary:before { display: inline-block; font-family: FontAwesome; font-size: 8px; content: '\f111'; vertical-align: middle; margin-right: 25px; color: #bbb; } #event-list li.event span.event-relative-time { display: inline-block; font-size: 12px; font-weight: 400; padding-left: 12px; color: #bbb; } #event-list li.event span.event-details { display: block; color: #bbb; margin-left: 56px; padding-top: 3px; padding-bottom: 6px; text-indent: -24px; line-height: 18px; } #event-list li.event span.event-details:before { text-indent: 0; display: inline-block; width: 14px; font-family: FontAwesome; text-align: center; margin-right: 9px; color: #bbb; } #event-list li.event span.event-details.event-location:before { content: '\f041'; } #event-list li.event span.event-details.event-duration:before { content: '\f017'; } #event-list li.event-past { background: #fcfcfc; padding: 15px 0 15px 10px; } #event-list li.event-past > * { opacity: 0.9; } #event-list li.event-past h2.event-summary { color: #bbb; } #event-list li.event-past h2.event-summary:before { color: #dfdfdf; } #event-list li.event-now { background: #222; color: #fff; padding: 15px 0 15px 10px; } #event-list li.event-now h2.event-summary:before { transform: scale(1.2); color: #fff; animation: dot-flash 1s alternate infinite ease-in-out; } #event-list li.event-now * { color: #fff !important; } #event-list li.event-future { background: #222; color: #fff; padding: 15px 0 15px 10px; } #event-list li.event-future h2.event-summary:before { transform: scale(1.2); color: #fff; animation: dot-flash 1s alternate infinite ease-in-out; } #event-list li.event-future * { color: #fff !important; } @-moz-keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } @-webkit-keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } @-o-keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } @keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } .page-post-detail .sidebar-toggle-line { background: #fc6423; } .page-post-detail .comments { overflow: hidden; } ul.breadcrumb { list-style: none; margin: 1em 0; padding: 0 2em; text-align: center; font-size: 12px; } ul.breadcrumb li { display: inline; } ul.breadcrumb li+li:before { padding: 0.5em; font-weight: normal; content: "/\00a0"; } ul.breadcrumb li+li:last-child { font-weight: bold; } .tag-cloud { text-align: center; } .tag-cloud a { display: inline-block; margin: 10px; } .tag-cloud a:hover { color: #222 !important; } .header { position: relative; margin: 0 auto; width: calc(100% - 20px); } @media (min-width: 1200px) { .header { width: 1160px; } } @media (min-width: 1600px) { .header { width: 73%; } } @media (max-width: 991px) { .header { width: auto; } } .header-inner { position: absolute; top: 0; overflow: hidden; padding: 0; width: 240px; background: #fff; box-shadow: initial; border-radius: initial; } @media (min-width: 1200px) { .container .header-inner { width: 240px; } } @media (max-width: 991px) { .header-inner { position: relative; width: auto; border-radius: initial; } } .main:before, .main:after { content: " "; display: table; } .main:after { clear: both; } @media (max-width: 991px) { .container .main-inner { width: auto; } } .content-wrap { float: right; box-sizing: border-box; padding: 40px; width: calc(100% - 252px); background: #fff; min-height: 700px; box-shadow: initial; border-radius: initial; } @media (min-width: 768px) and (max-width: 991px) { .content-wrap { width: 100%; padding: 20px; border-radius: initial; } } @media (max-width: 767px) { .content-wrap { width: 100%; padding: 20px; min-height: auto; border-radius: initial; } } .sidebar { position: static; float: left; margin-left: -100%; width: 240px; background: #f5f7f9; box-shadow: none; } @media (max-width: 991px) { .sidebar { display: none; } } .sidebar-toggle { display: none; } .footer-inner { padding-left: 260px; } @media (max-width: 991px) { .footer-inner { width: auto; padding-left: 0 !important; padding-right: 0 !important; } } .sidebar-position-right .header-inner { right: 0; } .sidebar-position-right .content-wrap { float: left; } .sidebar-position-right .sidebar { float: right; } .sidebar-position-right .footer-inner { padding-left: 0; padding-right: 260px; } .site-brand-wrapper { position: relative; } .site-meta { padding: 20px 0; color: #fff; background: #222; } @media (max-width: 991px) { .site-meta { box-shadow: 0 0 16px rgba(0,0,0,0.5); } } .brand { padding: 0; background: none; } .brand:hover { color: #fff; } .site-subtitle { margin: 10px 10px 0; font-weight: initial; } .custom-logo-image { margin-top: 20px; } @media (max-width: 991px) { .custom-logo-image { display: none; } } .site-search form { display: none; } .site-nav { border-top: none; } @media (min-width: 768px) and (max-width: 991px) { .site-nav { display: none !important; } } @media (min-width: 768px) and (max-width: 991px) { .site-nav-on { display: block !important; } } .menu-item-active a, .menu .menu-item a:hover, .menu .menu-item span.exturl:hover { background: #f9f9f9; border-bottom-color: #fff; } .menu-item-active a:after, .menu .menu-item a:hover:after, .menu .menu-item span.exturl:hover:after { content: " "; position: absolute; top: 50%; margin-top: -3px; right: 15px; width: 6px; height: 6px; border-radius: 50%; background-color: #bbb; } .menu .menu-item { display: block; margin: 0; } .menu .menu-item a, .menu .menu-item span.exturl { position: relative; box-sizing: border-box; padding: 5px 20px; text-align: left; line-height: inherit; transition-property: background-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } @media (hover: none) { .menu .menu-item a:hover, .menu .menu-item span.exturl:hover { background: none; } } .menu .menu-item .badge { display: inline-block; padding: 2px 5px; font-weight: 700; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: middle; background-color: #ccc; border-radius: 10px; float: right; margin: 0.35em 0 0 0; text-shadow: 1px 1px 0px rgba(0,0,0,0.1); } .menu .menu-item br { display: none; } .btn-bar { background-color: #fff; } .site-nav-toggle { left: 20px; top: 50%; transform: translateY(-50%); } @media (min-width: 768px) and (max-width: 991px) { .site-nav-toggle { display: block; } } .sub-menu { margin: 0; padding: 6px 0; background: #fff !important; border-bottom: 1px solid #ddd; } .sub-menu .menu-item { display: inline-block !important; } .sub-menu .menu-item a, .sub-menu .menu-item span.exturl { padding: initial !important; margin: 5px 10px; } .sub-menu .menu-item a:hover, .sub-menu .menu-item span.exturl:hover { background: initial !important; color: #fc6423; } .sub-menu .menu-item-active a { background: #fff !important; color: #fc6423; border-bottom-color: #fc6423; } .sub-menu .menu-item-active a:hover { background: #fff !important; border-bottom-color: #fc6423; } .sub-menu .menu-item-active a:after { content: initial; } .use-motion .sidebar .motion-element { opacity: 1; } .sidebar { right: auto; bottom: auto; -webkit-transform: none; } .sidebar a, .sidebar span.exturl { color: #555; } .sidebar a:hover, .sidebar span.exturl:hover { color: #222; border-bottom-color: #222; } .sidebar-inner { box-sizing: border-box; width: 240px; color: #555; background: #fff; box-shadow: initial; border-radius: initial; opacity: 0; } .sidebar-inner.affix { position: fixed; top: 12px; } .sidebar-inner.affix-bottom { position: absolute; } .site-overview { text-align: left; } .site-author:before, .site-author:after { content: " "; display: table; } .site-author:after { clear: both; } .site-state-item { padding: 0 10px; } .feed-link, .chat { border-top: 1px dotted #ccc; border-bottom: 1px dotted #ccc; text-align: center; } .feed-link a, .chat a { display: block; color: #fc6423; border: none; } .feed-link a:hover, .chat a:hover { background: none; color: #e34603; } .feed-link a:hover i, .chat a:hover i { color: #e34603; } .links-of-author { display: flex; flex-wrap: wrap; justify-content: center; } .links-of-author span.exturl { font-size: 13px; } .links-of-author-item { margin: 5px 0 0; width: 50%; } .links-of-author-item a, .links-of-author-item span.exturl { max-width: 216px; box-sizing: border-box; display: inline-block; margin-right: 0; margin-bottom: 0; padding: 0 5px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .links-of-author-item a:before, .links-of-author-item span.exturl:before { display: none; } .links-of-author-item a, .links-of-author-item span.exturl { border-bottom: none; text-decoration: underline; } .links-of-author-item a, .links-of-author-item span.exturl { display: block; text-decoration: none; } .links-of-author-item a:hover, .links-of-author-item span.exturl:hover { border-radius: 4px; background: #eee; } .links-of-author-item .fa { margin-right: 2px; font-size: 16px; } .links-of-author-item .fa-globe { font-size: 15px; } .links-of-blogroll { text-align: center; padding: 3px 0 0; } .links-of-blogroll-item { padding: 0; } .links-of-blogroll-inline:before, .links-of-blogroll-inline:after { content: " "; display: table; } .links-of-blogroll-inline:after { clear: both; } .links-of-blogroll-inline .links-of-blogroll-item { margin: 5px 0 0; width: 50%; display: inline-block; width: unset; } .links-of-blogroll-inline .links-of-blogroll-item a, .links-of-blogroll-inline .links-of-blogroll-item span.exturl { max-width: 216px; box-sizing: border-box; display: inline-block; margin-right: 0; margin-bottom: 0; padding: 0 5px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Ffont-awesome.min%2F</url>
    <content type="text"><![CDATA[/*! * Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome * License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License) */@font-face{font-family:'FontAwesome';src:url('../fonts/fontawesome-webfont.eot?v=4.7.0');src:url('../fonts/fontawesome-webfont.eot?#iefix&v=4.7.0') format('embedded-opentype'),url('../fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'),url('../fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'),url('../fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'),url('../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg');font-weight:normal;font-style:normal}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";-webkit-transform:scale(-1, 1);-ms-transform:scale(-1, 1);transform:scale(-1, 1)}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";-webkit-transform:scale(1, -1);-ms-transform:scale(1, -1);transform:scale(1, -1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"\f000"}.fa-music:before{content:"\f001"}.fa-search:before{content:"\f002"}.fa-envelope-o:before{content:"\f003"}.fa-heart:before{content:"\f004"}.fa-star:before{content:"\f005"}.fa-star-o:before{content:"\f006"}.fa-user:before{content:"\f007"}.fa-film:before{content:"\f008"}.fa-th-large:before{content:"\f009"}.fa-th:before{content:"\f00a"}.fa-th-list:before{content:"\f00b"}.fa-check:before{content:"\f00c"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\f00d"}.fa-search-plus:before{content:"\f00e"}.fa-search-minus:before{content:"\f010"}.fa-power-off:before{content:"\f011"}.fa-signal:before{content:"\f012"}.fa-gear:before,.fa-cog:before{content:"\f013"}.fa-trash-o:before{content:"\f014"}.fa-home:before{content:"\f015"}.fa-file-o:before{content:"\f016"}.fa-clock-o:before{content:"\f017"}.fa-road:before{content:"\f018"}.fa-download:before{content:"\f019"}.fa-arrow-circle-o-down:before{content:"\f01a"}.fa-arrow-circle-o-up:before{content:"\f01b"}.fa-inbox:before{content:"\f01c"}.fa-play-circle-o:before{content:"\f01d"}.fa-rotate-right:before,.fa-repeat:before{content:"\f01e"}.fa-refresh:before{content:"\f021"}.fa-list-alt:before{content:"\f022"}.fa-lock:before{content:"\f023"}.fa-flag:before{content:"\f024"}.fa-headphones:before{content:"\f025"}.fa-volume-off:before{content:"\f026"}.fa-volume-down:before{content:"\f027"}.fa-volume-up:before{content:"\f028"}.fa-qrcode:before{content:"\f029"}.fa-barcode:before{content:"\f02a"}.fa-tag:before{content:"\f02b"}.fa-tags:before{content:"\f02c"}.fa-book:before{content:"\f02d"}.fa-bookmark:before{content:"\f02e"}.fa-print:before{content:"\f02f"}.fa-camera:before{content:"\f030"}.fa-font:before{content:"\f031"}.fa-bold:before{content:"\f032"}.fa-italic:before{content:"\f033"}.fa-text-height:before{content:"\f034"}.fa-text-width:before{content:"\f035"}.fa-align-left:before{content:"\f036"}.fa-align-center:before{content:"\f037"}.fa-align-right:before{content:"\f038"}.fa-align-justify:before{content:"\f039"}.fa-list:before{content:"\f03a"}.fa-dedent:before,.fa-outdent:before{content:"\f03b"}.fa-indent:before{content:"\f03c"}.fa-video-camera:before{content:"\f03d"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\f03e"}.fa-pencil:before{content:"\f040"}.fa-map-marker:before{content:"\f041"}.fa-adjust:before{content:"\f042"}.fa-tint:before{content:"\f043"}.fa-edit:before,.fa-pencil-square-o:before{content:"\f044"}.fa-share-square-o:before{content:"\f045"}.fa-check-square-o:before{content:"\f046"}.fa-arrows:before{content:"\f047"}.fa-step-backward:before{content:"\f048"}.fa-fast-backward:before{content:"\f049"}.fa-backward:before{content:"\f04a"}.fa-play:before{content:"\f04b"}.fa-pause:before{content:"\f04c"}.fa-stop:before{content:"\f04d"}.fa-forward:before{content:"\f04e"}.fa-fast-forward:before{content:"\f050"}.fa-step-forward:before{content:"\f051"}.fa-eject:before{content:"\f052"}.fa-chevron-left:before{content:"\f053"}.fa-chevron-right:before{content:"\f054"}.fa-plus-circle:before{content:"\f055"}.fa-minus-circle:before{content:"\f056"}.fa-times-circle:before{content:"\f057"}.fa-check-circle:before{content:"\f058"}.fa-question-circle:before{content:"\f059"}.fa-info-circle:before{content:"\f05a"}.fa-crosshairs:before{content:"\f05b"}.fa-times-circle-o:before{content:"\f05c"}.fa-check-circle-o:before{content:"\f05d"}.fa-ban:before{content:"\f05e"}.fa-arrow-left:before{content:"\f060"}.fa-arrow-right:before{content:"\f061"}.fa-arrow-up:before{content:"\f062"}.fa-arrow-down:before{content:"\f063"}.fa-mail-forward:before,.fa-share:before{content:"\f064"}.fa-expand:before{content:"\f065"}.fa-compress:before{content:"\f066"}.fa-plus:before{content:"\f067"}.fa-minus:before{content:"\f068"}.fa-asterisk:before{content:"\f069"}.fa-exclamation-circle:before{content:"\f06a"}.fa-gift:before{content:"\f06b"}.fa-leaf:before{content:"\f06c"}.fa-fire:before{content:"\f06d"}.fa-eye:before{content:"\f06e"}.fa-eye-slash:before{content:"\f070"}.fa-warning:before,.fa-exclamation-triangle:before{content:"\f071"}.fa-plane:before{content:"\f072"}.fa-calendar:before{content:"\f073"}.fa-random:before{content:"\f074"}.fa-comment:before{content:"\f075"}.fa-magnet:before{content:"\f076"}.fa-chevron-up:before{content:"\f077"}.fa-chevron-down:before{content:"\f078"}.fa-retweet:before{content:"\f079"}.fa-shopping-cart:before{content:"\f07a"}.fa-folder:before{content:"\f07b"}.fa-folder-open:before{content:"\f07c"}.fa-arrows-v:before{content:"\f07d"}.fa-arrows-h:before{content:"\f07e"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\f080"}.fa-twitter-square:before{content:"\f081"}.fa-facebook-square:before{content:"\f082"}.fa-camera-retro:before{content:"\f083"}.fa-key:before{content:"\f084"}.fa-gears:before,.fa-cogs:before{content:"\f085"}.fa-comments:before{content:"\f086"}.fa-thumbs-o-up:before{content:"\f087"}.fa-thumbs-o-down:before{content:"\f088"}.fa-star-half:before{content:"\f089"}.fa-heart-o:before{content:"\f08a"}.fa-sign-out:before{content:"\f08b"}.fa-linkedin-square:before{content:"\f08c"}.fa-thumb-tack:before{content:"\f08d"}.fa-external-link:before{content:"\f08e"}.fa-sign-in:before{content:"\f090"}.fa-trophy:before{content:"\f091"}.fa-github-square:before{content:"\f092"}.fa-upload:before{content:"\f093"}.fa-lemon-o:before{content:"\f094"}.fa-phone:before{content:"\f095"}.fa-square-o:before{content:"\f096"}.fa-bookmark-o:before{content:"\f097"}.fa-phone-square:before{content:"\f098"}.fa-twitter:before{content:"\f099"}.fa-facebook-f:before,.fa-facebook:before{content:"\f09a"}.fa-github:before{content:"\f09b"}.fa-unlock:before{content:"\f09c"}.fa-credit-card:before{content:"\f09d"}.fa-feed:before,.fa-rss:before{content:"\f09e"}.fa-hdd-o:before{content:"\f0a0"}.fa-bullhorn:before{content:"\f0a1"}.fa-bell:before{content:"\f0f3"}.fa-certificate:before{content:"\f0a3"}.fa-hand-o-right:before{content:"\f0a4"}.fa-hand-o-left:before{content:"\f0a5"}.fa-hand-o-up:before{content:"\f0a6"}.fa-hand-o-down:before{content:"\f0a7"}.fa-arrow-circle-left:before{content:"\f0a8"}.fa-arrow-circle-right:before{content:"\f0a9"}.fa-arrow-circle-up:before{content:"\f0aa"}.fa-arrow-circle-down:before{content:"\f0ab"}.fa-globe:before{content:"\f0ac"}.fa-wrench:before{content:"\f0ad"}.fa-tasks:before{content:"\f0ae"}.fa-filter:before{content:"\f0b0"}.fa-briefcase:before{content:"\f0b1"}.fa-arrows-alt:before{content:"\f0b2"}.fa-group:before,.fa-users:before{content:"\f0c0"}.fa-chain:before,.fa-link:before{content:"\f0c1"}.fa-cloud:before{content:"\f0c2"}.fa-flask:before{content:"\f0c3"}.fa-cut:before,.fa-scissors:before{content:"\f0c4"}.fa-copy:before,.fa-files-o:before{content:"\f0c5"}.fa-paperclip:before{content:"\f0c6"}.fa-save:before,.fa-floppy-o:before{content:"\f0c7"}.fa-square:before{content:"\f0c8"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\f0c9"}.fa-list-ul:before{content:"\f0ca"}.fa-list-ol:before{content:"\f0cb"}.fa-strikethrough:before{content:"\f0cc"}.fa-underline:before{content:"\f0cd"}.fa-table:before{content:"\f0ce"}.fa-magic:before{content:"\f0d0"}.fa-truck:before{content:"\f0d1"}.fa-pinterest:before{content:"\f0d2"}.fa-pinterest-square:before{content:"\f0d3"}.fa-google-plus-square:before{content:"\f0d4"}.fa-google-plus:before{content:"\f0d5"}.fa-money:before{content:"\f0d6"}.fa-caret-down:before{content:"\f0d7"}.fa-caret-up:before{content:"\f0d8"}.fa-caret-left:before{content:"\f0d9"}.fa-caret-right:before{content:"\f0da"}.fa-columns:before{content:"\f0db"}.fa-unsorted:before,.fa-sort:before{content:"\f0dc"}.fa-sort-down:before,.fa-sort-desc:before{content:"\f0dd"}.fa-sort-up:before,.fa-sort-asc:before{content:"\f0de"}.fa-envelope:before{content:"\f0e0"}.fa-linkedin:before{content:"\f0e1"}.fa-rotate-left:before,.fa-undo:before{content:"\f0e2"}.fa-legal:before,.fa-gavel:before{content:"\f0e3"}.fa-dashboard:before,.fa-tachometer:before{content:"\f0e4"}.fa-comment-o:before{content:"\f0e5"}.fa-comments-o:before{content:"\f0e6"}.fa-flash:before,.fa-bolt:before{content:"\f0e7"}.fa-sitemap:before{content:"\f0e8"}.fa-umbrella:before{content:"\f0e9"}.fa-paste:before,.fa-clipboard:before{content:"\f0ea"}.fa-lightbulb-o:before{content:"\f0eb"}.fa-exchange:before{content:"\f0ec"}.fa-cloud-download:before{content:"\f0ed"}.fa-cloud-upload:before{content:"\f0ee"}.fa-user-md:before{content:"\f0f0"}.fa-stethoscope:before{content:"\f0f1"}.fa-suitcase:before{content:"\f0f2"}.fa-bell-o:before{content:"\f0a2"}.fa-coffee:before{content:"\f0f4"}.fa-cutlery:before{content:"\f0f5"}.fa-file-text-o:before{content:"\f0f6"}.fa-building-o:before{content:"\f0f7"}.fa-hospital-o:before{content:"\f0f8"}.fa-ambulance:before{content:"\f0f9"}.fa-medkit:before{content:"\f0fa"}.fa-fighter-jet:before{content:"\f0fb"}.fa-beer:before{content:"\f0fc"}.fa-h-square:before{content:"\f0fd"}.fa-plus-square:before{content:"\f0fe"}.fa-angle-double-left:before{content:"\f100"}.fa-angle-double-right:before{content:"\f101"}.fa-angle-double-up:before{content:"\f102"}.fa-angle-double-down:before{content:"\f103"}.fa-angle-left:before{content:"\f104"}.fa-angle-right:before{content:"\f105"}.fa-angle-up:before{content:"\f106"}.fa-angle-down:before{content:"\f107"}.fa-desktop:before{content:"\f108"}.fa-laptop:before{content:"\f109"}.fa-tablet:before{content:"\f10a"}.fa-mobile-phone:before,.fa-mobile:before{content:"\f10b"}.fa-circle-o:before{content:"\f10c"}.fa-quote-left:before{content:"\f10d"}.fa-quote-right:before{content:"\f10e"}.fa-spinner:before{content:"\f110"}.fa-circle:before{content:"\f111"}.fa-mail-reply:before,.fa-reply:before{content:"\f112"}.fa-github-alt:before{content:"\f113"}.fa-folder-o:before{content:"\f114"}.fa-folder-open-o:before{content:"\f115"}.fa-smile-o:before{content:"\f118"}.fa-frown-o:before{content:"\f119"}.fa-meh-o:before{content:"\f11a"}.fa-gamepad:before{content:"\f11b"}.fa-keyboard-o:before{content:"\f11c"}.fa-flag-o:before{content:"\f11d"}.fa-flag-checkered:before{content:"\f11e"}.fa-terminal:before{content:"\f120"}.fa-code:before{content:"\f121"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\f122"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\f123"}.fa-location-arrow:before{content:"\f124"}.fa-crop:before{content:"\f125"}.fa-code-fork:before{content:"\f126"}.fa-unlink:before,.fa-chain-broken:before{content:"\f127"}.fa-question:before{content:"\f128"}.fa-info:before{content:"\f129"}.fa-exclamation:before{content:"\f12a"}.fa-superscript:before{content:"\f12b"}.fa-subscript:before{content:"\f12c"}.fa-eraser:before{content:"\f12d"}.fa-puzzle-piece:before{content:"\f12e"}.fa-microphone:before{content:"\f130"}.fa-microphone-slash:before{content:"\f131"}.fa-shield:before{content:"\f132"}.fa-calendar-o:before{content:"\f133"}.fa-fire-extinguisher:before{content:"\f134"}.fa-rocket:before{content:"\f135"}.fa-maxcdn:before{content:"\f136"}.fa-chevron-circle-left:before{content:"\f137"}.fa-chevron-circle-right:before{content:"\f138"}.fa-chevron-circle-up:before{content:"\f139"}.fa-chevron-circle-down:before{content:"\f13a"}.fa-html5:before{content:"\f13b"}.fa-css3:before{content:"\f13c"}.fa-anchor:before{content:"\f13d"}.fa-unlock-alt:before{content:"\f13e"}.fa-bullseye:before{content:"\f140"}.fa-ellipsis-h:before{content:"\f141"}.fa-ellipsis-v:before{content:"\f142"}.fa-rss-square:before{content:"\f143"}.fa-play-circle:before{content:"\f144"}.fa-ticket:before{content:"\f145"}.fa-minus-square:before{content:"\f146"}.fa-minus-square-o:before{content:"\f147"}.fa-level-up:before{content:"\f148"}.fa-level-down:before{content:"\f149"}.fa-check-square:before{content:"\f14a"}.fa-pencil-square:before{content:"\f14b"}.fa-external-link-square:before{content:"\f14c"}.fa-share-square:before{content:"\f14d"}.fa-compass:before{content:"\f14e"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\f150"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\f151"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\f152"}.fa-euro:before,.fa-eur:before{content:"\f153"}.fa-gbp:before{content:"\f154"}.fa-dollar:before,.fa-usd:before{content:"\f155"}.fa-rupee:before,.fa-inr:before{content:"\f156"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\f157"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\f158"}.fa-won:before,.fa-krw:before{content:"\f159"}.fa-bitcoin:before,.fa-btc:before{content:"\f15a"}.fa-file:before{content:"\f15b"}.fa-file-text:before{content:"\f15c"}.fa-sort-alpha-asc:before{content:"\f15d"}.fa-sort-alpha-desc:before{content:"\f15e"}.fa-sort-amount-asc:before{content:"\f160"}.fa-sort-amount-desc:before{content:"\f161"}.fa-sort-numeric-asc:before{content:"\f162"}.fa-sort-numeric-desc:before{content:"\f163"}.fa-thumbs-up:before{content:"\f164"}.fa-thumbs-down:before{content:"\f165"}.fa-youtube-square:before{content:"\f166"}.fa-youtube:before{content:"\f167"}.fa-xing:before{content:"\f168"}.fa-xing-square:before{content:"\f169"}.fa-youtube-play:before{content:"\f16a"}.fa-dropbox:before{content:"\f16b"}.fa-stack-overflow:before{content:"\f16c"}.fa-instagram:before{content:"\f16d"}.fa-flickr:before{content:"\f16e"}.fa-adn:before{content:"\f170"}.fa-bitbucket:before{content:"\f171"}.fa-bitbucket-square:before{content:"\f172"}.fa-tumblr:before{content:"\f173"}.fa-tumblr-square:before{content:"\f174"}.fa-long-arrow-down:before{content:"\f175"}.fa-long-arrow-up:before{content:"\f176"}.fa-long-arrow-left:before{content:"\f177"}.fa-long-arrow-right:before{content:"\f178"}.fa-apple:before{content:"\f179"}.fa-windows:before{content:"\f17a"}.fa-android:before{content:"\f17b"}.fa-linux:before{content:"\f17c"}.fa-dribbble:before{content:"\f17d"}.fa-skype:before{content:"\f17e"}.fa-foursquare:before{content:"\f180"}.fa-trello:before{content:"\f181"}.fa-female:before{content:"\f182"}.fa-male:before{content:"\f183"}.fa-gittip:before,.fa-gratipay:before{content:"\f184"}.fa-sun-o:before{content:"\f185"}.fa-moon-o:before{content:"\f186"}.fa-archive:before{content:"\f187"}.fa-bug:before{content:"\f188"}.fa-vk:before{content:"\f189"}.fa-weibo:before{content:"\f18a"}.fa-renren:before{content:"\f18b"}.fa-pagelines:before{content:"\f18c"}.fa-stack-exchange:before{content:"\f18d"}.fa-arrow-circle-o-right:before{content:"\f18e"}.fa-arrow-circle-o-left:before{content:"\f190"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\f191"}.fa-dot-circle-o:before{content:"\f192"}.fa-wheelchair:before{content:"\f193"}.fa-vimeo-square:before{content:"\f194"}.fa-turkish-lira:before,.fa-try:before{content:"\f195"}.fa-plus-square-o:before{content:"\f196"}.fa-space-shuttle:before{content:"\f197"}.fa-slack:before{content:"\f198"}.fa-envelope-square:before{content:"\f199"}.fa-wordpress:before{content:"\f19a"}.fa-openid:before{content:"\f19b"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\f19c"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\f19d"}.fa-yahoo:before{content:"\f19e"}.fa-google:before{content:"\f1a0"}.fa-reddit:before{content:"\f1a1"}.fa-reddit-square:before{content:"\f1a2"}.fa-stumbleupon-circle:before{content:"\f1a3"}.fa-stumbleupon:before{content:"\f1a4"}.fa-delicious:before{content:"\f1a5"}.fa-digg:before{content:"\f1a6"}.fa-pied-piper-pp:before{content:"\f1a7"}.fa-pied-piper-alt:before{content:"\f1a8"}.fa-drupal:before{content:"\f1a9"}.fa-joomla:before{content:"\f1aa"}.fa-language:before{content:"\f1ab"}.fa-fax:before{content:"\f1ac"}.fa-building:before{content:"\f1ad"}.fa-child:before{content:"\f1ae"}.fa-paw:before{content:"\f1b0"}.fa-spoon:before{content:"\f1b1"}.fa-cube:before{content:"\f1b2"}.fa-cubes:before{content:"\f1b3"}.fa-behance:before{content:"\f1b4"}.fa-behance-square:before{content:"\f1b5"}.fa-steam:before{content:"\f1b6"}.fa-steam-square:before{content:"\f1b7"}.fa-recycle:before{content:"\f1b8"}.fa-automobile:before,.fa-car:before{content:"\f1b9"}.fa-cab:before,.fa-taxi:before{content:"\f1ba"}.fa-tree:before{content:"\f1bb"}.fa-spotify:before{content:"\f1bc"}.fa-deviantart:before{content:"\f1bd"}.fa-soundcloud:before{content:"\f1be"}.fa-database:before{content:"\f1c0"}.fa-file-pdf-o:before{content:"\f1c1"}.fa-file-word-o:before{content:"\f1c2"}.fa-file-excel-o:before{content:"\f1c3"}.fa-file-powerpoint-o:before{content:"\f1c4"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\f1c5"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\f1c6"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\f1c7"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\f1c8"}.fa-file-code-o:before{content:"\f1c9"}.fa-vine:before{content:"\f1ca"}.fa-codepen:before{content:"\f1cb"}.fa-jsfiddle:before{content:"\f1cc"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\f1cd"}.fa-circle-o-notch:before{content:"\f1ce"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"\f1d0"}.fa-ge:before,.fa-empire:before{content:"\f1d1"}.fa-git-square:before{content:"\f1d2"}.fa-git:before{content:"\f1d3"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"\f1d4"}.fa-tencent-weibo:before{content:"\f1d5"}.fa-qq:before{content:"\f1d6"}.fa-wechat:before,.fa-weixin:before{content:"\f1d7"}.fa-send:before,.fa-paper-plane:before{content:"\f1d8"}.fa-send-o:before,.fa-paper-plane-o:before{content:"\f1d9"}.fa-history:before{content:"\f1da"}.fa-circle-thin:before{content:"\f1db"}.fa-header:before{content:"\f1dc"}.fa-paragraph:before{content:"\f1dd"}.fa-sliders:before{content:"\f1de"}.fa-share-alt:before{content:"\f1e0"}.fa-share-alt-square:before{content:"\f1e1"}.fa-bomb:before{content:"\f1e2"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\f1e3"}.fa-tty:before{content:"\f1e4"}.fa-binoculars:before{content:"\f1e5"}.fa-plug:before{content:"\f1e6"}.fa-slideshare:before{content:"\f1e7"}.fa-twitch:before{content:"\f1e8"}.fa-yelp:before{content:"\f1e9"}.fa-newspaper-o:before{content:"\f1ea"}.fa-wifi:before{content:"\f1eb"}.fa-calculator:before{content:"\f1ec"}.fa-paypal:before{content:"\f1ed"}.fa-google-wallet:before{content:"\f1ee"}.fa-cc-visa:before{content:"\f1f0"}.fa-cc-mastercard:before{content:"\f1f1"}.fa-cc-discover:before{content:"\f1f2"}.fa-cc-amex:before{content:"\f1f3"}.fa-cc-paypal:before{content:"\f1f4"}.fa-cc-stripe:before{content:"\f1f5"}.fa-bell-slash:before{content:"\f1f6"}.fa-bell-slash-o:before{content:"\f1f7"}.fa-trash:before{content:"\f1f8"}.fa-copyright:before{content:"\f1f9"}.fa-at:before{content:"\f1fa"}.fa-eyedropper:before{content:"\f1fb"}.fa-paint-brush:before{content:"\f1fc"}.fa-birthday-cake:before{content:"\f1fd"}.fa-area-chart:before{content:"\f1fe"}.fa-pie-chart:before{content:"\f200"}.fa-line-chart:before{content:"\f201"}.fa-lastfm:before{content:"\f202"}.fa-lastfm-square:before{content:"\f203"}.fa-toggle-off:before{content:"\f204"}.fa-toggle-on:before{content:"\f205"}.fa-bicycle:before{content:"\f206"}.fa-bus:before{content:"\f207"}.fa-ioxhost:before{content:"\f208"}.fa-angellist:before{content:"\f209"}.fa-cc:before{content:"\f20a"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\f20b"}.fa-meanpath:before{content:"\f20c"}.fa-buysellads:before{content:"\f20d"}.fa-connectdevelop:before{content:"\f20e"}.fa-dashcube:before{content:"\f210"}.fa-forumbee:before{content:"\f211"}.fa-leanpub:before{content:"\f212"}.fa-sellsy:before{content:"\f213"}.fa-shirtsinbulk:before{content:"\f214"}.fa-simplybuilt:before{content:"\f215"}.fa-skyatlas:before{content:"\f216"}.fa-cart-plus:before{content:"\f217"}.fa-cart-arrow-down:before{content:"\f218"}.fa-diamond:before{content:"\f219"}.fa-ship:before{content:"\f21a"}.fa-user-secret:before{content:"\f21b"}.fa-motorcycle:before{content:"\f21c"}.fa-street-view:before{content:"\f21d"}.fa-heartbeat:before{content:"\f21e"}.fa-venus:before{content:"\f221"}.fa-mars:before{content:"\f222"}.fa-mercury:before{content:"\f223"}.fa-intersex:before,.fa-transgender:before{content:"\f224"}.fa-transgender-alt:before{content:"\f225"}.fa-venus-double:before{content:"\f226"}.fa-mars-double:before{content:"\f227"}.fa-venus-mars:before{content:"\f228"}.fa-mars-stroke:before{content:"\f229"}.fa-mars-stroke-v:before{content:"\f22a"}.fa-mars-stroke-h:before{content:"\f22b"}.fa-neuter:before{content:"\f22c"}.fa-genderless:before{content:"\f22d"}.fa-facebook-official:before{content:"\f230"}.fa-pinterest-p:before{content:"\f231"}.fa-whatsapp:before{content:"\f232"}.fa-server:before{content:"\f233"}.fa-user-plus:before{content:"\f234"}.fa-user-times:before{content:"\f235"}.fa-hotel:before,.fa-bed:before{content:"\f236"}.fa-viacoin:before{content:"\f237"}.fa-train:before{content:"\f238"}.fa-subway:before{content:"\f239"}.fa-medium:before{content:"\f23a"}.fa-yc:before,.fa-y-combinator:before{content:"\f23b"}.fa-optin-monster:before{content:"\f23c"}.fa-opencart:before{content:"\f23d"}.fa-expeditedssl:before{content:"\f23e"}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"\f240"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"\f241"}.fa-battery-2:before,.fa-battery-half:before{content:"\f242"}.fa-battery-1:before,.fa-battery-quarter:before{content:"\f243"}.fa-battery-0:before,.fa-battery-empty:before{content:"\f244"}.fa-mouse-pointer:before{content:"\f245"}.fa-i-cursor:before{content:"\f246"}.fa-object-group:before{content:"\f247"}.fa-object-ungroup:before{content:"\f248"}.fa-sticky-note:before{content:"\f249"}.fa-sticky-note-o:before{content:"\f24a"}.fa-cc-jcb:before{content:"\f24b"}.fa-cc-diners-club:before{content:"\f24c"}.fa-clone:before{content:"\f24d"}.fa-balance-scale:before{content:"\f24e"}.fa-hourglass-o:before{content:"\f250"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"\f251"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"\f252"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"\f253"}.fa-hourglass:before{content:"\f254"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"\f255"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"\f256"}.fa-hand-scissors-o:before{content:"\f257"}.fa-hand-lizard-o:before{content:"\f258"}.fa-hand-spock-o:before{content:"\f259"}.fa-hand-pointer-o:before{content:"\f25a"}.fa-hand-peace-o:before{content:"\f25b"}.fa-trademark:before{content:"\f25c"}.fa-registered:before{content:"\f25d"}.fa-creative-commons:before{content:"\f25e"}.fa-gg:before{content:"\f260"}.fa-gg-circle:before{content:"\f261"}.fa-tripadvisor:before{content:"\f262"}.fa-odnoklassniki:before{content:"\f263"}.fa-odnoklassniki-square:before{content:"\f264"}.fa-get-pocket:before{content:"\f265"}.fa-wikipedia-w:before{content:"\f266"}.fa-safari:before{content:"\f267"}.fa-chrome:before{content:"\f268"}.fa-firefox:before{content:"\f269"}.fa-opera:before{content:"\f26a"}.fa-internet-explorer:before{content:"\f26b"}.fa-tv:before,.fa-television:before{content:"\f26c"}.fa-contao:before{content:"\f26d"}.fa-500px:before{content:"\f26e"}.fa-amazon:before{content:"\f270"}.fa-calendar-plus-o:before{content:"\f271"}.fa-calendar-minus-o:before{content:"\f272"}.fa-calendar-times-o:before{content:"\f273"}.fa-calendar-check-o:before{content:"\f274"}.fa-industry:before{content:"\f275"}.fa-map-pin:before{content:"\f276"}.fa-map-signs:before{content:"\f277"}.fa-map-o:before{content:"\f278"}.fa-map:before{content:"\f279"}.fa-commenting:before{content:"\f27a"}.fa-commenting-o:before{content:"\f27b"}.fa-houzz:before{content:"\f27c"}.fa-vimeo:before{content:"\f27d"}.fa-black-tie:before{content:"\f27e"}.fa-fonticons:before{content:"\f280"}.fa-reddit-alien:before{content:"\f281"}.fa-edge:before{content:"\f282"}.fa-credit-card-alt:before{content:"\f283"}.fa-codiepie:before{content:"\f284"}.fa-modx:before{content:"\f285"}.fa-fort-awesome:before{content:"\f286"}.fa-usb:before{content:"\f287"}.fa-product-hunt:before{content:"\f288"}.fa-mixcloud:before{content:"\f289"}.fa-scribd:before{content:"\f28a"}.fa-pause-circle:before{content:"\f28b"}.fa-pause-circle-o:before{content:"\f28c"}.fa-stop-circle:before{content:"\f28d"}.fa-stop-circle-o:before{content:"\f28e"}.fa-shopping-bag:before{content:"\f290"}.fa-shopping-basket:before{content:"\f291"}.fa-hashtag:before{content:"\f292"}.fa-bluetooth:before{content:"\f293"}.fa-bluetooth-b:before{content:"\f294"}.fa-percent:before{content:"\f295"}.fa-gitlab:before{content:"\f296"}.fa-wpbeginner:before{content:"\f297"}.fa-wpforms:before{content:"\f298"}.fa-envira:before{content:"\f299"}.fa-universal-access:before{content:"\f29a"}.fa-wheelchair-alt:before{content:"\f29b"}.fa-question-circle-o:before{content:"\f29c"}.fa-blind:before{content:"\f29d"}.fa-audio-description:before{content:"\f29e"}.fa-volume-control-phone:before{content:"\f2a0"}.fa-braille:before{content:"\f2a1"}.fa-assistive-listening-systems:before{content:"\f2a2"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"\f2a3"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"\f2a4"}.fa-glide:before{content:"\f2a5"}.fa-glide-g:before{content:"\f2a6"}.fa-signing:before,.fa-sign-language:before{content:"\f2a7"}.fa-low-vision:before{content:"\f2a8"}.fa-viadeo:before{content:"\f2a9"}.fa-viadeo-square:before{content:"\f2aa"}.fa-snapchat:before{content:"\f2ab"}.fa-snapchat-ghost:before{content:"\f2ac"}.fa-snapchat-square:before{content:"\f2ad"}.fa-pied-piper:before{content:"\f2ae"}.fa-first-order:before{content:"\f2b0"}.fa-yoast:before{content:"\f2b1"}.fa-themeisle:before{content:"\f2b2"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"\f2b3"}.fa-fa:before,.fa-font-awesome:before{content:"\f2b4"}.fa-handshake-o:before{content:"\f2b5"}.fa-envelope-open:before{content:"\f2b6"}.fa-envelope-open-o:before{content:"\f2b7"}.fa-linode:before{content:"\f2b8"}.fa-address-book:before{content:"\f2b9"}.fa-address-book-o:before{content:"\f2ba"}.fa-vcard:before,.fa-address-card:before{content:"\f2bb"}.fa-vcard-o:before,.fa-address-card-o:before{content:"\f2bc"}.fa-user-circle:before{content:"\f2bd"}.fa-user-circle-o:before{content:"\f2be"}.fa-user-o:before{content:"\f2c0"}.fa-id-badge:before{content:"\f2c1"}.fa-drivers-license:before,.fa-id-card:before{content:"\f2c2"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"\f2c3"}.fa-quora:before{content:"\f2c4"}.fa-free-code-camp:before{content:"\f2c5"}.fa-telegram:before{content:"\f2c6"}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"\f2c7"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"\f2c8"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"\f2c9"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"\f2ca"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"\f2cb"}.fa-shower:before{content:"\f2cc"}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"\f2cd"}.fa-podcast:before{content:"\f2ce"}.fa-window-maximize:before{content:"\f2d0"}.fa-window-minimize:before{content:"\f2d1"}.fa-window-restore:before{content:"\f2d2"}.fa-times-rectangle:before,.fa-window-close:before{content:"\f2d3"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"\f2d4"}.fa-bandcamp:before{content:"\f2d5"}.fa-grav:before{content:"\f2d6"}.fa-etsy:before{content:"\f2d7"}.fa-imdb:before{content:"\f2d8"}.fa-ravelry:before{content:"\f2d9"}.fa-eercast:before{content:"\f2da"}.fa-microchip:before{content:"\f2db"}.fa-snowflake-o:before{content:"\f2dc"}.fa-superpowers:before{content:"\f2dd"}.fa-wpexplorer:before{content:"\f2de"}.fa-meetup:before{content:"\f2e0"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}]]></content>
  </entry>
  <entry>
    <title><![CDATA[跳跃表实现]]></title>
    <url>%2F2020%2F12%2F04%2F%E8%B7%B3%E8%B7%83%E8%A1%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172class Node&#123; private $id; public $value; public $level; public $forward = []; public function __construct($value, $level) &#123; $this-&gt;id = uniqid(); $this-&gt;level = $level; $this-&gt;value = $value; for ($i = 0; $i &lt; $level; $i++) &#123; $this-&gt;forward[$i] = 0; &#125; &#125; public function getID() &#123; return $this-&gt;id; &#125;&#125;class SkipList&#123; private $maxLevel; public $nodePool = []; public $header; public function __construct($maxLevel) &#123; $this-&gt;maxLevel = $maxLevel; $header = new Node(-1, $maxLevel); $this-&gt;addToNodePool($header-&gt;getID(), $header); $this-&gt;header = $header-&gt;getID(); &#125; public function addToNodePool($id, $object) &#123; $this-&gt;nodePool[$id] = $object; &#125; /** * @param $id * @return Node */ public function getFromNodePool($id) &#123; return isset($this-&gt;nodePool[$id]) ? $this-&gt;nodePool[$id] : null; &#125; public function insert($value) &#123; $visitTrace = []; $count = 0; $tmp = $this-&gt;getFromNodePool($this-&gt;header); for ($i = $this-&gt;maxLevel - 1; $i &gt;= 0; $i--) &#123; while ($tmp &amp;&amp; $tmp-&gt;forward[$i]) &#123; $count++; if ($count &gt; 20) &#123; break; &#125; $forward = $this-&gt;getFromNodePool($tmp-&gt;forward[$i]); if ($forward-&gt;value &lt; $value) &#123; $tmp = $forward; &#125; else if ($forward-&gt;value &gt; $value) &#123; break; &#125; else &#123; return false; &#125; &#125; if ($tmp) &#123; $visitTrace[$i] = $tmp-&gt;getID(); &#125; &#125; $level = $this-&gt;randomLevel(); $newNode = new Node($value, $level); $this-&gt;addToNodePool($newNode-&gt;getID(), $newNode); for ($i = 0; $i &lt; $level; $i++) &#123; $trace = $this-&gt;getFromNodePool($visitTrace[$i]); $newNode-&gt;forward[$i] = $trace-&gt;forward[$i]; $trace-&gt;forward[$i] = $newNode-&gt;getID(); &#125; return true; &#125; public function find($value) &#123; $tmp = $this-&gt;getFromNodePool($this-&gt;header); $count = 0; for ($i = $this-&gt;maxLevel - 1; $i &gt;= 0; $i--) &#123; while ($tmp &amp;&amp; $tmp-&gt;forward[$i]) &#123; $count++; if ($count &gt; 20) &#123; break; &#125; $forward = $this-&gt;getFromNodePool($tmp-&gt;forward[$i]); if ($forward-&gt;value &lt; $value) &#123; $tmp = $forward; &#125; else if ($forward-&gt;value &gt; $value) &#123; break; &#125; else &#123; return true; &#125; &#125; &#125; return false; &#125; private function randomLevel() &#123; $level = 1; if (rand(0, 1) &amp;&amp; $level &lt; $this-&gt;maxLevel) &#123; $level++; &#125; return $level; &#125;&#125;$testData = [898888, 300, 234, 123, 333, 456, 23, 99];$skipList = new SkipList(3);foreach ($testData as $value) &#123; $skipList-&gt;insert($value);&#125;$test = [898888, 300, 234, 123, 333, 456, 23, 99, 100, 111];foreach ($test as $value) &#123; $result = $skipList-&gt;find($value); if (in_array($value, $testData) &amp;&amp; in_array($value, $test)) &#123; if ($result) &#123; echo '正确&lt;br&gt;'; &#125; else &#123; echo '错误&lt;br&gt;'; &#125; &#125; else &#123; if ($result) &#123; echo '错误&lt;br&gt;'; &#125; else &#123; echo '正确&lt;br&gt;'; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是跳跃表？]]></title>
    <url>%2F2020%2F12%2F04%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
  </entry>
  <entry>
    <title><![CDATA[第五章 主要反转形态]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%BB%E8%A6%81%E5%8F%8D%E8%BD%AC%E5%BD%A2%E6%80%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言到这里，我们已经涉猎了道氏理论，这是目前实际应用的绝大多数趋势顺应机制的理论起点；也探讨了趋势的基本概念，诸如支撑、阻挡和趋势线等；对交易量和持仓兴趣也作了介绍。那么下一步，就该学习图表形态了。很快我们就会发现，这些形态就是建立在上述概念的基础之上的。 上一章，我们把趋势定义为一系列依次上升或下降的峰和谷。只要它们相对变化的方向向上，则趋势向上；如果其相对变化的方向向下，那么趋势就向下。我们还强调指出，在相当部分时间内，市场处于横向伸展的态势之中。而正是这种横向延伸的市场运动，构成了接下来两章的主要课题。 千万不要以为绝大部分趋势的变化突如其来，事实上，趋势在发生重要变异之前，通常需要一段酝酿的时间。问题就在于，这种酝酿时期并不总意味着趋势将要逆转，有时候，这只是既存趋势的休整，随后原有的趋势仍将继续。 价格形态研究这种酝酿时期及其预测性意义就是价格形态所要解决的问题。那么，什么是价格形态呢？价格形态是股票或期货价格图上的特定图案或花样，它们具有预测性价值，我们可以把它们分门别类。 形态具有两个类别：反转型和持续型 价格形态有两种最主要的分类—反转型形态和持续型形态。反转形态名符其实，意味着趋势正在发生重要反转；相反地，持续形态显示市场很可能仅仅是暂时作一段时间的休整，把近期的超买或超卖状况调整一番，过后，现存趋势仍将继续发展。关键是，必须在形态形成的过程中尽早判别出其所属类型。 本章将讨论五种最常用的主要反转形态：头肩形、三重顶（底）、双重顶（底）、V字顶（底）、以及圆形（盆形）顶（底）等形态。我们将考察价格本身的变化过程，及其变化在图表上的显示，还有判别它们的方法。然后，我们还要研究另外两方面重要因素—伴生的交易量的形态，以及价格形态的测算意义。 交易量在所有价格形态中，都起到重要的验证作用。在形势不明时（许多情况下都是这样的），研究一下与价格数据伴生的交易量形态，是判断当前价格形态是否可靠的决定性办法。 绝大多数价格形态各有其具体的测算技术，可以确定出最小价格目标。虽然这些目标仅仅是对下一步市场运动的大致估算，但仍有助于交易商确定其报偿—风险比。 下一章，我们将讨论形态的另一个大类—持续型形态，内容包括三角形、旗形和三角旗形、楔形、以及矩形。 这类形态通常反映出现行趋势正处于休整状态，而不是趋势的反转，因此，通常被归纳为中等的或次要的形态，算不上主要形态。 反转形态所共有的基本要领 在单独地剖析各个主要反转形态之前，我们先交待所有反转形态所共有的几个基本要领。 1.在市场上事先确有趋势存在，是所有反转形态存在的前提。 2.现行趋势即将反转的第一个信号，经常是重要的趋势线被突破。 3.形态的规模越大，则随之而来的市场动作越大。 4.顶部形态所经历的时间通常短于底部形态，但其波动性较强。 5.底部形态的价格范围通常较小，但其酝酿时间较长。 6.交易量在验证向上突破信号的可靠性方面，更具参考价值。 事先存在趋势的必要性。市场上确有趋势存在是所有反转形态存在的先决条件。市场必需先有明确的目标，然后才谈得上反转。在图表上，偶尔会出现一些与反转形态相像的图形，但是如果事前并无趋势存在，那么它便无物可反，因而意义有限。在我们辩识形态的过程中，正确把握趋势的总体结构，有的放矢地对最可能出现一定形态的阶段提高警惕，是成功的关键。 正因为反转形态事先必须有趋势可反，所以它才具备了测算意义。前面曾强调，绝大多数测算技术仅仅给出最小价格目标，那么，最大目标就是事前趋势的起点。如果市场发生过一轮主要的牛市，并且主要反转形态已经完成，就预示着价格向下运动的最大余地便是100%地回撤整个牛市，从它的终点回到它的起点。 重要趋势线的突破即将降临的反转过程，经常以突破重要的趋势线为其前兆。不过朋友们请记住，主要趋势线被突破，并不一定意味着趋势的反转。这个信号本身的意义是，原趋势正有所改变。主要向上趋势线被突破后，或许表示横向延伸的价格形态开始出场，以后，随着事态的进一步发展，我们才能够把该形态确认为反转型或连续型。 在有些情况下，主要趋势线被突破同价格形态的完成恰好同步实现。 形态的规模越大，则随之而来的市场动作越大。这里所谓规模大小，是就价格形态的高度和宽度而言的。高度标志着形态的波动性的强弱，而宽度则代表着该形态从发展到完成所花费的时间的多寡。形态的规模越大—即价格在形态内摆动的范围（高度）越大、经历的时间（宽度）越长—那么该形态就越重要，随之而来的价格运动的余地就越大。 实际上，这两章所介绍的所有的测算技术，均是以形态高度为基础的。这种方法主要适用于线图，这就是所谓垂直测算原则。而测量价格形态横向宽度的方法，通常应用在点数图分析中。在后面要讲的这种图表分析法中，采用了“横向数算”的技术，它认为顶或底部形态的宽度，同随之而来的价格运动的目标之间，存在着一一对应的关系。 顶和底的差别。顶部形态与底部形态相比，它的持续时间短但波动性更强。在顶部形态中，价格波动不但幅度更大，而且更剧烈，它的形成时间也较短。底部形态通常具有较小的价格波动幅度，但耗费的时间较长。正因如此，辨别和捕捉市场底部比捕捉其顶部，通常来得容易些，损失也相应少些。不过对喜欢“压顶”的朋友来说，尚有一点可资安慰，即价格通常倾向于跌快而升慢，因而顶部形态尽管难于对付，却也自有其引人之处。通常，交易商在捕捉住熊市的卖出机会的时候比抓住牛市的买入机会的时候，盈利快得多。事实上，一切都是风险与回报之间的平 衡。较高的风险从较高的回报中获得补偿，反之亦然。顶部形态虽然更难捕捉，却也更具盈利的潜力。 交易量在验证向上突破信号时更具重要性。交易量一般应该顺着市场趋势的方向相应地增长，这是验证所有价 格形态完成与否的重要线索。任何形态在完成时，均应伴随着交易量的显著增加。但是，在趋势的顶部反转过程的早期，交易量并不如此重要。一旦熊市潜入，市场惯于“因自重而下降”。图表分析者当然希望看到，在价格下跌的同时，交易活动也更为活跃，不过，在顶部反转过程中，这不是关键。然而，在底部反转过程中，交易量的相应扩张，却是绝对必需的。如果当价格向上突破的时候，交易量形态并未呈现出显著增长的态势，那么，整个价格形态 的可靠性，就值得怀疑了。在第七章中，我们将更深入地研究交易量。 头肩形反转形态 我们现在来细细地探讨一下头肩形反转形态。这种反转形态可能是最著名、最可靠的。我们将花费较多的篇幅来研究这类形态，因为一方面它本身颇为重要。另一方面，我们也需要通过它来讲解各种新概念。其它绝大多数反转形态仅仅是头肩形的变体，因此，等以后讲到它们的时候，我们就可以省却许多笔墨了。 就如其余所有的反转形态一样，头肩形主要反转形态其实也是前一章中的趋势概念的进一步提炼。举例来说， 在上升趋势中，一系列依次上升的波峰和波谷首先把上涨势头逐渐放缓，然后上升趋势开始停顿。此时，供求双方的力量对比处于相对平衡之中。一旦这个“消散阶段”完成，那么，上述调整的横向交易区间底边处的支撑就被打破了，从而，市场确立了新的下降趋势，反转形态大功告成。新的下降趋势具备依次降低的波峰和波谷。 我们来看看在头肩形顶中上述情况的具体表现（见图5.1a和b）。在点A，上升趋势一如既往，毫无反转的迹 向。交易量在价格上升到新高度的同时，也相应地扩张，表现正常。在B点的调整性下降中，交易量见轻，也符合要求。然而到了点C，警觉的图表分析者或许注意到，当这一轮上涨向上突破点A时，其交易量同前一轮上涨时的交易量相比，已经有所减少。虽然这个变化本身并不具有重大意义，但是这时候，分析者应该在脑海里亮起一盏黄色警告灯了。 后来，价格跌回到点D，出现了一些更令人困惑的问题。这一轮下跌的低点低于从前的高点A。请记住，在上升趋势中，以前的高点一旦被向上穿越后就在随后的市场调整中起到支撑作用。而这次下跌明显地低于A点，几乎达到前一个向上反弹的低点 B 的水平，这就是个警讯，说明该上升趋势可能出了问题。 图5.1a 头肩形顶的例子。左肩和右肩（A和E）的高度差不多相同，头（C）比两肩高。请注意在每个峰处逐渐减轻的交易量。当收市价居于颈线（2线）之下时，形态完成。其最近目标的求法是，自颈线上的突破点起，向下投射从头部到颈线的竖直距离。突破颈线后，常常出现回向颈线的反扑现象，但它不应再返回颈线的另一边 图5.1b 头肩形顶。其中有三个峰，头部高于两肩。注意观察在右肩形成前， 主要上升趋势线是如何被突破的。也请注意向下突破颈线后的返回颈线的反扑现象。从颈线上的突破点起，向下投射头部到颈线的竖直距离，就得到最小价格目标 然后，市场再次上冲到点E，这一次，交易量更轻，甚至不能达到冲击高点C时的水平（点E这轮最后的冲击，经常回撤到从点D到C之间下降幅度的一半到三分之二之间）。我们知道，如果上升趋势要持续发展，则每一轮新高点都必须超过前一轮上冲高点。点 E 处的上升无力达到前一轮高点 C，满足了新的下降趋势所要求的一半条件—即依次下降的波峰。 到了这个时候，在点 D，主要上升趋势线（线1）通常已经被跌破，从而构成了另一个危险信号。但是，尽管发生了上述许多警告讯号，此时我们唯一可以肯定的一点是：趋势已经从上升转化成横向延伸了。这也许是了结多头头寸的充分根据，但还不足以构成卖出做空头的理由。 突破颈线，完成形态 至此，通过最后两个向上反弹的低点（点B和点D），我们可以作出一条较为平缓的趋势线，称为颈线（如线2所示）。在顶部，颈线一般轻微上斜（尽管有时也可能水平，或者在更少数情况下略倾斜向下）。头肩顶成立的决定 性因素是，收市价格明确地突破到颈线之下。在这种情况下，市场终于突破了由底点B和D构成的趋势线，并跌破D点的支撑，从而完全满足了新趋势产生的前提条件—依次下降的峰和谷。于是，从依次下降的峰点和谷点C、D、E、F上，我们可以确定新的一轮下降趋势。顺便说明一下，在顶部形态完成后的初始阶段，当市场向下突破时交易量是否急剧扩张并不是至关重要的。 反扑 接下来，通常市场会出现反扑现象，即价格重新弹回颈线或者前一个向上反弹的低点D（如点G所示）。此时，这两者均已在市场上方构成了阻挡。反扑现象并不一定总能发生，有时或者只能形成一段极小的反弹。交易量也许有助于我们推测这种反弹的幅度大小。如果在突破颈线的初始阶段交易量极重，那么反扑的余地便大为减小，因为 上述突然增加的交易活动反应出市场上较重的向下压力。反过来，如果初始突破时的交易量较轻，那么反扑的可能性便大为增加。无论如何，这种反弹应当以较少的交易量进行，并且随后，当新的下降趋势恢复下跌的时侯，应该伴随着显著加重的交易活动。 小结我们来归纳一下形成头肩顶的各个要素。 1.事先的上升趋势。2.左肩（点A）伴随著较重的交易量，且之后市场向下调整到点B。3.以较轻的交易量上冲到新高点（点C）。4.随后的下跌低于前一个峰（A点处），且接近前一个向上反弹低点（点D）。5.第三轮上冲（点E）具有显著减轻的交易量，且无力达到头顶的高度（点C处）。6.收市价低于颈线。7.反扑回颈线（点G），然后下跌至新低点 这里有三个显著的波峰，它们的界定颇为明确。中间的峰（头）稍高于双肩（点A和E）。然而，只有当市场以收市价格的形式，决定性地突破颈线之后，该形态才得以最后完成。同样地，我们也可以采用3%穿越原则（或在前一章所介绍的其余价格过滤器）、或者双日原则（即市场连续两天收市于颈线之下），作为进一步的验证手段。另外， 除非确实发生了向下突破，不然始终存在以下这种可能性：整个图形并不是真正的头肩顶，在未来某一时刻，上升 趋势也许仍将恢复。 交易量的重要性 与价格变化相对应的交易量形态，在头肩顶形态的发展过程中担负着重要的角色。在其它的价格形态中，交易量的作用也都如此。一般来说，第二高峰（头）的伴随交易量比左肩为轻。这一点倒不是必要条件，而是市场在这种情况下通常具有的一种强烈的倾向性，也是说明市场上买进压力减轻的早期警讯。最重要的交易量信号，发生在第三高峰（右肩），此处的交易量应比前两个高峰处显著地减轻。在突破趋势线的时候，交易量应扩张；在价格反扑时，交易量应减少。然后，一旦反扑完结，交易量便再度扩张。 我们曾经交代，在市场顶部的形成过程中，交易量的关键性比底部过程要逊色些。但是在某些场合，如果新生的下降趋势能够持续的话，交易量依然应当开始增加。而在市场的底部过程中，交易量则担负着更为关键的角色，很快我们将讨论这个问题。现在我们先讨论一下头肩形的测算意义。 发现价格目标 形态高度是测算价格目标的基础。具体做法是，先测出从头（点C）到颈线的垂直距离，然后从颈线上被突破 的点出发，向下投射相同的距离。举个例子。假定头顶位于100，相应的颈线位置在80，那么其垂直距离便是两者的差，20。如果颈线如图5.1a所示，那么我们就应该从颈线上的突破点开始，向下量出20点。突破点位于82，那么，向下突破的目标就被投射到62的水平（82-20-62）。 还有一种较简便的方法：先简单地量出下降运动中第一浪（从点C到D）的长度，然后往下翻出一番。这两种情况的道理都是一样的，形态高度越大（即波动性越大），那么其“前程”便越远大。第四章中所介绍的关于趋势线被穿越的测算技巧，同此处的头肩形测算方法类似。现在朋友们不妨比较比较。大略地说，价格在突破趋势线后所走出的距离，同它在趋势线之上曾经经历的距离相当。贯穿我们关于价格形态的讨论，你都将看到，线图上的绝大多数价格目标是建立在各种形态的高度（或者说，波动性）之上的。从突破点开始顺势投射与形态高度一致的距离，这是个老话题，我们将会一再地提起。 重要的是，上述价格目标仅仅是最近的目标，而实际上，价格运动经常越过上述目标。不过，如果我们对最近目标心中有数，那么对判断市场运动是否还有足够余地来开立头寸无疑是大有帮助的。即便市场越过了这个价格目标，那么剩下的也只是蛋糕上的那层奶油。当然，最大目标是原先趋势的整个范围。比如说，原先的牛市从30涨到了l00，那么从顶反转形态得出的最大下跌目标便为30，从哪里来，还回撤到哪里去。从反转形态上，我们仅能预期 市场对原先趋势的反转或回撤。 价格目标的调整 在我们预计价格目标的时候，还应当考虑到其余许多因素。价格形态本身的测算技巧（如上面介绍的关于头肩形顶的相应情况），只是第一个步骤。其余技术性因素也应予以考虑。举例来说，由原先牛市中的向上反弹低点所形成的重要支撑水平在何处？熊市经常会在这些水平上被扼止住。百分比回撤的位置怎样？最大回撤目标是原先牛市 的 100%回撤。但 50%和 66%回撤的水平又在哪里？它们同样常常成为市场下方的重要支撑。价格跳空的情况怎样？ 它们同样常常演变成支撑区域。另外，市场下方有无长期趋势线存在？ 在从价格形态确定价格目标时，技术分析者必须考虑其余技术资料。比如说，如果向下的价格测算目标是30，而32是一个重要支撑水平，那么，明智的做法是，把向下测算目标放在32，而不是30。一般地，当测算目标同清晰的支撑或阻挡水平只有微小差别的时候，我们通常把价格目标调整到这些支撑或阻挡水平上，以求可靠。这种综合考虑其余技术信息来调整价格形态测算目标的做法，常常是很有必要的。我们都知道，有许多不同的工具可供分 析者选择，那么，最巧妙的技术分析者正是那些懂得如何恰如其分地综合使用各种工具的人。 倒头肩形 头肩形底有时也被称为倒头肩形，它恰好与头肩形顶互为镜像。正如图5.2a所示，它具有三个清楚的底谷，其中头（中间的谷）稍低于两肩。收市价格决定性地向上突破颈线，也是该形态得以完成的必要条件，而且它的测算技术也与头肩形顶的一样。稍有差别的一点是，在底部，当颈线被向上突破后，市场更惯于反扑。 头肩顶和头肩底最重要的区别在与之配合的交易量序列上。在判别头肩底形态及其突破的时候，交易量起到更 为关键的验证作用。前面我们讲过，市场具有“因自重而下跌”的倾向性，因此在底部，当市场力图发动一轮牛市的时候，必须具有较多的交易量才行，也就是说，必须具有显著增强的买进推力。 图5.2a倒头肩形的例子。这种形态的底部形式是顶部形式的镜像。其中最重要的区别是在形态后半部分的交易量形态上。在底部过程中，自头部弹起的上冲，应当具有较重的变易量，而当颈线被突破时，交易活动应更是具有进发性的扩张。回向颈线的反扑在底部过程中也更多见。 图5.2b 倒头肩形底的实例。左肩形成于10月，右肩形成于5月。头部形成于2月和3月，其外形与 V 形反转底相似。7月，本图的CRB外汇期货 指数收市于为期8个月的颈线之上，从而构成了外汇市场的主要看涨信号。 我们不妨把这种市场特点同重力规律对照一下。我们都知道，当物体从手中释放后，无需我们再作努力，便很快地跌向地面。举起某物则是另一回事，我们必须付出劳动。要是朋友们对体育运动较有体验的话，请设想一下山路赛跑的情况。在下山时，我们一直会跑得很轻快。然而上山的赛程才是考验耐力的关键之处。“波士顿马拉松赛” 的场地末端是块上坡地，人称“伤心坡”，要是它是下坡的话，可能就会以“快活坡”这样的名字而著称了。 我们用更带技术性的方式来理解这个区别。市场常常会仅仅因为惯性而下降，但市场却不因为惯性而上升。需 求不足、或者交易商缺乏买进兴趣等原因，经常就足以把市场压低。但只有在需求超过供给，并且买方比卖方更积 极时，价格才能上涨。在本形态前半部分，交易量形态同头肩顶很相似。就是说，头部的交易量是比左肩的稍有减少。然而，在头部 的上冲阶段，不但应该显示出交易活动有所增加，而且其交易量水平经常要超过左肩的上冲对应的交易量水平。右肩下跌部分的交易量应该非常轻弱。关键时刻是市场突破颈线而上冲的时候。这个突破信号如果成立，那么所伴随的交易量非得相应地急剧膨胀不可。 这一点是头肩底同头肩顶最大的分别。在底部，强劲的交易量绝对是完成形态的关键组成部分。反扑在底部比 在顶部更经常发生，不过，其交易量应该轻弱。随后，新的上升趋势应该在较重的交易量下恢复。头肩形底的测算 方法与头肩顶相同。 颈线的倾斜程度 顶部的颈线通常稍稍倾斜向上，不过也有时是水平的。这两种情况并没有太大差异。然而，偶尔顶部的颈线会向下倾斜。这种坡度是市场疲弱的一种表现，通常，随之而来的右肩也很软弱。不过，这并不全是好消息，而是利弊参半。如果分析者要等顶线突破再开立头寸的话，就不得不等待较长时间，因为该信号在向下倾斜的颈线上出现得很晚，而且届时大部分的下降运动已经发生了。对底部形态而盲，绝大多数颈线稍倾向下。而向上倾斜的颈线意味着市场的坚挺，不过此处同样也有信号过迟的缺陷。 复杂头肩形形态 在我们的图表上，有时会出现一些头肩形的变体，称为复杂头肩形。这种形态可能呈现出双头或二个左肩和二 个右肩的情况。它们不如其原型常见，但具有同样的测算意义。对付这种情况有个窍门。那就是利用头肩形形态所具有的强烈的对称倾向。单个的左肩通常对应着单个的右肩，双重左肩则使出现双重右肩的可能性增加了不少。 对策 在所有的期货交易中，交易策略问题均是举足轻重的，我们在以后章节中还将更耀入地探讨。并非所有的技术型交易商都愿意等到颈线突破后，才开立新头寸，如图5.3所示，较为大胆积极的交易者在相信自己已经正确地判明头肩底之后，在右肩形成过程中就开始尝试着买进，或者在右肩下跌完结的第一个信号出现时就买进了。 图 5.3 头肩形底中的交易策略。右肩（E）尚处在形成过程中的时候，很多技术型交易商就开始建立多头 头寸了。在从点 C到D的上冲的一半到三分之二的回撤位置上，或者当价格跌向近期的支撑水平或支撑性跳空的时候，或者在价格跌到与左肩点 A的水平差不多的时候，或者当短暂的下降趋势线（线1）被向上突破时，统统是早期的入市机会。当颈线果然被突破后，或者事后发生回向颈线的反扑时，可以追加更多的头寸 有些人先测出从头部的底点上冲的距离（点 C 到 D），然后在其50%或66%回撤位置买进。还有些人会看看市场下方有无跳空存在，以利用之作为买进点。也有些人或许沿着点D和E画出一条短期的下降趋势线，该趋势线一被突破便买进。有些人考虑到这种形态具有相当的对称性，从而当右肩的发展接近了左肩的低点的水平时买进。这里要说明的是，在右肩形成过程中，会发生许多预期性的买进行为。如果上述尝试性头寸果真有利可图，那么，在颈线被实际穿越时或者在颈线突破后市场反扑时，交易商就会追加更多的买进头寸。 流产的头肩形形态 一旦价格越过颈线，头肩形形态就完成了，市场也就不应再返回颈线的另一边。在顶部，一旦颈线被向下突破 了，那么只要随后有任何一个收市价格返回到颈线上方，都是严重的警讯，表明此次突破可能是无效信号。显而易 见，这就是流产头肩形的由来。此类形态起初貌似典型的头肩形反转，但在其演化过程中的一定时刻（无论是在颈线突破前还是其稍后），价格将恢复原先的趋势。 由此，我们可以得出两条教训。其一，没有哪个图表形态百发百中。它们在大多数时间是成功的，但并不是永 远如此，其二，技术型交易商必须永远警惕自己分析中的错误信号。在期货市场，致胜的关键之一，就是要尽快摆 脱亏损的交易头寸（逮将在第十六章关于资金管理及其策略的讨论中介绍）。确保交易损失限于小额。这里，我们或 许可以为图表分析这门工具添加一条最实用的长处：它能够警告交易商认清现实、纠正错误。在期货行业，迅速地 发现并承认自己的交易决策错误，及时采取断然的保护性措施，这样的能力和意志力是难能可贵的，我们绝不可以等闲视之。 头肩形作为调整形态 在接着讲述下一种价格形态之前，关于头肩形尚有最后一点需要补充。本章开头曾把它列举为最广为人知且最可靠的主要反转形态。但是朋友们必须明白，本图形偶尔也会充当调整性形态而不是反转形态。不过，后面这种情 况与其说是贯例，不如说是例外。在第六章讨论持续型形态时我们将有详细讲解。 三重顶和三重底 我们在讨论头肩形形态时所引入的大部分要领，也适用于其它种类的反转形态（见图 5.4a 到c）。三重顶（或底），比头肩形少见得多，其实是前者的小小变体。其主要区别是，三重顶或底的三个峰或谷位于大致相同的水平上（见图5.4a）。在判断某个反转形态到底应属于头肩形还是三重顶的问题上，图表分析者经常有争议。因为两种形 态其实是一回事，所以这种论争是迂腐的。 在三重顶中，交易量往往随着相继的峰而递减，而在向下突破时则应增加。三重顶只有在沿着两个中间低点的 支撑水平被向下突破后，才得以完成。在三重底中，情况正相反，形态完成的必要条件是，收市价格向上越过两个中间峰值的水平（我们还有另一种对策，那就是把价格突破最邻近的峰或谷选作反转信号）。底部形态完成时，向上突破的交易量是否强劲有力，也是同样关键的。 它们的测算意义与头肩形相似，以形态的高度为基础。通常，价格在突破颈线后，由突破点起算，至少将要走出等于形态高度的距离。一旦突破，随后回向突破水平的反扑现象也很常见。考虑到三重顶（或底）只是头肩形形态的稍许变化，我们这里就不再赘述了。 图5.4a 三重顶。它与头肩形类似，只是其中三个峰都处在同一水平。每个上冲峰的交易量均应见轻。当其中两个谷被市场以较量的交易量向下跌破后，本形态宪结。其测算技术是，自突破点起，向下投射出与形态的高度相等的距离。在突破发生后，回向下方直线的反扑现象也不少见。 图5.4b 三重底。它与头肩形底类似，只是其中每个低点均处于同一个水 平上。它是三重顶的镜像，不过对于向上突破来说，交易量因素更重要。 图5.4c 三重顶反转。请注意，其中8月到9月所形成的三个峰均处于250的水平。220附近一直是支撑区，一旦被向下跌破，则演化成阻挡区。同时，还要注意，后来价格何其接近其下方的目标。如果朋友们仔细观察，那么将看出，在这个顶部形态中，当 价格下跌时，交易量更胜一筹。当11月发生向下的突破时，交易量更是显著地扩张。 双重顶和双重底 双重顶（或底）反转形态比三重顶（或底）常见得多，这种形态仅次于头肩形，出现得也很频繁，且易于辨识（见图5.5a到e）。图5.5a和5.5b各展示了双重顶和双重底的两个例子。出于显而易见的原因，这类顶经常被称为“M顶”，这类底被称为“W 底”。从一般特点上讲，双重顶与头肩形顶、三重顶类似，只是此处只有两个峰，而不是三个。交易量形态与测算法则也均类似。 在上升趋势中（如图5.5a所示），市场在点A确立了新的高点，通常其交易量亦有所增加。然后，在减少的交易量背景之下，市场跌至B点。到此为止，一切均符合上升趋势的正常要求，趋势进展良好。然而，下一轮上冲抵达了C点后，收市价格却无力穿越前一个高点 A 点。接着，价格就开始跌回。此时，一个潜在的双重顶便跃然纸上。我们之所以讲“潜在”，是因为这才是所有的反转形态成立的必要条件，而只有在收市价格突破前一个低点B的支撑之后，这个反转才能成立。除非发生突破，否则价格可能仅仅是处于横向延伸的调整阶段中，为原先趋势的恢复作准备。 理想的双重顶具有两个显著的峰，且其价格水平大致相同。交易量倾向于在第一个峰时较重，而在第二峰时较 轻。在较重交易量下，当价格决定性地收市于中间谷点 B 点之下时，顶部形态就完成了，标志着趋势向下方的反转。 以后，在下降趋势恢复之前，市场往往先要反扑回突破点的水平。 双重顶的测算技术 双重顶的测算方法是，自向下突破点（中间谷点B即被突破的价位）开始，往下投射与形态高度相等的距离。另一种方法是，先测出双重顶中第一条下降轨迹（点A到B）的幅度，然后从位于B点的中间谷点开始，向下投射相同的长度。双重底的测算方法一样，只是方向相反。 图 5.5a 双重顶的例子。本形态有二个峰（A 和C），处在大致相同的水平。当其中的中谷（点B）被收市价跌破后，本形态完结。通常，在第二个峰（点C）交易量较轻，而在向下突破时（点D），变易量有所增加。回向下方直线的反扑现象也不罕见。最小测算目标是，从突破点起，向下投射出与形态高度相等的距离 图 5.5b 双重底的例子，它是双重顶的镜像。对这里的向上突破来说，交易量因素更有份量。在底部形态中，回向突破点的反扑现象较多见。 图5.5c 双重底的实例。请注意在5月到6月期间，在5800附近形成了两个清晰的底。当价格收市于 6116 以上时，底部形态完成，趋势转而向上。注意，在图中右上角，价格已经从前一峰值（72）处挡下。 在上升趋势中，这种情况并不少见。但无论如何，价格必须收市于6916的低点之下，方可完成这个双重顶 图5.5d 双重顶和底的实例。注意在5月到6月间稍高于30的经典的双重顶。在7月到9月间的两个底部也有可能形成一个双重底。 图5.5e 在连续周线图上，反转形态出现得相当频繁。注意1983年下半年形成的头肩形顶。其中向下的价格目标效用不凡。也请注意接近150处的小些的双重底，以及174附近的潜在的双重顶。从这张图上，我们也许可以得出如下看法；1984年年底的高点可能是一个主要的双重顶的第二个峰。当然，市 场必须收市于 148 之下，才能确认这种看跌的解释。价格从重要的的阻挡水平上弹下的现象并不稀奇。 理想形态的变体 各种市场分析的领域都一样，现实情况通常都是理想模型的某种变体。比如说，有时双重顶的两个峰并不处于严格相同的水平上。有时第二峰相当疲弱，达不到第一峰的高度，这并不太成问题。而当第二峰实际上约略超过第一峰时，就出了些岔子。起初它貌似有效的向上突破，显示上升趋势已经恢复。然而好景不长，不久，它竟演化成 顶部过程的一个部分。为了解决这个两难问题，前面曾经提到过的那些过滤法则或许会派上用场。 过滤器 在判别突破成立与否的时候，大多数图表分析者都要求收市价格越过前一个阻挡峰值，而不仅仅是日内的穿越。 其次，我们还可以采用某种价格过滤器。其中的一例便是百分比穿越原则（例如1%或3%过滤器）。第三，也可以 选用双日穿越原则，这是时间过滤器的一例。换言之，为了证明向上穿越的有效性，价格必须接连两天收市于第一峰之上。 上述过滤器肯定不会是绝对可靠的，不过，它们的确有助于减少经常发生的错误信号（所谓“拉锯”现象）。这 些过滤器有时有效用，有时也没用。分析者必须清楚，他面对的是百分比概率和可能性，错误信号的出现是免不了的，这是交易现实的客观规律。 在牛市中，双重顶的最后一程或最后一波在建立新高点之后，掉头转而向下的现象并不稀奇。在这种情况下， 最后的一轮向上突破就形成了“牛市陷阱”（见图 5.6a 和 b）。但是足资安慰的是，绝大多数趋势信号还是能贯彻始 终的，否则，整个趋势顺应理论就要丧失一大半价值和一大半可靠性了。 图5.6a 图中为伪突破信号的例子。这种情常常称为“牛市陷阱”。有时，在接近 主要上升趋势的尾声时，价格先是向上超越先前的峰，而后却溃不成军。图表师借助 时间和价格过滤器来避开此类拉锯现象。这里的顶部形态很可能属于双重顶的类型。 图5.6b 伪向上突破信号的实例。注意,在图表上方,价格起先向上突破了过去的高点,发出了错误 的看涨信号,然后,它却掉转方向,完成了一个双重顶的形体。不过也请注意,价格并没能够在先前峰值上方维持 2 个相继的交易日。在这种情况下,如果采用了双日时间过滤器的话，就有可能避免亏损 “双重顶”术语被大大滥用了 “双重顶”术语在期货市场上被大大地滥用了，大多数潜在的双重顶（或底）最终演化得面目全非。归根结底，价格本具有从前一峰值挡下，或者从前一低点弹起的强烈倾向，这种价格变化正是市场在阻挡或支撑水平上的自然反应，其本身并不足以构成反转形态。请记着，在顶部，价格必须真正跌破前一个向上反弹的低点，才能表明双重顶成立。 注意，在图5.7a中，在点C，价格被前一个高点 A 挡下。这一变化在上升趋势中完全正常。然而，许多期货交易商在价格第一次试探前一个高点失败之后，马上就判断这个图形为双重顶。图5.7b显示了在下降趋势中的对应的情况。对图表分析师来说，要判定价格从前一个高点的下撤，到底是双重顶反转形态的开端，还是仅仅是既存趋势的暂时挫折（或者反过来，要判定从前一个低点的上弹是不是双重底反转形态的发韧），是极为困难的。在通常情况下，从技术角度看，趋势继续发展的可能性更大，所以明智的做法是，一定要等到形态完成之后，才采取相应的动作。 图 5.7a 在上升趋势中，在价格恢复上升之前， 图5.7b市场从先前的低点正常上弹的例子。这也属于先从过去的峰值正常挡下的例子。这属于正常的正常的市场行为，切不可与双重底混淆。在正常情况下，市场行为，切不可与双重顶混为一谈。仅当点B价格在达到先前的低点时，至少总要上弹一次。这种正 支的撑被跌破后，双重顶才能成立。 常现象可能诱使一些朋友犯了过早预期双重底的错误。 两峰或两谷之间的持续时间很重要 最后，形态的规模始终是很重要的一个方面。双峰之间持续的时间越长、形态的高度越大，则即将来临的反转的潜力越大。这一点对所有的图表形态而言，都是成立的。一般地，在最有效力的双重顶或底形态中，市场至少应该在双峰或双谷之间持续一个月，有时甚至可能达到两、三个月之久（在更大范围的月线图和周线图上，这类形态可能跨越数年）。这里所列举的大部分例子，是市场的顶部形态。现在朋友们应该清楚了，底部形态只是顶部形态的镜像，而两者之间的几点一般性的差别，在本章的开头部分我们已有交代。 圆顶和圆底 下面要讲的反转形态比前面几种都少见得多。它有好几个名字——圆顶或圆底、圆形、盆形或者碗形（如果系 顶部形态，则不妨加上“倒扣”二字）。本形态代表着趋势的很平缓的、逐渐的变化。图 5.8a 和 b 展示了这种图表形态。 请注意，图中价格从上升到下降、或者从下降到上升的变化过程，极为平缓。同时也请注意，图表下方的交易 量也倾向于形成相应的盆状形态。在顶部和底部，交易量均随着市场的逐步转向而收缩，最后，当新的价格方向占据主动时，又都相应地逐步增加。 有时在圆底中点的稍后的位置上（如图 5.8b 所示），价格在异乎寻常的重大交易量的背景之下突破，向上冲刺， 然后又回落到缓慢的圆形形态过程中。在底部的末端，有时会出现一个“盆把”（或者说“平台”），随后新的上升趋势将恢复。请注意，在交易量图上的圆底上，过了中点之后，交易量突然开始上升，随着价格进一步上涨，交易活动相应逐步增加；平台出现时，交易量下降；接下来，当价格向上方突破时，交易量又进一步扩张。 图 5.8a 圆顶的例子。上升趋势逐步丧失上升的动力，慢慢地转化为新的下降趋势。 注意，与之相应，交易量往往也形成了自己的圆形形态。这种顶部形态又称“倒扣碗形” 图5.8b圆底的例子。注意交易量的圆形形态。有时候，在底部形态的中点稍后，交易活动会突然增加。在右侧，常常形成平台，此类形态在底部比在顶部更多见。底部形态的完结既可以以A点的峰被向上突破为标志，也可以以点B处向上突破平台为标志。 我们很难确切地说圆形形态何时完成。如果在中点 A 处价格上冲，那么此后，当这个高点被向上穿越时，可能 就是牛市信号。还有一个变通的办法，即把从平台向上的突破，作为底部完成的信号。 圆底不具备精确的测算规则。不过技术分析师还是拥有其他各种技术工具，可以测算出新趋势的潜力。比如说，原有趋势的规模就是个重要的参考，能够提供价格回撤的一些大致范围。同时，圆形形态本身持续的时间也是很有价值的信息，其持续时间越长，则未来运动的潜力越大。另外，技术分析者还需要考虑其它要素——诸如原先的支 撑和阻挡水平、百分比回撤、跳空、或长期趋势线等等。 如前面所述，相对来说盆形或者圆形形态，出现得较不频繁。此处之所以要着重讲述圆形底形态，是因为根据 我个人的经验，一旦这种罕见形态果真出现了，通常便是市场的底部。我怀疑，在过去十年，此类形态罕见的原因之一，在于我们所经历的特定市场条件。1970年代以剧烈牛市为特点，而1980年代则以熊市为代表，都不具备滋生圆底的环境条件。今后，在期货市场再度稳定以后，在各种主要底部形态中，我们很可能将看到圆底卷土重来。 图 5.8c 这张咖啡图展示了圆形底的一个实例，注意在 9 月到 11 月的趋势的逐渐变化过程。这一类市场底部通常是缓慢乏味的V 形形态，或称长钉形 最后要讲的这种反转形态可谓神出鬼没，在其出现时最难于判别，但它并不罕见。实际上，因为V形顶或底（或称长钉形）其实不是形态，所以我们极难判定。前面讨论的所有的反转形态均代表着趋势的逐渐变化。现存趋势先逐渐放缓，进而供求双方的力量对比达到相对平衡，最终，买卖双方通过“拔河比赛”，决定原有趋势到底是反转还 是恢复。 在前面的各种形态中，价格有一段横向延伸的时间，分析者能够利用这个机会研究市场行为，仔仔细细地探求 其去向的线索。这种阶段称为转换阶段。这是绝大部分反转形态的特点。 然而，V 形形态代表着剧烈的市场反转，同市场逐步改变方向的惯常方式大相径庭。当它发生时，在几乎毫无 先兆的情况下，趋势出人意料地突然转向，随即向相反的方向剧烈地运动。因为其身后并无形态可寻，从而其本质是非形态的。这类变化极为经常地孕育在关键反转日或岛状反转（见第四章有关内容）之中。交易商如何预期这类形态的降临，从而在其实际发生时，及时地把它判别（或至少猜测）出来并采取适当的措施呢？为了解答这些问题，我们要进一步深入研究V形顶形态（见图 5.9a 到 c）。 图 5.9a V 形顶（或称长钉形顶）的例子。此类形态通 图 5.9b V 形底（或称长钉形底）的例子。下降趋势常出现在失控的牛市环境中，事前市场向上伸展得太极快地反转为上升趋势，事先毫无征兆，中间也没有过分了。转折点通常以关键反转日或者岛形反转的形转换阶段。这可能是最难以识别和交易的价格形态。 式发生。届时市场陡然反转，突然掉头。 首先，事先必须有趋势存在。趋势以 V 形反转的现象，极经常地出现在市场持续上涨，一路很少调整或只有微小调整的情况下。通常，事前已经发生过数次价格跳空。当前的局面显得失去了控制，市场似乎已远远超出了绝大多数正常预期。目前，大部分职业交易商对这种情况已经提高警惕了。 我们可以想见，交易商当然梦想着自己能够在这种脱缰了似的市场中赶上潮流。但是从某个时刻开始，即便是最富经验的交易商也开始因为上涨的持续而不安。这种情况实在好象“骑虎难下”一样，抓住老虎，安全地爬上虎背只是开头，如何不出危险又不失体面地从虎背上下来才是棘手的难题。 这种困扰事出有因。市场有个极难对付的坏习惯，一旦它脱缰之后，起初总要朝一个方向走得过远，然后，又常常会向相反的方向突然反噬回来，就象一根橡皮带被拉得太长，突然“唰”地反弹回来。这类突然回弹的特点是，事先通常无迹可寻，事后，市场向相反方向的剧烈运动，往往引发一系列交易所涨（或跌）限价。 图5.9c V形反转的实例。在取暖油市场的图表上，象V字或长钉一样的突然反转屡屡发生。由于其中缺乏转换阶段，市场变得难以驾驭。请注意图中的许多关键反转日和岛形反转 V 形反转的形成条件 形成 V 形反转的主要条件是陡峭的或脱缰的趋势。其转折点以关键反转日或岛状反转形态为标志，同时伴随着重大的交易量。有些时候，这种反转的唯一有效信号是，市场对其非常陡峭的趋势线的突破。移动平均线在这种情形下帮助不大，因为它的天性使它滞后于失控的价格变化。 随之而来的下跌，通常在极短的时间内回撤到原先趋势的某个显要的比例（多达 1，3 或50%“）位置。发生这 种反向剧烈运动的原因之一是，在原先趋势中缺乏支撑和阻挡水平，它一路上的许多价格跳空也留下了“真空”。 事情发生后，在市场顶部被套牢的人急于抛售，以摆脱亏损头寸，这就反过来进一步加剧了下跌的速度。所以，另外一个危险的信号是，事前市场上高得非同寻常的持仓兴趣，尤其是在持仓兴趣的增长主要发生在原先趋势的后面部分的情况下（我们将在第七章中更多地讨论持仓兴趣）。 交易商面临着两难选择，一方面，市场趋势强劲，大大地有利可图；另一方面，他不得不选择恰当的时机，及时平仓出市，以免被套住。他总可以利用逐步尾随的保护性止损指令“让利润充分增长”，这是既能防止趋势突然反向，又能充分积累利润的常用的方法。问题是，在市场失控之后，V 形反转突如其来，即使我们已经预先设置好止损指令，但是由于市场在相反的方向经常发生限价的情况，平仓出市变得出奇地困难。而如果交易商试图猜想此类顶部即将降临，预先平仓获利，那么结果通常是过早地出市，丧失了更多的潜在利润。当然，话说回来，没有人敢说发财是件如履平地的容易事。 这里，我们主要讲述了市场的顶部。底部介绍得较少。虽然本形态在两种情况下均有发生，但最剧烈的实例还 是出现在顶部。 扩展 V 形反转形态 V 形形态有一种变体，称为扩展 V 形形态。在这种形态中，当市场反向后，很快形成一个小平台，除此之外，它与V形形态基本一致。如图5.10a所示，平台通常形成在图形的右侧。它与旗形形态（在第六章中讲解）颇为相似，也朝新趋势的相反方向稍稍倾斜。 在顶部，平台向上倾斜；而在底部，则往往向下倾斜。当平台出现时，交易量亦会有所下降，然后在趋势恢复之后，交易量再度增长。在平台突破后，我们就认为该形态已经完成了。扩展V形反转形态比真正的V形形态要少见些，但它能够为图表分析者提供更多的反应机会。在平台阶段，我们要么可以平仓了结旧头寸，要么可以顺着新 趋势的方向开立新头寸。 图 5.10a扩展V形顶的例子。在市场转折后，马上形图5.10b左侧扩展V形顶的例子。这类形态相当成了一个小平台。通常，它稍稍地斜向新趋势的相反方少见。它与正常的扩展V形一样，只是其平台超前向。当平台被突破时，趋势反转的过程也就完成了。底 于市场的转折点。 部扩展 V 形反转的形态与此类似，但上下正好倒过来。 左侧扩展 V 形形态 本形态比扩展 V 形形态更为少见，其中平台出现在形态的左侧，先于市场的反转（见图 5.10b）。尽管这种形态在市场反向后对交易商无甚价值，但它也能提供一点参考。它原先在图上形成的向上反弹低点一旦被向下突破，则顶部形态便完成了。这个向上反弹低点也许暂时从市场下方提供了一定的支撑，从而减缓了下跌的速度，使交易商有更多的应对时间。 结语本章我们讨论了五种最常用的主要反转形态—头肩形、双重顶和底、三重顶和底、圆形以及V形。其中最普遍的是头肩形，双重顶和底，以及V形反转。这些形态通常意味着趋势正在发生重要的转折，因而被划分到主要反转形态这一类中。还有另一类形态，它们在本质上较为短期，且通常表示趋势的休整而不是反转，所以恰如其分地，我们把它们归结为持续形态。下一章我们将对后面这类形态展开研究。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 道氏理论]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%81%93%E6%B0%8F%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 基本原则1.平均价格包容消化一切因素 挺耳熟吧？这正是第一章所介绍的技术分析理论的基本前提之一，只是这里用平均价格代替了个别对象的价格。这个原则表明，所有可能影响供求关系的因素都必得由平均市场价格来表现，就连“天灾”，比方说地震或者其它自然灾难也不例外。当然这些灾祸事先谁都难以料到，但是一旦发生，就会很快被市场通过价格变化消化吸收掉。 2.市场具有三种趋势 道氏的趋势定义是，只要相继的上冲价格波峰和波谷都对应地高过前一个波峰、波谷，那么市场就处在上升趋势之中。换言之，上升趋势必须体现在依次上升的峰和谷上。相反，下降趋势则以依次下降的峰和谷为特征。正如将在第四章所讲的，这仍是趋势的基本定义，仍是所有趋势分析的起点。 道氏把趋势分成三类—主要趋势、次要趋势和短暂趋势。其最关心者为主要趋势（或称大趋势），通常持续一年以上，有时甚至好几年。他坚信，大部分股市投资者钟情于市场的主要方向。道氏用大海来比喻这三种趋势，把它们分别对应于潮汐、浪涛和波纹。 主要趋势如同海潮，次要趋势（或称中趋势）是潮汐中的浪涛，而短暂趋势则是浪涛上泛着的波纹。从堤岸标尺上，我们可以读出每次浪涛卷及的最高位置，然后通过挨次地比较这些最高位置的相对高低就能测定海潮到底是涨还是落。如果读数依次递增，那么潮水依然在向陆地推进。只有当浪涛峰值逐步递减的时候，观测者才能确知潮水已经开始退却。 次要趋势（或中趋势）代表主要趋势中的调整，通常持续三个星期到三个月。这类中等规模的调整通常可回撤到界乎先前趋势整个进程的三分之一到三分之二之间的位置。常见的回撤约为一半，即百分之五十。 短暂趋势（或小趋势）通常持续不到三个星期，系中趋势中较短线的波动。我们在第四章讨论趋势概念时，将采用与这里几乎一致的术语，以及差不多的回撤比例。 3.大趋势可分为三个阶段 大趋势通常包括三个阶段。第一阶段又称积累阶段。以熊市末尾牛市开端为例，此时所有经济方面的所谓坏消息已经最终地为市场所包容消化，于是那些最机敏的投资商开始精明地逐步买进。第二阶段，商业新闻趋暖还阳，绝大多数技术性地顺应趋势的投资人开始跟进买入，从而价格快步上扬。第三阶段，即最后一个阶段，报纸上好消息连篇累牍，经济新闻捷报频传，大众投资者积极入市，活跃地买卖，投机性交易量日益增长。正是在这个最后阶段，从市面上看起来谁也不想卖出，但是那些当初在熊市的底部别人谁也不愿买进的时候乘机“积累”、步步吃进的精明人，开始“消散”，逐步抛出平仓。 熟悉艾略特波浪理论的读者肯定不会对上述关于大趋势的三部曲式、各具特色的划分感到陌生。在30年代出版的雷氏的《道氏理论》的基础上，艾略特构造了他自己的波浪理论。艾略特也认识到牛市有三个主要上涨阶段。 在本书的“艾略特波浪理论”一章中，我们将表明，道氏的牛市三部曲同波浪理论的分浪特色惊人地相似。艾略特理论和道氏理论的主要分歧在于相互验证原则，下面我们就要讲到。 4.各种平均价格必须相互验证 具体而言，道氏是指工业股指同铁路股指应相互验证，意思是除非两个平均价 格都同样发出看涨或看跌的信号，否则就不可能发生大规模的牛市或熊市。换句话说，为了标志牛市的发生，两种平均价格都必须涨过各自的前一轮浪涛（中趋势）的峰值。如果只有一个平均价格突破了前一个高峰，那还不是牛市。两个市场倒也不必同时发出上涨信号，不过在时间上越近越好。如果两个平均价格的表现相互背离，那么我们就认为原先的趋势依然有效（参见图2.1）。艾略特波浪理论在这一点上与道氏理论不同，只要求单个平均价格给出信号就足够了。关于相互验证和相互背离原则我们以后还要详细解说（见图2.2）。 图2.1 请注意，当工业类平均股票指数跌破了11月份的最低点的时候，在交通类股票指数中，并末出现类似情形，因而两者之间没有相互验证。这是个警讯，表明当时:工业类指数上的“卖出”信号是可疑的。就目前来看，工业类指数也必须冲破阻挡，以验证交通类指数的向上突破信号 图2.2 我们可以把相互验证的原则应用于任何两个市场或指数之间。本图表示价值线与S&amp;P500 期货指数之间的差价关系（两者价格之差）。请注意，S&amp;P500刚刚跌破其10月份的低点，勉强验证了早些时候价值线图上的突破信号。图中下部为差价图，表明价值线的疲弱程度更甚。通常，这是市场疲软的信号。但是，请注意，差价已出现止跌回升的迹向（向上突破了趋势线），意味着市场可能向上转折。换言之，价值线指数已开始比S&amp;P指数更有起色。通常，这是市场坚挺的信号 5.交易量必须验证趋势 道氏认为交易量分析是第二位的，但作为验证价格图表信号的旁证具有重要价值。简而言之，当价格在顺着大趋势发展的时候，交易量也应该相应递增。如果大趋势向上，那么在价格上涨的同时，交易量应该日益增加，而当价格下跌时，交易量应该日益减少。在一个下降趋势中，情况正好相反，当价格下跌时，交易量扩张，而当价格上涨时交易量则萎缩。当然，我们必须强调，交易量是第二位的参照指标，道氏理论实际使用的买卖信号完全是以收市价格为依据的。在第七章我们将更深入地讨论交易量问题。不过届时您会发现其基本原 则与此处如出一辙。即使是某些更复杂的交易量信号，其目的也主要是确认交易量增减的方向，然后同价格变化加 以参照。 6.唯有发生了确凿无疑的反转信号之后，我们才能判断一个既定的趋势已经终结 在第一章我们也曾涉及到这 条基本原则，它是目前广泛使用的顺应趋势方法的主要基础。这句话其实也就是说，一个既成趋势具有惯性，通常要继续发展。话说回头，要判别反转信号说起来容易，行起来困难。研究诸如支撑和阻挡价格水平、价格形态、趋势线和移动平均线等等倒也是几个实用的办法，我们或许从中能获得关于现行趋势发生变故的信号。摆动指数甚至能够更及时地发出现行趋势动力衰竭的警讯。不过，通常总是选择“趋势还将继续”这一边，把握更大些。掌握这个小小秘诀，就能令您成多败少，大有胜算（见图 2.3a 和 b）。 对信奉道氏理论者或者“因势导利”者来说，最困难之处就在于要有能力把大趋势中常见的次要调整，同掉头反转的新趋势的第一轮冲锋区分清楚。关于什么样的情形才是真正的反转信号，这一点在顺应趋势派中还有争议，图2.3a和2.3b均为衰竭形态，显示了两幅格局。在图2.3a中，我们注意到C点的上涨未能达到相邻的前一个高峰A点的高度，此后价格又回过头跌破了前一个低谷B点的水平。在这种情况下，就存在着两个依次下降的峰和两个依次下降的谷，表明当前一个低点B被跌破时，S点是一个清晰的卖出信号。这种反转形态常常被称为“一蹶 不振”。 图 2.3a “一蹶不振”。先是高点 C 无力 克最高点 A，然后，市场向下跌破了低点 B，从而构成了 S 点的卖出信号。 图 2.3b “物极而反”。请注意，这里点 C 超过了点 A，但之后却跌破了 B 点。有些道氏主义者认为 S1 点是“卖 出”信号，而另一些人则等市场走出了另一个较低的高点B 后，在 S2 点方采取看跌的态度。 在图 2.3b 中，我们注意到这一轮上冲所达的高点已经打破了前一个峰值A点，然后价格才滑破前一个低点B。尽管在S1点，B点价位的支撑显然已经崩溃，有些道氏主义者并不认为这是一个良好的卖出信号，理由是这里只有依次降低的低点，却没有依次降低的高点。他们宁可看到价格再次回到E点而无力达到C点的高度，然后再加上随之而来的下跌又低于D点之后，才认为这时的S2点是真正的卖出信号。因为此处既有依次下降的峰又有依次下降的谷。图2.3b所示的反转形态称为“物极而反”。图 2.3a 所示的。一蹶不振”的形态要比“物极而反”的形态疲软 得多。图 2.4a 和 2.4b 显示了市场在底部时对应于上面两种形态的镜像情形（见图 2.4a 和 2.4b）。 图 2.4a 底部的“一蹶不振”。当 B 点被 图 2.4b 底都的“物极而反”形态。 向上突破后（B1 点），构成“买入”信号。 点 B1 或点 B2 处为“买入”信号。 收市价格的使用和辅助直线的引入 道氏在股市平均价格图表中纯粹依赖收市价格，其信号是以收市价格对前一个高峰或低谷的穿越为标志的。除了收市价格之外，其余日内价格变化即使穿越了上述高、低点也是无效的。他在平均价格图上所使用的辅助直线，就是在某一段时间内界定价格上下变化范围的水平直线。其描述的横向延伸的波动常常出现在调整状态中，也可以 在顶部或底部的反转过程中见到，在现代术语中，这种形态称为矩形。 对道氏理论的某些批评实事求是地说，多年来道氏理论在辨别主要牛市和熊市上是成功的。不过即使如此，它也难逃求全之苛。最常见的批评可能是嫌信号来得太迟。通常道氏理论的买入信号发生在上升趋势的第二阶段，即当市场向上穿越了从底部弹起的第一个峰值的时候。一般来说，在信号发生之前，我们大约错过了新趋势全部价格变化的 20%一25%。顺便说一句，绝大部分顺应趋势的技术系统也是在此时确认和投入新趋势的。 奉行因势导利者对这种批评恐怕很熟悉。请切记，道氏理论从来不是企图抢在趋势前头，而是力求及时揭示大牛市或大熊市的降临。根据现有的记录，它在这方面的表现应当说是相当优良的。本章引言中提到的巴伦氏周刊上的那篇文章曾引用了一些统计材料，表明从 1920 年到 1975 年，道氏理论成功地揭示了工业股指和运输股指的所有 大幅运动中的 68%、标准普尔氏 500 种股指大动作的 67%。 正如绝大多数顺应趋势系统的设计精神一样，道氏理论的目的是捕获市场重要运动中幅度最大的中间阶段。就这种意义上说，上述批评是不能成立的。另一方面，这种责难本身也表明批评者对顺应趋势理论缺乏了解。实质上没有哪个顺应趋势系统试图抓住底或顶。想抄底或压顶的人很少如愿以偿。 还有一种指责由来已久，说没人能真正买卖平均价格指数，而道氏理论并未说明何种股票当买或何种股票当卖。不过现在股票指数期货已顺利上市，交易商确实可以毫不关心个别股票而一心一意地“买卖指数”了。随着股票指数的日益盛行，也许道氏理论将来能为期货技术分析充当更为有力的工具。 道氏理论肯定也不会绝无谬误，它也有错误信号频频发生的糟糕日子。不过任何优良的信号系统也都有缺点和不足。要知道，道氏甚至不曾打算用他的理论去预测股市方向。他觉得，其真正价值在于利用股市方向来作为一般商业活动的晴雨表。道氏的洞察力令人惊叹不已，他不但为我们今天处处运用的预测方法奠定了基础，而且竟然在 那时就已经认识到，股价指数是很好的经济先行指标。 总结本章相当简要地概括了道氏理论中较重要的各个方面。随着对本书的深入学习，您将充分认识到，理解和接受道氏理论可以为学习技术分析打下坚实的基础，同时您也会越来越清楚，今后各章中所讲解的内容代表着道氏理论的各种发展。诸如趋势概念的标准定义、趋势三类型和趋势三阶段的划分、相互验证原则和相互背离原则、交易量 的诠释、以及百分比回撤的用法等等，都是从道氏理论中衍生出来的。 结语在结束对道氏理论的讨论之前，我们还必须指出，虽说道氏理论的绝大部分内容在期货市场均有一定的应用，但也存在着某些重要区别。举例来说，道氏认为大多数投资人只做大趋势，而中等的调整被用作入市时机的选择，短暂趋势则置而不理。很显然，在期货市场情况并非如此。 绝大多数期货商追逐的是中等趋势而不是大趋势。小幅度价格波动对选择时机意义极为重大，这就是说，在一个预计持续数月的中等上升趋势中，顺应趋势者会利用短暂的价格下跌买进。而在一个中等下降趋势中，短暂的价格上弹是卖出的好机会。这样，短暂趋势在期货交易中就显得极为重要。许多短线交易商在非常短的时间内开仓和 平仓，他们更致力于把握日内的价格变化。 除了本章有关介绍以外，《股市趋势的技术分析》一书对道氏理论的基本原则也有很精彩的概括。该书作者是罗 伯特·D·爱得华兹和约翰·马吉，由约翰·马吉公司 1966 年出版。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 技术分析的理论基础]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言这一章我们先来做四个事情。第一，给技术分析下个定义，其二，讨论一下技术分析赖以成立的哲学前提或者说基本原理，接下来把技术分析同基础分析分出个子丑寅卯来，最后谈谈几种常见的反对技术分析的意见。 我坚信，只有先弄清楚了技术分析的所作所为，特别是它的理论基础之后，才谈得上全面理解和掌握它。 首先，我们下定义，技术分析是以预测市场价格变化的未来趋势为目的，以图表为主要手段对市场行为进行的研究。“市场行为”有三方面的含义—价格、交易量和持仓兴趣，它们是分析者通常能够获得的信息来源。另—个概念“价格变化”虽然也常用，但好象太狭窄了，因为大多数分析者也把交易量和持仓兴趣用作分析资料的一部分。在以后的讨论中，“价格变化”和“市场行为”就按这两种意义区别使用。 理论基础技术分析有三个基本假定或者说前提条件： 1、市场行为包容消化一切。 2、价格以趋势方式演变。 3、历史会重演。 市场行为包容消化一切“市场行为包容消化一切”构成了技术分析的基础。除非您已经完全理解和接收这个前提条件，否则以下的讨论毫无意义。技术分析者认为，能够影响某种商品期货价格的任何因素—基础的、政治的、心理的或任何其它方面的—实际上都反映在其价格之中。由此推论，研究价格变化就是我们必须做的事情。这个断语乍听也许过于武断，但是花功夫推敲推敲，就确实没话可说。 这个前提的实质含义其实就是价格变化必定反映供求关系，如果需求大于供给，价格必然上涨；如果供给过于 需求，价格必然下跌。这个供求规律是所有经济的、基础的预测方法的出发点。把它掉过来，那么，只要价格上涨，不论是因为什么具体的原因，需求一定超过供给，从经济基础上说必定看好；如果价格下跌，从经济基础上说必定看淡。您瞧，这段话基础分析的味道多么浓，不过大可不必为它出现在我们这篇纯粹关于技术分析的文章中而惊讶。归根结底，技术分析者不过是通过价格间接地研究经济基础。大多数技术派人士也会同意，正是根本的供求关系，即某种商品的经济基础决定了该商品的市场看涨或者看跌。图表本身并不能导致市场的升跌，只是简明地显示了市场上流行的乐观或悲观的心态。 图表派通常不理会价格涨落的原因，而且在价格趋势形成的早期或者市场正处在关键转折点的时候，往往没人 确切了解市场为什么如此这般古怪地动作。恰恰是在这种至关紧要的时刻，技术分析者常常独辟蹊径，一语中的。所以随着您市场经验日益丰富，遇上这种情况越多，“市场行为包容消化一切”这一点就越发显出不可抗拒的魅力。 顺理成章，既然影响市场价格的所有因素最终必定要通过市场价格反映出来，那么研究价格就足够了。实际上，图表分析师只不过是通过研究价格图表及大量的辅助技术指标，让市场自己揭示它最可能的走势，而并不是分析师凭他的精明“征服”了市场，之后讨论的所有技术工具只不过是市场分析的辅助手段。技术派当然知道市场涨落肯 定有缘故，但他们认为这些原因对于分析预测无关痛痒。 价格以趋势方式演变“趋势”概念是技术分析的核心。还是那句话，除非您也接受这第二个前提，否则就不必再读下去。研究价格图表的全部意义，就是要在一个趋势发生发展的早期及时准确地把它揭示出来，从而达到顺着趋势交易的目的。事实上，本书绝大部分理论在本质上就是顺应趋势，即以判定和追随既成趋势为目的(见图1.1)。 从“价格以趋势方式演变”可以自然而然地推断，对于一个既成的趋势来说，下一步常常是沿着现存趋势方向继续演变，而掉头反向的可能性要小得多。这当然也是牛顿惯性定律的应用。还可以换个说法：当前趋势将一直持续到掉头反向为止。虽然这几句差不多是车轱辘话，但反复强调的无非只有一个意思：坚定不移地顺应一个既成趋势，直至有反向的征兆为止。这就是趋势顺应理论的源头。 历史会重演技术分析和市场行为学与人类心理学有着千丝万缕的联系。比如价格形态，它们通过一些特定的价格图表形状表现出来，而这些图形表示了人们对某市场看好或看淡的心理。其实这些图形在过去的一百多年里早已广为人知、并被分门别类了。既然它们在过去很管用，就不妨认为它们在未来同样有效，因为它们是以人类心理为根据的，而人类心理从来就是“江山易改本性难移”。“历史会重演”说得具体点就是，打开未来之门的钥匙隐藏在历史里，或者说将来是过去的翻版。 技术分析与基础分析之辨 技术分析主要研究市场行为，基础分析则集中考察导致价格涨、落或持平的供求关系。基础分析者为了确定某 商品的内在价值，需要考虑影响价格的所有相关因素。所谓内在价值就是根据供求规律确定的某商品的实际价值， 它是基础分析派的基本概念。如果某商品内在价值小于市场价格，称为价格偏高，就应该卖出这种商品；如果市价小于内在价值，叫做价格偏低，就应买入。 图 1.1 上升趋势的示例。技术分析是基于以下前提之上 的:市场以趋势方式演变，并且其趋势倾向于持续发展两派都试图解决同样的问题，即预测价格变化的方向，只不过着眼点不同。基础派追究市场运动的前因，而技 术派则是研究其后果。技术派理所当然地认为“后果”就是所需的全部资料，而理由、原因等无关紧要。基础派则非得创根究底不可。 大多期货商要么说自己是技术派，要么说自己是基础派。实际上不少人两手兼备。绝大部分基础分析师对图表 分析的基本立场有实用的了解，同时，绝大部分技术分析师对经济基础也至少有个走马观花的印象(不过也有的技 术分析者不遗余力地拒绝知道任何经济信息，人称“技术癖”)。成问题的是，在很多场合，图表的预测和基础的分 析南辕北辙。当一场重要的市场运动初露端倪的时候，市场常常表现得颇为奇特，从基础方面找不出理由。恰恰是在这种趋势萌生的关键时刻，两条道路分歧最大。等趋势发展过一段之后，两者对市场的理解又协调起来，可这个时候往往来得太迟，交易者已经无法下手了。 两种方法貌合神离，而市场价格的变化总要超前于哪怕是最新获得的经济情报。换言之，市场价格是经济基础 的超前指标，也可以说是大众常识的超前指标。经济基础的新发展在被统计报告等资料揭示之前，早已在市场上实 际发生作用，已经被市场消化吸收了。因此，当前的价格实际上是当前尚来不及为人所知的经济基础因素作用的结 果。历史上一些最为剧烈的牛市或熊市在开始的时候，几乎找不到表明经济基础已改变了的资料，等到好消息或坏消息纷纷出笼的时候，新趋势早已滚滚向前了。 而技术派往往非常自信，当大众常识同市场变化牛头不对马嘴的时候，也能够“众人皆醉而我独醒”，应付自如。 他们乐于领先一步，当少数派，因为他们明白，个中原因迟早会大白于天下，不过那肯定是事后诸葛亮，他们既不愿意也没必要坐等，丧失良机。 有了上面的分析，您就不难理解何以技术派总觉得他们的一套比基础派的强。要是一个交易商非得从二者之中 挑一个不可，那么，合乎逻辑的抉择必然是技术分析。因为从定义上说，技术分析已经容纳了基础性因素。如果经 济基础已经反映在价格之中，那么再研究有关的基础性资料就多余了。图表分析抄了基础分析的近道，反过来却不 然。基础分析里不包括价格的变化。如果说单纯利用技术分析从事商品期货交易还可以的话，要是某人毫不理会市 场的技术特点，试图单单利用基础分析来做交易，那就大为可疑了。 技术分析与出、入市时机选择 为把上面最后一句话讲得更清楚，我们把决策过程分为前后两个阶段:先分析市场，而后选择出入市时机。期 货市场的杠杆作用注定了时机是交易成败的关键。请注意，即使您在把握大趋势上没有出问题，仍然很可能赔钱。 因为期货交易所要求的保证金实在太少(通常少于交易额的 10%)，价格朝不利的方向哪怕变化得并不大，交易商也 可能被扫地出门，损失大部分乃至全部保证金。在股票市场上。情况不一样，如果股价跌了，则不妨先拿着股票等 等看，但愿总有涨回来的一天。不少股票交易商就这么着，从投机转变成投资。 期贷交易商可占不到这个便宜。“买了走着瞧”这一套行不通。在市场预测阶段，技术分析或基础分析都可采用， 但到了选择具体出入市时机的时候，就只能仰仗技术分析了。这就是说，只要做交易，就得按步就班地完成这两个 步聚，哪怕您在第一个阶段用的只是基础分析，在第二阶段也还是非用技术分析不可。 技术分析的灵活性和适应性 技术分析有一个了不起的长处，它适用于任何交易媒介和任何时间尺度。不管是做股票交易，还是做商品交易， 没有用不上的地方。 做商品期货，图表派可以随心所欲地同时跟踪许多种类，而基础派往往顾此失彼。经济基础方面的资料太繁杂 了，大多数基础分析师只好从一而终，专门研究某种或某类商品，比如谷物或者金属类。我们绝不可忽视这个差别。 就说这一桩吧，市场有时平平淡淡，有时候高潮迭起；既有趋势明朗的情况，也有杂乱无章的阶段。技术派就不妨集中精力和资源，专门对付趋势良好的市场，暂且不理会其它趋势不明者。这样，在市场上各种商品轮流做庄， 交替活跃，技术派跟着把注意力和资金转移到最行时的对象上去。不同的时候总有不同的商品最火爆，趋势漂漂亮 亮，而且往往此起彼伏。技术分析师大得其宜，随机应变地轮换新宠。而基础派多是“专家”，常常享受不到这份灵 活性。即使他们要东施效颦，也非得付出许多额外的时间去把握新对象不可，缺了图表派那份潇洒。 技术派的另一个优势是“既见树木又见森林。”他们能同时跟踪所有市场，对商品市场在总体上有很好的把握， 避免了从一而终所致的管窥蠡测、坐井观天的毛病。而且许多期货之间存在着内在的联系，对类似的经济因素也会 作出相互关联的反映，因此它们之间在价格变化上可以互为线索、相互参照。 技术分析适用于各种交易媒介 图表分析原则既适用于期货，也适用于股市。它实际上起源于股市分析，后来才移植到期货市场，如今股票指数期货已经上市，两个市场之间的界限正飞快地消失。正如图 1.2 所示，各国股票市场也引入了图表及其分析原理。 10 年来，金融期货，包括利率和汇率期货大行其道，图表分析理论在这些市场上如鱼得水。 技术分析原则在套头交易(差价交易)和期权交易中也有用武之地。另外，商业保值也需要考虑价格未来走向，因而技术分析同样能发挥所长。 技术分析适用于各种时间尺度 图表分析的另一个优点是它能应用在不同的时间尺度之下。无论是研究一天以内的价格变化做当日交易，还是 顺应趋势做中等期限的跟势交易，都可以采用相同的原理。目前较长期技术预测还往往被忽视。有人说图表分析只 适合短时间域，这是无稽之谈。也有人和稀泥，说基础分析适合做长期预测，而技术分析用于短线的时机选择更好。 实践证明，使用周线图或月线图解决长期预测问题也毫不逊色。 只要您完全领会了本书所讨论的技术原理，就能在各种交易工具中、在各种时间尺度上左右逢源。 经济预测 许多人以为技术分析相对冷僻狭隘，或者把它理解成专门对付股票、期货的高度专业化的工具。实际上它的基 本理论完全能够应用到经济形势的预测上来，只不过迄今为止这方面的前景还没有被充分地认识。 技术分析预测的是金融市场的未来轨迹。这些预测对预测经济有价值吗?请看几年前华尔街日报刊登的这篇文 章:《近来债券价格快步上涨，而它历来是经济转折的优良先行指标》(1982 年 9 月 28 日)。文章通过广泛的历史纪 录有力地表明，债券价格是经济滑坡或回升之前的显著征兆。作者写道:“它作为征兆明显优于股票价格，就事论事，也大大胜过官方公布的各种先行指标。” 我们注意到引文中也提起了股票价格。标准普尔氏 500 种股票平均价格指数是商业部随时关注的 12 种经济先行 指标之一。文章引用了马萨诸塞州国立经济研究院的一份研究报告，证明该股票指数在这12种先行指标中表现最佳。 我想强调的是，现在我们既有债券期货，也有标准普尔氏 500 种指数的期货，而技术分析在研究这两种期货时都能 游刃有余，那么，不论您意识到与否，当我们对它们进行技术分析时，也同时成功地分析了经济。有个最生动的例 证:1982 年夏季，股票指数和债券市场同时爆发了—轮剧烈的牛市，及时地宣告一场自二次大战以来为时最长、痛 苦最深的大衰退就此终结——然而经济学界对如此重大的转折当时差不多毫无觉察。 纽约咖啡、糖和可可交易所(CSCE)已经申请开设四种经济指标的期货合约，其中包括住房开工率和工薪消费 者物价指数(CPI—W)，估计商品研究局期货价格指数(CRB 指数)也即将上市。而 CRB 指数早就被看成是显示通货膨胀压力的晴雨表。但这个指数的用途远不止于此。1984 年商品年鉴(商品研究公司，新泽西城)中有篇文章， 对照研究了自 1970 年以来 CRB 指数同各种经济指标的相互关系(见图 1.3)。该研究表明，CRB 指数同工业产出指标有很强的相关性，而且商品价格指数一般领先于后者的变化。有原文为 证:“CRB指数同工业产出指标有很高的相关性，表明CRB是一个非常可靠的一般经济指标。”(期蒂芬·W·麦克， 《作为一般经济指标的 CRB 指数——有27个品种的一篮子商品，一种新期货》，第 46 页)，不妨加一句，我们用图表分析CRB指数有年头了，干得相当漂亮。 综合上述可以清楚地看出，技术分析这一预测工具价值不菲，研究譬如黄金或大豆价格走向等等问题只是牛刀 小试而已。当然，也要清楚，技术分析在预测一般经济趋势上前景虽然广阔，但还有待开发利用。CSCE 最近推出的 消费者物价指数(CPI—W)期货可谓这方面的好榜样。 图 1.3 从图中可以明显看出，在 CRB 期货价格指数 (实线)与工业产出指数(虚线)之间存在着强烈的相关性 技术分析师?图表分析师? 对从事技术分析者有好几种称呼，比如技术分析师、技术师、图表分析师、市场分析家等等。这些说法以前其 实是一个意思，如今技术分析的专业分工越来越细，就有必要讲究讲究，仔细地区分。十年前，所有的技术分析都 是围绕图表开展的，技术分析、图表分析是一码事，现在不行。 随着技术分析领域的不断拓展，采用传统图表分析方法的人仍自成一派，新形成一派，即所谓技术分析派，则 往往借助统计科学和计算机工具。当然这种区分有许多重叠之处，而且大多数人在一定程度上两边都沾得上，但正 如技术派同基础派的分别一样，他们毕竟有所不同。 传统的图表分析师无论是否利用计算机辅助工作，图表依然占首要地位，其余统统是参考。而研究图表必定具有一定的主观色彩，在绝大多数场合，分析成功与否取决于分析者自身的素质。所以研读图表确实需要技艺，图表 分析师又常被称为“图表艺术家”，倒也并非“浪得虚名。” 反过来，技术分析应用了统计科学，以计算机为工具，力求客观地定量测试和改进其自动交易系统。他们把这 种系统或者交易模式编成软件，由计算机计算出“买”、“卖”信号。其中有的简单，有的极为复杂，不过总的一条， 就是要尽量减少甚至完全排除人的主观影响，把交易变成科学实践。图表在这些统计学家那里可有可无，但是只要 他们的工作不超出研究市场变化这个大范围，就仍算是技术分析师。 另外，使用计算机的分析者也可以划分成两类。一类人倾心研制自动交易系统，又称“黑箱技术”；另一种人则 致力于利用计算机开发新的技术信号，对这些技术指标的解释及其实际应用他们自己了然于心。 所有的图表分析师都是技术分析者，可是并非所有的技术分析师都是图表分析师。这也是区分两者的一个办法。 本书不打算刻意区别使用这两种说法，不过应该清楚，图表分析只是广阔的技术分析领域中的一部分。职业技术分 析人员宁愿人称“技术分析师”而不喜欢“图表分析师”这个头衔，就好比一个是“千里马”，一个是“驽马”，前者听起来俨然更加造诣不凡。 技术分析在股市和期货市场应用上的简要比较 常常有人间技术分析在股市和期货市场上的用法是不是一样，答案为既是也不是。 基本原理是共同的，使用的基本工具也一样，比如线图、点数图、价格形态、交易量、趋势线、移动平均线和 摆动指数等等。只要在一个市场上学会运用这些基本知识，就能轻车熟路地适应另外一个市场。当然股票市场和期 货市场毕竟有本质区别，要说技术分析在它们那里的差别，也就是由两个市场本身的先天特征造成的一般意义上的不同，工具本身是没有什么分别的。 标价方式 商品的标价方法比股票复杂得多。每种商品都按特定的单位标价并制定价格增减的最基本幅度。举例来说，谷物市场上的报价方式是每蒲式耳若干美分，金银是每盎司若干美元，利率是基本点数等等。交易商必须明了每个市 场的具体情况:在哪间交易所上市，合约如何标价，最大和最少的价格变化单位是多少，每张合约每基本单位价格 变化相当于多少钱的出入等等。 具有一定的有效期限 商品期货合约都有失效日期，股票则不然。比如美国长期国库券 1985 年 3 月份合约在 1985 年 3 月到期。期货 一般在到期前有大约一年半的交易时间，所以在任何时候同一商品在市场上至少同时流通着 6 种到期月份不同的合 约。交易商事先必须清楚哪一种值得买卖，哪种则应避开(以后解释这一点)。有效期特点给长期价格预测增加了难 度。每当旧合约期满新合约上市，总不得不相应地从头开始画图，而且过期合约的旧图表用处不大，新图表连同各 项新的技术参数都得重砌炉灶。市场上推陈出新不要紧，但要想维持一个长期图表就实在棘手。即使有计算机帮忙， 也必须从零开始，花费可观的人力物力来刷新资料。 较低的保证金水平 恐怕要数这个区别最要紧了。所有的期货都以保证金方式交易，大多数期货所要求的保证金少于交易量的 10%。 较低的保证金水平导致了很高的杠杆效应。价格不管朝哪个方向只变化一点点，就会影响总的交易成绩。正因如此， 在期货市场上可能在很短的时间内赚或者赔一大笔钱。既然交易者只拿出10%的押金，却做了 100%的交易，那么 10%的价格变化就能或者让他本金翻倍，或者让他血本无归。时间也不一定长，吃早饭开头寸，也许不到午饭时分，整个过程就结束了。期货市场的杠杆效应放大了市场动作，使之看起来比实际上更反复无常。要是有人扬言自己在 期货市场上被“洗劫一空”，您请记着他起先是拿 10%博 100%的。 从技术分析的角度看，杠杆效应使选择出入市时机这一步骤在期货市场比在股票市场大为重要。正确地选择入 市和出市的时机一方面是交易成败的关键，另一方面也是市场分析面对的一大课题。正是这样，以技术分析为中心 的交易策略才成为期货交易成败攸关、不可或缺的关键。 时间域大为缩小 在杠杆效应作用下，期货商必须密切关注市场的一举一动，因此所关心的时间域必然也细致入微。与此不同， 股市分析者喜欢更长时间的图表，研究更长时间的问题，他们也许要预测的是 3 个月或半年后的市场。期货商想知道的则是下周、明天乃至下半天的形势如何，所以所提炼出的一些具有即时效用的工具，股市分析师或许闻所未闻。 移动平均线便是一例。在股市分析中用得最广泛的是 30 周或者200天的平均线，而在期货市场，绝大多数在 40 天 以下，其中流行的移动平均线组合是 4 天、9 天和 18 天。 时机更为紧要 对期货商而言，时机决定一切。正确判别市场方向仅仅是问题答案的一小部分。入市时间相差一天，有时甚至 仅几分钟，结果可能就是成与败，截然不同。弄错了市场趋势而赔了钱固然糟糕，然而大方向没错却依然损兵折将 才是期货交易最令人沮丧、畏缩的地方。基础性因素很少一天一变，所以毋庸置疑，时机抉择问题实质上纯粹是技 术性的。广泛商品价格平均指数用得较少 股票平均价格指数的变化是极为引人注目的，比如道·琼斯工业股票指数或者标准普尔氏 500 种股票指数。实际上这是所有股市分析的起点。期货市场一般并非如此。尽管也有一些代表商品市场总体价格方向的指数，比如商品研究局期货价格指数(CRB)也广受注意，但它们没有股票指数那样显要。广泛性技术信号在期货市场用得较少股市分析中广泛性技术信号很重要，例如涨跌线、新高新低指数、空头动向比等，但它们在期货市场不流行。 这倒不是因为它们的理论和实践压根不适合期货，也许有一天期货种类大为增加，就有必要借助这些广泛性指标来 判断市场总体运动了，只是迄今为止还用不着它们。具体的技术工具大多数起源于股市分析的技术工具也能适用在商品市场，不过用法不完全一样。举个例子，期货的图表形态往往不象在股市里那样走得那么完整，移动平均线的天数也少得多，传统的点数图 也用得不广泛。这是因为很难获得每天的价格数据的细节，所以主要是场内交易商使用点数图。本书后面还将进一 步讨论上述分别以及其余用法上的差别。最后我们谈谈股市同期货之间另一个重要区别。在进行股市技术分析时，非常看重情绪指数和资金动向。情绪 指数用来跟踪显示散户、共同基金、场内交易商等各个群体的表现。根据“真理往往在少数人一边”的原则，情绪 指数是判断市场在总体上看好或看淡的极为重要的依据。资金动向用来考察不同群体的现金头寸情况，比如共同基 金或大机构交易商的帐户。它的基本理论是现金头寸越大，就越有购买股票的潜力。就技术分析本身而言，两者都 属于辅助性质，但股市分析者对它们的重视程度比对传统的市场分析要大些。在我个人看来，期货市场中的技术分析是更为纯粹的价格研究。虽然相反意见理论在一定范围内不无长处，但 基本趋势分析和传统技术指标的应用更为关键。技术分析的一些反面意见在讨论技术分析时，常常出现一些大同小异的疑问。所谓“预言自我应验”就听得不少。还有“到底能否用过 去的价格资料来预测下一步价格方向?”等等。反对者总是强调。图表记录了市场价格的来龙，却说不出它的去脉。 很显然，如果您不会读图，当然从图表上看不出门道来。这一点姑且不论。随机行走理论认为价格毫无趋势可言， 言下之意是什么样的预测技术也不比简简单单地“买了拿在手里等着”这一招高明。这就值得理论理论。 “一语成谶”论“一语成谶”论也可以说成“预言自我应验”。是不是真管用?这个问题问得太多了，说明很多人心存疑惑。这 种说法肯定不是无中生有，不过大可不必如此耿耿于怀。下面我们引用一段话，也是讨论期货交易的，从几个方面 批评了图表形态，这也许是表述上述问题的最好方法。a.近年来绝大部分图表形态流传广泛。许多交易商把它们牢记于心，常常根据图形不约而同地行动。于是乎每 当图形发出“看涨”或“看跌”的信号时，买者或卖者一涌而上，结果产生了“预言自我应验”的现象……b.图表形态的辩认几乎纯粹出自主观判断。迄今没有任何图形可以用数学方法科学地定量研究。要说它们是读 图者心中的臆想，一点也不夸张……(理查德·J·塔韦尔斯，查尔斯·V·哈洛，赫伯特·L·斯通，《商品期货游 戏》，p.176，麦格劳—希尔出版社，1971 年)。上面两段批评自相矛盾，后语抹杀了前言。既然图表形态“出自主观判断”，是“读图者心中的臆想”，那么许 多人在同时看出同样的信号这事就实在不可思议了，而这恰恰是“自我应验”论的基础。看来批评家们只好割爱， 不可以一边说图表形态是板上钉钉，既客观又容易判定，每个人都能同时看出同样的图形，采取同样的行动，使图 表形态自动应验；一边又批评图表分析过分地主观、人见人殊。 事实上图表形态很客观，而研读图表是门艺术(或者说是“技巧”更恰当)。图表形态几乎从来没有清楚得能让 有经验的分析师们意见一致的时候。疑虑重重、困惑不解或者仁者见仁智者见智才是家常便饭。正如本书将要说明 的那样，技术分析有许多种选择，各种选择相互之间经常合不上榫。有条条大路，但不全通罗马。 即便大多数分析者预测一致，所见略同，他们也不一定在同时以同样的方式入市。有些也许预计到图表信号将 会出现便“先下手为强”。还有人也许等到图形或指标突破后在市场回撤时才下手。有些交易商大胆积极，有些人谨 慎保守。有些人在入市时同时发出止损指令，有些则留下预定水平指令或限价交易指令做交易。因此所有人在同一时刻以同一方式入市的可能性甚微。 即使“预言自我应验”果有其事，那么它天生也会“自我修正”。换句话说，在交易商们不谋而合的行为扭曲市 场之前，大家都仰仗图表，而一旦“自我应验”发生之后，他们要么把图表扔到一边，要么更改交易策略。比如他 们可能力图在众人之前或者等到市场进一步证实时才作反应。就这样，即使短时间内预言自动应验现象惹出问题，这种机制本身也将自动地修正自己。 请记住，唯有供求规律才能决定牛市或熊市的发生、发展。技术分析师势单力薄，绝不能凭白无故地靠他们自 己的买进或者卖出引发市场的重要变化。要是他们能做到这一点，早就该发大财了。 一些规模庞大的交易商越来越多地借助计算机化的自动交易系统，它们带来的问题其实比图表分析师招惹的麻 烦重大得多。设计这些系统都是为了辨识和顺应大趋势，本质上属于“因势利导”。十多年来在期货行业中，置于职 业化管理之下的资金急剧膨胀，公共和私人基金动辄上亿美元地买卖。它们又大多采用此类技术性系统，结果是庞 大的资金高度集中，在为数不多的几个趋势性市场“追势逐利”。因为期货市场总的容量尚有限，这些系统短期内对 价格产生破坏性影响的危险性与日俱增。然而哪怕万一出现了这种偏差，也注定为时短暂，不会引起重要的运动。 我们再次强调，甚至由于高度集中的巨额资金采用技术性系统引致的问题也会自我修正。如果所有的系统同时 做同样的操作，交易商就会调整系统，使之更迟钝或更灵敏。我们一般把预言自我应验论看成是对图表分析的反对意见，其实说它是赞誉或许更为恰当。要是有哪种预测技 术如此广受欢迎，以致于能够影响市场，那它非得出类拔萃不行。您不妨琢磨琢磨，为什么提起基础分析时，很少有人会顾虑它也出现自我应验的问题呢? 过去能否预测未来? 用过去的价格资料能否有效地预测未来，这是另一个引起争议的问题。很奇怪为什么反对技术分析的人总是拿 出这个法宝来，大家都明白，每一种预测方法，从气象预报到基础分析，都是建筑在对历史资料的研究之上的。除此之外，还有什么资料可供选择呢? 统计学理论划分成描述统计学和推导统计学两部分。描述统计学指用图表达资料数据，比如用一张标准的线图 来展示价格历史。推导统计学则指从资料推导出概括的、预测的或推延性的结论。所以价格图表属于前者的范畴， 而针对价格图表进行的技术分析则属于推导统计学的范畴。 正如一本统计学教科书所说:“商业或经济预测的第一个步聚就是搜集历史观测资料”(约翰-E·弗罗因德和弗 兰克·J·威廉斯，《现代商用统计学》，p.383，普伦蒂斯一霍尔出版社，1969 年)。图表分析只是时间序列分析的 一种形式，正如所有的时间序列分析一样，也是以历史为依据的。无论谁，唯一能获得的资料或者数据，只是过去 的记录。只有把过去的经历投影到未来，我们才能估计未来。再从这本书中引用一段:人口预测、工业预测等等，在很大程度上是基于对过去发生的事物的研究。正如在日常生活中一样，在商业和 科学上，我们也都是依靠过击的经验展望难以捉摸的未来的(《现代商用统计学》，p.383)。综合起来，技术分析以过去的价格数据预测未来，有充分的统计学根据。要有人执意怀疑技术分析在这个方面 的立足点，那么他只好把所有以过去研究未来的学问一古脑儿推翻，当然其中免不了所有的经济分析、基础分析。 随机行走理论 随机行走理论原本在高知识阶层发端并流行。它认为价格变化在顺序上互相独立，因而价格历史并不是未来价格方向的可靠线索。简而言之，价格变化是随机而不可预测的。这个理论借着《股票市场的随机行走特点》一书到 处“行走”，名噪一时。该书编者是保罗·H·库特纳，由麻省理工学院出版社 1964 年出版。从此赞成和反对两派纷 纷著书立说，论战不休。该理论根据有效市场假定，认为价格在内在价值上下随机波动。同时还推论，最好的市场 策略就是简简单单地“买了等着”，反对“战胜市场”的企图。 所有的市场确实都具备一定的随机性，或者说“噪音”，但以为所有价格变化都是随机而来却并非实情。断这个 官司恐怕凭经验和实践更靠得住，而复杂高深的统计学方法要么似乎能证明研究者预先设想的一切，要么什么也否 定不了。满目随机其实只是无力辩识系统性价格变化形态的代名词，您不妨把这话记在心里浒多学者没有能力揭示 价格形态，可这并不能证明价格形态不存在(见图 1.4)。 图 1.4 请看这张瑞士法朗的图表，如果“随机行走论”者在这张图面前楞 想兜售“市场上根本无趋势可言”的论调的话，恐怕免不了要碰一鼻子灰当市场趋势明朗时，趋势对一般的市场分析人员或实际交易人员到底有无价值呢?学院派争论不休。要是您对 这一点也有疑惑，随便翻翻哪本图表书(随机地挑出来)，就可以很直观地看到趋势确实客观存在。如果价格变化前 后无关，也就等于昨天或者上星期的事儿在今天或明天全无痕迹，那么试问随机行走派诸君，如何解释触目可见的 趋势呢?不少顺应趋势系统在现实交易中战果辉煌，利润丰厚，又该作何解释呢?在期货市场选择时机是个关键，“买 了等着”如何行得通呢?应该在熊市中拿着这些头寸坐等吗?要是前后价格相互无关，价格变化既没有趋势也无从 预测，交易商如何能知道牛市和熊市的分别呢?事实上“买了等着”就等于是个上升趋势。那么熊市如何能存在呢? 统计学证据能否最终肯定或彻底推翻随机行走理论，天晓得，不过随机理论在技术分析界毫无市场。如果市场 果真随机，那么没有什么预测技术靠得住。有效市场假定恰恰同技术分析的前提之一“市场包容消化一切”异曲同 工，而不是否定了技术分析的可靠性。学院派也发觉市场很快地消化一切信息，想靠消息灵通来发财没门儿。在这 里他们总算摸着技术分析理论基础的一点边，即重要的市场信息在其广为人知之前，早已为市场价格所包容消化。 学院派弄巧成拙，反而清清楚楚地证明了密切关注价格变化的重要性，试图利用基础性情报渔利至少对短时期而言是缘木求鱼。 最后我们必须承认，要是不理解具体的过程进行规则，任何过程都会显得杂乱无章。比方说一张心电图，在外行看来，活象一长串杂乱无章的噪音，可在一个训练有素的医生眼中，其中每个小波折都充满了意义，肯定不是随 机而来。对没有花功夫研究期货市场行为规律的人来说，市场动作也可能是随机的。随着读图技能的提高，随机的 错觉逐渐消失。相信读者在逐步深入学习本书各章节的过程中，会亲身体验这种现象。 如果有兴趣进一步了解随机行走理论，这儿有一份自从70年代早期以来商品期货市场研究的摘要，名为《期货市场问题——一份调查报告》。卡玛拉摘录了几份认为期货价格具有连续性、反对随机理论的文章，也选入了另一派的意见，使学院派的这场争论有来有去。这些出版物学究气很浓。其它讨论随机理论 的文章偶尔可见。另一本书叫《在华尔街上随机走走》。 下面，我想引用市场技术分析师协会会员大会上的“主席致辞”，来结束对随机行走理论的讨论。这次会议是应学院派研究者为增进同各行业技术分析业者的交流的要求而召开的。 我注意到学院派研究者有一个重要的转变。他们现在终于意识到，尽管近年来学院派出版物上各种批评不绝于耳，分析家和投资者们依然非常成功(弗雷德·迪克森，协会主席，市场枝术分析师协会通讯，1984 年 2 月)。 结论现在我们已经为技术分析打好了理论基础，也澄清了一些有关技术分析的常见疑问，可以言归正传了。我们选择源远流长的最著名的技术分析理论—道氏理论作起点。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[既然有HTTP请求，为什么还要用RPC调用？]]></title>
    <url>%2F2020%2F11%2F25%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 问：既然有 HTTP 请求，为什么还要用 RPC 调用？ 首先 RPC 框架配置复杂，如果走 HTTP 请求同样也能做到相同功能，而且配置可以几乎为零配置。项目也不用引用太多的包。虽然如果单纯用 RPC，可以不用类似于 Servlet 的 Web 标准。 首先，实名赞扬题主的问题。这个问题非常好。 其次，实名反对各个上来就讲RPC好而HTTP不好的答案。因为，题主的观点非常对。 HTTP协议，以其中的Restful规范为代表，其优势很大。它可读性好，且可以得到防火墙的支持、跨语言的支持。而且，在去年的报告中，Restful大有超过RPC的趋势。 本想引用下报告内容，无奈最近由于某些原因，KeXueShangWang被Qiang了。等我日后出墙时，再做补充。 但是HTTP也有其缺点，这是与其优点相对应的。首先是有用信息占比少，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是效率低，还是因为第七层的缘故。还有，其可读性似乎没有必要，因为我们可以引入网关增加可读性。此外，使用HTTP协议调用远程方法比较复杂，要封装各种参数名和参数值。 而RPC则与HTTP互补，我们详细介绍下。看完这篇回答，能让你对RPC的产生、原理、实现代码都有着清晰的了解。这样，也能在业务系统中，在RPC和HTTP之间做好抉择。 但需要再说一句，不是说RPC好，也不是说HTTP好，两者各有千秋，还在比拼中。 要问我站谁？我根据业务场景，灵活站位…… RPC的英文全称是Remote Procedure Call，翻译为中文叫“远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是方法。所以，可以把RPC理解为“远程方法调用”。 要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。 而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。 要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。 然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。 服务A调用服务B的过程是应用间的内部过程，牺牲可读性提升效率、易用性是可取的。基于这种思路，RPC产生了。 通常，RPC要求在调用方中放置被调用的方法的接口。调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。 那要想实现这个过程该怎么办呢？别急，咱们一步一步来。 首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。 第二，动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步： 识别具体要调用的远程方法的IP、端口 将调用方法的入参进行序列化 通过通信将请求发送到远程的方法中 这样，远程的服务就接收到了调用方的请求。它应该： 反序列化各个调用参数 定位到实际要调用的方法，然后输入参数，执行方法 按照调用的路径返回调用的结果 整个过程如下所示。 这样，RPC操作就完成了。 调用方调用内部的一个方法，但是被RPC框架偷梁换柱为远程的一个方法。之间的通信数据可读性不需要好，只需要RPC框架能读懂即可，因此效率可以更高。通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。例如下面的示例中，为了保证实现最简单，就用了HTTP进行通信。 讲到这里，RPC的产生原因、原理应该清楚了。为了让大家真的明白，我写了一个真的是最最简单的RPC实现。把它放到了： https://github.com/yeecode/EasyRPC 它包含一个客户端，一个服务端。客户端只要调用自身内部的接口，就通过这个小的RPC实现调用到了服务端的方法。 下面是客户端的代码，看着类有点多，其实代码不长。其中的RPC代码完成完成动态代理、远程调用参数序列化、远程调用发起、远程调用结果反序列化的工作。 RPC客户端下面是服务端的代码，代码更少，完成远程调用接收、调用参数反序列化、调用实际触发、调用结果序列化的工作。 RPC服务端这样，一个RPC小框架就做完了，并不复杂。 所以，不要被RPC吓到，它就是让一个应用调用另一个应用中方法的一种实现方式。与调用远程接口区别不大，条条大路通罗马。 再说一次，不是说RPC好，也不是说HTTP好，两者各有千秋。本质上，两者是可读性和效率之间的抉择，通用性和易用性之间的抉择。最终谁能发展更好，很难说。 要问我站谁？我根据业务场景，灵活站位……]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈redis的热key问题如何解决]]></title>
    <url>%2F2020%2F11%2F24%2F%E8%B0%88%E8%B0%88redis%E7%9A%84%E7%83%ADkey%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言讲了几天的数据库系列的文章，大家一定看烦了，其实还没讲完。。。(以下省略一万字)。今天我们换换口味，来写redis方面的内容，谈谈热key问题如何解决。其实热key问题说来也很简单，就是瞬间有几十万的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况。其实生活中也是有不少这样的例子。比如XX明星结婚。那么关于XX明星的Key就会瞬间增大，就会出现热数据问题。ps:hot key和big key问题，大家一定要有所了解。本文预计分为如下几个部分 热key问题 如何发现 业内方案 正文热Key问题上面提到，所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。 怎么发现热key方法一:凭借业务经验，进行预估哪些是热key其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。方法二:在客户端进行收集这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。方法三:在Proxy层做收集有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。 方法四:用redis自带命令(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。方法五:自己抓包评估Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？ 如何解决目前业内的方案有两种(1)利用二级缓存比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。(2)备份热key这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。假设redis的集群数量为N，步骤如下图所示 注:不一定是2N，你想取3N，4N都可以，看要求。12345678910const M = N * 2//生成随机数random = GenRandom(0, M)//构造备份新keybakHotKey = hotKey + “_” + randomdata = redis.GET(bakHotKey)if data == NULL &#123; data = GetFromDB() redis.SET(bakHotKey, expireTime + GenRandom(0,5))&#125; 业内方案OK，其实看完上面的内容，大家可能会有一个疑问。 烟哥，有办法在项目运行过程中，自动发现热key，然后程序自动处理么？ 嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步(1)监控热key(2)通知系统做处理正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明(1)监控热key在监控热key方面，有赞用的是方式二：在客户端进行收集。在《有赞透明多级缓存解决方案（TMC）》中有一句话提到 TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。 也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。那Hermes-SDK包用来干嘛？OK，就是做热点发现和本地缓存。从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。 当然，这只是其中一种方式，有的公司在监控方面用的是方式五:自己抓包评估具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。 (2)通知系统做处理在这个角度，有赞用的是上面的解决方案一:利用二级缓存进行处理。有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。 除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。 通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-跳跃表]]></title>
    <url>%2F2020%2F11%2F24%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 原文地址 前言跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。这么说，我们可能很难理解，我们可以先回忆一下链表。 跳跃表什么是跳跃表对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。 如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。 这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为7的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。我们下降到链表层继续遍历就找到了8这个节点。原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。 从这个例子里，我们看出，加了一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。 从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。 像这种链表加多级索引的结构，就是跳跃表！ Redis跳跃表Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。 这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？ 从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。 Redis中跳跃表的实现Redis的跳跃表由zskiplistNode和zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。 上图展示了一个跳跃表示例，其中最左边的是skiplist结构，该结构包含以下属性。 header：指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1) tail：指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1) level：记录目前跳跃表内,层数最大的那个节点的层数（表头节点的层数不计算在内），通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。 length：记录跳跃表的长度,也即是,跳跃表目前包含节点的数量（表头节点不计算在内），通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。 结构右方的是四个zskiplistNode结构，该结构包含以下属性： 层（level）： 节点中用1、2、L3等字样标记节点的各个层，L1代表第一层，L代表第二层，以此类推。 每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离（跨度越大、距离越远）。在上图中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。 每次创建一个新跳跃表节点的时候,程序都根据幂次定律（powerlaw，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。 后退（backward）指针： 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。 分值（score）： 各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。 成员对象（oj）： 各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。 Redis跳跃表常用操作的时间复杂度 操作 时间复杂度 创建一个跳跃表 O(1) 释放给定跳跃表以及其中包含的节点 O(N) 添加给定成员和分值的新节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 删除除跳跃表中包含给定成员和分值的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 返回给定成员和分值的节点再表中的排位 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 返回在给定排位上的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 给定一个分值范围，返回跳跃表中第一个符合这个范围的节点 O(1) 给定一个分值范围，返回跳跃表中最后一个符合这个范围的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 给定一个分值范围，除跳跃表中所有在这个范围之内的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 给定一个排位范围，鼎除跳跃表中所有在这个范围之内的节点 O(N)，N为被除节点数量 给定一个分值范围（range），比如0到15，20到28，诸如此类，如果跳氏表中有至少一个节点的分值在这个范間之内，那么返回1，否则返回0 O(N)，N为被除节点数量 本文重点 跳跃表基于单链表加索引的方式实现。 跳跃表以空间换时间的方式提升了查找速度。 Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现。 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。 Redis每个跳跃表节点的层高都是1至32之间的随机数。 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的ArrayAccess用法详解]]></title>
    <url>%2F2020%2F11%2F04%2FPHP%E4%B8%AD%E7%9A%84ArrayAccess%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在Laravel的源码当中，作者多次使用到了PHP SPL中的ArrayAccess接口，那么这个ArrayAccess接口到底有什么作用呢？我会用一个简单的例子跟大家说明。 请看下面的这段代码，Foo类实现了ArrayAccess接口中的四个方法，请仔细看这些方法内部的实现代码。看到了吗？这些代码是干什么用的，回答就是这些代码没有用，随便你怎么写，你想写什么就写什么。接口中这四个方法的内部的实现跟方法名字其实没有任何关系。啊！这。。。实际的作用是取决于你的调用。 12345678910111213141516171819202122class Foo implements ArrayAccess&#123; public function offsetExists( $offset ) &#123; echo "这里是 offsetExists() 方法 你输入的参数是 &#123;$offset&#125;"; &#125; public function offsetGet( $offset ) &#123; echo "这里是 offsetGet() 方法 你输入的参数是 $offset"; &#125; public function offsetSet( $offset, $value ) &#123; echo "这里是 offsetSet() 方法 你输入的 &#123;$offset&#125;=&#123;$value&#125;"; &#125; public function offsetUnset( $offset ) &#123; echo "这里是 offsetUnset() 方法 你输入的参数是 &#123;$offset&#125;"; &#125;&#125; 好，我们调用一下看看。 我们使用isset这个函数去调用$foo[‘how’]，那么实际上是调用了offsetExists这个方法，也就是说$foo[‘xxxx’]这种结构去调用哪个ArrayAccess的方法是取决于你是如何调用的$foo[‘xxxx’]。而方法内部的实现代码你想怎么写就怎么写。在这里一旦你使用isset去调用了这种结构，系统就会去调用offsetExists这个方法，在本例中方法里面有什么，仅仅是echo了一句话。为什么var_dump($t); 会输出false呢？因为在我们实现的这个offsetExists方法里面，没有任何的返回值，没有返回值当然就是null了，也就是false了。123$foo = new Foo();$t = isset($foo['how']);// 输出: 这里是 offsetExists() 方法 你输入的参数是 howvar_dump($t);// 输出: boolean false 接着看看这种$foo[‘xxxx’]结构还可以怎样被调用，不如我们这次直接使用$foo[‘xxxx’]看看。原来直接使用$foo[‘xxxx’]这种结构也可以调用一个方法啊，从输出当中得知调用了offsetGet方法，同样也获取到了参数。12$foo = new Foo();$foo['what'];// 输出: 这里是 offsetGet() 方法 你输入的参数是 what 继续看还能怎么调用到其他的方法，我们给这个结构赋值看看，果然赋值的操作当然是调用offsetSet方法了，同样的方法内部的实现代码仍然还是你想写什么就写什么。12$foo = new Foo();$foo['when'] = 'today';// 输出: 这里是 offsetSet() 方法 你输入的 when=today 最后一个了，看方法名字也知道是通过unset方法才能被调用了。 $foo = new Foo(); unset($foo[&#39;wow&#39;]);// 输出: 这里是 offsetUnset() 方法 你输入的参数是 wow 总结好了，总结一下吧： 如果你的类实现了ArrayAccess接口，那么这个类的对象就可以使用$foo[‘xxx’]这种结构了。 $foo[‘xxx’] 对应调用offsetGet方法。 $foo[‘xxx’] = ‘yyy’ 对应调用offsetSet方法。 isset($foo[‘xxx’]) 对应调用offsetExists方法。 unset($foo[‘xxx’]) 对应调用offsetUnset方法。 再次强调，方法的实现代码，你想怎么写就怎么写。（当然代码的功能最好是贴近方法名啦）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis分布式锁解决超卖问题]]></title>
    <url>%2F2020%2F07%2F30%2FRedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Redis的multi命令是什么意思？ watch要在multi前面吗？ Redis事务Redis事务介绍 1.redis事务可以一次执行多个命令，本质是一组命令的集合。 2.一个事务中的所有命令都会序列化，按顺序串行化的执行而不会被其他命令插入。 作用：一个队列中，一次性、顺序性、排他性的执行一系列命令。 multi指令的使用 1.下面指令演示了一个完整的事务过程，所有指令在exec前不执行，而是缓存在服务器的一个事务队列中。 2.服务器一旦收到exec指令才开始执行事务队列，执行完毕后一次性返回所有结果。 3.因为redis是单线程的，所以不必担心自己在执行队列时被打断，可以保证“原子性”。 注：Redis事务在遇到指令失败后，后面的指令会继续执行。 1234567# Multi命令用于标记一个事务块的开始# 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由EXEC命令原子性（atomic）的执行&gt; multi #（开始一个redis事务）incr booksincr books&gt; exec #（执行事务）&gt; discard #（丢弃事务） 12345678910111213141516def multi_test(): r = redis.Redis(host='127.0.0.1') pipe = r.pipeline() pipe.multi() # 开启事务 pipe.set('key2', 400) # 存储子命令 pipe.execute() # 执行事务 print("第一次事务提交后的结果" + r.get('key2').decode("utf-8")) pipe.multi() # 开启事务 pipe.set('key2', 100) # 存储子命令 print("第二次未提交事务的结果" + r.get("key2").decode("utf-8"))#第一次事务提交后的结果400#第二次未提交事务的结果400 注：mysql的rollback与redis的discard的区别 1.mysql回滚为sql全部成功才执行，一条sql失败则全部失败，执行rollback后所有语句造成的影响消失。 2.redis的discard只是结束本次事务，正确命令造成的影响仍然还在。 1）redis如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 2）redis如果在一个事务中出现运行错误，那么正确的命令会被执行。 watch指令作用 1.watch其实就是redis提供的一种乐观锁，可以解决并发修改问题。 2.watch会在事务开始前盯住一个或多个关键变量，当服务器收到exec指令要顺序执行缓存中的事务队列时，redis会检查关键变量自watch后是否被修改。 3.watch只会在数据被其他客户端抢先修改了的情况下通知执行命令的这个客户端（通过WatchError异常），但不会阻止其他客户端对数据的修改。 watch+multi实现乐观锁 setnx指令（redis的分布式锁） 1.分布式锁本质是占一个坑，当别的进程也要来占坑时发现已经被占，就会放弃或者稍后重试。 2.占坑一般使用setnx（set if not exists）指令，只允许一个客户端占坑。 3.先来先占，用完了在调用del指令释放坑。 123&gt; setnx lock:codehole true.... do something critical ....&gt; del lock:codehole 4.但是这样有一个问题，如果逻辑执行到中间出现异常，可能导致del指令没有被调用，这样就会陷入死锁，锁永远无法释放。 5.为了解决死锁问题，我们拿到锁时可以加上一个expire过期时间，这样即使出现异常，当到达过期时间也会自动释放锁。 1234&gt; setnx lock:codehole true&gt; expire lock:codehole 5.... do something critical ....&gt; del lock:codehole 6.这样又有一个问题，setnx和expire是两条指令而不是原子指令，如果两条指令之间进程挂掉依然会出现死锁。 7.为了治理上面乱象，在redis2.8中加入了set指令的扩展参数，使setnx和expire指令可以一起执行。 123&gt; set lock:codehole true ex 5 nx''' do something '''&gt; del lock:codehole Redis解决超卖问题使用Redis的watch+multi指令实现1234567891011121314151617181920212223242526#! /usr/bin/env python# -*- coding: utf-8 -*-import redisdef sale(rs): while True: with rs.pipeline() as p: try: p.watch('apple') # 监听key值为apple的数据数量改变 count = int(rs.get('apple')) print('拿取到了苹果的数量: %d' % count) p.multi() # 事务开始 if count&gt; 0 : # 如果此时还有库存 p.set('apple', count - 1) p.execute() # 执行事务 p.unwatch() break # 当库存成功减一或没有库存时跳出执行循环 except Exception as e: # 当出现watch监听值出现修改时，WatchError异常抛出 print('[Error]: %s' % e) continue # 继续尝试执行rs = redis.Redis(host='127.0.0.1', port=6379) # 连接redisrs.set('apple',1000) # 首先在redis中设置某商品apple对应数量value值为1000sale(rs) 1）原理 1.当用户购买时，通过WATCH监听用户库存，如果库存在watch监听后发生改变，就会捕获异常而放弃对库存减一操作； 2.如果库存没有监听到变化并且数量大于1，则库存数量减一，并执行任务。 2）弊端 1.Redis在尝试完成一个事务的时候，可能会因为事务的失败而重复尝试重新执行。 2.保证商品的库存量正确是一件很重要的事情，但是单纯的使用WATCH这样的机制对服务器压力过大。 使用Redis的watch+multi+setnx指令实现1）为什么要自己构建锁 1.虽然有类似的SETNX命令可以实现Redis中的锁的功能，但他锁提供的机制并不完整。 2.并且setnx也不具备分布式锁的一些高级特性，还是得通过我们手动构建。 2）创建一个redis锁 1.在Redis中，可以通过使用SETNX命令来构建锁：rs.setnx(lock_name, uuid值)。 2.而锁要做的事情就是将一个随机生成的128位UUID设置位键的值，防止该锁被其他进程获取。 3）释放锁 1.锁的删除操作很简单，只需要将对应锁的key值获取到的uuid结果进行判断验证； 2.符合条件（判断uuid值）通过delete在redis中删除即可，rs.delete(lockname)； 3.此外当其他用户持有同名锁时，由于uuid的不同，经过验证后不会错误释放掉别人的锁。 4）解决锁无法释放问题 1.在之前的锁中，还出现这样的问题，比如某个进程持有锁之后突然程序崩溃，那么会导致锁无法释放； 2.而其他进程无法持有锁继续工作，为了解决这样的问题，可以在获取锁的时候加上锁的超时功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import redisimport uuidimport time# 1.初始化连接函数def get_conn(host,port=6379): rs = redis.Redis(host=host, port=port) return rs# 2. 构建redis锁def acquire_lock(rs, lock_name, expire_time=10): ''' rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 return -&gt; False 获锁失败 or True 获锁成功 ''' identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 return identifier # time.sleep(.001) return False# 3. 释放锁def release_lock(rs, lockname, identifier): ''' rs: 连接对象 lockname: 锁标识 identifier: 锁的value值，用来校验 ''' if rs.get(lockname).decode() == identifier: # 防止其他进程同名锁被误删 rs.delete(lockname) return True # 删除锁 else: return False # 删除失败#有过期时间的锁def acquire_expire_lock(rs, lock_name, expire_time=10, locked_time=10): ''' rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 locked_time: 锁的有效时间 return -&gt; False 获锁失败 or True 获锁成功 ''' identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 # print('锁已设置: %s' % identifier) rs.expire(lock_name, locked_time) return identifier time.sleep(.001) return False'''在业务函数中使用上面的锁'''def sale(rs): start = time.time() # 程序启动时间 with rs.pipeline() as p: ''' 通过管道方式进行连接 多条命令执行结束，一次性获取结果 ''' while 1: lock = acquire_lock(rs, 'lock') if not lock: # 持锁失败 continue #开始监测"lock" p.watch("lock") try: #开启事务 p.multi() count = int(rs.get('apple')) # 取量 p.set('apple', count-1) # 减量 # time.sleep(5) #提交事务 p.execute() print('当前库存量: %s' % count) #成功则跳出循环 break except: #事务失败对应处理 print("修改数据失败") #无论成功与否最终都需要释放锁 finally: res = release_lock(rs, 'lock', lock) #释放锁成功， if res: print("删除锁成功") #释放锁失败，强制删除 else: print("删除锁失败,强制删除锁") res = rs.delete('lock') print(res) print('[time]: %.2f' % (time.time() - start))rs = redis.Redis(host='127.0.0.1', port=6379) # 连接redis# rs.set('apple',1000) # # 首先在redis中设置某商品apple 对应数量value值为1000sale(rs) 优化锁无法释放的问题，为锁添加过期时间 def acquire_expire_lock(rs, lock_name, expire_time=10, locked_time=10): &#39;&#39;&#39; rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 locked_time: 锁的有效时间 return -&gt; False 获锁失败 or True 获锁成功 &#39;&#39;&#39; identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 # print(&#39;锁已设置: %s&#39; % identifier) rs.expire(lock_name, locked_time) return identifier time.sleep(.001) return False]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Lock]]></title>
    <url>%2F2020%2F07%2F29%2FLaravel-Lock%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 使用创建锁 12345678910use Illuminate\Support\Facades\Cache;$lock = Cache::lock('foo', 10);if ($lock-&gt;get()) &#123; // 处理业务逻辑 sleep(3); $lock-&gt;release();&#125; 获取无限期锁并自动释放 get方法可以接收一个闭包。在闭包执行之后，Laravel将会自动释放锁。 123Cache::lock('foo')-&gt;get(function () &#123; // 获取无限期锁并自动释放...&#125;); 在指定时间内获取锁 123456789101112use Illuminate\Contracts\Cache\LockTimeoutException;$lock = Cache::lock('foo', 10);try &#123; $lock-&gt;block(5); echo "5秒时间内成功获取锁...";&#125; catch (LockTimeoutException $e) &#123; echo "5秒时间内获取锁失败...";&#125; finally &#123; optional($lock)-&gt;release();&#125; 另一种写法：123Cache::lock('foo', 10)-&gt;block(5, function () &#123; echo "5秒时间内成功获取锁...";&#125;); 无视拥有者强制释放锁 1Cache::lock('foo')-&gt;forceRelease(); 跨进程管理锁 1234567// 控制器中...$podcast = Podcast::find($id);$lock = Cache::lock('foo', 120);if ($result = $lock-&gt;get()) &#123; ProcessPodcast::dispatch($podcast, $lock-&gt;owner());&#125; 123// 队列任务中...// 使用锁名称和拥有者重新获取锁实例后再释放Cache::restoreLock('foo', $this-&gt;owner)-&gt;release(); 源码接口 Illuminate\Contracts\Cache\Lock.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace Illuminate\Contracts\Cache;interface Lock&#123; /** * 尝试获取锁。 * * @param callable|null $callback * @return mixed */ public function get($callback = null); /** * 尝试获取给定秒数的锁。 * * @param int $seconds * @param callable|null $callback * @return bool */ public function block($seconds, $callback = null); /** * Release the lock. * * @return void */ public function release(); /** * Returns the current owner of the lock. * * @return string */ public function owner(); /** * Releases this lock in disregard of ownership. * * @return void */ public function forceRelease();&#125; 首先是锁的抽象类，定义了继承的类必须实现加锁、释放锁、返回锁拥有者的方法。 Illuminate\Cache\Lock.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Lock as LockContract;use Illuminate\Contracts\Cache\LockTimeoutException;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Str;abstract class Lock implements LockContract&#123; use InteractsWithTime; /** * 锁的名称 * * @var string */ protected $name; /** * 锁的时长 * * @var int */ protected $seconds; /** * 当前操作锁的拥有者 * * @var string */ protected $owner; /** * 获取锁失败时，重新获取锁需要等待的毫秒数 * * @var int */ protected $sleepMilliseconds = 250; /** * 构造函数 * * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($name, $seconds, $owner = null) &#123; if (is_null($owner)) &#123; $owner = Str::random(); &#125; $this-&gt;name = $name; $this-&gt;owner = $owner; $this-&gt;seconds = $seconds; &#125; /** * 加锁 * * @return bool */ abstract public function acquire(); /** * 释放锁 * * @return bool */ abstract public function release(); /** * 获取锁中保存的拥有者信息 * * @return string */ abstract protected function getCurrentOwner(); /** * 尝试获取锁，获取成功后执行一个回调函数，执行完成后自动释放锁 * * @param callable|null $callback * @return mixed */ public function get($callback = null) &#123; $result = $this-&gt;acquire(); if ($result &amp;&amp; is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return $result; &#125; /** * 尝试在指定的时间内获取锁，超时则失败抛出异常 * * @param int $seconds * @param callable|null $callback * @return bool * * @throws \Illuminate\Contracts\Cache\LockTimeoutException */ public function block($seconds, $callback = null) &#123; $starting = $this-&gt;currentTime(); while (! $this-&gt;acquire()) &#123; usleep($this-&gt;sleepMilliseconds * 1000); if ($this-&gt;currentTime() - $seconds &gt;= $starting) &#123; throw new LockTimeoutException; &#125; &#125; if (is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return true; &#125; /** * 返回当前操作锁的拥有者 * * @return string */ public function owner() &#123; return $this-&gt;owner; &#125; /** * 判断当前操作的拥有者是否为锁中保存的拥有者 * * @return bool */ protected function isOwnedByCurrentProcess() &#123; return $this-&gt;getCurrentOwner() === $this-&gt;owner; &#125; /** * 设置重试获取锁需要等待的毫秒数 * * @param int $milliseconds * @return $this */ public function betweenBlockedAttemptsSleepFor($milliseconds) &#123; $this-&gt;sleepMilliseconds = $milliseconds; return $this; &#125;&#125; Illuminate\Contracts\Cache\LockTimeoutException.php 12345678910&lt;?phpnamespace Illuminate\Contracts\Cache;use Exception;class LockTimeoutException extends Exception&#123; //&#125; Redis锁实现类，增加了强制删除锁的方法。 Illuminate\Cache\RedisLock.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpnamespace Illuminate\Cache;class RedisLock extends Lock&#123; /** * Redis对象 * * @var \Illuminate\Redis\Connections\Connection */ protected $redis; /** * Create a new lock instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($redis, $name, $seconds, $owner = null) &#123; parent::__construct($name, $seconds, $owner); $this-&gt;redis = $redis; &#125; /** * Attempt to acquire the lock. * * @return bool */ public function acquire() &#123; if ($this-&gt;seconds &gt; 0) &#123; return $this-&gt;redis-&gt;set($this-&gt;name, $this-&gt;owner, 'EX', $this-&gt;seconds, 'NX') == true; &#125; else &#123; return $this-&gt;redis-&gt;setnx($this-&gt;name, $this-&gt;owner) === 1; &#125; &#125; /** * Release the lock. * * @return bool */ public function release() &#123; return (bool) $this-&gt;redis-&gt;eval(LuaScripts::releaseLock(), 1, $this-&gt;name, $this-&gt;owner); &#125; /** * 无视锁的拥有者强制删除锁 * * @return void */ public function forceRelease() &#123; $this-&gt;redis-&gt;del($this-&gt;name); &#125; /** * 返回锁中保存的拥有者信息 * * @return string */ protected function getCurrentOwner() &#123; return $this-&gt;redis-&gt;get($this-&gt;name); &#125;&#125; 原子性释放锁的Lua脚本。 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\Cache;class LuaScripts&#123; /** * 使用Lua脚本原子性地释放锁. * * KEYS[1] - 锁的名称 * ARGV[1] - 锁的拥有者，只有是该锁的拥有者才允许释放 * * @return string */ public static function releaseLock() &#123; return &lt;&lt;&lt;'LUA'if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1])else return 0endLUA; &#125;&#125; 总结 1.可以通过get()方法直接获取锁并传入回调函数在成功时执行。 2.可以通过block()方法在指定时间内不断获取锁，知道成功或超时为止，成功时会执行传入的回调函数。 3.Redis通过set()命令设置一个值为“拥有者”的字符串来作为锁。 4.set()通过NX参数来实现排他锁（只在键不存在时，才对键进行设置）。 5.set()通过EX参数来控制锁的生存时间（防止程序意外终止发生死锁）。 6.不能使用set()+expire()来代替set()，防止网络延迟或其他故障导致死锁。 7.Redis通过Lua脚本来达到原子性删除锁。 8.Lua脚本中会判断字符串的内容是否与参数中的拥有者一致，一致才执行删除操作。防止当前锁被其他进程误删除，或者误删除了其他进程的锁。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP使用Redis锁限制并发访问类]]></title>
    <url>%2F2020%2F07%2F29%2FPHP%E4%BD%BF%E7%94%A8Redis%E9%94%81%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 1.并发访问限制问题对于一些需要限制同一个用户并发访问的场景，如果用户并发请求多次，而服务器处理没有加锁限制，用户则可以多次请求成功。 例如换领优惠券，如果用户同一时间并发提交换领码，在没有加锁限制的情况下，用户则可以使用同一个换领码同时兑换到多张优惠券。 伪代码如下：1234if A(可以换领) B(执行换领) C(更新为已换领)D(结束) 如果用户并发提交换领码，都能通过可以换领(A)的判断，因为必须有一个执行换领(B)后，才会更新为已换领(C)。因此如果用户在有一个更新为已换领之前，有多少次请求，这些请求都可以执行成功。 2.并发访问限制方法本文将使用Redis的setnx方法实现分布式锁功能。setnx即Set it Not eXists。 当键值不存在时，插入成功（获取锁成功），如果键值已经存在，则插入失败（获取锁失败）。 RedisLock.class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?phpclass RedisLock &#123; private $_config; private $_redis; /** * 初始化 * * @param Array $config redis连接设定 */ public function __construct($config=[]) &#123; $this-&gt;_config = $config; $this-&gt;_redis = $this-&gt;connect(); &#125; /** * 获取锁 * * @param String $key 锁标识 * @param Int $expire 锁过期时间 * @return Boolean */ public function lock($key, $expire=5) &#123; $is_lock = $this-&gt;_redis-&gt;setnx($key, time()+$expire); // 已经设置了，不能获取锁 if(!$is_lock) &#123; // 判断锁是否过期 $lock_time = $this-&gt;_redis-&gt;get($key); // 锁已过期，删除锁，重新获取 if(time() &gt; $lock_time) &#123; $this-&gt;unlock($key); $is_lock = $this-&gt;_redis-&gt;setnx($key, time()+$expire); &#125; &#125; return $is_lock ? true : false; &#125; /** * 释放锁 * * @param String $key 锁标识 * @return Boolean */ public function unlock($key) &#123; return $this-&gt;_redis-&gt;del($key); &#125; /** * 创建redis连接 * * @return Link */ private function connect() &#123; try &#123; $redis = new Redis(); $redis-&gt;connect( $this-&gt;_config['host'], $this-&gt;_config['port'], $this-&gt;_config['timeout'], $this-&gt;_config['reserved'], $this-&gt;_config['retry_interval'] ); if(!empty($this-&gt;_config['auth'])) &#123; $redis-&gt;auth($this-&gt;_config['auth']); &#125; $redis-&gt;select($this-&gt;_config['index']); &#125;catch(RedisException $e) &#123; throw new Exception($e-&gt;getMessage()); &#125; return $redis; &#125;&#125; demo.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire 'RedisLock.class.php';$config = [ 'host' =&gt; 'localhost', 'port' =&gt; 6379, 'index' =&gt; 0, 'auth' =&gt; '', 'timeout' =&gt; 1, 'reserved' =&gt; NULL, 'retry_interval' =&gt; 100,];// 创建redislock对象$oRedisLock = new RedisLock($config);// 定义锁标识$key = 'mylock';// 获取锁$is_lock = $oRedisLock-&gt;lock($key, 10);if($is_lock)&#123; echo 'get lock success&lt;br&gt;'; echo 'do sth..&lt;br&gt;'; sleep(5); echo 'success&lt;br&gt;'; $oRedisLock-&gt;unlock($key);// 获取锁失败&#125;else&#123; echo 'request too frequently&lt;br&gt;';&#125; 测试方法： 打开两个不同的浏览器,同时在A,B中访问demo.php，先访问的会获取到锁。 输出：123get lock successdo sth..success 另一个获取锁失败则会输出：1request too frequently 保证同一时间只有一个访问有效，有效限制并发访问。 为了避免系统突然出错导致死锁，所以在获取锁的时候增加一个过期时间，如果已超过过期时间，即使是锁定状态都会释放锁，避免死锁导致的问题。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP在大并发下Redis锁实现]]></title>
    <url>%2F2020%2F07%2F29%2FPHP%E5%9C%A8%E5%A4%A7%E5%B9%B6%E5%8F%91%E4%B8%8BRedis%E9%94%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在现如今电商盛行的时期，会出现很多促销活动，最为常见的就是秒杀。在秒杀系统中最为常见的问题就是会出现超卖的情况，那么如何来杜绝超卖的情形了，在业务逻辑层面可以使用缓存以及加锁的手法来避免超卖的情形。 现如今nosql已经非常流行和稳定了，在此我将通过redis和php来说明如何实现锁机制。当然我使用redis加锁并不是我的秒杀系统，而是最近做的一个项目有个用户提现，初期没有考虑到会有人恶意刷新接口，而导致用户无限制提现。经过查看nginx日志，发现用户在同一时间段，通过刷接口的方法超额提现，导致亏损 起初的提现代码如下：]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则]]></title>
    <url>%2F2020%2F06%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。怎么理解？ 为什么在对每一个模式进行优缺点评价时都会将开闭原则作为一个重要的评价依据？ 为什么在程序中尽量使用基类类型对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象？ 为什么用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情？ 为什么在程序中应该尽量使用抽象层进行编程而将具体类写在配置文件中？ 为什么接口应该尽量细化，同时接口中的方法应该尽量少？ 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。这种复用名词是什么？ 什么是“黑箱”复用？ **本章导学** 对于面向对象软件系统设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的，每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 本章将学习7个重要的面向对象设计原则，结合实例分析7个原则的特点，这7个原则分别是单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成复用原则和迪米特法则。 快速跳转 单一职责原则 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 合成复用原则 迪米特法则 面向对象设计原则概述软件的可维护性（Maintainability）和可复用性（Reusability）是两个非常重要的用于衡量软件质量的质量属性，软件的可维护性是指软件能够被理解、改正、适应及扩展的难易程度，软件的可复用性是指软件能够被重复使用的难易程度。 面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性。面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则，但并不是强制性的。 面向对象设计原则也是后续学习设计模式的基础，每一个设计模式都符合一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一。通过在软件开发中使用这些原则可以提高软件的可维护性和可复用性，以便设计出兼具良好的可维护性和可复用性的软件系统，实现可维护性复用的目标。 最常见的7个面向对象设计原则如表1所示。 表1 7个常用的面向对象设计原则 **设计原则名称** **定 义** **使用频率** 单一职责原则（Single Responsibility Principle， SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 ★★★★☆ 开闭原则（Open-Closed Principle， OCP） 软件实体应当对扩展开放，对修改关闭 ★★★★★ 里氏代换原则（Liskov Substitution Principle， LSP） 所有引用基类的地方必须能透明地使用其子类的对象 ★★★★★ 依赖倒转原则（Dependence Inversion Principle， DIP） 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 ★★★★★ 接口隔离原则（Interface Segregation Principle， ISP） 客户端不应该依赖那些它不需要的接口 ★★☆☆☆ 合成复用原则（Composite Reuse Principle， CRP） 优先使用对象组合，而不是继承来达到复用的目的 ★★★★☆ 迪米特法则（Law of Demeter， LoD） 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 ★★★☆☆ 单一职责原则&lt;/span&gt;单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小。 单一职责原则的定义如下：1一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 单一职责原则的另一种定义方法：1就一个类而言，应该仅有一个引起它变化的原因。 软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。因此，要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可以将它们封装在同一类中。 单一职责原则是实现高内聚、低耦合的指导方针，是最简单却最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 下面通过一个简单实例来进一步分析单一职责原则： 某软件公司开发人员针对CRM（Customer Relationship Management，客户关系管理）系统中的客户信息图表统计模块提出了如图1所示的初始设计方案。图1 初始设计方案结构图在图1中，GetConnection()方法用于连接数据库，FindCustomers()方法用于查询所有的客户信息，CreateChart()方法用于创建图表，DisplayChart()方法用于显示图表。现使用单一职责原则对其进行重构。 在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用FindCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它拥有不止一个引起变化的原因，违背了单一职责原则。因此，需要对该类进行拆分，使其满足单一职责原则，CustomerDataChart类可拆分为以下3个类。 (1)DBUtil：负责连接数据库，包含数据库连接方法GetConnection()。 (2)CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增、删、改、查等方法，例如FindCustomers()。 (3)CustomerDataChart：负责图表的生成和显示，包含方法CreateChart()和DisplayChart()。 使用单一职责原则重构后的结构如图2所示。 图2 重构后的结构图 开闭原则&lt;/span&gt;开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则。 开闭原则的定义如下：1软件实体应当对扩展开放，对修改关闭。 在开闭原则的定义中，软件实体可以是一个软件模块、一个由多个类组成的局部结构或一个独立的类。开闭原则是指软件实体应尽量在不修改原有代码的情况下进行扩展。 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在C#、Java等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 在GoF23种设计模式中，大部分设计模式都符合开闭原则，在对每一个模式进行优缺点评价时都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可扩展性。 里氏替换原则&lt;/span&gt;里氏代换原则的严格表述为：1如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。 这个原始的定义不太容易理解，因此，一般使用它的通俗版定义：1所有引用基类的地方必须能透明地使用其子类的对象。 里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢所有的动物。 里氏代换原则是实现开闭原则的基础，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在运用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。运行时，子类实例替换父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 依赖倒转原则&lt;/span&gt;如果说开闭原则是面向对象设计的目标，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则的定义如下：1高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 简单来说，依赖倒转原则要求:1要针对接口编程，不要针对实现编程。 依赖倒转原则要求，在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中应该尽量使用抽象层进行编程而将具体类写在配置文件中。这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时，需要针对抽象层进行编程，而将具体类的对象通过依赖注入（Dependency Injection，DI）的方式注入其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过方法参数来注入所依赖的对象。常用的注入方式有3种，分别是构造注入、设值（Setter）注入和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 下面通过一个简单实例来加深对开闭原则、里氏代换原则和依赖倒转原则的理解： 某软件公司开发人员在开发CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类CustomerDAO中将调用数据格式转换类的方法来实现格式转换，初始设计方案结构如图3所示。图3 初始设计方案结构图在编码实现图3所示的结构时，该软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要经常更换数据转换类。例如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违背了开闭原则，需要对该方案进行重构。 在本实例中，由于CustomerDAO针对具体数据转换类编程，所以在增加新的数据转换类或者更换数据转换类时不得不修改CustomerDAO的源代码。可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会产生任何异常。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图4所示。 图4 重构后的结构图 在上述重构过程中，同时使用了开闭原则、里氏代换原则和依赖倒转原则。在大多数情况下，这3个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 接口隔离原则&lt;/span&gt;接口隔离原则的定义如下：1客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”，有严格的定义和结构，例如C#和Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义也有所不同。 (1)当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以称为“角色隔离原则”。 (2)如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，对于客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责分别放在不同的小接口中，以确保每个接口用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 下面通过一个简单实例来加深对接口隔离原则的理解： 某软件公司开发人员针对CRM系统的客户数据显示模块设计了图5所示的接口，其中，方法DataRead()用于从文件中读取数据，方法TransformToXML()用于将数据转换成XML格式，方法CreateChart()用于创建图表，方法DisplayChart()用于显示图表，方法CreateReport()用于创建文字报表，方法DisplayReport()用于显示文字报表。图5 初始设计方案结构图在实际使用过程中开发人员发现该接口很不灵活，例如，一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，不得不实现其中声明的TransformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需要实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序在编译时将报错。现使用接口隔离原则对其进行重构。 在图5中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程度上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此，需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端所需的方法即可。 通过使用接口隔离原则，本实例重构后的结构如图6所示。 图6 重构后的结构图 在使用接口隔离原则时，需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些他们不用的方法。 合成复用原则&lt;/span&gt;合成复用原则又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP），其定义如下：1优先使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，因为组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此开发人员需要慎重使用继承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的某些内部细节对子类来说是可见的，所以这种复用又称为“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 一般而言，如果两个类之间是“Has-A”关系应使用组合或聚合，如果是“Is-A”关系可使用继承。“Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的一种；而“Has-A”则不同，它表示某一个角色具有某一项责任。 下面通过一个简单实例来加深对合成复用原则的理解： 某软件公司开发人员在初期的CRM系统设计中，考虑到客户数量不多，系统采用Access作为数据库，与数据库操作有关的类，例如CustomerDAO类等都需要连接数据库，连接数据库的方法GetConnection()封装在DBUtil类中，由于需要重用DBUtil类的GetConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如图7所示。图7 初始设计方案结构图随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违背开闭原则。当然也可以直接修改DBUtil类的源代码，这同样也违背了开闭原则。现使用合成复用原则对其进行重构。 根据合成复用原则，在实现复用时应该多用关联，少用继承。因此在本实例中可以使用关联复用来取代继承复用，重构后的结构如图8所示。 图8 重构后的结构图 在图8中，CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用设值注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，例如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须修改，而且还可以很灵活地增加新的数据库连接方式，符合开闭原则。 迪米特法则&lt;/span&gt;迪米特法则又称为最少知识原则（Least Knowledge Principle，LKP），其定义如下：1每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 迪米特法则还有几种定义形式，包括不要和“陌生人”说话（Don’t talk to strangers）、只与你的直接朋友通信（Talk only to your immediate friends）等，在迪米特法则中，对于一个对象，其朋友包括以下几类： (1)当前对象本身（this）。 (2)以参数形式传入到当前对象方法中的对象。 (3)当前对象的成员对象。 (4)如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。 (5)当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要和“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。 迪米特法则要求在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。简而言之，就是通过引入一个合理的“第三者”来降低现有对象之间的耦合度。 在将迪米特法则运用到系统设计中时，要注意几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大影响；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 下面通过一个简单实例来加深对迪米特法则的理解： 某软件公司所开发的CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应。例如，当一个按钮（Button）被单击时，对应的列表框（List）、组合框（ComboBox）、文本框（TextBox）、文本标签（Label）等都将发生改变，在初始设计方案中，界面控件之间的交互关系可以简化为图9所示的结构。图9 初始设计方案结构图在图9中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除控件。现使用迪米特法则对其进行重构。 在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类（Mediator）来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后的结构如图10所示。 图10 重构后的结构图 在图10中，省略了中间类以及控件的属性和方法定义，在中介者模式中将进一步对该实例进行讲解，详细说明中间类Mediator的设计和实现。 本章小结(1)在软件开发中使用面向对象设计原则可以提高软件的可维护性和可复用性，以便设计出兼具良好的可维护性和可复用性的软件系统，实现可维护性复用的目标。 (2)单一职责原则要求在软件系统中，一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 (3)开闭原则要求软件实体应当对扩展开放，对修改关闭。 (4)里氏代换原则可以通俗地表述为：在软件中所有引用基类的地方必须能透明地使用其子类的对象。 (5)依赖倒转原则要求高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 (6)接口隔离原则要求客户端不应该依赖那些它不需要的接口。 (7)合成复用原则要求优先使用对象组合，而不是继承来达到复用的目的。 (8)迪米特法则要求每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model源码分析（下）]]></title>
    <url>%2F2020%2F06%2F11%2FLaravel-Database-Eloquent-Model%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 获取模型get函数 1234567891011121314151617public function get($columns = ['*'])&#123; $builder = $this-&gt;applyScopes(); if (count($models = $builder-&gt;getModels($columns)) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $builder-&gt;getModel()-&gt;newCollection($models);&#125;public function getModels($columns = ['*'])&#123; return $this-&gt;model-&gt;hydrate( $this-&gt;query-&gt;get($columns)-&gt;all() )-&gt;all();&#125; get 函数会将QueryBuilder所获取的数据进一步包装hydrate。hydrate函数会将数据库取回来的数据打包成数据库模型对象EloquentModel，如果可以获取到数据，还会利用函数eagerLoadRelations来预加载关系模型。12345678public function hydrate(array $items)&#123; $instance = $this-&gt;newModelInstance(); return $instance-&gt;newCollection(array_map(function ($item) use ($instance) &#123; return $instance-&gt;newFromBuilder($item); &#125;, $items));&#125; newModelInstance函数创建了一个新的数据库模型对象，重要的是这个函数为新的数据库模型对象赋予了connection：123456public function newModelInstance($attributes = [])&#123; return $this-&gt;model-&gt;newInstance($attributes)-&gt;setConnection( $this-&gt;query-&gt;getConnection()-&gt;getName() );&#125; newFromBuilder函数会将所有数据库数据存入另一个新的Eloquent Model的attributes中：123456789101112public function newFromBuilder($attributes = [], $connection = null)&#123; $model = $this-&gt;newInstance([], true); $model-&gt;setRawAttributes((array) $attributes, true); $model-&gt;setConnection($connection ?: $this-&gt;getConnectionName()); $model-&gt;fireModelEvent('retrieved', false); return $model;&#125; newInstance函数专用于创建新的数据库对象模型：123456789101112public function newInstance($attributes = [], $exists = false)&#123; $model = new static((array) $attributes); $model-&gt;exists = $exists; $model-&gt;setConnection( $this-&gt;getConnectionName() ); return $model;&#125; 值得注意的是newInstance将exist设置为true，意味着当前这个数据库模型对象是从数据库中获取而来，并非是手动新建的，这个exist为真，我们才能对这个数据库对象进行update。 setRawAttributes函数为新的数据库对象赋予属性值，并且进行sync，标志着对象的原始状态：1234567891011121314151617public function setRawAttributes(array $attributes, $sync = false)&#123; $this-&gt;attributes = $attributes; if ($sync) &#123; $this-&gt;syncOriginal(); &#125; return $this;&#125;public function syncOriginal()&#123; $this-&gt;original = $this-&gt;attributes; return $this;&#125; 这个原始状态的记录十分重要，原因是save函数就是利用原始值original与属性值attributes 的差异来决定更新的字段。 find函数 find函数用于利用主键id来查询数据，find函数也可以传入数组，查询多个数据1234567891011121314151617public function find($id, $columns = ['*'])&#123; if (is_array($id) || $id instanceof Arrayable) &#123; return $this-&gt;findMany($id, $columns); &#125; return $this-&gt;whereKey($id)-&gt;first($columns);&#125;public function findMany($ids, $columns = ['*'])&#123; if (empty($ids)) &#123; return $this-&gt;model-&gt;newCollection(); &#125; return $this-&gt;whereKey($ids)-&gt;get($columns);&#125; findOrFail laravel 还提供 findOrFail 函数，一般用于 controller，在未找到记录的时候会抛出异常。12345678910111213141516public function findOrFail($id, $columns = ['*'])&#123; $result = $this-&gt;find($id, $columns); if (is_array($id)) &#123; if (count($result) == count(array_unique($id))) &#123; return $result; &#125; &#125; elseif (! is_null($result)) &#123; return $result; &#125; throw (new ModelNotFoundException)-&gt;setModel( get_class($this-&gt;model), $id );&#125; 其他查询与数据获取方法 所用 Query Builder支持的查询方法，例如select、selectSub、whereDate、whereBetween等等，都可以直接对Eloquent Model直接使用，程序会通过魔术方法调用Query Builder的相关方法：1234567891011121314151617protected $passthru = [ 'insert', 'insertGetId', 'getBindings', 'toSql', 'exists', 'count', 'min', 'max', 'avg', 'sum', 'getConnection',];public function __call($method, $parameters)&#123; ... if (in_array($method, $this-&gt;passthru)) &#123; return $this-&gt;toBase()-&gt;&#123;$method&#125;(...$parameters); &#125; $this-&gt;query-&gt;&#123;$method&#125;(...$parameters); return $this;&#125; passthru 中的各个函数在调用前需要加载查询作用域，原因是这些操作基本上是aggregate的，需要添加搜索条件才能更加符合预期：12345678910111213141516171819202122232425262728293031323334353637383940public function toBase()&#123; return $this-&gt;applyScopes()-&gt;getQuery();&#125;``` 添加和更新模型save 函数在Eloquent Model中，添加与更新模型可以统一用save函数。在添加模型的时候需要事先为model属性赋值，可以单个手动赋值，也可以批量赋值。在更新模型的时候，需要事先从数据库中取出模型，然后修改模型属性，最后执行 save 更新操作。官方文档：添加和更新模型```phppublic function save(array $options = [])&#123; $query = $this-&gt;newQueryWithoutScopes(); if ($this-&gt;fireModelEvent('saving') === false) &#123; return false; &#125; if ($this-&gt;exists) &#123; $saved = $this-&gt;isDirty() ? $this-&gt;performUpdate($query) : true; &#125; else &#123; $saved = $this-&gt;performInsert($query); if (! $this-&gt;getConnectionName() &amp;&amp; $connection = $query-&gt;getConnection()) &#123; $this-&gt;setConnection($connection-&gt;getName()); &#125; &#125; if ($saved) &#123; $this-&gt;finishSave($options); &#125; return $saved;&#125; save函数不会加载全局作用域，原因是凡是利用save函数进行的插入或者更新的操作都不会存在where条件，仅仅利用自身的主键属性来进行更新。如果需要where条件可以使用query\builder的update函数，我们在下面会详细介绍：1234567891011121314151617public function newQueryWithoutScopes()&#123; $builder = $this-&gt;newEloquentBuilder($this-&gt;newBaseQueryBuilder()); return $builder-&gt;setModel($this) -&gt;with($this-&gt;with) -&gt;withCount($this-&gt;withCount);&#125;protected function newBaseQueryBuilder()&#123; $connection = $this-&gt;getConnection(); return new QueryBuilder( $connection, $connection-&gt;getQueryGrammar(), $connection-&gt;getPostProcessor() );&#125; newQueryWithoutScopes函数创建新的没有任何其他条件的Eloquent\builder类，而Eloquent\builder 类需要 Query\builder 类作为底层查询构造器。 performUpdate函数 如果当前的数据库模型对象是从数据库中取出的，也就是直接或间接的调用get()函数从数据库中获取到的数据库对象，那么其 exists 必然是 true12345678910111213141516171819public function isDirty($attributes = null)&#123; return $this-&gt;hasChanges( $this-&gt;getDirty(), is_array($attributes) ? $attributes : func_get_args() );&#125;public function getDirty()&#123; $dirty = []; foreach ($this-&gt;getAttributes() as $key =&gt; $value) &#123; if (! $this-&gt;originalIsEquivalent($key, $value)) &#123; $dirty[$key] = $value; &#125; &#125; return $dirty;&#125; getDirty函数可以获取所有与原始值不同的属性值，也就是需要更新的数据库字段。关键函数在于originalIsEquivalent：1234567891011121314151617181920212223protected function originalIsEquivalent($key, $current)&#123; if (! array_key_exists($key, $this-&gt;original)) &#123; return false; &#125; $original = $this-&gt;getOriginal($key); if ($current === $original) &#123; return true; &#125; elseif (is_null($current)) &#123; return false; &#125; elseif ($this-&gt;isDateAttribute($key)) &#123; return $this-&gt;fromDateTime($current) === $this-&gt;fromDateTime($original); &#125; elseif ($this-&gt;hasCast($key)) &#123; return $this-&gt;castAttribute($key, $current) === $this-&gt;castAttribute($key, $original); &#125; return is_numeric($current) &amp;&amp; is_numeric($original) &amp;&amp; strcmp((string) $current, (string) $original) === 0;&#125; 可以看到，对于数据库可以转化的属性都要先进行转化，然后再开始对比。比较出的结果，就是我们需要 update 的字段。 执行更新的时候，除了 getDirty 函数获得的待更新字段，还会有 UPDATED_AT 这个字段：1234567891011121314151617181920212223242526272829303132333435protected function performUpdate(Builder $query)&#123; if ($this-&gt;fireModelEvent('updating') === false) &#123; return false; &#125; if ($this-&gt;usesTimestamps()) &#123; $this-&gt;updateTimestamps(); &#125; $dirty = $this-&gt;getDirty(); if (count($dirty) &gt; 0) &#123; $this-&gt;setKeysForSaveQuery($query)-&gt;update($dirty); $this-&gt;fireModelEvent('updated', false); $this-&gt;syncChanges(); &#125; return true;&#125;protected function updateTimestamps()&#123; $time = $this-&gt;freshTimestamp(); if (! is_null(static::UPDATED_AT) &amp;&amp; ! $this-&gt;isDirty(static::UPDATED_AT)) &#123; $this-&gt;setUpdatedAt($time); &#125; if (! $this-&gt;exists &amp;&amp; ! $this-&gt;isDirty(static::CREATED_AT)) &#123; $this-&gt;setCreatedAt($time); &#125;&#125; 执行更新的时候，where 条件只有一个，那就是主键 id：1234567891011121314151617protected function setKeysForSaveQuery(Builder $query)&#123; $query-&gt;where($this-&gt;getKeyName(), '=', $this-&gt;getKeyForSaveQuery()); return $query;&#125;protected function getKeyForSaveQuery()&#123; return $this-&gt;original[$this-&gt;getKeyName()] ?? $this-&gt;getKey();&#125;public function getKey()&#123; return $this-&gt;getAttribute($this-&gt;getKeyName());&#125; 最后会调用 EloquentBuilder 的 update 函数：12345678910111213141516171819202122232425262728public function update(array $values)&#123; return $this-&gt;toBase()-&gt;update($this-&gt;addUpdatedAtColumn($values));&#125;protected function addUpdatedAtColumn(array $values)&#123; if (! $this-&gt;model-&gt;usesTimestamps()) &#123; return $values; &#125; return Arr::add( $values, $this-&gt;model-&gt;getUpdatedAtColumn(), $this-&gt;model-&gt;freshTimestampString() );&#125;public function freshTimestampString()&#123; return $this-&gt;fromDateTime($this-&gt;freshTimestamp());&#125;public function fromDateTime($value)&#123; return is_null($value) ? $value : $this-&gt;asDateTime($value)-&gt;format( $this-&gt;getDateFormat() );&#125; performInsert 关于数据库对象的插入，如果数据库的主键被设置为increment，也就是自增的话，程序会调用 insertAndSetId，这个时候不需要给数据库模型对象手动赋值主键id。若果数据库的主键并不支持自增，那么就需要在插入前，为数据库对象的主键 id 赋值，否则数据库会报错。12345678910111213141516171819202122232425262728293031protected function performInsert(Builder $query)&#123; if ($this-&gt;fireModelEvent('creating') === false) &#123; return false; &#125; if ($this-&gt;usesTimestamps()) &#123; $this-&gt;updateTimestamps(); &#125; $attributes = $this-&gt;attributes; if ($this-&gt;getIncrementing()) &#123; $this-&gt;insertAndSetId($query, $attributes); &#125; else &#123; if (empty($attributes)) &#123; return true; &#125; $query-&gt;insert($attributes); &#125; $this-&gt;exists = true; $this-&gt;wasRecentlyCreated = true; $this-&gt;fireModelEvent('created', false); return true;&#125; laravel 默认数据库的主键支持自增属性，程序调用的也是函数 insertAndSetId 函数：123456protected function insertAndSetId(Builder $query, $attributes)&#123; $id = $query-&gt;insertGetId($attributes, $keyName = $this-&gt;getKeyName()); $this-&gt;setAttribute($keyName, $id);&#125; 插入后，会将插入后得到的主键 id 返回，并赋值到模型的属性当中。 如果数据库主键不支持自增，那么我们在数据库类中要设置：1public $incrementing = false; 每次进行插入数据的时候，需要手动给主键赋值。 update 函数save 函数仅仅支持手动的属性赋值，无法批量赋值。laravel 的 Eloquent Model 还有一个函数: update 支持批量属性赋值。有意思的是，Eloquent Builder 也有函数 update，那个是上一小节提到的 performUpdate 所调用的函数。 两个 update 功能一致，只是 Model 的 update 函数比较适用于更新从数据库取回的数据库对象：123$flight = App\Flight::find(1);$flight-&gt;update(['name' =&gt; 'New Flight Name','desc' =&gt; 'test']); 而 Builder 的 update 适用于多查询条件下的更新：12345678910111213141516App\Flight::where('active', 1) -&gt;where('destination', 'San Diego') -&gt;update(['delayed' =&gt; 1]);``` 无论哪一种，都会自动更新 updated_at 字段。Model 的 update 函数借助 fill 函数与 save 函数：```phppublic function update(array $attributes = [], array $options = [])&#123; if (! $this-&gt;exists) &#123; return false; &#125; return $this-&gt;fill($attributes)-&gt;save($options);&#125; make 函数同样的，save 的插入也仅仅支持手动属性赋值，如果想实现批量属性赋值的插入可以使用 make 函数：123$model = App\Flight::make(['name' =&gt; 'New Flight Name','desc' =&gt; 'test']);$model-&gt;save(); make 函数实际上仅仅是新建了一个 Eloquent Model，并批量赋予属性值：1234567891011public function make(array $attributes = [])&#123; return $this-&gt;newModelInstance($attributes);&#125;public function newModelInstance($attributes = [])&#123; return $this-&gt;model-&gt;newInstance($attributes)-&gt;setConnection( $this-&gt;query-&gt;getConnection()-&gt;getName() );&#125; create 函数如果想要一步到位，批量赋值属性与插入一起操作，可以使用 create 函数：1App\Flight::create(['name' =&gt; 'New Flight Name','desc' =&gt; 'test']); 相比较 make 函数，create 函数更进一步调用了 save 函数：123456public function create(array $attributes = [])&#123; return tap($this-&gt;newModelInstance($attributes), function ($instance) &#123; $instance-&gt;save(); &#125;);&#125; 实际上，属性值是否可以批量赋值需要受 fillable 或 guarded 来控制，如果我们想要强制批量赋值可以使用 forceCreate：123456public function forceCreate(array $attributes)&#123; return $this-&gt;model-&gt;unguarded(function () use ($attributes) &#123; return $this-&gt;newModelInstance()-&gt;create($attributes); &#125;);&#125; findOrNew 函数laravel 提供一种主键查询或者新建数据库对象的函数：findOrNew：12345678public function findOrNew($id, $columns = ['*'])&#123; if (! is_null($model = $this-&gt;find($id, $columns))) &#123; return $model; &#125; return $this-&gt;newModelInstance();&#125; 值得注意的是，当查询失败的时候，会返回一个全新的数据库对象，不含有任何 attributes。 firstOrNew 函数laravel 提供一种自定义查询或者新建数据库对象的函数：firstOrNew：12345678public function firstOrNew(array $attributes, array $values = [])&#123; if (! is_null($instance = $this-&gt;where($attributes)-&gt;first())) &#123; return $instance; &#125; return $this-&gt;newModelInstance($attributes + $values);&#125; 值得注意的是，如果查询失败，会返回一个含有 attributes 和 values 两者合并的属性的数据库对象。 firstOrCreate 函数类似于 firstOrNew 函数，firstOrCreate 函数也用于自定义查询或者新建数据库对象，不同的是，firstOrCreate 函数还进一步对数据进行了插入操作：12345678910public function firstOrCreate(array $attributes, array $values = [])&#123; if (! is_null($instance = $this-&gt;where($attributes)-&gt;first())) &#123; return $instance; &#125; return tap($this-&gt;newModelInstance($attributes + $values), function ($instance) &#123; $instance-&gt;save(); &#125;);&#125; updateOrCreate 函数在 firstOrCreate 函数基础上，除了对数据进行查询，还会对查询成功的数据利用 value 进行更新：123456public function updateOrCreate(array $attributes, array $values = [])&#123; return tap($this-&gt;firstOrNew($attributes), function ($instance) use ($values) &#123; $instance-&gt;fill($values)-&gt;save(); &#125;);&#125; firstOr 函数如果想要自定义查找失败后的操作，可以使用 firstOr 函数，该函数可以传入闭包函数，处理找不到数据的情况：1234567891011121314public function firstOr($columns = ['*'], Closure $callback = null)&#123; if ($columns instanceof Closure) &#123; $callback = $columns; $columns = ['*']; &#125; if (! is_null($model = $this-&gt;first($columns))) &#123; return $model; &#125; return call_user_func($callback);&#125; 删除模型删除模型也会分为两种，一种是针对 Eloquent Model 的删除，这种删除必须是从数据库中取出的对象。还有一种是 Eloquent Builder 的删除，这种删除一般会带有多个查询条件。我们这一小节主要讲 model 的删除：12345678910111213141516171819202122public function delete()&#123; if (is_null($this-&gt;getKeyName())) &#123; throw new Exception('No primary key defined on model.'); &#125; if (! $this-&gt;exists) &#123; return; &#125; if ($this-&gt;fireModelEvent('deleting') === false) &#123; return false; &#125; $this-&gt;touchOwners(); $this-&gt;performDeleteOnModel(); $this-&gt;fireModelEvent('deleted', false); return true;&#125; 删除模型时，模型对象必然要有主键。performDeleteOnModel 函数执行具体的删除操作：12345678910111213protected function performDeleteOnModel()&#123; $this-&gt;setKeysForSaveQuery($this-&gt;newQueryWithoutScopes())-&gt;delete(); $this-&gt;exists = false;&#125;protected function setKeysForSaveQuery(Builder $query)&#123; $query-&gt;where($this-&gt;getKeyName(), '=', $this-&gt;getKeyForSaveQuery()); return $query;&#125; 所以实际上，Model 调用的也是 builder 的 delete 函数。 软删除如果想要使用软删除，需要使用 Illuminate\Database\Eloquent\SoftDeletes 这个 trait。并且需要定义软删除字段，默认为 deleted_at，将软删除字段放入 dates 中，具体用法可参考官方文档: 软删除1234567891011class Flight extends Model&#123; use SoftDeletes; /** * 需要被转换成日期的属性。 * * @var array */ protected $dates = ['deleted_at'];&#125; 我们先看看这个 trait：12345678trait SoftDeletes &#123; public static function bootSoftDeletes() &#123; static::addGlobalScope(new SoftDeletingScope); &#125;&#125; 如果使用了软删除，在 model 的启动过程中，就会启动软删除的这个函数。可以看出来，软删除是需要查询作用域来合作发挥作用的。我们看看这个 SoftDeletingScope :123456789101112131415161718192021222324class SoftDeletingScope implements Scope&#123; protected $extensions = ['Restore', 'WithTrashed', 'WithoutTrashed', 'OnlyTrashed']; public function apply(Builder $builder, Model $model) &#123; $builder-&gt;whereNull($model-&gt;getQualifiedDeletedAtColumn()); &#125; public function extend(Builder $builder) &#123; foreach ($this-&gt;extensions as $extension) &#123; $this-&gt;&#123;"add&#123;$extension&#125;"&#125;($builder); &#125; $builder-&gt;onDelete(function (Builder $builder) &#123; $column = $this-&gt;getDeletedAtColumn($builder); return $builder-&gt;update([ $column =&gt; $builder-&gt;getModel()-&gt;freshTimestampString(), ]); &#125;); &#125;&#125; apply 函数是加载全局域调用的函数，每次进行查询的时候，调用 get 函数就会自动加载这个函数，whereNull 这个查询条件会被加载到具体的 where 条件中。deleted_at 字段一般被设置为 null，在执行软删除的时候，该字段会被赋予时间格式的值，标志着被删除的时间。 在加载全局作用域的时候，还会调用 extend 函数，extend 函数为 model 添加了四个函数： WithTrashed123456 protected function addWithTrashed(Builder $builder)&#123; $builder-&gt;macro('withTrashed', function (Builder $builder) &#123; return $builder-&gt;withoutGlobalScope($this); &#125;);&#125; withTrashed 函数取消了软删除的全局作用域，这样我们查询数据的时候就会查询到正常数据和被软删除的数据。 withoutTrashed123456789101112protected function addWithoutTrashed(Builder $builder)&#123; $builder-&gt;macro('withoutTrashed', function (Builder $builder) &#123; $model = $builder-&gt;getModel(); $builder-&gt;withoutGlobalScope($this)-&gt;whereNull( $model-&gt;getQualifiedDeletedAtColumn() ); return $builder; &#125;);&#125; withTrashed 函数着重强调了不要获取软删除的数据。 onlyTrashed123456789101112protected function addOnlyTrashed(Builder $builder)&#123; $builder-&gt;macro('onlyTrashed', function (Builder $builder) &#123; $model = $builder-&gt;getModel(); $builder-&gt;withoutGlobalScope($this)-&gt;whereNotNull( $model-&gt;getQualifiedDeletedAtColumn() ); return $builder; &#125;);&#125; 如果只想获取被软删除的数据，可以使用这个函数 onlyTrashed，可以看到，它使用了 whereNotNull。 restore12345678protected function addRestore(Builder $builder)&#123; $builder-&gt;macro('restore', function (Builder $builder) &#123; $builder-&gt;withTrashed(); return $builder-&gt;update([$builder-&gt;getModel()-&gt;getDeletedAtColumn() =&gt; null]); &#125;);&#125; 如果想要恢复被删除的数据，还可以使用 restore，重新将 deleted_at 数据恢复为 null。 performDeleteOnModelSoftDeletes 这个 trait 会重载 performDeleteOnModel 函数，它将不会调用 Eloquent Builder 的 delete 方法，而是采用更新操作：123456789101112131415161718192021222324252627protected function performDeleteOnModel()&#123; if ($this-&gt;forceDeleting) &#123; return $this-&gt;newQueryWithoutScopes()-&gt;where($this-&gt;getKeyName(), $this-&gt;getKey())-&gt;forceDelete(); &#125; return $this-&gt;runSoftDelete();&#125;protected function runSoftDelete()&#123; $query = $this-&gt;newQueryWithoutScopes()-&gt;where($this-&gt;getKeyName(), $this-&gt;getKey()); $time = $this-&gt;freshTimestamp(); $columns = [$this-&gt;getDeletedAtColumn() =&gt; $this-&gt;fromDateTime($time)]; $this-&gt;&#123;$this-&gt;getDeletedAtColumn()&#125; = $time; if ($this-&gt;timestamps) &#123; $this-&gt;&#123;$this-&gt;getUpdatedAtColumn()&#125; = $time; $columns[$this-&gt;getUpdatedAtColumn()] = $this-&gt;fromDateTime($time); &#125; $query-&gt;update($columns);&#125; 删除操作不仅更新了 deleted_at，还更新了 updated_at 字段。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model源码分析（上）]]></title>
    <url>%2F2020%2F06%2F11%2FLaravel-Database-Eloquent-Model%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言前面几个博客向大家介绍了查询构造器的原理与源码，然而查询构造器更多是为Eloquent Model服务的，我们对数据库操作更加方便的是使用Eloquent Model。本篇文章将会大家介绍Model的一些特性原理。 Eloquent Model修改器简介当你在Eloquent模型实例中获取或设置某些属性值的时候，访问器和修改器允许你对Eloquent属性值进行格式化。例如，你可能需要使用Laravel加密器来加密保存在数据库中的值，而在使用Eloquent模型访问该属性的时候自动进行解密其值。 除了自定义访问器和修改器外，Eloquent也会自动将日期字段类型转换为Carbon实例，或将文本类型转换为JSON。 访问器&amp;修改器定义一个访问器若要定义一个访问器，则需在模型上创建一个getFooAttribute方法，要访问的Foo字段需使用「驼峰式」命名。在这个示例中，我们将为first_name属性定义一个访问器。当Eloquent尝试获取first_name属性时，将自动调用此访问器：12345678910111213141516171819&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 获取用户的姓名. * * @param string $value * @return string */ public function getFirstNameAttribute($value) &#123; return ucfirst($value); &#125;&#125; 如你所见，字段的原始值被传递到访问器中，允许你对它进行处理并返回结果。如果想获取被修改后的值，你可以在模型实例上访问first_name属性：123$user = App\User::find(1);$firstName = $user-&gt;first_name; 当然，你也可以通过已有的属性值，使用访问器返回新的计算值：123456789/** * 获取用户的姓名. * * @return string */public function getFullNameAttribute()&#123; return "&#123;$this-&gt;first_name&#125; &#123;$this-&gt;last_name&#125;";&#125; Tip：如果你需要将这些计算值添加到模型的数组/JSON中，你需要追加它们。 定义一个修改器若要定义一个修改器，则需在模型上面定义setFooAttribute方法。要访问的Foo字段使用「驼峰式」命名。让我们再来定义一个first_name属性的修改器。当我们尝试在模型上设置first_name属性值时，该修改器将被自动调用：12345678910111213141516171819&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 设置用户的姓名. * * @param string $value * @return void */ public function setFirstNameAttribute($value) &#123; $this-&gt;attributes['first_name'] = strtolower($value); &#125;&#125; 修改器会获取属性已经被设置的值，允许你修改并且将其值设置到Eloquent模型内部的$attributes属性上。举个例子，如果我们尝试将first_name属性的值设置为Sally：123$user = App\User::find(1);$user-&gt;first_name = 'Sally'; 在这个例子中，setFirstNameAttribute方法在调用的时候接受Sally这个值作为参数。接着修改器会应用strtolower函数并将处理的结果设置到内部的$attributes数组。 日期转换器默认情况下，Eloquent会将created_at和updated_at字段转换为Carbon实例，它继承了PHP原生的DateTime类并提供了各种有用的方法。你可以通过设置模型的$dates属性来添加其他日期属性：1234567891011121314151617&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 应该转换为日期格式的属性. * * @var array */ protected $dates = [ 'seen_at', ];&#125; Tip：你可以通过将模型的公有属性$timestamps值设置为false来禁用默认的created_at和updated_at时间戳。 当某个字段是日期格式时，你可以将值设置为一个UNIX时间戳，日期时间（Y-m-d）字符串，或者DateTime/Carbon实例。日期值会被正确格式化并保存到你的数据库中：12345$user = App\User::find(1);$user-&gt;deleted_at = now();$user-&gt;save(); 就如上面所说，当获取到的属性包含在$dates属性中时，都会自动转换为Carbon实例，允许你在属性上使用任意的Carbon方法：123$user = App\User::find(1);return $user-&gt;deleted_at-&gt;getTimestamp(); 日期格式 默认情况下，时间戳都将以’Y-m-d Hs’形式格式化。如果你需要自定义时间戳格式，可在模型中设置$dateFormat属性。这个属性决定了日期属性将以何种形式保存在数据库中，以及当模型序列化成数组或JSON时的格式：123456789101112131415&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class Flight extends Model&#123; /** * 模型日期字段的保存格式. * * @var string */ protected $dateFormat = 'U';&#125; 属性类型转换 模型中的$casts属性提供了一个便利的方法来将属性转换为常见的数据类型。$casts属性应是一个数组，且数组的键是那些需要被转换的属性名称，值则是你希望转换的数据类型。支持转换的数据类型有：integer，real，float，double，decimal:\，string，boolean，object，array，collection，date，datetime和timestamp。当需要转换为decimal类型时，你需要定义小数位的个数，如：decimal:2。 示例，让我们把以整数（0或1）形式存储在数据库中的is_admin属性转成布尔值：1234567891011121314151617&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 这个属性应该被转换为原生类型. * * @var array */ protected $casts = [ 'is_admin' =&gt; 'boolean', ];&#125; 现在当你访问is_admin属性时，虽然保存在数据库里的值是一个整数类型，但是返回值总是会被转换成布尔值类型：12345$user = App\User::find(1);if ($user-&gt;is_admin) &#123; //&#125; 数组&amp;JSON转换 当你在数据库存储序列化的JSON的数据时，array类型的转换非常有用。比如：如果你的数据库具有被序列化为JSON的JSON或TEXT字段类型，并且在Eloquent模型中加入了array类型转换，那么当你访问的时候就会自动被转换为PHP数组：1234567891011121314151617181920212223242526272829 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model &#123; /** * 这个属性应该被转换为原生类型. * * @var array */ protected $casts = [ 'options' =&gt; 'array', ]; &#125;``` 一旦定义了转换，你访问options属性时他会自动从JSON类型反序列化为PHP数组。当你设置了options属性的值时，给定的数组也会自动序列化为JSON类型存储：```php $user = App\User::find(1); $options = $user-&gt;options; $options['key'] = 'value'; $user-&gt;options = $options; $user-&gt;save(); Date转换 当使用date或datetime属性时，可以指定日期的格式。这种格式会被用在模型序列化为数组或者JSON：12345678/** * 这个属性应该被转化为原生类型. * * @var array */protected $casts = [ 'created_at' =&gt; 'datetime:Y-m-d',]; 源码当我们在Eloquent模型实例中设置某些属性值的时候，修改器允许对Eloquent属性值进行格式化。 下面先看看修改器的原理：1234567891011121314151617181920212223242526272829public function offsetSet($offset, $value)&#123; $this-&gt;setAttribute($offset, $value);&#125;public function setAttribute($key, $value)&#123; if ($this-&gt;hasSetMutator($key)) &#123; $method = 'set'.Str::studly($key).'Attribute'; return $this-&gt;&#123;$method&#125;($value); &#125; elseif ($value &amp;&amp; $this-&gt;isDateAttribute($key)) &#123; $value = $this-&gt;fromDateTime($value); &#125; if ($this-&gt;isJsonCastable($key) &amp;&amp; ! is_null($value)) &#123; $value = $this-&gt;castAttributeAsJson($key, $value); &#125; if (Str::contains($key, '-&gt;')) &#123; return $this-&gt;fillJsonAttribute($key, $value); &#125; $this-&gt;attributes[$key] = $value; return $this;&#125; 自定义修改器 当我们为model的成员变量赋值的时候，就会调用offsetSet函数，进而运行setAttribute函数，在这个函数中第一个检查的就是是否存在预处理函数：1234public function hasSetMutator($key)&#123; return method_exists($this, 'set'.Str::studly($key).'Attribute');&#125; 如果存在该函数，就会直接调用自定义修改器。 日期转换器 接着如果没有自定义修改器的话，还会检查当前更新的成员变量是否是日期属性：12345678910111213141516171819protected function isDateAttribute($key)&#123; return in_array($key, $this-&gt;getDates()) || $this-&gt;isDateCastable($key);&#125;public function getDates()&#123; $defaults = [static::CREATED_AT, static::UPDATED_AT]; return $this-&gt;usesTimestamps() ? array_unique(array_merge($this-&gt;dates, $defaults)) : $this-&gt;dates;&#125;protected function isDateCastable($key)&#123; return $this-&gt;hasCast($key, ['date', 'datetime']);&#125; 字段的时间属性有两种设置方法，一种是设置$dates属性：1protected $dates = ['date_attr']; 还有一种方法是设置 cast 数组：1protected $casts = ['date_attr' =&gt; 'date']; 只要是时间属性的字段，无论是什么类型的值，Laravel都会自动将其转化为数据库的时间格式。数据库的时间格式设置是dateFormat成员变量，不设置的时候，默认的时间格式为’Y-m-d H:i:s’:123protected $dateFormat = ['U'];protected $dateFormat = ['Y-m-d H:i:s']; 当数据库对应的字段是时间类型时，为其赋值就可以非常灵活。我们可以赋值Carbon类型、DateTime类型、数字类型、字符串等等：12345678910111213141516171819202122232425262728293031public function fromDateTime($value)&#123; return is_null($value) ? $value : $this-&gt;asDateTime($value)-&gt;format( $this-&gt;getDateFormat() );&#125;protected function asDateTime($value)&#123; if ($value instanceof Carbon) &#123; return $value; &#125; if ($value instanceof DateTimeInterface) &#123; return new Carbon( $value-&gt;format('Y-m-d H:i:s.u'), $value-&gt;getTimezone() ); &#125; if (is_numeric($value)) &#123; return Carbon::createFromTimestamp($value); &#125; if ($this-&gt;isStandardDateFormat($value)) &#123; return Carbon::createFromFormat('Y-m-d', $value)-&gt;startOfDay(); &#125; return Carbon::createFromFormat( $this-&gt;getDateFormat(), $value );&#125; json转换器 接下来，如果该变量被设置为array、json等属性，那么其将会转化为json类型。123456789protected function isJsonCastable($key)&#123; return $this-&gt;hasCast($key, ['array', 'json', 'object', 'collection']);&#125;protected function asJson($value)&#123; return json_encode($value);&#125; Eloquent Model 访问器 相比较修改器来说，访问器的适用情景会更加多。例如，我们经常把一些关于类型的字段设置为 1、2、3等等，例如用户数据表中用户性别字段，1代表男，2代表女，很多时候我们取出这些值之后必然要经过转换，然后再显示出来。这时候就需要定义访问器。 访问器的源码：1234567891011121314151617public function getAttribute($key)&#123; if (! $key) &#123; return; &#125; if (array_key_exists($key, $this-&gt;attributes) || $this-&gt;hasGetMutator($key)) &#123; return $this-&gt;getAttributeValue($key); &#125; if (method_exists(self::class, $key)) &#123; return; &#125; return $this-&gt;getRelationValue($key);&#125; 可以看到，当我们访问数据库对象的成员变量的时候，大致可以分为两类：属性值与关系对象。关系对象我们以后再详细来说，本文中先说关于属性的访问。12345678910111213141516171819public function getAttributeValue($key)&#123; $value = $this-&gt;getAttributeFromArray($key); if ($this-&gt;hasGetMutator($key)) &#123; return $this-&gt;mutateAttribute($key, $value); &#125; if ($this-&gt;hasCast($key)) &#123; return $this-&gt;castAttribute($key, $value); &#125; if (in_array($key, $this-&gt;getDates()) &amp;&amp; ! is_null($value)) &#123; return $this-&gt;asDateTime($value); &#125; return $value;&#125; 与修改器类似，访问器也由三部分构成：自定义访问器、日期访问器、类型访问器。 获取原始值 访问器的第一步就是从成员变量attributes中获取原始的字段值，一般指的是存在数据库的值。有的时候，我们要取的属性并不在attributes中，这时候就会返回null。123456protected function getAttributeFromArray($key)&#123; if (isset($this-&gt;attributes[$key])) &#123; return $this-&gt;attributes[$key]; &#125;&#125; 自定义访问器 如果定义了访问器，那么就会调用访问器，获取返回值：123456789public function hasGetMutator($key)&#123; return method_exists($this, 'get'.Str::studly($key).'Attribute');&#125;protected function mutateAttribute($key, $value)&#123; return $this-&gt;&#123;'get'.Str::studly($key).'Attribute'&#125;($value);&#125; 类型转换 若我们在成员变量 $casts 数组中为属性定义了类型转换，那么就要进行类型转换：123456789101112131415161718192021222324252627282930313233343536373839404142434445public function hasCast($key, $types = null)&#123; if (array_key_exists($key, $this-&gt;getCasts())) &#123; return $types ? in_array($this-&gt;getCastType($key), (array) $types, true) : true; &#125; return false;&#125;protected function castAttribute($key, $value)&#123; if (is_null($value)) &#123; return $value; &#125; switch ($this-&gt;getCastType($key)) &#123; case 'int': case 'integer': return (int) $value; case 'real': case 'float': case 'double': return (float) $value; case 'string': return (string) $value; case 'bool': case 'boolean': return (bool) $value; case 'object': return $this-&gt;fromJson($value, true); case 'array': case 'json': return $this-&gt;fromJson($value); case 'collection': return new BaseCollection($this-&gt;fromJson($value)); case 'date': return $this-&gt;asDate($value); case 'datetime': return $this-&gt;asDateTime($value); case 'timestamp': return $this-&gt;asTimestamp($value); default: return $value; &#125;&#125; 日期转换 若当前属性是CREATED_AT、UPDATED_AT或者被存入成员变量dates中，那么就要进行日期转换。日期转换函数asDateTime可以查看上一节中的内容。 Eloquent Model数组转化 在使用数据库对象中，我们经常使用toArray函数，它可以将从数据库中取出的所有属性和关系模型转化为数组：1234public function toArray()&#123; return array_merge($this-&gt;attributesToArray(), $this-&gt;relationsToArray());&#125; 本文中只介绍属性转化为数组的部分：1234567891011121314151617181920public function attributesToArray()&#123; $attributes = $this-&gt;addDateAttributesToArray( $attributes = $this-&gt;getArrayableAttributes() ); $attributes = $this-&gt;addMutatedAttributesToArray( $attributes, $mutatedAttributes = $this-&gt;getMutatedAttributes() ); $attributes = $this-&gt;addCastAttributesToArray( $attributes, $mutatedAttributes ); foreach ($this-&gt;getArrayableAppends() as $key) &#123; $attributes[$key] = $this-&gt;mutateAttributeForArray($key, null); &#125; return $attributes;&#125; 与访问器与修改器类似，需要转为数组的元素有日期类型、自定义访问器、类型转换，我们接下来一个个看： getArrayableAttributes 原始值获取 首先我们要从成员变量 attributes 数组中获取原始值：1234567891011121314151617protected function getArrayableAttributes()&#123; return $this-&gt;getArrayableItems($this-&gt;attributes);&#125;protected function getArrayableItems(array $values)&#123; if (count($this-&gt;getVisible()) &gt; 0) &#123; $values = array_intersect_key($values, array_flip($this-&gt;getVisible())); &#125; if (count($this-&gt;getHidden()) &gt; 0) &#123; $values = array_diff_key($values, array_flip($this-&gt;getHidden())); &#125; return $values;&#125; 我们还可以为数据库对象设置可见元素$visible与隐藏元素$hidden，这两个变量会控制toArray可转化的元素属性。 日期转换12345678910111213141516171819protected function addDateAttributesToArray(array $attributes)&#123; foreach ($this-&gt;getDates() as $key) &#123; if (! isset($attributes[$key])) &#123; continue; &#125; $attributes[$key] = $this-&gt;serializeDate( $this-&gt;asDateTime($attributes[$key]) ); &#125; return $attributes;&#125;protected function serializeDate(DateTimeInterface $date)&#123; return $date-&gt;format($this-&gt;getDateFormat());&#125; 自定义访问器转换 定义了自定义访问器的属性，会调用访问器函数来覆盖原有的属性值，首先我们需要获取所有的自定义访问器变量：123456789101112131415161718192021222324public function getMutatedAttributes()&#123; $class = static::class; if (! isset(static::$mutatorCache[$class])) &#123; static::cacheMutatedAttributes($class); &#125; return static::$mutatorCache[$class];&#125;public static function cacheMutatedAttributes($class)&#123; static::$mutatorCache[$class] = collect(static::getMutatorMethods($class))-&gt;map(function ($match) &#123; return lcfirst(static::$snakeAttributes ? Str::snake($match) : $match); &#125;)-&gt;all();&#125;protected static function getMutatorMethods($class)&#123; preg_match_all('/(?&lt;=^|;)get([^;]+?)Attribute(;|$)/', implode(';', get_class_methods($class)), $matches); return $matches[1];&#125; 可以看到，函数用get_class_methods获取类内所有的函数，并筛选出符合get…Attribute的函数，获得自定义的访问器变量，并缓存到mutatorCache中。 接着将会利用自定义访问器变量替换原始值：123456789101112131415161718192021protected function addMutatedAttributesToArray(array $attributes, array $mutatedAttributes)&#123; foreach ($mutatedAttributes as $key) &#123; if (! array_key_exists($key, $attributes)) &#123; continue; &#125; $attributes[$key] = $this-&gt;mutateAttributeForArray( $key, $attributes[$key] ); &#125; return $attributes;&#125;protected function mutateAttributeForArray($key, $value)&#123; $value = $this-&gt;mutateAttribute($key, $value); return $value instanceof Arrayable ? $value-&gt;toArray() : $value;&#125; cast 类型转换 被定义在cast数组中的变量也要进行数组转换，调用的方法和访问器相同，也是castAttribute，如果是时间类型，还要按照时间格式来转换：12345678910111213141516171819protected function addCastAttributesToArray(array $attributes, array $mutatedAttributes)&#123; foreach ($this-&gt;getCasts() as $key =&gt; $value) &#123; if (! array_key_exists($key, $attributes) || in_array($key, $mutatedAttributes)) &#123; continue; &#125; $attributes[$key] = $this-&gt;castAttribute( $key, $attributes[$key] ); if ($attributes[$key] &amp;&amp; ($value === 'date' || $value === 'datetime')) &#123; $attributes[$key] = $this-&gt;serializeDate($attributes[$key]); &#125; &#125; return $attributes;&#125; appends 额外属性添加 toArray()还会将我们定义在appends变量中的属性一起进行数组转换，但是注意被放入appends成员变量数组中的属性需要有自定义访问器函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546protected function getArrayableAppends()&#123; if (! count($this-&gt;appends)) &#123; return []; &#125; return $this-&gt;getArrayableItems( array_combine($this-&gt;appends, $this-&gt;appends) );&#125;``` ## 查询作用域查询作用域分为全局作用域与本地作用域。全局作用域不需要手动调用，由程序在每次的查询中自动加载，本地作用域需要在查询的时候进行手动调用。### 全局作用域全局作用域可以给模型的查询都添加上约束。Laravel的软删除功能就是利用此特性从数据库中获取「未删除」的模型。你可以编写你自己的全局作用域，很简单、方便的为每个模型查询都加上约束条件：**编写全局作用域**编写全局作用域很简单。定义一个实现Illuminate\Database\Eloquent\Scope接口的类，并实现apply这个方法。根据你的需求，在apply方法中加入查询的where条件：```php&lt;?phpnamespace App\Scopes;use Illuminate\Database\Eloquent\Scope;use Illuminate\Database\Eloquent\Model;use Illuminate\Database\Eloquent\Builder;class AgeScope implements Scope&#123; /** * 把约束加到Eloquent查询构造中。 * * @param \Illuminate\Database\Eloquent\Builder $builder * @param \Illuminate\Database\Eloquent\Model $model * @return void */ public function apply(Builder $builder, Model $model) &#123; $builder-&gt;where('age', '&gt;', 200); &#125;&#125; 提示：如果你需要在select语句里添加字段，应使用addSelect方法，而不是select方法。这将有效防止无意中替换现有select语句的情况。 应用全局作用域 要将全局作用域分配给模型，需要重写模型的boot方法并使用addGlobalScope方法：123456789101112131415161718192021&lt;?phpnamespace App;use App\Scopes\AgeScope;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 模型的「启动」方法 * * @return void */ protected static function boot() &#123; parent::boot(); static::addGlobalScope(new AgeScope); &#125;&#125; 添加作用域后，对User::all()的查询会生成以下SQL查询语句：1select * from `users` where `age` &gt; 200 匿名全局作用域 Eloquent同样允许使用闭包定义全局作用域，这样就不需要为一个简单的作用域而编写一个单独的类：1234567891011121314151617181920212223&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;use Illuminate\Database\Eloquent\Builder;class User extends Model&#123; /** * 模型的「启动」方法 * * @return void */ protected static function boot() &#123; parent::boot(); static::addGlobalScope('age', function (Builder $builder) &#123; $builder-&gt;where('age', '&gt;', 200); &#125;); &#125;&#125; 取消全局作用域 如果需要对当前查询取消全局作用域，需要使用withoutGlobalScope方法。该方法仅接受全局作用域类名作为它唯一的参数：1User::withoutGlobalScope(AgeScope::class)-&gt;get(); 或者，如果使用闭包定义全局作用域的话：1User::withoutGlobalScope('age')-&gt;get(); 如果你需要取消部分或者全部的全局作用域的话，需要使用withoutGlobalScopes方法：1234567// 取消所有的全局作用域...User::withoutGlobalScopes()-&gt;get();// 取消部分全局作用域...User::withoutGlobalScopes([ FirstScope::class, SecondScope::class])-&gt;get(); 我们先看看源码：123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\Database\Eloquent\Concerns;use Closure;use Illuminate\Database\Eloquent\Scope;use Illuminate\Support\Arr;use InvalidArgumentException;trait HasGlobalScopes&#123; /** * Register a new global scope on the model. * * @param \Illuminate\Database\Eloquent\Scope|\Closure|string $scope * @param \Closure|null $implementation * @return mixed * * @throws \InvalidArgumentException */ public static function addGlobalScope($scope, Closure $implementation = null) &#123; if (is_string($scope) &amp;&amp; ! is_null($implementation)) &#123; return static::$globalScopes[static::class][$scope] = $implementation; &#125; elseif ($scope instanceof Closure) &#123; return static::$globalScopes[static::class][spl_object_hash($scope)] = $scope; &#125; elseif ($scope instanceof Scope) &#123; return static::$globalScopes[static::class][get_class($scope)] = $scope; &#125; throw new InvalidArgumentException('Global scope must be an instance of Closure or Scope.'); &#125;&#125; 可以看到，全局作用域使用的是全局的静态变量globalScopes，该变量保存着所有数据库对象的全局作用域。 Eloquent\Model类并不负责查询功能，相关功能由Eloquent\Builder负责，因此每次查询都会间接调用Eloquent\Builder类。1234567891011121314151617181920abstract class Model&#123; use ForwardsCalls; /** * Handle dynamic method calls into the model. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (in_array($method, ['increment', 'decrement'])) &#123; return $this-&gt;$method(...$parameters); &#125; return $this-&gt;forwardCallTo($this-&gt;newQuery(), $method, $parameters); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace Illuminate\Support\Traits;use BadMethodCallException;use Error;trait ForwardsCalls&#123; /** * Forward a method call to the given object. * * @param mixed $object * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ protected function forwardCallTo($object, $method, $parameters) &#123; try &#123; return $object-&gt;&#123;$method&#125;(...$parameters); &#125; catch (Error | BadMethodCallException $e) &#123; $pattern = '~^Call to undefined method (?P&lt;class&gt;[^:]+)::(?P&lt;method&gt;[^\(]+)\(\)$~'; if (! preg_match($pattern, $e-&gt;getMessage(), $matches)) &#123; throw $e; &#125; if ($matches['class'] != get_class($object) || $matches['method'] != $method) &#123; throw $e; &#125; static::throwBadMethodCallException($method); &#125; &#125;&#125; 创建新的Eloquent\Builder类需要newQuery函数：1234567891011121314151617181920212223242526public function newQuery()&#123; $builder = $this-&gt;newQueryWithoutScopes(); foreach ($this-&gt;getGlobalScopes() as $identifier =&gt; $scope) &#123; $builder-&gt;withGlobalScope($identifier, $scope); &#125; return $builder;&#125;public function getGlobalScopes()&#123; return Arr::get(static::$globalScopes, static::class, []);&#125;public function withGlobalScope($identifier, $scope)&#123; $this-&gt;scopes[$identifier] = $scope; if (method_exists($scope, 'extend')) &#123; $scope-&gt;extend($this); &#125; return $this;&#125; newQuery函数为Eloquent\builder加载全局作用域，这样静态变量globalScopes的值就会被赋到Eloquent\builder的scopes成员变量中。 当我们使用get()函数获取数据库数据的时候，也需要借助魔术方法调用Illuminate\Database\Eloquent\Builder类的get函数：12345678910public function get($columns = ['*'])&#123; $builder = $this-&gt;applyScopes(); if (count($models = $builder-&gt;getModels($columns)) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $builder-&gt;getModel()-&gt;newCollection($models);&#125; 调用applyScopes函数加载所有的全局作用域：1234567891011121314151617181920212223242526public function applyScopes()&#123; if (! $this-&gt;scopes) &#123; return $this; &#125; $builder = clone $this; foreach ($this-&gt;scopes as $identifier =&gt; $scope) &#123; if (! isset($builder-&gt;scopes[$identifier])) &#123; continue; &#125; $builder-&gt;callScope(function (Builder $builder) use ($scope) &#123; if ($scope instanceof Closure) &#123; $scope($builder); &#125; if ($scope instanceof Scope) &#123; $scope-&gt;apply($builder, $this-&gt;getModel()); &#125; &#125;); &#125; return $builder;&#125; 可以看到，builder查询类会通过callScope加载全局作用域的查询条件。1234567891011121314151617protected function callScope(callable $scope, $parameters = [])&#123; array_unshift($parameters, $this); $query = $this-&gt;getQuery(); $originalWhereCount = is_null($query-&gt;wheres) ? 0 : count($query-&gt;wheres); $result = $scope(...array_values($parameters)) ?? $this; if (count((array) $query-&gt;wheres) &gt; $originalWhereCount) &#123; $this-&gt;addNewWheresWithinGroup($query, $originalWhereCount); &#125; return $result;&#125; callScope函数首先会获取更加底层的Query\builder，更新query\bulid的where条件。 addNewWheresWithinGroup这个函数很重要，它为Query\builder提供nest类型的where条件：123456789101112131415161718192021222324252627282930313233343536protected function addNewWheresWithinGroup(QueryBuilder $query, $originalWhereCount)&#123; $allWheres = $query-&gt;wheres; $query-&gt;wheres = []; $this-&gt;groupWhereSliceForScope( $query, array_slice($allWheres, 0, $originalWhereCount) ); $this-&gt;groupWhereSliceForScope( $query, array_slice($allWheres, $originalWhereCount) );&#125;protected function groupWhereSliceForScope(QueryBuilder $query, $whereSlice)&#123; $whereBooleans = collect($whereSlice)-&gt;pluck('boolean'); if ($whereBooleans-&gt;contains('or')) &#123; $query-&gt;wheres[] = $this-&gt;createNestedWhere( $whereSlice, $whereBooleans-&gt;first() ); &#125; else &#123; $query-&gt;wheres = array_merge($query-&gt;wheres, $whereSlice); &#125;&#125;protected function createNestedWhere($whereSlice, $boolean = 'and')&#123; $whereGroup = $this-&gt;getQuery()-&gt;forNestedWhere(); $whereGroup-&gt;wheres = $whereSlice; return ['type' =&gt; 'Nested', 'query' =&gt; $whereGroup, 'boolean' =&gt; $boolean];&#125; 当我们在查询作用域中，所有的查询条件连接符都是and的时候，可以直接合并到where中。 如果我们在查询作用域中或者原查询条件写下了orWhere、orWhereColumn等等连接符为or的查询条件，那么就会利用createNestedWhere函数创建nest类型的where条件。这个where条件会包含查询作用域的所有查询条件，或者原查询的所有查询条件。 本地作用域全局作用域会自动加载到所有的查询条件当中，Laravel中还有本地作用域，只有在查询时调用才会生效。 本地作用域允许定义通用的约束集合以便在应用程序中重复使用。例如，你可能经常需要获取所有「流行」的用户。要定义这样一个范围，只需要在对应的Eloquent模型方法前添加scope前缀。 作用域总是返回一个查询构造器实例： 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 只查询受欢迎的用户的作用域 * * @param \Illuminate\Database\Eloquent\Builder $query * @return \Illuminate\Database\Eloquent\Builder */ public function scopePopular($query) &#123; return $query-&gt;where('votes', '&gt;', 100); &#125; /** * 只查询active用户的作用域 * * @param \Illuminate\Database\Eloquent\Builder $query * @return \Illuminate\Database\Eloquent\Builder */ public function scopeActive($query) &#123; return $query-&gt;where('active', 1); &#125;&#125; 使用本地作用域 一旦定义了作用域，就可以在查询该模型时调用作用域方法。不过，在调用这些方法时不必包含scope前缀。甚至可以链式调用多个作用域，例如：1$users = App\User::popular()-&gt;active()-&gt;orderBy('created_at')-&gt;get(); 借助or查询运行符整合多个Eloquent模型，可能需要使用闭包回调：123$users = App\User::popular()-&gt;orWhere(function (Builder $query) &#123; $query-&gt;active();&#125;)-&gt;get(); 因为这样可能会有点麻烦，Laravel提供了「更高阶的」orWhere方法，它允许你在链式调用作用域时不使用闭包：1$users = App\User::popular()-&gt;orWhere-&gt;active()-&gt;get(); 动态作用域 有时可能地希望定义一个可以接受参数的作用域。把额外参数传递给作用域就可以达到此目的。作用域参数要放在$query参数之后：1234567891011121314151617181920&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 将查询作用域限制为仅包含给定类型的用户 * * @param \Illuminate\Database\Eloquent\Builder $query * @param mixed $type * @return \Illuminate\Database\Eloquent\Builder */ public function scopeOfType($query, $type) &#123; return $query-&gt;where('type', $type); &#125;&#125; 这样就可以在调用作用域时传递参数了：1$users = App\User::ofType('admin')-&gt;get(); 本地作用域是由魔术方法__call实现的：12345678910111213141516public function __call($method, $parameters)&#123; ... if (method_exists($this-&gt;model, $scope = 'scope'.ucfirst($method))) &#123; return $this-&gt;callScope([$this-&gt;model, $scope], $parameters); &#125; if (in_array($method, $this-&gt;passthru)) &#123; return $this-&gt;toBase()-&gt;&#123;$method&#125;(...$parameters); &#125; $this-&gt;query-&gt;&#123;$method&#125;(...$parameters); return $this;&#125; 批量调用本地作用域 Laravel还提供一个方法可以一次性调用多个本地作用域：1234567$scopes = [ 'published', 'category' =&gt; 'Laravel', 'framework' =&gt; ['Laravel', '5.3'],];(new EloquentModelStub)-&gt;scopes($scopes); 上面的写法会调用三个本地作用域，它们的参数是$scopes的值。1234567891011121314151617181920212223242526272829303132333435363738394041public function scopes(array $scopes)&#123; $builder = $this; foreach ($scopes as $scope =&gt; $parameters) &#123; if (is_int($scope)) &#123; list($scope, $parameters) = [$parameters, []]; &#125; $builder = $builder-&gt;callScope( [$this-&gt;model, 'scope'.ucfirst($scope)], (array) $parameters ); &#125; return $builder;&#125;``` fill批量赋值Eloquent Model默认只能一个一个的设置数据库对象的属性，这是为了保护数据库。但是有的时候，字段过多会造成代码很繁琐。因此，Laravel提供属性批量赋值的功能，fill函数，相关的官方文档：批量赋值fill函数```phppublic function fill(array $attributes)&#123; $totallyGuarded = $this-&gt;totallyGuarded(); foreach ($this-&gt;fillableFromArray($attributes) as $key =&gt; $value) &#123; $key = $this-&gt;removeTableFromKey($key); if ($this-&gt;isFillable($key)) &#123; $this-&gt;setAttribute($key, $value); &#125; elseif ($totallyGuarded) &#123; throw new MassAssignmentException($key); &#125; &#125; return $this;&#125; fill函数会从参数attributes中选取可以批量赋值的属性。所谓的可以批量赋值的属性，是指被fillable或guarded成员变量设置的参数。被放入fillable的属性允许批量赋值的属性，被放入guarded的属性禁止批量赋值。 获取可批量赋值的属性：12345678910111213protected function fillableFromArray(array $attributes)&#123; if (count($this-&gt;getFillable()) &gt; 0 &amp;&amp; ! static::$unguarded) &#123; return array_intersect_key($attributes, array_flip($this-&gt;getFillable())); &#125; return $attributes;&#125;public function getFillable()&#123; return $this-&gt;fillable;&#125; 可以看到，若想要实现批量赋值，需要将属性设置在fillable成员数组中。 在Laravel中，有一种数据库对象关系是morph，也就是多态关系，这种关系也会调用fill函数，这个时候传入的参数attributes会带有数据库前缀。接下来，就要调用removeTableFromKey函数来去除数据库前缀：1234protected function removeTableFromKey($key)&#123; return Str::contains($key, '.') ? last(explode('.', $key)) : $key;&#125; 下一步，还要进一步验证属性的fillable：1234567891011121314151617public function isFillable($key)&#123; if (static::$unguarded) &#123; return true; &#125; if (in_array($key, $this-&gt;getFillable())) &#123; return true; &#125; if ($this-&gt;isGuarded($key)) &#123; return false; &#125; return empty($this-&gt;getFillable()) &amp;&amp; ! Str::startsWith($key, '_');&#125; 如果当前unguarded开启，也就是不会保护任何属性，那么直接返回true。如果当前属性在fillable中，也会返回true。如果当前属性在guarded中，返回false。最后，如果fillable是空数组，也会返回true。 forceFill如果不想受fillable或者guarded等的影响，还可以使用forceFill强制来批量赋值。123456789101112131415161718192021public function forceFill(array $attributes)&#123; return static::unguarded(function () use ($attributes) &#123; return $this-&gt;fill($attributes); &#125;);&#125;public static function unguarded(callable $callback)&#123; if (static::$unguarded) &#123; return $callback(); &#125; static::unguard(); try &#123; return $callback(); &#125; finally &#123; static::reguard(); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章 接下来如何做]]></title>
    <url>%2F2020%2F06%2F03%2F%E7%AC%AC11%E7%AB%A0-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%A6%82%E4%BD%95%E5%81%9A%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 概述本书未介绍的10种算法以及它们很有用的原因。 如何根据兴趣选择接下来要阅读的内容。 树在前面的二分查找示例中，每当用户登录Facebook时，Facebook都必须在一个庞大的数组中查找，核实其中是否包含指定的用户名。前面说过，在这种数组中查找时，最快的方式是二分查找，但问题是每当有新用户注册时，都必须将其用户名插入该数组并重新排序，因为二分查找仅在数组有序时才管用。如果能将用户名插入到数组的正确位置就好了，这样就无需在插入后再排序。为此，有人设计了一种名为二叉查找树（binary search tree）的数据结构。 二叉查找树类似于下面这样。 对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。 假设你要查找Maggie。为此，你首先检查根节点。 Maggie排在David的后面，因此你往右边找。 Maggie排在Manning前面，因此你往左边找。 终于找到了Maggie！这几乎与二分查找一样！在二叉查找树中查找节点时，平均运行时间为O(log n)，但在最糟的情况下所需时间为O(n)；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。 二叉查找树也存在一些缺点，例如，不能随机访问，就像不能这么说：“给我第五个元素。”在二叉查找树处于平衡状态时，平均访问时间也为O(log n)。假设二叉查找树像下面这样处于不平衡状态。 注意，这棵树是向右倾斜的，因此性能不佳。也有一些处于平衡状态的特殊二叉查找树，如红黑树。 那在什么情况下使用二叉查找树呢？B树是一种特殊的二叉树，数据库常用它来存储数据。 如果你对数据库或高级数据结构感兴趣，请研究如下数据结构：B树，红黑树，堆，伸展树。 反向索引这里非常简单地说说搜索引擎的工作原理。假设你有三个网页，内容如下。 我们根据这些内容创建一个散列表。 这个散列表的键为单词，值为包含指定单词的页面。现在假设有用户搜索hi，在这种情况下，搜索引擎需要检查哪些页面包含hi。 搜索引擎发现页面A和B包含hi，因此将这些页面作为搜索结果呈现给用户。现在假设用户搜索there。你知道，页面A和C包含它。非常简单，不是吗？这是一种很有用的数据结构：一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（inverted index），常用于创建搜索引擎。如果你对搜索感兴趣，从反向索引着手研究是不错的选择。 傅里叶变换绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。Better Explained是一个杰出的网站，致力于以通俗易懂的语言阐释数学，它就傅里叶变换做了一个绝佳的比喻：给它一杯冰沙，它能告诉你其中包含哪些成分。换言之，给定一首歌曲，傅里叶变换能够将其中的各种频率分离出来。 这种理念虽然简单，应用却极其广泛。例如，如果能够将歌曲分解为不同的频率，就可强化你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。为此，首先需要将音频文件分解为音符。傅里叶变换能够准确地指出各个音符对整个歌曲的贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理！ 数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅里叶变换还被用来地震预测和DNA分析。 使用傅里叶变换可创建类似于Shazam这样的音乐识别软件。傅里叶变换的用途极其广泛，你遇到它的可能性极高！ 并行算法接下来的三个主题都与可扩展性和海量数据处理相关。我们身处一个处理器速度越来越快的时代，如果你要提高算法的速度，可等上几个月，届时计算机本身的速度就会更快。但这个时代已接近尾声，因此笔记本电脑和台式机转而采用多核处理器。为提高算法的速度，你需要让它们能够在多个内核中并行地执行！ 来看一个简单的例子。在最佳情况下，排序算法的速度大致为O(n log n)。众所周知，对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)！对数组进行排序时，快速排序的并行版本所需的时间为O(n)。 并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。 并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。 负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？ 要改善性能和可扩展性，并行算法可能是不错的选择！ MapReduce有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计算机上运行。MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。 分布式算法为何很有用假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。在这种情况下，你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。相反，你需要通过Hadoop来使用MapReduce！ 又假设你需要处理一个很长的清单，其中包含100万个职位，而每个职位处理起来需要10秒。 如果使用一台计算机来处理，将耗时数月！如果使用100台计算机来处理，可能几天就能完工。 分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。 映射函数映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。例如，下面的映射函数将数组的每个元素翻倍。 123&gt;&gt;&gt; arr1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; arr2 = map(lambda x: 2 * x, arr1)[2, 4, 6, 8, 10] arr2包含[2, 4, 6, 8, 10]：将数组arr1的每个元素都翻倍！将元素翻倍的速度非常快，但如果要执行的操作需要更长的时间呢？请看下面的伪代码。 12&gt;&gt;&gt; arr1 = # A list of URLs&gt;&gt;&gt; arr2 = map(download_page, arr1) 在这个示例中，你有一个URL清单，需要下载每个URL指向的页面并将这些内容存储在数组arr2中。对于每个URL，处理起来都可能需要几秒钟。如果总共有1000个URL，可能耗时几小时！ 如果有100台计算机，而 map 能够自动将工作分配给这些计算机去完成就好了。这样就可同时下载100个页面，下载速度将快得多！这就是MapReduce中“映射”部分基于的理念。 归并函数归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。 而归并是将一个数组转换为一个元素。 下面是一个示例。123&gt;&gt;&gt; arr1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; reduce(lambda x,y: x+y, arr1)15 在这个示例中，你将数组中的所有元素相加：1 + 2 + 3 + 4 + 5 = 15！这里不深入介绍归并，网上有很多这方面的教程。 MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。 布隆过滤器和HyperLogLog假设你管理着网站Reddit。每当有人发布链接时，你都要检查它以前是否发布过，因为之前未发布过的故事更有价值。 又假设你在Google负责搜集网页，但只想搜集新出现的网页，因此需要判断网页是否搜集过。 在假设你管理着提供网址缩短服务的bit.ly，要避免将用户重定向到恶意网站。你有一个清单，其中记录了恶意网站的URL。你需要确定要将用户重定向到的URL是否在这个清单中。 这些都是同一种类型的问题，涉及庞大的集合。 给定一个元素，你需要判断它是否包含在这个集合中。为快速做出这种判断，可使用散列表。例如，Google可能有一个庞大的散列表，其中的键是已搜集的网页。 要判断是否已搜集adit.io，可在这个散列表中查找它。 adit.io是这个散列表中的一个键，这说明已搜集它。散列表的平均查找时间为O(1)，即查找时间是固定的，非常好！ 只是Google需要建立数万亿个网页的索引，因此这个散列表非常大，需要占用大量的存储空间。Reddit和bit.ly也面临着这样的问题。面临海量数据，你需要创造性的解决方案！ 布隆过滤器布隆过滤器提供了解决之道。布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。使用散列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。 可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。 不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。 布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。对bit.ly而言，这样说完全可行：“我们认为这个网站可能是恶意的，请倍加小心。” HyperLogLogHyperLogLog是一种类似于布隆过滤器的算法。如果Google要计算用户执行的不同搜索的数量，或者Amazon要计算当天用户浏览的不同商品的数量，要回答这些问题，需要耗用大量的空间！对Google来说，必须有一个日志，其中包含用户执行的不同搜索。有用户执行搜索时，Google必须判断该搜索是否包含在日志中：如果答案是否定的，就必须将其加入到日志中。即便只记录一天的搜索，这种日志也大得不得了！ HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。 面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！ SHA算法还记得第5章介绍的散列算法吗？我们回顾一下，假设你有一个键，需要将其相关联的值放到数组中。 你使用散列函数来确定应将这个值放在数组的什么地方。 你将值放在这个地方。 这样查找时间是固定的。当你想要知道指定键对应的值时，可再次执行散列函数，它将告诉你这个值存储在什么地方，需要的时间为O(1)。 在这个示例中，你希望散列函数的结果是均匀分布的。散列函数接受一个字符串，并返回一个索引号。 比较文件另一种散列函数是安全散列算法（secure hash algorithm，SHA）函数。给定一个字符串，SHA返回其散列值。 这里的术语有点令人迷惑。SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。 对于每个不同的字符串，SHA生成的散列值都不同。 说 明SHA生成的散列值很长，这里截短了。 你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。假设你有一个4GB的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送给朋友，而可计算它们的SHA散列值，再对结果进行比较。 检查密码SHA还让你能在不知道原始字符串的情况下对其进行比较。例如，假设Gmail遭到攻击，攻击者窃取了所有的密码！你的密码暴露了吗？没有，因为Google存储的并非密码，而是密码的SHA散列值！你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。 Google只是比较散列值，因此不必存储你的密码！SHA被广泛用于计算密码的散列值。这种散列算法是单向的。你可根据字符串计算出散列值。 但你无法根据散列值推断出原始字符串。 这意味着计算攻击者窃取了Gmail的SHA散列值，也无法据此推断出原始密码！你可将密码转换为散列值，但反过来不行。 SHA实际上是一系列算法：SHA-0、SHA-1、SHA-2和SHA-3。本书编写期间，SHA-0和SHA-1已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用SHA-2或SHA-3。 当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。 局部敏感的散列算法SHA还有一个重要特征，那就是局部不敏感的。假设你有一个字符串，并计算了其散列值。 如果你修改其中的一个字符，再计算其散列值，结果将截然不同！ 这很好，让攻击者无法通过比较散列值是否类似来破解密码。 有时候，你希望结果相反，即希望散列函数是局部敏感的。在这种情况下，可使用Simhash。如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比较散列值来判断两个字符串的相似程度，这很有用！ Google使用Simhash来判断网页是否已搜集。 老师可以使用Simhash来判断学生的论文是否是从网上抄的。 Scribd允许用户上传文档或图书，以便与人分享，但不希望用户上传有版权的内容！这个网站可使用Simhash来检查上传的内容是否与小说《哈利·波特》类似，如果类似，就自动拒绝。 需要检查两项内容的相似程度时，Simhash很有用。 Diffie-Hellman密钥交换这里有必要提一提Diffie-Hellman算法，它以优雅的方式解决了一个古老的问题：如何对消息进行加密，以便只有收件人才能看懂呢？ 最简单的方式是设计一种加密算法，如将a转换为1，b转换为2，以此类推。这样，如果我给你发送消息“4,15,7”，你就可将其转换为“d,o,g”。但我们必须就加密算法达成一致，这种方式才可行。我们不能通过电子邮件来协商，因为可能有人拦截电子邮件，获悉加密算法，进而破译消息。即便通过会面来协商，这种加密算法也可能被猜出来——它并不复杂。因此，我们每天都得修改加密算法，但这样我们每天都得会面！ 即便我们能够每天修改，像这样简单的加密算法也很容易使用蛮力攻击破解。假设我看到消息“9,6,13,13,16 24,16,19,13,5”，如果使用加密算法a = 1、b = 2等，转换结果将如下。 结果是一堆乱码。我们来尝试加密算法a = 2、b = 3等。 结果对了！像这样的简单加密算法很容易破解。在二战期间，德国人使用的加密算法比这复杂得多，但还是被破解了。Diffie-Hellman算法解决了如下两个问题。 双方无需知道加密算法。他们不必会面协商要使用的加密算法。 要破解加密的消息比登天还难。 Diffie-Hellman使用两个密钥：公钥和私钥。顾名思义，公钥就是公开的，可将其发布到网站上，通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。有人要向你发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道私钥，就只有你才能解密消息！ Diffie-Hellman算法及其替代者RSA依然被广泛使用。如果你对加密感兴趣，先着手研究Diffie-Hellman算法是不错的选择：它既优雅又不难理解。 线性规划最好的东西留到最后介绍。线性规划是我知道的最酷的算法之一。 线性规划用于在给定约束条件下最大限度地改善指定的指标。例如，假设你所在的公司生产两种产品：衬衫和手提袋。衬衫每件利润2美元，需要消耗1米布料和5粒扣子；手提袋每个利润3美元，需要消耗2米布料和2粒扣子。你有11米布料和20粒扣子，为最大限度地提高利润，该生产多少件衬衫、多少个手提袋呢？ 在这个例子中，目标是利润最大化，而约束条件是拥有的原材料数量。 再举一个例子。你是个政客，要尽可能多地获得支持票。你经过研究发现，平均而言，对于每张支持票，在旧金山需要付出1小时的劳动（宣传、研究等）和2美元的开销，而在芝加哥需要付出1.5小时的劳动和1美元的开销。在旧金山和芝加哥，你至少需要分别获得500和300张支持票。你有50天的时间，总预算为1500美元。请问你最多可从这两个地方获得多少支持票？ 这里的目标是支持票数最大化，而约束条件是时间和预算。 你可能在想，本书花了很大的篇幅讨论最优化，这与线性规划有何关系？所有的图算法都可使用线性规划来实现。线性规划是一个宽泛得多的框架，图问题只是其中的一个子集。但愿你听到这一点后心潮澎湃！ 线性规划使用Simplex算法，这个算法很复杂，因此本书没有介绍。如果你对最优化感兴趣，就研究研究线性规划吧！ 结语本章简要地介绍了10个算法，唯愿这让你知道还有很多地方等待你去探索。在我看来，最佳的学习方式是找到感兴趣的主题，然后一头扎进去，而本书便为你这样做打下了坚实的基础。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章 K最近邻算法]]></title>
    <url>%2F2020%2F06%2F02%2F%E7%AC%AC10%E7%AB%A0-K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习使用K最近邻算法创建分类系统。 学习特征抽取。 学习回归，即预测数值，如明天的股价或用户对某部电影的喜欢程度。 学习K最近邻算法的应用案例和局限性。 橙子还是柚子请看下面的水果，是橙子还是柚子呢？我知道，柚子通常比橙子更大、更红。 我的思维过程类似于这样：我脑子里有个图表。 一般而言，柚子更大、更红。这个水果又大又红，因此很可能是柚子。但下面这样的水果呢？ 如果判断这个水果是橙子还是柚子呢？一种办法是看它的邻居。来看看离它最近的三个邻居。 在这三个邻居中，橙子比柚子多，因此这个水果很可能是橙子。祝贺你，你刚才就是使用K最近邻（k-nearest neighbours，KNN）算法进行了分类！这个算法非常简单。 KNN算法虽然简单却很有用！要对东西进行分类时，可首先尝试这种算法。下面来看一个更真实的例子。 创建推荐系统假设你是Netflix，要为用户创建一个电影推荐系统。从本质上说，这类似于前面的水果问题！ 你可以将所有用户都放入一个图表中。 这些用户在图表中的位置取决于其喜好，因此喜好相似的用户距离较近。假设你要向Priyanka推荐电影，可以找出五位与他最接近的用户。 假设在对电影的喜好方面，Justin、JC、Joey、Lance和Chris都与Priyanka差不多，因此他们喜欢的电影很可能Priyanka也喜欢！ 有了这样的图表以后，创建推荐系统就将易如反掌：只要是Justin喜欢的电影，就将其推荐给Priyanka。 但还有一个重要的问题没有解决。在前面的图表中，相似的用户相距较近，但如何确定两位用户的相似程度呢？ 特征抽取在前面的水果示例中，你根据个头和颜色来比较水果，换言之，你比较的特征是个头和颜色。现在假设有三个水果，你可抽取它们的特征。 再根据这些特征绘图。 从上图可知，水果A和B比较像。下面来度量它们有多像。要计算两点的距离，可使用毕达哥拉斯公式。 例如，A和B的距离如下。 A和B的距离为1。你还可计算其他水果之间的距离。 这个距离公式印证了你的直觉：A和B很像。 假设你要比较的是Netflix用户，就需要以某种方式将他们放到图表中。因此，你需要将每位用户都转换为一组坐标，就像前面对水果所做的那样。 在能够将用户放入图表后，你就可以计算他们之间的距离了。 下面是一种将用户转换为一组数字的方式。用户注册时，要求他们指出对各种电影的喜欢程度。这样，对于每位用户，都将获得一组数字！ Priyanka和Justin都喜欢爱情片且都讨厌恐怖片。Morpheus喜欢动作片，但讨厌爱情片（他讨厌好好的动作电影毁于浪漫的桥段）。前面判断水果是橙子还是柚子时，每种水果都用2个数字表示，你还记得吗？在这里，每位用户都用5个数字表示。 在数学家看来，这里计算的是五维（而不是二维）空间中的距离，但计算公式不变。 这个公式包含5个而不是2个数字。 这个距离公式很灵活，即便涉及很多个数字，依然可以使用它来计算距离。你可能会问，涉及5个数字时，距离意味着什么呢？这种距离指出了两组数字之间的相似程度。 这是Priyanka和Justin的距离。 Priyanka和Justin很像。Priyanka和Morpheus的差别有多大呢？请计算他们之间的距离，再接着往下读。 Priyanka和Morpheus的距离为24，你算对了吗？上述距离表明，Priyanka的喜好更接近于Justin而不是Morpheus。 太好了！现在要向Priyanka推荐电影将易如反掌：只要是Justin喜欢的电影，就将其推荐给Priyanka，反之亦然。你这就创建了一个电影推荐系统！ 如果你是Netflix用户，Netflix将不断提醒你：多给电影评分吧，你评论的电影越多，给你的推荐就越准确。现在你明白了其中的原因：你评论的电影越多，Netflix就越能准确地判断出你与哪些用户类似。 练习 1、在Netflix示例中，你使用距离公式计算两位用户的距离，但给电影打分时，每位用户的标准并不都相同。假设你有两位用户——Yogi和Pinky，他们欣赏电影的品味相同，但Yogi给喜欢的电影都打5分，而Pinky更挑剔，只给特别好的电影打5分。他们的品味一致，但根据距离算法，他们并非邻居。如何将这种评分方式的差异考虑进来呢？ 2、假设Netflix指定了一组意见领袖。例如，Quentin Tarantino和Wes Anderson就是Netflix的意见领袖，因此他们的评分比普通用户更重要。请问你该如何修改推荐系统，使其偏重于意见领袖的评分呢？ 回归假设你不仅要向Priyanka推荐电影，还要预测她将给这部电影打多少分。为此，先找出与她最近的5个人。 顺便说一句，我老说最近的5个人，其实并非一定要选择5个最近的邻居，也可选择2个、10个或10 000个。这就是这种算法名为K最近邻而不是5最近邻的原因！ 假设你要预测Priyanka会给电影Pitch Perfect打多少分。Justin、JC、Joey、Lance和Chris都给它打了多少分呢？ 你求这些人打的分的平均值，结果为4.2。这就是回归（regression）。你将使用KNN来做两项基本工作——分类和回归： 分类就是编组； 回归就是预测结果（如一个数字）。 回归很有用。假设你在伯克利开个小小的面包店，每天都做新鲜面包，需要根据如下一组特征预测当天该烤多少条面包： 天气指数1～5（1表示天气很糟，5表示天气非常好）； 是不是周末或节假日（周末或节假日为1，否则为0）； 有没有活动（1表示有，0表示没有）。 你还有一些历史数据，记录了在各种不同的日子里售出的面包数量。 今天是周末，天气不错。根据这些数据，预测你今天能售出多少条面包呢？我们来使用KNN算法，其中的K为4。首先，找出与今天最接近的4个邻居。 距离如下，因此最近的邻居为A、B、D和E。 将这些天售出的面包数平均，结果为218.75。这就是你今天要烤的面包数！ 余弦相似度前面计算两位用户的距离时，使用的都是距离公式。还有更合适的公式吗？在实际工作中，经常使用余弦相似度（cosine similarity）。假设有两位品味类似的用户，但其中一位打分时更保守。他们都很喜欢Manmohan Desai的电影Amar Akbar Anthony，但Paul给了5星，而Rowan只给4星。如果你使用距离公式，这两位用户可能不是邻居，虽然他们的品味非常接近。余弦相似度不计算两个矢量的距离，而比较它们的角度，因此更适合处理前面所说的情况。本书不讨论余弦相似度，但如果你要使用KNN，就一定要研究研究它！ 挑选合适的特征为推荐电影，你让用户指出他对各类电影的喜好程度。如果你是让用户给一系列小猫图片打分呢？在这种情况下，你找出的是对小猫图片的欣赏品味类似的用户。对电影推荐系统来说，这很可能是一个糟糕的推荐引擎，因为你选择的特征与电影欣赏品味没多大关系。 又假设你只让用户给《玩具总动员》《玩具总动员2》和《玩具总动员3》打分。这将难以让用户的电影欣赏品味显现出来！使用KNN时，挑选合适的特征进行比较至关重要。所谓合适的特征，就是： 与要推荐的电影紧密相关的特征； 不偏不倚的特征（例如，如果只让用户给喜剧片打分，就无法判断他们是否喜欢动作片）。 你认为评分是不错的电影推荐指标吗？我给The Wire的评分可能比House Hunters高，但实际上我观看House Hunters的时间更长。该如何改进Netflix的推荐系统呢？ 回到面包店的例子：对于面包店，你能找出两个不错和糟糕的特征吗？在报纸上打广告后，你可能需要烤制更多的面包；或者每周一你都需要烤制更多的面包。 在挑选合适的特征方面，没有放之四海皆准的法则，你必须考虑到各种需要考虑的因素。 练习 3、Netflix的用户数以百万计，前面创建推荐系统时只考虑了5个最近的邻居，这是太多还是太少了呢？ 机器学习简介KNN算法真的是很有用，堪称你进入神奇的机器学习领域的领路人！机器学习旨在让计算机更聪明。你见过一个机器学习的例子：创建推荐系统。下面再来看看其他一些例子。 OCROCR指的是光学字符识别（optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。Google使用OCR来实现图书数字化。OCR是如何工作的呢？我们来看一个例子。请看下面的数字。 如何自动识别出这个数字是什么呢？可使用KNN。 (1) 浏览大量的数字图像，将这些数字的特征提取出来。 (2) 遇到新图像时，你提取该图像的特征，再找出它最近的邻居都是谁！ 这与前面判断水果是橙子还是柚子时一样。一般而言，OCR算法提取线段、点和曲线等特征。 遇到新字符时，可从中提取同样的特征。 与前面的水果示例相比，OCR中的特征提取要复杂得多，但再复杂的技术也是基于KNN等简单理念的。这些理念也可用于语音识别和人脸识别。你将照片上传到Facebook时，它有时候能够自动标出照片中的人物，这是机器学习在发挥作用！ OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。下一个示例是垃圾邮件过滤器，其中也包含训练的步骤。 创建垃圾邮件过滤器垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（Naive Bayes classifier），你首先需要使用一些数据对这个分类器进行训练。 假设你收到一封主题为“collect your million dollars now!”的邮件，这是垃圾邮件吗？你可研究这个句子中的每个单词，看看它在垃圾邮件中出现的概率是多少。例如，使用这个非常简单的模型时，发现只有单词million在垃圾邮件中出现过。朴素贝叶斯分类器能计算出邮件为垃圾邮件的概率，其应用领域与KNN相似。 例如，你可使用朴素贝叶斯分类器来对水果进行分类：假设有一个又大又红的水果，它是柚子的概率是多少呢？朴素贝叶斯分类器也是一种简单而极其有效的算法。我们钟爱这样的算法！ 预测股票市场使用机器学习来预测股票市场的涨跌真的很难。对于股票市场，如何挑选合适的特征呢？股票昨天涨了，今天也会涨，这样的特征合适吗？又或者每年五月份股票市场都以绿盘报收，这样的预测可行吗？在根据以往的数据来预测未来方面，没有万无一失的方法。未来很难预测，由于涉及的变数太多，这几乎是不可能完成的任务。 小结但愿通过阅读本章，你对KNN和机器学习的各种用途能有大致的认识！机器学习是个很有趣的领域，只要下定决心，你就能很深入地了解它。 KNN用于分类和回归，需要考虑最近的邻居。 分类就是编组。 回归就是预测结果（如数字）。 特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。 能否挑选合适的特征事关KNN算法的成败。 答案10.1 可使用归一化（normalization）。你可计算每位用户的平均评分，并据此来调整用户的评分。例如，你可能发现Pinky的平均评分为星3，而Yogi的平均评分为3.5星。因此，你稍微调高Pinky的评分，使其平均评分也为3.5星。这样就能基于同样的标准比较他们的评分了。 10.2 可在使用KNN时给意见领袖的评分更大权重。假设有3个邻居——Joe、Dave和意见领袖Wes Anderson，他们给Caddyshack的评分分别为3星、4星和5星。可不计算这些评分的平均值 (3 + 4 + 5) / 3 = 4星，而给Wes Anderson的评分更大权重：(3 + 4 + 5 + 5 + 5) / 5 = 4.4星。 10.3 太少了。如果考虑的邻居太少，结果很可能存在偏差。一个不错的经验规则是：如果有N位用户，应考虑sqrt(N)个邻居。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 动态规划]]></title>
    <url>%2F2020%2F06%2F02%2F%E7%AC%AC9%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习动态规划，这是一种解决棘手问题的方法，它将问题分成小问题，并先着手解决这些小问题。 学习如何设计问题的动态规划解决方案。 背包问题我们再来看看第8章的背包问题。假设你是个小偷，背着一个可装4磅东西的背包。 你可盗窃的商品有如下3件。 物品 价格 重量 音响 3000美元 4磅 笔记本电脑 2000美元 3磅 吉他 1500美元 1磅 为了让盗窃的商品价值最高，你该选择哪些商品？ 简单算法最简单的算法如下：尝试各种可能的商品组合，并找出价值最高的组合。 这样可行，但速度非常慢。在有3件商品的情况下，你需要计算8个不同的集合；有4件商品时，你需要计算16个集合。每增加一件商品，需要计算的集合数都将翻倍！这种算法的运行时间为O(2n)，真的是慢如蜗牛。 只要商品数量多到一定程度，这种算法就行不通。在第8章，你学习了如何找到近似解，这接近最优解，但可能不是最优解。 那么如何找到最优解呢？ 动态规划答案是使用动态规划！下面来看看动态规划算法的工作原理。动态规划先解决子问题，再逐步解决大问题。 对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。 动态规划是一个难以理解的概念，如果你没有立即搞懂，也不用担心，我们将研究很多示例。 先来演示这种算法的执行过程。看过执行过程后，你心里将有一大堆问题！我将竭尽所能解答这些问题。 每个动态规划算法都从一个网格开始，背包问题的网格如下。 网格的各行为商品，各列为不同容量（1～4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。 网格最初是空的。你将填充其中的每个单元格，网格填满后，就找到了问题的答案！你一定要跟着做。请你创建网格，我们一起来填满它。 1.吉他行 后面将列出计算这个网格中单元格值的公式。我们先来一步一步做。首先来看第一行。 这是吉他行，意味着你将尝试将吉他装入背包。在每个单元格，都需要做一个简单的决定：偷不偷吉他？别忘了，你要找出一个价值最高的商品集合。 第一个单元格表示背包的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。 下面来开始填充网格。 与这个单元格一样，每个单元格都将包含当前可装入背包的所有商品。 来看下一个单元格。这个单元格表示背包的容量为2磅，完全能够装下吉他！ 这行的其他单元格也一样。别忘了，这是第一行，只有吉他可供你选择。换言之，你假装现在还没法盗窃其他两件商品。 此时你很可能心存疑惑：原来的问题说的是4磅的背包，我们为何要考虑容量为1磅、2磅等的背包呢？前面说过，动态规划从小问题着手，逐步解决大问题。这里解决的子问题将帮助你解决大问题。请接着往下读，稍后你就会明白的。 此时网格应类似于下面这样。 别忘了，你要做的是让背包中商品的价值最大。这行表示的是当前的最大价值。它指出，如果你有一个容量4磅的背包，可在其中装入的商品的最大价值为1500美元。 你知道这不是最终的解。随着算法往下执行，你将逐步修改最大价值。 2.音响行 我们来填充下一行——音响行。你现在处于第二行，可偷的商品有吉他和音响。在每一行，可偷的商品都为当前行的商品以及之前各行的商品。因此，当前你还不能偷笔记本电脑，而只能偷音响和吉他。我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品的最大价值为1500美元。 该不该偷音响呢？ 背包的容量为1磅，能装下音响吗？音响太重了，装不下！由于容量1磅的背包装不下音响，因此最大价值依然是1500美元。 接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。 由于这些背包装不下音响，因此最大价值保持不变。 背包容量为4磅呢？终于能够装下音响了！原来的最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！因此还是偷音响吧。 你更新了最大价值！如果背包的容量为4磅，就能装入价值至少3000美元的商品。在这个网格中，你逐步地更新最大价值。 3.笔记本电脑行 下面以同样的方式处理笔记本电脑。笔记本电脑重3磅，没法将其装入容量为1磅或2磅的背包，因此前两个单元格的最大价值还是1500美元。 对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可选择盗窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元！ 对于容量为4磅的背包，情况很有趣。这是非常重要的部分。当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。 价值没有原来高。但等一等，笔记本电脑的重量只有3磅，背包还有1磅的容量没用！ 在1磅的容量中，可装入的商品的最大价值是多少呢？你之前计算过。 根据之前计算的最大价值可知，在1磅的容量中可装入吉他，价值1500美元。因此，你需要做如下比较。 你可能始终心存疑惑：为何计算小背包可装入的商品的最大价值呢？但愿你现在明白了其中的原因！余下了空间时，你可根据这些子问题的答案来确定余下的空间可装入哪些商品。笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。 最终的网格类似于下面这样。 答案如下：将吉他和笔记本电脑装入背包时价值最高，为3500美元。 你可能认为，计算最后一个单元格的价值时，我使用了不同的公式。那是因为填充之前的单元格时，我故意避开了一些复杂的因素。其实，计算每个单元格的价值时，使用的公式都相同。这个公式如下。 你可以使用这个公式来计算每个单元格的价值，最终的网格将与前一个网格相同。现在你明白了为何要求解子问题吧？你可以合并两个子问题的解来得到更大问题的解。 背包问题FAQ你可能还是觉得这像是变魔术。本节将回答一些常见的问题。 再增加一件商品将如何呢假设你发现还有第四件商品可偷——一个价值2000美元重量为1磅的iPhone！ 此时需要重新执行前面所做的计算吗？不需要。别忘了，动态规划逐步计算最大价值。到目前为止，计算出的最大价值如下。 这意味着背包容量为4磅时，你最多可偷价值3500美元的商品。但这是以前的情况，下面再添加表示iPhone的行。 最大价值可能发生变化！请尝试填充这个新增的行，再接着往下读。 我们从第一个单元格开始。iPhone可装入容量为1磅的背包。之前的最大价值为1500美元，但iPhone价值2000美元，因此该偷iPhone而不是吉他。 在下一个单元格中，你可装入iPhone和吉他。 对于第三个单元格，也没有比装入iPhone和吉他更好的选择了。 对于最后一个单元格，情况比较有趣。当前的最大价值为3500美元，但你可偷iPhone，这将余下3磅的容量。 3磅容量的最大价值为2000美元！再加上iPhone价值2000美元，总价值为4000美元。新的最大价值诞生了！ 最终的网格如下。 问题：沿着一列往下走时，最大价值有可能降低吗？ 请找出这个问题的答案，再接着往下读。 答案：不可能。每次迭代时，你都存储当前的最大价值。最大价值不可能比以前低！ 练习 1.假设你还可偷另外一件商品——MP3播放器，它重1磅，价值1000美元。你要偷吗？ 行的排列顺序发生变化时结果将如何答案会随之变化吗？假设你按如下顺序填充各行：音响、笔记本电脑、吉他。网格将会是什么样的？请自己动手填充这个网格，再接着往下读。 网格将类似于下面这样。 答案没有变化。也就是说，各行的排列顺序无关紧要。 可以逐列而不是逐行填充网格吗自己动手试试吧！就这个问题而言，这没有任何影响，但对于其他问题，可能有影响。 增加一件更小的商品将如何呢假设你还可以偷一条项链，它重0.5磅，价值1000美元。前面的网格都假设所有商品的重量为整数，但现在你决定把项链给偷了，因此余下的容量为3.5磅。在3.5磅的容量中，可装入的商品的最大价值是多少呢？不知道！因为你只计算了容量为1磅、2磅、3磅和4磅的背包可装下的商品的最大价值。现在，你需要知道容量为3.5磅的背包可装下的商品的最大价值。 由于项链的加入，你需要考虑的粒度更细，因此必须调整网格。 可以偷商品的一部分吗假设你在杂货店行窃，可偷成袋的扁豆和大米，但如果整袋装不下，可打开包装，再将背包倒满。在这种情况下，不再是要么偷要么不偷，而是可偷商品的一部分。如何使用动态规划来处理这种情形呢？ 答案是没法处理。使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分。 但使用贪婪算法可轻松地处理这种情况！首先，尽可能多地拿价值最高的商品；如果拿光了，再尽可能多地拿价值次高的商品，以此类推。 例如，假设有如下商品可供选择。 藜麦比其他商品都值钱，因此要尽量往背包中装藜麦！如果能够在背包中装满藜麦，结果就是最佳的。 如果藜麦装完后背包还没满，就接着装入下一种最值钱的商品，以此类推。 旅游行程最优化假设你要去伦敦度假，假期两天，但你想去游览的地方很多。你没法前往每个地方游览，因此你列个单子。 对于想去游览的每个名胜，都列出所需的时间以及你有多想去看看。根据这个清单，你能确定该去游览哪些名胜吗？ 这也是一个背包问题！但约束条件不是背包的容量，而是有限的时间；不是决定该装入哪些商品，而是决定该去游览哪些名胜。请根据这个清单绘制动态规划网格，再接着往下读。 网格类似于下面这样。 你画对了吗？请填充这个网格，决定该游览哪些名胜。答案如下。 处理相互依赖的情况假设你还想去巴黎，因此在前述清单中又添加了几项。 去这些地方游览需要很长时间，因为你先得从伦敦前往巴黎，这需要半天时间。如果这3个地方都去玩，是不是要4.5天呢？ 不是的，因为不是去每个地方都得先从伦敦到巴黎。到达巴黎后，每个地方都只需1天时间。因此玩这3个地方需要的总时间为3.5天（半天从伦敦到巴黎，每个地方1天），而不是4.5天。 将埃菲尔铁塔加入“背包”后，卢浮宫将更“便宜”：只要1天时间，而不是1.5天。如何使用动态规划对这种情况建模呢？ 没办法建模。动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。这意味着使用动态规划算法解决不了去巴黎玩的问题。 计算最终的解时会涉及两个以上的子背包吗为获得前述背包问题的最优解，可能需要偷两件以上的商品。但根据动态规划算法的设计，最多只需合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包。 最优解可能导致背包没装满吗完全可能。假设你还可以偷一颗钻石。 这颗钻石非常大，重达3.5磅，价值100万美元，比其他商品都值钱得多。 你绝对应该把它给偷了！但当你这样做时，余下的容量只有0.5磅，别的什么都装不下。 练习 2.假设你要去野营。你有一个容量为6磅的背包，需要决定该携带下面的哪些东西。其中每样东西都有相应的价值，价值越大意味着越重要： 水（重3磅，价值10）； 书（重1磅，价值3） 食物（重2磅，价值9）； 夹克（重2磅，价值5）； 相机（重1磅，价值6）。 请问携带哪些东西时价值最高？ 最长公共子串通过前面的动态规划问题，你得到了哪些启示呢？ 动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 要设计出动态规划解决方案可能很难，这正是本节要介绍的。下面是一些通用的小贴士。 每种动态规划解决方案都涉及网格。 单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。 下面再来看一个例子。假设你管理着网站dictionary.com。用户在该网站输入单词时，你需要给出其定义。 但如果用户拼错了，你必须猜测他原本要输入的是什么单词。例如，Alex想查单词fish，但不小心输入了hish。在你的字典中，根本就没有这样的单词，但有几个类似的单词。 在这个例子中，只有两个类似的单词，真是太小儿科了。实际上，类似的单词很可能有数千个。 Alex输入了hish，那他原本要输入的是fish还是vista呢？ 绘制网格用于解决这个问题的网格是什么样的呢？要确定这一点，你得回答如下问题。 单元格中的值是什么？ 如何将这个问题划分为子问题？ 网格的坐标轴是什么？ 在动态规划中，你要将某个指标最大化。在这个例子中，你要找出两个单词的最长公共子串。hish和fish都包含的最长子串是什么呢？hish和vista呢？这就是你要计算的值。 别忘了，单元格中的值通常就是你要优化的值。在这个例子中，这很可能是一个数字：两个字符串都包含的最长子串的长度。 如何将这个问题划分为子问题呢？你可能需要比较子串：不是比较hish和fish，而是先比较his和fis。每个单元格都将包含这两个子串的最长公共子串的长度。这也给你提供了线索，让你觉得坐标轴很可能是这两个单词。因此，网格可能类似于下面这样。 如果这在你看来犹如巫术，也不用担心。这些内容很难懂，但这也正是我到现在才介绍它们的原因！本章后面有一个练习，到时你可以自己动手来进行动态规划。 填充网格现在，你很清楚网格应是什么样的。填充该网格的每个单元格时，该使用什么样的公式呢？由于你已经知道答案——hish和fish的最长公共子串为ish，因此可以作点弊。 即便如此，你还是不能确定该使用什么样的公式。计算机科学家有时会开玩笑说，那就使用费曼算法（Feynman algorithm）。这个算法是以著名物理学家理查德·费曼命名的，其步骤如下。 (1) 将问题写下来。(2) 好好思考。(3) 将答案写下来。 计算机科学家真是一群不按常理出牌的人啊！ 实际上，根本没有找出计算公式的简单办法，你必须通过尝试才能找出管用的公式。有些算法并非精确的解决步骤，而只是帮助你理清思路的框架。 请尝试为这个问题找到计算单元格值的公式。给你一点提示吧：下面是这个单元格的一部分。 其他单元格的值呢？别忘了，每个单元格都是一个子问题的值。为何单元格(3,3)的值为2呢？ 又为何单元格(3, 4)的值为0呢？ 请找出计算公式，再接着往下读。这样即便你没能找出正确的公式，后面的解释也将容易理解得多。 揭晓答案最终的网格如下。 我使用下面的公式来计算每个单元格的值。 实现这个公式的伪代码类似于下面这样。 1234if word_a[i] == word_b[j]: # 两个字母相同 cell[i][j] = cell[i-1][j-1] + 1else: # 两个字母不同 cell[i][j] = 0 查找单词hish和vista的最长公共子串时，网格如下。 需要注意的一点是，这个问题的最终答案并不在最后一个单元格中！对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。 我们回到最初的问题：哪个单词与hish更像？hish和fish的最长公共子串包含三个字母，而hish和vista的最长公共子串包含两个字母。 因此Alex很可能原本要输入的是fish。 最长公共子序列假设Alex不小心输入了fosh，他原本想输入的是fish还是fort呢？ 我们使用最长公共子串公式来比较它们。 最长公共子串的长度相同，都包含两个字母！但fosh与fish更像。 这里比较的是最长公共子串，但其实应比较最长公共子序列：两个单词中都有的序列包含的字母数。如何计算最长公共子序列呢？ 下面是用于计算fish和fosh的最长公共子序列的网格的一部分。 你能找出填充这个网格时使用的公式吗？最长公共子序列与最长公共子串很像，计算公式也很像。请试着找出这个公式——答案稍后揭晓。 最长公共子序列之解决方案最终的网格如下。 下面是填写各个单元格时使用的公式。 伪代码如下。 1234if word_a[i] == word_b[j]: # 两个字母相同 cell[i][j] = cell[i-1][j-1] + 1else: # 两个字母不同 cell[i][j] = max(cell[i-1][j], cell[i][j-1]) 本章到这里就结束了！它绝对是本书最难理解的一章。动态规划都有哪些实际应用呢？ 生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。 你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。 前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。 你使用过诸如Microsoft Word等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！ 练习 3.请绘制并填充用来计算blue和clues最长公共子串的网格。 小结 需要在给定约束条件下优化某种指标时，动态规划很有用。 问题可分解为离散子问题时，可使用动态规划来解决。 每种动态规划解决方案都涉及网格。 单元格中的值通常就是你要优化的值。 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。 没有放之四海皆准的计算动态规划解决方案的公式。 答案9.1 要。在这种情况下，你可偷来MP3播放器和iPhone和吉他，总价值为4500美元。 9.2 你应携带水、食物和相机。 9.3]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 贪婪算法]]></title>
    <url>%2F2020%2F06%2F02%2F%E7%AC%AC8%E7%AB%A0-%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 贪婪算法很简单：每步都采取最优的做法。怎么理解？ 你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 本章内容 学习如何处理不可能完成的任务：没有快速算法的问题（NP完全问题）。 学习识别NP完全问题，以免浪费时间去寻找解决它们的快速算法。 学习近似算法，使用它们可快速找到NP完全问题的近似解。 学习贪婪策略——一种非常简单的问题解决策略。 教室调度问题假设有如下课程表，你希望将尽可能多的课程安排在某间教室上。 你没法让这些课都在这间教室上，因为有些课的上课时间有冲突。 你希望在这间教室上尽可能多的课。如何选出尽可能多且时间不冲突的课程呢？ 这个问题好像很难，不是吗？实际上，算法可能简单得让你大吃一惊。具体做法如下。 (1) 选出结束最早的课，它就是要在这间教室上的第一堂课。 (2) 接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。 重复这样做就能找出答案！下面来试一试。美术课的结束时间最早，为10:00 a.m.，因此它就是第一堂课。 接下来的课必须在10:00 a.m.后开始，且结束得最早。 英语课不行，因为它的时间与美术课冲突，但数学课满足条件。最后，计算机课与数学课的时间是冲突的，但音乐课可以。 因此将在这间教室上如下三堂课。 很多人都跟我说，这个算法太容易、太显而易见，肯定不对。但这正是贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。在这个示例中，你每次都选择结束最早的课。用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。信不信由你，对于这个调度问题，上述简单算法找到的就是最优解！ 显然，贪婪算法并非在任何情况下都行之有效，但它易于实现！下面再来看一个例子。 背包问题假设你是个贪婪的小偷，背着可装35磅（1磅≈0.45千克）重东西的背包，在商场伺机盗窃各种可装入背包的商品。 你力图往背包中装入价值最高的商品，你会使用哪种算法呢？ 同样，你采取贪婪策略，这非常简单。 (1) 盗窃可装入背包的最贵商品。 (2) 再盗窃还可装入背包的最贵商品，以此类推。 只是这次这种贪婪策略不好使了！例如，你可盗窃的商品有下面三种。 你的背包可装35磅的东西。音响最贵，你把它给偷了，但背包没有空间装其他东西了。 你偷到了价值3000美元的东西。且慢！如果不是偷音响，而是偷笔记本电脑和吉他，总价将为3500美元！ 在这里，贪婪策略显然不能获得最优解，但非常接近。下一章将介绍如何找出最优解。不过小偷去购物中心行窃时，不会强求所偷东西的总价最高，只要差不多就行了。 从这个示例你得到了如下启示：在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。 练习 1.你在一家家具公司工作，需要将家具发往全国各地，为此你需要将箱子装上卡车。每个箱子的尺寸各不相同，你需要尽可能利用每辆卡车的空间，为此你将如何选择要装上卡车的箱子呢？请设计一种贪婪算法。使用这种算法能得到最优解吗？ 2.你要去欧洲旅行，总行程为7天。对于每个旅游胜地，你都给它分配一个价值——表示你有多想去那里看看，并估算出需要多长时间。你如何将这次旅行的价值最大化？请设计一种贪婪算法。使用这种算法能得到最优解吗？ 下面来看最后一个例子。在这个例子中，你别无选择，只能使用贪婪算法。 集合覆盖问题假设你办了个广播节目，要让全美50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。现有广播台名单如下。 每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。 如何找出覆盖全美50个州的最小广播台集合呢？听起来很容易，但其实非常难。具体方法如下。 (1) 列出每个可能的广播台集合，这被称为幂集（power set）。可能的子集有2n个。 (2) 在这些集合中，选出覆盖全美50个州的最小集合。 问题是计算每个可能的广播台子集需要很长时间。由于可能的集合有2n个，因此运行时间为O(2n)。如果广播台不多，只有5～10个，这是可行的。但如果广播台很多，结果将如何呢？随着广播台的增多，需要的时间将激增。假设你每秒可计算10个子集，所需的时间将如下。 没有任何算法可以足够快地解决这个问题！怎么办呢？ 近似算法 贪婪算法可化解危机！使用下面的贪婪算法可得到非常接近的解。 (1) 选出这样一个广播台，即它覆盖了最多的未覆盖州。即便这个广播台覆盖了一些已覆盖的州，也没有关系。 (2) 重复第一步，直到覆盖了所有的州。 这是一种近似算法（approximation algorithm）。在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下： 速度有多快； 得到的近似解与最优解的接近程度。 贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。在这个例子中，贪婪算法的运行时间为O(n2)，其中n为广播台数量。 下面来看看解决这个问题的代码。 1.准备工作 出于简化考虑，这里假设要覆盖的州没有那么多，广播台也没有那么多。 首先，创建一个列表，其中包含要覆盖的州。1states_needed = set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"]) #你传入一个数组，它被转换为集合 我使用集合来表示要覆盖的州。集合类似于列表，只是同样的元素只能出现一次，即集合不能包含重复的元素。例如，假设你有如下列表。1&gt;&gt;&gt; arr = [1, 2, 2, 3, 3, 3] 并且你将其转换为集合。12&gt;&gt;&gt; set(arr)set([1, 2, 3]) 在这个集合中，1、2和3都只出现一次。 还需要有可供选择的广播台清单，我选择使用散列表来表示它。 123456stations = &#123;&#125;stations["kone"] = set(["id", "nv", "ut"])stations["ktwo"] = set(["wa", "id", "mt"])stations["kthree"] = set(["or", "nv", "ca"])stations["kfour"] = set(["nv", "ut"])stations["kfive"] = set(["ca", "az"]) 其中的键为广播台的名称，值为广播台覆盖的州。在该示例中，广播台kone覆盖了爱达荷州、内达华州和犹他州。所有的值都是集合。你马上将看到，使用集合来表示一切可以简化工作。 最后，需要使用一个集合来存储最终选择的广播台。1final_stations = set() 2.计算答案 接下来需要计算要使用哪些广播台。根据下面的示意图，你能确定应使用哪些广播台吗？ 正确的解可能有多个。你需要遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台。我将这个广播台存储在best_station中。123best_station = Nonestates_covered = set()for station, states_for_station in stations.items(): states_covered是一个集合，包含该广播台覆盖的所有未覆盖的州。for循环迭代每个广播台，并确定它是否是最佳的广播台。下面来看看这个for循环的循环体。1234covered = states_needed &amp; states_for_stationif len(covered) &gt; len(states_covered): # 你没见过的语法！它计算交集 best_station = station states_covered = covered 其中有一行代码看起来很有趣。1covered = states_needed &amp; states_for_station 它是做什么的呢？ 3.集合 假设你有一个水果集合。 还有一个蔬菜集合。 有这两个集合后，你就可以使用它们来做些有趣的事情。 下面是你可以对集合执行的一些操作。 并集意味着将集合合并。 交集意味着找出两个集合中都有的元素（在这里，只有西红柿符合条件）。 差集意味着将从一个集合中剔除出现在另一个集合中的元素。 下面是一个例子。 123456789&gt;&gt;&gt; fruits = set(["avocado", "tomato", "banana"])&gt;&gt;&gt; vegetables = set(["beets", "carrots", "tomato"])&gt;&gt;&gt; fruits | vegetables # 并集set(["avocado", "beets", "carrots", "tomato", "banana"])&gt;&gt;&gt; fruits &amp; vegetables # 交集set(["tomato"])&gt;&gt;&gt; fruits – vegetables # 差集set(["avocado", "banana"])&gt;&gt;&gt; vegetables – fruits # 你觉得这行代码是做什么的呢？ 这里小结一下： 集合类似于列表，只是不能包含重复的元素； 你可执行一些有趣的集合运算，如并集、交集和差集。 4.回到代码 回到前面的示例。 下面的代码计算交集。 1covered = states_needed &amp; states_for_station covered 是一个集合，包含同时出现在states_needed和states_for_station中的州；换言之，它包含当前广播台覆盖的一系列还未覆盖的州！接下来，你检查该广播台覆盖的州是否比best_station多。 123if len(covered) &gt; len(states_covered): best_station = station states_covered = covered 如果是这样的，就将best_station设置为当前广播台。最后，你在for循环结束后将best_station添加到最终的广播台列表中。 1final_stations.add(best_station) 你还需更新states_needed。由于该广播台覆盖了一些州，因此不用再覆盖这些州。 1states_needed -= states_covered 你不断地循环，直到states_needed为空。这个循环的完整代码如下。 12345678910111213while states_needed: best_station = None states_covered = set() for station, states in stations.items(): covered = states_needed &amp; states if len(covered) &gt; len(states_covered): best_station = station states_covered = coveredstates_needed -= states_coveredfinal_stations.add(best_station) 最后，你打印final_stations，结果类似于下面这样。 12&gt;&gt;&gt; print final_stationsset(['ktwo', 'kthree', 'kone', 'kfive']) 结果符合你的预期吗？选择的广播台可能是2、3、4和5，而不是预期的1、2、3和5。下面来比较一下贪婪算法和精确算法的运行时间。 练习 下面各种算法是否是贪婪算法。 3.快速排序。 4.广度优先搜索。 5.狄克斯特拉算法。 NP完全问题为解决集合覆盖问题，你必须计算每个可能的集合。 这可能让你想起了第1章介绍的旅行商问题。在这个问题中，旅行商需要前往5个不同的城市。 他需要找出前往这5个城市的最短路径，为此，必须计算每条可能的路径。 前往5个城市时，可能的路径有多少条呢？ 旅行商问题详解我们从城市数较少的情况着手。假设只涉及两个城市，因此可供选择的路线有两条。 这两条路线相同还是不同你可能认为这两条路线相同，难道从旧金山到马林的距离与从马林到旧金山的距离不同吗？不一定。有些城市（如旧金山）有很多单行线，因此你无法按原路返回。你可能需要离开原路行驶一两英里才能找到上高速的匝道。因此，这两条路线不一定相同。 你可能心存疑惑：在旅行商问题中，必须从特定的城市出发吗？例如，假设我是旅行商。我居住在旧金山，需要前往其他4个城市，因此我将从旧金山出发。 但有时候，不确定要从哪个城市出发。假设联邦快递将包裹从芝加哥发往湾区，包裹将通过航运发送到联邦快递在湾区的50个集散点之一，再装上经过不同配送点的卡车。该通过航运发送到哪个集散点呢？在这个例子中，起点就是未知的。因此，你需要通过计算为旅行商找出起点和最佳路线。 在这两种情况下，运行时间是相同的。但出发城市未定时更容易处理，因此这里以这种情况为例。 涉及两个城市时，可能的路线有两条。 1、3个城市 现在假设再增加一个城市，可能的路线有多少条呢？ 如果从伯克利出发，就需前往另外两个城市。 从每个城市出发时，都有两条不同的路线，因此总共有6条路线。 因此涉及3个城市时，可能的路线有6条。 2、4个城市 我们再增加一个城市——弗里蒙特。现在假设从弗里蒙特出发。 从弗里蒙特出发时，有6条可能的路线。这些路线与前面只有3个城市时计算的6条路线很像，只是现在所有的路线都多了一个城市——弗里蒙特！这里有一个规律。假设有4个城市，你选择一个出发城市——弗里蒙特后，还余下3个城市。而你知道，涉及3个城市时，可能的路线有6条。 从弗里蒙特出发时，有6条可能的路线，但还可以从其他任何一个城市出发。 可能的出发城市有4个，从每个城市出发时都有6条可能的路线，因此可能的路线有4 × 6 = 24条。 你看出规律了吗？每增加一个城市，需要计算的路线数都将增加。 涉及6个城市时，可能的路线有多少条呢？如果你说720条，那就对了。7个城市为5040条，8个城市为40 320条。 这被称为阶乘函数（factorial function），第3章介绍过。5! = 120。假设有10个城市，可能的路线有多少条呢？10! = 3 628 800。换句话说，涉及10个城市时，需要计算的可能路线超过300万条。正如你看到的，可能的路线数增加得非常快！因此，如果涉及的城市很多，根本就无法找出旅行商问题的正确解。 旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 近似求解对旅行商问题来说，什么样的近似算法不错呢？能找到较短路径的算法就算不错。在继续往下阅读前，看看你能设计出这样的算法吗？我会采取这样的做法：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还没去的最近的城市。假设旅行商从马林出发。总旅程为71英里。这条路径可能不是最短的，但也相当短了。 NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。 如何识别NP完全问题Jonah正为其虚构的橄榄球队挑选队员。他列了一个清单，指出了对球队的要求：优秀的四分卫，优秀的跑卫，擅长雨中作战，以及能承受压力等。他有一个候选球员名单，其中每个球员都满足某些要求。 Jonah需要组建一个满足所有这些要求的球队，可名额有限。等等，Jonah突然间意识到，这不就是一个集合覆盖问题吗！ Jonah可使用前面介绍的近似算法来组建球队。 (1) 找出符合最多要求的球员。 (2) 不断重复这个过程，直到球队满足要求（或球队名额已满）。 NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。例如，前一章深入讨论了最短路径，你知道如何找出从A点到B点的最短路径。 但如果要找出经由指定几个点的的最短路径，就是旅行商问题——NP完全问题。简言之，没办法判断问题是不是NP完全问题，但还是有一些蛛丝马迹可循的。 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。 涉及“所有组合”的问题通常是NP完全问题。 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。 练习 6.有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一个NP完全问题吗？ 7.在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？ 8.你要制作美国地图，需要用不同的颜色标出相邻的州。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻州的颜色都不同。请问这是NP完全问题吗？ 小结 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 对于NP完全问题，还没有找到快速解决方案。 面临NP完全问题时，最佳的做法是使用近似算法。 贪婪算法易于实现、运行速度快，是不错的近似算法。 答案8.1 一种贪婪策略是，选择可装入卡车剩余空间内的最大箱子，并重复这个过程，直到不能再装入箱子为止。使用这种算法不能得到最优解。 8.2 不断地挑选可在余下的时间内完成的价值最大的活动，直到余下的时间不够完成任何活动为止。使用这种算法不能得到最优解。 8.3 不是。8.4 是。8.5 是。8.6 是。8.7 是。8.8 是。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 狄克斯特拉算法]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%AC%AC7%E7%AB%A0-%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 继续图的讨论，介绍加权图——提高或降低某些边的权重。 介绍狄克斯特拉算法，让你能够找出加权图中前往X的最短路径。 介绍图中的环，它导致狄克斯特拉算法不管用。 在前一章，你找出了从A点到B点的路径。 这是最短路径，因为段数最少——只有三段，但不一定是最快路径。如果给这些路段加上时间，你将发现有更快的路径。 你在前一章使用了广度优先搜索，它找出的是段数最少的路径（如第一个图所示）。如果你要找出最快的路径（如第二个图所示），该如何办呢？为此，可使用另一种算法——狄克斯特拉算法（Dijkstra’s algorithm）。 使用狄克斯特拉算法下面来看看如何对下面的图使用这种算法。 其中每个数字表示的都是时间，单位分钟。为找出从起点到终点耗时最短的路径，你将使用狄克斯特拉算法。 如果你使用广度优先搜索，将得到下面这条段数最少的路径。 这条路径耗时7分钟。下面来看看能否找到耗时更短的路径！狄克斯特拉算法包含4个步骤。 (1) 找出“最便宜”的节点，即可在最短时间内到达的节点。 (2) 更新该节点的邻居的开销，其含义将稍后介绍。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。 第一步：找出最便宜的节点。你站在起点，不知道该前往节点A还是前往节点B。前往这两个节点都要多长时间呢？ 前往节点A需要6分钟，而前往节点B需要2分钟。至于前往其他节点，你还不知道需要多长时间。 由于你还不知道前往终点需要多长时间，因此你假设为无穷大（这样做的原因你马上就会明白）。节点B是最近的——2分钟就能达到。 第二步：计算经节点B前往其各个邻居所需的时间。 你刚找到了一条前往节点A的更短路径！直接前往节点A需要6分钟。 但经由节点B前往节点A只需5分钟！ 对于节点B的邻居，如果找到前往它的更短路径，就更新其开销。在这里，你找到了： 前往节点A的更短路径（时间从6分钟缩短到5分钟）； 前往终点的更短路径（时间从无穷大缩短到7分钟）。 第三步：重复！ 重复第一步：找出可在最短时间内前往的节点。你对节点B执行了第二步，除节点B外，可在最短时间内前往的节点是节点A。 重复第二步：更新节点A的所有邻居的开销。 你发现前往终点的时间为6分钟！ 你对每个节点都运行了狄克斯特拉算法（无需对终点这样做）。现在，你知道： 前往节点B需要2分钟； 前往节点A需要5分钟； 前往终点需要6分钟。 最后一步——计算最终路径将留到下一节去介绍，这里先直接将最终路径告诉你。 如果使用广度优先搜索，找到的最短路径将不是这条，因为这条路径包含3段，而有一条从起点到终点的路径只有两段。 在前一章，你使用了广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。 这里重述一下，狄克斯特拉算法包含4个步骤。 (1) 找出最便宜的节点，即可在最短时间内前往的节点。 (2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。（下一节再介绍！） 术语介绍其他狄克斯特拉算法使用示例前，先来澄清一些术语。 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。 带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。 要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。图还可能有环，而环类似右面这样。 这意味着你可从一个节点出发，走一圈后又回到这个节点。假设在下面这个带环的图中，你要找出从起点到终点的最短路径。 绕环前行是否合理呢？你可以选择避开环的路径。 也可选择包含环的路径。 这两条路径都可到达终点，但环增加了权重。如果你愿意，甚至可绕环两次。 但每绕环一次，总权重都增加8。因此，绕环的路径不可能是最短的路径。 最后，还记得第6章对有向图和无向图的讨论吗？ 无向图意味着两个节点彼此指向对方，其实就是环！ 在无向图中，每条边都是一个环。狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）。 换钢琴术语介绍得差不多了，我们再来看一个例子！这是Rama，想拿一本乐谱换架钢琴。 Alex说：“这是我最喜欢的乐队Destroyer的海报，我愿意拿它换你的乐谱。如果你再加5美元，还可拿乐谱换我这张稀有的Rick Astley黑胶唱片。”Amy说：“哇，我听说这张黑胶唱片里有首非常好听的歌曲，我愿意拿我的吉他或架子鼓换这张海报或黑胶唱片。” Beethoven惊呼：“我一直想要吉他，我愿意拿我的钢琴换Amy的吉他或架子鼓。” 太好了！只要再花一点点钱，Rama就能拿乐谱换架钢琴。现在他需要确定的是，如何花最少的钱实现这个目标。我们来绘制一个图，列出大家的交换意愿。 这个图中的节点是大家愿意拿出来交换的东西，边的权重是交换时需要额外加多少钱。拿海报换吉他需要额外加30美元，拿黑胶唱片换吉他需要额外加15美元。Rama需要确定采用哪种路径将乐谱换成钢琴时需要支付的额外费用最少。为此，可以使用狄克斯特拉算法！别忘了，狄克斯特拉算法包含四个步骤。在这个示例中，你将完成所有这些步骤，因此你也将计算最终路径。 动手之前，你需要做些准备工作：创建一个表格，在其中列出每个节点的开销。这里的开销指的是达到节点需要额外支付多少钱。 在执行狄克斯特拉算法的过程中，你将不断更新这个表。为计算最终路径，还需在这个表中添加表示父节点的列。 这列的作用将稍后介绍。我们开始执行算法吧。 第一步：找出最便宜的节点。在这里，换海报最便宜，不需要支付额外的费用。还有更便宜的换海报的途径吗？这一点非常重要，你一定要想一想。Rama能够通过一系列交换得到海报，还能额外得到钱吗？想清楚后接着往下读。答案是不能，因为海报是Rama能够到达的最便宜的节点，没法再便宜了。下面提供了另一种思考角度。假设你要从家里去单位。 如果你走经过学校的路，到学校需要2分钟。如果你走经过停车场的路，到停车场需要6分钟。如果经停车场前往学校，能不能将时间缩短到少于2分钟呢？不可能，因为只前往停车场就超过2分钟了。另一方面，有没有能更快到达停车场的路呢？有。 这就是狄克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径！ 回到换钢琴的例子。换海报需要支付的额外费用最少。 第二步：计算前往该节点的各个邻居的开销。 现在的表中包含低音吉他和架子鼓的开销。这些开销是用海报交换它们时需要支付的额外费用，因此父节点为海报。这意味着，要到达低音吉他，需要沿从海报出发的边前行，对架子鼓来说亦如此。 再次执行第一步：下一个最便宜的节点是黑胶唱片——需要额外支付5美元。 再次执行第二步：更新黑胶唱片的各个邻居的开销。 你更新了架子鼓和吉他的开销！这意味着经“黑胶唱片”前往“架子鼓”和“吉他”的开销更低，因此你将这些乐器的父节点改为黑胶唱片。 下一个最便宜的是吉他，因此更新其邻居的开销。 你终于计算出了用吉他换钢琴的开销，于是你将其父节点设置为吉他。最后，对最后一个节点——架子鼓，做同样的处理。 如果用架子鼓换钢琴，Rama需要额外支付的费用更少。因此，采用最便宜的交换路径时，Rama需要额外支付35美元。 现在来兑现前面的承诺，确定最终的路径。当前，我们知道最短路径的开销为35美元，但如何确定这条路径呢？为此，先找出钢琴的父节点。 钢琴的父节点为架子鼓，这意味着Rama需要用架子鼓来换钢琴。因此你就沿着这一边。 我们来看看需要沿哪些边前行。钢琴的父节点为架子鼓。 架子鼓的父节点为黑胶唱片。 因此Rama需要用黑胶唱片了换架子鼓。显然，他需要用乐谱来换黑胶唱片。通过沿父节点回溯，便得到了完整的交换路径。 下面是Rama需要做的一系列交换。 本章前面使用的都是术语最短路径的字面意思：计算两点或两人之间的最短路径。但希望这个示例让你明白：最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。在这个示例中，最短路径指的是Rama想要额外支付的费用最少。这都要归功于狄克斯特拉！ 负权边在前面的交换示例中，Alex提供了两种可用乐谱交换的东西。 假设黑胶唱片不是Alex的，而是Sarah的，且Sarah愿意用黑胶唱片和7美元换海报。换句话说，换得Alex的海报后，Rama用它来换Sarah的黑胶唱片时，不但不用支付额外的费用，还可得7美元。对于这种情况，如何在图中表示出来呢？ 从黑胶唱片到海报的边的权重为负！即这种交换让Rama能够得到7美元。现在，Rama有两种获得海报的方式。 第二种方式更划算——Rama可赚2美元！你可能还记得，Rama可以用海报换架子鼓，但现在有两种换得架子鼓的方式。 第二种方式的开销少2美元，他应采取这种方式。然而，如果你对这个图运行狄克斯特拉算法，Rama将选择错误的路径——更长的那条路径。如果有负权边，就不能使用狄克斯特拉算法。因为负权边会导致这种算法不管用。下面来看看对这个图执行狄克斯特拉算法的情况。首先，创建开销表。 接下来，找出开销最低的节点，并更新其邻居的开销。在这里，开销最低的节点是海报。根据狄克斯特拉算法，没有比不支付任何费用获得海报更便宜的方式。（你知道这并不对！）无论如何，我们来更新其邻居的开销。 现在，架子鼓的开销变成了35美元。 我们来找出最便宜的未处理节点。 更新其邻居的开销。 海报节点已处理过，这里却更新了它的开销。这是一个危险信号。节点一旦被处理，就意味着没有前往该节点的更便宜途径，但你刚才却找到了前往海报节点的更便宜途径！架子鼓没有任何邻居，因此算法到此结束，最终开销如下。 换得架子鼓的开销为35美元。你知道有一种交换方式只需33美元，但狄克斯特拉算法没有找到。这是因为狄克斯特拉算法这样假设：对于处理过的海报节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。因此，不能将狄克斯特拉算法用于包含负权边的图。在包含负权边的图中，要找出最短路径，可使用另一种算法——贝尔曼福德算法（Bellman-Ford algorithm）。本书不介绍这种算法，你可以在网上找到其详尽的说明。 实现下面来看看如何使用代码来实现狄克斯特拉算法，这里以下面的图为例。 要编写解决这个问题的代码，需要三个散列表。 随着算法的进行，你将不断更新散列表costs和parents。首先，需要实现这个图，为此可像第6章那样使用一个散列表。1graph = &#123;&#125; 在前一章中，你像下面这样将节点的所有邻居都存储在散列表中。1graph["you"] = ["alice", "bob", "claire"] 但这里需要同时存储邻居和前往邻居的开销。例如，起点有两个邻居——A和B。 如何表示这些边的权重呢？为何不使用另一个散列表呢？123graph["start"] = &#123;&#125;graph["start"]["a"] = 6graph["start"]["b"] = 2 因此 graph[“start”] 是一个散列表。要获取起点的所有邻居，可像下面这样做。12&gt;&gt;&gt; print graph["start"].keys()["a", "b"] 有一条从起点到A的边，还有一条从起点到B的边。要获悉这些边的权重，该如何办呢？1234&gt;&gt;&gt; print graph["start"]["a"]2&gt;&gt;&gt; print graph["start"]["b"]6 下面来添加其他节点及其邻居。123456graph["a"] = &#123;&#125;graph["a"]["fin"] = 1graph["b"] = &#123;&#125;graph["b"]["a"] = 3graph["b"]["fin"] = 5graph["fin"] = &#123;&#125; # 终点没有任何邻居 表示整个图的散列表类似于下面这样。 接下来，需要用一个散列表来存储每个节点的开销。 节点的开销指的是从起点出发前往该节点需要多长时间。你知道的，从起点到节点B需要2分钟，从起点到节点A需要6分钟（但你可能会找到所需时间更短的路径）。你不知道到终点需要多长时间。对于还不知道的开销，你将其设置为无穷大。在Python中能够表示无穷大吗？你可以这样做：1infinity = float("inf") 创建开销表的代码如下：12345infinity = float("inf")costs = &#123;&#125;costs["a"] = 6costs["b"] = 2costs["fin"] = infinity 还需要一个存储父节点的散列表： 创建这个散列表的代码如下：1234parents = &#123;&#125;parents["a"] = "start"parents["b"] = "start"parents["fin"] = None 最后，你需要一个数组，用于记录处理过的节点，因为对于同一个节点，你不用处理多次。1processed = [] 准备工作做好了，下面来看看算法。 我先列出代码，然后再详细介绍。代码如下。123456789101112node = find_lowest_cost_node(costs) # 在未处理的节点中找出开销最小的节点while node is not None: # 这个while循环在所有节点都被处理过后结束 cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): # 遍历当前节点的所有邻居 new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: # 如果经当前节点前往该邻居更近 costs[n] = new_cost # 就更新该邻居的开销 parents[n] = node # 同时将该邻居的父节点设置为当前节点 processed.append(node) # 将当前节点标记为处理过 node = find_lowest_cost_node(costs) # 找出接下来要处理的节点，并循环 这就是实现狄克斯特拉算法的Python代码！函数find_lowest_cost_node的代码稍后列出，我们先来看看这些代码的执行过程。 找出开销最低的节点。 获取该节点的开销和邻居。 遍历邻居。 每个节点都有开销。开销指的是从起点前往该节点需要多长时间。在这里，你计算从起点出发，经节点B前往节点A（而不是直接前往节点A）需要多长时间。 接下来对新旧开销进行比较。 找到了一条前往节点A的更短路径！因此更新节点A的开销。 这条新路径经由节点B，因此节点A的父节点改为节点B。 现在回到了for循环开头。下一个邻居是终点节点。 经节点B前往终点需要多长时间呢？ 需要7分钟。终点原来的开销为无穷大，比7分钟长。 设置终点节点的开销和父节点。 你更新了节点B的所有邻居的开销。现在，将节点B标记为处理过。 找出接下来要处理的节点。 获取节点A的开销和邻居。 节点A只有一个邻居：终点节点。 当前，前往终点需要7分钟。如果经节点A前往终点，需要多长时间呢？ 经节点A前往终点所需的时间更短！因此更新终点的开销和父节点。 处理所有的节点后，这个算法就结束了。希望前面对执行过程的详细介绍让你对这个算法有更深入的认识。函数 find_lowest_cost_node找出开销最低的节点，其代码非常简单，如下所示。12345678910def find_lowest_cost_node(costs): lowest_cost = float("inf") lowest_cost_node = None for node in costs: # 遍历所有的节点 cost = costs[node] if cost &lt; lowest_cost and node not in processed: # 如果当前节点的开销更低且未处理过， lowest_cost = cost # 就将其视为开销最低的节点 lowest_cost_node = node return lowest_cost_node 练习 1.在下面的各个图中，从起点到终点的最短路径的总权重分别是多少？ 小结 广度优先搜索用于在非加权图中查找最短路径。 狄克斯特拉算法用于在加权图中查找最短路径。 仅当权重为正时狄克斯特拉算法才管用。 如果图中包含负权边，请使用贝尔曼福德算法。 答案7.1 A为8；B为60；C使用狄克斯特拉算法无法找出最短路径，因为存在负权边。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 广度优先搜索]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%AC%AC6%E7%AB%A0-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习使用新的数据结构图来建立网络模型。 学习广度优先搜索，你可对图使用这种算法回答诸如“到X的最短路径是什么”等问题。 学习有向图和无向图。 学习拓扑排序，这种排序算法指出了节点之间的依赖关系。 本章将介绍图。首先，我将说说什么是图（它们不涉及X轴和Y轴），再介绍第一种图算法——广度优先搜索（breadth-first search，BFS）。 广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！使用广度优先搜索可以： 编写国际跳棋AI，计算最少走多少步就可获胜； 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方； 根据你的人际关系网络找到关系最近的医生。 在我所知道的算法中，图算法应该是最有用的。请务必仔细阅读接下来的几章，这些算法你将经常用到。 图简介假设你居住在旧金山，要从双子峰前往金门大桥。你想乘公交车前往，并希望换乘最少。可乘坐的公交车如下。 为找出换乘最少的乘车路线，你将使用什么样的算法？ 一步就能到达金门大桥吗？下面突出了所有一步就能到达的地方。 金门大桥未突出，因此一步无法到达那里。两步能吗？ 金门大桥也未突出，因此两步也到不了。三步呢？ 金门大桥突出了！因此从双子峰出发，可沿下面的路线三步到达金门大桥。 还有其他前往金门大桥的路线，但它们更远（需要四步）。这个算法发现，前往金门大桥的最短路径需要三步。这种问题被称为最短路径问题（shorterst-path problem）。你经常要找出最短路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。解决最短路径问题的算法被称为广度优先搜索。 要确定如何从双子峰前往金门大桥，需要两个步骤。 (1) 使用图来建立问题模型。 (2) 使用广度优先搜索解决问题。 下面介绍什么是图，然后再详细探讨广度优先搜索。 图是什么图模拟一组连接。例如，假设你与朋友玩牌，并要模拟谁欠谁钱，可像下面这样指出Alex欠Rama钱。 完整的欠钱图可能类似于下面这样。 指出谁欠谁钱的图 Alex欠Rama钱，Tom欠Adit钱，等等。图由节点（node）和边（edge）组成。 就这么简单！图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。在前面的欠钱图中，Rama是Alex的邻居。Adit不是Alex的邻居，因为他们不直接相连。但Adit既是Rama的邻居，又是Tom的邻居。 图用于模拟不同的东西是如何相连的。下面来看看广度优先搜索。 广度优先搜索第1章介绍了一种查找算法——二分查找。广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。 第一类问题：从节点A出发，有前往节点B的路径吗？ 第二类问题：从节点A出发，前往节点B的哪条路径最短？ 前面计算从双子峰前往金门大桥的最短路径时，你使用过广度优先搜索。这个问题属于第二类问题：哪条路径最短？下面来详细地研究这个算法，你将使用它来回答第一类问题：有路径吗？ 假设你经营着一个芒果农场，需要寻找芒果销售商，以便将芒果卖给他。在Facebook，你与芒果销售商有联系吗？为此，你可在朋友中查找。 这种查找很简单。首先，创建一个朋友名单。 然后，依次检查名单中的每个人，看看他是否是芒果销售商。 假设你没有朋友是芒果销售商，那么你就必须在朋友的朋友中查找。 检查名单中的每个人时，你都将其朋友加入名单。 这样一来，你不仅在朋友中查找，还在朋友的朋友中查找。别忘了，你的目标是在你的人际关系网中找到一位芒果销售商。因此，如果Alice不是芒果销售商，就将其朋友也加入到名单中。这意味着你将在她的朋友、朋友的朋友等中查找。使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。 查找最短路径再说一次，广度优先搜索可回答两类问题。 第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？） 第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？） 刚才你看到了如何回答第一类问题，下面来尝试回答第二类问题——谁是关系最近的芒果销售商。例如，朋友是一度关系，朋友的朋友是二度关系。 在你看来，一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。广度优先搜索就是这样做的！在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。顺便问一句：将先检查Claire还是Anuj呢？Claire是一度关系，而Anuj是二度关系，因此将先检查Claire，后检查Anuj。 你也可以这样看，一度关系在二度关系之前加入查找名单。 你按顺序依次检查名单中的每个人，看看他是否是芒果销售商。这将先在一度关系中查找，再在二度关系中查找，因此找到的是关系最近的芒果销售商。广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。 注意，只有按添加顺序查找时，才能实现这样的目的。换句话说，如果Claire先于Anuj加入名单，就需要先检查Claire，再检查Anuj。如果Claire和Anuj都是芒果销售商，而你先检查Anuj再检查Claire，结果将如何呢？找到的芒果销售商并非是与你关系最近的，因为Anuj是你朋友的朋友，而Claire是你的朋友。因此，你需要按添加顺序进行检查。有一个可实现这种目的的数据结构，那就是队列（queue）。 队列队列的工作原理与现实生活中的队列完全相同。假设你与朋友一起在公交车站排队，如果你排在他前面，你将先上车。队列的工作原理与此相同。队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队。 如果你将两个元素加入队列，先加入的元素将在后加入的元素之前出队。因此，你可使用队列来表示查找名单！这样，先加入的人将先出队并先被检查。 队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In First Out，LIFO）的数据结构。 知道队列的工作原理后，我们来实现广度优先搜索！ 练习 对于下面的每个图，使用广度优先搜索算法来找出答案。 1.找出从起点到终点的最短路径的长度。 2.找出从cab到bat的最短路径的长度。 实现图首先，需要使用代码来实现图。图由多个节点组成。 每个节点都与邻近节点相连，如果表示类似于“你→Bob”这样的关系呢？好在你知道的一种结构让你能够表示这种关系，它就是散列表！ 记住，散列表让你能够将键映射到值。在这里，你要将节点映射到其所有邻居。 表示这种映射关系的Python代码如下。12graph = &#123;&#125;graph["you"] = ["alice", "bob", "claire"] 注意，“你”被映射到了一个数组，因此graph[“you”]是一个数组，其中包含了“你”的所有邻居。 图不过是一系列的节点和边，因此在Python中，只需使用上述代码就可表示一个图。那像下面这样更大的图呢？ 表示它的Python代码如下。 123456789graph = &#123;&#125;graph["you"] = ["alice", "bob", "claire"]graph["bob"] = ["anuj", "peggy"]graph["alice"] = ["peggy"]graph["claire"] = ["thom", "jonny"]graph["anuj"] = []graph["peggy"] = []graph["thom"] = []graph["jonny"] = [] 顺便问一句：键 — 值对的添加顺序重要吗？换言之，如果你这样编写代码：12graph["claire"] = ["thom", "jonny"]graph["anuj"] = [] 而不是这样编写代码：12graph["anuj"] = []graph["claire"] = ["thom", "jonny"] 对结果有影响吗？ 只要回顾一下前一章介绍的内容，你就知道没影响。散列表是无序的，因此添加键 — 值对的顺序无关紧要。 Anuj、Peggy、Thom和Jonny都没有邻居，这是因为虽然有指向他们的箭头，但没有从他们出发指向其他人的箭头。这被称为有向图（directed graph），其中的关系是单向的。因此，Anuj是Bob的邻居，但Bob不是Anuj的邻居。无向图（undirected graph）没有箭头，直接相连的节点互为邻居。例如，下面两个图是等价的。 实现算法先概述一下这种算法的工作原理。 说 明更新队列时，我使用术语“入队”和“出队”，但你也可能遇到术语“压入”和“弹出”。压入大致相当于入队，而弹出大致相当于出队。 首先，创建一个队列。在Python中，可使用函数deque来创建一个双端队列。1234from collections import dequesearch_queue = deque() # 创建一个队列search_queue += graph["you"] # 将你的邻居都加入到这个搜索队列中 别忘了，graph[“you”]是一个数组，其中包含你的所有邻居，如[“alice”,”bob”,”claire”] 。这些邻居都将加入到搜索队列中。 下面来看看其他的代码。123456789while search_queue: #只要队列不为空 person = search_queue.popleft() # 就取出其中的第一个人 if person_is_seller(person): # 检查这个人是否是芒果销售商 print person + " is a mango seller!" # 是芒果销售商 return True else: search_queue += graph[person] # 不是芒果销售商。将这个人的朋友都加入搜索队列return False # 如果到达了这里，就说明队列中没人是芒果销售商 最后，你还需编写函数 person_is_seller ，判断一个人是不是芒果销售商，如下所示。12def person_is_seller(name): return name[-1] == 'm' 这个函数检查人的姓名是否以m结尾：如果是，他就是芒果销售商。这种判断方法有点搞笑，但就这个示例而言是可行的。下面来看看广度优先搜索的执行过程。 这个算法将不断执行，直到满足以下条件之一： 找到一位芒果销售商； 队列变成空的，这意味着你的人际关系网中没有芒果销售商。 Peggy既是Alice的朋友又是Bob的朋友，因此她将被加入队列两次：一次是在添加Alice的朋友时，另一次是在添加Bob的朋友时。因此，搜索队列将包含两个Peggy。 但你只需检查Peggy一次，看她是不是芒果销售商。如果你检查两次，就做了无用功。因此，检查完一个人后，应将其标记为已检查，且不再检查他。 如果不这样做，就可能会导致无限循环。假设你的人际关系网类似于下面这样。 一开始，搜索队列包含你的所有邻居。 现在你检查Peggy。她不是芒果销售商，因此你将其所有邻居都加入搜索队列。 接下来，你检查自己。你不是芒果销售商，因此你将你的所有邻居都加入搜索队列。 以此类推。这将形成无限循环，因为搜索队列将在包含你和包含Peggy之间反复切换。 检查一个人之前，要确认之前没检查过他，这很重要。为此，你可使用一个列表来记录检查过的人。 考虑到这一点后，广度优先搜索的最终代码如下。1234567891011121314151617def search(name): search_queue = deque() search_queue += graph[name] searched = [] # 这个数组用于记录检查过的人 while search_queue: person = search_queue.popleft() if not person in searched: # 仅当这个人没检查过时才检查 if person_is_seller(person): print person + " is a mango seller!" return True else: search_queue += graph[person] searched.append(person) # 将这个人标记为检查过 return Falsesearch("you") 请尝试运行这些代码，看看其输出是否符合预期。你也许应该将函数person_is_seller改为更有意义的名称。 运行时间 如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。 你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。 练习 下面的小图说明了我早晨起床后要做的事情。 该图指出，我不能没刷牙就吃早餐，因此“吃早餐”依赖于“刷牙”。 另一方面，洗澡不依赖于刷牙，因为我可以先洗澡再刷牙。根据这个图，可创建一个列表，指出我需要按什么顺序完成早晨起床后要做的事情： (1) 起床(2) 洗澡(3) 刷牙(4) 吃早餐 请注意，“洗澡”可随便移动，因此下面的列表也可行： (1) 起床(2) 刷牙(3) 洗澡(4) 吃早餐 1.请问下面的三个列表哪些可行、哪些不可行？ 2.下面是一个更大的图，请根据它创建一个可行的列表。 从某种程度上说，这种列表是有序的。如果任务A依赖于任务B，在列表中任务A就必须在任务B后面。这被称为拓扑排序，使用它可根据图创建一个有序列表。假设你正在规划一场婚礼，并有一个很大的图，其中充斥着需要做的事情，但却不知道要从哪里开始。这时就可使用拓扑排序来创建一个有序的任务列表。 假设你有一个家谱。 这是一个图，因为它由节点（人）和边组成。其中的边从一个节点指向其父母，但所有的边都往下指。在家谱中，往上指的边不合情理！因为你父亲不可能是你祖父的父亲！ 这种图被称为树。树是一种特殊的图，其中没有往后指的边。 3.请问下面哪个图也是树？ 小结 广度优先搜索指出是否有从A到B的路径。 如果有，广度优先搜索将找出最短路径。 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。 有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约会，而rachel也与ross约会”。 队列是先进先出（FIFO）的。 栈是后进先出（LIFO）的。 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。 对于检查过的人，务必不要再去检查，否则可能导致无限循环。 答案6.1 最短路径的长度为2。 6.2 最短路径的长度为2。 6.3 A不可行，B可行，C不可行。 6.4 1—起床，2—锻炼，3—洗澡，4—刷牙，5—穿衣服，6—打包午餐，7—吃早餐。 6.5 A是树，B不是树，C是树。C是一棵横着的树。树是图的子集，因此树都是图，但图可能是树，也可能不是。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 散列表]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%AC%AC5%E7%AB%A0-%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章将介绍其常见的用途。 学习散列表的内部机制：实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。 假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查找价格。如果本子的内容不是按字母顺序排列的，你可能为查找苹果（apple）的价格而浏览每一行，这需要很长的时间。此时你使用的是第1章介绍的简单查找，需要浏览每一行。还记得这需要多长时间吗？O(n)。如果本子的内容是按字母顺序排列的，可使用二分查找来找出苹果的价格，这需要的时间更短，为O(log n)。 需要提醒你的是，运行时间O(n)和O(log n)之间有天壤之别！假设你每秒能够看10行，使用简单查找和二分查找所需的时间将如下。 你知道，二分查找的速度非常快。但作为收银员，在本子中查找价格是件很痛苦的事情，哪怕本子的内容是有序的。在查找价格时，你都能感觉到顾客的怒气。看来真的需要一名能够记住所有商品价格的雇员，这样你就不用查找了：问她就能马上知道答案。 不管商品有多少，这位雇员（假设她的名字为Maggie）报出任何商品的价格的时间都为O(1)，速度比二分查找都快。 真是太厉害了！如何聘到这样的雇员呢？ 下面从数据结构的角度来看看。前面介绍了两种数据结构：数组和链表（其实还有栈，但栈并不能用于查找）。你可使用数组来实现记录商品价格的本子。 这种数组的每个元素包含两项内容：商品名和价格。如果将这个数组按商品名排序，就可使用二分查找在其中查找商品的价格。这样查找价格的时间将为O(log n)。然而，你希望查找商品价格的时间为O(1)，即你希望查找速度像Maggie那么快，这是散列函数的用武之地。 散列函数散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。 如果用专业术语来表达的话，我们会说，散列函数“将输入映射到数字”。你可能认为散列函数输出的数字没什么规律，但其实散列函数必须满足一些要求。 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。 它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。 散列函数将输入映射为数字，这有何用途呢？你可使用它来打造你的“Maggie”！ 为此，首先创建一个空数组。 你将在这个数组中存储商品的价格。下面来将苹果的价格加入到这个数组中。为此，将apple作为输入交给散列函数。 散列函数的输出为3，因此我们将苹果的价格存储到数组的索引3处。 下面将牛奶（milk）的价格存储到数组中。为此，将milk作为散列函数的输入。 散列函数的输出为0，因此我们将牛奶的价格存储在索引0处。 不断地重复这个过程，最终整个数组将填满价格。 现在假设需要知道鳄梨（avocado）的价格。你无需在数组中查找，只需将avocado作为输入交给散列函数。 它将告诉你鳄梨的价格存储在索引4处。果然，你在那里找到了。 散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这样，具体原因如下。 散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。 散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。 散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。 刚才你就打造了一个“Maggie”！你结合使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。 在你将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。散列表的速度很快！还记得第2章关于数组和链表的讨论吗？你可以立即获取数组中的元素，而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。 你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典，你可使用函数dict来创建散列表。1&gt;&gt;&gt; book = dict() # 一个空的散列表 创建散列表book后，在其中添加一些商品的价格。12345&gt;&gt;&gt; book["apple"] = 0.67 &gt;&gt;&gt; book["milk"] = 1.49&gt;&gt;&gt; book["avocado"] = 1.49&gt;&gt;&gt; print book&#123;'avocado': 1.49, 'apple': 0.67, 'milk': 1.49&#125; 非常简单！我们来查询鳄梨的价格。12&gt;&gt;&gt; print book["avocado"]1.49 散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键映射到值。 在下一节中，你将看到一些散列表使用示例。 练习 对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！ 请问下面哪些散列函数是一致的？ 1.f(x) = 1 &lt;-无论输入是什么，都返回1 2.f(x) = rand() &lt;-每次都返回一个随机数 3.f(x) = next_empty_slot() &lt;-返回散列表中下一个空位置的索引 4.f(x) = len(x) &lt;-将字符串的长度用作索引 应用案例散列表用途广泛，本节将介绍几个应用案例。 将散列表用于查找手机都内置了方便的电话簿，其中每个姓名都有对应的电话号码。 假设你要创建一个类似这样的电话簿，将姓名映射到电话号码。该电话簿需要提供如下功能。 添加联系人及其电话号码。 通过输入联系人来获悉其电话号码。 这非常适合使用散列表来实现！在下述情况下，使用散列表是很不错的选择。 创建映射。 查找。 创建电话簿非常容易。首先，新建一个散列表。1&gt;&gt;&gt; phone_book = dict() 顺便说一句，Python提供了一种创建散列表的快捷方式——使用一对大括号。1&gt;&gt;&gt; phone_book = &#123;&#125; # 与phone_book = dict()等效 下面在这个电话簿中添加一些联系人的电话号码。12&gt;&gt;&gt; phone_book["jenny"] = 8675309&gt;&gt;&gt; phone_book["emergency"] = 911 这就成了！现在，假设你要查找Jenny的电话号码，为此只需向散列表传入相应的键。12&gt;&gt;&gt; print phone_book["jenny"]8675309 # Jenny的电话号码 如果要求你使用数组来创建电话簿，你将如何做呢？散列表让你能够轻松地模拟映射关系。 散列表被用于大海捞针式的查找。例如，你在访问像http://adit.io这样的网站时，计算机必须将adit.io转换为IP地址。 无论你访问哪个网站，其网址都必须转换为IP地址。 这不是将网址映射到IP地址吗？好像非常适合使用散列表啰！这个过程被称为DNS解析（DNS resolution），散列表是提供这种功能的方式之一。 防止重复假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投票呢？有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。 如果名字在名单中，就说明这个人投过票了，因此将他拒之门外！否则，就将他的姓名加入到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。 每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办法，那就是使用散列表！ 为此，首先创建一个散列表，用于记录已投票的人。1&gt;&gt;&gt; voted = &#123;&#125; 有人来投票时，检查他是否在散列表中。1&gt;&gt;&gt; value = voted.get("tom") 如果“tom”在散列表中，函数get将返回它；否则返回None。你可使用这个函数检查来投票的人是否投过票！ 代码如下。12345678voted = &#123;&#125;def check_voter(name): if voted.get(name): print "kick them out!" else: voted[name] = True print "let them vote!" 我们来测试几次。123456&gt;&gt;&gt; check_voter("tom")let them vote!&gt;&gt;&gt; check_voter("mike")let them vote!&gt;&gt;&gt; check_voter("mike")kick them out! 首先来投票的是Tom，上述代码打印let them vote!。接着Mike来投票，打印的也是let them vote!。然后，Mike又来投票，于是打印的就是kick them out!。 别忘了，如果你将已投票者的姓名存储在列表中，这个函数的速度终将变得非常慢，因为它必须使用简单查找搜索整个列表。但这里将它们存储在了散列表中，而散列表让你能够迅速知道来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。 将散列表用作缓存来看最后一个应用案例：缓存。如果你在网站工作，可能听说过进行缓存是一种不错的做法。下面简要地介绍其中的原理。假设你访问网站facebook.com。 (1) 你向Facebook的服务器发出请求。 (2) 服务器做些处理，生成一个网页并将其发送给你。 (3) 你获得一个网页。 例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢！另一方面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器少做些工作，从而提高Facebook网站的访问速度呢？ 假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远？月球呢？木星呢？每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她老问你月球离地球多远，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她答案。这就是缓存的工作原理：网站将数据记住，而不再重新计算。 如果你登录了Facebook，你看到的所有内容都是为你定制的。你每次访问facebook.com，其服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到的登录页面都相同。Facebook被反复要求做同样的事情：“当我注销时，请向我显示主页。”有鉴于此，它不让服务器去生成主页，而是将主页存储起来，并在需要时将其直接发送给用户。 这就是缓存，具有如下两个优点。 用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。 Facebook需要做的工作更少。 缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！ Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多其他的页面。因此，它需要将页面URL映射到页面数据。 当你访问Facebook的页面时，它首先检查散列表中是否存储了该页面。 具体的代码如下。123456789cache = &#123;&#125;def get_page(url): if cache.get(url): return cache[url] # 返回缓存的数据 else: data = get_data_from_server(url) cache[url] = data # 先将数据保存到缓存中 return data 仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。 小结这里总结一下，散列表适合用于： 模拟映射关系； 防止重复； 缓存/记住数据，以免服务器再通过处理来生成它们。 冲突前面说过，大多数语言都提供了散列表实现，你不用知道如何实现它们。有鉴于此，我就不再过多地讨论散列表的内部原理，但你依然需要考虑性能！要明白散列表的性能，你得先搞清楚什么是冲突。本节和下一节将分别介绍冲突和性能。 首先，我撒了一个善意的谎。我之前告诉你的是，散列函数总是将不同的键映射到数组的不同位置。 实际上，几乎不可能编写出这样的散列函数。我们来看一个简单的示例。假设你有一个数组，它包含26个位置。 而你使用的散列函数非常简单，它按字母表顺序分配数组的位置。 你可能已经看出了问题。如果你要将苹果的价格存储到散列表中，分配给你的是第一个位置。 接下来，你要将香蕉的价格存储到散列表中，分配给你的是第二个位置。 一切顺利！但现在你要将鳄梨的价格存储到散列表中，分配给你的又是第一个位置。 不好，这个位置已经存储了苹果的价格！怎么办？这种情况被称为冲突（collision）：给两个键分配的位置相同。这是个问题。如果你将鳄梨的价格存储到这个位置，将覆盖苹果的价格，以后再查询苹果的价格时，得到的将是鳄梨的价格！冲突很糟糕，必须要避免。处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。 在这个例子中，apple和avocado映射到了同一个位置，因此在这个位置存储一个链表。在需要查询香蕉的价格时，速度依然很快。但在需要查询苹果的价格时，速度要慢些：你必须在相应的链表中找到apple。如果这个链表很短，也没什么大不了——只需搜索三四个元素。但是，假设你工作的杂货店只销售名称以字母A打头的商品。 等等！除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟糕：散列表的速度会很慢。 这里的经验教训有两个。 散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长！ 散列函数很重要，好的散列函数很少导致冲突。那么，如何选择好的散列函数呢？这将在下一节介绍！ 性能本章开头是假设你在杂货店工作。你想打造一个让你能够迅速获悉商品价格的工具，而散列表的速度确实很快。 在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。 二分查找的速度更快，所需时间为对数时间。 在散列表中查找所花费的时间为常量时间。 一条水平线，看到了吧？这意味着无论散列表包含一个元素还是10亿个元素，从其中获取数据所需的时间都相同。实际上，你以前见过常量时间——从数组中获取一个元素所需的时间就是固定的：不管数组多大，从中获取一个元素所需的时间都是相同的。在平均情况下，散列表的速度确实很快。 在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。我们来将散列表同数组和链表比较一下。 在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有： 较低的填装因子； 良好的散列函数。 说 明接下来的内容并非必读的，我将讨论如何实现散列表，但你根本就不需要这样做。不管你使用的是哪种编程语言，其中都内置了散列表实现。你可使用内置的散列表，并假定其性能良好。下面带你去看看幕后的情况。 填装因子散列表的填装因子很容易计算。 散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如，下述散列表的填装因子为2/5，即0.4。 下面这个散列表的填装因子为多少呢？ 如果你的答案为1/3，那就对了。填装因子度量的是散列表中有多少位置是空的。 假设你要在散列表中存储100种商品的价格，而该散列表包含100个位置。那么在最佳情况下，每个商品都将有自己的位置。 这个散列表的填装因子为1。如果这个散列表只有50个位置呢？填充因子将为2。不可能让每种商品都有自己的位置，因为没有足够的位置！填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing）。例如，假设有一个像下面这样相当满的散列表。 你就需要调整它的长度。为此，你首先创建一个更长的新数组：通常将数组增长一倍。 接下来，你需要使用函数 hash 将所有的元素都插入到这个新的散列表中。 这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。 你可能在想，调整散列表长度的工作需要很长时间！你说得没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即便考虑到调整长度所需的时间，散列表操作所需的时间也为O(1)。 良好的散列函数良好的散列函数让数组中的值呈均匀分布。 糟糕的散列函数让值扎堆，导致大量的冲突。 什么样的散列函数是良好的呢？你根本不用操心——天塌下来有高个子顶着。如果你好奇，可研究一下SHA函数（本书最后一章做了简要的介绍）。你可将它用作散列函数。 练习 散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。 假设你有四个处理字符串的散列函数。 A. 不管输入是什么，都返回1。 B. 将字符串的长度用作索引。 C. 将字符串的第一个字符用作索引。即将所有以a打头的字符串都映射到散列表的同一个位置，以此类推。 D. 将每个字符都映射到一个素数：a = 2，b = 3，c = 5，d = 7，e = 11，等等。对于给定的字符串，这个散列函数将其中每个字符对应的素数相加，再计算结果除以散列表长度的余数。例如，如果散列表的长度为10，字符串为 bag ，则索引为(3 + 2 + 17) % 10 = 22 % 10 = 2。 在下面的每个示例中，上述哪个散列函数可实现均匀分布？假设散列表的长度为10。 5.将姓名和电话号码分别作为键和值的电话簿，其中联系人姓名为Esther、Ben、Bob和Dan。 6.电池尺寸到功率的映射，其中电池尺寸为A、AA、AAA和AAAA。 6.书名到作者的映射，其中书名分别为Maus、Fun Home和Watchmen。 小结你几乎根本不用自己去实现散列表，因为你使用的编程语言提供了散列表实现。你可使用Python提供的散列表，并假定能够获得平均情况下的性能：常量时间。 散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。 你可能很快会发现自己经常在使用它。 你可以结合散列函数和数组来创建散列表。 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。 散列表的查找、插入和删除速度都非常快。 散列表适合用于模拟映射关系。 一旦填装因子超过0.7，就该调整散列表的长度。 散列表可用于缓存数据（例如，在Web服务器上）。 散列表非常适合用于防止重复。 答案5.1 一致。5.2 不一致。5.3 不一致。5.4 一致。5.5 散列函数C和D可实现均匀分布。5.6 散列函数B和D可实现均匀分布。5.7 散列函数B、C和D可实现均匀分布。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 快速排序]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%AC%AC4%E7%AB%A0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习分而治之。有时候，你可能会遇到使用任何已知的算法都无法解决的问题。优秀的算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。分而治之是你学习的第一种通用的问题解决方法。 学习快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。 前一章深入介绍了递归，本章的重点是使用学到的新技能来解决问题。我们将探索分而治之（divide and conquer，D&amp;C）——一种著名的递归式问题解决方法。 本书将深入算法的核心。只能解决一种问题的算法毕竟用处有限，而D&amp;C提供了解决问题的思路，是另一个可供你使用的工具。面对新问题时，你不再束手无策，而是自问：“使用分而治之能解决吗？” 在本章末尾，你将学习第一个重要的D&amp;C算法——快速排序。快速排序是一种排序算法，速度比第2章介绍的选择排序快得多，实属优雅代码的典范。 分而治之D&amp;C并不那么容易掌握，我将通过三个示例来介绍。首先，介绍一个直观的示例；然后，介绍一个代码示例，它不那么好看，但可能更容易理解；最后，详细介绍快速排序——一种使用D&amp;C的排序算法。 假设你是农场主，有一小块土地。 你要将这块地均匀地分成方块，且分出的方块要尽可能大。显然，下面的分法都不符合要求。 如何将一块地均匀地分成方块，并确保分出的方块是最大的呢？使用D&amp;C策略！D&amp;C算法是递归的。使用D&amp;C解决问题的过程包括两个步骤。 (1) 找出基线条件，这种条件必须尽可能简单。 (2) 不断将问题分解（或者说缩小规模），直到符合基线条件。 下面就来使用D&amp;C找出前述问题的解决方案。可你能使用的最大方块有多大呢？ 首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。 如果一边长25m，另一边长50m，那么可使用的最大方块为25m×25m。换言之，可以将这块地分成两个这样的方块。 现在需要找出递归条件，这正是D&amp;C的用武之地。根据D&amp;C的定义，每次递归调用都必须缩小问题的规模。如何缩小前述问题的规模呢？我们首先找出这块地可容纳的最大方块。 你可以从这块地中划出两个640m×640m的方块，同时余下一小块地。现在是顿悟时刻：何不对余下的那一小块地使用相同的算法呢？ 最初要划分的土地尺寸为1680m×640m，而现在要划分的土地更小，为640m×400m。适用于这小块地的最大方块，也是适用于整块地的最大方块。换言之，你将均匀划分1680m×640m土地的问题，简化成了均匀划分640m×400m土地的问题！ 欧几里得算法前面说“适用于这小块地的最大方块，也是适用于整块地的最大方块”，如果你觉得这一点不好理解，也不用担心。这确实不好理解，但遗憾的是，要证明这一点，需要的篇幅有点长，在本书中无法这样做，因此你只能选择相信这种说法是正确的。如果你想搞明白其中的原因，可参阅欧几里得算法。 下面再次使用同样的算法。对于640m×400m的土地，可从中划出的最大方块为400m×400m。 这将余下一块更小的土地，其尺寸为400m×240m。 你可从这块土地中划出最大的方块，余下一块更小的土地，其尺寸为240m×160m。 接下来，从这块土地中划出最大的方块，余下一块更小的土地。 余下的这块土地满足基线条件，因为160是80的整数倍。将这块土地分成两个方块后，将不会余下任何土地！ 因此，对于最初的那片土地，适用的最大方块为80m×80m。 这里重申一下D&amp;C的工作原理： (1) 找出简单的基线条件； (2) 确定如何缩小问题的规模，使其符合基线条件。 D&amp;C并非可用于解决问题的算法，而是一种解决问题的思路。我们再来看一个例子。 给定一个数字数组。 你需要将这些数字相加，并返回结果。使用循环很容易完成这种任务。 1234567def sum(arr): total = 0 for x in arr: total += x return totalprint sum([1, 2, 3, 4]) 但如何使用递归函数来完成这种任务呢？ 第一步：找出基线条件。最简单的数组什么样呢？请想想这个问题，再接着往下读。如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。 因此这就是基线条件。 第二步：每次递归调用都必须离空数组更近一步。如何缩小问题的规模呢？下面是一种办法。 这与下面的版本等效。 这两个版本的结果都为12，但在第二个版本中，给函数sum传递的数组更短。换言之，这缩小了问题的规模！ 函数sum的工作原理类似于下面这样。 这个函数的运行过程如下。 别忘了，递归记录了状态。 提 示 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。 函数式编程一瞥 你可能想，既然使用循环可轻松地完成任务，为何还要使用递归方式呢？看看函数式编程你就明白了！诸如Haskell等函数式编程语言没有循环，因此你只能使用递归来编写这样的函数。如果你对递归有深入的认识，函数式编程语言学习起来将更容易。例如，使用Haskell时，你可能这样编写函数sum。12sum [] = 0 # 基线条件sum (x:xs) = x + (sum xs) # 递归条件 注意，这就像是你有函数的两个定义。符合基线条件时运行第一个定义，符合递归条件时运行第二个定义。也可以使用Haskell语言中的if语句来编写这个函数。123sum arr = if arr == [] then 0 else (head arr) + (sum (tail arr)) 但前一个版本更容易理解。Haskell大量使用了递归，因此它提供了各种方便实现递归的语法。如果你喜欢递归或想学习一门新语言，可以研究一下Haskell。 练习 1.请编写前述sum函数的代码。 2.编写一个递归函数来计算列表包含的元素数。 3.找出列表中最大的数字。 4.还记得第1章介绍的二分查找吗？它也是一种分而治之算法。你能找出二分查找算法的基线条件和递归条件吗？ 快速排序快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。 下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢？还记得前一节的“提示”吗？就是根本不需要排序的数组。 因此，基线条件为数组为空或只包含一个元素。在这种情况下，只需原样返回数组——根本就不用排序。123def quicksort(array): if len(array) &lt; 2: return array 我们来看看更长的数组。对包含两个元素的数组进行排序也很容易。 包含三个元素的数组呢？ 别忘了，你要使用D&amp;C，因此需要将数组分解，直到满足基线条件。下面介绍快速排序的工作原理。首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。 稍后再介绍如何选择合适的基准值。我们暂时将数组的第一个元素用作基准值。 接下来，找出比基准值小的元素以及比基准值大的元素。 这被称为分区（partitioning）。现在你有： 一个由所有小于基准值的数字组成的子数组； 基准值； 一个由所有大于基准值的数组组成的子数组。 这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。 如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组 + 基准值 +右边的数组。在这里，就是[10, 15] + [33] + []，结果为有序数组[10, 15, 33]。 如何对子数组进行排序呢？对于包含两个元素的数组（左边的子数组）以及空数组（右边的子数组），快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！12quicksort([15, 10]) + [33] + quicksort([])&gt; [10, 15, 33] # 一个有序数组 不管将哪个元素用作基准值，这都管用。假设你将15用作基准值。 这个子数组都只有一个元素，而你知道如何对这些数组进行排序。现在你就知道如何对包含三个元素的数组进行排序了，步骤如下。 (1) 选择基准值。 (2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。 (3) 对这两个子数组进行快速排序。 包含四个元素的数组呢？ 假设你也将33用作基准值。 左边的子数组包含三个元素，而你知道如何对包含三个元素的数组进行排序：对其递归地调用快速排序。 因此你能够对包含四个元素的数组进行排序。如果能够对包含四个元素的数组进行排序，就能对包含五个元素的数组进行排序。为什么呢？假设有下面这样一个包含五个元素的数组。 根据选择的基准值，对这个数组进行分区的各种可能方式如下。 注意，这些子数组包含的元素数都在0～4内，而你已经知道如何使用快速排序对包含0～4个元素的数组进行排序！因此，不管如何选择基准值，你都可对划分得到的两个子数组递归地进行快速排序。 例如，假设你将3用作基准值，可对得到的子数组进行快速排序。 将子数组排序后，将它们合并，得到一个有序数组。即便你将5用作基准值，这也可行。 将任何元素用作基准值都可行，因此你能够对包含五个元素的数组进行排序。同理，你能够对包含六个元素的数组进行排序，以此类推。 归纳证明刚才你大致见识了归纳证明！归纳证明是一种证明算法行之有效的方式，它分两步：基线条件和归纳条件。是不是有点似曾相识的感觉？例如，假设我要证明我能爬到梯子的最上面。递归条件是这样的：如果我站在一个横档上，就能将脚放到下一个横档上。换言之，如果我站在第二个横档上，就能爬到第三个横档。这就是归纳条件。而基线条件是这样的，即我已经站在第一个横档上。因此，通过每次爬一个横档，我就能爬到梯子最顶端。对于快速排序，可使用类似的推理。在基线条件中，我证明这种算法对空数组或包含一个元素的数组管用。在归纳条件中，我证明如果快速排序对包含一个元素的数组管用，对包含两个元素的数组也将管用；如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用，以此类推。因此，我可以说，快速排序对任何长度的数组都管用。这里不再深入讨论归纳证明，但它很有趣，并与D&amp;C协同发挥作用。 下面是快速排序的代码。123456789101112def quicksort(array): if len(array) &lt; 2: return array # 基线条件：为空或只包含一个元素的数组是“有序”的 else: pivot = array[0] # 递归条件 less = [i for i in array[1:] if i &lt;= pivot] # 由所有小于基准值的元素组成的子数组 greater = [i for i in array[1:] if i &gt; pivot] # 由所有大于基准值的元素组成的子数组 return quicksort(less) + [pivot] + quicksort(greater)print quicksort([10, 5, 2, 3]) 再谈大O表示法快速排序的独特之处在于，其速度取决于选择的基准值。在讨论快速排序的运行时间前，我们再来看看最常见的大O运行时间。 上述图表中的时间是基于每秒执行10次操作计算得到的。这些数据并不准确，这里提供它们只是想让你对这些运行时间的差别有大致认识。实际上，计算机每秒执行的操作远不止10次。 对于每种运行时间，本书还列出了相关的算法。来看看第2章介绍的选择排序，其运行时间为O(n2)，速度非常慢。 还有一种名为合并排序（merge sort）的排序算法，其运行时间为O(n log n)，比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。 与选择排序一样慢！但这是最糟情况。在平均情况下，快速排序的运行时间为O(n log n)。你可能会有如下疑问。 这里说的最糟情况和平均情况是什么意思呢？ 若快速排序在平均情况下的运行时间为O(n log n)，而合并排序的运行时间总是O(n log n)，为何不使用合并排序？它不是更快吗？ 比较合并排序和快速排序假设有下面这样打印列表中每个元素的简单函数。123def print_items(list): for item in list: print item 这个函数遍历列表中的每个元素并将其打印出来。它迭代整个列表一次，因此运行时间为O(n)。现在假设你对这个函数进行修改，使其在打印每个元素前都休眠1秒钟。123456from time import sleepdef print_items2(list): for item in list: sleep(1) print item 它在打印每个元素前都暂停1秒钟。假设你使用这两个函数来打印一个包含5个元素的列表。 这两个函数都迭代整个列表一次，因此它们的运行时间都为O(n)。你认为哪个函数的速度更快呢？我认为print_items要快得多，因为它没有在每次打印元素前都暂停1秒钟。因此，虽然使用大O表示法表示时，这两个函数的速度相同，但实际上print_items的速度更快。在大O表示法O(n)中，n实际上指的是这样的。 c是算法所需的固定时间量，被称为常量。例如，print_items所需的时间可能是10毫秒*n，而print_items2所需的时间为1秒*n。 通常不考虑这个常量，因为如果两种算法的大O运行时间不同，这种常量将无关紧要。就拿二分查找和简单查找来举例说明。假设这两种算法的运行时间包含如下常量。 你可能认为，简单查找的常量为10毫秒，而二分查找的常量为1秒，因此简单查找的速度要快得多。现在假设你要在包含40亿个元素的列表中查找，所需时间将如下。 正如你看到的，二分查找的速度还是快得多，常量根本没有什么影响。 但有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。快速查找的常量比合并查找小，因此如果它们的运行时间都为O(n log n)，快速查找的速度将更快。实际上，快速查找的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多。 此时你可能会问，何为平均情况，何为最糟情况呢？ 平均情况和最糟情况快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。 注意，数组并没有被分成两半，相反，其中一个子数组始终为空，这导致调用栈非常长。现在假设你总是将中间的元素用作基准值，在这种情况下，调用栈如下。 调用栈短得多！因为你每次都将数组分成两半，所以不需要那么多递归调用。你很快就到达了基线条件，因此调用栈短得多。 第一个示例展示的是最糟情况，而第二个示例展示的是最佳情况。在最糟情况下，栈长为O(n)，而在最佳情况下，栈长为O(log n)。 现在来看看栈的第一层。你将一个元素用作基准值，并将其他的元素划分到两个子数组中。这涉及数组中的全部8个元素，因此该操作的时间为O(n)。在调用栈的第一层，涉及全部8个元素，但实际上，在调用栈的每层都涉及O(n)个元素。 即便以不同的方式划分数组，每次也将涉及O(n)个元素。 因此，完成每层所需的时间都为O(n)。 在这个示例中，层数为O(log n)（用技术术语说，调用栈的高度为O(log n)），而每层需要的时间为O(n)。因此整个算法需要的时间为O(n) * O(log n) = O(n log n)。这就是最佳情况。 在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) * O(n) = O(n2)。 知道吗？这里要告诉你的是，最佳情况也是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为O(n log n)。快速排序是最快的排序算法之一，也是D&amp;C典范。 练习 5.使用大O表示法时，下面各种操作都需要多长时间？ 6.打印数组中每个元素的值。 7.将数组中每个元素的值都乘以2。 8.只将数组中第一个元素的值乘以2。 9.根据数组包含的元素创建一个乘法表，即如果数组为[2, 3, 7, 8, 10]，首先将每个元素都乘以2，再将每个元素都乘以3，然后将每个元素都乘以7，以此类推。 小结 D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。 答案4.11234def sum(list): if list == []: return 0 return list[0] + sum(list[1:]) 4.21234def count(list): if list == []: return 0 return 1 + count(list[1:]) 4.312345def max(list): if len(list) == 2: return list[0] if list[0] &gt; list[1] else list[1] sub_max = max(list[1:]) return list[0] if list[0] &gt; sub_max else sub_max 4.4 二分查找的基线条件是数组只包含一个元素。如果要查找的值与这个元素相同，就找到了！否则，就说明它不在数组中。 在二分查找的递归条件中，你把数组分成两半，将其中一半丢弃，并对另一半执行二分查找。 4.5 O(n)。4.6 O(n)。4.7 O(1)。4.8 O(n2)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 递归]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%AC%AC3%E7%AB%A0-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。怎么理解？ 本章内容 学习递归。递归是很多算法都使用的一种编程方法。 学习如何将问题分成基线条件和递归条件。第4章将介绍的分而治之策略使用这种简单的概念来解决棘手的问题。 递归假设你发现了一个上锁的神秘手提箱。这个盒子里有盒子，而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙，你将使用什么算法？先想想这个问题，再接着往下看。 下面是一种方法。 (1) 创建一个要查找的盒子堆。 (2) 从盒子堆取出一个盒子，在里面找。 (3) 如果找到的是盒子，就将其加入盒子堆中，以便以后再查找。 (4) 如果找到钥匙，则大功告成！ (5) 回到第二步。 下面是另一种方法。 (1) 检查盒子中的每样东西。 (2) 如果是盒子，就回到第一步。 (3) 如果是钥匙，就大功告成！ 在你看来，哪种方法更容易呢？第一种方法使用的是while循环：只要盒子堆不空，就从中取一个盒子，并在其中仔细查找。123456789def look_for_key(main_box): pile = main_box.make_a_pile_to_look_through() while pile is not empty: box = pile.grab_a_box() for item in box: if item.is_a_box(): pile.append(item) elif item.is_a_key(): print "found the key!" 第二种方法使用递归——函数调用自己，这种方法的伪代码如下。123456def look_for_key(box): for item in box: if item.is_a_box(): look_for_key(item) # 递归！ elif item.is_a_key(): print "found the key!" 这两种方法的作用相同，但在我看来，第二种方法更清晰。递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。我很喜欢Stack Overflow上的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。” 基线条件和递归条件由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。例如，假设你要编写一个像下面这样倒计时的函数。1&gt; 3...2...1 为此，你可以用递归的方式编写，如下所示。123def countdown(i): print i countdown(i-1) 如果你运行上述代码，将发现一个问题：这个函数运行起来没完没了！（要让脚本停止运行，可按Ctrl+C。）1&gt; 3...2...1...0...-1...-2... 编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。 我们来给函数 countdown 添加基线条件。123456def countdown(i): print i if i &lt;= 0: # 基线条件 return else: # 递归条件 countdown(i-1) 现在，这个函数将像预期的那样运行。 栈本节将介绍一个重要的编程概念——调用栈（call stack）。调用栈不仅对编程来说很重要，使用递归时也必须理解这个概念。 假设你去野外烧烤，并为此创建了一个待办事项清单——一叠便条。 本书之前讨论数组和链表时，也有一个待办事项清单。你可将待办事项添加到该清单的任何地方，还可删除任何一个待办事项。一叠便条要简单得多：插入的待办事项放在清单的最前面；读取待办事项时，你只读取最上面的那个，并将其删除。因此这个待办事项清单只有两种操作：压入（插入）和弹出（删除并读取）。 下面来看看如何使用这个待办事项清单。 这种数据结构称为栈。栈是一种简单的数据结构，刚才我们一直在使用它，却没有意识到！ 调用栈计算机在内部使用被称为调用栈的栈。我们来看看计算机是如何使用调用栈的。下面是一个简单的函数。12345def greet(name): print "hello, " + name + "!" greet2(name) print "getting ready to say bye..." bye() 这个函数问候用户，再调用另外两个函数。这两个函数的代码如下。12345def greet2(name): print "how are you, " + name + "?"def bye(): print "ok bye!" 下面详细介绍调用函数时发生的情况。 说 明在Python中，print是一个函数，但出于简化考虑，这里假设它不是函数。你也这样假设就行了。 假设你调用greet(“maggie”)，计算机将首先为该函数调用分配一块内存。 我们来使用这些内存。变量name被设置为maggie，这需要存储到内存中。 每当你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来，你打印hello,maggie!，再调用greet2(“maggie”)。同样，计算机也为这个函数调用分配一块内存。 计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。你打印how are you, maggie?，然后从函数调用返回。此时，栈顶的内存块被弹出。 现在，栈顶的内存块是函数greet的，这意味着你返回到了函数greet。当你调用函数greet2时，函数greet只执行了一部分。这是本节的一个重要概念：调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。执行完函数greet2后，你回到函数greet，并从离开的地方开始接着往下执行：首先打印getting ready to say bye…，再调用函数bye。 在栈顶添加了函数bye的内存块。然后，你打印ok bye!，并从这个函数返回。 现在你又回到了函数greet。由于没有别的事情要做，你就从函数greet返回。这个栈用于存储多个函数的变量，被称为调用栈。 练习 1.根据下面的调用栈，你可获得哪些信息？ 下面来看看递归函数的调用栈。 递归调用栈递归函数也使用调用栈！来看看递归函数factorial的调用栈。factorial(5)写作5!，其定义如下：5! = 5 * 4 * 3 * 2 * 1。同理， factorial(3) 为3 * 2 * 1。下面是计算阶乘的递归函数。12345def fact(x): if x == 1: return 1 else: return x * fact(x-1) 下面来详细分析调用fact(3)时调用栈是如何变化的。别忘了，栈顶的方框指出了当前执行到了什么地方。 注意，每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。 栈在递归中扮演着重要角色。在本章开头的示例中，有两种寻找钥匙的方法。下面再次列出了第一种方法。 使用这种方法时，你创建一个待查找的盒子堆，因此你始终知道还有哪些盒子需要查找。 但使用递归方法时，没有盒子堆。 既然没有盒子堆，那算法怎么知道还有哪些盒子需要查找呢？下面是一个例子。 此时，调用栈类似于下面这样。 原来“盒子堆”存储在了栈中！这个栈包含未完成的函数调用，每个函数调用都包含还未检查完的盒子。使用栈很方便，因为你无需自己跟踪盒子堆——栈替你这样做了。 使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。 重新编写代码，转而使用循环。 使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言都支持尾递归。 练习 2.假设你编写了一个递归函数，但不小心导致它没完没了地运行。正如你看到的，对于每次函数调用，计算机都将为其在栈中分配内存。递归函数没完没了地运行时，将给栈带来什么影响？ 小结 递归指的是调用自己的函数。 每个递归函数都有两个条件：基线条件和递归条件。 栈有两种操作：压入和弹出。 所有函数调用都进入调用栈。 调用栈可能很长，这将占用大量的内存。 答案3.1 下面是一些你可获得的信息。 首先调用了函数greet，并将参数name的值指定为maggie。 接下来，函数greet调用了函数greet2 ，并将参数name的值指定为maggie。 此时函数greet处于未完成（挂起）状态。 当前的函数调用为函数greet2。 这个函数执行完毕后，函数greet将接着执行。 3.2 栈将不断地增大。每个程序可使用的调用栈空间都有限，程序用完这些空间（终将如此）后，将因栈溢出而终止。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 选择排序]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%AC%AC2%E7%AB%A0-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 算法运行时间是从其增速的角度度量的。怎么理解？ 随机访问和顺序访问分别是什么数据结构的访问方式？ 链表的优势在插入元素方面， 本章内容 学习两种最基本的数据结构——数组和链表，它们无处不在。第1章使用了数组，其他各章几乎也都将用到数组。数组是个重要的主题，一定要高度重视！但在有些情况下，使用链表比使用数组更合适。本章阐述数组和链表的优缺点，让你能够根据要实现的算法选择合适的一个。 学习第一种排序算法。很多算法仅在数据经过排序后才管用。还记得二分查找吗？它只能用于有序元素列表。本章将介绍选择排序。很多语言都内置了排序算法，因此你基本上不用从头开始编写自己的版本。但选择排序是下一章将介绍的快速排序的基石。快速排序是一种重要的算法，如果你熟悉其他排序算法，理解起来将更容易。 内存的工作原理假设你去看演出，需要将东西寄存。寄存处有一个柜子，柜子有很多抽屉。每个抽屉可放一样东西，你有两样东西要寄存，因此要了两个抽屉。你将两样东西存放在这里。现在你可以去看演出了！这大致就是计算机内存的工作原理。计算机就像是很多抽屉的集合体，每个抽屉都有地址。 fe0ffeeb是一个内存单元的地址。 需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。接下来介绍数组和链表以及它们的优缺点。 数组和链表有时候，需要在内存中存储一系列元素。假设你要编写一个管理待办事项的应用程序，为此需要将这些待办事项存储在内存中。 应使用数组还是链表呢？鉴于数组更容易掌握，我们先将待办事项存储在数组中。使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。 现在假设你要添加第四个待办事项，但后面的那个抽屉放着别人的东西！ 这就像你与朋友去看电影，找到地方就坐后又来了一位朋友，但原来坐的地方没有空位置，只得再找一个可坐下所有人的地方。在这种情况下，你需要请求计算机重新分配一块可容纳4个待办事项的内存，再将所有待办事项都移到那里。 如果又来了一位朋友，而当前坐的地方也没有空位，你们就得再次转移！真是太麻烦了。同样，在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。这是一个不错的权变措施，但你应该明白，它存在如下两个缺点。 你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。 待办事项超过10个后，你还得转移。 因此，这种权宜措施虽然不错，但绝非完美的解决方案。对于这种问题，可使用链表来解决。 链表链表中的元素可存储在内存的任何地方。 链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。 串在一起的内存地址 这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。 使用链表时，根本就不需要移动元素。这还可避免另一个问题。假设你与五位朋友去看一部很火的电影。你们六人想坐在一起，但看电影的人较多，没有六个在一起的座位。使用数组时有时就会遇到这样的情况。假设你要为数组分配10 000个位置，内存中有10 000个位置，但不都靠在一起。在这种情况下，你将无法为该数组分配内存！链表相当于说“我们分开来坐”，因此，只要有足够的内存空间，就能为链表分配内存。 链表的优势在插入元素方面，那数组的优势又是什么呢？ 数组排行榜网站使用卑鄙的手段来增加页面浏览量。它们不在一个页面中显示整个排行榜，而将排行榜的每项内容都放在一个页面中，并让你单击Next来查看下一项内容。例如，显示十大电视反派时，不在一个页面中显示整个排行榜，而是先显示第十大反派（Newman）。你必须在每个页面中单击Next，才能看到第一大反派（Gustavo Fring）。这让网站能够在10个页面中显示广告，但用户需要单击Next九次才能看到第一个，真的是很烦。如果整个排行榜都显示在一个页面中，将方便得多。这样，用户可单击排行榜中的人名来获得更详细的信息。 链表存在类似的问题。在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。 数组与此不同：你知道其中每个元素的地址。例如，假设有一个数组，它包含五个元素，起始地址为00，那么元素#5的地址是多少呢？ 只需执行简单的数学运算就知道：04。需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。 术语数组的元素带编号，编号从0而不是1开始。例如，在下面的数组中，元素20的位置为1。 而元素10的位置为0。这通常会让新手晕头转向。从0开始让基于数组的代码编写起来更容易，因此程序员始终坚持这样做。几乎所有的编程语言都从0开始对数组元素进行编号。你很快就会习惯这种做法。 元素的位置称为索引。因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书将使用索引来表示位置。 下面列出了常见的数组和链表操作的运行时间。 问题：在数组中插入元素时，为何运行时间为O(n)呢？假设要在数组开头插入一个元素，你将如何做？这需要多长时间？请阅读下一节，找出这些问题的答案！ 练习 1.假设你要编写一个记账的应用程序。 你每天都将所有的支出记录下来，并在月底统计支出，算算当月花了多少钱。因此，你执行的插入操作很多，但读取操作很少。该使用数组还是链表呢？ 在中间插入假设你要让待办事项按日期排列。之前，你在清单末尾添加了待办事项。 但现在你要根据新增待办事项的日期将其插入到正确的位置。 需要在中间插入元素时，数组和链表哪个更好呢？使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。 而使用数组时，则必须将后面的元素都向后移。 如果没有足够的空间，可能还得将整个数组复制到其他地方！因此，当需要在中间插入元素时，链表是更好的选择。 删除如果你要删除元素呢？链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移。 不同于插入，删除元素总能成功。如果内存中没有足够的空间，插入操作可能失败，但在任何情况下都能够将元素删除。 下面是常见数组和链表操作的运行时间。 需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O(1)。通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O(1)。查找并删除还是O(n)，因为要查找。 数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持随机访问。有两种访问方式：随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。数组和链表还被用来实现其他数据结构，这将在本书后面介绍。 练习 2.假设你要为饭店创建一个接受顾客点菜单的应用程序。这个应用程序存储一系列点菜单。服务员添加点菜单，而厨师取出点菜单并制作菜肴。这是一个点菜单队列：服务员在队尾添加点菜单，厨师取出队列开头的点菜单并制作菜肴。 你使用数组还是链表来实现这个队列呢？（提示：链表擅长插入和删除，而数组擅长随机访问。在这个应用程序中，你要执行的是哪些操作呢？） 3.我们来做一个思考实验。假设Facebook记录一系列用户名，每当有用户试图登录Facebook时，都查找其用户名，如果找到就允许用户登录。由于经常有用户登录Facebook，因此需要执行大量的用户名查找操作。假设Facebook使用二分查找算法，而这种算法要求能够随机访问——立即获取中间的用户名。考虑到这一点，应使用数组还是链表来存储用户名呢？ 4.经常有用户在Facebook注册。假设你已决定使用数组来存储用户名，在插入方面数组有何缺点呢？具体地说，在数组中添加新用户将出现什么情况？ 5.实际上，Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用的是一种混合数据：链表数组。这个数组包含26个元素，每个元素都指向一个链表。例如，该数组的第一个元素指向的链表包含所有以A打头的用户名，第二个元素指向的链表包含所有以B打头的用户名，以此类推。 假设Adit B在Facebook注册，而你需要将其加入前述数据结构中。因此，你访问数组的第一个元素，再访问该元素指向的链表，并将Adit B添加到这个链表末尾。现在假设你要查找Zakhir H。因此你访问第26个元素，再在它指向的链表（该链表包含所有以z打头的用户名）中查找Zakhir H。 请问，相比于数组和链表，这种混合数据结构的查找和插入速度更慢还是更快？你不必给出大O运行时间，只需指出这种新数据结构的查找和插入速度更快还是更慢。 选择排序有了前面的知识，你就可以学习第二种算法——选择排序了。要理解本节的内容，你必须熟悉数组、链表和大O表示法。 假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。 你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？ 一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。 再次这样做，找出播放次数第二多的乐队。 继续这样做，你将得到一个有序列表。 下面从计算机科学的角度出发，看看这需要多长时间。别忘了，O(n)时间意味着查看列表中的每个元素一次。例如，对乐队列表进行简单查找时，意味着每个乐队都要查看一次。 要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。 需要的总时间为O(n×n)，即O(n2)。 排序算法很有用。你现在可以对如下内容进行排序： 电话簿中的人名 旅行日期 电子邮件（从新到旧） 需要检查的元素数越来越少随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。既然如此，运行时间怎么还是O(n2)呢？这个问题问得好，这与大O表示法中的常数相关。第4章将详细解释，这里只简单地说一说。你说得没错，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素数依次为n-1, n-2, …, 2和1。平均每次检查的元素数为1/2×n，因此运行时间为O(n× 1/2×n)。但大O表示法省略诸如1/2这样的常数（有关这方面的完整讨论，请参阅第4章），因此简单地写作O(n×n)或O(n2)。 选择排序是一种灵巧的算法，但其速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n)，这将在下一章介绍。 示例代码 前面没有列出对乐队进行排序的代码，但下述代码提供了类似的功能：将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。 123456789def findSmallest(arr): smallest = arr[0] # 存储最小的值 smallest_index = 0 # 存储最小元素的索引 for i in range(1, len(arr)): if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_index 现在可以使用这个函数来编写选择排序算法了。12345678def selectionSort(arr): # 对数组进行排序 newArr = [] for i in range(len(arr)): smallest = findSmallest(arr) # 找出数组中最小的元素，并将其加入到新数组中 newArr.append(arr.pop(smallest))return newArrprint selectionSort([5, 3, 6, 2, 10]) 小结 计算机内存犹如一大堆抽屉。 需要存储多个元素时，可使用数组或链表。 数组的元素都在一起。 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。 数组的读取速度很快。 链表的插入和删除速度很快。 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。 答案2.1 在这里，你每天都在列表中添加支出项，但每月只读取支出一次。数组的读取速度快，而插入速度慢；链表的读取速度慢，而插入速度快。由于你执行的插入操作比读取操作多，因此使用链表更合适。另外，仅当你要随机访问元素时，链表的读取速度才慢。鉴于你要读取所有的元素，在这种情况下，链表的读取速度也不慢。因此，对这个问题来说，使用链表是不错的解决方案。 2.2 使用链表。经常要执行插入操作（服务员添加点菜单），而这正是链表擅长的。不需要执行（数组擅长的）查找和随机访问操作，因为厨师总是从队列中取出第一个点菜单。 2.3 有序数组。数组让你能够随机访问——立即获取数组中间的元素，而使用链表无法这样做。要获取链表中间的元素，你必须从第一个元素开始，沿链接逐渐找到这个元素。 2.4 数组的插入速度很慢。另外，要使用二分查找算法来查找用户名，数组必须是有序的。假设有一个名为Adit B的用户在Facebook注册，其用户名将插入到数组末尾，因此每次插入用户名后，你都必须对数组进行排序！ 2.5 查找时，其速度比数组慢，但比链表快；而插入时，其速度比数组快，但与链表相当。因此，其查找速度比数组慢，但在各方面都不比链表慢。本书后面将介绍另一种混合数据结构——散列表。这个练习应该能让你对如何使用简单数据结构创建复杂的数据结构有大致了解。 Facebook实际使用的是什么呢？很可能是十多个数据库，它们基于众多不同的数据结构：散列表、B树等。数组和链表是这些更复杂的数据结构的基石。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Kernel]]></title>
    <url>%2F2020%2F05%2F28%2FLaravel-Kernel%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 接口 \Illuminate\Contracts\Http\Kernel.php 1234567891011121314151617181920212223242526272829303132333435namespace Illuminate\Contracts\Http;interface Kernel&#123; /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap(); /** * Handle an incoming HTTP request. * * @param \Symfony\Component\HttpFoundation\Request $request * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request); /** * 在请求生命周期中执行所有最终操作。 * * @param \Symfony\Component\HttpFoundation\Request $request * @param \Symfony\Component\HttpFoundation\Response $response * @return void */ public function terminate($request, $response); /** * Get the Laravel application instance. * * @return \Illuminate\Contracts\Foundation\Application */ public function getApplication();&#125; KernelFoundation 地基 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace Illuminate\Foundation\Http;use Illuminate\Contracts\Debug\ExceptionHandler;use Illuminate\Contracts\Foundation\Application;use Illuminate\Contracts\Http\Kernel as KernelContract;use Illuminate\Foundation\Http\Events\RequestHandled;use Illuminate\Routing\Pipeline;use Illuminate\Routing\Router;use Illuminate\Support\Facades\Facade;use InvalidArgumentException;use Throwable;class Kernel implements KernelContract&#123; protected $app; protected $route; protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class, ]; protected $middleware = []; protected $middlewareGroups = []; protected $routeMiddleware = []; protected $middlewarePriority = [ \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \Illuminate\Contracts\Auth\Middleware\AuthenticatesRequests::class, \Illuminate\Routing\Middleware\ThrottleRequests::class, \Illuminate\Session\Middleware\AuthenticateSession::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, \Illuminate\Auth\Middleware\Authorize::class, ]; public function __construct(Application $app, Router $router) &#123; $this-&gt;app = $app; $this-&gt;router = $router; $this-&gt;syncMiddlewareToRouter(); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model模型关系加载与查询]]></title>
    <url>%2F2020%2F05%2F28%2FLaravel-Database-Eloquent-Model%E6%A8%A1%E5%9E%8B%E5%85%B3%E7%B3%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言我们在上一篇文章中介绍了模型关系的定义初始化，我们可以看到，在初始化的过程中Laravel已经为各种关联关系的模型预先插入了初始的where条件。本文将会进一步介绍如何添加自定义的查询条件，如何加载、预加载关联模型。 关联模型的加载当我们定义关联模型后： 12345678910class User extends Model&#123; /** * 获得与用户关联的电话记录。 */ public function phone() &#123; $this-&gt;hasOne('App\Phone', 'user_id', 'id'); &#125;&#125; 我们可以像成员变量一样来获取与之关联的模型：123456$user = App\User::find(1);foreach ($user-&gt;posts as $post) &#123; //&#125; 实际上，模型的属性获取函数的确可以加载关联模型：12345678910public function getAttribute($key)&#123; if (! $key) &#123; return; &#125; ... return $this-&gt;getRelationValue($key);&#125; getRelationValue函数专用于加载我们之前定义的关联模型：123456789101112131415161718192021222324252627282930313233/** * Get a relationship. * * @param string $key * @return mixed */public function getRelationValue($key)&#123; // If the key already exists in the relationships array, it just means the // relationship has already been loaded, so we'll just return it out of // here because there is no need to query within the relations twice. if ($this-&gt;relationLoaded($key)) &#123; return $this-&gt;relations[$key]; &#125; // If the "attribute" exists as a method on the model, we will just assume // it is a relationship and will load and return results from the query // and hydrate the relationship's value on the "relationships" array. if (method_exists($this, $key)) &#123; return $this-&gt;getRelationshipFromMethod($key); &#125;&#125;/** * Determine if the given relation is loaded. * * @param string $key * @return bool */public function relationLoaded($key)&#123; return array_key_exists($key, $this-&gt;relations);&#125; 可以看到，关联的加载带有缓存，Laravel首先会验证当前关联关系是否已经被加载，如果加载过，那么直接返回缓存结果。12345678910111213141516171819202122232425262728/** * Get a relationship value from a method. * * @param string $method * @return mixed * * @throws \LogicException */protected function getRelationshipFromMethod($method)&#123; $relation = $this-&gt;$method(); if (! $relation instanceof Relation) &#123; if (is_null($relation)) &#123; throw new LogicException(sprintf( '%s::%s must return a relationship instance, but "null" was returned. Was the "return" keyword used?', static::class, $method )); &#125; throw new LogicException(sprintf( '%s::%s must return a relationship instance.', static::class, $method )); &#125; return tap($relation-&gt;getResults(), function ($results) use ($method) &#123; $this-&gt;setRelation($method, $results); &#125;);&#125; 当我们调用$user-&gt;posts语句的时候，Laravel会调用posts函数，该函数开始定义关联关系，并且返回hasOne对象，在这里将会调用getResults函数来加载关联模型：12345678910111213/** * Get the results of the relationship. * * @return mixed */public function getResults()&#123; if (is_null($this-&gt;getParentKey())) &#123; return $this-&gt;getDefaultFor($this-&gt;parent); &#125; return $this-&gt;query-&gt;first() ?: $this-&gt;getDefaultFor($this-&gt;parent);&#125; getDefaultFor函数用于在未查询到任何关联模型时的情况。我们在定义关联的时候，可以提供默认的方法来控制返回的结果：12345678910111213141516public function user()&#123; return $this-&gt;belongsTo('App\User')-&gt;withDefault();&#125;public function user()&#123; return $this-&gt;belongsTo('App\User')-&gt;withDefault(['name' =&gt; '游客',]);&#125;public function user()&#123; return $this-&gt;belongsTo('App\User')-&gt;withDefault(function ($user) &#123; $user-&gt;name = '游客'; &#125;);&#125; withDefault可以提供空值、数组、闭包函数等等选项，getDefaultFor函数在关联没有查询到结果的时候，按要求返回一个模型：12345678910111213141516171819202122232425262728293031323334353637/** * Return a new model instance in case the relationship does not exist. * * @param \Closure|array|bool $callback * @return $this */public function withDefault($callback = true)&#123; $this-&gt;withDefault = $callback; return $this;&#125;/** * Get the default value for this relation. * * @param \Illuminate\Database\Eloquent\Model $parent * @return \Illuminate\Database\Eloquent\Model|null */protected function getDefaultFor(Model $parent)&#123; if (! $this-&gt;withDefault) &#123; return; &#125; $instance = $this-&gt;newRelatedInstanceFor($parent); if (is_callable($this-&gt;withDefault)) &#123; return call_user_func($this-&gt;withDefault, $instance, $parent) ?: $instance; &#125; if (is_array($this-&gt;withDefault)) &#123; $instance-&gt;forceFill($this-&gt;withDefault); &#125; return $instance;&#125; 获取到关联模型后，就要放入缓存当中，以备后续情况使用：12345678910111213/** * Set the given relationship on the model. * * @param string $relation * @param mixed $value * @return $this */public function setRelation($relation, $value)&#123; $this-&gt;relations[$relation] = $value; return $this;&#125; 多对多关系的加载多对多关系的加载与一对多等关系的加载有所不同，原因是不仅要加载related模型，还要加载中间表模型：123456789101112131415161718192021222324252627282930313233343536373839404142/** * Get the results of the relationship. * * @return mixed */public function getResults()&#123; return ! is_null($this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;) ? $this-&gt;get() : $this-&gt;related-&gt;newCollection();&#125;/** * Execute the query as a "select" statement. * * @param array $columns * @return \Illuminate\Database\Eloquent\Collection */public function get($columns = ['*'])&#123; // First we'll add the proper select columns onto the query so it is run with // the proper columns. Then, we will get the results and hydrate out pivot // models with the result of those columns as a separate model relation. $builder = $this-&gt;query-&gt;applyScopes(); $columns = $builder-&gt;getQuery()-&gt;columns ? [] : $columns; $models = $builder-&gt;addSelect( $this-&gt;shouldSelect($columns) )-&gt;getModels(); $this-&gt;hydratePivotRelation($models); // If we actually found models we will also eager load any relationships that // have been specified as needing to be eager loaded. This will solve the // n + 1 query problem for the developer and also increase performance. if (count($models) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $this-&gt;related-&gt;newCollection($models);&#125; shouldSelect函数加载了中间表的字段属性：123456789101112131415161718192021222324252627282930/** * Set the select clause for the relation query. * * @param array $columns * @return array */protected function shouldSelect(array $columns = ['*'])&#123; if ($columns == ['*']) &#123; $columns = [$this-&gt;related-&gt;getTable().'.*']; &#125; return array_merge($columns, [$this-&gt;getQualifiedFirstKeyName().' as laravel_through_key']);&#125;/** * Get the pivot columns for the relation. * * "pivot_" is prefixed ot each column for easy removal later. * * @return array */protected function aliasedPivotColumns()&#123; $defaults = [$this-&gt;foreignPivotKey, $this-&gt;relatedPivotKey]; return collect(array_merge($defaults, $this-&gt;pivotColumns))-&gt;map(function ($column) &#123; return $this-&gt;table.'.'.$column.' as pivot_'.$column; &#125;)-&gt;unique()-&gt;all();&#125; 可以看到，这个时候，中间表的属性会被放入related模型中，并且会被赋予别名前缀pivot_。 接着hydratePivotRelation会将这些中间表属性加载到中间表模型中：1234567891011121314151617181920212223242526272829303132333435363738394041/** * Hydrate the pivot table relationship on the models. * * @param array $models * @return void */protected function hydratePivotRelation(array $models)&#123; // To hydrate the pivot relationship, we will just gather the pivot attributes // and create a new Pivot model, which is basically a dynamic model that we // will set the attributes, table, and connections on it so it will work. foreach ($models as $model) &#123; $model-&gt;setRelation($this-&gt;accessor, $this-&gt;newExistingPivot( $this-&gt;migratePivotAttributes($model) )); &#125;&#125;/** * Get the pivot attributes from a model. * * @param \Illuminate\Database\Eloquent\Model $model * @return array */protected function migratePivotAttributes(Model $model)&#123; $values = []; foreach ($model-&gt;getAttributes() as $key =&gt; $value) &#123; // To get the pivots attributes we will just take any of the attributes which // begin with "pivot_" and add those to this arrays, as well as unsetting // them from the parent's models since they exist in a different table. if (strpos($key, 'pivot_') === 0) &#123; $values[substr($key, 6)] = $value; unset($model-&gt;$key); &#125; &#125; return $values;&#125; accessor默认值为pivot，我们也可以在定义多对多的时候使用as函数为它取别名：1return $this-&gt;belongsToMany('App\Role')-&gt;as(‘role_user’); 源码：123456789101112/** * Specify the custom pivot accessor to use for the relationship. * * @param string $accessor * @return $this */public function as($accessor)&#123; $this-&gt;accessor = $accessor; return $this;&#125; 关联模型的预加载with函数当作为属性访问Eloquent关联时，关联数据是「懒加载」的。意味着在你第一次访问该属性时，才会加载关联数据。不过，当你查询父模型时，Eloquent还可以进行「预加载」关联数据。预加载避免了N + 1查询问题。 预加载可以一次操作中预加载关联模型并且自定义用于select的列，可以预加载几个不同的关联，还可以预加载嵌套关联，预加载关联数据的时候，为查询指定额外的约束条件： 1234567$books = App\Book::with(['author:id,name'])-&gt;get();$books = App\Book::with(['author', 'publisher'])-&gt;get();$books = App\Book::with('author.contacts')-&gt;get();$users = App\User::with(['posts' =&gt; function ($query) &#123; $query-&gt;where('title', 'like', '%first%');&#125;])-&gt;get(); 我们来看看with函数：123456789101112/** * Begin querying a model with eager loading. * * @param array|string $relations * @return \Illuminate\Database\Eloquent\Builder */public static function with($relations)&#123; return static::query()-&gt;with( is_string($relations) ? func_get_args() : $relations );&#125; 预加载调用Eloquent/builder的with函数： 1234567891011121314/** * Set the relationships that should be eager loaded. * * @param mixed $relations * @return $this */public function with($relations)&#123; $eagerLoad = $this-&gt;parseWithRelations(is_string($relations) ? func_get_args() : $relations); $this-&gt;eagerLoad = array_merge($this-&gt;eagerLoad, $eagerLoad); return $this;&#125; eagerLoad成员变量用于存放预加载的关联关系，parseWithRelations用于解析关联关系：12345678910111213141516171819202122232425262728293031323334/** * Parse a list of relations into individuals. * * @param array $relations * @return array */protected function parseWithRelations(array $relations)&#123; $results = []; foreach ($relations as $name =&gt; $constraints) &#123; // If the "name" value is a numeric key, we can assume that no constraints // have been specified. We will just put an empty Closure there so that // we can treat these all the same while we are looping through them. if (is_numeric($name)) &#123; $name = $constraints; [$name, $constraints] = Str::contains($name, ':') ? $this-&gt;createSelectWithConstraint($name) : [$name, static function () &#123; // &#125;]; &#125; // We need to separate out any nested includes, which allows the developers // to load deep relationships using "dots" without stating each level of // the relationship with its own key in the array of eager-load names. $results = $this-&gt;addNestedWiths($name, $results); $results[$name] = $constraints; &#125; return $results;&#125; 当我们在模型关系中写入:符合的时候，说明我们不想select *，而是想要只查询特定的字段，createSelectWithConstraint：123456789101112/** * Create a constraint to select the given columns for the relation. * * @param string $name * @return array */protected function createSelectWithConstraint($name)&#123; return [explode(':', $name)[0], static function ($query) use ($name) &#123; $query-&gt;select(explode(',', explode(':', $name)[1])); &#125;];&#125; 也就是为关联关系添加select条件。 当我们想要进行嵌套查询的时候，需要在关联关系中写下“.”，addNestedWiths： 1234567891011121314151617181920212223242526/** * Parse the nested relationships in a relation. * * @param string $name * @param array $results * @return array */protected function addNestedWiths($name, $results)&#123; $progress = []; // If the relation has already been set on the result array, we will not set it // again, since that would override any constraints that were already placed // on the relationships. We will only set the ones that are not specified. foreach (explode('.', $name) as $segment) &#123; $progress[] = $segment; if (! isset($results[$last = implode('.', $progress)])) &#123; $results[$last] = static function () &#123; // &#125;; &#125; &#125; return $results;&#125; 可以看到，addNestedWiths为嵌套的模型关系赋予默认的空闭包函数，例如a.b.c，addNestedWiths返回的results数组中会有三个成员:a、a.b、a.b.c，这三个变量的闭包函数都是空。 接下来，parseWithRelations为a.b.c的闭包函数重新赋值，将用户定义的约束条件赋予给a.b.c。 get函数预加载with函数为Laravel提供了需要预加载的关联关系，get函数在从数据库中获取父模型的数据后，会将需要预加载的模型也一并取出来：12345678910public function get($columns = ['*'])&#123; $builder = $this-&gt;applyScopes(); if (count($models = $builder-&gt;getModels($columns)) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $builder-&gt;getModel()-&gt;newCollection($models);&#125; 顾名思义eagerLoadRelations函数就是获取预加载模型的的函数：12345678910111213public function eagerLoadRelations(array $models)&#123; foreach ($this-&gt;eagerLoad as $name =&gt; $constraints) &#123; // For nested eager loads we'll skip loading them here and they will be set as an // eager load on the query to retrieve the relation so that they will be eager // loaded on that query, because that is where they gethydrated as models. if (strpos($name, '.') === false) &#123; $models = $this-&gt;eagerLoadRelation($models, $name, $constraints); &#125; &#125; return $models;&#125; 在这里，很让人费解的是if条件，这个条件语句看起来排除了嵌套预加载关系。例如上面的a.b.c，eagerLoadRelations 只会加载a这个关联关系。 其实原因是： 1// For nested eager loads we&apos;ll skip loading them here and they will be set as an eager load on the query to retrieve the relation so that they will be eager loaded on that query, because that is where they get hydrated as models. 翻译过来就是说，嵌套预加载要一步一步的来，第一次只加载a，获得了a的关联模型之后，第二次再加载b，最后加载c。这里看不懂没关系，答案在下面的代码中：1234567891011protected function eagerLoadRelation(array $models, $name, Closure $constraints)&#123; $relation = $this-&gt;getRelation($name); $relation-&gt;addEagerConstraints($models); $constraints($relation); return $relation-&gt;match( $relation-&gt;initRelation($models, $name), $relation-&gt;getEager(), $name );&#125; eagerLoadRelation 是预加载关联关系的核心，我们可以看到加载关联模型关系主要有四个步骤： 通过关系名来调用hasOne等函数来加载模型关系relation 利用models来为模型关系添加约束条件 调用with函数附带的约束条件 从数据库获取关联模型并匹配到各个父模型中，作为父模型的属性 我们先从调用关联函数getRelation来说： getRelation123456789101112131415161718public function getRelation($name)&#123; $relation = Relation::noConstraints(function () use ($name)&#123; try &#123; return $this-&gt;getModel()-&gt;&#123;$name&#125;(); &#125; catch (BadMethodCallException $e) &#123; throw RelationNotFoundException::make($this-&gt;getModel(), $name); &#125; &#125;); $nested = $this-&gt;relationsNestedUnder($name); if (count($nested) &gt; 0) &#123; $relation-&gt;getQuery()-&gt;with($nested); &#125; return $relation;&#125; 我们在上一个文章说过， hasOne 等函数会自动加约束条件例如：select phone where phone.user_id = user.id但是这个约束条件并不适用于预加载，因为预加载的父模型通常不只只一个。因此需要调用函数 noConstraints 来避免加载约束条件:12345678910public static function noConstraints(Closure $callback)&#123; $previous = static::$constraints; static::$constraints = false; try &#123; return call_user_func($callback); &#125; finally &#123; static::$constraints = $previous; &#125;&#125; 接下来，就要调用定义关联的函数：return $this-&gt;getModel()-&gt;{$name}();下面的 relationsNestedUnder 函数用于加载嵌套的预加载关联关系：123456789101112131415protected function relationsNestedUnder($relation)&#123; $nested = []; foreach ($this-&gt;eagerLoad as $name =&gt; $constraints) &#123; if ($this-&gt;isNestedUnder($relation, $name)) &#123; $nested[substr($name, strlen($relation.'.'))] = $constraints; &#125; &#125; return $nested;&#125;protected function isNestedUnder($relation, $name)&#123; return Str::contains($name, '.') &amp;&amp; Str::startsWith($name, $relation.'.');&#125; 从代码上可以看出来，如果当前的模型关系是 a ， relationsNestedUnder函数会把其嵌套的关系都检测出来： a.b 、 a.b.c ，并且放入 nested 数组中： nested[b]、nested[b.c] 。接下来：123if (count($nested) &gt; 0) &#123; $relation-&gt;getQuery()-&gt;with($nested);&#125; 就会继续递归预加载关联关系。关联关系预加载约束条件获得关联关系之后，就要加载各个关联关系自己的预加载约束条件：123456public function addEagerConstraints(array $models)&#123; $this-&gt;query-&gt;whereIn( $this-&gt;foreignKey, $this-&gt;getKeys($models, $this-&gt;localKey) );&#125; 也就是从父模型的外键来为关联模型添加 where 条件。当然各个关联关系不同，这个函数也有一定的区别。with 预加载约束条件接下来还有加载 with 函数的约束条件 ：$constraints($relation);匹配父模型当关联关系的约束条件都设置完毕后，就要从数据库中来获取关联模型：123456789$relation-&gt;match( $relation-&gt;initRelation($models, $name), $relation-&gt;getEager(), $name);public function getEager()&#123; return $this-&gt;get();&#125; initRelation 会为父模型设置默认的关联模型：1234567public function initRelation(array $models, $relation)&#123;foreach ($models as $model) &#123;$model-&gt;setRelation($relation, $this-&gt;getDefaultFor($model));&#125;return $models;&#125; 两步都做好了，接下来就要为父模型和子模型进行匹配了：1234567891011121314151617181920212223public function match(array $models, Collection $results, $relation)&#123; return $this-&gt;matchOne($models, $results, $relation);&#125;public function matchOne(array $models, Collection $results, $relation)&#123; return $this-&gt;matchOneOrMany($models, $results, $relation, 'one');&#125;protected function matchOneOrMany(array $models, Collection $results, $relation, $type)&#123; $dictionary = $this-&gt;buildDictionary($results); foreach ($models as $model) &#123; if (isset($dictionary[$key = $model-&gt;getAttribute($this-&gt;localKey)])) &#123; $model-&gt;setRelation( $relation, $this-&gt;getRelationValue($dictionary, $key, $type) ); &#125; &#125; return $models;&#125; 匹配的过程分为两步：创建目录 buildDictionary 和设置子模型setRelation ：123456789protected function buildDictionary(Collection $results)&#123; $dictionary = []; $foreign = $this-&gt;getForeignKeyName(); foreach ($results as $result) &#123; $dictionary[$result-&gt;&#123;$foreign&#125;][] = $result; &#125; return $dictionary;&#125; 创建目录buildDictionary函数根据子模型的外键foreign将子模型进行分类，拥有同一外键的子模型放入同一个数组中。接下来，为父模型设置子模型： 12345678910111213foreach ($models as $model) &#123; if (isset($dictionary[$key = $model-&gt;getAttribute($this-&gt;localKey)])) &#123; $model-&gt;setRelation( $relation, $this-&gt;getRelationValue($dictionary, $key, $type) ); &#125;&#125;protected function getRelationValue(array $dictionary, $key, $type)&#123; $value = $dictionary[$key]; return $type == 'one' ? reset($value) : $this-&gt;related-&gt;newCollection($value);&#125; 如果目录dictionary中存在父模型的主键，就会从目录中取出对应的子模型数组，并利用setRelation来为父模型设置关联模型。 关联模型的关联查询基于存在的关联查询官方样例：12345678910// 获得所有至少有一条评论的文章...$posts = App\Post::has('comments')-&gt;get();// 获得所有有三条或三条以上评论的文章...$posts = Post::has('comments', '&gt;=', 3)-&gt;get();// 获得所有至少有一条获赞评论的文章...$posts = Post::has('comments.votes')-&gt;get();// 获得所有至少有一条评论内容满足 foo% 条件的文章$posts = Post::whereHas('comments', function ($query) &#123;$query-&gt;where('content', 'like', 'foo%');&#125;)-&gt;get(); has 函数用于基于存在的关联查询：123456789101112131415161718public function has($relation, $operator = '&gt;=', $count = 1, $boolean = 'and', Closure $callback = null)&#123;if (strpos($relation, '.') !== false) &#123;return $this-&gt;hasNested($relation, $operator, $count, $boolean, $callback);&#125;$relation = $this-&gt;getRelationWithoutConstraints($relation);$method = $this-&gt;canUseExistsForExistenceCheck($operator, $count)? 'getRelationExistenceQuery': 'getRelationExistenceCountQuery';$hasQuery = $relation-&gt;&#123;$method&#125;($relation-&gt;getRelated()-&gt;newQuery(), $this);if ($callback) &#123;$hasQuery-&gt;callScope($callback);&#125;return $this-&gt;addHasWhere($hasQuery, $relation, $operator, $count, $boolean);&#125; has函数的步骤： 获取无约束的关联关系 为关联关系添加existence约束 为关联关系添加has外部约束 将关联关系添加到where条件中 无约束的关联关系123456protected function getRelationWithoutConstraints($relation)&#123;return Relation::noConstraints(function () use ($relation) &#123;return $this-&gt;getModel()-&gt;&#123;$relation&#125;();&#125;);&#125; 这个不用多说，和预加载的原理一样。existence 约束关系模型的 existence 约束条件很简单：select * from post where user.id = post.user_idLaravel 还考虑一种特殊情况，那就是自己关联自己，这个时候就会为模型命名一个新的 hash ：1select * from user as wedfklk where user.id = wedfklk.foreignKey 源代码比较简单：123456789101112131415161718192021222324252627public function getRelationExistenceQuery(Builder $query, Builder $parentQuery, $columns = ['*'])&#123;if ($query-&gt;getQuery()-&gt;from == $parentQuery-&gt;getQuery()-&gt;from) &#123;return $this-&gt;getRelationExistenceQueryForSelfRelation($query, $parentQuery, $columns);&#125;return parent::getRelationExistenceQuery($query, $parentQuery, $columns);&#125;public function getRelationExistenceQueryForSelfRelation(Builder$query, Builder $parentQuery, $columns = ['*'])&#123;$query-&gt;from($query-&gt;getModel()-&gt;getTable().' as '.$hash = $this-&gt;getRelationCountHash());$query-&gt;getModel()-&gt;setTable($hash);return $query-&gt;select($columns)-&gt;whereColumn($this-&gt;getQualifiedParentKeyName(), '=', $hash.'.'.$this-&gt;getForeignKeyName());&#125;public function getRelationExistenceQuery(Builder $query, Builder $parentQuery, $columns = ['*'])&#123;return $query-&gt;select($columns)-&gt;whereColumn($this-&gt;getQualifiedParentKeyName(), '=', $this-&gt;getExistenceCompareKey());&#125;public function getExistenceCompareKey()&#123;return $this-&gt;getQualifiedForeignKeyName();&#125; ExistenceCount 约束ExistenceCount 约束只是 select 变成了 select count(\) :1234567select count(\*) from post where user.id = post.user_id源代码：```phppublic function getRelationExistenceCountQuery(Builder $query, Builder $parentQuery)&#123; return $this-&gt;getRelationExistenceQuery($query, $parentQuery, new Expression('count(*)'));&#125; 关联关系添加到 where 条件当关联关系的 存在 约束设置完毕后，就要加载到父模型的 where 条件中，一般会作为父模型的子查询：123456789101112131415161718192021222324protected function addHasWhere(Builder $hasQuery, Relation $relation, $operator, $count, $boolean)&#123; $hasQuery-&gt;mergeConstraintsFrom($relation-&gt;getQuery()); return $this-&gt;canUseExistsForExistenceCheck($operator, $count) ? $this-&gt;addWhereExistsQuery($hasQuery-&gt;toBase(), $boolean, $operator === '&lt;' &amp;&amp; $count === 1) : $this-&gt;addWhereCountQuery($hasQuery-&gt;toBase(), $operator, $count, $boolean);&#125;public function addWhereExistsQuery(Builder $query, $boolean = 'and', $not = false)&#123; $type = $not ? 'NotExists' : 'Exists'; $this-&gt;wheres[] = compact('type', 'operator', 'query', 'boolean'); $this-&gt;addBinding($query-&gt;getBindings(), 'where'); return $this;&#125;protected function addWhereCountQuery(QueryBuilder $query, $operator = '&gt;=', $count = 1, $boolean = 'and')&#123; $this-&gt;query-&gt;addBinding($query-&gt;getBindings(), 'where'); return $this-&gt;where(new Expression('('.$query-&gt;toSql().')'),$operator,is_numeric($count) ? new Expression($count) : $count,$boolean );&#125; existence 约束最后条件：1select * from user where exists (select * from phone where phone.user_id=user.id) ExistenceCount 约束:1select * from user where (select count(*) from phone where phone.user_id=user.id) &gt;= 3 嵌套查询嵌套查询需要进行递归来调用has函数：12345678910111213141516protected function hasNested($relations, $operator = '&gt;=', $count = 1, $boolean = 'and', $callback = null)&#123;$relations = explode('.', $relations);$closure = function ($q) use (&amp;$closure, &amp;$relations, $operator, $count, $callback) &#123;count($relations) &gt; 1? $q-&gt;whereHas(array_shift($relations), $closure): $q-&gt;has(array_shift($relations), $operator, $count, 'and', $callback);&#125;;return $this-&gt;has(array_shift($relations), '&gt;=', 1, $boolean, $closure);&#125;public function whereHas($relation, Closure $callback = null, $operator = '&gt;=', $count = 1)&#123;return $this-&gt;has($relation, $operator, $count, 'and', $callback);&#125; 例如1$posts = Post::has('comments.votes')-&gt;get(); 首先 hasNested 会返回：1234$this-&gt;has('comments', '&gt;=', 1, 'and', function ($q) use (&amp;$closure, ‘votes’, '&gt;=', 1, $callback) &#123;$q-&gt;has(‘votes’, '&gt;=', 1, 'and', $callback);&#125;); 生成的sql：1select * from post where exist (select * from comment where comment.post_id=post.id and where exist (select * from vote where vote.comment_id=comment.id)) 基于不存在的关联查询基于不存在的关联查询只是基于存在的关联查询123456789101112131415161718192021222324/** * Add a relationship count / exists condition to the query. * * @param string $relation * @param string $boolean * @param \Closure|null $callback * @return \Illuminate\Database\Eloquent\Builder|static */public function doesntHave($relation, $boolean = 'and', Closure $callback = null)&#123; return $this-&gt;has($relation, '&lt;', 1, $boolean, $callback);&#125;/** * Add a relationship count / exists condition to the query with where clauses. * * @param string $relation * @param \Closure|null $callback * @return \Illuminate\Database\Eloquent\Builder|static */public function whereDoesntHave($relation, Closure $callback = null)&#123; return $this-&gt;doesntHave($relation, 'and', $callback);&#125; 关联数据计数 如果您只想统计结果数而不需要加载实际数据，那么可以使用 withCount 方法，此方法会在您的结果集模型中添加一个 {关联名}_count 字段。例如：1234567891011121314151617181920212223$posts = App\Post::withCount('comments')-&gt;get();//select *,(select count(*) from comment where comment.post_id=post.id) as comments_count from postforeach ($posts as $post) &#123; echo $post-&gt;comments_count;&#125;//多个关联数据「计数」，并为其查询添加约束条件：$posts = Post::withCount(['votes', 'comments' =&gt; function ($query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;])-&gt;get();//select *,(select count(*) from comment where comment.post_id=post.id and content like 'foo%') as comments_count,(select count(*) from votes where vote.post_id=post.id) as votes_count from postecho $posts[0]-&gt;votes_count;echo $posts[0]-&gt;comments_count;//可以为关联数据计数结果起别名，允许在同一个关联上多次计数：$posts = Post::withCount(['comments','comments as pending_comments_count' =&gt; function ($query) &#123; $query-&gt;where('approved', false);&#125;])-&gt;get();//select *,(select count(*) from comment where comment.post_id=post.id) as comments_count,(select count(*) from comment where comment.post_id=post.id and approved=false) as pending_comments_count from postecho $posts[0]-&gt;comments_count;echo $posts[0]-&gt;pending_comments_count; withCount的源代码与has的代码高度相似：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Add subselect queries to count the relations. * * @param mixed $relations * @return $this */public function withCount($relations)&#123; if (empty($relations)) &#123; return $this; &#125; if (is_null($this-&gt;query-&gt;columns)) &#123; $this-&gt;query-&gt;select([$this-&gt;query-&gt;from.'.*']); &#125; $relations = is_array($relations) ? $relations : func_get_args(); foreach ($this-&gt;parseWithRelations($relations) as $name =&gt; $constraints) &#123; // First we will determine if the name has been aliased using an "as" clause on the name // and if it has we will extract the actual relationship name and the desired name of // the resulting column. This allows multiple counts on the same relationship name. $segments = explode(' ', $name); unset($alias); if (count($segments) === 3 &amp;&amp; Str::lower($segments[1]) === 'as') &#123; [$name, $alias] = [$segments[0], $segments[2]]; &#125; $relation = $this-&gt;getRelationWithoutConstraints($name); // Here we will get the relationship count query and prepare to add it to the main query // as a sub-select. First, we'll get the "has" query and use that to get the relation // count query. We will normalize the relation name then append _count as the name. $query = $relation-&gt;getRelationExistenceCountQuery( $relation-&gt;getRelated()-&gt;newQuery(), $this ); $query-&gt;callScope($constraints); $query = $query-&gt;mergeConstraintsFrom($relation-&gt;getQuery())-&gt;toBase(); $query-&gt;orders = null; $query-&gt;setBindings([], 'order'); if (count($query-&gt;columns) &gt; 1) &#123; $query-&gt;columns = [$query-&gt;columns[0]]; $query-&gt;bindings['select'] = []; &#125; // Finally we will add the proper result column alias to the query and run the subselect // statement against the query builder. Then we will return the builder instance back // to the developer for further constraint chaining that needs to take place on it. $column = $alias ?? Str::snake($name.'_count'); $this-&gt;selectSub($query, $column); &#125; return $this;&#125; 解析关联关系名称 获取无约束的关联关系 为关联关系添加existenceCount约束 为关联关系添加with外部约束 将关联关系添加到where条件中 设置alias别名 创建select子查询 多对多关系的中间表查询12345678910111213141516171819202122232425262728293031323334return $this-&gt;belongsToMany('App\Role')-&gt;wherePivot('approved', 1);return $this-&gt;belongsToMany('App\Role')-&gt;wherePivotIn('priority', [1, 2]);/** * Set a where clause for a pivot table column. * * @param string $column * @param string|null $operator * @param mixed $value * @param string $boolean * @return $this */public function wherePivot($column, $operator = null, $value = null, $boolean = 'and')&#123; $this-&gt;pivotWheres[] = func_get_args(); return $this-&gt;where($this-&gt;table.'.'.$column, $operator, $value, $boolean);&#125;/** * Set a "where in" clause for a pivot table column. * * @param string $column * @param mixed $values * @param string $boolean * @param bool $not * @return $this */public function wherePivotIn($column, $values, $boolean = 'and', $not = false)&#123; $this-&gt;pivotWhereIns[] = func_get_args(); return $this-&gt;whereIn($this-&gt;table.'.'.$column, $values, $boolean, $not);&#125; 注意这里的pivotWheres与pivotWheres变量，这个变量在对中间表的加载中会被使用：12345678910111213141516171819/** * Create a new query builder for the pivot table. * * @return \Illuminate\Database\Query\Builder */public function newPivotQuery()&#123; $query = $this-&gt;newPivotStatement(); foreach ($this-&gt;pivotWheres as $arguments) &#123; call_user_func_array([$query, 'where'], $arguments); &#125; foreach ($this-&gt;pivotWhereIns as $arguments) &#123; call_user_func_array([$query, 'whereIn'], $arguments); &#125; return $query-&gt;where($this-&gt;foreignPivotKey, $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的B+树索引的概念、使用、优化及使用场景]]></title>
    <url>%2F2020%2F05%2F28%2FMySQL%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E4%BD%BF%E7%94%A8%E3%80%81%E4%BC%98%E5%8C%96%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 索引的管理索引有很多种类型：普通索引、唯一索引、主键索引、组合索引、全文索引。 使用SHOW INDEX命令查看索引信息 如果想要查看表中的索引信息，可以使用命令SHOW INDEX，下面的例子，我们查看表table_index的索引信息。 1SHOW INDEX FROM table_index\G; 得到上面的信息，上面的信息什么意思呢？我们逐一介绍！ 字段 解释 Table 索引所在的表 Non_unique 非唯一索引，如果是0，代表唯一的，也就是说如果该列索引中不包括重复的值则为0，否则为1 Key_name 索引的名字，如果是主键的话，则为PRIMARY Seq_in_index 索引中该列的位置，从1开始，如果是组合索引，那么按照字段在建立索引时的顺序排列 Collation 列是以什么方式存储在索引中的。可以是A或者NULL，B+树索引总是A，排序的 Sub_part 是否列的部分被索引，如果只是前100行索引，就显示100，如果是整列，就显示NULL Packed 关键字是否被压缩，如果没有，为NULL Index_type 索引的类型，对于InnoDB只支持B+树索引，所以都是显示BTREE Cardinality关键字解析在上面介绍了那么多个关键字的意思，但是Cardinality这个关键字非常的关键，优化器会根据这个值来判断是否使用这个索引。在B+树索引中，只有高选择性的字段才是有意义的，高选择性就是这个字段的取值范围很广，比如姓名字段，会有很多的名字，可选择性就高了。 一般来说，判断是否需要使用索引，就可以通过Cardinality关键字来判断，如果非常接近1，说明有必要使用，如果非常小，那么就要考虑是否使用索引了。 需要注意的一个问题是，这个关键字不是及时更新的，需要更新的话，需要使用ANALYZE TABLE，例如 1analyze table table_index; 因为目前没有数据，所以，你会发现，这个值一直都是0，没有变化。 InoDB存储引擎Cardinality的策略 在InnoDB存储引擎中，这个关键字的更新发生在两个操作中：insert和update。但是，并不是每次都会更新，这样会增加负荷，所以，对于这个关键字的更新有它的策略： 表中1/16的数据发生变化 InnoDB存储引擎的计数器stat_modified_conter&gt;2000000000 默认InnoDB存储引擎会对8个叶子节点进行采样，采样过程如下： B+树索引中叶子节点数量，记做A 随机取得B+树索引中的8个叶子节点。统计每个页不同的记录个数，分别为p1-p8 根据采样信息得到Cardinality的预估值：(p1+p2+p3+…+p8)*A/8 因为随机采样，所以，每次的Cardinality值都是不一样的，只有一种情况会一样的，就是表中的叶子节点小于或者等于8，这时候，怎么随机采样都是这8个，所以也就一样的。 Fast Index Creation在MySQL5.5之前，对于索引的添加或者删除，每次都需要创建一张临时表，然后导入数据到临时表，接着删除原表，如果一张大表进行这样的操作，会非常的耗时，这是一个很大的缺陷。 InnoDB存储引擎从1.0.x版本开始加入了一种Fast Index Creation（快速索引创建）的索引创建方式。 这种方式的策略为：每次为创建索引的表加上一个S锁（共享锁），在创建的时候，不需要重新建表，删除辅助索引只需要更新内部视图，并将辅助索引空间标记为可用，所以，这种效率就大大提高了。 在线数据定义MySQL5.6开始支持的在线数据定义操作就是：允许辅助索引创建的同时，还允许其他insert、update、delete这类DM操作，这就极大提高了数据库的可用性。 所以，我们可以使用新的语法进行创建索引： 123ALTER TABLE table_name ADD [UNIQUE|FULLLTEXT] INDEX index_name (column(length))[ALGORITHM = &#123;DEFAULT|INPLACE|COPY&#125;][LOCK = &#123;DEFAULT|NONE|SHARED|EXLUSIVE&#125;] ALGORITHM指定创建或者删除索引的算法 COPY：创建临时表的方式 INPLACE：不需要创建临时表 DEFAULT：根据参数 old_alter_table参数判断，如果是 OFF,采用 INPLACE的方式 LOCK表示对表添加锁的情况 NONE：不加任何锁 SHARE：加一个S锁，并发读可以进行，写操作需要等待 EXCLUSIVE：加一个X锁，读写都不能并发进行 DEFAULT：先判断是否可以使用NONE，如不能，判断是否可以使用SHARE，如不能，再判断是否可以使用EXCLUSIVE模式。 B+树索引的使用联合索引联合索引是指对表上的多个列进行索引，这一部分我们将通过几个例子来讲解联合索引的相关知识点。 首先，我们先创建一张表以及为这张表创建联合索引。 123456create table t_index(a char(2) not null default '',b char(2) not null default '',c char(2) not null default '',d char(2) not null default '')engine myisam charset utf8; 创建联合索引 1alter table t_index add index abcd(a,b,c,d); 插入几条测试数据 123456insert into t_index values('a','b','c','d'),('a2','b2','c2','d2'),('a3','b3','c3','d3'),('a4','b4','c4','d4'),('a5','b5','c5','d5'),('a6','b6','c6','d6'); 到这一步，我们已经基本准备好了需要的数据，我们可以进行更深一步的联合索引的探讨。 我们什么时候需要创建联合索引呢索引建立的主要目的就是为了提高查询的效率，那么联合索引的目的也是类似的，联合索引的目的就是为了提高存在多个查询条件的情况下的效率，就如上面建立的表一样，有多个字段，当我们需要利用多个字段进行查询的时候，我们就需要利用到联合索引了。 什么时候联合索引才会发挥作用呢有时候，我们会用联合索引，但是，我们并不清楚其原理，不知道什么时候联合索引会起到作用，什么时候又是会失效的？ 带着这个问题，我们了解一下联合索引的最左匹配原则。 最左匹配原则：这个原则的意思就是创建组合索引，以最左边的为准，只要查询条件中带有最左边的列，那么查询就会使用到索引。 下面，我们用几个例子来看看这个原则。 1EXPLAIN SELECT * FROM t_index WHERE a = 'a' \G; 我们看看这条语句的结果，首先，我们看到使用了索引，因为查询条件中带有最左边的列a，那么利用了几个索引呢？这个我们需要看key_len这个字段，我们知道utf8编码的一个字符3个字节，而我们使用的数据类型是 char(2)，占两个字节，索引就是2*3等于6个字节，所以只有一个索引起到了作用。 1EXPLAIN SELECT * FROM t_index WHERE b = 'b2' \G; 这个语句我们可以看出，这个没有使用索引，因为possible_keys为空，而且，从查询的行数 rows可以看出为6（我们测试数据总共6条），说明进行了全盘扫描的，说明这种情况是不符合最左匹配原则，所以不会使用索引查询。 1EXPLAIN SELECT * FROM t_index WHERE a = 'a2' AND b = 'b2' ORDER BY d \G; 这种情况又有点不一样了，我们使用了一个排序，可以看出使用了索引，通过key_len为12可以得到使用了2个索引a、b，另外在Extra选项中可以看到使用了Using filesort，也就是文件排序，这里使用文件排序的原因是这样的：上面的查询使用了a、b索引，但是当我们用d字段来排序时，（a，d）或者（b，d）这两个索引是没有排序的，联合索引的使用有一个好处，就是索引的下一个字段是会自动排序的，在这里的这种情况来说，c字段就是排序的，但是d是不会，如果我们用c来排序就会得到不一样的结果。 1EXPLAIN SELECT * FROM t_index WHERE a = 'a2' AND b = 'b2' ORDER BY c \G; 是不是可以看到，当我们用c进行排序的时候，因为使用了a、b索引，所以c就自动排序了，所以也就不用filesort了。 讲到这里，我相信通过上面的几个例子，对于联合索引的相关知识已经非常的透彻清晰了，最后，我们再来聊几个常见的问题。 Q1：为什么不对表中的每一个列创建一个索引呢 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 Q2：为什么需要使用联合索引 减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！ 覆盖索引。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。 效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！ 覆盖索引覆盖索引是一种从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录，使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，所以大小远小于聚集索引，因此可以大大减少IO操作。覆盖索引的另外一个好处就是对于统计问题有优化，我们看下面的一个例子。 1explain select count(*) from t_index \G; 如果是myisam引擎，Extra列会输出 Select tables optimized away语句，myisam引擎已经保存了记录的总数，直接返回结果，就不需要覆盖索引优化了。 如果是InnoDB引擎，Extra列会输出 Using index语句，说明InnoDB引擎优化器使用了覆盖索引操作。 索引提示MySQL数据库支持索引提示功能，索引提示功能就是我们可以显示的告诉优化器使用哪个索引，一般有下面两种情况可能使用到索引提示功能（INDEX HINT）： MySQL数据库的优化器错误的选择了某个索引，导致SQL运行很慢 某SQL语句可以选择的索引非常的多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。 这里我们接着上面的例子来讲解，首先，我们先为上面的t_index表添加几个索引； 123alter table t_index add index a (a);alter table t_index add index b (b);alter table t_index add index c (c); 接着，我们执行下面的语句； 1EXPLAIN SELECT * FROM t_index WHERE a = 'a' AND b = 'b' AND c = 'c' \G; 你会发现这条语句就可以使用三个索引，这个时候，我们可以显示的使用索引提示来使用a这个索引，如下： 1EXPLAIN SELECT * FROM t_index USE INDEX(a) WHERE a = 'a' AND b = 'b' AND c = 'c' \G; 这样就显示的使用索引a了，如果这种方式有时候优化器还是没有选择你想要的索引，那么，我们可以另外一种方式 FORCE INDEX。 1EXPLAIN SELECT * FROM t_index FORCE INDEX(a) WHERE a = 'a' AND b = 'b' AND c = 'c' \G; 这种方式则一定会选择你想要的索引。 索引优化Multi-Range Read优化 MySQL5.6开始支持，这种优化的目的是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这种优化适用于range、ref、eq_ref类型的查询。 Multi-Range Read 优化的好处： 让数据访问变得较为顺序。 减少缓冲区中页被替换的次数。 批量处理对键值的查询操作。 我们可以使用参数 optimizer_switch中的标记来控制是否开启Multi-Range Read优化。下面的方式将设置为总是开启状态： 1SET @@optimizer_switch='mrr=on,mrr_cost_based=off'; Index Condition Pushdown（ICP）优化 这种优化方式也是从MySQL5.6开始支持的，不支持这种方式之前，当进行索引查询时，首先我们先根据索引查找记录，然后再根据where条件来过滤记录。然而，当支持ICP优化后，MySQL数据库会在取出索引的同时，判断是否可以进行where条件过滤，也就是将where过滤部分放在了存储引擎层，大大减少了上层SQL对记录的索取。 ICP支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。 我们可以使用下面语句开启ICP： 1set @@optimizer_switch = "index_condition_pushdown=on" 或者关闭： 1set @@optimizer_switch = "index_condition_pushdown=off" 当开启了ICP之后，在执行计划Extra可以看到 Using index condition提示。 索引的特点、优点、缺点及适用场景索引的特点 可以加快数据库的检索速度 降低数据库插入、修改、删除等维护的速度 只能创建在表上，不能创建在视图上 既可以直接创建也可以间接创建 索引的优点 创建唯一性索引，保证数据库表中的每一行数据的唯一性 大大加快数据的检索速度 加快数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义 在使用分组和排序字句进行数据检索时，同样可以显著减少查询的时间 通过使用索引，可以在查询中使用优化隐藏器，提高系统性能 索引的缺点 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引的适用场景 匹配全值 对索引中所有列都指定具体值，即是对索引中的所有列都有等值匹配的条件。 匹配值的范围查询 对索引的值能够进行范围查找。 匹配最左前缀 仅仅使用索引中的最左边列进行查询，比如在 col1 + col2 + col3 字段上的联合索引能够被包含 col1、(col1 + col2)、（col1 + col2 + col3）的等值查询利用到，可是不能够被 col2、（col2、col3）的等值查询利用到。最左匹配原则可以算是 MySQL 中 B-Tree 索引使用的首要原则。 仅仅对索引进行查询 当查询的列都在索引的字段中时，查询的效率更高，所以应该尽量避免使用 select *，需要哪些字段，就只查哪些字段。 匹配列前缀 仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找。 能够实现索引匹配部分精确而其他部分进行范围匹配 如果列名是索引，那么使用 column_name is null 就会使用索引，例如下面的就会使用索引： 1explain select * from t_index where a is null \G 经常出现在关键字order by、group by、distinct后面的字段 在union等集合操作的结果集字段 经常用作表连接的字段 考虑使用索引覆盖，对数据很少被更新，如果用户经常值查询其中你的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描变为索引的扫描 索引失效情况 以%开头的like查询不能利用B-Tree索引，执行计划中key的值为null表示没有使用索引 数据类型出现隐式转换的时候也不会使用索引，例如，where ‘age’+10=30 对索引列进行函数运算，原因同上 正则表达式不会使用索引 字符串和数据比较不会使用索引 复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则leftmost，是不会使用复合索引的 如果MySQL估计使用索引比全表扫描更慢，则不使用索引 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到 使用负向查询（not ，not in， not like ，&lt;&gt; ,!= ,!&gt; ,!&lt; ）不会使用索引]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务，这篇文章就够了]]></title>
    <url>%2F2020%2F05%2F28%2FMySQL%E4%BA%8B%E5%8A%A1%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是事务事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 同时，事务有着严格的地定义，必须满足四个特性，也就是我们一直说的ACID，但是，并不是说各种数据库就一定会满足四个特性，对于不同的数据库的实现来说，在不同程度上是不一定完全满足要求的，比如，Oracle数据库来说，默认的事务隔离级别是READ COMMITTED，是不满足隔离性的要求的。 下面我们趁热打铁，介绍一下事务的必知必会的四大特性，这几个特性也是在面试中，面试官面试MySQL的相关知识的时候，问的比较多的问题，所以，这几个特性务必需要理解并且透彻的记在心里！ 事务的四大特性事务的四大特性简称为：ACID，分别是原子性、一致性、隔离性和持久性。 下面我们一一来介绍一下。 原子性（Atomicity） 原子性指的是整个数据库的事务是一个不可分割的工作单位，每一个都应该是一个原子操作。 当我们执行一个事务的时候，如果一系列的操作中，有一个操作失败了，那么，需要将这一个事务中的所有操作恢复到执行事务之前的状态，这就是事务的原子性。 下面举个简单的例子。1i++; 上面这个最简单不过的代码经常也会被问到，这是一个原子操作吗？那肯定不是，如果我们把这个代码放到一个事务中来说，当i+1出现问题的时候，回滚的就是整个代码i++（i = i + 1）了，所以回滚之后，i的值也是不会改变的。 以上就是原子性的概念。 一致性（consistency） 一致性是指事务将数据库从一种状态转变为下一种一致性的状态，也就是说在事务执行前后，这两种状态应该是一样的，也就是数据库的完整性约束不会被破坏。 另外，需要注意的是一致性是不关注中间状态的，比如银行转账的过程，你转账给别人，至于中间的状态，你少了500 ，他多了500，这些中间状态不关注，如果分多次转账中间状态也是不可见的，只有最后的成功或者失败的状态是可见的。 如果到分布式的一致性问题，又可以分为强一致性、弱一致性和最终一致性，关于这些概念，可以自己查查，还是很有意思的。 隔离性（isolation） 事务我们是可以开启很多的，MySQL数据库中可以同时启动很多的事务，但是，事务和事务之间他们是相互分离的，也就是互不影响的，这就是事务的隔离性。 持久性（durability） 事务的持久性是指事务一旦提交，就是永久的了，就是发生问题，数据库也是可以恢复的。因此，持久性保证事务的高可靠性。 事务的分类事务可以分为很多种类型，一般分为：扁平事务、带有保存点的扁平事务、链事务、嵌套事务、分布式事务。 扁平事务扁平事务是最简单的一种，在实际开发中也是使用的最多的一种事务。在这种事务中，所有操作都处于同一层次，最常见的方式如下： 1234567BEGIN WORKOperation 1Operation 2Operation 3...Operation NCOMMIT WORK 举个例子1234567begin work;select * from user;update user set name = 'sihai' where id = 1;commit work; 扁平事务的主要缺点是不能提交或回滚事务的某一部分，或者分几个独立的步骤去提交。 带有保存点的扁平事务这种事务除了支持扁平事务支持的操作外，这种事务跟扁平事务最大的区别就是允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。 举个例子1234567891011begin work;select * from user;savepoint t1;update user set name = 'sihai' where id = 1;savepoint t2;commit work; 通过上面的方式我们就建立了两个保存点t1、t2，通过ROLLBACK TO SAVEPOINT t1，我们就可以返回到保存点t1。 链事务链事务：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式的传给下一个要开始的事务。需要注意，提交事务操作和下一个事务操作将合并为一个原子操作，就是下一个事务可以看到上一个事务的结果。 链事务，就是指回滚时，只能恢复到最近一个保存点；而带有保存点的扁平事务则可以回滚到任意正确的保存点。 举个例子 1234567891011begin work;select * from user;savepoint t1;update user set name = 'sihai' where id = 1;savepoint t2;commit work; 还是这个例子，但是对于链事务来说，是不能直接rollback到保存点t1的，最能恢复到最近的一个保存点t2；另外我们需要注意，链事务在执行commit后就会释放当前事务所持有的所有锁，而带有保存点的扁平事务不会影响所持有的锁。 嵌套事务在事务中再嵌套事务，这种结构有点像一颗横着的树的结构，位于根节点的事务称为顶层事务。事务的前驱称为父事务，其它事务称为子事务。事务的前驱称为父事务，事务的下一层称为子事务。 子事务既可以提交也可以回滚，但是它的提交操作并不马上生效，除非由其父事务提交。因此就可以确定，任何子事务都在顶层事务提交后才真正的被提交了。同理，任意一个事务的回滚都会引起它的所有子事务一同回滚。 123456789101112131415BEGIN WORK SubTransaction1: BEGIN WORK SubOperationX COMMIT WORK SubTransaction2: BEGIN WORK SubOperationY COMMIT WORK ... SubTransactionN: BEGIN WORK SubOperationN COMMIT WORKCOMMIT WORK 分布式事务分布式事务通常是指在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。 在不同的物理地址，通过网络访问，执行不同的事务，这就是分布式事务。 事务的使用首先这一部分我们还是先介绍一下这些事务的语句，也不是很多，使用也不复杂，下面用一个表格做一个整理。 注意：COMMIT和COMMIT WORK语句不同之处在于COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE，如果是CHAIN，那么事务就是链事务。 用户可以通过参数completion_type控制，如下： completion_type = 1 实例 执行下面的操作； 1234567SET @@completion_type = 1;BEGIN WORK;INSERT INTO lock_test SELECT 10;COMMIT WORK; 接着我们再执行下面的操作；12345INSERT INTO lock_test SELECT 115;ROLLBACK;SELECT * FROM lock_test; 我们先插入一条数据115，然后再回滚，我们知道如果不是在一个事务的时候，115应该是会插入成功的，就算我们回滚了，但是，这里我们回滚之后，查询结果如下： 这个时候并没有115这条记录，也就是回滚生效了，说明在COMMIT WORK之后，又是一个新的事务，所以才会出现这样的结果。 completion_type = 2 实例 我们先进行下面的操作； 1234567SET @@completion_type = 2;BEGIN WORK;INSERT INTO lock_test SELECT 5;COMMIT WORK; 上面我们已经提交事务了，当我们使用下面的语句查询lock_test的数据的时候，就会出现断开连接。 1SELECT * FROM lock_test; 事务的隔离级别事务的隔离级别有四种分别是： READ UNCOMMITTED READ COMMITTED REPEATABLE READ SERIALIZABLE 对于这几种隔离级别会带来的问题及总结，可以查看这篇文章：MySQL的又一神器-锁，MySQL面试必备 总结这篇文章从下面几个内容介绍了一下MySQL数据库事务的内容，更详细的其他内容在后面的文章中再讲解。 概念事务类型事务使用事务的隔离级别]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-数据库的CURD操作]]></title>
    <url>%2F2020%2F05%2F25%2FLaravel-Database-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84CURD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Exception::getPrevious—返回异常链中的前一个异常。什么意思？ 前言当Connection对象构建初始化完成后，我们就可以利用DB来进行数据库的CURD（Create、Update、Retrieve、Delete）操作。本篇文章，我们将会讲述Laravel如何与PDO交互，实现基本数据库服务的原理。 源码runLaravel中任何数据库的操作都要经过run这个函数，这个函数作用在于重新连接数据库、记录数据库日志、数据库异常处理： Illuminate\Database\Connection.php 123456789101112131415161718192021222324252627282930313233343536373839/** * 运行一条SQL语句并记录其执行上下文。 * * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function run($query, $bindings, Closure $callback)&#123; $this-&gt;reconnectIfMissingConnection(); $start = microtime(true); // 在这里，我们将运行此查询。 // 如果发生异常，我们将确定它是否是连接丢失引起的。 // 如果是，我们将尝试重新建立连接，并使用新的连接重新运行查询。 try &#123; $result = $this-&gt;runQueryCallback($query, $bindings, $callback); &#125; catch (QueryException $e) &#123; $result = $this-&gt;handleQueryException( $e, $query, $bindings, $callback ); &#125; // 运行查询后，我们将计算运行时间， // 然后记录查询，绑定和执行时间，以便在开发人员需要它们时报告它们。 // 我们将以毫秒为单位记录时间。 $this-&gt;logQuery( $query, $bindings, $this-&gt;getElapsedTime($start) ); return $result;&#125; 重新连接数据库reconnect如果当前的pdo是空，那么就会调用reconnector重新与数据库进行连接：12345678910111213141516171819202122232425262728293031/** * 如果PDO连接丢失，重新连接数据库。 * * @return void */protected function reconnectIfMissingConnection()&#123; if (is_null($this-&gt;pdo)) &#123; $this-&gt;reconnect(); &#125;&#125;/** * 重新连接数据库。 * * @return void * * @throws \LogicException */public function reconnect()&#123; if (is_callable($this-&gt;reconnector)) &#123; $this-&gt;doctrineConnection = null; return call_user_func($this-&gt;reconnector, $this); &#125; throw new LogicException('Lost connection and no reconnector available.');&#125; 运行数据库操作数据库的CURD操作会被包装成为一个闭包函数，作为runQueryCallback的一个参数，当运行正常时，会返回结果，如果遇到异常的话，会将异常转化为QueryException，并且抛出。 123456789101112131415161718192021222324252627282930/** * 运行一个SQL语句。 * * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function runQueryCallback($query, $bindings, Closure $callback)&#123; // 为了执行该语句，我们将简单地调用回调，该回调实际上将针对PDO连接运行SQL。 // 然后，我们可以计算执行时间并在内存中记录查询SQL，绑定和时间。 try &#123; $result = $callback($query, $bindings); &#125; // 如果在尝试运行查询时发生异常，我们将格式化错误消息以包含SQL绑定， // 这将使该异常对开发人员有很大帮助，而不仅仅是数据库的错误。 catch (Exception $e) &#123; throw new QueryException( $query, $this-&gt;prepareBindings($bindings), $e ); &#125; return $result;&#125; 数据库异常处理当pdo查询返回异常的时候，如果当前是事务进行时，那么直接返回异常，让上一层事务来处理。 如果是由于与数据库事情连接导致的异常，那么就要重新与数据库进行连接： 1234567891011121314151617181920212223242526272829/** * 活跃事务数。 * * @var int */protected $transactions = 0;/** * 处理查询异常。 * * @param \Illuminate\Database\QueryException $e * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function handleQueryException(QueryException $e, $query, $bindings, Closure $callback)&#123; if ($this-&gt;transactions &gt;= 1) &#123; throw $e; &#125; return $this-&gt;tryAgainIfCausedByLostConnection( $e, $query, $bindings, $callback );&#125; 与数据库失去连接： 12345678910111213141516171819202122/** * 处理在查询执行期间发生的查询异常。 * * @param \Illuminate\Database\QueryException $e * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function tryAgainIfCausedByLostConnection(QueryException $e, $query, $bindings, Closure $callback)&#123; if ($this-&gt;causedByLostConnection($e-&gt;getPrevious())) &#123; $this-&gt;reconnect(); return $this-&gt;runQueryCallback($query, $bindings, $callback); &#125; throw $e;&#125; Illuminate\Database\DetectsLostConnections.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Database;use Illuminate\Support\Str;use Throwable;trait DetectsLostConnections&#123; /** * 确定给定的异常是否由丢失的连接引起。 * * @param \Throwable $e * @return bool */ protected function causedByLostConnection(Throwable $e) &#123; $message = $e-&gt;getMessage(); return Str::contains($message, [ 'server has gone away', 'no connection to the server', 'Lost connection', 'is dead or not enabled', 'Error while sending', 'decryption failed or bad record mac', 'server closed the connection unexpectedly', 'SSL connection has been closed unexpectedly', 'Error writing data to the connection', 'Resource deadlock avoided', 'Transaction() on null', 'child connection forced to terminate due to client_idle_limit', 'query_wait_timeout', 'reset by peer', 'Physical connection is not usable', 'TCP Provider: Error code 0x68', 'ORA-03114', 'Packets out of order. Expected', 'Adaptive Server connection failed', 'Communication link failure', 'connection is no longer usable', 'Login timeout expired', 'Connection refused', 'running with the --read-only option so it cannot execute this statement', ]); &#125;&#125; 数据库日志123456789101112131415161718192021222324/** * All of the queries run against the connection. * * @var array */protected $queryLog = [];/** * 将查询记录在连接的查询日志中。 * * @param string $query * @param array $bindings * @param float|null $time * @return void */public function logQuery($query, $bindings, $time = null)&#123; $this-&gt;event(new QueryExecuted($query, $bindings, $time, $this)); if ($this-&gt;loggingQueries) &#123; $this-&gt;queryLog[] = compact('query', 'bindings', 'time'); &#125;&#125; 想要开启或关闭日志功能：1234567891011121314151617181920212223242526/** * 指明是否正在记录查询。 * * @var bool */protected $loggingQueries = false;/** * 在连接上启用查询日志。 * * @return void */public function enableQueryLog()&#123; $this-&gt;loggingQueries = true;&#125;/** * 在连接上禁用查询日志。 * * @return void */public function disableQueryLog()&#123; $this-&gt;loggingQueries = false;&#125; Select查询12345678910111213141516171819202122232425262728/** * 对数据库运行一条select语句。 * * @param string $query * @param array $bindings * @param bool $useReadPdo * @return array */public function select($query, $bindings = [], $useReadPdo = true)&#123; return $this-&gt;run($query, $bindings, function ($query, $bindings) use ($useReadPdo) &#123; if ($this-&gt;pretending()) &#123; return []; &#125; // 对于select语句，我们将简单地执行查询并返回数据库结果集的数组。 // 数组中的每个元素都是数据库表中的一行，并且可以是数组或对象。 $statement = $this-&gt;prepared($this-&gt;getPdoForSelect($useReadPdo) -&gt;prepare($query)); $this-&gt;bindValues($statement, $this-&gt;prepareBindings($bindings)); $statement-&gt;execute(); return $statement-&gt;fetchAll(); &#125;);&#125; 数据库的查询主要有以下几个步骤： 获取$this-&gt;pdo成员变量，若当前未连接数据库，则进行数据库连接，获取pdo对象。 设置pdo数据fetch模式。 pdo进行sql语句预处理。 pdo绑定参数sql语句执行，并获取数据。 getPdoForSelect获取pdo对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 获取用于选择查询的PDO连接。 * * @param bool $useReadPdo * @return \PDO */protected function getPdoForSelect($useReadPdo = true)&#123; return $useReadPdo ? $this-&gt;getReadPdo() : $this-&gt;getPdo();&#125;/** * 获取当前的PDO连接。 * * @return \PDO */public function getPdo()&#123; if ($this-&gt;pdo instanceof Closure) &#123; return $this-&gt;pdo = call_user_func($this-&gt;pdo); &#125; return $this-&gt;pdo;&#125;/** * 获取用于读取的当前PDO连接。 * * @return \PDO */public function getReadPdo()&#123; if ($this-&gt;transactions &gt; 0) &#123; return $this-&gt;getPdo(); &#125; if ($this-&gt;recordsModified &amp;&amp; $this-&gt;getConfig('sticky')) &#123; return $this-&gt;getPdo(); &#125; if ($this-&gt;readPdo instanceof Closure) &#123; return $this-&gt;readPdo = call_user_func($this-&gt;readPdo); &#125; return $this-&gt;readPdo ?: $this-&gt;getPdo();&#125; getPdo这里逻辑比较简单，值得我们注意的是getReadPdo。为了减缓数据库的压力，我们常常对数据库进行读写分离，也就是只要当写数据库这种操作发生时，才会使用写数据库，否则都会用读数据库。这种措施减少了数据库的压力，但是也带来了一些问题，那就是读写两个数据库在一定时间内会出现数据不一致的情况，原因就是写库的数据未能及时推送给读库，造成读库数据延迟的现象。为了在一定程度上解决这类问题，Laravel增添了sticky选项，从程序中我们可以看出，当我们设置选项sticky为真，并且的确对数据库进行了写操作后，getReadPdo会强制返回主库的连接，这样就避免了读写分离造成的延迟问题。 还有一种情况，当数据库在执行事务期间，所有的读取操作也会被强制连接主库。 prepared设置数据获取方式1234567891011121314151617181920212223/** * 连接的默认fetchMode。 * * @var int */protected $fetchMode = PDO::FETCH_OBJ;/** * 配置PDO准备语句。 * * @param \PDOStatement $statement * @return \PDOStatement */protected function prepared(PDOStatement $statement)&#123; $statement-&gt;setFetchMode($this-&gt;fetchMode); $this-&gt;event(new StatementPrepared( $this, $statement )); return $statement;&#125; pdo的setFetchMode函数用于为语句设置默认的获取模式，通常模式有-以下几种： PDO::FETCH_ASSOC 从结果集中获取以列名为索引的关联数组。 PDO::FETCH_NUM 从结果集中获取一个以列在行中的数值偏移量为索引的值数组。 PDO::FETCH_BOTH 这是默认值，包含上面两种数组。 PDO::FETCH_OBJ 从结果集当前行的记录中获取其属性对应各个列名的一个对象。 PDO::FETCH_BOUND 使用fetch()返回TRUE，并将获取的列值赋给在bindParm()方法中指定的相应变量。 PDO::FETCH_LAZY 创建关联数组和索引数组，以及包含列属性的一个对象，从而可以在这三种接口中任选一种。 pdo的prepare函数prepare函数会为PDOStatement::execute()方法准备要执行的SQL语句， SQL语句可以包含零个或多个命名（:name）或问号（?）参数标记，参数在SQL执行时会被替换。 不能在SQL语句中同时包含命名（:name）或问号（?）参数标记，只能选择其中一种风格。 预处理SQL语句中的参数在使用PDOStatement::execute()方法时会传递真实的参数。 之所以使用prepare函数，是因为这个函数可以防止SQL注入，并且可以加快同一查询语句的速度。关于预处理与参数绑定防止SQL漏洞注入的原理可以参考：Web安全之SQL注入攻击技巧与防范. pdo的bindValues函数在调用pdo的参数绑定函数之前，Laravel对参数值进一步进行了优化，把时间类型的对象利用grammer的设置重新格式化，false也改为0。 pdo的参数绑定函数bindValue，对于使用命名占位符的预处理语句，应是类似:name形式的参数名。对于使用问号占位符的预处理语句，应是以1开始索引的参数位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 准备要执行的查询绑定。 * * @param array $bindings * @return array */public function prepareBindings(array $bindings)&#123; $grammar = $this-&gt;getQueryGrammar(); foreach ($bindings as $key =&gt; $value) &#123; // 我们需要将DateTimeInterface的所有实例转换为实际的日期字符串。 // 每个查询语法都维护自己的日期字符串格式，因此我们只要求语法从日期中获取格式。 if ($value instanceof DateTimeInterface) &#123; $bindings[$key] = $value-&gt;format($grammar-&gt;getDateFormat()); &#125; elseif (is_bool($value)) &#123; $bindings[$key] = (int) $value; &#125; &#125; return $bindings;&#125;/** * 将值绑定到给定语句中的参数。 * * @param \PDOStatement $statement * @param array $bindings * @return void */public function bindValues($statement, $bindings)&#123; foreach ($bindings as $key =&gt; $value) &#123; $statement-&gt;bindValue( is_string($key) ? $key : $key + 1, $value, is_int($value) ? PDO::PARAM_INT : PDO::PARAM_STR ); &#125;&#125; insert123456789101112131415161718192021222324252627282930313233343536/** * 对数据库运行insert语句。 * * @param string $query * @param array $bindings * @return bool */public function insert($query, $bindings = [])&#123; return $this-&gt;statement($query, $bindings);&#125;/** * 执行一条SQL语句并返回布尔值。 * * @param string $query * @param array $bindings * @return bool */public function statement($query, $bindings = [])&#123; return $this-&gt;run($query, $bindings, function ($query, $bindings) &#123; if ($this-&gt;pretending()) &#123; return true; &#125; $statement = $this-&gt;getPdo()-&gt;prepare($query); $this-&gt;bindValues($statement, $this-&gt;prepareBindings($bindings)); $this-&gt;recordsHaveBeenModified(); return $statement-&gt;execute(); &#125;);&#125; 这部分的代码与select非常相似，不同之处有以下几个： 直接获取写库的连接，不会考虑读库。 由于不需要返回任何数据库数据，因此也不必设置fetchMode。 recordsHaveBeenModified函数标志当前连接数据库已被写入。 不需要调用函数fetchAll。 12345678910111213/** * 指出是否有任何记录被修改。 * * @param bool $value * @return void */public function recordsHaveBeenModified($value = true)&#123; if (! $this-&gt;recordsModified) &#123; $this-&gt;recordsModified = $value; &#125;&#125; update、deleteaffectingStatement这个函数与上面的statement函数一致，只是最后会返回更新、删除影响的行数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 对数据库运行一条update语句。 * * @param string $query * @param array $bindings * @return int */public function update($query, $bindings = [])&#123; return $this-&gt;affectingStatement($query, $bindings);&#125;/** * 对数据库运行一条delete语句。 * * @param string $query * @param array $bindings * @return int */public function delete($query, $bindings = [])&#123; return $this-&gt;affectingStatement($query, $bindings);&#125;/** * 运行一条SQL语句并获取受影响的行数。 * * @param string $query * @param array $bindings * @return int */public function affectingStatement($query, $bindings = [])&#123; return $this-&gt;run($query, $bindings, function ($query, $bindings) &#123; if ($this-&gt;pretending()) &#123; return 0; &#125; // 对于update或delete语句，我们希望获得该语句影响的行数，并将其返回给开发人员。 // 我们首先需要执行该语句，然后使用PDO来获取受影响的对象。 $statement = $this-&gt;getPdo()-&gt;prepare($query); $this-&gt;bindValues($statement, $this-&gt;prepareBindings($bindings)); $statement-&gt;execute(); $this-&gt;recordsHaveBeenModified( ($count = $statement-&gt;rowCount()) &gt; 0 ); return $count; &#125;);&#125; 事务transaction数据库事务为保持数据的一致性，对于重要的数据我们经常使用数据库事务，transaction函数接受一个闭包函数，与一个重复尝试的次数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpnamespace Illuminate\Database\Concerns;use Closure;use Throwable;trait ManagesTransactions&#123; /** * 在事务中执行闭包 * * @param \Closure $callback * @param int $attempts * @return mixed * * @throws \Throwable */ public function transaction(Closure $callback, $attempts = 1) &#123; for ($currentAttempt = 1; $currentAttempt &lt;= $attempts; $currentAttempt++) &#123; $this-&gt;beginTransaction(); // 我们将简单地在try/catch块中执行给定的回调，如果捕获到任何异常， // 我们可以回滚该事务，这样就不会使这些事务实际持久化到数据库或以永久方式存储。 try &#123; $callbackResult = $callback($this); &#125; // 如果我们捕获到异常，我们将回滚此事务，如果没有超出尝试次数，就重试。 // 如果超出，我们将抛出异常，让开发人员处理未捕获的异常。 catch (Throwable $e) &#123; $this-&gt;handleTransactionException( $e, $currentAttempt, $attempts ); continue; &#125; try &#123; $this-&gt;commit(); &#125; catch (Throwable $e) &#123; $this-&gt;handleCommitTransactionException( $e, $currentAttempt, $attempts ); continue; &#125; return $callbackResult; &#125; &#125;&#125; 开始事务数据库事务中非常重要的成员变量是$this-&gt;transactions，它标志着当前事务的进程： 123456789101112131415/** * 启动一个新的数据库事务。 * * @return void * * @throws \Throwable */public function beginTransaction()&#123; $this-&gt;createTransaction(); $this-&gt;transactions++; $this-&gt;fireConnectionEvent('beganTransaction');&#125; 可以看出，当创建事务成功后，就会累加$this-&gt;transactions，并且启动event，创建事务： 123456789101112131415161718192021222324252627/** * 在数据库中创建一个事务。 * * @return void * * @throws \Throwable */protected function createTransaction()&#123; if ($this-&gt;transactions == 0) &#123; $this-&gt;reconnectIfMissingConnection(); try &#123; $this-&gt;getPdo()-&gt;beginTransaction(); &#125; catch (Throwable $e) &#123; $this-&gt;handleBeginTransactionException($e); &#125; &#125; elseif ($this-&gt;transactions &gt;= 1 &amp;&amp; $this-&gt;queryGrammar-&gt;supportsSavepoints()) &#123; $this-&gt;createSavepoint(); &#125;&#125; 如果当前没有任何事务，那么就会调用pdo来开启事务。 如果当前已经在事务保护的范围内，那么就会创建SAVEPOINT，实现数据库嵌套事务：12345678910111213/** * 在数据库中创建一个保存点。 * * @return void * * @throws \Throwable */protected function createSavepoint()&#123; $this-&gt;getPdo()-&gt;exec( $this-&gt;queryGrammar-&gt;compileSavepoint('trans'.($this-&gt;transactions + 1)) );&#125; 1234567891011121314151617&lt;?phpnamespace Illuminate\Database\Query\Grammars;class Grammar extends BaseGrammar&#123; /** * 编译SQL语句以定义一个保存点。 * * @param string $name * @return string */ public function compileSavepoint($name) &#123; return 'SAVEPOINT '.$name; &#125;&#125; 如果创建事务失败，那么就会调用handleBeginTransactionException： 123456789101112131415161718192021/** * 从事务开始处理异常。 * * @param \Throwable $e * @return void * * @throws \Throwable */protected function handleBeginTransactionException(Throwable $e)&#123; if ($this-&gt;causedByLostConnection($e)) &#123; $this-&gt;reconnect(); $this-&gt;getPdo()-&gt;beginTransaction(); &#125; else &#123; throw $e; &#125;&#125; 如果创建事务失败是由于与数据库失去连接的话，那么就会重新连接数据库，否则就要抛出异常。 事务异常事务的异常处理比较复杂，可以先看一看代码：1234567891011121314151617181920212223242526272829303132333435/** * 处理运行事务语句时遇到的异常。 * * @param \Throwable $e * @param int $currentAttempt * @param int $maxAttempts * @return void * * @throws \Throwable */protected function handleTransactionException(Throwable $e, $currentAttempt, $maxAttempts)&#123; // 陷入僵局时，MySQL会回滚整个事务，因此我们不能只是重试查询。 // 我们必须彻底消除该异常，并让开发人员以另一种方式处理它。 // 我们也会减少transactions。 if ($this-&gt;causedByConcurrencyError($e) &amp;&amp; $this-&gt;transactions &gt; 1) &#123; $this-&gt;transactions--; throw $e; &#125; // 如果有异常，我们将回滚该事务，然后我们可以检查是否超出了最大尝试次数， // 如果没有，我们将返回并在循环中再次尝试此查询。 $this-&gt;rollBack(); if ($this-&gt;causedByConcurrencyError($e) &amp;&amp; $currentAttempt &lt; $maxAttempts) &#123; return; &#125; throw $e;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Illuminate\Database;use Illuminate\Support\Str;use PDOException;use Throwable;trait DetectsConcurrencyErrors&#123; /** * 确定给定的异常是否由并发错误（例如死锁或序列化失败）引起。 * * @param \Throwable $e * @return bool */ protected function causedByConcurrencyError(Throwable $e) &#123; if ($e instanceof PDOException &amp;&amp; $e-&gt;getCode() === '40001') &#123; return true; &#125; $message = $e-&gt;getMessage(); return Str::contains($message, [ 'Deadlock found when trying to get lock', 'deadlock detected', 'The database file is locked', 'database is locked', 'database table is locked', 'A table in the database is locked', 'has been chosen as the deadlock victim', 'Lock wait timeout exceeded; try restarting transaction', 'WSREP detected deadlock/conflict and aborted the transaction. Try restarting the transaction', ]); &#125;&#125; 这里可以分为四种情况： 单一事务，非死锁导致的异常 单一事务就是说，此时的事务只有一层，没有嵌套事务的存在。数据库的异常也不是死锁导致的，一般是由于sql语句不正确引起的。这个时候，handleTransactionException会直接回滚事务，并且抛出异常到外层： 123456789101112131415try &#123; return tap($callback($this), function ($result) &#123; $this-&gt;commit(); &#125;);&#125;catch (Exception $e) &#123; $this-&gt;handleTransactionException($e, $currentAttempt, $attempts);&#125; catch (Throwable $e) &#123; $this-&gt;rollBack(); throw $e;&#125; 接到异常之后，程序会再次回滚，但是由于$this-&gt;transactions已经为0，因此回滚直接返回，并未真正执行，之后就会抛出异常。 单一事务，死锁异常 有死锁导致的单一事务异常，一般是由于其他程序同时更改了数据库，这个时候，就要判断当前重复尝试的次数是否大于用户设置的maxAttempts，如果小于就继续尝试，如果大于，那么就会抛出异常。 嵌套事务，非死锁异常 如果出现嵌套事务，例如： 123456789\DB::transaction(function()&#123; ... // 直接或间接调用另一笔交易： \DB::transaction(function() &#123; ... ... &#125;, 2);//attempt twice &#125;, 2);//attempt twice 如果是非死锁导致的异常，那么就要首先回滚内层的事务，抛出异常到外层事务，再回滚外层事务，抛出异常，让用户来处理。也就是说，对于嵌套事务来说，内部事务异常，一定要回滚整个事务，而不是仅仅回滚内部事务。 嵌套事务，死锁异常 嵌套事务的死锁异常，仍然和嵌套事务非死锁异常一样，内部事务异常，一定要回滚整个事务。 但是，不同的是，mysql对于嵌套事务的回滚会导致外部事务一并回滚：InnoDB Error Handling，因此这时，我们仅仅将$this-&gt;transactions减一，并抛出异常，使得外层事务回滚抛出异常即可。 回滚事务如果事务内的数据库更新操作失败，那么就要进行回滚： 12345678910111213141516171819202122232425262728293031323334353637/** * 回滚活跃的数据库事务。 * * @param int|null $toLevel * @return void * * @throws \Throwable */public function rollBack($toLevel = null)&#123; // 我们允许开发人员回滚到某个交易级别。 // 在尝试回滚到该级别之前，我们将验证该给定的交易级别是否有效。 // 如果不是，我们只会退出，不会尝试任何事情。 $toLevel = is_null($toLevel) ? $this-&gt;transactions - 1 : $toLevel; if ($toLevel &lt; 0 || $toLevel &gt;= $this-&gt;transactions) &#123; return; &#125; // 接下来，我们将实际在此数据库中执行此回滚并触发回滚事件。 // 我们还将当前交易级别设置为传递给此方法的给定级别，因此从现在开始就正确了。 try &#123; $this-&gt;performRollBack($toLevel); &#125; catch (Throwable $e) &#123; $this-&gt;handleRollBackException($e); &#125; $this-&gt;transactions = $toLevel; $this-&gt;fireConnectionEvent('rollingBack');&#125; 回滚的第一件事就是要减少$this-&gt;transactions的值，标志当前事务失败。 回滚的时候仍然要判断当前事务的状态，如果当前处于嵌套事务的话，就要进行回滚到SAVEPOINT，如果是单一事务的话，才会真正回滚退出事务： 1234567891011121314151617181920212223242526272829303132/** * 在数据库内执行回滚。 * * @param int $toLevel * @return void * * @throws \Throwable */protected function performRollBack($toLevel)&#123; if ($toLevel == 0) &#123; $this-&gt;getPdo()-&gt;rollBack(); &#125; elseif ($this-&gt;queryGrammar-&gt;supportsSavepoints()) &#123; $this-&gt;getPdo()-&gt;exec( $this-&gt;queryGrammar-&gt;compileSavepointRollBack('trans'.($toLevel + 1)) ); &#125;&#125;/** * 编译SQL语句以执行保存点回滚。 * * @param string $name * @return string */public function compileSavepointRollBack($name)&#123; return 'ROLLBACK TO SAVEPOINT '.$name;&#125; 提交事务提交事务比较简单，仅仅是调用pdo的commit即可。需要注意的是对于嵌套事务的事务提交，commit函数仅仅更新了$this-&gt;transactions，而并没有真正提交事务，原因是内层事务的提交对于mysql来说是无效的，只有外部事务的提交才能更新整个事务。 123456789101112131415161718/** * 提交活跃的数据库事务。 * * @return void * * @throws \Throwable */public function commit()&#123; if ($this-&gt;transactions == 1) &#123; $this-&gt;getPdo()-&gt;commit(); &#125; $this-&gt;transactions = max(0, $this-&gt;transactions - 1); $this-&gt;fireConnectionEvent('committed');&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model关联源码分析]]></title>
    <url>%2F2020%2F05%2F24%2FLaravel-Database-Eloquent-Model%E5%85%B3%E8%81%94%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言数据库表通常相互关联。Laravel中的模型关联功能使得关于数据库的关联代码变得更加简单，更加优雅。本文会详细说说关于模型关联的源码，以便更好的理解和使用关联模型。 定义关联所谓的定义关联，就是在一个Model中定义一个关联函数，我们利用这个关联函数去操作另外一个Model，例如，user表是用户表，posts是用户发的文章，一个用户可以发表多篇文章，我们就可以这样写：1$user-&gt;posts()-&gt;where('active', 1)-&gt;get(); 这表明了我们想通过$user这个用户查询到状态active为1的所有文章，posts就是关联函数，我们可以通过这个关联函数去操作另一个与user关联的表。 在说模型关联的定义之前，我们要先说说父模型与子模型的概念。所谓的父模型是指在模型关系中主动的一方，例如用户模型和文章模型中的用户，相应的子模型就是模型关系中的被动一方，例如文章模型。在正向定义中，被关联的是子模型，而在反向关联中，被关联的是父模型。 我们知道，关联有多种形式，各种关系如下： hasOne一对一我们以官方文档的例子来说明，一个User模型可能关联一个Phone模型： 12345678910class User extends Model&#123; /** * 获得与用户关联的电话记录。 */ public function phone() &#123; $this-&gt;hasOne('App\Phone', 'user_id', 'id'); &#125;&#125; 我们来看看hasOne的源码： 1234567891011121314151617181920212223namespace Illuminate\Database\Eloquent\Concerns;trait HasRelationships&#123; /** * Define a one-to-one relationship. * * @param string $related * @param string|null $foreignKey * @param string|null $localKey * @return \Illuminate\Database\Eloquent\Relations\HasOne */ public function hasOne($related, $foreignKey = null, $localKey = null) &#123; $instance = $this-&gt;newRelatedInstance($related); $foreignKey = $foreignKey ?: $this-&gt;getForeignKey(); $localKey = $localKey ?: $this-&gt;getKeyName(); return $this-&gt;newHasOne($instance-&gt;newQuery(), $this, $instance-&gt;getTable().'.'.$foreignKey, $localKey); &#125;&#125; newRelatedInstance函数负责建立一个新的被关联的模型实例，主要目的是设置数据库连接： 1234567891011121314/** * Create a new model instance for a related model. * * @param string $class * @return mixed */protected function newRelatedInstance($class)&#123; return tap(new $class, function ($instance) &#123; if (! $instance-&gt;getConnectionName()) &#123; $instance-&gt;setConnection($this-&gt;connection); &#125; &#125;);&#125; 在一对一的关系中，foreignKey外键名默认是父模型的类名和主键名的蛇形变量，localKey是父模型的主键名： 1234567891011121314namespace Illuminate\Database\Eloquent;abstract class Model implements Arrayable, ArrayAccess, Jsonable, JsonSerializable, QueueableEntity, UrlRoutable&#123; /** * Get the default foreign key name for the model. * * @return string */ public function getForeignKey() &#123; return Str::snake(class_basename($this)).'_'.$this-&gt;getKeyName(); &#125;&#125; hasOne函数的构造函数继承HasOneOrMany类，也就是说，一对一与一对多构造函数相同，这部分主要设置外键名：123456789101112131415161718192021namespace Illuminate\Database\Eloquent\Relations;abstract class HasOneOrMany extends Relation&#123; /** * Create a new has one or many relationship instance. * * @param \Illuminate\Database\Eloquent\Builder $query * @param \Illuminate\Database\Eloquent\Model $parent * @param string $foreignKey * @param string $localKey * @return void */ public function __construct(Builder $query, Model $parent, $foreignKey, $localKey) &#123; $this-&gt;localKey = $localKey; $this-&gt;foreignKey = $foreignKey; parent::__construct($query, $parent); &#125;&#125; HasOneOrMany类继承Relation类，这部分主要设置parent（父模型）、被关联模型（子模型）与被关联模型（子模型）的查询构造器： 1234567891011121314151617181920212223namespace Illuminate\Database\Eloquent\Relations;/** * @mixin \Illuminate\Database\Eloquent\Builder */abstract class Relation&#123; /** * Create a new relation instance. * * @param \Illuminate\Database\Eloquent\Builder $query * @param \Illuminate\Database\Eloquent\Model $parent * @return void */ public function __construct(Builder $query, Model $parent) &#123; $this-&gt;query = $query; $this-&gt;parent = $parent; $this-&gt;related = $query-&gt;getModel(); $this-&gt;addConstraints(); &#125;&#125; hasOne的模型关系如下： 除了保存被关联模型的查询构造器、被关联模型与parent模型之外，还会提供额外的限制条件：123456789101112131415161718192021222324/** * Set the base constraints on the relation query. * * @return void */public function addConstraints()&#123; if (static::$constraints) &#123; $this-&gt;query-&gt;where($this-&gt;foreignKey, '=', $this-&gt;getParentKey()); $this-&gt;query-&gt;whereNotNull($this-&gt;foreignKey); &#125;&#125;/** * Get the key value of the parent's local key. * * @return mixed */public function getParentKey()&#123; return $this-&gt;parent-&gt;getAttribute($this-&gt;localKey);&#125; 限制条件为被关联模型和关联模型建立外键约束关系：1select phone where phone.user_id = 1 (user.id) hasMany一对多在模型关联的定义中，一对一与一对多源码是一样的：12345678910111213141516171819202122232425namespace Illuminate\Database\Eloquent\Concerns;trait HasRelationships&#123; /** * Define a one-to-many relationship. * * @param string $related * @param string|null $foreignKey * @param string|null $localKey * @return \Illuminate\Database\Eloquent\Relations\HasMany */ public function hasMany($related, $foreignKey = null, $localKey = null) &#123; $instance = $this-&gt;newRelatedInstance($related); $foreignKey = $foreignKey ?: $this-&gt;getForeignKey(); $localKey = $localKey ?: $this-&gt;getKeyName(); return $this-&gt;newHasMany( $instance-&gt;newQuery(), $this, $instance-&gt;getTable().'.'.$foreignKey, $localKey ); &#125;&#125; hasMany的模型关系如下： 限制条件与一对一相同，为被关联模型和关联模型建立外键约束关系：1select phone where phone.user_id = 1 (user.id) belongsTo一对一、一对多反向关联如果想要从文章反向查找作者用户，那么可以定义反向关联： 1234public function user()&#123; return $this-&gt;belongsTo('App\User', 'foreign_key', 'other_key');&#125; belongsTo源码：12345678910111213141516171819202122232425262728293031323334353637383940414243namespace Illuminate\Database\Eloquent\Concerns;trait HasRelationships&#123; /** * Define an inverse one-to-one or many relationship. * * @param string $related * @param string|null $foreignKey * @param string|null $ownerKey * @param string|null $relation * @return \Illuminate\Database\Eloquent\Relations\BelongsTo */ public function belongsTo($related, $foreignKey = null, $ownerKey = null, $relation = null) &#123; // If no relation name was given, we will use this debug backtrace to extract // the calling method's name and use that as the relationship name as most // of the time this will be what we desire to use for the relationships. if (is_null($relation)) &#123; $relation = $this-&gt;guessBelongsToRelation(); &#125; $instance = $this-&gt;newRelatedInstance($related); // If no foreign key was supplied, we can use a backtrace to guess the proper // foreign key name by using the name of the relationship function, which // when combined with an "_id" should conventionally match the columns. if (is_null($foreignKey)) &#123; $foreignKey = Str::snake($relation).'_'.$instance-&gt;getKeyName(); &#125; // Once we have the foreign key names, we'll just create a new Eloquent query // for the related models and returns the relationship instance which will // actually be responsible for retrieving and hydrating every relations. $ownerKey = $ownerKey ?: $instance-&gt;getKeyName(); return $this-&gt;newBelongsTo( $instance-&gt;newQuery(), $this, $foreignKey, $ownerKey, $relation ); &#125;&#125; 正向定义与反向定义不同的是多了一个参数relation，这个参数默认值是从debug_backtrace函数获取的：1234567891011/** * Guess the "belongs to" relationship name. * * @return string */protected function guessBelongsToRelation()&#123; [$one, $two, $caller] = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3); return $caller['function'];&#125; 也就是我们的关联函数名user，belongsTo函数会将关联函数名作为关联名保存起来。 另一个不同是外键的默认名称，不再是类名+主键名，而是关联名+主键名：1234if (is_null($foreignKey)) &#123; $foreignKey = Str::snake($relation).'_'.$instance-&gt;getKeyName();&#125; 我们接着看belongsTo函数：123456789101112131415161718namespace Illuminate\Database\Eloquent\Relations;class BelongsTo extends Relation&#123; public function __construct(Builder $query, Model $child, $foreignKey, $ownerKey, $relationName) &#123; $this-&gt;ownerKey = $ownerKey; $this-&gt;relationName = $relationName; $this-&gt;foreignKey = $foreignKey; // In the underlying base relationship class, this variable is referred to as // the "parent" since most relationships are not inversed. But, since this // one is we will create a "child" variable for much better readability. $this-&gt;child = $child; parent::__construct($query, $child); &#125;&#125; 我们可以看出来，相对于正向关联，反向关联除了保存外键名与主键名之外，还保存了关系名、子模型。值得注意的是，反向关联中related代表父模型，parent代表子模型，与正向关联相反。 hasMany的模型关系如下： 约束条件也相应地进行反转改变： 12345678public function addConstraints()&#123;if (static::$constraints) &#123;$table = $this-&gt;related-&gt;getTable();$this-&gt;query-&gt;where($table.'.'.$this-&gt;ownerKey, '=', $this-&gt;child-&gt;&#123;$this-&gt;foreignKey&#125;);&#125;&#125; 限制条件：1select user where user.id = 1 (post.user_id) belongsMany多对多多对多关系由于中间表的原因相对来说比较复杂，涉及的参数也非常多。我们以官网例子：12345678910class User extends Model&#123; /** * 获得此用户的角色。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Role', 'role_user', 'user_id', 'role_id'); &#125;&#125; User表与role表是多对多关系，另外有一中间表user_role表，我们在定义关系的时候，related是被关联模型，table是中间表，foreignPivotKey是中间表中父模型外键名，relatedPivotKey是中间表中子模型外键名，parentKey是父模型主键名，relatedKey是子模型主键名，relation是关系名。123456789101112131415161718192021public function belongsToMany($related, $table = null, $foreignPivotKey = null, $relatedPivotKey = null, $parentKey = null, $relatedKey = null, $relation = null)&#123;if (is_null($relation)) &#123;$relation = $this-&gt;guessBelongsToManyRelation();&#125;$instance = $this-&gt;newRelatedInstance($related);$foreignPivotKey = $foreignPivotKey ?: $this-&gt;getForeignKey();$relatedPivotKey = $relatedPivotKey ?: $instance-&gt;getForeignKey();if (is_null($table)) &#123;$table = $this-&gt;joiningTable($related);&#125;return new BelongsToMany($instance-&gt;newQuery(), $this, $table, $foreignPivotKey,$relatedPivotKey, $parentKey ?: $this-&gt;getKeyName(),$relatedKey ?: $instance-&gt;getKeyName(), $relation);&#125; 获取关联名称仍然使用的是debug_backtrace函数，不同于guessBelongsToRelation函数只有 belongsTo调用，guessBelongsToManyRelation函数还可以被morphedByMany函数调用，所以不能单纯的限制返回堆栈帧：1234567891011121314public static $manyMethods = ['belongsToMany', 'morphToMany', 'morphedByMany','guessBelongsToManyRelation', 'findFirstMethodThatIsntRelation',];protected function guessBelongsToManyRelation()&#123;$caller = Arr::first(debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS), function ($trace) &#123;return ! in_array($trace['function'], Model::$manyMethods);&#125;);return ! is_null($caller) ? $caller['function'] : null;&#125; 默认的中间表是两个表名的蛇形变量：123456789public function joiningTable($related)&#123;$models = [Str::snake(class_basename($related)),Str::snake(class_basename($this)),];sort($models);return strtolower(implode('_', $models));&#125; BelongsToMany的初始化也需要保存这些变量：12345678910111213public function __construct(Builder $query, Model $parent, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, $relationName = null)&#123;$this-&gt;table = $table;$this-&gt;parentKey = $parentKey;$this-&gt;relatedKey = $relatedKey;$this-&gt;relationName = $relationName;$this-&gt;relatedPivotKey = $relatedPivotKey;$this-&gt;foreignPivotKey = $foreignPivotKey;parent::__construct($query, $parent);&#125; belongsToMany 的模型关系如下：反向的多对多模型关系： 限制条件：123456789101112131415161718192021222324public function addConstraints()&#123;$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;addWhereConstraints();&#125;&#125;protected function performJoin($query = null)&#123;$query = $query ?: $this-&gt;query;$baseTable = $this-&gt;related-&gt;getTable();$key = $baseTable.'.'.$this-&gt;relatedKey;$query-&gt;join($this-&gt;table, $key, '=', $this-&gt;getQualifiedRelatedPivotKeyName());return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125; 本例中wher条件：12select role join role_user on role_user.role_id = 1 (role.id)select role where role_user.user_id = 1 (user.id) hasManyThrough远程一对多远程一对多关联提供了方便、简短的方式通过中间的关联来获得远层的关联。以官方例子来看： 1234567891011121314class Country extends Model&#123; public function posts() &#123; return $this-&gt;hasManyThrough( 'App\Post', 'App\User', 'country_id', // 用户表外键... 'user_id', // 文章表外键... 'id', // 国家表本地键... 'id' // 用户表本地键... ); &#125;&#125; 可以看到，远程一对多的参数比较多。第一个参数related是最终被关联的模型，through是中间模型，firstKey是中间模型关于父模型的外键，secondKey是最终被关联的模型关于中间模型的外键，localKey是父模型的主键，secondLocalKey是中间模型的主键：123456789101112public function hasManyThrough($related, $through, $firstKey = null, $secondKey = null, $localKey = null, $secondLocalKey = null)&#123;$through = new $through;$firstKey = $firstKey ?: $this-&gt;getForeignKey();$secondKey = $secondKey ?: $through-&gt;getForeignKey();$localKey = $localKey ?: $this-&gt;getKeyName();$secondLocalKey = $secondLocalKey ?: $through-&gt;getKeyName();$instance = $this-&gt;newRelatedInstance($related);return new HasManyThrough($instance-&gt;newQuery(), $this, $through, $firstKey, $secondKey, $localKey, $secondLocalKey);&#125; HasManyThrough的初始化：123456789101112public function __construct(Builder $query, Model $farParent, Model $throughParent, $firstKey, $secondKey, $localKey, $secondLocalKey)&#123;$this-&gt;localKey = $localKey;$this-&gt;firstKey = $firstKey;$this-&gt;secondKey = $secondKey;$this-&gt;farParent = $farParent;$this-&gt;throughParent = $throughParent;$this-&gt;secondLocalKey = $secondLocalKey;parent::__construct($query, $throughParent);&#125; hasManyThrough的模型关系如下： 限制条件： 12345678910111213141516171819202122232425262728293031323334353637public function addConstraints()&#123;$localValue = $this-&gt;farParent[$this-&gt;localKey];$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedFirstKeyName(), '=', $localValue);&#125;&#125;protected function performJoin(Builder $query = null)&#123;$query = $query ?: $this-&gt;query;$farKey = $this-&gt;getQualifiedFarKeyName();$query-&gt;join($this-&gt;throughParent-&gt;getTable(), $this-&gt;getQualifiedParentKeyName(), '=', $farKey);if ($this-&gt;throughParentSoftDeletes()) &#123;$query-&gt;whereNull($this-&gt;throughParent-&gt;getQualifiedDeletedAtColumn());&#125;&#125;public function getQualifiedParentKeyName()&#123;return $this-&gt;parent-&gt;getTable().'.'.$this-&gt;secondLocalKey;&#125;public function getQualifiedFarKeyName()&#123;return $this-&gt;getQualifiedForeignKeyName();&#125;public function getQualifiedForeignKeyName()&#123;return $this-&gt;related-&gt;getTable().'.'.$this-&gt;secondKey;&#125;public function getQualifiedFirstKeyName()&#123;return $this-&gt;throughParent-&gt;getTable().'.'.$this-&gt;firstKey;&#125; 本例中的限制条件： 123select post join user on user.id = post.user_idselect post where user.delete_at is nullselect post where user.country_id = 1 (country.id) morphOne/morphMany多态关联 多态关联允许我们应用一个表来单独作为多个表的属性，多态关联存在一对一、一对多、多对多的情形。所谓一对一、一对多是指，一个模型只拥有一个属性或多个属性，例如官网中的例子： 用户可以「评论」文章和视频。使用多态关联，您可以用一个comments表同时满足这两个使用场景 1234567891011121314151617181920class Post extends Model&#123;/*** 获得此文章的所有评论。*/public function comments()&#123;return $this-&gt;morphMany('App\Comment', 'commentable');&#125;&#125;class Video extends Model&#123;/*** 获得此视频的所有评论。*/public function comments()&#123;return $this-&gt;morphMany('App\Comment', 'commentable');&#125;&#125; 这个 comments 表就是属性表，当文章和视频只能有一个评论的时候，那么就是一对一多态关联；如果文章和视频可以由多个评论的时候，就是一对多多态关联。 这种属性表一般会有两个固定的字段： commentable_type用于标识该条评论是文章的还是视频的、 commentable_id 用于记录文章或视频的主键 id 。我们可以把多态关联看作普通的一对一、一对多关系，只是外键参数是 type 与id 的组合。related 是属性表，也就是这里的 comments ，type参数是属性表中存储父模型类型的列名(commentable_type)， id 参数是属性表中存储父模型主键的列名(commentable_id)，而name专用于省略type参数与id参数，localKey是指父模型的主键。123456789101112131415161718192021222324public function morphOne($related, $name, $type = null, $id = null, $localKey = null)&#123;$instance = $this-&gt;newRelatedInstance($related);list($type, $id) = $this-&gt;getMorphs($name, $type, $id);$table = $instance-&gt;getTable();$localKey = $localKey ?: $this-&gt;getKeyName();return new MorphOne($instance-&gt;newQuery(), $this, $table.'.'.$type, $table.'.'.$id, $localKey);&#125;public function morphMany($related, $name, $type = null, $id = null, $localKey = null)&#123;$instance = $this-&gt;newRelatedInstance($related);list($type, $id) = $this-&gt;getMorphs($name, $type, $id);$table = $instance-&gt;getTable();$localKey = $localKey ?: $this-&gt;getKeyName();return new MorphMany($instance-&gt;newQuery(), $this, $table.'.'.$type, $table.'.'.$id, $localKey);&#125;protected function getMorphs($name, $type, $id)&#123;return [$type ?: $name.'_type', $id ?: $name.'_id'];&#125; 一对一、一对多多态关联主要保存属性表中表示类型的列名，还有需要向该类型列中写入的父模型名称，一般来说，默认会写父模型的类名( App\Post 、 App\Video )12345678910111213141516public function __construct(Builder $query, Model $parent, $type, $id, $localKey)&#123;$this-&gt;morphType = $type;$this-&gt;morphClass = $parent-&gt;getMorphClass();parent::__construct($query, $parent, $id, $localKey);&#125;public function getMorphClass()&#123;$morphMap = Relation::morphMap();if (! empty($morphMap) &amp;&amp; in_array(static::class, $morphMap)) &#123;return array_search(static::class, $morphMap, true);&#125;return static::class;&#125; 不过我们也可以自定义写入的值： 1234Relation::morphMap(['posts' =&gt; 'App\Post','videos' =&gt; 'App\Video',]); 这样，就会把App\Post换成posts， App\Video换成videos。我们来看看这个多态映射表函数：1234567891011121314151617181920public static function morphMap(array $map = null, $merge = true)&#123;$map = static::buildMorphMapFromModels($map);if (is_array($map)) &#123;static::$morphMap = $merge &amp;&amp; static::$morphMap? array_merge(static::$morphMap, $map) :$map;&#125;return static::$morphMap;&#125;protected static function buildMorphMapFromModels(array $models= null)&#123;if (is_null($models) || Arr::isAssoc($models)) &#123;return $models;&#125;return array_combine(array_map(function ($model) &#123;return (new $model)-&gt;getTable();&#125;, $models), $models);&#125; 可以看到， buildMorphMapFromModels 函数将字符串App\Post转为model，并利用array_combine转为键。 morphOne的模型关系如下： morphMany的模型关系如下：限制条件：12345678910111213141516public function addConstraints()&#123;if (static::$constraints) &#123;parent::addConstraints();$this-&gt;query-&gt;where($this-&gt;morphType, $this-&gt;morphClass);&#125;&#125;public function addConstraints()&#123;if (static::$constraints) &#123;$this-&gt;query-&gt;where($this-&gt;foreignKey, '=', $this-&gt;getParentKey());$this-&gt;query-&gt;whereNotNull($this-&gt;foreignKey);&#125;&#125; 本例中的限制条件：123select comments where comment.commentable_id = post.idselect comments where comment.commentable_id is not nullselect comments where comment.commentable_type = 'App\Post' morphTo 反向多态关联 和一对一、一对多的 belongsTo 相似，多态关联还可以定义反向关联morphTo :12345678910class Comment extends Model&#123;/*** 获得拥有此评论的模型。*/public function commentable()&#123;return $this-&gt;morphTo();&#125;&#125; 与 belongsTo 类似， morphTo 也是利用 debug_backtrace 获取关联名称。当前如果正处于预加载状态的时候， Comment 一般还没有从数据库获取数据，$this-&gt;{$type}是空值，这个时候需要去除预加载来初始化：12345678910111213141516171819202122232425262728public function morphTo($name = null, $type = null, $id = null)&#123;$name = $name ?: $this-&gt;guessBelongsToRelation();list($type, $id) = $this-&gt;getMorphs(Str::snake($name), $type, $id);return empty($class = $this-&gt;&#123;$type&#125;)? $this-&gt;morphEagerTo($name, $type, $id): $this-&gt;morphInstanceTo($class, $name, $type, $id);&#125;protected function morphEagerTo($name, $type, $id)&#123;return new MorphTo($this-&gt;newQuery()-&gt;setEagerLoads([]), $this, $id, null,$type, $name);&#125;protected function morphInstanceTo($target, $name, $type, $id)&#123;$instance = $this-&gt;newRelatedInstance(static::getActualClassNameForMorph($target));return new MorphTo($instance-&gt;newQuery(), $this, $id, $instance-&gt;getKeyName(), $type, $name);&#125; 多态的成员变量 morphType 代表属性表的类型列， morphClass MorphTo的成员变量只有一个 morphType :1234567public function __construct(Builder $query, Model $parent, $foreignKey, $ownerKey, $type, $relation)&#123;$this-&gt;morphType = $type;parent::__construct($query, $parent, $foreignKey, $ownerKey,$relation);&#125; morphTo 的模型关系如下：限制条件与 belongsTo 相同：12345678public function addConstraints()&#123;if (static::$constraints) &#123;$table = $this-&gt;related-&gt;getTable();$this-&gt;query-&gt;where($table.'.'.$this-&gt;ownerKey, '=', $this-&gt;child-&gt;&#123;$this-&gt;foreignKey&#125;);&#125;&#125; 本例中的限制条件 1select post where post.id = comments.commentable_id 多对多多态关联除了传统的多态关联，您也可以定义「多对多」的多态关联。例如，Post模型和Video模型可以共享一个多态关联至 Tag 模型。 使用多对多多态关联可以让您在文章和视频中共享唯一的标签列表。 12345678910class Post extends Model&#123;/*** 获得此文章的所有标签。*/public function tags()&#123;return $this-&gt;morphToMany('App\Tag', 'taggable');&#125;&#125; 多对多多态关联与多对多关联的代码类似，不同的是中间表不再是两个父模型的蛇形变量，而是name的复数，值得注意的是foreignPivotKey代表中间表中对当前post或者video的外键，一般会放在taggable_id字段中，relatedPivotKey代表中间表中对属性表 tag 的外键 tag_id :123456789101112131415161718192021public function morphToMany($related, $name, $table = null, $foreignPivotKey = null,$relatedPivotKey = null, $parentKey = null,$relatedKey = null, $inverse = false)&#123;$caller = $this-&gt;guessBelongsToManyRelation();$instance = $this-&gt;newRelatedInstance($related);$foreignPivotKey = $foreignPivotKey ?: $name.'_id';$relatedPivotKey = $relatedPivotKey ?: $instance-&gt;getForeignKey();$table = $table ?: Str::plural($name);return new MorphToMany($instance-&gt;newQuery(), $this, $name, $table,$foreignPivotKey, $relatedPivotKey, $parentKey ?: $this-&gt;getKeyName(),$relatedKey ?: $instance-&gt;getKeyName(), $caller, $inverse);&#125; MorphToMany的构造函数依然有morphType与morphClass，morphType标识着当前中间表的记录类型是Post，还是videos，morphClass的值默认值是Post类或者videos的全名，正向关联的时候， inverse是false，反向关联的时候，inverse是true 。1234567891011121314public function __construct(Builder $query, Model $parent, $name, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, $relationName = null, $inverse = false)&#123;$this-&gt;inverse = $inverse;$this-&gt;morphType = $name.'_type';$this-&gt;morphClass = $inverse ? $query-&gt;getModel()-&gt;getMorphClass() : $parent-&gt;getMorphClass();parent::__construct($query, $parent, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, $relationName);&#125; 正向关联的时候， parent 类是 Post 类或者 videos 类，反向关联的时候related 是 Post 类或者 videos 类。限制条件：12345678910111213141516171819protected function addWhereConstraints()&#123;parent::addWhereConstraints();$this-&gt;query-&gt;where($this-&gt;table.'.'.$this-&gt;morphType, $this-&gt;morphClass);return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125;public function getQualifiedForeignPivotKeyName()&#123;return $this-&gt;table.'.'.$this-&gt;foreignPivotKey;&#125; 官网中例子限制条件转化为 sql (假设 Post 的主键为 1) ： 12where taggables.taggable_id = 1;where taggables.taggable_type = 'App\Post' morphToMany 的模型关系如下： 限制条件： 12345678910111213141516171819202122232425262728293031public function addConstraints()&#123;$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;addWhereConstraints();&#125;&#125;protected function performJoin($query = null)&#123;$query = $query ?: $this-&gt;query;$baseTable = $this-&gt;related-&gt;getTable();$key = $baseTable.'.'.$this-&gt;relatedKey;$query-&gt;join($this-&gt;table, $key, '=', $this-&gt;getQualifiedRelatedPivotKeyName());return $this;&#125;protected function addWhereConstraints()&#123;parent::addWhereConstraints();$this-&gt;query-&gt;where($this-&gt;table.'.'.$this-&gt;morphType, $this-&gt;morphClass);return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125; 本例中的限制条件：123select tag join tagable on tagable.tag_id = tag.idselect tags where tagable.tagables_id = post.idselect tags where tagable.tagables_type = 'App\Tag' 多对多多态反向关联官方文档例子：12345678910class Tag extends Model&#123;/*** 获得此标签下所有的文章。*/public function posts()&#123;return $this-&gt;morphedByMany('App\Post', 'taggable');&#125;&#125; 与正向关联相反，relatedPivotKey代表中间表中对related表post或者video的外键，一般会放在taggable_id字段中， foreignPivotKey代表中间表中对当前属性表tag的外键tag_id： 12345678910111213public function morphedByMany($related, $name, $table = null, $foreignPivotKey = null,$relatedPivotKey = null, $parentKey = null, $relatedKey = null)&#123;$foreignPivotKey = $foreignPivotKey ?: $this-&gt;getForeignKey();$relatedPivotKey = $relatedPivotKey ?: $name.'_id';return $this-&gt;morphToMany($related, $name, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, true);&#125; 官网中例子限制条件转化为 sql (假设 Tag 的主键为 1) ： 12where taggables.tag_id = 1;where taggables.taggable_type = 'App\Post' morphedByMany 的模型关系如下：限制条件与 morphToMany 一致： 1234567891011121314151617181920212223242526272829303132public function addConstraints()&#123;$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;addWhereConstraints();&#125;&#125;protected function performJoin($query = null)&#123;$query = $query ?: $this-&gt;query;$baseTable = $this-&gt;related-&gt;getTable();$key = $baseTable.'.'.$this-&gt;relatedKey;$query-&gt;join($this-&gt;table, $key, '=', $this-&gt;getQualifiedRelatedPivotKeyName());return $this;&#125;protected function addWhereConstraints()&#123;parent::addWhereConstraints();$this-&gt;query-&gt;where($this-&gt;table.'.'.$this-&gt;morphType, $this-&gt;morphClass);return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125; 本例中的限制条件123select post join post on post.id = tagables.tagable_idselect post where tagables.tag_id = tag.idselect post where tagables.tagable_type = 'App\Post']]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-控制器方法的参数构建与运行]]></title>
    <url>%2F2020%2F05%2F24%2FLaravel-HTTP-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言经过前面一系列中间件的工作，现在请求终于要达到了正确的控制器方法了。本篇文章主要讲Laravel如何调用控制器方法，并且为控制器方法依赖注入构建参数的过程。 路由控制器的调用我们前面已经解析过中间件的搜集与排序、pipeline的原理，接下来就要进行路由的run运行函数： 1234567891011121314151617181920212223242526272829namespace Illuminate\Routing;class Router implements BindingRegistrar, RegistrarContract&#123; /** * Run the given route within a Stack "onion" instance. * * @param \Illuminate\Routing\Route $route * @param \Illuminate\Http\Request $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) &#123; $shouldSkipMiddleware = $this-&gt;container-&gt;bound('middleware.disable') &amp;&amp; $this-&gt;container-&gt;make('middleware.disable') === true; $middleware = $shouldSkipMiddleware ? [] : $this-&gt;gatherRouteMiddleware($route); return (new Pipeline($this-&gt;container)) -&gt;send($request) -&gt;through($middleware) -&gt;then(function ($request) use ($route) &#123; return $this-&gt;prepareResponse( $request, $route-&gt;run() ); &#125;); &#125;&#125; 路由的run函数主要负责路由控制器方法与路由闭包函数的运行：123456789101112131415161718192021222324namespace Illuminate\Routing;class Route&#123; /** * Run the route action and return the response. * * @return mixed */ public function run() &#123; $this-&gt;container = $this-&gt;container ?: new Container; try &#123; if ($this-&gt;isControllerAction()) &#123; return $this-&gt;runController(); &#125; return $this-&gt;runCallable(); &#125; catch (HttpResponseException $e) &#123; return $e-&gt;getResponse(); &#125; &#125;&#125; 路由的运行主要靠ControllerDispatcher这个类：1234567891011121314151617181920212223242526class Route&#123; /** * Checks whether the route's action is a controller. * * @return bool */ protected function isControllerAction() &#123; return is_string($this-&gt;action['uses']); &#125; /** * Run the route action and return the response. * * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException */ protected function runController() &#123; return $this-&gt;controllerDispatcher()-&gt;dispatch( $this, $this-&gt;getController(), $this-&gt;getControllerMethod() ); &#125;&#125; 123456789101112131415161718192021222324252627282930namespace Illuminate\Routing;use Illuminate\Container\Container;use Illuminate\Routing\Contracts\ControllerDispatcher as ControllerDispatcherContract;class ControllerDispatcher implements ControllerDispatcherContract&#123; use RouteDependencyResolverTrait; /** * Dispatch a request to a given controller and method. * * @param \Illuminate\Routing\Route $route * @param mixed $controller * @param string $method * @return mixed */ public function dispatch(Route $route, $controller, $method) &#123; $parameters = $this-&gt;resolveClassMethodDependencies( $route-&gt;parametersWithoutNulls(), $controller, $method ); if (method_exists($controller, 'callAction')) &#123; return $controller-&gt;callAction($method, $parameters); &#125; return $controller-&gt;&#123;$method&#125;(...array_values($parameters)); &#125;&#125; 上面可以很清晰地看出，控制器的运行分为两步：解析函数参数、调用callAction 解析控制器方法参数解析参数的功能主要由ControllerDispatcher类的RouteDependencyResolverTrait这一trait负责： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace Illuminate\Routing;use Illuminate\Support\Arr;use ReflectionFunctionAbstract;use ReflectionMethod;use ReflectionParameter;trait RouteDependencyResolverTrait&#123; /** * Resolve the object method's type-hinted dependencies. * * @param array $parameters * @param object $instance * @param string $method * @return array */ protected function resolveClassMethodDependencies(array $parameters, $instance, $method) &#123; if (! method_exists($instance, $method)) &#123; return $parameters; &#125; return $this-&gt;resolveMethodDependencies( $parameters, new ReflectionMethod($instance, $method) ); &#125; /** * Resolve the given method's type-hinted dependencies. * * @param array $parameters * @param \ReflectionFunctionAbstract $reflector * @return array */ public function resolveMethodDependencies(array $parameters, ReflectionFunctionAbstract $reflector) &#123; $instanceCount = 0; $values = array_values($parameters); foreach ($reflector-&gt;getParameters() as $key =&gt; $parameter) &#123; $instance = $this-&gt;transformDependency( $parameter, $parameters ); if (! is_null($instance)) &#123; $instanceCount++; $this-&gt;spliceIntoParameters($parameters, $key, $instance); &#125; elseif (! isset($values[$key - $instanceCount]) &amp;&amp; $parameter-&gt;isDefaultValueAvailable()) &#123; $this-&gt;spliceIntoParameters($parameters, $key, $parameter-&gt;getDefaultValue()); &#125; &#125; return $parameters; &#125;&#125; 控制器方法函数参数构造难点在于，参数来源有三种： 路由参数赋值 IoC容器自动注入 函数自带默认值 在IoC容器自动注入的时候，要保证路由的现有参数中没有相应的类，防止依赖注入覆盖路由绑定的参数： 1234567891011121314151617181920/** * Attempt to transform the given parameter into a class instance. * * @param \ReflectionParameter $parameter * @param array $parameters * @return mixed */protected function transformDependency(ReflectionParameter $parameter, $parameters)&#123; $class = $parameter-&gt;getClass(); // If the parameter has a type-hinted class, we will check to see if it is already in // the list of parameters. If it is we will just skip it as it is probably a model // binding and we do not want to mess with those; otherwise, we resolve it here. if ($class &amp;&amp; ! $this-&gt;alreadyInParameters($class-&gt;name, $parameters)) &#123; return $parameter-&gt;isDefaultValueAvailable() ? $parameter-&gt;getDefaultValue() : $this-&gt;container-&gt;make($class-&gt;name); &#125;&#125; 由IoC容器构造出的参数需要插入到原有的路由参数数组中： 123456789101112131415161718192021if (! is_null($instance)) &#123; $instanceCount++; $this-&gt;spliceIntoParameters($parameters, $key, $instance);&#125;/** * Splice the given value into the parameter list. * * @param array $parameters * @param string $offset * @param mixed $value * @return void */protected function spliceIntoParameters(array &amp;$parameters, $offset, $value)&#123; array_splice( $parameters, $offset, 0, [$value] );&#125; 当路由的参数数组与IoC容器构造的参数数量不足以覆盖控制器参数个数时，就要去判断控制器是否具有默认参数： 1234elseif (! isset($values[$key - $instanceCount]) &amp;&amp; $parameter-&gt;isDefaultValueAvailable()) &#123; $this-&gt;spliceIntoParameters($parameters, $key, $parameter-&gt;getDefaultValue());&#125; 调用控制器方法callAction所有的控制器并非是直接调用相应方法的，而是通过callAction函数再分配，如果实在没有相应方法还会调用魔术方法__call() : 12345678910111213141516171819202122232425262728293031323334namespace Illuminate\Routing;use BadMethodCallException;abstract class Controller&#123; /** * Execute an action on the controller. * * @param string $method * @param array $parameters * @return \Symfony\Component\HttpFoundation\Response */ public function callAction($method, $parameters) &#123; return call_user_func_array([$this, $method], $parameters); &#125; /** * Handle calls to missing methods on the controller. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125;&#125; 路由闭包函数的调用路由闭包函数的调用与控制器方法一样，仍然需要依赖注入，参数构造： 1234567891011121314151617class Route&#123; /** * Run the route action and return the response. * * @return mixed */ protected function runCallable() &#123; $callable = $this-&gt;action['uses']; return $callable(...array_values($this-&gt;resolveMethodDependencies( $this-&gt;parametersWithoutNulls(), new ReflectionFunction($this-&gt;action['uses']) ))); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-数据库服务的启动与连接]]></title>
    <url>%2F2020%2F05%2F23%2FLaravel-Database-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言大致的讲，Laravel的数据库功能可以分为两部分：数据库DB、数据库Eloquent Model。数据库的Eloquent是功能十分丰富的ORM，让我们可以避免写繁杂的SQL语句。数据库DB是比较底层的与PDO交互的功能，Eloquent的底层依赖于DB。本文将会介绍数据库DB中关于数据库服务的启动与连接部分。 在详细讲解数据库各个功能之前，我们先看看支撑着整个Laravel数据库功能的框架： DB也就是DatabaseManager，承担着数据库接口的工作，一切数据库相关的操作，例如查询、更新、插入、删除都可以通过DB这个接口来完成。但是，具体的调用PDO API的工作却不是由该类完成的，它仅仅是一个对外的接口而已。 ConnectionFactory顾名思义专门为DB构造初始化Connector、Connection对象。 Connector负责数据库的连接功能，为保障程序的高效，Laravel将其包装成为闭包函数，并将闭包函数作为Connection的一个成员对象，实现懒加载。 Connection负责数据库的具体功能，负责底层与PDO API的交互。 数据库服务的注册与启动数据库服务也是一种服务提供者。 Illuminate\Database\DatabaseServiceProvider.php 123456789101112131415namespace Illuminate\Database;class DatabaseServiceProvider extends ServiceProvider&#123; public function register() &#123; Model::clearBootedModels(); $this-&gt;registerConnectionServices(); $this-&gt;registerEloquentFactory(); $this-&gt;registerQueueableEntityResolver(); &#125;&#125; 我们先来看这个注册函数的第一句：Model::clearBootedModels()。这一句其实是为了Eloquent服务的启动做准备。数据库的Eloquent Model有一个静态的成员变量数组$booted，这个静态数组存储了所有已经被初始化的数据库model，以便加载数据库模型时更加迅速。因此，在Eloquent服务启动之前需要初始化静态成员变量$booted： Illuminate\Database\Eloquent\Model.php 123456789101112131415161718192021222324252627282930namespace Illuminate\Database\Eloquent;abstract class Model implements Arrayable, ArrayAccess, Jsonable, JsonSerializable, QueueableEntity, UrlRoutable&#123; /** * 已经初始化的数据库 * * @var array */ protected static $booted = []; /** * The array of global scopes on the model. * * @var array */ protected static $globalScopes = []; /** * 清除已经初始化的数据库的列表，以便将其重新初始化。 * * @return void */ public static function clearBootedModels() &#123; static::$booted = []; static::$globalScopes = []; &#125;&#125; 接下来我们就开始看数据库服务的注册最重要的两部分：ConnectionServices与Eloquent。 ConnectionServices注册 Illuminate\Database\DatabaseServiceProvider.php 12345678910111213141516171819202122232425262728namespace Illuminate\Database;class DatabaseServiceProvider extends ServiceProvider&#123; /** * 注册主数据库绑定。 * * @return void */ protected function registerConnectionServices() &#123; // ConnectionFactory用于在数据库上创建实际的连接实例。 // 我们会将工厂注入到manager中，以便它可以在实际需要时（而不是以前）建立连接。 $this-&gt;app-&gt;singleton('db.factory', function ($app) &#123; return new ConnectionFactory($app); &#125;); // DatabaseManager用于解析各种连接，因为可以管理多个连接。 // 它还实现了连接解析器接口，该接口可以由需要连接的其他组件使用。 $this-&gt;app-&gt;singleton('db', function ($app) &#123; return new DatabaseManager($app, $app['db.factory']); &#125;); $this-&gt;app-&gt;bind('db.connection', function ($app) &#123; return $app['db']-&gt;connection(); &#125;); &#125;&#125; 可以看出，数据库服务向IoC容器注册了db、db.factory与db.connection。 最重要的莫过于db对象，它有一个Facade是DB，我们可以利用DB::connection()来连接任意数据库，可以利用DB::select()来进行数据库的查询，可以说DB就是我们操作数据库的接口。 db.factory负责为DB创建connector提供数据库的底层连接服务，负责为DB创建connection对象来进行数据库的查询等操作。 db.connection是Laravel用于与数据库pdo接口进行交互的底层类，可用于数据库的查询、更新、创建等操作。 Eloquent注册12345678910111213141516171819202122namespace Illuminate\Database;class DatabaseServiceProvider extends ServiceProvider&#123; /** * 在容器中注册Eloquent工厂实例。 * * @return void */ protected function registerEloquentFactory() &#123; $this-&gt;app-&gt;singleton(FakerGenerator::class, function ($app, $parameters) &#123; return FakerFactory::create($parameters['locale'] ?? $app['config']-&gt;get('app.faker_locale', 'en_US')); &#125;); $this-&gt;app-&gt;singleton(EloquentFactory::class, function ($app) &#123; return EloquentFactory::construct( $app-&gt;make(FakerGenerator::class), $this-&gt;app-&gt;databasePath('factories') ); &#125;); &#125;&#125; EloquentFactory用于创建Eloquent Model，用于全局函数factory()来创建数据库模型。 数据库服务的启动1234567891011/** * 初始化应用程序事件。 * * @return void */public function boot()&#123; Model::setConnectionResolver($this-&gt;app['db']); Model::setEventDispatcher($this-&gt;app['events']);&#125; 数据库服务的启动主要设置Eloquent Model的connection resolver，用于数据库模型model利用db来连接数据库。还有设置数据库事件的分发器dispatcher，用于监听数据库的事件。 DatabaseManager-数据库的接口如果我们想要使用任何数据库服务，首先要做的事情当然是利用用户名与密码来连接数据库。在Laravel中，数据库的用户名与密码一般放在.env文件中或者放入nginx配置中，并且利用数据库的接口DB来与pdo进行交互，利用pdo来连接数据库。 DB即是类Illuminate\Database\DatabaseManager，首先我们来看看其构造函数： 1234567891011121314namespace Illuminate\Database;class DatabaseManager implements ConnectionResolverInterface&#123; public function __construct($app, ConnectionFactory $factory) &#123; $this-&gt;app = $app; $this-&gt;factory = $factory; $this-&gt;reconnector = function ($connection) &#123; $this-&gt;reconnect($connection-&gt;getName()); &#125;; &#125;&#125; 我们称DB为一个接口，或者是一个门面模式，是因为数据库操作，例如数据库的连接或者查询、更新等操作均不是DB的功能，数据库的连接使用类Illuminate\Database\Connectors\Connector完成，数据库的查询等操作由类Illuminate\Database\Connection完成，因此，我们不必直接操作connector或者connection，仅仅会操作DB即可。 那么DB是如何实现connector或者connection的功能的呢？关键还是这个ConnectionFactory类，这个工厂类专门为DB来生成connection对象，并将其放入DB的成员变量数组$connections中去。connection中会包含connector对象来实现数据库的连接工作。 12345678910111213namespace Illuminate\Database;class DatabaseManager implements ConnectionResolverInterface&#123; protected $app; protected $factory; protected $connections = []; public function __call($method, $parameters) &#123; return $this-&gt;connection()-&gt;$method(...$parameters); &#125;&#125; 魔术函数实现了DB与connection的无缝连接，任何对数据库的操作，例如DB::select()、DB::table(‘user’)-&gt;save()，都会被转移至connection中去。 connection函数-获取数据库连接对象123456789101112131415161718192021222324252627282930313233343536373839namespace Illuminate\Database;use Illuminate\Database\Connectors\ConnectionFactory;use Illuminate\Support\Arr;use Illuminate\Support\ConfigurationUrlParser;use Illuminate\Support\Str;use InvalidArgumentException;use PDO;/** * @mixin \Illuminate\Database\Connection */class DatabaseManager implements ConnectionResolverInterface&#123; /** * 获取数据库连接实例。 * * @param string|null $name * @return \Illuminate\Database\Connection */ public function connection($name = null) &#123; [$database, $type] = $this-&gt;parseConnectionName($name); $name = $name ?: $database; // 如果尚未创建此连接，则将基于应用程序中提供的配置来创建它。 // 创建连接后，我们将为PDO设置“fetch mode”，该模式将确定查询返回类型。 if (! isset($this-&gt;connections[$name])) &#123; $this-&gt;connections[$name] = $this-&gt;configure( $this-&gt;makeConnection($database), $type ); &#125; return $this-&gt;connections[$name]; &#125;&#125; 具体流程如下： DB的connection函数可以传入数据库的名字，也可以不传任何参数，此时会连接默认数据库，默认数据库的设置在config/database文件中。 connection函数流程： 解析数据库名称与数据库类型，例如只读、写。 若没有创建过与该数据库的连接，则开始创建数据库连接。 返回数据库连接对象Connection。 123456789101112131415161718192021222324252627282930313233343536373839namespace Illuminate\Database;use Illuminate\Database\Connectors\ConnectionFactory;use Illuminate\Support\Arr;use Illuminate\Support\ConfigurationUrlParser;use Illuminate\Support\Str;use InvalidArgumentException;use PDO;/** * @mixin \Illuminate\Database\Connection */class DatabaseManager implements ConnectionResolverInterface&#123; /** * 将连接解析为名称和读/写类型的数组。 * * @param string $name * @return array */ protected function parseConnectionName($name) &#123; $name = $name ?: $this-&gt;getDefaultConnection(); return Str::endsWith($name, ['::read', '::write']) ? explode('::', $name, 2) : [$name, null]; &#125; /** * 获取默认的连接名称。 * * @return string */ public function getDefaultConnection() &#123; return $this-&gt;app['config']['database.default']; &#125;&#125; 可以看出，若没有特别指定连接的数据库名称，那么就会利用文件config/database文件中设置的default数据库名称作为默认连接数据库名称。若数据库支持读写分离，那么还可以指定数据库的读写属性，例如mysql::read。 makeConnection函数-创建新的数据库连接对象当框架从未连接过当前数据库的时候，就要对数据库进行连接操作，首先程序会调用makeConnection函数：123456789101112131415161718192021222324252627/** * make数据库连接实例。 * * @param string $name * @return \Illuminate\Database\Connection */protected function makeConnection($name)&#123; $config = $this-&gt;configuration($name); // 首先，我们将通过连接名称进行检查，以查看是否已为该连接专门注册了扩展名。 // 如果有，我们将调用Closure并将其传递给配置，以使其能够解析连接。 if (isset($this-&gt;extensions[$name])) &#123; return call_user_func($this-&gt;extensions[$name], $config, $name); &#125; // 接下来，我们将检查是否已为驱动程序注册了扩展名， // 如果已注册，则将调用Closure，这将使我们能够为驱动程序本身使用更通用的解析器， //该解析器适用于所有连接。 if (isset($this-&gt;extensions[$driver = $config['driver']])) &#123; return call_user_func($this-&gt;extensions[$driver], $config, $name); &#125; return $this-&gt;factory-&gt;make($config, $name);&#125; 可以看出，连接数据库仅仅需要两个步骤：获取数据库配置、利用connection factory获取connection对象。 获取数据库配置： 123456789101112131415161718192021222324/** * 获取连接的配置。 * * @param string $name * @return array * * @throws \InvalidArgumentException */protected function configuration($name)&#123; $name = $name ?: $this-&gt;getDefaultConnection(); // 要获取数据库连接配置，我们将仅提取每个连接配置并获取给定名称的配置。 // 如果配置不存在，我们将抛出异常并撒手不管。 $connections = $this-&gt;app['config']['database.connections']; if (is_null($config = Arr::get($connections, $name))) &#123; throw new InvalidArgumentException("Database connection [&#123;$name&#125;] not configured."); &#125; return (new ConfigurationUrlParser) -&gt;parseConfiguration($config);&#125; 也是非常简单，直接从配置文件中获取当前数据库的配置： 123456789101112131415161718192021'connections' =&gt; [ 'mysql' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST', '127.0.0.1'), 'port' =&gt; env('DB_PORT', '3306'), 'database' =&gt; env('DB_DATABASE', 'forge'), 'username' =&gt; env('DB_USERNAME', 'forge'), 'password' =&gt; env('DB_PASSWORD', ''), 'charset' =&gt; 'utf8mb4', 'collation' =&gt; 'utf8mb4_unicode_ci', 'prefix' =&gt; '', 'strict' =&gt; true, 'engine' =&gt; null, 'read' =&gt; [ 'database' =&gt; env('DB_DATABASE', 'forge'), ], 'write' =&gt; [ 'database' =&gt; env('DB_DATABASE', 'forge'), ], ],], $this-&gt;factory-&gt;make($config, $name)函数向我们提供了数据库连接对象。 configure-连接对象读写配置当我们从connection factory中获取到连接对象connection之后，我们就要根据传入的参数进行读写配置：1234567891011121314151617181920212223242526/** * 准备数据库连接实例。 * * @param \Illuminate\Database\Connection $connection * @param string $type * @return \Illuminate\Database\Connection */protected function configure(Connection $connection, $type)&#123; $connection = $this-&gt;setPdoForType($connection, $type); // 首先，我们将设置获取模式以及数据库连接的其他一些依赖性。 // 该方法基本上只是配置并准备好供应用程序使用。 // 完成后，我们将其退回。 if ($this-&gt;app-&gt;bound('events')) &#123; $connection-&gt;setEventDispatcher($this-&gt;app['events']); &#125; // 在这里，我们将设置一个reconnector回调。 // 此重新连接器可以是任何可调用的， // 因此我们将设置一个Closure以使用连接名从该管理器重新连接， // 这将允许我们从连接中重新连接。 $connection-&gt;setReconnector($this-&gt;reconnector); return $connection;&#125; setPdoForType函数就是根据type来设置读写： 当我们需要read数据库连接时，我们将read-pdo设置为主pdo。当我们需要write数据库连接时，我们将读写pdo都设置为write-pdo： 1234567891011121314151617181920/** * 准备数据库连接实例的读/写模式。 * * @param \Illuminate\Database\Connection $connection * @param string|null $type * @return \Illuminate\Database\Connection */protected function setPdoForType(Connection $connection, $type = null)&#123; if ($type === 'read') &#123; $connection-&gt;setPdo($connection-&gt;getReadPdo()); &#125; elseif ($type === 'write') &#123; $connection-&gt;setReadPdo($connection-&gt;getPdo()); &#125; return $connection;&#125; ConnectionFactory-数据库连接对象工厂 make函数-工厂接口获取到了数据库的配置参数之后，就要利用ConnectionFactory来获取connection对象了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Database\Connectors;use Illuminate\Contracts\Container\Container;use Illuminate\Database\Connection;use Illuminate\Database\MySqlConnection;use Illuminate\Database\PostgresConnection;use Illuminate\Database\SQLiteConnection;use Illuminate\Database\SqlServerConnection;use Illuminate\Support\Arr;use InvalidArgumentException;use PDOException;class ConnectionFactory&#123; /** * 根据配置建立PDO连接。 * * @param array $config * @param string|null $name * @return \Illuminate\Database\Connection */ public function make(array $config, $name = null) &#123; $config = $this-&gt;parseConfig($config, $name); if (isset($config['read'])) &#123; return $this-&gt;createReadWriteConnection($config); &#125; return $this-&gt;createSingleConnection($config); &#125; /** * 解析并准备数据库配置。 * * @param array $config * @param string $name * @return array */ protected function parseConfig(array $config, $name) &#123; return Arr::add(Arr::add($config, 'prefix', ''), 'name', $name); &#125;&#125; 在建立连接之前，要先向配置参数中添加默认的prefix属性与name属性。 接着，就要判断我们在配置文件中是否设置了读写分离。如果设置了读写分离，那么就会调用createReadWriteConnection函数，生成具有读、写两个功能的connection；否则的话，就会调用createSingleConnection函数，生成普通的连接对象。 createSingleConnection函数-制造数据库连接对象createSingleConnection函数是类ConnectionFactory的核心，用于生成新的数据库连接对象。 1234567891011121314/** * 创建一个数据库连接单例。 * * @param array $config * @return \Illuminate\Database\Connection */protected function createSingleConnection(array $config)&#123; $pdo = $this-&gt;createPdoResolver($config); return $this-&gt;createConnection( $config['driver'], $pdo, $config['database'], $config['prefix'], $config );&#125; ConnectionFactory也很简单，只做了两件事情：制造pdo连接的闭包函数、构造一个新的connection对象。 createPdoResolver-数据库连接器闭包函数根据配置参数中是否含有host，创建不同的闭包函数： 123456789101112/** * 创建一个新的Closure，解析为PDO实例。 * * @param array $config * @return \Closure */protected function createPdoResolver(array $config)&#123; return array_key_exists('host', $config) ? $this-&gt;createPdoResolverWithHosts($config) : $this-&gt;createPdoResolverWithoutHosts($config);&#125; 不带有host的pdo闭包函数： 123456789101112/** * 创建一个新的Closure，解析为没有配置主机的PDO实例。 * * @param array $config * @return \Closure */protected function createPdoResolverWithoutHosts(array $config)&#123; return function () use ($config) &#123; return $this-&gt;createConnector($config)-&gt;connect($config); &#125;;&#125; 可以看出，不带有pdo的闭包函数非常简单，仅仅创建connector对象，利用connector对象进行数据库的连接。 带有host的pdo闭包函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 创建一个新的Closure，解析为具有特定主机或主机阵列的PDO实例。 * * @param array $config * @return \Closure */protected function createPdoResolverWithHosts(array $config)&#123; return function () use ($config) &#123; foreach (Arr::shuffle($hosts = $this-&gt;parseHosts($config)) as $key =&gt; $host) &#123; $config['host'] = $host; try &#123; return $this-&gt;createConnector($config)-&gt;connect($config); &#125; catch (PDOException $e) &#123; continue; &#125; &#125; throw $e; &#125;;&#125;/** * 将主机配置项解析为一个数组。 * * @param array $config * @return array * * @throws \InvalidArgumentException */protected function parseHosts(array $config)&#123; $hosts = Arr::wrap($config['host']); if (empty($hosts)) &#123; throw new InvalidArgumentException('Database hosts array is empty.'); &#125; return $hosts;&#125; 带有host的闭包函数相对比较复杂，首先程序会随机选择不同的数据库依次来建立数据库连接，若均失败，就会报告异常。 createConnector-创建连接器程序会根据配置参数中driver的不同来创建不同的连接器，每个连接器都继承自connector类，用于连接数据库。 12345678910111213141516171819202122232425262728293031323334/** * 根据配置创建连接器实例。 * * @param array $config * @return \Illuminate\Database\Connectors\ConnectorInterface * * @throws \InvalidArgumentException */public function createConnector(array $config)&#123; if (! isset($config['driver'])) &#123; throw new InvalidArgumentException('A driver must be specified.'); &#125; if ($this-&gt;container-&gt;bound($key = "db.connector.&#123;$config['driver']&#125;")) &#123; return $this-&gt;container-&gt;make($key); &#125; switch ($config['driver']) &#123; case 'mysql': return new MySqlConnector; case 'pgsql': return new PostgresConnector; case 'sqlite': return new SQLiteConnector; case 'sqlsrv': return new SqlServerConnector; &#125; throw new InvalidArgumentException("Unsupported driver [&#123;$config['driver']&#125;]");&#125; createConnection-创建连接对象123456789101112131415161718192021222324252627282930313233/** * 创建一个新的连接实例。 * * @param string $driver * @param \PDO|\Closure $connection * @param string $database * @param string $prefix * @param array $config * @return \Illuminate\Database\Connection * * @throws \InvalidArgumentException */protected function createConnection($driver, $connection, $database, $prefix = '', array $config = [])&#123; if ($resolver = Connection::getResolver($driver)) &#123; return $resolver($connection, $database, $prefix, $config); &#125; switch ($driver) &#123; case 'mysql': return new MySqlConnection($connection, $database, $prefix, $config); case 'pgsql': return new PostgresConnection($connection, $database, $prefix, $config); case 'sqlite': return new SQLiteConnection($connection, $database, $prefix, $config); case 'sqlsrv': return new SqlServerConnection($connection, $database, $prefix, $config); &#125; throw new InvalidArgumentException("Unsupported driver [&#123;$driver&#125;]");&#125; 创建pdo闭包函数之后，会将该闭包函数放入connection对象当中去。以后我们利用connection对象进行查询或者更新数据库时，程序便会运行该闭包函数，与数据库进行连接。 createReadWriteConnection-创建读写连接对象当配置文件中有read、write等配置项时，说明用户希望创建一个可以读写分离的数据库连接，此时：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 创建一个数据库连接单例。 * * @param array $config * @return \Illuminate\Database\Connection */protected function createReadWriteConnection(array $config)&#123; $connection = $this-&gt;createSingleConnection($this-&gt;getWriteConfig($config)); return $connection-&gt;setReadPdo($this-&gt;createReadPdo($config));&#125;/** * 获取读/写连接的读配置。 * * @param array $config * @return array */protected function getWriteConfig(array $config)&#123; return $this-&gt;mergeReadWriteConfig( $config, $this-&gt;getReadWriteConfig($config, 'write') );&#125;/** * 获取读/写级别配置。 * * @param array $config * @param string $type * @return array */protected function getReadWriteConfig(array $config, $type)&#123; return isset($config[$type][0]) ? Arr::random($config[$type]) : $config[$type];&#125;/** * 合并读/写连接的配置。 * * @param array $config * @param array $merge * @return array */protected function mergeReadWriteConfig(array $config, array $merge)&#123; return Arr::except(array_merge($config, $merge), ['read', 'write']);&#125; 可以看出，程序先读出关于write数据库的配置，之后将其合并到总配置当中，删除关于read数据库的配置，然后进行createSingleConnection建立新的连接对象。 建立连接对象之后，再根据read数据库的配置，生成read数据库的pdo闭包函数，并调用setReadPdo将其设置为读库pdo。1234567891011121314151617181920212223/** * 创建一个新的PDO实例进行读取。 * * @param array $config * @return \Closure */protected function createReadPdo(array $config)&#123; return $this-&gt;createPdoResolver($this-&gt;getReadConfig($config));&#125;/** * 获取读/写连接的读配置。 * * @param array $config * @return array */protected function getReadConfig(array $config)&#123; return $this-&gt;mergeReadWriteConfig( $config, $this-&gt;getReadWriteConfig($config, 'read') );&#125; Connector连接我们以MySQL为例：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Illuminate\Database\Connectors;use PDO;class MySqlConnector extends Connector implements ConnectorInterface&#123; /** * 建立数据库连接。 * * @param array $config * @return \PDO */ public function connect(array $config) &#123; $dsn = $this-&gt;getDsn($config); $options = $this-&gt;getOptions($config); // 我们需要获取在创建全新连接实例时应使用的PDO选项。 // PDO选项控制连接行为的各个方面，某些可能由开发人员指定。 $connection = $this-&gt;createConnection($dsn, $config, $options); if (! empty($config['database'])) &#123; $connection-&gt;exec("use `&#123;$config['database']&#125;`;"); &#125; $this-&gt;configureEncoding($connection, $config); // 接下来，我们将检查是否在此配置中指定了时区， // 如果已指定，则将发出一条语句来修改数据库的时区。 // 设置此数据库时区是可选配置项。 $this-&gt;configureTimezone($connection, $config); $this-&gt;setModes($connection, $config); return $connection; &#125;&#125; getDsn-获取数据库连接DSN参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 从配置中创建一个DSN字符串。 * * 根据“ unix_socket”配置值选择socket或host/port。 * * @param array $config * @return string */protected function getDsn(array $config)&#123; return $this-&gt;hasSocket($config) ? $this-&gt;getSocketDsn($config) : $this-&gt;getHostDsn($config);&#125;/** * 确定给定的配置数组是否具有UNIX套接字值。 * * @param array $config * @return bool */protected function hasSocket(array $config)&#123; return isset($config['unix_socket']) &amp;&amp; ! empty($config['unix_socket']);&#125;/** * 获取套接字配置的DSN字符串。 * * @param array $config * @return string */protected function getSocketDsn(array $config)&#123; return "mysql:unix_socket=&#123;$config['unix_socket']&#125;;dbname=&#123;$config['database']&#125;";&#125;/** * 获取主机/端口配置的DSN字符串。 * * @param array $config * @return string */protected function getHostDsn(array $config)&#123; extract($config, EXTR_SKIP); return isset($port) ? "mysql:host=&#123;$host&#125;;port=&#123;$port&#125;;dbname=&#123;$database&#125;" : "mysql:host=&#123;$host&#125;;dbname=&#123;$database&#125;";&#125; mysql数据库的连接有两种：tcp连接与socket连接。 socket连接更快，但是它要求应用程序与数据库在同一台机器，更普通的是使用tcp的方式连接数据库。框架根据配置参数来选择是采用socket还是tcp的方式连接数据库。 getOptions-pdo属性设置12345678910111213141516171819202122232425/** * 默认的PDO连接选项。 * * @var array */protected $options = [ PDO::ATTR_CASE =&gt; PDO::CASE_NATURAL, PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_ORACLE_NULLS =&gt; PDO::NULL_NATURAL, PDO::ATTR_STRINGIFY_FETCHES =&gt; false, PDO::ATTR_EMULATE_PREPARES =&gt; false,];/** * 根据配置获取PDO选项。 * * @param array $config * @return array */public function getOptions(array $config)&#123; $options = $config['options'] ?? []; return array_diff_key($this-&gt;options, $options) + $options;&#125; pdo的属性主要有以下几种： PDO::ATTR_CASE强制列名为指定的大小写。他的$value可为： PDO::CASE_LOWER：强制列名小写。 PDO::CASE_NATURAL：保留数据库驱动返回的列名。 PDO::CASE_UPPER：强制列名大写。 PDO::ATTR_ERRMODE：错误报告。他的$value可为： PDO::ERRMODE_SILENT：仅设置错误代码。 PDO::ERRMODE_WARNING：引发E_WARNING错误。 PDO::ERRMODE_EXCEPTION：抛出exceptions异常。 PDO::ATTR_ORACLE_NULLS（在所有驱动中都可用，不仅限于Oracle）：转换NULL和空字符串。他的$value可为: PDO::NULL_NATURAL：不转换。 PDO::NULL_EMPTY_STRING：将空字符串转换成NULL。 PDO::NULL_TO_STRING：将NULL转换成空字符串。 PDO::ATTR_STRINGIFY_FETCHES：提取的时候将数值转换为字符串。 PDO::ATTR_EMULATE_PREPARES 启用或禁用预处理语句的模拟。有些驱动不支持或有限度地支持本地预处理。使用此设置强制PDO总是模拟预处理语句（如果为TRUE），或试着使用本地预处理语句（如果为FALSE）。如果驱动不能成功预处理当前查询，它将总是回到模拟预处理语句上。 需要bool类型。 PDO::ATTR_AUTOCOMMIT：设置当前连接MySQL服务器的客户端的SQL语句是否自动执行，默认是自动提交。 PDO::ATTR_PERSISTENT：当前对MySQL服务器的连接是否是长连接. createConnection-创建数据库连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 创建一个新的PDO连接。 * * @param string $dsn * @param array $config * @param array $options * @return \PDO * * @throws \Exception */public function createConnection($dsn, array $config, array $options)&#123; [ $username, $password ] = [ $config['username'] ?? null, $config['password'] ?? null, ]; try &#123; return $this-&gt;createPdoConnection( $dsn, $username, $password, $options ); &#125; catch (Exception $e) &#123; return $this-&gt;tryAgainIfCausedByLostConnection( $e, $dsn, $username, $password, $options ); &#125;&#125;/** * 创建一个新的PDO连接实例。 * * @param string $dsn * @param string $username * @param string $password * @param array $options * @return \PDO */protected function createPdoConnection($dsn, $username, $password, $options)&#123; if (class_exists(PDOConnection::class) &amp;&amp; ! $this-&gt;isPersistentConnection($options)) &#123; return new PDOConnection($dsn, $username, $password, $options); &#125; return new PDO($dsn, $username, $password, $options);&#125; 当pdo对象成功的建立起来后，说明我们已经与数据库成功地建立起来了一个连接，接下来我们就可以利用这个pdo对象进行查询或者更新等操作。 当创建pdo的时候抛出异常时： 12345678910111213141516171819202122/** * 处理在查询执行期间发生的查询异常。 * * @param \Illuminate\Database\QueryException $e * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function tryAgainIfCausedByLostConnection(QueryException $e, $query, $bindings, Closure $callback)&#123; if ($this-&gt;causedByLostConnection($e-&gt;getPrevious())) &#123; $this-&gt;reconnect(); return $this-&gt;runQueryCallback($query, $bindings, $callback); &#125; throw $e;&#125; Illuminate\Database\DetectsLostConnections.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Database;use Illuminate\Support\Str;use Throwable;trait DetectsLostConnections&#123; /** * 确定给定的异常是否由丢失的连接引起。 * * @param \Throwable $e * @return bool */ protected function causedByLostConnection(Throwable $e) &#123; $message = $e-&gt;getMessage(); return Str::contains($message, [ 'server has gone away', 'no connection to the server', 'Lost connection', 'is dead or not enabled', 'Error while sending', 'decryption failed or bad record mac', 'server closed the connection unexpectedly', 'SSL connection has been closed unexpectedly', 'Error writing data to the connection', 'Resource deadlock avoided', 'Transaction() on null', 'child connection forced to terminate due to client_idle_limit', 'query_wait_timeout', 'reset by peer', 'Physical connection is not usable', 'TCP Provider: Error code 0x68', 'ORA-03114', 'Packets out of order. Expected', 'Adaptive Server connection failed', 'Communication link failure', 'connection is no longer usable', 'Login timeout expired', 'Connection refused', 'running with the --read-only option so it cannot execute this statement', ]); &#125;&#125; 当判断出的异常是上面几种情况时，框架会再次尝试连接数据库。 configureEncoding-设置字符集与校对集123456789101112131415161718192021222324252627/** * 设置连接字符集和排序规则。 * * @param \PDO $connection * @param array $config * @return void */protected function configureEncoding($connection, $config)&#123; if (! isset($config['charset'])) &#123; return; &#125; $connection-&gt;prepare("set names '&#123;$config['charset']&#125;'")-&gt;execute();&#125;/** * 获取配置的排序规则。 * * @param array $config * @return string */protected function getCollation(array $config)&#123; return isset($config['collation']) ? " collate '&#123;$config['collation']&#125;'" : '';&#125; 如果配置参数中设置了字符集与校对集，程序会利用配置的参数对数据库进行相关设置。 所谓的字符集与校对集设置，可以参考mysql中character set与collation的点滴理解 configureTimezone-设置时间区12345678910111213/** * 在连接上设置时区。 * * @param \PDO $connection * @param array $config * @return void */protected function configureTimezone($connection, array $config)&#123; if (isset($config['timezone'])) &#123; $connection-&gt;prepare('set time_zone="'.$config['timezone'].'"')-&gt;execute(); &#125;&#125; setModes-设置SQL_MODE模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 设置连接模式。 * * @param \PDO $connection * @param array $config * @return void */protected function setModes(PDO $connection, array $config)&#123; if (isset($config['modes'])) &#123; $this-&gt;setCustomModes($connection, $config); &#125; elseif (isset($config['strict'])) &#123; if ($config['strict']) &#123; $connection-&gt;prepare($this-&gt;strictMode($connection))-&gt;execute(); &#125; else &#123; $connection-&gt;prepare("set session sql_mode='NO_ENGINE_SUBSTITUTION'")-&gt;execute(); &#125; &#125;&#125;/** * 在连接上设置自定义模式。 * * @param \PDO $connection * @param array $config * @return void */protected function setCustomModes(PDO $connection, array $config)&#123; $modes = implode(',', $config['modes']); $connection-&gt;prepare("set session sql_mode='&#123;$modes&#125;'")-&gt;execute();&#125;/** * 获取查询以启用严格模式。 * * @param \PDO $connection * @return string */protected function strictMode(PDO $connection)&#123; if (version_compare($connection-&gt;getAttribute(PDO::ATTR_SERVER_VERSION), '8.0.11') &gt;= 0) &#123; return "set session sql_mode='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'"; &#125; return "set session sql_mode='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'";&#125; 以下内容参考：mysql的sql_mode设置简介: SQL_MODE直接理解就是：sql的运作模式。官方的说法是：sql_mode可以影响sql支持的语法以及数据的校验执行，这使得MySQL可以运行在不同的环境中以及和其他数据库一起运作。 想设置sql_mode有三种方式： 在命令行启动MySQL时添加参数—sql-mode=”modes” 在MySQL的配置文件（my.cnf或者my.ini）中添加一个配置sql-mode=”modes” 运行时修改SQL mode可以通过以下命令之一：12SET GLOBAL sql_mode = &apos;modes&apos;;SET SESSION sql_mode = &apos;modes&apos;; 几种常见的mode介绍： ONLY_FULL_GROUP_BY：出现在select语句、HAVING条件和ORDER BY语句中的列，必须是GROUP BY的列或者依赖于GROUP BY列的函数列。 NO_AUTO_VALUE_ON_ZERO：该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 STRICT_TRANS_TABLES：在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制 NO_ZERO_IN_DATE：这个模式影响了是否允许日期中的月份和日包含0。如果开启此模式，2016-01-00是不允许的，但是0000-02-01是允许的。它实际的行为受到strict mode是否开启的影响1。 NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期。它实际的行为受到strict mode是否开启的影响。 ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULL NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户 NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 PIPES_AS_CONCAT：将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似 ANSI_QUOTES：启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-路由加载源码分析]]></title>
    <url>%2F2020%2F05%2F22%2FLaravel-HTTP-%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言作为Laravel极其重要的一部分，route功能贯穿着整个网络请求，是request生命周期的主干。本文主要讲述route服务的注册与启动、路由的属性注册。本篇内容相对简单，更多的是框架添加路由的整体设计流程。 route服务的注册Laravel在接受到请求后，先进行了服务容器与http核心的初始化，再进行了请求request的构造与分发。 route服务的注册-RoutingServiceProvider发生在服务容器container的初始化上； route服务的启动与加载-RouteServiceProvider发生在request的分发上。 route服务的注册-RoutingServiceProvider所有需要Laravel服务的请求都会加载入口文件index.php： 123require __DIR__.'/../vendor/autoload.php';$app = require_once __DIR__.'/../bootstrap/app.php'; 第一句我们在之前的博客提过，是实现PSR0、PSR4标准自动加载的功能模块，第二句就是今天说的Container的初始化：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php/*|--------------------------------------------------------------------------| Create The Application|--------------------------------------------------------------------------|| The first thing we will do is create a new Laravel application instance| which serves as the "glue" for all the components of Laravel, and is| the IoC container for the system binding all of the various parts.|*/$app = new Illuminate\Foundation\Application( $_ENV['APP_BASE_PATH'] ?? dirname(__DIR__));/*|--------------------------------------------------------------------------| Bind Important Interfaces|--------------------------------------------------------------------------|| Next, we need to bind some important interfaces into the container so| we will be able to resolve them when needed. The kernels serve the| incoming requests to this application from both the web and CLI.|*/$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class);/*|--------------------------------------------------------------------------| Return The Application|--------------------------------------------------------------------------|| This script returns the application instance. The instance is given to| the calling script so we can separate the building of the instances| from the actual running of the application and sending responses.|*/return $app; Application： 123456789101112131415161718192021namespace Illuminate\Foundation;class Application extends Container implements ApplicationContract, CachesConfiguration, CachesRoutes, HttpKernelInterface&#123; /** * Create a new Illuminate application instance. * * @param string|null $basePath * @return void */ public function __construct($basePath = null) &#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases(); &#125;&#125; 路由服务的注册就在registerBaseServiceProviders()这个函数中：1234567891011/** * Register all of the base service providers. * * @return void */protected function registerBaseServiceProviders()&#123; $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this));&#125; RoutingServiceProvider：123456789101112131415161718192021222324namespace Illuminate\Routing;class RoutingServiceProvider extends ServiceProvider&#123; public function register() &#123; $this-&gt;registerRouter(); ... &#125; /** * Register the router instance. * * @return void */ protected function registerRouter() &#123; $this-&gt;app-&gt;singleton('router', function ($app) &#123; return new Router($app['events'], $app); &#125;); &#125; ...&#125; 可以看到，RoutingServiceProvider做的事情比较简单，就是向服务容易中注册router。 route服务的启动与加载-RouteServiceProviderLaravel在初始化Application后，就要进行http/Kernel的构造： 12345$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture()); 初始化结束后，就会调用handle函数，这个函数用于Laravel各个功能服务的注册启动，还有request的分发： 1234567891011121314151617181920public function handle($request)&#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; return $response;&#125;protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap();//各种服务的注册与 return (new Pipeline($this-&gt;app))//请求的分发 -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [ ] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 路由服务的启动与加载就在其中一个函数中bootstrap，这个函数用于各种服务的注册与启动，比较复杂，我们有机会在以后单独来说。 总之，这个函数会调用RouteServiceProvider这个类的两个函数：注册-register、启动-boot。 由于route的注册工作由之前RoutingServiceProvider完成，所以RouteServiceProvider的register是空的，这里它只负责路由的启动与加载工作，我们主要看boot：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849namespace Illuminate\Foundation\Support\Providers;class RouteServiceProvider extends ServiceProvider&#123; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; $this-&gt;setRootControllerNamespace(); if ($this-&gt;routesAreCached()) &#123; $this-&gt;loadCachedRoutes(); &#125; else &#123; $this-&gt;loadRoutes(); $this-&gt;app-&gt;booted(function () &#123; $this-&gt;app['router']-&gt;getRoutes()-&gt;refreshNameLookups(); $this-&gt;app['router']-&gt;getRoutes()-&gt;refreshActionLookups(); &#125;); &#125; &#125; /** * Load the cached routes for the application. * * @return void */ protected function loadCachedRoutes() &#123; $this-&gt;app-&gt;booted(function () &#123; require $this-&gt;app-&gt;getCachedRoutesPath(); &#125;); &#125; /** * Load the application routes. * * @return void */ protected function loadRoutes() &#123; if (method_exists($this, 'map')) &#123; $this-&gt;app-&gt;call([$this, 'map']); &#125; &#125;&#125; 12345678910111213141516171819202122class Application extends Container implements ApplicationContract, CachesConfiguration, CachesRoutes, HttpKernelInterface&#123; /** * Determine if the application routes are cached. * * @return bool */ public function routesAreCached() &#123; return $this['files']-&gt;exists($this-&gt;getCachedRoutesPath()); &#125; /** * Get the path to the routes cache file. * * @return string */ public function getCachedRoutesPath() &#123; return $this-&gt;normalizeCachePath('APP_ROUTES_CACHE', 'cache/routes-v7.php'); &#125;&#125; 从boot中可以看出，Laravel首先去寻找路由的缓存文件，没有缓存文件再去进行加载路由。缓存文件一般在bootstrap/cache/routes.php文件中。 加载路由主要调用map函数，这个函数一般在App\Providers\RouteServiceProvider这个类中，这个类继承上面的Illuminate\Foundation\Support\Providers\RouteServiceProvider：1234567891011121314151617181920212223242526use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;class RouteServiceProvider extends ServiceProvider&#123; public function map() &#123; $this-&gt;mapApiRoutes(); $this-&gt;mapWebRoutes(); // &#125; protected function mapWebRoutes() &#123; Route::middleware('web') -&gt;namespace($this-&gt;namespace) -&gt;group(base_path('routes/web.php')); &#125; protected function mapApiRoutes() &#123; Route::prefix('api') -&gt;middleware('api') -&gt;namespace($this-&gt;namespace) -&gt;group(base_path('routes/api.php')); &#125;&#125; Laravel将路由分为两个大组：api、web。这两个部分的路由分别写在两个文件中：routes/web.php、routes/api.php。 路由的加载所谓的路由加载，就是将定义路由时添加的属性，例如’name’、’domain’、’scheme’等等保存起来，以待后用。 Laravel定义路由的属性的方法很灵活，可以定义在路由群组前，例如： 123Route::domain('route.domain.name')-&gt;group(function() &#123; Route::get('foo','controller@method');&#125;) 可以定义在路由群组中，例如： 123Route::group('domain' =&gt; 'group.domain.name',function() &#123; Route::get('foo','controller@method');&#125;) 可以定义在method的前面，例如： 1Route::domain('route.domain.name')-&gt;get('foo','controller@method'); 可以定义在method中，例如： 1Route::get('foo', ['domain' =&gt; 'route.domain.name','use' =&gt; 'controller@method']); 还可以定义在method后，例如： 1Route::get('&#123;one&#125;', 'use' =&gt; 'controller@method')-&gt;where('one', '(.+)'); 事实上，路由的加载功能主要有三个类负责： Illuminate\Routing\Router、Illuminate\Routing\Route、Illuminate\Routing\RouteRegistrar。 Router在整个路由功能中都是起着中枢的作用，RouteRegistrar主要负责位于group、method这些函数之前的属性注册，例如上面的第一种和第三种，route主要负责位于group、method这些函数之后的属性注册，例如第五种。 RouteRegistrar路由加载属性注册当我们想要在Route后面直接利用domain()、name()等函数来为路由注册属性的时候，我们实际调用的是router的魔术方法__call()： 123456789101112131415161718192021222324namespace Illuminate\Routing;class Router implements BindingRegistrar, RegistrarContract&#123; /** * Dynamically handle calls into the router instance. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (static::hasMacro($method)) &#123; return $this-&gt;macroCall($method, $parameters); &#125; if ($method === 'middleware') &#123; return (new RouteRegistrar($this))-&gt;attribute($method, is_array($parameters[0]) ? $parameters[0] : $parameters); &#125; return (new RouteRegistrar($this))-&gt;attribute($method, $parameters[0]); &#125;&#125; 在类RouteRegistrar中：12345678910111213141516171819202122232425262728293031class RouteRegistrar&#123; /** * The attributes that can be set through this class. * * @var array */ protected $allowedAttributes = [ 'as', 'domain', 'middleware', 'name', 'namespace', 'prefix', 'where', ]; /** * Set the value for a given attribute. * * @param string $key * @param mixed $value * @return $this * * @throws \InvalidArgumentException */ public function attribute($key, $value) &#123; if (! in_array($key, $this-&gt;allowedAttributes)) &#123; throw new InvalidArgumentException("Attribute [&#123;$key&#125;] does not exist."); &#125; $this-&gt;attributes[Arr::get($this-&gt;aliases, $key, $key)] = $value; return $this; &#125;&#125; 添加路由注册属性之后，创建路由的时候，可以仅仅提供uri，可以提供uri与闭包，可以提供uri与控制器，可以提供uri与数组：123456789Route::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar'); // 仅仅uriRoute::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar', function () &#123;&#125;); // uri与闭包Route::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar', 'controller@method');// uri与控制器Route::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar', ['as'=&gt; 'foo','use' =&gt;'controller@method']) ;// uri与数组 利用get、post等方法创建新的路由时，会调用类RouteRegistrar中的魔术方法__call()： Illuminate\Routing\RouteRegistrar.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class RouteRegistrar&#123; /** * The methods to dynamically pass through to the router. * * @var array */ protected $passthru = [ 'get', 'post', 'put', 'patch', 'delete', 'options', 'any', ]; /** * Dynamically handle calls into the route registrar. * * @param string $method * @param array $parameters * @return \Illuminate\Routing\Route|$this * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; if (in_array($method, $this-&gt;passthru)) &#123; return $this-&gt;registerRoute($method, ...$parameters); &#125; if (in_array($method, $this-&gt;allowedAttributes)) &#123; if ($method === 'middleware') &#123; return $this-&gt;attribute($method, is_array($parameters[0]) ? $parameters[0] : $parameters); &#125; return $this-&gt;attribute($method, $parameters[0]); &#125; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; /** * Register a new route with the router. * * @param string $method * @param string $uri * @param \Closure|array|string|null $action * @return \Illuminate\Routing\Route */ protected function registerRoute($method, $uri, $action = null) &#123; if (! is_array($action)) &#123; $action = array_merge($this-&gt;attributes, $action ? ['uses' =&gt; $action] : []); &#125; return $this-&gt;router-&gt;&#123;$method&#125;($uri, $this-&gt;compileAction($action)); &#125; /** * Compile the action into an array including the attributes. * * @param \Closure|array|string|null $action * @return array */ protected function compileAction($action) &#123; if (is_null($action)) &#123; return $this-&gt;attributes; &#125; if (is_string($action) || $action instanceof Closure) &#123; $action = ['uses' =&gt; $action]; &#125; return array_merge($this-&gt;attributes, $action); &#125;&#125; 也就是说，RouteRegistrar在这里会为闭包或控制器等所有非数组的action添加use键，然后才会去router中创建路由。 添加路由群组注册属性之后，还可以创建路由群组，但是这时路由群组不允许添加属性action： 12345678910111213class RouteRegistrar&#123; /** * Create a route group with shared attributes. * * @param \Closure|string $callback * @return void */ public function group($callback) &#123; $this-&gt;router-&gt;group($this-&gt;attributes, $callback); &#125;&#125; Router路由群组加载路由群组的功能可以不断叠加递归，因此每次调用group，都要用新路由群组的属性与旧路由群组属性合并，以待新的路由去继承。group参数可以是闭包函数，也可以是包含定义路由的文件路径。 Illuminate\Routing\Router.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpnamespace Illuminate\Routing;/** * @mixin \Illuminate\Routing\RouteRegistrar */class Router implements BindingRegistrar, RegistrarContract&#123; /** * Create a route group with shared attributes. * * @param array $attributes * @param \Closure|string $routes * @return void */ public function group(array $attributes, $routes) &#123; $this-&gt;updateGroupStack($attributes); // Once we have updated the group stack, we'll load the provided routes and // merge in the group's attributes when the routes are created. After we // have created the routes, we will pop the attributes off the stack. $this-&gt;loadRoutes($routes); array_pop($this-&gt;groupStack); &#125; /** * Update the group stack with the given attributes. * * @param array $attributes * @return void */ protected function updateGroupStack(array $attributes) &#123; if ($this-&gt;hasGroupStack()) &#123; $attributes = $this-&gt;mergeWithLastGroup($attributes); &#125; $this-&gt;groupStack[] = $attributes; &#125; /** * Determine if the router currently has a group stack. * * @return bool */ public function hasGroupStack() &#123; return ! empty($this-&gt;groupStack); &#125; /** * Merge the given array with the last group stack. * * @param array $new * @param bool $prependExistingPrefix * @return array */ public function mergeWithLastGroup($new, $prependExistingPrefix = true) &#123; return RouteGroup::merge($new, end($this-&gt;groupStack), $prependExistingPrefix); &#125;&#125; 关于路由群组属性的合并： prefix、as、namespace这几个属性会连接在一起，例如prefix1/prefix2/prefix3。 where属性数组相同的会被替换，不同的会被合并。 domain属性会被替换。 其他属性，例如middleware数组会直接被合并，即使存在相同的元素。 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\Routing;use Illuminate\Support\Arr;class RouteGroup&#123; /** * Merge route groups into a new array. * * @param array $new * @param array $old * @param bool $prependExistingPrefix * @return array */ public static function merge($new, $old, $prependExistingPrefix = true) &#123; if (isset($new['domain'])) &#123; unset($old['domain']); &#125; $new = array_merge(static::formatAs($new, $old), [ 'namespace' =&gt; static::formatNamespace($new, $old), 'prefix' =&gt; static::formatPrefix($new, $old, $prependExistingPrefix), 'where' =&gt; static::formatWhere($new, $old), ]); return array_merge_recursive(Arr::except( $old, ['namespace', 'prefix', 'where', 'as'] ), $new); &#125;&#125; Router路由加载添加路由需要很多步骤，需要将路由本身的属性和路由群组的属性相结合。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Router implements BindingRegistrar, RegistrarContract&#123; /** * Register a new GET route with the router. * * @param string $uri * @param array|string|callable|null $action * @return \Illuminate\Routing\Route */ public function get($uri, $action = null) &#123; return $this-&gt;addRoute(['GET', 'HEAD'], $uri, $action); &#125; /** * Add a route to the underlying route collection. * * @param array|string $methods * @param string $uri * @param array|string|callable|null $action * @return \Illuminate\Routing\Route */ public function addRoute($methods, $uri, $action) &#123; return $this-&gt;routes-&gt;add($this-&gt;createRoute($methods, $uri, $action)); &#125; /** * Create a new route instance. * * @param array|string $methods * @param string $uri * @param mixed $action * @return \Illuminate\Routing\Route */ protected function createRoute($methods, $uri, $action) &#123; // If the route is routing to a controller we will parse the route action into // an acceptable array format before registering it and creating this route // instance itself. We need to build the Closure that will call this out. if ($this-&gt;actionReferencesController($action)) &#123; $action = $this-&gt;convertToControllerAction($action); &#125; $route = $this-&gt;newRoute( $methods, $this-&gt;prefix($uri), $action ); // If we have groups that need to be merged, we will merge them now after this // route has already been created and is ready to go. After we're done with // the merge we will be ready to return the route back out to the caller. if ($this-&gt;hasGroupStack()) &#123; $this-&gt;mergeGroupAttributesIntoRoute($route); &#125; $this-&gt;addWhereClausesToRoute($route); return $route; &#125;&#125; 从上面来看，添加一个新的路由需要： 给路由的控制器添加group的namespace 给路由的uri添加group的prefix前缀 创建新的路由 更新路由的属性信息 为路由添加router-pattern正则约束 路由添加到RouteCollection中 控制器namespace路由控制器的命名空间一般不用特别指定，默认值是\App\Http\Controllers，每次创建新的路由，都要将默认的命名空间添加到控制器中去：123456789101112131415161718192021222324252627protected function actionReferencesController($action)&#123;if (! $action instanceof Closure) &#123;return is_string($action) || (isset($action['uses']) &amp;&amp;is_string($action['uses']));&#125;return false;&#125;protected function convertToControllerAction($action)&#123;if (is_string($action)) &#123;$action = ['uses' =&gt; $action];&#125;if (! empty($this-&gt;groupStack)) &#123;$action['uses'] = $this-&gt;prependGroupNamespace($action['uses']);&#125;$action['controller'] = $action['uses'];return $action;&#125;protected function prependGroupNamespace($class)&#123;$group = end($this-&gt;groupStack);return isset($group['namespace']) &amp;&amp; strpos($class, '\\') !== 0? $group['namespace'].'\\'.$class : $class;&#125; uri前缀在创建新的路由前，需要将路由群组的prefix添加到路由的uri中：12345678910111213protected function prefix($uri)&#123;return trim(trim($this-&gt;getLastGroupPrefix(), '/').'/'.trim($uri, '/'), '/') ?: '/';&#125;public function getLastGroupPrefix()&#123;if (! empty($this-&gt;groupStack)) &#123;$last = end($this-&gt;groupStack);return isset($last['prefix']) ? $last['prefix'] : '';&#125;return '';&#125; 创建新的路由路由的创建需要Route类： 123456protected function newRoute($methods, $uri, $action)&#123;return (new Route($methods, $uri, $action))-&gt;setRouter($this)-&gt;setContainer($this-&gt;container);&#125; 关于Router类添加新的路由我们在下一部分详细说。 更新路由属性信息创建新的路由之后，需要将路由本身的属性action与路由群组的属性结合在一起：12345678public function hasGroupStack()&#123;return ! empty($this-&gt;groupStack);&#125;protected function mergeGroupAttributesIntoRoute($route)&#123;$route-&gt;setAction($this-&gt;mergeWithLastGroup($route-&gt;getAction()));&#125; 添加全局正则约束到路由上一篇文章我们说过，我们可以为路由通过pattern方法添加全局的参数正则约束，所有每次添加新的路由都要将这个全局正则约束添加到路由中： 1234567891011public function pattern($key, $pattern)&#123;$this-&gt;patterns[$key] = $pattern;&#125;protected function addWhereClausesToRoute($route)&#123;$route-&gt;where(array_merge($this-&gt;patterns, isset($route-&gt;getAction()['where']) ? $route-&gt;getAction()['where'] : []));return $route;&#125; Route路由加载前面说过，路由的创建是由Route这个类完成的：12345678910111213public function __construct($methods, $uri, $action)&#123;$this-&gt;uri = $uri;$this-&gt;methods = (array) $methods;$this-&gt;action = $this-&gt;parseAction($action);if (in_array('GET', $this-&gt;methods) &amp;&amp; ! in_array('HEAD', $this-&gt;methods)) &#123;$this-&gt;methods[] = 'HEAD';&#125;if (isset($this-&gt;action['prefix'])) &#123;$this-&gt;prefix($this-&gt;action['prefix']);&#125;&#125; 由此可以看出，路由的创建主要是路由的各个属性的初始化，其中值得注意的有两个：action与prefix action解析 1234protected function parseAction($action)&#123;return RouteAction::parse($this-&gt;uri, $action);&#125; 我们可以看出，添加新的路由时，action属性需要利用RouteAction类：12345678910111213141516171819202122232425262728293031323334class RouteAction&#123;public static function parse($uri, $action)&#123;if (is_null($action)) &#123;return static::missingAction($uri);&#125;if (is_callable($action)) &#123;return ['uses' =&gt; $action];&#125;elseif (! isset($action['uses'])) &#123;$action['uses'] = static::findCallable($action);&#125;if (is_string($action['uses']) &amp;&amp; ! Str::contains($action['uses'], '@')) &#123;$action['uses'] = static::makeInvokable($action['uses']);&#125;return $action;&#125;protected static function findCallable(array $action)&#123;return Arr::first($action, function ($value, $key) &#123;return is_callable($value) &amp;&amp; is_numeric($key);&#125;);&#125;protected static function makeInvokable($action)&#123;if (! method_exists($action, '__invoke')) &#123;throw new UnexpectedValueException("Invalid route action: [&#123;$action&#125;].");&#125;return $action.'@__invoke';&#125;&#125; 前面的博客我们说过，创建路由的时候，除了为路由分配控制器之外，还可以为路由分配闭包函数，还有类函数，例如之前说的单动作控制器：123456789$router-&gt;get('foo/bar2', [‘domain’ =&gt; 'www.example.com', 'Illuminate\Tests\Routing\ActionStub']);class ActionStub&#123;public function __invoke()&#123;return 'hello';&#125;&#125; 因此，解析action主要做两件事： 为闭包函数添加use键。对于此时没有use键的路由，由于之前在Router中已经为控制器添加use键，因此这时没有use键的，必然是闭包函数，在这里直接或者在action中寻找闭包函数后，为闭包函数添加use键。 单动作控制器添加__invoke 。对于单动作控制器来说，此时已经和控制器一样拥有’use’键，但是并没有@符号，此时就会调用makeInvokable函数来将__invoke添加到后面。 prefix前缀路由自身也有prefix属性，而且这个属性要加在其他prefix的最前面，作为路由的uri： 123456public function prefix($prefix)&#123;$uri = rtrim($prefix, '/').'/'.ltrim($this-&gt;uri, '/');$this-&gt;uri = trim($uri, '/');return $this;&#125; Route路由属性加载除了RouteRegistrar之外，Route也可以为路由添加属性： prefix前缀123456public function prefix($prefix)&#123;$uri = rtrim($prefix, '/').'/'.ltrim($this-&gt;uri, '/');$this-&gt;uri = trim($uri, '/');return $this;&#125; where正则约束123456789101112public function where($name, $expression = null)&#123;foreach ($this-&gt;parseWhere($name, $expression) as $name =&gt; $expression) &#123;$this-&gt;wheres[$name] = $expression;&#125;return $this;&#125;protected function parseWhere($name, $expression)&#123;return is_array($name) ? $name : [$name =&gt; $expression];&#125; middleware中间件1234567891011121314public function middleware($middleware = null)&#123;if (is_null($middleware)) &#123;return (array) Arr::get($this-&gt;action, 'middleware', []);&#125;if (is_string($middleware)) &#123;$middleware = func_get_args();&#125;$this-&gt;action['middleware'] = array_merge((array) Arr::get($this-&gt;action, 'middleware', []), $middleware);return $this;&#125; uses控制器1234567891011121314public function uses($action)&#123; $action = is_string($action) ? $this-&gt;addGroupNamespaceToStringUses($action) : $action; return $this-&gt;setAction( array_merge( $this-&gt;action, $this-&gt;parseAction([ 'uses' =&gt; $action, 'controller' =&gt; $action, ]) ) );&#125; name命名123456public function name($name)&#123; $this-&gt;action['as'] = isset($this-&gt;action['as']) ? $this-&gt;action['as'].$name : $name; return $this;&#125; RouteCollection添加路由在上面的部分，我们看到添加路由的代码： 1234protected function addRoute($methods, $uri, $action)&#123; return $this-&gt;routes-&gt;add($this-&gt;createRoute($methods, $uri,$action));&#125; 新创建的路由会加入到RouteCollection中，会更新类中的routes、allRoutes、nameList、actionList。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpnamespace Illuminate\Routing;use Illuminate\Container\Container;use Illuminate\Http\Request;use Illuminate\Support\Arr;class RouteCollection extends AbstractRouteCollection&#123; /** * Add a Route instance to the collection. * * @param \Illuminate\Routing\Route $route * @return \Illuminate\Routing\Route */ public function add(Route $route) &#123; $this-&gt;addToCollections($route); $this-&gt;addLookups($route); return $route; &#125; /** * Add the given route to the arrays of routes. * * @param \Illuminate\Routing\Route $route * @return void */ protected function addToCollections($route) &#123; $domainAndUri = $route-&gt;getDomain().$route-&gt;uri(); foreach ($route-&gt;methods() as $method) &#123; $this-&gt;routes[$method][$domainAndUri] = $route; &#125; $this-&gt;allRoutes[$method.$domainAndUri] = $route; &#125; /** * Add the route to any look-up tables if necessary. * * @param \Illuminate\Routing\Route $route * @return void */ protected function addLookups($route) &#123; // If the route has a name, we will add it to the name look-up table so that we // will quickly be able to find any route associate with a name and not have // to iterate through every route every time we need to perform a look-up. if ($name = $route-&gt;getName()) &#123; $this-&gt;nameList[$name] = $route; &#125; // When the route is routing to a controller we will also store the action that // is used by the route. This will let us reverse route to controllers while // processing a request and easily generate URLs to the given controllers. $action = $route-&gt;getAction(); if (isset($action['controller'])) &#123; $this-&gt;addToActionList($action, $route); &#125; &#125; /** * Add a route to the controller action dictionary. * * @param array $action * @param \Illuminate\Routing\Route $route * @return void */ protected function addToActionList($action, $route) &#123; $this-&gt;actionList[trim($action['controller'], '\\')] = $route; &#125;&#125; 我们在上面路由的注册启动章节说道，路由的启动是namespace Illuminate\Foundation\Support\Providers\RouteServiceProvider完成的，调用的是boot函数： 123456789101112public function boot()&#123;$this-&gt;setRootControllerNamespace();if ($this-&gt;app-&gt;routesAreCached()) &#123;$this-&gt;loadCachedRoutes();&#125; else &#123;$this-&gt;loadRoutes();$this-&gt;app-&gt;booted(function () &#123;$this-&gt;app['router']-&gt;getRoutes()-&gt;refreshNameLookups();&#125;);&#125;&#125; 在最后一句，程序将会在所有服务都启动后运行refreshNameLookups函数，把所有的name属性加载到RouteCollection中: 1234567891011121314151617181920212223242526272829class RouteCollection extends AbstractRouteCollection&#123; /** * A flattened array of all of the routes. * * @var \Illuminate\Routing\Route[] */ protected $allRoutes = []; /** * Refresh the name look-up table. * * This is done in case any names are fluently defined or if routes are overwritten. * * @return void */ public function refreshNameLookups() &#123; $this-&gt;nameList = []; foreach ($this-&gt;allRoutes as $route) &#123; if ($route-&gt;getName()) &#123; $this-&gt;nameList[$route-&gt;getName()] = $route; &#125; &#125; &#125;&#125; 测试样例如下：1234567891011121314public function testRouteCollectionCanRefreshNameLookups()&#123; $routeIndex = new Route('GET', 'foo/index', ['uses' =&gt; 'FooController@index',]); $this-&gt;assertNull($routeIndex-&gt;getName()); $this-&gt;routeCollection-&gt;add($routeIndex)-&gt;name('route_name'); $this-&gt;assertNull($this-&gt;routeCollection-&gt;getByName('route_name')); $this-&gt;routeCollection-&gt;refreshNameLookups(); $this-&gt;assertEquals($routeIndex, $this-&gt;routeCollection-&gt;getByName('route_name'));&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-路由]]></title>
    <url>%2F2020%2F05%2F22%2FLaravel-HTTP-%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言作为一个web后台框架，路由无疑是极其重要的一部分。本博客接下来几篇文章都将会围绕路由这一主题来展开讨论，分别讲述： 路由的使用 路由属性注册 路由的正则编译与匹配 路由的中间件 路由的控制器与参数绑定 RESTful路由 和之前一样，第一篇将会利用单元测试样例说明我们在平时可能用到的route的api函数用法，后面几篇文章将会剖析Laravel的route源码。下面开始介绍Laravel中路由的各种用法。 路由属性注册所有Laravel路由都定义在位于routes目录下的路由文件中，这些文件通过框架自动加载。routes/web.php文件定义了web界面的路由，这些路由被分配了web中间件组，从而可以提供session和csrf防护等功能。routes/api.php中的路由是无状态的，被分配了api中间件组。 对大多数应用而言，都是从routes/web.php文件开始定义路由。 路由method方法我们可以注册路由来响应任何HTTP请求：123456Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback); 有时候还需要注册路由响应多个HTTP请求——这可以通过match方法来实现。或者，可以使用any方法注册一个路由来响应所有HTTP请求：1234567Route::match(['get', 'post'], '/', function () &#123; //&#125;);Route::any('foo', function () &#123; //&#125;); 值得注意的是，一般的HTML表单仅仅支持get、post，并不支持put、patch、delete等动作，这时候就需要在前端添加一个隐藏的_method字段到给表单中，其值被用作HTTP请求方法名：1&lt;input type="hidden" name="_method" value="PUT"&gt; 在web路由文件中所有请求方式为PUT、POST或DELETE的HTML表单都会包含一个CSRF令牌字段，否则，请求会被拒绝。关于CSRF的更多细节，可以参考浅谈CSRF攻击方式：1234&lt;form method="POST" action="/profile"&gt;&#123;&#123; csrf_field() &#125;&#125;...&lt;/form&gt; 路由scheme协议对于web后台框架来说，路由的scheme底层协议一般使用http、https：1234567Route::get('foo/&#123;bar&#125;', ['http', function () &#123;&#125;]);Route::get('foo/&#123;bar&#125;', ['https', function () &#123;&#125;]); 路由domain子域名子域名可以像URI一样被分配给路由参数，子域名可以通过路由属性中的domain来指定：1234567Route::domain('api.name.bar')-&gt;get('foo/bar', function ($name) &#123; return $name;&#125;);Route::get('foo/bar', ['domain' =&gt; 'api.name.bar', function ($name) &#123; return $name;&#125;]); 路由prefix前缀可以为路由添加一个给定URI前缀，通过利用路由属性的prefix指定： 1234567891011Route::prefix('pre')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['prefix' =&gt; 'pre', function () &#123;&#125;]);Route::get('foo/bar', function () &#123;&#125;)-&gt;prefix('pre'); 路由where正则约束可以为路由的URI参数指定正则约束：1234567Route::get('&#123;one&#125;', ['where' =&gt; ['one' =&gt; '(.+)'], function () &#123;&#125;]);Route::get('&#123;one&#125;', function () &#123;&#125;)-&gt;where('one', '(.+)'); 如果想要路由参数在全局范围内被给定正则表达式约束，可以使用pattern方法。在RouteServiceProvider类的boot方法中定义约束模式： 12345public function boot()&#123; Route::pattern('one', '(.+)'); parent::boot();&#125; 路由middleware中间件为路由添加中间件，通过利用路由属性的middleware指定： 1234567891011Route::middleware('web')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['middleware' =&gt; 'web', function () &#123;&#125;]);Route::get('foo/bar', function () &#123;&#125;)-&gt;middleware('web'); 路由namespace属性可以为路由的控制器添加namespace来指定控制器的命名空间：1234567Route::namespace('Namespace\\Example\\')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['namespace' =&gt; 'Namespace\\Example\\', function () &#123;&#125;]); 路由uses属性可以为路由添加URI对应的执行逻辑，例如闭包或者控制器： 123456789101112Route::get('foo/bar', ['uses' =&gt; function () &#123;&#125;]);Route::get('foo/bar', ['uses' =&gt; 'Illuminate\Tests\Routing\RouteTestControllerStub@index']);Route::get('foo/bar')-&gt;uses(function () &#123;&#125;);Route::get('foo/bar')-&gt;uses('Illuminate\Tests\Routing\RouteTestControllerStub@index'); 路由as别名可以为路由指定别名，通过路由属性的as来指定：123456789101112131415Route::as('Foo')-&gt;get('foo/bar', function () &#123;&#125;);Route::name('Foo')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['as' =&gt; 'Foo', function () &#123;&#125;]);Route::get('foo/bar', function () &#123;&#125;)-&gt;name('Foo'); 路由group群组属性可以为一系列具有类似属性的路由归为同一组，利用group将这些路由归并到一起： 12345678910111213141516171819202122232425262728293031323334353637383940414243Route::group( [ 'domain' =&gt; 'group.domain.name', 'prefix' =&gt; 'grouppre', 'where' =&gt; ['one' =&gt; '(.+)'], 'middleware' =&gt; 'groupMiddleware', 'namespace' =&gt; 'Namespace\\Group\\', 'as' =&gt; 'Group::', ],function () &#123; Route::get('/replace','domain' =&gt; 'route.domain.name','uses' =&gt; function ()&#123; return 'replace'; &#125;); Route::get('additional/&#123;one&#125;/&#123;two&#125;', 'prefix' =&gt; 'routepre','where' =&gt; ['one' =&gt; '([0-9]+)', 'two' =&gt; '(.+)'], 'middleware' =&gt; 'routeMiddleware', 'namespace' =&gt; 'Namespace\\Group\\', 'as' =&gt; 'Route', 'use' =&gt; function () &#123; return 'additional'; &#125;);&#125;);$this-&gt;assertEquals('replace', $router-&gt;dispatch(Request::create('http://route.domain.name/grouppre/replace', 'GET'))-&gt;getContent());$this-&gt;assertEquals('additional', $router-&gt;dispatch(Request::create('http://group.domain.name/routepre/grouppre/additional/111/add', 'GET'))-&gt;getContent());$routes = $router-&gt;getRoutes()-&gt;getRoutes();$action = $routes[0]-&gt;getAction();$this-&gt;assertEquals('Namespace\\Group\\', $action['namespace']);$this-&gt;assertEquals('Group::', $action['as']);$routes = $router-&gt;getRoutes()-&gt;getRoutes();$action = $routes[1]-&gt;getAction();$this-&gt;assertEquals(['groupMiddleware', 'routeMiddleware'], $action['middleware']);$this-&gt;assertEquals('Namespace\\Group\\Namespace\\Group\\', $action['namespace']);$this-&gt;assertEquals('Group::Route', $action['as']); group群组的属性分为两类：替换型、递增型。当群组属性与路由属性重复的时候，替换型属性会用路由的属性替换群组的属性，递增型的属性会综合路由和群组的属性。 在上面的例子可以看出： domain这个属性是替换型属性，路由的属性会覆盖和替换群组的这几个属性； prefix、middleware、namespace、as、where这几个属性是递增型属性，路由的属性和群组属性会相互结合。 另外值得注意的是： 路由的prefix属性具有优先级，因此上面第二个路由的uri是routepre/grouppre/additional/111/add，而不是grouppre/routepre/additional/111/add； where属性对于相同的路由参数会替换，不同的路由参数会结合，因此上面where中one被替换，two被结合进来 路由参数与匹配Laravel允许在注册定义路由的时候设定路由参数，以供控制器或者闭包所用。路由参数可以设定在URI中，也可以设定在domain中。 路由编码匹配对于已编码的请求URI，框架会自动进行解码然后进行匹配: 123456789101112131415$router = $this-&gt;getRouter();$router-&gt;get('foo/bar/åαф', function () &#123; return 'hello';&#125;);$this-&gt;assertEquals('hello', $router-&gt;dispatch(Request::create('foo/bar/%C3%A5%CE%B1%D1%84', 'GET'))-&gt;getContent());$router = $this-&gt;getRouter();$route = $router-&gt;get('foo/&#123;file&#125;', function ($file) &#123; return $file;&#125;);$this-&gt;assertEquals('oxygen%20', $router-&gt;dispatch(Request::create('http://test.com/foo/oxygen%2520', 'GET'))-&gt;getContent()); 路由参数路由参数总是通过花括号进行包裹，这些参数在路由被执行时会被传递到路由的闭包。路由参数不能包含-字符，需要的话可以使用_替代。 12345678910111213141516171819202122$router = $this-&gt;getRouter();$route = $router-&gt;get('foo/&#123;age&#125;', ['domain' =&gt; 'api.&#123;name&#125;.bar', function ($name, $age)&#123; return $name.$age;&#125;]);$this-&gt;assertEquals('taylor25', $router-&gt;dispatch(Request::create('http://api.taylor.bar/foo/25', 'GET'))-&gt;getContent());$route = new Route('GET', 'images/&#123;id&#125;.&#123;ext&#125;', function () &#123;&#125;);$request1 = Request::create('images/1.png', 'GET');$this-&gt;assertTrue($route-&gt;matches($request1));$route-&gt;bind($request1);$this-&gt;assertTrue($route-&gt;hasParameter('id'));$this-&gt;assertFalse($route-&gt;hasParameter('foo'));$this-&gt;assertEquals('1', $route-&gt;parameter('id'));$this-&gt;assertEquals('png', $route-&gt;parameter('ext')); 路由可选参数有时候可能需要指定可选的路由参数，这可以通过在参数名后加一个?标记来实现，这种情况下需要给相应的变量指定默认值：12345678910111213$router = $this-&gt;getRouter();$router-&gt;get('&#123;foo?&#125;/&#123;baz?&#125;', function ($name = 'taylor', $age = 25) &#123; return $name.$age;&#125;);$this-&gt;assertEquals('fred25', $router-&gt;dispatch(Request::create('fred', 'GET'))-&gt;getContent());$router-&gt;get('default/&#123;foo?&#125;/&#123;baz?&#125;', function ($name, $age = 25)&#123; return $name.$age;&#125;)-&gt;default('name', 'taylor');$this-&gt;assertEquals('fred25', $router-&gt;dispatch(Request::create('fred', 'GET'))-&gt;getContent()); 路由参数正则约束可以使用路由实例上的where方法来约束路由参数的格式。where方法接收参数名和一个正则表达式来定义该参数如何被约束： 123Route::get('user/&#123;name&#125;', function ($name) &#123; //&#125;)-&gt;where('name', '[A-Za-z]+'); 如果想要路由参数在全局范围内被给定正则表达式约束，可以使用pattern方法。在RouteServiceProvider类的boot方法中定义约束模式: 12345public function boot()&#123; Route::pattern('id', '[0-9]+'); parent::boot();&#125; 值得注意的是，路由参数是不允许出现/字符的，例如：1234567$router-&gt;get('&#123;one?&#125;', ['uses' =&gt; function ($one = null)&#123; return $one;&#125;]);$request2 = Request::create('foo/bar/baz', 'GET');$this-&gt;assertFalse($route-&gt;matches($request2)); 上例中one只能匹配foo，不能匹配foo/bar/baz，这时就需要对one进行正则约束： 123456789101112131415161718public function testLeadingParamDoesntReceiveForwardSlashOnEmptyPath()&#123; $router = $this-&gt;getRouter(); $router-&gt;get( '&#123;one?&#125;', [ 'uses' =&gt; function ($one = null)&#123; return $one; &#125;, 'where' =&gt; ['one' =&gt; '(.+)'], ] ); $this-&gt;assertEquals('foo', $router-&gt;dispatch(Request::create('/foo', 'GET'))-&gt;getContent()); $this-&gt;assertEquals('foo/bar/baz', $router-&gt;dispatch(Request::create('/foo/bar/baz', 'GET'))-&gt;getContent());&#125; 路由中间件HTTP中间件为过滤进入应用的HTTP请求提供了一套便利的机制。例如，Laravel内置了一个中间件来验证用户是否经过认证，如果用户没有经过认证，中间件会将用户重定向到登录页面，否则如果用户经过认证，中间件就会允许请求继续往前进入下一步操作。 Laravel框架自带了一些中间件，包括认证、CSRF保护中间件等等。所有的中间件都位于app/Http/Middleware目录。 中间件之前/之后/终止一个中间件是请求前还是请求后执行取决于中间件本身。比如，以下中间件会在请求处理前执行一些任务： 123456789101112131415161718class BeforeMiddleware&#123; public function handle($request, Closure $next) &#123; // 执行动作 return $next($request); &#125;&#125;class AfterMiddleware&#123; public function handle($request, Closure $next) &#123; $response = $next($request); // 执行动作 return $response; &#125;&#125; 有时候中间件可能需要在HTTP响应发送到浏览器之后做一些工作。比如，Laravel内置的“session”中间件会在响应发送到浏览器之后将Session数据写到存储器中，为了实现这个功能，需要定义一个终止中间件并添加terminate方法到这个中间件：123456789101112class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate($request, $response) &#123; // 存储session数据... &#125;&#125; 全局中间件如果你想要中间件在每一个HTTP请求期间被执行，只需要将相应的中间件类设置到app/Http/Kernel.php的数组属性$middleware中即可。 1234567protected $middleware = [ \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class, \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class, \App\Http\Middleware\TrimStrings::class, \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,]; 路由中间件如果你想要分配中间件到指定路由，可以传递完整的类名：12345use App\Http\Middleware\CheckAge;Route::get('admin/profile', function () &#123; //&#125;)-&gt;middleware(CheckAge::class); 或者可以给中间件提供一个别名：1234567891011121314public function testDefinedClosureMiddleware()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', ['middleware' =&gt; 'foo', function ()&#123; return 'hello'; &#125;]); $router-&gt;aliasMiddleware('foo', function ($request, $next) &#123; return 'caught'; &#125;); $this-&gt;assertEquals('caught', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent());&#125; 也可以在app/Http/Kernel.php文件中分配给该中间件一个key，默认情况下，该类的$routeMiddleware属性包含了Laravel自带的中间件，要添加你自己的中间件，只需要将其追加到后面并为其分配一个key，例如：12345678910111213protected $routeMiddleware = [ 'auth' =&gt; \Illuminate\Auth\Middleware\Authenticate::class, 'auth.basic' =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class, 'bindings' =&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class, 'can' =&gt; \Illuminate\Auth\Middleware\Authorize::class, 'guest' =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class, 'throttle' =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,];Route::get('admin/profile', function () &#123; //&#125;)-&gt;middleware('auth'); 使用数组分配多个中间件到路由： 123Route::get('/', function () &#123; //&#125;)-&gt;middleware('first', 'second'); 中间件组有时候你可能想要通过指定一个键名的方式将相关中间件分到同一个组里面，从而更方便将其分配到路由中，这可以通过使用HTTP Kernel的$middlewareGroups属性实现。 Laravel自带了开箱即用的web和api两个中间件组以分别包含可以应用到Web UI和API路由的通用中间件：12345678910111213141516171819protected $middlewareGroups = [ 'web' =&gt; [ \App\Http\Middleware\EncryptCookies::class, \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class, \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \App\Http\Middleware\VerifyCsrfToken::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, ], 'api' =&gt; [ 'throttle:60,1', 'auth:api', ],];Route::get('/', function () &#123;//&#125;)-&gt;middleware('web'); 值得注意的是，中间件组中可以循环嵌套中间件组：12345678910111213141516171819202122public function testMiddlewareGroupsCanReferenceOtherGroups()&#123; unset($_SERVER['__middleware.group']); $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', ['middleware' =&gt; 'web', function ()&#123; return 'hello'; &#125;]); $router-&gt;aliasMiddleware('two', 'Illuminate\Tests\Routing\RoutingTestMiddlewareGroupTwo'); $router-&gt;middlewareGroup('first', ['two:abigail']); $router-&gt;middlewareGroup('web', ['Illuminate\Tests\Routing\RoutingTestMiddlewareGroupOne', 'first']); $this-&gt;assertEquals('caught abigail', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent()); $this-&gt;assertTrue($_SERVER['__middleware.group']); unset($_SERVER['__middleware.group']);&#125; 中间件参数中间件还可以接收额外的自定义参数，例如，如果应用需要在执行给定动作之前验证认证用户是否拥有指定的角色，可以创建一个CheckRole来接收角色名作为额外参数。 额外的中间件参数会在$next参数之后传入中间件：1234567891011121314151617181920namespace App\Http\Middleware;use Closure;class CheckRole&#123; public function handle($request, Closure $next, $role) &#123; if (! $request-&gt;user()-&gt;hasRole($role)) &#123; // Redirect... &#125; return $next($request); &#125;&#125;Route::put('post/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;middleware('role:editor'); 中间件的顺序当router中有多个中间件的时候，中间件的执行顺序并不是严格按照中间件数组进行的，框架中存在一个数组$middlewarePriority，规定了这个数组中各个中间件的顺序：123456789protected $middlewarePriority = [ \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \Illuminate\Auth\Middleware\Authenticate::class, \Illuminate\Session\Middleware\AuthenticateSession::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, \Illuminate\Auth\Middleware\Authorize::class,]; 当我们使用了上面其中多个中间件的时候，框架会自动按照上面的数组进行排序：1234567891011121314151617181920212223242526public function testMiddlewarePrioritySorting()&#123; $middleware = [ Placeholder1::class, SubstituteBindings::class, Placeholder2::class, Authenticate::class, Placeholder3::class, ]; $router = $this-&gt;getRouter(); $router-&gt;middlewarePriority = [Authenticate::class, SubstituteBindings::class, Authorize::class]; $route = $router-&gt;get('foo', ['middleware' =&gt; $middleware, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $this-&gt;assertEquals([ Placeholder1::class, Authenticate::class, SubstituteBindings::class, Placeholder2::class, Placeholder3::class, ], $router-&gt;gatherRouteMiddleware($route));&#125; 控制器控制器类更普遍的方法是使用控制器来组织管理这些行为。控制器可以将相关的HTTP请求封装到一个类中进行处理。通常控制器存放在app/Http/Controllers目录中. 所有的Laravel控制器应该继承自Laravel自带的控制器基类Controller，控制器基类提供了一些很方便的方法如middleware，用于添加中间件到控制器动作： 1234567class UserController extends Controller&#123; public function show($id) &#123; return view('user.profile', ['user' =&gt; User::findOrFail($id)]); &#125;&#125; 1Route::get('user/&#123;id&#125;', 'UserController@show'); 单动作控制器如果想要定义一个只处理一个动作的控制器，可以在这个控制器中定义__invoke方法，当为这个单动作控制器注册路由的时候，不需要指定方法：12345678910111213141516171819202122public function testDispatchingCallableActionClasses()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', 'Illuminate\Tests\Routing\ActionStub'); $this-&gt;assertEquals('hello', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent()); $router-&gt;get('foo/bar2', [ 'uses' =&gt; 'Illuminate\Tests\Routing\ActionStub@func', ]); $this-&gt;assertEquals('hello2', $router-&gt;dispatch(Request::create('foo/bar2', 'GET'))-&gt;getContent());&#125;class ActionStub extends Controller&#123; public function __invoke() &#123; return 'hello'; &#125;&#125; 控制器中间件将中间件放在控制器构造函数中更方便，在控制器的构造函数中使用middleware方法你可以很轻松的分配中间件给该控制器。你甚至可以限定该中间件应用到该控制器类的指定方法：123456789class UserController extends Controller&#123; public function __construct() &#123; $this-&gt;middleware('auth'); $this-&gt;middleware('log')-&gt;only('index'); $this-&gt;middleware('subscribed')-&gt;except('store'); &#125;&#125; callAction方法值得注意的是每次执行控制器方法都会先执行控制器的callAction函数： 1234public function callAction($method, $parameters)&#123; return call_user_func_array([$this, $method], $parameters);&#125; 测试样例：12345678910111213141516171819unset($_SERVER['__test.controller_callAction_parameters']);$router-&gt;get(($str = str_random()).'/&#123;one&#125;/&#123;two&#125;', 'Illuminate\Tests\Routing\RouteTestAnotherControllerWithParameterStub@oneArgument');$router-&gt;dispatch(Request::create($str.'/one/two', 'GET'));$this-&gt;assertEquals(['one' =&gt; 'one', 'two' =&gt; 'two'], $_SERVER['__test.controller_callAction_parameters']);class RouteTestAnotherControllerWithParameterStub extends Controller&#123; public function callAction($method, $parameters) &#123; $_SERVER['__test.controller_callAction_parameters'] = $parameters; &#125; public function oneArgument($one) &#123; &#125;&#125; __call方法和普通类一样，若控制器中没有对应classname@method中的method，则会调用类的__call函数。1234567891011121314151617181920public function testCallableControllerRouting()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', 'Illuminate\Tests\Routing\RouteTestControllerCallableStub@bar'); $router-&gt;get('foo/baz', 'Illuminate\Tests\Routing\RouteTestControllerCallableStub@baz'); $this-&gt;assertEquals('bar', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent()); $this-&gt;assertEquals('baz', $router-&gt;dispatch(Request::create('foo/baz', 'GET'))-&gt;getContent());&#125;class RouteTestControllerCallableStub extends Controller&#123; public function __call($method, $arguments = []) &#123; return $method; &#125;&#125; 路由参数依赖注入与绑定Laravel使用服务容器解析所有的Laravel控制器，因此，可以在控制器的构造函数中类型声明任何依赖，这些依赖会被自动解析并注入到控制器实例中。路由的参数绑定可以分为两种：显示绑定与隐示绑定。 路由隐示绑定控制器方法期望输入路由参数，只需要将路由参数放到其他依赖之后12345678Route::put('user/&#123;id&#125;', 'UserController@update');class UserController extends Controller&#123; public function update(Request $request, $id) &#123; &#125;&#125; 可以在控制器的动作方法中进行依赖的类型提示，例如，我们可以在某个方法中类型提示Illuminate\Http\Request实例： 1234567class UserController extends Controller&#123; public function store(Request $request) &#123; $name = $request-&gt;input('name'); &#125;&#125; 可以为控制器的动作方法中添加数据库模型的主键，框架会自动利用主键来获取对应的记录，需要注意的是，route定义路由的路由参数必须和控制器内的变量名相同，例如下例中路由参数userid和控制器参数userid： 12345678910Route::put('user/&#123;userid&#125;', 'UserController@update');class UserController extends Controller&#123; public function update(UserModel $userid) &#123; $userid-&gt;name = 'taylor'; $userid-&gt;update(); &#125;&#125; 综合测试样例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public function testImplicitBindingsWithOptionalParameter()&#123; unset($_SERVER['__test.controller_callAction_parameters']); $router-&gt;get(($str = str_random()).'/&#123;user&#125;/&#123;defaultNull?&#125;/&#123;team?&#125;', [ 'middleware' =&gt; SubstituteBindings::class,'uses' =&gt; 'Illuminate\Tests\Routing\RouteTestAnotherControllerWithParameterStub@withModels', ]); $router-&gt;dispatch(Request::create($str.'/1', 'GET')); $values = array_values($_SERVER['__test.controller_callAction_parameters']); $this-&gt;assertInstanceOf('Illuminate\Http\Request', $values[0]); $this-&gt;assertEquals(1, $values[1]-&gt;value); $this-&gt;assertNull($values[2]); $this-&gt;assertInstanceOf('Illuminate\Tests\Routing\RoutingTestTeamModel', $values[3]);&#125;class RouteTestAnotherControllerWithParameterStub extends Controller&#123; public function callAction($method, $parameters) &#123; $_SERVER['__test.controller_callAction_parameters'] = $parameters; &#125; public function withModels(Request $request, RoutingTestUserModel $user, $defaultNull = null, RoutingTestTeamModel $team = null) &#123; &#125;&#125;class RoutingTestUserModel extends Model&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; $this-&gt;value = $value; return $this; &#125; public function first() &#123; return $this; &#125; public function firstOrFail() &#123; return $this; &#125;&#125;class RoutingTestTeamModel extends Model&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; $this-&gt;value = $value; return $this; &#125; public function first() &#123; return $this; &#125; public function firstOrFail() &#123; return $this; &#125;&#125; 路由显示绑定除了隐示地转化路由参数外，我们还可以给路由参数显示提供绑定。显示绑定有bind、model两种方法。 通过bind为参数绑定闭包函数： 1234567891011121314public function testRouteBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;bind('bar', function ($value) &#123; return strtoupper($value); &#125;); $this-&gt;assertEquals('TAYLOR', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125; 通过bind为参数绑定类方法，可以指定classname@method，也可以直接使用类名，默认会调用类的bind函数：1234567891011121314151617181920212223242526272829303132333435363738public function testRouteClassBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;bind('bar', 'Illuminate\Tests\Routing\RouteBindingStub'); $this-&gt;assertEquals('TAYLOR', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125;public function testRouteClassMethodBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;bind('bar', 'Illuminate\Tests\Routing\RouteBindingStub@find'); $this-&gt;assertEquals('dragon', $router-&gt;dispatch(Request::create('foo/Dragon', 'GET'))-&gt;getContent());&#125;class RouteBindingStub&#123; public function bind($value, $route) &#123; return strtoupper($value); &#125; public function find($value, $route) &#123; return strtolower($value); &#125;&#125; 通过model为参数绑定数据库模型，路由的参数就不需要和控制器方法中的变量名相同，Laravel会利用路由参数的值去调用where方法查找对应记录： 123if ($model = $instance-&gt;where($instance-&gt;getRouteKeyName(), $value)-&gt;first()) &#123; return $model;&#125; 测试样例如下：12345678910111213141516171819202122232425262728293031public function testModelBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function($name) &#123; return $name; &#125;]); $router-&gt;model('bar', 'Illuminate\Tests\Routing\RouteModelBindingStub'); $this-&gt;assertEquals('TAYLOR', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125;class RouteModelBindingStub&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; $this-&gt;value = $value; return $this; &#125; public function first() &#123; return strtoupper($this-&gt;value); &#125;&#125; 若绑定的model并没有找到对应路由参数的记录，可以在model中定义一个闭包函数，路由参数会调用闭包函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public function testModelBindingWithCustomNullReturn()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;model('bar', 'Illuminate\Tests\Routing\RouteModelBindingNullStub', function () &#123; return 'missing'; &#125;); $this-&gt;assertEquals('missing', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125;public function testModelBindingWithBindingClosure()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;model('bar', 'Illuminate\Tests\Routing\RouteModelBindingNullStub', function ($value) &#123; return (new RouteModelBindingClosureStub())-&gt;findAlternate($value); &#125;); $this-&gt;assertEquals('tayloralt', $router-&gt;dispatch(Request::create('foo/TAYLOR', 'GET'))-&gt;getContent());&#125;class RouteModelBindingNullStub&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; return $this; &#125; public function first() &#123; &#125;&#125;class RouteModelBindingClosureStub&#123; public function findAlternate($value) &#123; return strtolower($value).'alt'; &#125;&#125; router扩展方法router支持添加自定义的方法，只需要利用macro函数来注册对应的函数名和函数实现： 12345678910111213141516public function testMacro()&#123; $router = $this-&gt;getRouter(); $router-&gt;macro('webhook', function () use ($router) &#123; $router-&gt;match(['GET', 'POST'], 'webhook', function () &#123; return 'OK'; &#125;); &#125;); $router-&gt;webhook(); $this-&gt;assertEquals('OK', $router-&gt;dispatch(Request::create('webhook', 'GET'))-&gt;getContent()); $this-&gt;assertEquals('OK', $router-&gt;dispatch(Request::create('webhook', 'POST'))-&gt;getContent());&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Composer自动加载]]></title>
    <url>%2F2020%2F05%2F19%2FPHP-Composer%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在__autoload()函数中将所有的映射规则全部实现，可能会非常复杂。为什么？ __autoload()是全局函数只能定义一次，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。怎么解决？ PHP自动加载功能由来在PHP开发过程中，如果希望从外部引入一个Class，通常会使用include和require方法，去把定义这个Class的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，使用这种方式会带来一些隐含的问题：如果一个PHP文件需要使用很多其它类，那么就需要很多的require/include语句，这样有可能会造成遗漏或者包含进不必要的类文件。如果大量的文件都需要使用其它的类，那么要保证每个文件都包含正确的类文件肯定是一个噩梦，况且require_once的代价很大。 PHP5为这个问题提供了一个解决方案，这就是类的自动加载（autoload）机制。autoload机制可以使得PHP程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为Lazy Loading（延迟加载）。 总结起来，自动加载功能带来了几处优点： 1.使用类之前无需include/require。 2.使用类的时候才会include/require文件，实现了Lazy Loading，避免了include/require多余文件。 3.无需考虑引入类的实际磁盘地址，实现了逻辑和实体文件的分离。 PHP自动加载函数__autoload()通常PHP5在使用一个类时，如果发现这个类没有加载，就会自动运行__autoload()函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。下面是个简单的示例：123456&lt;?phpfunction __autoload($classname)&#123; require_once ($classname . ".class.php");&#125; 在我们这个简单的例子中，我们直接将类名加上扩展名.class.php构成了类文件名，然后使用require_once将其加载。 从这个例子中，我们可以看出__autoload至少要做三件事情： 1.根据类名确定类文件名； 2.确定类文件所在的磁盘路径（在我们的例子是最简单的情况，类与调用它们的PHP程序文件在同一个文件夹下）； 3.将类从磁盘文件中加载到系统中。 第三步最简单，只需要使用include/require即可。要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在__autoload()函数中，将类名与实际的磁盘文件对应起来，就可以实现Lazy Loading的效果。从这里我们也可以看出__autoload()函数的实现中最重要的是类名与实际的磁盘文件映射规则的实现。 __autoload()函数存在的问题如果在一个系统的实现中，需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的，其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须在__autoload()函数中将所有的映射规则全部实现，这样的话__autoload()函数有可能会非常复杂，甚至无法实现。最后可能会导致__autoload()函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。 那么问题出现在哪里呢？问题出现在__autoload()是全局函数只能定义一次，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个__autoload调用堆栈，不同的映射关系写到不同的__autoload函数中去，然后统一注册统一管理，这个就是PHP5引入的SPL Autoload。 SPL AutoloadSPL是Standard PHP Library（标准PHP库）的缩写。它是PHP5引入的一个扩展库，其主要功能包括autoload机制的实现及包括各种Iterator接口或类。SPL Autoload具体有几个函数： 1.spl_autoload_register：注册__autoload()函数 2.spl_autoload_unregister：注销已注册的函数 3.spl_autoload_functions：返回所有已注册的函数 4.spl_autoload_call：尝试所有已注册的函数来加载类 5.spl_autoload：__autoload()的默认实现 6.spl_autoload_extionsions：注册并返回spl_autoload函数使用的默认文件扩展名。 简单来说，spl_autoload就是SPL自己定义的__autoload()函数，功能很简单，就是去注册的目录（由set_include_path设置）找与$classname同名的.php/.inc文件。当然，你也可以指定特定类型的文件，方法是注册扩展名(spl_autoload_extionsions)。 而splautoload_register()就是我们上面所说的__autoload调用堆栈，我们可以向这个函数注册多个我们自己的__autoload()函数，当PHP找不到类名时，PHP就会调用这个堆栈，一个一个去调用自定义的__autoload()函数，实现自动加载功能。如果我们不向这个函数输入任何参数，那么就会注册spl_autoload()函数。 好啦，PHP自动加载的底层就是这些，注册机制已经非常灵活，但是还缺什么呢？我们上面说过，自动加载关键就是类名和文件的映射，这种映射关系不同框架有不同方法，非常灵活，但是过于灵活就会显得杂乱，PHP有专门对这种映射关系的规范，那就是PSR标准中PSR0与PSR4。 不过在谈PSR0与PSR4之前，我们还需要了解PHP的命名空间的问题，因为这两个标准其实针对的都不是类名与目录文件的映射，而是命名空间与文件的映射。 为什么会这样呢？在我的理解中，规范的面向对象PHP思想，命名空间在一定程度上算是类名的别名，那么为什么要推出命名空间，命名空间的优点是什么呢？ 二、Namespace命名空间什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，文件foo.txt可以同时在目录/home/greg和/home/other中存在，但在同一个目录中不能存在两个foo.txt文件。另外，在目录/home/greg外访问foo.txt文件时，我们必须将目录名以及目录分隔符放在文件名之前得到/home/greg/foo.txt。这个原理应用到程序设计领域就是命名空间的概念。 在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 1.用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 2.为很长的标识符名称（通常是为了缓解第一类问题而定义的）创建一个别名（或简短）的名称，提高源代码的可读性。 PHP命名空间提供了一种将相关的类、函数和常量组合到一起的途径。 简单来说就是PHP是不允许程序中存在两个名字一样一样的类或者函数或者变量名的，那么有人就很疑惑了，那就不起一样名字不就可以了？事实上很多大程序依赖很多第三方库，名字冲突什么的不要太常见，这个就是官网中的第一个问题。那么如何解决这个问题呢？在没有命名空间的时候，可怜的程序员只能给类名起 a_b_c_d_e_f 这样的，其中 a/b/c/d/e/f 一般有其特定意义，这样一般就不会发生冲突了，但是这样长的类名编写起来累，读起来更是难受。因此PHP5就推出了命名空间，类名是类名，命名空间是命名空间，程序写/看的时候直接用类名，运行起来机器看的是命名空间，这样就解决了问题。 另外，命名空间提供了一种将相关的类、函数和常量组合到一起的途径。这也是面向对象语言命名空间的很大用途，把特定用途所需要的类、变量、函数写到一个命名空间中，进行封装。 解决了类名的问题，我们终于可以回到PSR标准来了，那么PSR0与PSR4是怎么 规范 文件与命名空间的映射关系的呢？答案就是：对命名空间的命名（额，有点绕）、类文件目录的位置 和 两者映射关系 做出了限制，这个就是标准的核心了。 三、PSR标准PSR是Proposing a Standards Recommendation（提出标准建议）的缩写，截止到目前为止，总共有5套PSR规范，分别是： PSR-0 (Autoloading Standard) 自动加载标准PSR-1 (Basic Coding Standard)基础编码标准PSR-2 (Coding Style Guide) 编码风格向导PSR-3 (Logger Interface) 日志接口PSR-4 (Improved Autoloading) 自动加载的增强版，可以替换掉PSR-0了。 PSR0标准 PRS-0规范是他们出的第1套规范，主要是制定了一些自动加载标准（Autoloading Standard）PSR-0强制性要求几点： 1.一个完全合格的namespace和class必须符合这样的结构： 1&lt;VendorName&gt;[&lt;Namespace&gt;]*&lt;Class Name&gt; 2.每个namespace必须有一个顶层的namespace（”Vendor Name”提供者名字） 3.每个namespace可以有多个子namespace 4.当从文件系统中加载时，每个namespace的分隔符(/)要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符) 5.在类名中，每个下划线(_) 符号要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符)。在 namespace 中，下划线 _ 符号是没有（特殊）意义的。 6.当从文件系统中载入时，合格的 namespace 和 class 一定是以.php结尾的 7.verdor name , namespaces , class 名可以由大小写字母组合而成（大小写敏感的） 具体规则可能有些让人晕，我们从头讲一下。 我们先来看PSR0标准大致内容，第1、2、3、7条对命名空间的名字做出了限制，第4、5条对命名空间和文件目录的映射关系做出了限制，第6条是文件后缀名。 前面我们说过，PSR标准是如何规范命名空间和所在文件目录之间的映射关系？是通过限制命名空间的名字、所在文件目录的位置和两者映射关系。 那么我们可能就要问了，哪里限制了文件所在目录的位置了呢？其实答案就是： 限制命名空间名字 + 限制命名空间名字与文件目录映射 = 限制文件目录 好了，我们先想一想，对于一个具体程序来说，如果它想要支持PSR0标准,它需要做什么调整呢？ 首先，程序必须定义一个符合PSR0标准第4、5条的映射函数，然后把这个函数注册到spl_register()中； 其次，定义一个新的命名空间时，命名空间的名字和所在文件的目录位置必须符合第1、2、3、7条。 一般为了代码维护方便，我们会在一个文件只定义一个命名空间。 好了，我们有了符合PSR0的命名空间的名字，通过符合PSR0标准的映射关系就可以得到符合PSR0标准的文件目录地址，如果我们按照PSR0标准正确存放文件，就可以顺利require该文件了，我们就可以使用该命名空间啦，是不是很神奇呢？ 接下来，我们详细地来看看PSR0标准到底规范了什么呢？ 我们以Laravel中第三方库Symfony其中一个命名空间 /Symfony/Core/Request为例，讲一讲上面PSR0标准。 一个完全合格的namespace和class必须符合这样的结构： 1&lt;VendorName&gt;[&lt;Namespace&gt;]*&lt;Class Name&gt; 上面所展示的/Symfony就是Vendor Name，也就是第三方库的名字，/Core是Namespace名字，一般是我们命名空间的一些属性信息(例如request是Symfony的核心功能)；最后Request就是我们命名空间的名字，这个标准规范就是让人看到命名空间的来源、功能非常明朗，有利于代码的维护。 2 . 每个namespace必须有一个顶层的namespace（”Vendor Name”提供者名字） 也就是说每个命名空间都要有一个类似于/Symfony的顶级命名空间，为什么要有这种规则呢？因为PSR0标准只负责顶级命名空间之后的映射关系，也就是/Symfony/Core/Request这一部分，关于/Symfony应该关联到哪个目录，那就是用户或者框架自己定义的了。所谓的顶层的namespace，就是自定义了映射关系的命名空间，一般就是提供者名字（第三方库的名字）。换句话说顶级命名空间是自动加载的基础。为什么标准要这么设置呢？原因很简单，如果有个命名空间是/Symfony/Core/Transport/Request，还有个命名空间是/Symfony/Core/Transport/Request1,如果没有顶级命名空间，我们就得写两个路径和这两个命名空间相对应，如果再有Request2、Request3呢。有了顶层命名空间/Symfony，那我们就仅仅需要一个目录对应即可，剩下的就利用PSR标准去解析就行了。 3.每个namespace可以有多个子namespace 这个很简单，Request可以定义成/Symfony/Core/Request，也可以定义成/Symfony/Core/Transport/Request，/Core这个命名空间下面可以有很多子命名空间，放多少层命名空间都是自己定义。 4.当从文件系统中加载时，每个namespace的分隔符(/)要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符) 现在我们终于来到了映射规范了。命名空间的/符号要转为路径分隔符，也就是说要把/Symfony/Core/Request这个命名空间转为\Symfony\Core\Request这样的目录结构。 5.在类名中，每个下划线_符号要转换成DIRECTORYSEPARATOR(操作系统路径分隔符)。在namespace中，下划线\符号是没有（特殊）意义的。 这句话的意思就是说，如果我们的命名空间是/Symfony/Core/Request_a，那么我们就应该把它映射到\Symfony\Core\Request\a这样的目录。为什么会有这种规定呢？这是因为PHP5之前并没有命名空间，程序员只能把名字起成Symfony_Core_Request_a这样，PSR0的这条规定就是为了兼容这种情况。 剩下两个很简单就不说了。有这样的命名空间命名规则和映射标准，我们就可以推理出我们应该把命名空间所在的文件该放在哪里了。依旧以Symfony/Core/Request为例， 它的目录是/path/to/project/vendor/Symfony/Core/Request.php，其中/path/to/project是你项目在磁盘的位置，/path/to/project/vendor是项目用的所有第三方库所在目录。/path/to/project/vendor/Symfony就是与顶级命名空间/Symfony存在对应关系的目录，再往下的文件目录就是按照PSR0标准建立的：/Symfony/Core/Request =&gt; /Symfony/Core/Request.php一切很完满了是吗？不，还有一些瑕疵： 我们是否应该还兼容没有命名空间的情况呢？ 按照PSR0标准，命名空间/A/B/C/D/E/F必然对应一个目录结构/A/B/C/D/E/F，这种目录结构层次是不是太深了？ PSR4标准 2013年底，新出了第5个规范——PSR-4。 PSR-4规范了如何指定文件路径从而自动加载类定义，同时规范了自动加载文件的位置。这个乍一看和PSR-0重复了，实际上，在功能上确实有所重复。区别在于PSR-4的规范比较干净，去除了兼容PHP 5.3以前版本的内容，有一点PSR-0升级版的感觉。当然，PSR-4也不是要完全替代PSR-0，而是在必要的时候补充PSR-0——当然，如果你愿意，PSR-4也可以替代PSR-0。PSR-4可以和包括PSR-0在内的其他自动加载机制共同使用。 PSR4标准与PSR0标准的区别： 在类名中使用下划线没有任何特殊含义。 命名空间与文件目录的映射方法有所调整。 对第二项我们详细解释一下(Composer自动加载的原理)： 假如我们有一个命名空间：Foo/class，Foo是顶级命名空间，其存在着用户定义的与目录的映射关系：“Foo/“ =&gt; “src/“ 按照PSR0标准，映射后的文件目录是:src/Foo/class.php，但是按照PSR4标准，映射后的文件目录就会是:src/class.php，为什么要这么更改呢？原因就是怕命名空间太长导致目录层次太深，使得命名空间和文件目录的映射关系更加灵活。 再举一个例子,来源PSR-4——新鲜出炉的PHP规范： PSR-0风格 1234567891011-vendor/| -vendor_name/| | -package_name/| | | -src/| | | | -Vendor_Name/| | | | | -Package_Name/| | | | | | -ClassName.php # Vendor_Name\Package_Name\ClassName| | | -tests/| | | | -Vendor_Name/| | | | | -Package_Name/| | | | | | -ClassNameTest.php # Vendor_Name\Package_Name\ClassName PSR-4风格 1234567-vendor/| -vendor_name/| | -package_name/| | | -src/| | | | -ClassName.php # Vendor_Name\Package_Name\ClassName| | | -tests/| | | | -ClassNameTest.php # Vendor_Name\Package_Name\ClassNameTest 对比以上两种结构，明显可以看出PSR-4带来更简洁的文件结构。 前言上一篇文章中，我们讨论了PHP自动加载功能、PHP命名空间、PSR0/PSR4标准，有了这些知识，其实我们就可以按照PSR4标准写出可以自动加载的程序了。然而我们为什么要自己写呢？尤其是有Composer这神一样的包管理器的情况下？ Composer自动加载概论简单的说，Composer 帮助我们下载好了符合PSR0/PSR4标准的第三方库，并把文件放在相应位置；帮我们写了__autoload()函数，注册到了spl_register()函数，当我们想用第三方库的时候直接使用命名空间即可。 那么当我们想要写自己的命名空间的时候，该怎么办呢？很简单，我们只要按照PSR4标准命名我们的命名空间，放置我们的文件，然后在composer里面写好顶级域名与具体目录的映射，就可以享用composer的便利了。 当然如果有一个非常棒的框架，我们会惊喜地发现，在 composer 里面写顶级域名映射这事我们也不用做了，框架已经帮我们写好了顶级域名映射了，我们只需要在框架里面新建文件，在新建的文件中写好命名空间，就可以在任何地方 use 我们的命名空间了。 下面我们就以 Laravel 框架为例，讲一讲composer是如何实现PSR0/PSR4标准的自动加载功能。Composer自动加载文件 首先，我们先大致了解一下Composer自动加载所用到的源文件。 autoload_real.php: 自动加载功能的引导类。任务是composer加载类的初始化 (顶级命名空间与文件路径映射初始化) 和注册(spl_autoload_register())。 ClassLoader.php: composer加载类。composer自动加载功能的核心类。 autoload_static.php: 顶级命名空间初始化类，用于给核心类初始化顶级命名空间。 autoload_classmap.php: 自动加载的最简单形式，有完整的命名空间和文件目录的映射； autoload_files.php: 用于加载全局函数的文件，存放各个全局函数所在的文件路径名； autoload_namespaces.php: 符合PSR0标准的自动加载文件，存放着顶级命名空间与文件的映射； autoload_psr4.php: 符合PSR4标准的自动加载文件，存放着顶级命名空间与文件的映射； Laravel框架下Composer的自动加载源码分析启动Laravel框架的初始化是需要composer自动加载协助的，所以Laravel的入口文件index.php利用composer来实现自动加载功能。 12345&lt;?phpdefine('LARAVEL_START', microtime(true));require __DIR__.'/../vendor/autoload.php'; 再去vendor目录下的autoload.php：1234&lt;?phprequire_once __DIR__ . '/composer/autoload_real.php';return ComposerAutoloaderInit41730e5b8bc2247776726758bb07e21b::getLoader(); 好了，我们终于要看到了Composer真正要显威的地方了。autoload_real.php里面就是一个自动加载功能的引导类，这个类不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。 到autoload_real这个文件里面去看，发现这个引导类的名字叫ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e，为什么要叫这么古怪的名字呢？因为这是防止用户自定义类名跟这个类重复冲突了，所以在类名上加了一个hash值。其实还有一个做法我们更加熟悉，那就是不直接定义类名，而是定义一个命名空间。这里为什么不定义一个命名空间呢？个人理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用hash值更加合适。 Laravel框架下Composer的自动加载源码分析-autoload_real引导类在vendor目录下的autoload.php文件中我们可以看出，程序主要调用了引导类的静态方法getLoader()，我们接着看看这个函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static function getLoader()&#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register(array('ComposerAutoloaderInit41730e5b8bc2247776726758bb07e21b', 'loadClassLoader'), true, true); self::$loader = $loader = new \Composer\Autoload\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit41730e5b8bc2247776726758bb07e21b', 'loadClassLoader')); $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION') &amp;&amp; (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func(\Composer\Autoload\ComposerStaticInit41730e5b8bc2247776726758bb07e21b::getInitializer($loader)); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; $loader-&gt;register(true); if ($useStaticLoader) &#123; $includeFiles = Composer\Autoload\ComposerStaticInit41730e5b8bc2247776726758bb07e21b::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire41730e5b8bc2247776726758bb07e21b($fileIdentifier, $file); &#125; return $loader;&#125; 从上面可以看出，我把自动加载引导类分为5个部分。 第一部分—单例第一部分很简单，就是个最经典的单例模式，自动加载类只能有一个。12345&lt;?phpif (null !== self::$loader) &#123; return self::$loader;&#125; 第二部分——构造ClassLoader核心类 第二部分new一个自动加载的核心类对象。 123456789101112&lt;?php/***********************获得自动加载核心类对象********************/spl_autoload_register(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader'), true, true);self::$loader = $loader = new \Composer\Autoload\ClassLoader();spl_autoload_unregister(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader')); loadClassLoader()函数：1234567&lt;?phppublic static function loadClassLoader($class)&#123;if ('Composer\Autoload\ClassLoader' === $class) &#123;require __DIR__ . '/ClassLoader.php';&#125;&#125; 从程序里面我们可以看出，composer先向PHP自动加载机制注册了一个函数，这个函数require了 ClassLoader 文件。成功new出该文件中核心类ClassLoader()后，又销毁了该函数。 为什么不直接require，而要这么麻烦？原因就是怕有的用户也定义了个\Composer\Autoload\ClassLoader命名空间，导致自动加载错误文件。那为什么不跟引导类一样用个hash呢？因为这个类是可以复用的，框架允许用户使用这个类。 第三部分-初始化核心类对象12345678910111213141516171819202122232425&lt;?php/***********************初始化自动加载核心类对象********************/$useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION');if ($useStaticLoader) &#123;require_once __DIR__ . '/autoload_static.php';call_user_func(\Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::getInitializer($loader));&#125; else &#123;$map = require __DIR__ . '/autoload_namespaces.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;set($namespace, $path);&#125;$map = require __DIR__ . '/autoload_psr4.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;setPsr4($namespace, $path);&#125;$classMap = require __DIR__ . '/autoload_classmap.php';if ($classMap) &#123;$loader-&gt;addClassMap($classMap);&#125;&#125; 这一部分就是对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。初始化的方法有两种： 使用autoload_static进行静态初始化； 调用核心类接口初始化。 autoload_static静态初始化 静态初始化只支持 PHP5.6 以上版本并且不支持 HHVM 虚拟机。我们深入autoload_static.php 这个文件发现这个文件定义了一个用于静态初始化的类，名字叫ComposerStaticInit832ea71bfb9a4128da8660baedaac82e ，仍然为了避免冲突加了 hash 值。这个类很简单： 123456789101112131415161718192021222324&lt;?phpclass ComposerStaticInit832ea71bfb9a4128da8660baedaac82e&#123;public static $files = array(...);public static $prefixLengthsPsr4 = array(...);public static $prefixDirsPsr4 = array(...);public static $prefixesPsr0 = array(...);public static $classMap = array (...);public static function getInitializer(ClassLoader $loader)&#123;return \Closure::bind(function () use ($loader) &#123;$loader-&gt;prefixLengthsPsr4= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$prefixLengthsPsr4;$loader-&gt;prefixDirsPsr4= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$prefixDirsPsr4;$loader-&gt;prefixesPsr0= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$prefixesPsr0;$loader-&gt;classMap= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$classMap;&#125;, null, ClassLoader::class);&#125; 这个静态初始化类的核心就是 getInitializer() 函数，它将自己类中的顶级命名空间映射给了ClassLoader类。值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是ClassLoader类中的prefixLengthsPsr4、prefixDirsPsr4等等方法都是private的。。。普通的函数没办法给类的private成员变量赋值。利用匿名函数的绑定功能就可以将把匿名函数转为ClassLoader类 的成员函数。 关于匿名函数的绑定功能。 接下来就是顶级命名空间初始化的关键了。 最简单的 classMap:1234567891011121314151617&lt;?phppublic static $classMap = array ('App\\Console\\Kernel'=&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php','App\\Exceptions\\Handler'=&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php','App\\Http\\Controllers\\Auth\\ForgotPasswordController'=&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/ForgotPasswordController.php','App\\Http\\Controllers\\Auth\\LoginController'=&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/LoginController.php','App\\Http\\Controllers\\Auth\\RegisterController'=&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/RegisterController.php',...) 简单吧，直接命名空间全名与目录的映射，没有顶级命名空间。。。简单粗暴，也导致这个数组相当的大。 PSR0 顶级命名空间映射：12345678910111213141516171819202122232425262728293031&lt;?phppublic static $prefixesPsr0 = array ('P' =&gt; array ('Prophecy\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/phpspec/prophecy/src',),'Parsedown' =&gt; array (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',),),'M' =&gt; array ('Mockery' =&gt; array (0 =&gt; __DIR__ . '/..' . '/mockery/mockery/library',),),'J' =&gt; array ('JakubOnderka\\PhpConsoleHighlighter' =&gt; array (0 =&gt; __DIR__ . '/..' . '/jakub-onderka/php-console-highlighter/src',),'JakubOnderka\\PhpConsoleColor' =&gt; array (0 =&gt; __DIR__ . '/..' . '/jakub-onderka/php-console-color/src',),),'D' =&gt; array ('Doctrine\\Common\\Inflector\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/doctrine/inflector/lib',),),); 为了快速找到顶级命名空间，我们这里使用命名空间第一个字母作为前缀索引。这个映射的用法比较明显，假如我们有Parsedown/example这样的命名空间，首先通过首字母P，找到123456789&lt;?php'P' =&gt; array ('Prophecy\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/phpspec/prophecy/src',),'Parsedown' =&gt; array (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',),), 这个数组，然后我们就会遍历这个数组来和 Parsedown/example 比较，发现第一个 Prophecy 不符合，第二个 Parsedown 符合，然后得到了映射目录：(映射目录可能不止一个)12&lt;?phparray (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',) 我们会接着遍历这个数组，尝试 DIR . ‘/..’ .‘/erusev/parsedown/Parsedown/example.php’ 是否存在，如果不存在接着遍历数组(这个例子数组只有一个元素)，如果数组遍历完都没有，就会加载失败。 PSR4标准顶级命名空间映射数组：12345678910111213141516171819202122232425262728&lt;?phppublic static $prefixLengthsPsr4 = array('p' =&gt; array ('phpDocumentor\\Reflection\\' =&gt; 25,),'S' =&gt; array ('Symfony\\Polyfill\\Mbstring\\' =&gt; 26,'Symfony\\Component\\Yaml\\' =&gt; 23,'Symfony\\Component\\VarDumper\\' =&gt; 28,...),...);public static $prefixDirsPsr4 = array ('phpDocumentor\\Reflection\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src',1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src',2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src',),'Symfony\\Polyfill\\Mbstring\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring',),'Symfony\\Component\\Yaml\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/symfony/yaml',),...) PSR4标准顶级命名空间映射用了两个数组，第一个和 PSR0 一样用命名空间第一个字母作为前缀索引，然后是顶级命名空间，但是最终并不是文件路径，而是顶级命名空间的长度。为什么呢？因为前一篇文章我们说过，PSR4标准 的文件目录更加灵活，更加简洁。 PSR0 中顶级命名空间目录直接加到命名空间前面就可以得到路径 Parsedown/example =&gt; DIR . ‘/..’ . ‘/erusev/parsedown/Parsedown/example.php↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑而PSR4标准却是用顶级命名空间目录替换顶级命名空间，所以获得顶级命名空间的长度很重要。Parsedown/example =&gt; DIR . ‘/..’ . ‘/erusev/parsedown/example.php↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑具体的用法：假如我们找Symfony\\Polyfill\\Mbstring\\example这个命名空间，和PSR0一样通过前缀索引和字符串匹配我们得到了12&lt;?php'Symfony\\Polyfill\\Mbstring\\' =&gt; 26, 这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去$prefixDirsPsr4数组 获取它的映射目录数组：(注意映射目录可能不止一条) 12345&lt;?php'Symfony\\Polyfill\\Mbstring\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring',) 然后我们就可以将命名空间 Symfony\\Polyfill\\Mbstring\\example前26个字符替换成目录 DIR . ‘/..’ . ‘/symfony/polyfill-mbstring ，我们就得到了 DIR . ‘/..’ . ‘/symfony/polyfill-mbstring/example.php，先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。 自动加载核心类ClassLoader的静态初始化完成！！！ ClassLoader接口初始化 如果PHP版本低于5.6或者使用 HHVM 虚拟机环境，那么就要使用核心类的接口进行初始化。 123456789101112131415&lt;?php//PSR0标准$map = require __DIR__ . '/autoload_namespaces.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;set($namespace, $path);&#125;//PSR4标准$map = require __DIR__ . '/autoload_psr4.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;setPsr4($namespace, $path);&#125;$classMap = require __DIR__ . '/autoload_classmap.php';if ($classMap) &#123;$loader-&gt;addClassMap($classMap);&#125; PSR0标准autoload_namespaces：1234567891011121314151617&lt;?phpreturn array('Prophecy\\'=&gt; array($vendorDir . '/phpspec/prophecy/src'),'Parsedown'=&gt; array($vendorDir . '/erusev/parsedown'),'Mockery'=&gt; array($vendorDir . '/mockery/mockery/library'),'JakubOnderka\\PhpConsoleHighlighter'=&gt; array($vendorDir . '/jakub-onderka/php-console-highlighter/src'),'JakubOnderka\\PhpConsoleColor'=&gt; array($vendorDir . '/jakub-onderka/php-console-color/src'),'Doctrine\\Common\\Inflector\\'=&gt; array($vendorDir . '/doctrine/inflector/lib'),); PSR0标准的初始化接口：12345678910&lt;?phppublic function set($prefix, $paths)&#123;if (!$prefix) &#123;$this-&gt;fallbackDirsPsr0 = (array) $paths;&#125; else &#123;$this-&gt;prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;&#125;&#125; 很简单，PSR0标准取出命名空间的第一个字母作为索引，一个索引对应多个顶级命名空间，一个顶级命名空间对应多个目录路径，具体形式可以查看上面我们讲的autoload_static的$prefixesPsr0。如果没有顶级命名空间，就只存储一个路径名，以便在后面尝试加载。PSR4标准autoload_psr4 123456789101112131415&lt;?phpreturn array('XdgBaseDir\\'=&gt; array($vendorDir . '/dnoegel/php-xdg-base-dir/src'),'Webmozart\\Assert\\'=&gt; array($vendorDir . '/webmozart/assert/src'),'TijsVerkoyen\\CssToInlineStyles\\'=&gt; array($vendorDir . '/tijsverkoyen/css-to-inline-styles/src'),'Tests\\'=&gt; array($baseDir . '/tests'),'Symfony\\Polyfill\\Mbstring\\'=&gt; array($vendorDir . '/symfony/polyfill-mbstring'),...) PSR4标准的初始化接口:123456789101112131415161718&lt;?phppublic function setPsr4($prefix, $paths)&#123;if (!$prefix) &#123;$this-&gt;fallbackDirsPsr4 = (array) $paths;&#125; else &#123;$length = strlen($prefix);if ('\\' !== $prefix[$length - 1]) &#123;throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");&#125;$this-&gt;prefixLengthsPsr4[$prefix[0]][$prefix] = $length;$this-&gt;prefixDirsPsr4[$prefix] = (array) $paths;&#125;&#125; PSR4初始化接口也很简单。如果没有顶级命名空间，就直接保存目录。如果有命名空间的话，要保证顶级命名空间最后是 \ ，然后分别保存( 前缀 -&gt; 顶级命名空间，顶级命名空间 -&gt; 顶级命名空间长度 )( 顶级命名空间 -&gt; 目录 )这两个映射数组。具体形式可以查看上面我们讲的autoload_static的prefixLengthsPsr4、$prefixDirsPsr4 。傻瓜式命名空间映射autoload_classmap：12345678&lt;?phppublic static $classMap = array ('App\\Console\\Kernel'=&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php','App\\Exceptions\\Handler'=&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php',...) addClassMap:12345678910&lt;?phppublic function addClassMap(array $classMap)&#123;if ($this-&gt;classMap) &#123;$this-&gt;classMap = array_merge($this-&gt;classMap, $classMap);&#125; else &#123;$this-&gt;classMap = $classMap;&#125;&#125; 这个最简单，就是整个命名空间与目录之间的映射。 结语我们回顾一下，这篇文章主要讲了： 1.框架如何启动composer自动加载;2.composer自动加载分为5部分； 其实说是5部分，真正重要的就两部分——初始化与注册。初始化负责顶层命名空间的目录映射，注册负责实现顶层以下的命名空间映射规则。 前言上一篇文章我们讲到了Composer自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，换句话说，如果有命名空间’App\Console\Kernel，我们已经知道了App\对应的目录，接下来我们就要解决下面的就是\Console\Kernel这一段。 Composer自动加载源码分析——注册 我们先回顾一下自动加载引导类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static function getLoader()&#123;/***************************经典单例模式********************/if (null !== self::$loader) &#123;return self::$loader;&#125;/***********************获得自动加载核心类对象********************/spl_autoload_register(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader'), true,true);self::$loader = $loader = new \Composer\Autoload\ClassLoader();spl_autoload_unregister(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader'));/***********************初始化自动加载核心类对象********************/$useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp;!defined('HHVM_VERSION');if ($useStaticLoader) &#123;require_once __DIR__ . '/autoload_static.php';call_user_func(\Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::getInitializer($loader));&#125; else &#123;$map = require __DIR__ . '/autoload_namespaces.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;set($namespace, $path);&#125;$map = require __DIR__ . '/autoload_psr4.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;setPsr4($namespace, $path);&#125;$classMap = require __DIR__ . '/autoload_classmap.php';if ($classMap) &#123;$loader-&gt;addClassMap($classMap);&#125;&#125;/***********************注册自动加载核心类对象********************/$loader-&gt;register(true);/***********************自动加载全局函数********************/if ($useStaticLoader) &#123;$includeFiles = Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$files;&#125; else &#123;$includeFiles = require __DIR__ . '/autoload_files.php';&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file);&#125;return $loader;&#125; 现在我们开始引导类的第四部分：注册自动加载核心类对象。我们来看看核心类的register()函数：12345public function register($prepend = false)&#123;spl_autoload_register(array($this, 'loadClass'), true, $prepend);&#125; 简单到爆炸啊！一行代码实现自动加载有木有！其实奥秘都在自动加载核心类ClassLoader的loadClass()函数上，这个函数负责按照PSR标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将’App\Console\Kernel中’Console\Kernel这一段转为目录，至于怎么转的我们在下面“Composer自动加载源码分析——运行”讲。核心类ClassLoader将loadClass()函数注册到PHP SPL中的spl_autoload_register()里面去，这个函数的来龙去脉我们之前文章讲过。这样，每当PHP遇到一个不认识的命名空间的时候，PHP会自动调用注册到spl_autoload_register里面的函数堆栈，运行其中的每个函数，直到找到命名空间对应的文件。 Composer自动加载源码分析——全局函数的自动加载 Composer不止可以自动加载命名空间，还可以加载全局函数。怎么实现的呢？很简单，把全局函数写到特定的文件里面去，在程序运行前挨个require就行了。这个就是composer自动加载的第五步，加载全局函数。 12345678910if ($useStaticLoader) &#123;$includeFiles = Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$files;&#125; else &#123;$includeFiles = require __DIR__ . '/autoload_files.php';&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123;composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file);&#125; 跟核心类的初始化一样，全局函数自动加载也分为两种：静态初始化和普通初始化，静态加载只支持PHP5.6以上并且不支持HHVM。 静态初始化： ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$files：1234567public static $files = array ('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; __DIR__ . '/..' . '/symfony/var-dumper/Resources/functions/dump.php',...); 看到这里我们可能又要有疑问了，为什么不直接放文件路径名，还要一个hash干什么呢？这个我们一会儿讲，我们这里先了解一下这个数组的结构。 普通初始化 autoload_files: 123456789$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir);return array('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; $vendorDir . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; $vendorDir . '/symfony/var-dumper/Resources/functions/dump.php',....); 其实跟静态初始化区别不大。 加载全局函数 1234567891011121314151617181920class ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e&#123;public static function getLoader()&#123;...foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123;composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file);&#125;...&#125;&#125;function composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file)&#123;if (empty(\$GLOBALS['__composer_autoload_files'][\$fileIdentifier])) &#123;require $file;$GLOBALS['__composer_autoload_files'][$fileIdentifier] =true;&#125;&#125; 这一段很有讲究，第一个问题：为什么自动加载引导类的getLoader()函数不直接require $includeFiles里面的每个文件名，而要用类外面的函数composerRequire832ea71bfb9a4128da8660baedaac82e0？(顺便说下这个函数名hash仍然为了避免和用户定义函数冲突)为怕有人在全局函数所在的文件写$this或者self。 假如$includeFiles有个app/helper.php文件，这个helper.php文件的函数外有一行代码：$this-&gt;foo()，如果引导类在getLoader()函数直接require($file)，那么引导类就会运行这句代码，调用自己的foo()函数，这显然是错的。事实上helper.php就不应该出现$this或self这样的代码，这样写一般都是用户写错了的，一旦这样的事情发生，第一种情况：引导类恰好有foo()函数，那么就会莫名其妙执行了引导类的foo();第二种情况：引导类没有foo()函数，但是却甩出来引导类没有foo()方法这样的错误提示，用户不知道自己哪里错了。把require语句放到引导类的外面，遇到$this或者self，程序就会告诉用户根本没有类，$this或self无效， 错误信息更加明朗。 第二个问题，为什么要用hash作为$fileIdentifier，上面的代码明显可以看出来这个变量是用来控制全局函数只被require一次的，那为什么不用require_once呢？事实上require_once比require效率低很多，使用全局变量$GLOBALS这样控制加载会更快。还有一个原因我猜测应该是require_once对相对路径的支持并不理想，所以composer尽量少用require_once。 Composer自动加载源码分析——运行 我们终于来到了核心的核心——composer自动加载的真相，命名空间如何通过composer转为对应目录文件的奥秘就在这一章。 前面说过，ClassLoader的register()函数将loadClass()函数注册到PHP的SPL函数堆栈中，每当PHP遇到不认识的命名空间时就会调用函数堆栈的每个函数，直到加载命名空间成功。所以loadClass()函数就是自动加载的关键 了。 loadClass():12345678910111213141516171819202122232425262728293031323334public function loadClass($class)&#123;if ($file = $this-&gt;findFile($class)) &#123;includeFile($file);return true;&#125;&#125;public function findFile($class)&#123;// work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731if ('\\' == $class[0]) &#123;$class = substr($class, 1);&#125;// class map lookupif (isset($this-&gt;classMap[$class])) &#123;return $this-&gt;classMap[$class];&#125;if ($this-&gt;classMapAuthoritative) &#123;return false;PHP Composer-——-注册与运行源码分析41&#125;$file = $this-&gt;findFileWithExtension($class, '.php');// Search for Hack files if we are running on HHVMif ($file === null &amp;&amp; defined('HHVM_VERSION')) &#123;$file = $this-&gt;findFileWithExtension($class, '.hh');&#125;if ($file === null) &#123;// Remember that this class does not exist.return $this-&gt;classMap[$class] = false;&#125;return $file;&#125; 我们看到loadClass()，主要调用findFile()函数。findFile()在解析命名空间的时候主要分为两部分：classMap和findFileWithExtension()函数。classMap很简单，直接看命名空间是否在映射数组中即可。麻烦的是findFileWithExtension()函数，这个函数包含了PSR0和PSR4标准的实现。还有个值得我们注意的是查找路径成功后includeFile()仍然类外面的函数，并不是ClassLoader的成员函数，原理跟上面一样，防止有用户写$this或self。还有就是如果命名空间是以\开头的，要去掉\然后再匹配。 findFileWithExtension： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private function findFileWithExtension($class, $ext)&#123;// PSR-4 lookup$logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR). $ext;$first = $class[0];if (isset($this-&gt;prefixLengthsPsr4[$first])) &#123;foreach ($this-&gt;prefixLengthsPsr4[$first] as $prefix =&gt;$length) &#123;if (0 === strpos($class, $prefix)) &#123;foreach ($this-&gt;prefixDirsPsr4[$prefix] as $dir)&#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) &#123;return $file;&#125;&#125;&#125;&#125;&#125;// PSR-4 fallback dirsforeach ($this-&gt;fallbackDirsPsr4 as $dir) &#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) &#123;return $file;&#125;&#125;// PSR-0 lookupif (false !== $pos = strrpos($class, '\\')) &#123;// namespaced class name$logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1). strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);&#125; else &#123;// PEAR-like class name$logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;&#125;if (isset($this-&gt;prefixesPsr0[$first])) &#123;foreach ($this-&gt;prefixesPsr0[$first] as $prefix =&gt; $dirs) &#123;if (0 === strpos($class, $prefix)) &#123;foreach ($dirs as $dir) &#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123;return $file;&#125;&#125;&#125;&#125;&#125;// PSR-0 fallback dirsforeach ($this-&gt;fallbackDirsPsr0 as $dir) &#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123;return $file;&#125;&#125;// PSR-0 include paths.if ($this-&gt;useIncludePath &amp;&amp; $file = stream_resolve_include_path($logicalPathPsr0)) &#123;return $file;&#125;&#125; 下面我们通过举例来说下上面代码的流程： 如果我们在代码中写下’phpDocumentor\Reflection\example’，PHP会通过SPL调用loadClass-&gt;findFile-&gt;findFileWithExtension。首先默认用php作为文件后缀名调用findFileWithExtension函数里，利用PSR4标准尝试解析目录文件，如果文件不存在则继续用PSR0标准解析，如果解析出来的目录文件仍然不存在，但是环境是HHVM虚拟机，继续用后缀名为hh再次调用findFileWithExtension函数，如果不存在，说明此命名空间无法加载，放到classMap中设为false，以便以后更快地加载。 对于phpDocumentor\Reflection\example，当尝试利用PSR4标准映射目录时，步骤如下： PSR4标准加载将\转为文件分隔符/，加上后缀php或hh，得到$logicalPathPsr4即phpDocumentor//Reflection//example.php(hh);利用命名空间第一个字母p作为前缀索引搜索prefixLengthsPsr4数组，查到下面这个数组： 12345p' =&gt;array ('phpDocumentor\\Reflection\\' =&gt; 25,'phpDocumentor\\Fake\\' =&gt; 19,) 遍历这个数组，得到两个顶层命名空间phpDocumentor\Reflection\和phpDocumentor\Fake\用这两个顶层命名空间与phpDocumentor\Reflection\example_e相比较，可以得到phpDocumentor\Reflection\这个顶层命名空间在prefixLengthsPsr4映射数组中得到phpDocumentor\Reflection\长度为25。 在prefixDirsPsr4映射数组中得到phpDocumentor\Reflection\的目录映射为：123456789'phpDocumentor\\Reflection\\' =&gt;array (0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src',1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src',2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src',), 遍历这个映射数组，得到三个目录映射；查看“目录+文件分隔符//+substr($logicalPathPsr4, $length)”文件是否存在，存在即返回。这里就是’_DIR_/../phpdocumentor/reflection-common/src + /+substr(phpDocumentor/Reflection/example_e.php(hh),25)’如果失败，则利用fallbackDirsPsr4数组里面的目录继续判断是否存在文件，具体方法是“目录+文件分隔符//+$logicalPathPsr4” PSR0标准加载 如果PSR4标准加载失败，则要进行PSR0标准加载： 找到phpDocumentor\Reflection\examplee最后“\”的位置，将其后面文件名中’‘’‘字符转为文件分隔符“/”,得到$logicalPathPsr0即phpDocumentor/Reflection/example/e.php(hh) 利用命名空间第一个字母p作为前缀索引搜索prefixLengthsPsr4数组，查到下面这个数组：1234567891011'P' =&gt;array ('Prophecy\\' =&gt;array (0 =&gt; __DIR__ . '/..' . '/phpspec/prophecy/src',),'phpDocumentor' =&gt;array (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',),), 遍历这个数组，得到两个顶层命名空间phpDocumentor和Prophecy用这两个顶层命名空间与phpDocumentor\Reflection\example_e相比较，可以得到phpDocumentor这个顶层命名空间在映射数组中得到phpDocumentor目录映射为’_DIR_ . ‘/..’ .’/erusev/parsedown’查看“目录+文件分隔符//+$logicalPathPsr0”文件是否存在，存在即返回。这里就是 “_DIR_ . ‘/..’ . ‘/erusev/parsedown + //+phpDocumentor//Reflection//example/e.php(hh)”如果失败，则利用fallbackDirsPsr0数组里面的目录继续判断是否存在文件，具体方法是“目录+文件分隔符//+$logicalPathPsr0”如果仍然找不到，则利用stream_resolve_include_path()，在当前include目录寻找该文件，如果找到返回绝对路径。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Facade-Facade门面源码分析]]></title>
    <url>%2F2020%2F05%2F18%2FLaravel-Facade-Facade%E9%97%A8%E9%9D%A2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： __callStatic是什么意思？和Route::get()有什么关系？ 前言什么是门面呢？ Facades为应用程序的服务容器中可用的类提供了一个「静态」接口。Laravel自带了很多Facades，几乎可以用来访问到Laravel中所有的服务。Laravel Facades实际上是服务容器中那些底层类的「静态代理」，相比于传统的静态方法，Facades在提供了简洁且丰富的语法同时，还带来了更好的可测试性和扩展性。 首先，我们要知道Laravel框架的核心就是个IoC容器即服务容器，功能类似于一个工厂模式，是个高级版的工厂。Laravel的其他功能例如路由、缓存、日志、数据库其实都是类似于插件或者零件一样，叫做服务。IoC容器主要的作用就是生产各种零件，就是提供各个服务。在Laravel中，如果我们想要用某个服务，该怎么办呢？最简单的办法就是调用服务容器的make函数，或者利用依赖注入，或者就是今天要讲的门面Facade。门面相对于其他方法来说，最大的特点就是简洁，例如我们经常使用的Router，如果利用服务容器的make：123App::make('router')-&gt;get('/', function () &#123; return view('welcome');&#125;); 如果利用门面：123Route::get('/', function () &#123; return view('welcome');&#125;); 可以看出代码更加简洁。其实，下面我们就会介绍门面最后调用的函数也是服务容器的make函数。 Facade的原理我们以Route为例，来讲解一下门面Facade的原理与实现。我们先来看Route的门面类： Illuminate\Support\Facades\Route.php 123456789101112class Route extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'router'; &#125;&#125; 每个门面类也就是重定义一下getFacadeAccessor函数就行了，这个函数返回服务的唯一名称：router。需要注意的是要确保这个名称可以用服务容器的make函数创建成功（App::make(‘router’)），原因我们马上就会讲到。 那么当我们写出Route::get()这样的语句时，到底发生了什么呢？奥秘就在基类Facade中。 Illuminate\Support\Facades\Facade.php 1234567891011121314151617181920212223abstract class Facade&#123; /** * Handle dynamic, static calls to the object. * * @param string $method * @param array $args * @return mixed * * @throws \RuntimeException */ public static function __callStatic($method, $args) &#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException('A facade root has not been set.'); &#125; return $instance-&gt;$method(...$args); &#125;&#125; 当运行Route::get()时，发现门面Route没有静态get()函数，PHP就会调用这个魔术函数__callStatic。我们看到这个魔术函数做了两件事：获得对象实例，利用对象调用get()函数。首先看看如何获得对象实例的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * The application instance being facaded. * * @var \Illuminate\Contracts\Foundation\Application */protected static $app;/** * The resolved object instances. * * @var array */protected static $resolvedInstance;/** * Get the root object behind the facade. * * @return mixed */public static function getFacadeRoot()&#123; return static::resolveFacadeInstance(static::getFacadeAccessor());&#125;/** * Get the registered name of the component. * * @return string * * @throws \RuntimeException */protected static function getFacadeAccessor()&#123; throw new RuntimeException('Facade does not implement getFacadeAccessor method.');&#125;/** * Resolve the facade root instance from the container. * * @param object|string $name * @return mixed */protected static function resolveFacadeInstance($name)&#123; if (is_object($name)) &#123; return $name; &#125; if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; if (static::$app) &#123; return static::$resolvedInstance[$name] = static::$app[$name]; &#125;&#125; 我们看到基类getFacadeRoot()调用了getFacadeAccessor()，也就是我们的服务重载的函数，如果调用了基类的getFacadeAccessor，就会抛出异常。在我们的例子里getFacadeAccessor()返回了“router”，接下来getFacadeRoot()又调用了resolveFacadeInstance()。在这个函数里重点就是：1return static::$resolvedInstance[$name] = static::$app[$name]; 我们看到，在这里利用了$app也就是服务容器创建了“router”，创建成功后放入$resolvedInstance作为缓存，以便以后快速加载。 别名Aliases为什么我们可以在Laravel中全局用Route，而不需要使用use Illuminate\Support\Facades\Route？其实奥秘在于一个PHP函数：class_alias，它可以为任何类创建别名。Laravel在启动的时候为各个门面类调用了class_alias函数，因此不必直接用类名，直接用别名即可。在config文件夹的app文件里面存放着门面与类名的映射：123456'aliases' =&gt; [ 'App' =&gt; Illuminate\Support\Facades\App::class, 'Artisan' =&gt; Illuminate\Support\Facades\Artisan::class, 'Auth' =&gt; Illuminate\Support\Facades\Auth::class, ...] 下面我们来看看Laravel是如何为门面类创建别名的。 启动别名Aliases服务说到Laravel的启动，我们离不开index.php： 123456789require __DIR__.'/../vendor/autoload.php';$app = require_once __DIR__.'/../bootstrap/app.php';$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture()); 第一句就是我们前面博客说的composer的自动加载，接下来第二句获取Laravel核心的IoC容器，第三句“制造”出Http请求的内核，第四句是我们这里的关键，这句牵扯很大，Laravel里面所有功能服务的注册加载，乃至Http请求的构造与传递都是这一句的功劳。1$request = Illuminate\Http\Request::capture() 这句是Laravel通过全局$_SERVER数组构造一个Http请求的语句，接下来会调用Http的内核函数handle： Illuminate\Foundation\Http\Kernel.php 123456789101112131415161718192021222324252627class Kernel implements KernelContract&#123; /** * Handle an incoming HTTP request. * * @param \Illuminate\Http\Request $request * @return \Illuminate\Http\Response */ public function handle($request) &#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app['events']-&gt;dispatch( new RequestHandled($request, $response) ); return $response; &#125;&#125; 在handle函数方法中enableHttpMethodParameterOverride函数是允许在表单中使用delete、put等类型的请求。我们接着看sendRequestThroughRouter： 12345678910111213141516171819/** * Send the given request through the middleware / router. * * @param \Illuminate\Http\Request $request * @return \Illuminate\Http\Response */protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 前两句是在Laravel的IoC容器设置request请求的对象实例，Facade中清除request的缓存实例。bootstrap： 12345678910111213141516171819202122232425/** * The bootstrap classes for the application. * * @var array */protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class,];/** * Bootstrap the application for HTTP requests. * * @return void */public function bootstrap()&#123; if (! $this-&gt;app-&gt;hasBeenBootstrapped()) &#123; $this-&gt;app-&gt;bootstrapWith($this-&gt;bootstrappers()); &#125;&#125; $bootstrappers是Http内核里专门用于启动的组件，bootstrap函数中调用IoC容器的bootstrapWith函数来创建这些组件并利用组件进行启动服务。app-&gt;bootstrapWith： 12345678910111213141516171819/** * Run the given array of bootstrap classes. * * @param string[] $bootstrappers * @return void */public function bootstrapWith(array $bootstrappers)&#123; $this-&gt;hasBeenBootstrapped = true; foreach ($bootstrappers as $bootstrapper) &#123; $this['events']-&gt;dispatch('bootstrapping: '.$bootstrapper, [$this]); $this-&gt;make($bootstrapper)-&gt;bootstrap($this); $this['events']-&gt;dispatch('bootstrapped: '.$bootstrapper, [$this]); &#125;&#125; 可以看到bootstrapWith函数也就是利用IoC容器创建各个启动服务的实例后，回调启动自己的函数bootstrap，在这里我们只看我们Facade的启动组件： Illuminate\Foundation\Bootstrap\RegisterFacades.php 1234567891011121314151617181920212223242526272829&lt;?phpnamespace Illuminate\Foundation\Bootstrap;use Illuminate\Contracts\Foundation\Application;use Illuminate\Foundation\AliasLoader;use Illuminate\Foundation\PackageManifest;use Illuminate\Support\Facades\Facade;class RegisterFacades&#123; /** * Bootstrap the given application. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function bootstrap(Application $app) &#123; Facade::clearResolvedInstances(); Facade::setFacadeApplication($app); AliasLoader::getInstance(array_merge( $app-&gt;make('config')-&gt;get('app.aliases', []), $app-&gt;make(PackageManifest::class)-&gt;aliases() ))-&gt;register(); &#125;&#125; 可以看出来，bootstrap做了一下几件事： 1.清除了Facade中的缓存 2.设置Facade的IoC容器 3.获得我们前面讲的config文件夹里面app文件aliases别名映射数组 4.使用aliases实例化初始化AliasLoader 5.调用AliasLoader-&gt;register() Illuminate\Foundation\AliasLoader.php 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace Illuminate\Foundation;class AliasLoader&#123; /** * Register the loader on the auto-loader stack. * * @return void */ public function register() &#123; if (! $this-&gt;registered) &#123; $this-&gt;prependToLoaderStack(); $this-&gt;registered = true; &#125; &#125; /** * Prepend the load method to the auto-loader stack. * * @return void */ protected function prependToLoaderStack() &#123; spl_autoload_register([$this, 'load'], true, true); &#125;&#125; 我们可以看出，别名服务的启动关键就是这个spl_autoload_register，这个函数我们应该很熟悉了，在自动加载中这个函数用于解析命名空间，在这里用于解析别名的真正类名。 别名Aliases服务我们首先来看看被注册到spl_autoload_register的函数，load： 123456789101112131415161718/** * Load a class alias if it is registered. * * @param string $alias * @return bool|null */public function load($alias)&#123; if (static::$facadeNamespace &amp;&amp; strpos($alias, static::$facadeNamespace) === 0) &#123; $this-&gt;loadFacade($alias); return true; &#125; if (isset($this-&gt;aliases[$alias])) &#123; return class_alias($this-&gt;aliases[$alias], $alias); &#125;&#125; 这个函数的下面很好理解，就是class_alias利用别名映射数组将别名映射到真正的门面类中去，但是上面这个是什么呢?实际上，这个是Laravel5.4版本新出的功能叫做实时门面服务。 实时门面服务其实门面功能已经很简单了，我们只需要定义一个类继承Facade即可，但是Laravel5.4打算更近一步——自动生成门面子类，这就是实时门面。 实时门面怎么用？看下面的例子： 1234567891011namespace App\Services;class PaymentGateway&#123; protected $tax; public function __construct(TaxCalculator $tax) &#123; $this-&gt;tax = $tax; &#125;&#125; 这是一个自定义的类，如果我们想要为这个类定义一个门面，在Laravel5.4我们可以这么做：1234567use Facades\ &#123; App\Services\PaymentGateway&#125;;Route::get('/pay/&#123;amount&#125;', function ($amount) &#123; PaymentGateway::pay($amount);&#125;); 当然如果你愿意，你还可以在alias数组为门面添加一个别名映射”PaymentGateway” =&gt; “use Facades\App\Services\PaymentGateway”，这样就不用写这么长的名字了。 那么这么做的原理是什么呢？我们接着看源码： 1234567protected static $facadeNamespace = 'Facades\\';if (static::$facadeNamespace &amp;&amp; strpos($alias, static::$facadeNamespace) === 0)&#123; $this-&gt;loadFacade($alias); return true;&#125; 如果命名空间是以Facades\开头的，那么就会调用实时门面的功能，调用loadFacade函数：123456protected function loadFacade($alias)&#123; tap($this-&gt;ensureFacadeExists($alias), function ($path) &#123; require $path; &#125;);&#125; tap是Laravel的全局帮助函数，ensureFacadeExists函数负责自动生成门面类，loadFacade负责加载门面类： 1234567891011121314protected function ensureFacadeExists($alias)&#123; if (file_exists($path = storage_path('framework/cache/facade-'.sha1($alias).'.php'))) &#123; return $path; &#125; file_put_contents( $path, $this-&gt;formatFacadeStub($alias, file_get_contents(__DIR__.'/stubs/facade.stub') )); return $path;&#125; 可以看出来，Laravel框架生成的门面类会放到stroge/framework/cache/文件夹下，名字以facade开头，以命名空间的哈希结尾。如果存在这个文件就会返回，否则就要利用file_put_contents生成这个文件，formatFacadeStub：1234567891011121314protected function formatFacadeStub($alias, $stub)&#123; $replacements = [ str_replace('/', '\\', dirname(str_replace('\\', '/', $alias))), class_basename($alias), substr($alias, strlen(static::$facadeNamespace)), ]; return str_replace( ['DummyNamespace', 'DummyClass', 'DummyTarget'], $replacements, $stub );&#125; 简单的说，对于Facades\App\Services\PaymentGateway，$replacements第一项是门面命名空间，将Facades\App\Services\PaymentGateway转为Facades/App/Services/PaymentGateway，取前面Facades/App/Services/，再转为命名空间Facades\App\Services\；第二项是门面类名，PaymentGateway；第三项是门面类的服务对象，App\Services\PaymentGateway，用这些来替换门面的模板文件：12345678910111213141516171819&lt;?phpnamespace DummyNamespace;use Illuminate\Support\Facades\Facade;/*** @see \DummyTarget*/class DummyClass extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'DummyTarget'; &#125;&#125; 替换后的文件是： 12345678910111213141516171819&lt;?phpnamespace Facades\App\Services\;use Illuminate\Support\Facades\Facade;/*** @see \DummyTarget*/class PaymentGateway extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'App\Services\PaymentGateway'; &#125;&#125; 就是这么简单！！！ 结语门面的原理就是这些，相对来说门面服务的原理比较简单，和自动加载相互配合使得代码更加简洁，希望大家可以更好的使用这些门面！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel ENV/Config-环境变量/配置文件的加载与源码解析]]></title>
    <url>%2F2020%2F05%2F18%2FLaravel-ENV-Config-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： ENVENV文件的使用多环境ENV文件的设置一、在项目写多个ENV文件，例如三个env文件： .env.development .env.staging .env.production 这三个文件中分别针对不同环境为某些变量配置了不同的值。 二、配置APP_ENV环境变量值 配置环境变量的方法有很多，其中一个方法是在nginx的配置文件中写下这句代码：1fastcgi_param APP_ENV production; 那么Laravel会通过env(‘APP_ENV’)根据环境变量APP_ENV来判断当前具体的环境，假如环境变量APP_ENV为production，那么Laravel将会自动加载.env.production文件。 自定义ENV文件的路径与文件名Laravel为用户提供了自定义ENV文件路径或文件名的函数，例如，若想要自定义env路径，就可以在bootstrap文件夹中修改app.php文件：12345$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../'));$app-&gt;useEnvironmentPath('/customer/path') 若想要自定义env文件名称，就可以在bootstrap文件夹中修改app.php文件：12345$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../'));$app-&gt;loadEnvironmentFrom('customer.env') ENV加载源码分析Laravel加载ENVENV的加载功能由类\Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class完成，它的启动函数为：123456789101112131415161718public function bootstrap(Application $app)&#123; if ($app-&gt;configurationIsCached()) &#123; return; &#125; $this-&gt;checkForSpecificEnvironmentFile($app); try &#123; $this-&gt;createDotenv($app)-&gt;safeLoad(); &#125; catch (InvalidFileException $e) &#123; $this-&gt;writeErrorAndDie($e); &#125;&#125; 如果我们在环境变量中设置了APP_ENV变量，那么就会调用函数checkForSpecificEnvironmentFile来根据环境加载不同的env文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Detect if a custom environment file matching the APP_ENV exists. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */protected function checkForSpecificEnvironmentFile($app)&#123; if ($app-&gt;runningInConsole() &amp;&amp; ($input = new ArgvInput)-&gt;hasParameterOption('--env')) &#123; if ($this-&gt;setEnvironmentFilePath( $app, $app-&gt;environmentFile().'.'.$input-&gt;getParameterOption('--env') )) &#123; return; &#125; &#125; $environment = Env::get('APP_ENV'); if (! $environment) &#123; return; &#125; $this-&gt;setEnvironmentFilePath( $app, $app-&gt;environmentFile().'.'.$environment );&#125;/** * Load a custom environment file. * * @param \Illuminate\Contracts\Foundation\Application $app * @param string $file * @return bool */protected function setEnvironmentFilePath($app, $file)&#123; if (file_exists($app-&gt;environmentPath().'/'.$file)) &#123; $app-&gt;loadEnvironmentFrom($file); return true; &#125; return false;&#125; vlucas/phpdotenv源码解读 Laravel中对env文件的读取是采用vlucas/phpdotenv的开源项目：1234567891011121314151617181920class Dotenv&#123; public function __construct($path, $file = '.env') &#123; $this-&gt;filePath = $this-&gt;getFilePath($path, $file); $this-&gt;loader = new Loader($this-&gt;filePath, true); &#125; public function load() &#123; return $this-&gt;loadData(); &#125; protected function loadData($overload = false) &#123; $this-&gt;loader = new Loader($this-&gt;filePath, !$overload); return $this-&gt;loader-&gt;load(); &#125;&#125; env 文件变量的读取依赖类/Dotenv/Loader：1234567891011121314151617181920class Loader&#123; public function load() &#123; $this-&gt;ensureFileIsReadable(); $filePath = $this-&gt;filePath; $lines = $this-&gt;readLinesFromFile($filePath); foreach ($lines as $line) &#123; if (!$this-&gt;isComment($line) &amp;&amp; $this-&gt;looksLikeSetter($line)) &#123; $this-&gt;setEnvironmentVariable($line); &#125; &#125; return $lines; &#125;&#125; 我们可以看到，env文件的读取的流程： 判断env文件是否可读 读取整个env文件，并将文件按行存储 循环读取每一行，略过注释 进行环境变量赋值 12345678910111213141516171819202122232425262728293031protected function ensureFileIsReadable()&#123; if (!is_readable($this-&gt;filePath) || !is_file($this-&gt;filePath)) &#123; throw new InvalidPathException(sprintf('Unable to read the environment file at %s.', $this-&gt;filePath)); &#125;&#125;protected function readLinesFromFile($filePath)&#123; // Read file into an array of lines with auto-detected lineendings $autodetect = ini_get('auto_detect_line_endings'); ini_set('auto_detect_line_endings', '1'); $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); ini_set('auto_detect_line_endings', $autodetect); return $lines;&#125;protected function isComment($line)&#123; return strpos(ltrim($line), '#') === 0;&#125;protected function looksLikeSetter($line)&#123; return strpos($line, '=') !== false;&#125; 环境变量赋值是env文件加载的核心，主要由setEnvironmentVariable函数：12345678910111213141516171819202122public function setEnvironmentVariable($name, $value = null)&#123; list($name, $value) = $this-&gt;normaliseEnvironmentVariable($name, $value); if ($this-&gt;immutable &amp;&amp; $this-&gt;getEnvironmentVariable($name) !== null) &#123; return; &#125; if (function_exists('apache_getenv') &amp;&amp; function_exists('apache_setenv') &amp;&amp; apache_getenv($name)) &#123; apache_setenv($name, $value); &#125; if (function_exists('putenv')) &#123; putenv("$name=$value"); &#125; $_ENV[$name] = $value; $_SERVER[$name] = $value;&#125; normaliseEnvironmentVariable函数用来加载各种类型的环境变量：123456789101112protected function normaliseEnvironmentVariable($name, $value)&#123; list($name, $value) = $this-&gt;splitCompoundStringIntoParts($name, $value); list($name, $value) = $this-&gt;sanitiseVariableName($name, $value); list($name, $value) = $this-&gt;sanitiseVariableValue($name, $value); $value = $this-&gt;resolveNestedVariables($value); return array($name, $value);&#125; splitCompoundStringIntoParts用于将赋值语句转化为环境变量名name和环境变量值value。12345678protected function splitCompoundStringIntoParts($name, $value)&#123; if (strpos($name, '=') !== false) &#123; list($name, $value) = array_map('trim', explode('=', $name, 2)); &#125; return array($name, $value);&#125; sanitiseVariableName用于格式化环境变量名：123456protected function sanitiseVariableName($name, $value)&#123; $name = trim(str_replace(array('export ', '\'', '"'), '', $name)); return array($name, $value);&#125; sanitiseVariableValue用于格式化环境变量值：123456789101112131415161718192021222324252627282930313233343536protected function sanitiseVariableValue($name, $value)&#123;$value = trim($value);if (!$value) &#123;return array($name, $value);&#125;if ($this-&gt;beginsWithAQuote($value)) &#123; // value starts witha quote$quote = $value[0];$regexPattern = sprintf('/^%1$s # match a quote at the start of the value( # capturing sub-pattern used(?: # we do not need to capture this|\\\\\\\\ # or two backslashes together|\\\\%1$s # or an escaped quote e.g \")* # as many characters that match the previous rules) # end of the capturing sub-pattern%1$s # and the closing quote.*$ # and discard any string after the closing quote/mx',$quote);$value = preg_replace($regexPattern, '$1', $value);$value = str_replace("\\$quote", $quote, $value);$value = str_replace('\\\\', '\\', $value);&#125; else &#123;$parts = explode(' #', $value, 2);$value = trim($parts[0]);// Unquoted values cannot contain whitespaceif (preg_match('/\s+/', $value) &gt; 0) &#123;throw new InvalidFileException('Dotenv values containing spaces must be surrounded by quotes.');&#125;&#125;return array($name, trim($value));&#125; 这段代码是加载env文件最复杂的部分，我们详细来说：若环境变量值是具体值，那么仅仅需要分割注 #部分，并判断是否存在空格符即可。若环境变量值由引用构成，那么就需要进行正则匹配，具体的正则表达式为：1/^"((?:[^"\\]|\\\\|\\"))".*$/mx 这个正则表达式的意思是：提取 “” 双引号内部的字符串，抛弃双引号之后的字符串若双引号内部还有双引号，那么以最前面的双引号为提取内容，例如”dfd(“dfd”)fdf”，我们只能提取出来最前面的部分 “dfd(“对于内嵌的引用可以使用 \” ，例如 “dfd\”dfd\”fdf”,我们就可以提取出来”dfd\”dfd\”fdf”。不允许引用中含有 \ ，但可以使用转义字符 \\ Configconfig配置文件的加载config配置文件由类\Illuminate\Foundation\Bootstrap\LoadConfiguration::class完成：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace Illuminate\Foundation\Bootstrap;use Exception;use Illuminate\Config\Repository;use Illuminate\Contracts\Config\Repository as RepositoryContract;use Illuminate\Contracts\Foundation\Application;use SplFileInfo;use Symfony\Component\Finder\Finder;class LoadConfiguration&#123; /** * 引导给定的应用程序 * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function bootstrap(Application $app) &#123; $items = []; // 首先，我们将查看是否有缓存配置文件。如果有，我们将从该文件中加载配置项，以使其非常快。 // 否则，我们将需要遍历每个配置文件并全部加载它们。 if (file_exists($cached = $app-&gt;getCachedConfigPath())) &#123; $items = require $cached; $loadedFromCache = true; &#125; $app-&gt;instance('config', $config = new Repository($items)); // 接下来，我们将遍历配置目录中的所有配置文件，并将每个配置文件加载到存储库中。 // 这将使开发人员可以在该应用的各个部分中使用所有选项。 if (! isset($loadedFromCache)) &#123; $this-&gt;loadConfigurationFiles($app, $config); &#125; // 最后，我们将基于已加载的配置值设置应用程序的环境。 // 我们将传递一个回调，该回调将用于在不存在“--env”开关的Web上下文中获取环境。 $app-&gt;detectEnvironment(function () use ($config) &#123; return $config-&gt;get('app.env', 'production'); &#125;); date_default_timezone_set($config-&gt;get('app.timezone', 'UTC')); mb_internal_encoding('UTF-8'); &#125;&#125; 可以看到，配置文件的加载步骤： 加载缓存 若缓存不存在，则利用函数loadConfigurationFiles加载配置文件 加载环境变量、时间区、编码方式 函数loadConfigurationFiles用于加载配置文件：1234567891011121314151617181920212223/** * 从所有文件加载配置项 * * @param \Illuminate\Contracts\Foundation\Application $app * @param \Illuminate\Contracts\Config\Repository $repository * @return void * * @throws \Exception */protected function loadConfigurationFiles(Application $app, RepositoryContract $repository)&#123; $files = $this-&gt;getConfigurationFiles($app); if (! isset($files['app'])) &#123; throw new Exception('Unable to load the "app" configuration file.'); &#125; foreach ($files as $key =&gt; $path) &#123; $repository-&gt;set($key, require $path); &#125;&#125; 加载配置文件有两部分：搜索配置文件、加载配置文件的数组变量值 搜索配置文件getConfigurationFiles可以根据配置文件目录搜索所有的php为后缀的文件，并将其转化为files数组，其key为目录名以字符“.”为连接的字符串，value为文件真实路径：123456789101112131415161718192021222324252627282930313233343536373839404142/** * 获取该应用程序的所有配置文件 * * @param \Illuminate\Contracts\Foundation\Application $app * @return array */protected function getConfigurationFiles(Application $app)&#123; $files = []; $configPath = realpath($app-&gt;configPath()); foreach (Finder::create()-&gt;files()-&gt;name('*.php')-&gt;in($configPath) as $file) &#123; $directory = $this-&gt;getNestedDirectory($file, $configPath); $files[$directory.basename($file-&gt;getRealPath(), '.php')] = $file-&gt;getRealPath(); &#125; ksort($files, SORT_NATURAL); return $files;&#125;/** * 获取配置文件的嵌套路径 * * @param \SplFileInfo $file * @param string $configPath * @return string */protected function getNestedDirectory(SplFileInfo $file, $configPath)&#123; $directory = $file-&gt;getPath(); if ($nested = trim(str_replace($configPath, '', $directory), DIRECTORY_SEPARATOR)) &#123; $nested = str_replace(DIRECTORY_SEPARATOR, '.', $nested).'.'; &#125; return $nested;&#125; 加载配置文件数组加载配置文件由类Illuminate\Config\Repository\LoadConfiguration完成：123456789101112131415161718192021222324252627&lt;?phpnamespace Illuminate\Config;use ArrayAccess;use Illuminate\Contracts\Config\Repository as ConfigContract;use Illuminate\Support\Arr;class Repository implements ArrayAccess, ConfigContract&#123; /** * Set a given configuration value. * * @param array|string $key * @param mixed $value * @return void */ public function set($key, $value = null) &#123; $keys = is_array($key) ? $key : [$key =&gt; $value]; foreach ($keys as $key =&gt; $value) &#123; Arr::set($this-&gt;items, $key, $value); &#125; &#125;&#125; 加载配置文件时间上就是将所有配置文件的数值放入一个巨大的多维数组中，这一部分由类Illuminate\Support\Arr完成：1234567891011121314151617181920212223242526272829303132333435363738394041class Arr&#123; /** * Set an array item to a given value using "dot" notation. * * If no key is given to the method, the entire array will be replaced. * * @param array $array * @param string|null $key * @param mixed $value * @return array */ public static function set(&amp;$array, $key, $value) &#123; if (is_null($key)) &#123; return $array = $value; &#125; $keys = explode('.', $key); while (count($keys) &gt; 1) &#123; $key = array_shift($keys); // If the key doesn't exist at this depth, we will just create an empty array // to hold the next value, allowing us to create the arrays to hold final // values at the correct depth. Then we'll keep digging into the array. if (! isset($array[$key]) || ! is_array($array[$key])) &#123; $array[$key] = []; &#125; $array = &amp;$array[$key]; &#125; $array[array_shift($keys)] = $value; return $array; &#125;&#125; 例如dir1.dir2.app，配置文件会生成$array[dir1][dir2][app]这样的数组。 配置文件数值的获取当我们利用全局函数config来获取配置值的时候：1234567891011121314151617181920212223242526if (! function_exists('config')) &#123; /** * Get / set the specified configuration value. * * If an array is passed as the key, we will assume you want to set an array of values. * * @param array|string|null $key * @param mixed $default * @return mixed|\Illuminate\Config\Repository */ function config($key = null, $default = null) &#123; if (is_null($key)) &#123; return app('config'); &#125; if (is_array($key)) &#123; return app('config')-&gt;set($key); &#125; return app('config')-&gt;get($key, $default); &#125;&#125; 配置文件的获取和加载类似，都是将字符串转为多维数组，然后获取具体数组值：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Get an item from an array using "dot" notation. * * @param \ArrayAccess|array $array * @param string|int|null $key * @param mixed $default * @return mixed */public static function get($array, $key, $default = null)&#123; if (! static::accessible($array)) &#123; return value($default); &#125; if (is_null($key)) &#123; return $array; &#125; if (static::exists($array, $key)) &#123; return $array[$key]; &#125; if (strpos($key, '.') === false) &#123; return $array[$key] ?? value($default); &#125; foreach (explode('.', $key) as $segment) &#123; if (static::accessible($array) &amp;&amp; static::exists($array, $segment)) &#123; $array = $array[$segment]; &#125; else &#123; return value($default); &#125; &#125; return $array;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Event-事件系统的启动与运行源码分析]]></title>
    <url>%2F2020%2F05%2F17%2FLaravel-Event-%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言Laravel的事件系统是一个简单的观察者模式，主要目的是用于代码的解耦，可以防止不同功能的代码耦合在一起。Laravel中事件系统由两部分构成，一个是事件的名称，事件的名称可以是个字符串，例如event.email，也可以是一个事件类，例如App\Events\OrderShipped；另一个是事件的Listener，可以是一个闭包，还可以是监听类，例如App\Listeners\SendShipmentNotification。 事件服务的注册事件服务的注册分为两部分，一个是Application启动时所调用的registerBaseServiceProviders函数： Illuminate\Foundation\Application.php 1234567891011/** * Register all of the base service providers. * * @return void */protected function registerBaseServiceProviders()&#123; $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this));&#125; 其中的EventServiceProvider是/Illuminate/Events/EventServiceProvider： Illuminate\Support\ServiceProvider.php 1234567891011121314151617181920abstract class ServiceProvider&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * Create a new service provider instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125;&#125; Illuminate\Events\EventServiceProvider.php 1234567891011121314151617181920212223&lt;?phpnamespace Illuminate\Events;use Illuminate\Contracts\Queue\Factory as QueueFactoryContract;use Illuminate\Support\ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('events', function ($app) &#123; return (new Dispatcher($app))-&gt;setQueueResolver(function () use ($app) &#123; return $app-&gt;make(QueueFactoryContract::class); &#125;); &#125;); &#125;&#125; 这部分为IoC容器注册了events实例，Dispatcher就是events真正的实现类。QueueResolver是队列化事件的实现。 另一个注册是普通注册类/app/Providers/EventServiceProvider：12345678910111213141516171819202122232425class EventServiceProvider extends ServiceProvider&#123; /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'App\Events\SomeEvent' =&gt; [ 'App\Listeners\EventListener', ], ]; /** * Register any events for your application. * * @return void */ public function boot() &#123; parent::boot(); // &#125;&#125; 这个注册类的主要作用是事件系统的启动，这个类继承自/Illuminate/Foundation/Support/Providers/EventServiceProvider： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Foundation\Support\Providers;use Illuminate\Foundation\Events\DiscoverEvents;use Illuminate\Support\Facades\Event;use Illuminate\Support\ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; /** * The event handler mappings for the application. * * @var array */ protected $listen = []; /** * The subscriber classes to register. * * @var array */ protected $subscribe = []; /** * Register the application's event listeners. * * @return void */ public function boot() &#123; $events = $this-&gt;getEvents(); foreach ($events as $event =&gt; $listeners) &#123; foreach (array_unique($listeners) as $listener) &#123; Event::listen($event, $listener); &#125; &#125; foreach ($this-&gt;subscribe as $subscriber) &#123; Event::subscribe($subscriber); &#125; &#125;&#125; 可以看到，事件系统的启动主要是进行事件系统的监听与订阅。 事件系统的监听Listen所谓的事件监听，就是将事件名与闭包函数，或者事件类与监听类之间建立关联。1234567891011121314151617181920212223242526272829303132333435/** * Register an event listener with the dispatcher. * * @param string|array $events * @param \Closure|string $listener * @return void */public function listen($events, $listener)&#123; foreach ((array) $events as $event) &#123; if (Str::contains($event, '*')) &#123; $this-&gt;setupWildcardListen($event, $listener); &#125; else &#123; $this-&gt;listeners[$event][] = $this-&gt;makeListener($listener); &#125; &#125;&#125;/** * Setup a wildcard listener callback. * * @param string $event * @param \Closure|string $listener * @return void */protected function setupWildcardListen($event, $listener)&#123; $this-&gt;wildcards[$event][] = $this-&gt;makeListener($listener, true); $this-&gt;wildcardsCache = [];&#125; 对于有通配符的事件名，会统一放入wildcards数组中，makeListener是创建事件的关键：12345678910111213141516171819202122232425/** * Register an event listener with the dispatcher. * * @param \Closure|string $listener * @param bool $wildcard * @return \Closure */public function makeListener($listener, $wildcard = false)&#123; if (is_string($listener)) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; if (is_array($listener) &amp;&amp; isset($listener[0]) &amp;&amp; is_string($listener[0])) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return $listener($event, $payload); &#125; return $listener(...array_values($payload)); &#125;;&#125; 创建监听者的时候，会判断监听对象是监听类还是闭包函数。 对于闭包监听来说，makeListener会再包上一层闭包函数，根据是否含有通配符来确定具体的参数。 对于监听类来说，会继续createClassListener：1234567891011121314151617181920212223242526272829303132333435363738/** * Create a class based listener using the IoC container. * * @param string $listener * @param bool $wildcard * @return \Closure */public function createClassListener($listener, $wildcard = false)&#123; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return call_user_func($this-&gt;createClassCallable($listener), $event, $payload); &#125; return call_user_func_array( $this-&gt;createClassCallable($listener), $payload ); &#125;;&#125;/** * Create the class based event callable. * * @param array|string $listener * @return callable */protected function createClassCallable($listener)&#123; [$class, $method] = is_array($listener) ? $listener : $this-&gt;parseClassCallable($listener); if ($this-&gt;handlerShouldBeQueued($class)) &#123; return $this-&gt;createQueuedHandlerCallable($class, $method); &#125; return [$this-&gt;container-&gt;make($class), $method];&#125; 对于监听类来说，程序首先会判断监听类对应的函数：12345678910/** * Parse the class listener into class and method. * * @param string $listener * @return array */protected function parseClassCallable($listener)&#123; return Str::parseCallback($listener, 'handle');&#125; 如果未指定监听类的对应函数，那么会默认handle函数。 如果当前监听类是队列的话，会将任务推送给队列。 触发事件事件的触发可以利用事件名，或者事件类的实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 触发事件并调用侦听器 * * @param string|object $event * @param mixed $payload * @param bool $halt * @return array|null */public function dispatch($event, $payload = [], $halt = false)&#123; // 当给定的“事件”实际上是一个对象时，我们将假定它是一个事件对象，并使用类作为事件名称， // 并使用该事件本身作为处理程序的有效负载，这使基于对象的事件非常简单。 [$event, $payload] = $this-&gt;parseEventAndPayload( $event, $payload ); if ($this-&gt;shouldBroadcast($payload)) &#123; $this-&gt;broadcastEvent($payload[0]); &#125; $responses = []; foreach ($this-&gt;getListeners($event) as $listener) &#123; $response = $listener($event, $payload); // 如果从侦听器返回了响应，并且启用了事件暂停，我们将仅返回此响应，而不调用其余的事件侦听器。 // 否则，我们会将响应添加到响应列表中。 if ($halt &amp;&amp; ! is_null($response)) &#123; return $response; &#125; // 如果从侦听器返回false，则我们将停止将事件传播到链中任何其他侦听器， // 否则我们将继续遍历侦听器并触发序列中的每个侦听器。 if ($response === false) &#123; break; &#125; $responses[] = $response; &#125; return $halt ? null : $responses;&#125; parseEventAndPayload函数利用传入参数是事件名还是事件类实例来确定监听类函数的参数：12345678910111213141516/** * 解析给定的事件和有效负载，并为分发做好准备 * * @param mixed $event * @param mixed $payload * @return array */protected function parseEventAndPayload($event, $payload)&#123; if (is_object($event)) &#123; [$payload, $event] = [[$event], get_class($event)]; &#125; return [$event, Arr::wrap($payload)];&#125; 如果是事件类的实例，那么监听函数的参数就是事件类自身；如果是事件类名，那么监听函数的参数就是触发事件时传入的参数。 获得事件与参数后，就要获取监听类：12345678910111213141516171819/** * Get all of the listeners for a given event name. * * @param string $eventName * @return array */public function getListeners($eventName)&#123; $listeners = $this-&gt;listeners[$eventName] ?? []; $listeners = array_merge( $listeners, $this-&gt;wildcardsCache[$eventName] ?? $this-&gt;getWildcardListeners($eventName) ); return class_exists($eventName, false) ? $this-&gt;addInterfaceListeners($eventName, $listeners) : $listeners;&#125; 寻找监听类的时候，也要从通配符监听器中寻找：1234567891011121314protected function getWildcardListeners($eventName)&#123; $wildcards = []; foreach ($this-&gt;wildcards as $key =&gt; $listeners) &#123; if (Str::is($key, $eventName)) &#123; $wildcards = array_merge($wildcards, $listeners); &#125; &#125; return $wildcards;&#125; 如果监听类继承自其他类，那么父类也会一并当做监听类返回。 获得了监听类之后，就要调用监听类相应的函数。 触发事件时有一个参数halt，这个参数如果是true的时候，只要有一个监听类返回了结果，那么就会立刻返回。例如：1234567891011121314151617public function testHaltingEventExecution()&#123; unset($_SERVER['__event.test']); $d = new Dispatcher; $d-&gt;listen('foo', function ($foo) &#123; $this-&gt;assertTrue(true); return 'here'; &#125;); $d-&gt;listen('foo', function ($foo) &#123; throw new Exception('should not be called'); &#125;); $d-&gt;until('foo', ['bar']);&#125; 多个监听类在运行的时候，只要有一个返回了false，那么就会中断事件。 push函数push函数可以将触发事件的参数事先设置好，这样触发的时候只要写入事件名即可，例如：123456789101112131415161718public function testQueuedEventsAreFired()&#123; unset($_SERVER['__event.test']); $d = new Dispatcher; $d-&gt;push('update', ['name' =&gt; 'taylor']); $d-&gt;listen('update', function ($name) &#123; $_SERVER['__event.test'] = $name; &#125;); $this-&gt;assertFalse(isset($_SERVER['__event.test'])); $d-&gt;flush('update'); $this-&gt;assertEquals('taylor', $_SERVER['__event.test']);&#125; 原理也很简单：123456789101112131415161718192021222324/** * Register an event and payload to be fired later. * * @param string $event * @param array $payload * @return void */public function push($event, $payload = [])&#123; $this-&gt;listen($event.'_pushed', function () use ($event, $payload) &#123; $this-&gt;dispatch($event, $payload); &#125;);&#125;/** * Flush a set of pushed events. * * @param string $event * @return void */public function flush($event)&#123; $this-&gt;dispatch($event.'_pushed');&#125; 数据库Eloquent的事件数据库模型的事件的注册除了以上的方法还有另外两种，具体详情可以看：Laravel模型事件实现原理； 事件注册静态方法定义 12345678910111213class EventServiceProvider extends ServiceProvider&#123; public function boot() &#123; parent::boot(); User::saved(function(User$user) &#123; &#125;); User::saved('UserSavedListener@saved'); &#125;&#125; 观察者 123456789101112class UserObserver&#123; public function created(User $user) &#123; &#125; public function saved(User $user) &#123; &#125;&#125; 然后在某个服务提供者的boot方法中注册观察者：123456789101112class AppServiceProvider extends ServiceProvider&#123; public function boot() &#123; User::observe(UserObserver::class); &#125; public function register() &#123; &#125;&#125; 这两种方法都是向事件系统注册事件名eloquent.{$event}:{static::class}： 静态方法 123456789101112131415161718192021222324252627/** * Register a saved model event with the dispatcher. * * @param \Closure|string $callback * @return void */public static function saved($callback)&#123; static::registerModelEvent('saved', $callback);&#125; /** * Register a model event with the dispatcher. * * @param string $event * @param \Closure|string $callback * @return void */protected static function registerModelEvent($event, $callback)&#123; if (isset(static::$dispatcher)) &#123; $name = static::class; static::$dispatcher-&gt;listen("eloquent.&#123;$event&#125;: &#123;$name&#125;", $callback); &#125;&#125; 观察者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Register observers with the model. * * @param object|array|string $classes * @return void * * @throws \RuntimeException */public static function observe($classes)&#123; $instance = new static; foreach (Arr::wrap($classes) as $class) &#123; $instance-&gt;registerObserver($class); &#125;&#125;/** * Register a single observer with the model. * * @param object|string $class * @return void * * @throws \RuntimeException */protected function registerObserver($class)&#123; $className = $this-&gt;resolveObserverClassName($class); // 在注册模型观察者时，我们将遍历所有可能的事件并确定该观察者是否具有该方法。 // 如果是这样，我们会将其挂接到模型的事件系统中，以方便观看。 foreach ($this-&gt;getObservableEvents() as $event) &#123; if (method_exists($class, $event)) &#123; static::registerModelEvent($event, $className.'@'.$event); &#125; &#125;&#125;/** * Get the observable event names. * * @return array */public function getObservableEvents()&#123; return array_merge( [ 'retrieved', 'creating', 'created', 'updating', 'updated', 'saving', 'saved', 'restoring', 'restored', 'replicating', 'deleting', 'deleted', 'forceDeleted', ], $this-&gt;observables );&#125; 事件触发模型事件的触发需要调用fireModelEvent函数：12345678910111213141516171819202122232425262728293031/** * Fire the given event for the model. * * @param string $event * @param bool $halt * @return mixed */protected function fireModelEvent($event, $halt = true)&#123; if (! isset(static::$dispatcher)) &#123; return true; &#125; // 首先，我们将获得适当的方法来调用事件分配器，然后尝试为给定事件触发基于对象的自定义事件。 // 如果返回一个结果，我们可以返回该结果，或者我们将调用字符串事件。 $method = $halt ? 'until' : 'dispatch'; $result = $this-&gt;filterModelEventResults( $this-&gt;fireCustomModelEvent($event, $method) ); if ($result === false) &#123; return false; &#125; return ! empty($result) ? $result : static::$dispatcher-&gt;&#123;$method&#125;( "eloquent.&#123;$event&#125;: ".static::class, $this );&#125; fireCustomModelEvent是我们本文中着重讲的事件类与监听类的触发：123456789101112131415161718192021/** * Fire a custom model event for the given event. * * @param string $event * @param string $method * @return mixed|null */protected function fireCustomModelEvent($event, $method)&#123; if (! isset($this-&gt;dispatchesEvents[$event])) &#123; return; &#125; $result = static::$dispatcher-&gt;$method(new $this-&gt;dispatchesEvents[$event]($this)); if (! is_null($result)) &#123; return $result; &#125;&#125; 如果没有对应的事件后，会继续利用事件名进行触发。 until是我们上一节讲的如果任意事件返回正确结果，就会直接返回，不会继续进行下一个事件。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Container-IoC服务容器]]></title>
    <url>%2F2020%2F05%2F14%2FLaravel-Container-IoC%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 服务容器在说IoC容器之前，我们需要了解什么是IoC容器。 Laravel服务容器是一个用于管理类依赖和执行依赖注入的强大工具。 在理解这句话之前，我们需要先了解一下服务容器的来龙去脉：Laravel神奇的服务容器。这篇博客告诉我们，服务容器就是工厂模式的升级版，对于传统的工厂模式来说，虽然解耦了对象和外部资源之间的关系，但是工厂和外部资源之间却存在了耦和。而服务容器在为对象创建了外部资源的同时，又与外部资源没有任何关系，这个就是IoC容器。 所谓的依赖注入和控制反转：依赖注入和控制反转，就是只要不是由内部生产（比如初始化、构造函数__construct中通过工厂方法、自行手动new的），而是由外部以参数或其他形式注入的，都属于依赖注入（DI）。 也就是说： 依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。 Laravel中的服务容器Laravel服务容器主要承担两个作用：绑定与解析。 绑定所谓的绑定就是将接口与实现建立对应关系。几乎所有的服务容器绑定都是在服务提供者中完成，也就是在服务提供者中绑定。 如果一个类没有基于任何接口那么就没有必要将其绑定到容器。容器并不需要被告知如何构建对象，因为它会使用PHP的反射服务自动解析出具体的对象。 也就是说，如果需要依赖注入的外部资源如果没有接口，那么就不需要绑定，直接利用服务容器进行解析就可以了，服务容器会根据类名利用反射对其进行自动构造。 bind绑定绑定有多种方法，首先最常用的是bind函数的绑定： 绑定自身 1234567891011121314151617181920212223242526272829$this-&gt;app-&gt;bind('App\Services\RedisEventPusher', null);$this-&gt;app-&gt;bind('name', function () &#123; return 'Taylor';&#125;); // 闭包返回变量$this-&gt;app-&gt;bind('HelpSpot\API', function () &#123; return HelpSpot\API::class;&#125;); // 闭包直接提供类实现方式public function testSharedClosureResolution()&#123; $container = new Container; $class = new stdClass; $container-&gt;bind('class', function () use ($class) &#123; return $class; &#125;); $this-&gt;assertSame($class, $container-&gt;make('class'));&#125; // 闭包返回类变量$this-&gt;app-&gt;bind('HelpSpot\API', function () &#123; return new HelpSpot\API();&#125;);// 闭包直接提供类实现方式$this-&gt;app-&gt;bind('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;);// 闭包返回需要依赖注入的类 绑定接口 1234567891011121314151617181920212223242526272829public function testCanBuildWithoutParameterStackWithConstructors()&#123; $container = new Container; $container-&gt;bind('Illuminate\Tests\Container\IContainerContractStub', 'Illuminate\Tests\Container\ContainerImplementationStub'); $this-&gt;assertInstanceOf( ContainerDependentStub::class, $container-&gt;build(ContainerDependentStub::class) );&#125;interface IContainerContractStub&#123;&#125;class ContainerImplementationStub implements IContainerContractStub&#123;&#125;class ContainerDependentStub&#123; public $impl; public function __construct(IContainerContractStub $impl) &#123; $this-&gt;impl = $impl; &#125;&#125; 这三种绑定方式中，第一种绑定自身一般用于绑定单例。 bindif绑定 1234567891011121314public function testBindIfDoesntRegisterIfServiceAlreadyRegistered()&#123; $container = new Container; $container-&gt;bind('name', function ()&#123; return 'Taylor'; &#125;); $container-&gt;bindIf('name', function () &#123; return 'Dayle'; &#125;); $this-&gt;assertEquals('Taylor', $container-&gt;make('name'));&#125; singleton绑定 singleton方法绑定一个只需要解析一次的类或接口到容器，然后接下来对容器的调用将会返回同一个实例：123$this-&gt;app-&gt;singleton('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;); 值得注意的是，singleton绑定在解析的时候若存在参数重载，那么就自动取消单例模式。123456789101112public function testSingletonBindingsNotRespectedWithMakeParameters()&#123; $container = new Container; $container-&gt;singleton('foo', function ($app, $config) &#123; return $config; &#125;); $this-&gt;assertEquals(['name' =&gt; 'taylor'], $container-&gt;makeWith('foo', ['name' =&gt; 'taylor'])); $this-&gt;assertEquals(['name' =&gt; 'abigail'], $container-&gt;makeWith('foo', ['name' =&gt; 'abigail']));&#125; instance绑定 我们还可以使用instance方法绑定一个已存在的对象实例到容器，随后调用容器将总是返回给定的实例：12$api = new HelpSpot\API(new HttpClient);$this-&gt;app-&gt;instance('HelpSpot\Api', $api); Context绑定 有时侯我们可能有两个类使用同一个接口，但我们希望在每个类中注入不同实现，例如，两个控制器依赖Illuminate\Contracts\Filesystem\Filesystem契约的不同实现。Laravel为此定义了简单、平滑的接口：12345678910111213141516171819202122use Illuminate\Support\Facades\Storage;use App\Http\Controllers\VideoController;use App\Http\Controllers\PhotoControllers;use Illuminate\Contracts\Filesystem\Filesystem;$this-&gt;app-&gt;when(StorageController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; Storage::class &#125;); // 提供类名$this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return new Storage(); &#125;); // 提供实现方式$this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return new Storage($app-&gt;make(Disk::class)); &#125;); // 需要依赖注入 原始值绑定 我们可能有一个接收注入类的类，同时需要注入一个原生的数值比如整型，可以结合上下文轻松注入这个类需要的任何值：123$this-&gt;app-&gt;when('App\Http\Controllers\UserController') -&gt;needs('$variableName') -&gt;give($value); 数组绑定 数组绑定一般用于绑定闭包和变量，但是不能绑定接口，否则只能返回接口的实现类名字符串,并不能返回实现类的对象。1234567891011121314151617public function testArrayAccess()&#123; $container = new Container; $container[IContainerContractStub::class] = ContainerImplementationStub::class; $this-&gt;assertTrue(isset($container[IContainerContractStub::class])); $this-&gt;assertEquals( ContainerImplementationStub::class, $container[IContainerContractStub::class] ); unset($container['something']); $this-&gt;assertFalse(isset($container['something']));&#125; 标签绑定 少数情况下，我们需要解析特定分类下的所有绑定，例如，你正在构建一个接收多个不同Report接口实现的报告聚合器，在注册完Report实现之后，可以通过tag方法给它们分配一个标签：123456789$this-&gt;app-&gt;bind('SpeedReport', function () &#123;//&#125;);$this-&gt;app-&gt;bind('MemoryReport', function () &#123;//&#125;);$this-&gt;app-&gt;tag(['SpeedReport', 'MemoryReport'], 'reports'); 这些服务被打上标签后，可以通过tagged方法来轻松解析它们：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$this-&gt;app-&gt;bind('ReportAggregator', function ($app) &#123; return new ReportAggregator($app-&gt;tagged('reports'));&#125;);public function testContainerTags()&#123; $container = new Container; $container-&gt;tag( 'Illuminate\Tests\Container\ContainerImplementationStub', 'foo', 'bar' ); $container-&gt;tag( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', ['foo'] ); $this-&gt;assertCount(1, $container-&gt;tagged('bar')); $this-&gt;assertCount(2, $container-&gt;tagged('foo')); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;tagged('foo')[0] ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;tagged('bar')[0] ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;tagged('foo')[1] ); $container = new Container; $container-&gt;tag( [ 'Illuminate\Tests\Container\ContainerImplementationStub', 'Illuminate\Tests\Container\ContainerImplementationStubTwo' ], ['foo'] ); $this-&gt;assertCount(2, $container-&gt;tagged('foo')); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;tagged('foo')[0] ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;tagged('foo')[1] ); $this-&gt;assertEmpty($container-&gt;tagged('this_tag_does_not_exist'));&#125; extend扩展 extend是在当原来的类被注册或者实例化出来后，可以对其进行扩展，而且可以支持多重扩展：123456789101112131415161718192021222324252627282930public function testExtendInstancesArePreserved()&#123; $container = new Container; $container-&gt;bind('foo', function () &#123; $obj = new StdClass; $obj-&gt;foo = 'bar'; return $obj; &#125;); $obj = new StdClass; $obj-&gt;foo = 'foo'; $container-&gt;instance('foo', $obj); $container-&gt;extend('foo', function ($obj, $container) &#123; $obj-&gt;bar = 'baz'; return $obj; &#125;); $container-&gt;extend('foo', function ($obj, $container) &#123; $obj-&gt;baz = 'foo'; return $obj; &#125;); $this-&gt;assertEquals('foo', $container-&gt;make('foo')-&gt;foo); $this-&gt;assertEquals('baz', $container-&gt;make('foo')-&gt;bar); $this-&gt;assertEquals('foo', $container-&gt;make('foo')-&gt;baz);&#125; Rebounds与Rebinding绑定是针对接口的，是为接口提供实现方式的方法。我们可以对接口在不同的时间段里提供不同的实现方法，一般来说，对同一个接口提供新的实现方法后，不会对已经实例化的对象产生任何影响。但是在一些场景下，在提供新的接口实现后，我们希望对已经实例化的对象重新做一些改变，这个就是rebinding函数的用途。下面就是一个例子：1234567891011121314151617181920212223242526272829303132333435abstract class Car&#123; public function __construct(Fuel $fuel) &#123; $this-&gt;fuel = $fuel; &#125; public function refuel($litres) &#123; return $litres * $this-&gt;fuel-&gt;getPrice(); &#125; public function setFuel(Fuel $fuel) &#123; $this-&gt;fuel = $fuel; &#125;&#125;class JeepWrangler extends Car&#123;//&#125;interface Fuel&#123; public function getPrice();&#125;class Petrol implements Fuel&#123; public function getPrice() &#123; return 130.7; &#125;&#125; 我们在服务容器中是这样对car接口和fuel接口绑定的：123456789$this-&gt;app-&gt;bind('fuel', function ($app) &#123; return new Petrol;&#125;);$this-&gt;app-&gt;bind('car', function ($app) &#123; return new JeepWrangler($app['fuel']);&#125;);$this-&gt;app-&gt;make('car'); 如果car被服务容器解析实例化成对象之后，有人修改了fuel接口的实现，从Petrol改为 PremiumPetrol：123$this-&gt;app-&gt;bind('fuel', function ($app) &#123; return new PremiumPetrol;&#125;); 由于car已经被实例化，那么这个接口实现的改变并不会影响到car的实现，假若我们想要car的成员变量fuel随着fuel接口的变化而变化，我们就需要一个回调函数，每当对fuel接口实现进行改变的时候，都要对car的fuel变量进行更新，这就是rebinding的用途：12345678910$this-&gt;app-&gt;bindShared('car', function ($app) &#123; return new JeepWrangler( $app-&gt;rebinding( 'fuel', function ($app, $fuel) &#123; $app['car']-&gt;setFuel($fuel); &#125; ) );&#125;); 服务别名什么是服务别名在说服务容器的解析之前，需要先说说服务的别名。什么是服务别名呢？不同于上一个博客中提到的Facade门面的别名(在config/app中定义)，这里的别名服务绑定名称的别名。通过服务绑定的别名，在解析服务的时候，跟不使用别名的效果一致。别名的作用也是为了同时支持全类型的服务绑定名称以及简短的服务绑定名称考虑的。 通俗的讲，假如我们想要创建auth服务，我们既可以这样写：1$this-&gt;app-&gt;make('auth') 又可以写成：1$this-&gt;app-&gt;make('\Illuminate\Auth\AuthManager::class') 还可以写成1$this-&gt;app-&gt;make('\Illuminate\Contracts\Auth\Factory::class') 后面两个服务的名字都是auth的别名，使用别名和使用auth的效果是相同的。 服务别名的递归需要注意的是别名是可以递归的：123app()-&gt;alias('service', 'alias_a');app()-&gt;alias('alias_a', 'alias_b');app()-&gt;alias('alias_b', 'alias_c'); 会得到：123'alias_a' =&gt; 'service''alias_b' =&gt; 'alias_a''alias_c' =&gt; 'alias_b' 服务别名的实现那么这些别名是如何加载到服务容器里面的呢？实际上，服务容器里面有个aliases数组：12345678910111213141516171819202122$aliases = [ 'app' =&gt; [ \Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class ], 'auth' =&gt; [ \Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class ], 'auth.driver' =&gt; [ \Illuminate\Contracts\Auth\Guard::class ], 'blade.compiler' =&gt; [ \Illuminate\View\Compilers\BladeCompiler::class ], 'cache' =&gt; [ \Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class ], ...] 而服务容器的初始化的过程中，会运行一个函数：12345678910111213141516public function registerCoreContainerAliases()&#123; foreach ($aliases as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125;&#125;public function alias($abstract, $alias)&#123; $this-&gt;aliases[$alias] = $abstract; $this-&gt;abstractAliases[$abstract][] = $alias;&#125; 加载后，服务容器的aliases和abstractAliases数组：123456789101112131415161718192021222324252627282930$aliases = [ 'Illuminate\Foundation\Application' = "app" 'Illuminate\Contracts\Container\Container' = "app" 'Illuminate\Contracts\Foundation\Application' = "app" 'Illuminate\Auth\AuthManager' = "auth" 'Illuminate\Contracts\Auth\Factory' = "auth" 'Illuminate\Contracts\Auth\Guard' = "auth.driver" 'Illuminate\View\Compilers\BladeCompiler' = "blade.compiler" 'Illuminate\Cache\CacheManager' = "cache" 'Illuminate\Contracts\Cache\Factory' = "cache" ...］$abstractAliases = [ app = &#123;array&#125; [3] 0 = "Illuminate\Foundation\Application" 1 = "Illuminate\Contracts\Container\Container" 2 = "Illuminate\Contracts\Foundation\Application" auth = &#123;array&#125; [2] 0 = "Illuminate\Auth\AuthManager" 1 = "Illuminate\Contracts\Auth\Factory" auth.driver = &#123;array&#125; [1] 0 = "Illuminate\Contracts\Auth\Guard" blade.compiler = &#123;array&#125; [1] 0 = "Illuminate\View\Compilers\BladeCompiler" cache = &#123;array&#125; [2] 0 = "Illuminate\Cache\CacheManager" 1 = "Illuminate\Contracts\Cache\Factory" ...] 服务解析make解析有很多方式可以从容器中解析对象，首先，你可以使用make方法，该方法接收你想要解析的类名或接口名作为参数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public function testAutoConcreteResolution()&#123; $container = new Container; $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerConcreteStub', $container-&gt;make('Illuminate\Tests\Container\ContainerConcreteStub') );&#125;// 带有依赖注入和默认值的解析public function testResolutionOfDefaultParameters()&#123; $container = new Container; $instance = $container-&gt;make( 'Illuminate\Tests\Container\ContainerDefaultValueStub' ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerConcreteStub', $instance-&gt;stub ); $this-&gt;assertEquals('taylor', $instance-&gt;default);&#125;//public function testResolvingWithArrayOfParameters()&#123; $container = new Container; $instance = $container-&gt;makeWith( ContainerDefaultValueStub::class, ['default' =&gt; 'adam'] ); $this-&gt;assertEquals('adam', $instance-&gt;default); $instance = $container-&gt;make(ContainerDefaultValueStub::class); $this-&gt;assertEquals('taylor', $instance-&gt;default); $container-&gt;bind('foo', function ($app, $config) &#123; return $config; &#125;); $this-&gt;assertEquals( [1, 2, 3], $container-&gt;makeWith('foo', [1, 2, 3]) );&#125;public function testNestedDependencyResolution()&#123; $container = new Container; $container-&gt;bind( 'Illuminate\Tests\Container\IContainerContractStub', 'Illuminate\Tests\Container\ContainerImplementationStub' ); $class = $container-&gt;make( 'Illuminate\Tests\Container\ContainerNestedDependentStub'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerDependentStub', $class-&gt;inner ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $class-&gt;inner-&gt;impl );&#125;class ContainerDefaultValueStub&#123; public $stub; public $default; public function __construct(ContainerConcreteStub $stub, $default = 'taylor') &#123; $this-&gt;stub = $stub; $this-&gt;default = $default; &#125;&#125;class ContainerConcreteStub&#123;&#125;class ContainerImplementationStub implements IContainerContractStub&#123;&#125;class ContainerDependentStub&#123; public $impl; public function __construct(IContainerContractStub $impl) &#123; $this-&gt;impl = $impl; &#125;&#125;class ContainerNestedDependentStub&#123; public $inner; public function __construct(ContainerDependentStub $inner) &#123; $this-&gt;inner = $inner; &#125;&#125; 如果你所在的代码位置访问不了$app变量，可以使用辅助函数resolve：1$api = resolve('HelpSpot\API'); 自动注入12345678910111213141516171819202122namespace App\Http\Controllers;use App\Users\Repository as UserRepository;class UserController extends Controller&#123; /** * 用户仓库实例 */ protected $users; /** * 创建一个控制器实例 * * @param UserRepository $users 自动注入 * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125;&#125; call方法注入make解析是服务容器进行解析构建类对象时所用的方法，在实际应用中，还有另外一个需求，那就是当前已经获取了一个类对象，我们想要调用它的一个方法函数，这时发现这个方法中参数众多，如果一个个的make会比较繁琐，这个时候就要用到call解析了。我们可以看这个例子：123456789101112131415161718192021222324class TaskRepository&#123; public function testContainerCall(User $user,Task $task) &#123; $this-&gt;assertInstanceOf(User::class, $user); $this-&gt;assertInstanceOf(Task::class, $task); &#125; public static function testContainerCallStatic(User $user,Task $task) &#123; $this-&gt;assertInstanceOf(User::class, $user); $this-&gt;assertInstanceOf(Task::class, $task); &#125; public function testCallback() &#123; echo 'call callback successfully!'; &#125; public function testDefaultMethod() &#123; echo 'default Method successfully!'; &#125;&#125; 闭包函数注入12345678910111213141516171819public function testCallWithDependencies()&#123; $container = new Container; $result = $container-&gt;call(function (StdClass $foo, $bar =[]) &#123; return func_get_args(); &#125;); $this-&gt;assertInstanceOf('stdClass', $result[0]); $this-&gt;assertEquals([], $result[1]); $result = $container-&gt;call(function (StdClass $foo, $bar =[]) &#123; return func_get_args(); &#125;, ['bar' =&gt; 'taylor']); $this-&gt;assertInstanceOf('stdClass', $result[0]); $this-&gt;assertEquals('taylor', $result[1]);&#125; 普通函数注入12345678910111213public function testCallWithGlobalMethodName()&#123; $container = new Container; $result = $container-&gt;call('Illuminate\Tests\Container\containerTestInject'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerConcreteStub', $result[0] ); $this-&gt;assertEquals('taylor', $result[1]);&#125; 静态方法注入服务容器的call解析主要依靠call_user_func_array()函数，关于这个函数可以查看Laravel学习笔记之Callback Type - 来生做个漫画家，这个函数对类中的静态函数和非静态函数有一些区别，对于静态函数来说：123456789class ContainerCallTest&#123; public function testContainerCallStatic() &#123; App::call(TaskRepository::class.'@testContainerCallStatic'); App::call(TaskRepository::class.'::testContainerCallStatic'); App::call([TaskRepository::class,'testContainerCallStatic']); &#125;&#125; 服务容器调用类的静态方法有三种，注意第三种使用数组的形式，数组中可以直接传类名 TaskRepository::class； 非静态方法注入对于类的非静态方法：123456789class ContainerCallTest&#123; public function testContainerCall() &#123; $taskRepo = new TaskRepository(); App::call(TaskRepository::class.'@testContainerCall'); App::call([$taskRepo,'testContainerCall']); &#125;&#125; 我们可以看到非静态方法只有两种调用方式，而且第二种数组传递的参数是类对象，原因就是 call_user_func_array函数的限制，对于非静态方法只能传递对象。 bindmethod方法绑定服务容器还有一个bindmethod的方法，可以绑定类的一个方法到自定义的函数：1234567891011121314151617181920212223public function testContainCallMethodBind()&#123; App::bindMethod(TaskRepository::class.'@testContainerCallStatic',function () &#123; $taskRepo = new TaskRepository(); $taskRepo-&gt;testCallback(); &#125;); App::call(TaskRepository::class.'@testContainerCallStatic'); App::call(TaskRepository::class.'::testContainerCallStatic'); App::call([TaskRepository::class,'testContainerCallStatic']); App::bindMethod( TaskRepository::class.'@testContainerCall', function (TaskRepository $taskRepo) &#123; $taskRepo-&gt;testCallback(); &#125; ); $taskRepo = new TaskRepository(); App::call(TaskRepository::class.'@testContainerCall'); App::call([$taskRepo,'testContainerCall']);&#125; 从结果上看，bindmethod不会对静态的第二种解析方法（::解析方式）起作用，对于其他方式都会调用绑定的函数。1234567891011121314151617181920212223242526272829303132333435363738public function testCallWithBoundMethod()&#123; $container = new Container; $container-&gt;bindMethod( 'Illuminate\Tests\Container\ContainerTestCallStub@unresolvable', function ($stub) &#123; return $stub-&gt;unresolvable('foo', 'bar'); &#125; ); $result = $container-&gt;call( 'Illuminate\Tests\Container\ContainerTestCallStub@unresolvable' ); $this-&gt;assertEquals(['foo', 'bar'], $result); $container = new Container; $container-&gt;bindMethod( 'Illuminate\Tests\Container\ContainerTestCallStub@unresolvable', function ($stub) &#123; return $stub-&gt;unresolvable('foo', 'bar'); &#125; ); $result = $container-&gt;call([new ContainerTestCallStub, 'unresolvable']); $this-&gt;assertEquals(['foo', 'bar'], $result);&#125;class ContainerTestCallStub&#123; public function unresolvable($foo, $bar) &#123; return func_get_args(); &#125;&#125; 默认函数注入1234567891011121314151617181920212223public function testContainCallDefultMethod()&#123; App::call(TaskRepository::class,[],'testContainerCall'); App::call(TaskRepository::class,[],'testContainerCallStatic'); App::bindMethod( TaskRepository::class.'@testContainerCallStatic', function () &#123; $taskRepo = new TaskRepository(); $taskRepo-&gt;testCallback(); &#125; ); App::bindMethod( TaskRepository::class.'@testContainerCall', function (TaskRepository $taskRepo) &#123; $taskRepo-&gt;testCallback(); &#125; ); App::call(TaskRepository::class,[],'testContainerCall'); App::call(TaskRepository::class,[],'testContainerCallStatic');&#125; 值得注意的是，这种默认函数注入的方法使得非静态的方法也可以利用类名去调用，并不需要对象。默认函数注入也回受到bindmethod函数的影响。 数组解析app()[‘service’];app($service)的形式app(‘service’); 服务容器事件每当服务容器解析一个对象时就会触发一个事件。你可以使用resolving方法监听这个事件：123456789101112131415$this-&gt;app-&gt;resolving(function ($object, $app) &#123; // 解析任何类型的对象时都会调用该方法...&#125;);$this-&gt;app-&gt;resolving(HelpSpot\API::class, function ($api, $app)&#123; // 解析「HelpSpot\API」类型的对象时调用...&#125;);$this-&gt;app-&gt;afterResolving(function ($object, $app) &#123; // 解析任何类型的对象后都会调用该方法...&#125;);$this-&gt;app-&gt;afterResolving(HelpSpot\API::class, function ($api, $app) &#123; // 解析「HelpSpot\API」类型的对象后调用...&#125;); 服务容器每次解析对象的时候，都会调用这些通过resolving和afterResolving函数传入的闭包函数，也就是触发这些事件。 注意：如果是单例，则只在解析时会触发一次123456789101112131415161718192021222324252627282930313233343536373839public function testResolvingCallbacksAreCalled()&#123;$container = new Container;$container-&gt;resolving(function ($object) &#123;return $object-&gt;name = 'taylor';&#125;);$container-&gt;bind('foo', function () &#123;return new StdClass;&#125;);$instance = $container-&gt;make('foo');$this-&gt;assertEquals('taylor', $instance-&gt;name);&#125;public function testResolvingCallbacksAreCalledForType()&#123;$container = new Container;$container-&gt;resolving('StdClass', function ($object) &#123;return $object-&gt;name = 'taylor';&#125;);$container-&gt;bind('foo', function () &#123;return new StdClass;&#125;);$instance = $container-&gt;make('foo');$this-&gt;assertEquals('taylor', $instance-&gt;name);&#125;public function testResolvingCallbacksShouldBeFiredWhenCalledWithAliases()&#123;$container = new Container;$container-&gt;alias('StdClass', 'std');$container-&gt;resolving('std', function ($object) &#123;return $object-&gt;name = 'taylor';&#125;);$container-&gt;bind('foo', function () &#123;return new StdClass;&#125;);$instance = $container-&gt;make('foo');$this-&gt;assertEquals('taylor', $instance-&gt;name);&#125; 装饰函数容器的装饰函数有两种，wrap用于装饰call，factory用于装饰make：1234567891011121314151617181920212223242526public function testContainerWrap()&#123; $result = $container-&gt;wrap(function (StdClass $foo, $bar =[]) &#123; return func_get_args(); &#125;, ['bar' =&gt; 'taylor']); $this-&gt;assertInstanceOf('Closure', $result); $result = $result(); $this-&gt;assertInstanceOf('stdClass', $result[0]); $this-&gt;assertEquals('taylor', $result[1]);&#125;public function testContainerGetFactory()&#123; $container = new Container; $container-&gt;bind('name', function () &#123; return 'Taylor'; &#125;); $factory = $container-&gt;factory('name'); $this-&gt;assertEquals($container-&gt;make('name'), $factory());&#125; 容器重置flush容器的重置函数flush会清空容器内部的aliases、abstractAliases、resolved、bindings、instances123456789101112131415161718192021222324252627public function testContainerFlushFlushesAllBindingsAliasesAndResolvedInstances()&#123; $container = new Container; $container-&gt;bind('ConcreteStub', function () &#123; return new ContainerConcreteStub; &#125;, true); $container-&gt;alias('ConcreteStub', 'ContainerConcreteStub'); $concreteStubInstance = $container-&gt;make('ConcreteStub'); $this-&gt;assertTrue($container-&gt;resolved('ConcreteStub')); $this-&gt;assertTrue($container-&gt;isAlias('ContainerConcreteStub')); $this-&gt;assertArrayHasKey('ConcreteStub', $container-&gt;getBindings()); $this-&gt;assertTrue($container-&gt;isShared('ConcreteStub')); $container-&gt;flush(); $this-&gt;assertFalse($container-&gt;resolved('ConcreteStub')); $this-&gt;assertFalse($container-&gt;isAlias('ContainerConcreteStub')); $this-&gt;assertEmpty($container-&gt;getBindings()); $this-&gt;assertFalse($container-&gt;isShared('ConcreteStub'));&#125; 前言在前面几个博客中，我详细讲了IoC容器各个功能的使用、绑定的源码、解析的源码，今天这篇博客会详细介绍Ioc容器的一些细节，一些特性，以便更好地掌握容器的功能。 注：本文使用的测试类与测试对象都取自Laravel的单元测试文件src/illuminate/tests/Container/ContainerTest.php rebind绑定特性 rebind在绑定之前instance和普通bind绑定一样，当重新绑定的时候都会调用rebind回调函数，但是有趣的是，对于普通bind绑定来说，rebind回调函数被调用的条件是当前接口被解析过：12345678910111213141516171819202122public function testReboundListeners()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;rebinding('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $container-&gt;make('foo'); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertTrue($_SERVER['__test.rebind']);&#125; 所以遇到下面这样的情况，rebinding的回调函数是不会调用的：1234567891011121314151617181920public function testReboundListeners()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;rebinding('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertFalse(isset($_SERVER['__test.rebind']));&#125; 有趣的是对于instance绑定：1234567891011121314151617181920public function testReboundListeners()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;rebinding('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $container-&gt;instance('foo', function () &#123; &#125;); $this-&gt;assertTrue(isset($_SERVER['__test.rebind']));&#125; rebinding回调函数却是可以被调用的。其实原因就是 instance 源码中 rebinding 回调函数调用的条件是 rebound 为真，而普通 bind 函数调用 rebinding 回调函数的条件是 resolved 为真. 目前笔者不是很清楚为什么要对 instance 和 bind 区别对待，希望有大牛指导。 rebind在绑定之后 为了使得rebind回调函数在下一次的绑定中被激活，在rebind函数的源码中，如果判断当前对象已经绑定过，那么将会立即解析：12345678public function rebinding($abstract, Closure $callback)&#123; $this-&gt;reboundCallbacks[$abstract = $this-&gt;getAlias($abstract)][] = $callback; if ($this-&gt;bound($abstract)) &#123; return $this-&gt;make($abstract); &#125;&#125; 单元测试代码：12345678910111213141516171819202122232425public function testReboundListeners1()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;bind('foo', function () &#123; return 'foo'; &#125;); $container-&gt;resolving('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;rebinding('foo', function ($container,$object) &#123; // 会立即解析 $container['foobar'] = $object.'bar'; &#125;); $this-&gt;assertTrue($_SERVER['__test.rebind']); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertEquals('bar', $container['foobar']);&#125; resolving特性resolving 回调的类型resolving不仅可以针对接口执行回调函数，还可以针对接口实现的类型进行回调函数。 1234567891011121314151617181920212223242526272829303132333435public function testResolvingCallbacksAreCalledForType()&#123; $container = new Container; $container-&gt;resolving('StdClass', function ($object) &#123; return $object-&gt;name = 'taylor'; &#125;); $container-&gt;bind('foo', function () &#123; return new StdClass; &#125;); $instance = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $instance-&gt;name);&#125;public function testResolvingCallbacksShouldBeFiredWhenCalledWithAliases()&#123; $container = new Container; $container-&gt;alias('StdClass', 'std'); $container-&gt;resolving('std', function ($object) &#123; return $object-&gt;name = 'taylor'; &#125;); $container-&gt;bind('foo', function () &#123; return new StdClass; &#125;); $instance = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $instance-&gt;name);&#125; resolving回调与instance前面讲过，对于singleton绑定来说，resolving回调函数仅仅运行一次，只在singleton 第一次解析的时候才会调用。如果我们利用instance直接绑定类的对象，不需要解析，那么resolving回调函数将不会被调用：1234567891011121314public function testResolvingCallbacksAreCalledForSpecificAbstracts()&#123; $container = new Container; $container-&gt;resolving('foo', function ($object) &#123; return $object-&gt;name = 'taylor'; &#125;); $obj = new StdClass; $container-&gt;instance('foo', $obj); $instance = $container-&gt;make('foo'); $this-&gt;assertFalse(isset($instance-&gt;name));&#125; extend扩展特性extend用于扩展绑定对象的功能，对于普通绑定来说，这个函数的位置很灵活：在绑定前扩展12345678910111213141516171819202122public function testExtendIsLazyInitialized()&#123; ContainerLazyExtendStub::$initialized = false; $container = new Container; $container-&gt;extend( 'Illuminate\Tests\Container\ContainerLazyExtendStub', function ($obj, $container) &#123; $obj-&gt;init(); return $obj; &#125; ); $container-&gt;bind('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertTrue(ContainerLazyExtendStub::$initialized);&#125; 在绑定后解析前扩展 1234567891011121314151617181920public function testExtendIsLazyInitialized()&#123; ContainerLazyExtendStub::$initialized = false; $container = new Container; $container-&gt;bind('Illuminate\Tests\Container\ContainerLazyExtendStub'); $container-&gt;extend( 'Illuminate\Tests\Container\ContainerLazyExtendStub', function ($obj, $container) &#123; $obj-&gt;init(); return $obj; &#125; ); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertTrue(ContainerLazyExtendStub::$initialized);&#125; 在解析后扩展1234567891011121314151617181920212223public function testExtendIsLazyInitialized()&#123; ContainerLazyExtendStub::$initialized = false; $container = new Container; $container-&gt;bind('Illuminate\Tests\Container\ContainerLazyExtendStub'); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;extend( 'Illuminate\Tests\Container\ContainerLazyExtendStub', function ($obj, $container) &#123; $obj-&gt;init(); return $obj; &#125; ); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertTrue(ContainerLazyExtendStub::$initialized);&#125; 可以看出，无论在哪个位置，extend扩展都有lazy初始化的特点，也就是使用extend函数并不会立即起作用，而是要等到make解析才会激活。 extend与instance绑定对于instance绑定来说，暂时extend的位置需要位于instance之后才会起作用，并且会立即起作用，没有lazy的特点：123456789101112131415161718192021public function testExtendInstancesArePreserved()&#123; $container = new Container; $obj = new StdClass; $obj-&gt;foo = 'foo'; $container-&gt;instance('foo', $obj); $container-&gt;extend( 'foo', function ($obj, $container) &#123; $obj-&gt;bar = 'baz'; return $obj; &#125; ); $this-&gt;assertEquals('foo', $container-&gt;make('foo')-&gt;foo); $this-&gt;assertEquals('baz', $container-&gt;make('foo')-&gt;bar);&#125; extend绑定与rebind回调无论扩展对象是instance绑定还是bind绑定，extend都会启动rebind回调函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344public function testExtendReBindingInstance()&#123; $_SERVER['_test_rebind'] = false; $container = new Container; $container-&gt;rebinding('foo',function ()&#123; $_SERVER['_test_rebind'] = true; &#125;); $obj = new StdClass; $container-&gt;instance('foo',$obj); $container-&gt;make('foo'); $container-&gt;extend('foo', function ($obj, $container) &#123; return $obj; &#125;); $this-&gt;assertTrue($_SERVER['_test_rebind']);&#125;public function testExtendReBinding()&#123; $_SERVER['_test_rebind'] = false; $container = new Container; $container-&gt;rebinding('foo',function ()&#123; $_SERVER['_test_rebind'] = true; &#125;); $container-&gt;bind('foo',function ()&#123; $obj = new StdClass; return $obj; &#125;); $container-&gt;make('foo'); $container-&gt;extend('foo', function ($obj, $container) &#123; return $obj; &#125;); $this-&gt;assertFalse($_SERVER['_test_rebind']);&#125; contextual绑定特性contextual在绑定前 contextual绑定不仅可以与bind绑定合作，相互不干扰，还可以与instance绑定相互合作。而且instance的位置也很灵活，可以在contextual绑定前，也可以在contextual绑定后：123456789101112131415public function testContextualBindingWorksForExistingInstancedBindings()&#123; $container = new Container; $container-&gt;instance('Illuminate\Tests\Container\IContainerContractStub', new ContainerImplementationStub); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; contextual在绑定后 123456789101112131415161718public function testContextualBindingWorksForNewlyInstancedBindings()&#123; $container = new Container; $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $container-&gt;instance( 'Illuminate\Tests\Container\IContainerContractStub', new ContainerImplementationStub ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; contextual绑定与别名contextual绑定也可以在别名上进行，无论赋予别名的位置是contextual的前面还是后面：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public function testContextualBindingDoesntOverrideNonContextualResolution()&#123; $container = new Container; $container-&gt;instance('stub', new ContainerImplementationStub); $container-&gt;alias( 'stub', 'Illuminate\Tests\Container\IContainerContractStub' ); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectTwo') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectTwo')-&gt;impl ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125;public function testContextualBindingWorksOnNewAliasedBindings()&#123; $container = new Container; $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $container-&gt;bind('stub', ContainerImplementationStub::class); $container-&gt;alias( 'stub', 'Illuminate\Tests\Container\IContainerContractStub' ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; 争议 目前比较有争议的是下面的情况：1234567891011121314151617public function testContextualBindingWorksOnExistingAliasedInstances()&#123; $container = new Container; $container-&gt;alias('Illuminate\Tests\Container\IContainerContractStub', 'stub'); $container-&gt;instance('stub', new ContainerImplementationStub); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('stub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; 由于instance的特性，当别名被绑定到其他对象上时，别名stub已经失去了与Illuminate\Tests\Container\IContainerContractStub之间的关系，因此不能使用stub代替作上下文绑定。 但是另一方面：1234567891011121314151617public function testContextualBindingWorksOnBoundAlias()&#123; $container = new Container; $container-&gt;alias('Illuminate\Tests\Container\IContainerContractStub', 'stub'); $container-&gt;bind('stub', ContainerImplementationStub::class); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('stub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; 代码只是从 instance 绑定改为bind绑定，由于bind绑定只切断了别名中的alias数组的联系，并没有断绝abstractAlias数组的联系，因此这段代码却可以通过，很让人难以理解。本人在给 Taylor Otwell 提出 PR 时，作者原话为“I’m not making any of these changes to the container on a patch release.”。也许，在以后(5.5或以后)版本作者会更新这里的逻辑，我们就可以看看服务容器对别名绑定的态度了，大家也最好不要这样用。 服务容器中的闭包函数参数 服务容器中很多函数都有闭包函数，这些闭包函数可以放入特定的参数，在绑定或者解析过程中，这些参数会被服务容器自动带入各种类对象或者服务容器实例。 bind闭包参数123456789101112public function testAliasesWithArrayOfParameters()&#123; $container = new Container; $container-&gt;bind('foo', function ($app, $config) &#123; return $config; &#125;); $container-&gt;alias('foo', 'baz'); $this-&gt;assertEquals([1, 2, 3], $container-&gt;makeWith('baz', [1, 2, 3]));&#125; extend闭包参数1234567891011121314151617181920212223242526272829public function testExtendedBindings()&#123; $container = new Container; $container['foo'] = 'foo'; $container-&gt;extend('foo', function ($old, $container) &#123; return $old.'bar'; &#125;); $this-&gt;assertEquals('foobar', $container-&gt;make('foo')); $container = new Container; $container-&gt;singleton('foo', function () &#123; return (object) ['name' =&gt; 'taylor']; &#125;); $container-&gt;extend('foo', function ($old, $container) &#123; $old-&gt;age = 26; return $old; &#125;); $result = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $result-&gt;name); $this-&gt;assertEquals(26, $result-&gt;age); $this-&gt;assertSame($result, $container-&gt;make('foo'));&#125; bindmethod闭包参数1234567891011121314public function testCallWithBoundMethod()&#123; $container = new Container; $container-&gt;bindMethod('Illuminate\Tests\Container\ContainerTestCallStub@unresolvable', function ($stub, $container) &#123; $container['foo'] = 'foo'; return $stub-&gt;unresolvable('foo', 'bar'); &#125;); $result = $container-&gt;call('Illuminate\Tests\Container\ContainerTestCallStub@unresolvable'); $this-&gt;assertEquals(['foo', 'bar'], $result); $this-&gt;assertEquals('foo',$container['foo']);&#125; resolve闭包参数12345678910111213141516public function testResolvingCallbacksAreCalledForSpecificAbstracts()&#123; $container = new Container; $container-&gt;resolving('foo', function ($object，$container)&#123; return $object-&gt;name = 'taylor'; &#125;); $container-&gt;bind('foo', function () &#123; return new StdClass; &#125;); $instance = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $instance-&gt;name);&#125; rebinding闭包参数123456789101112131415161718public function testReboundListeners()&#123; $container = new Container; $container-&gt;bind('foo', function () &#123; return 'foo'; &#125;); $container-&gt;rebinding('foo', function ($container, $object) &#123; $container['bar'] = $object.'bar'; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertEquals('bar', $container['foobar']);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-Pipeline中间件处理源码分析]]></title>
    <url>%2F2020%2F05%2F13%2FLaravel-HTTP-Pipeline%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言当所有的路由都加载完毕后，就会根据请求的url来将请求分发到对应的路由上去。然而，在分发到路由之前还要经过各种中间件的计算。 Laravel利用装饰者模式来实现中间件的功能。 从原始装饰者模式到闭包装饰者 装饰者模式是设计模式的一种，主要进行对象的多次处理与过滤，是在开放-关闭原则下实现动态添加或减少功能的一种方式。下面先看一个装饰者模式的例子： 总共有两种咖啡：Decaf、Espresso，另有两种调味品：Mocha、Whip（3种设计的主要差别在于抽象方式不同）装饰模式分为3个部分：1，抽象组件 — 对应Coffee类2，具体组件 — 对应具体的咖啡，如：Decaf，Espresso3，装饰者 — 对应调味品，如：Mocha，Whip原始装饰者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public interface Coffee&#123; public double cost();&#125;public class Espresso implements Coffee&#123; public double cost() &#123; return 2.5; &#125;&#125;public class Dressing implements Coffee&#123; private Coffee coffee; public Dressing(Coffee coffee) &#123; this.coffee = coffee; &#125; public double cost() &#123; return coffee.cost(); &#125;&#125;public class Whip extends Dressing &#123; public Whip(Coffee coffee) &#123; super(coffee); &#125; public double cost() &#123; return super.cost() + 0.1; &#125;&#125;public class Mocha extends Dressing&#123; public Mocha(Coffee coffee) &#123; super(coffee); &#125; public double cost() &#123; return super.cost() + 0.5; &#125;&#125; 当我们使用装饰者模式的时候：123456789101112public class Test &#123; public static void main(String[] args) &#123; Coffee coffee = new Espresso(); coffee = new Mocha(coffee); coffee = new Mocha(coffee); coffee = new Whip(coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 我们可以看出来，装饰者模式就是利用装饰者类来对具体类不断的进行多层次的处理，首先我们创建了Espresso类，然后第一次利用Mocha装饰者对Espresso咖啡加了摩卡，第二次重复加了摩卡，第三次利用装饰者Whip对Espresso咖啡加了奶油。每次加入新的调料，装饰者都会对价格cost做一些处理（+0.1、+0.5）。 无构造函数的装饰者 我们对这个装饰者进行一些改造：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Espresso&#123; double cost; public double cost() &#123; $this-&gt; cost = 2.5; &#125;&#125;public class Dressing&#123; public double cost(Espresso $espresso) &#123; return ($espresso); &#125;&#125;public class Whip extends Dressing&#123; public double cost(Espresso $espresso) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.1; return ($espresso); &#125;&#125;public class Mocha extends Dressing&#123; public double cost(Espresso $espresso) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.5; return ($espresso); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $coffee = (new Mocha())-&gt;cost($coffee); $coffee = (new Mocha())-&gt;cost($coffee); $coffee = (new Whip())-&gt;cost($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 改造后，装饰者类通过函数cost来注入具体类caffee，而不是通过构造函数，这样做有助于自动化进行装饰处理。我们改造后发现，想要对具体类通过装饰类进行处理，需要不断的调用cost函数，如果有10个装饰操作，就要手动写10个语句，因此我们继续进行改造： 闭包装饰者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Espresso&#123; double cost; public double cost() &#123; $this-&gt; cost = 2.5; &#125;&#125;public class Dressing&#123; public double cost(Espresso $espresso, Closure $closure) &#123; return ($espresso); &#125;&#125;public class Whip extends Dressing&#123; public double cost(Espresso $espresso, Closure $closure) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.1; return $closure($espresso); &#125;&#125;public class Mocha extends Dressing&#123; public double cost(Espresso $espresso, Closure $closure) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.5; return $closure($espresso); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $fun = function($coffee，$fuc，$dressing) &#123; $dressing-&gt;cost($coffee, $fuc); &#125; $fuc0 = function($coffee) &#123; return $coffee; &#125;; $fuc1 = function($coffee) use ($fuc0, $dressing = (new Mocha()，$fun)) &#123; return $fun($coffee, $fuc0, $dressing); &#125; $fuc2 = function($coffee) use ($fuc1, $dressing = (new Mocha()，$fun)) &#123; return $fuc($coffee, $fun1, $dressing); &#125; $fuc3 = function($coffee) use ($fuc2, $dressing = (new Whip()，$fun)) &#123; return $fuc($coffee, $fun2, $dressing); &#125; $coffee = $fun3($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 在这次改造中，我们使用了闭包函数，这样做的目的在于，我们只需要最后一句$fun3($coffee) ,就可以启动整个装饰链条。 闭包装饰者的抽象化 然而这种改造还不够深入，因为我们还可以把$fuc1、$fuc2、$fuc3继续抽象化为一个闭包函数，这个闭包函数仅仅是参数$fuc、$dressing每次不同，$coffee相同，因此改造如下：1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $fun = function($coffee) use ($fuc，$dressing) &#123; $dressing-&gt;cost($coffee, $fuc); &#125; $fuc = function($fuc，$dressing) use ($fun) &#123; return $fun; &#125;; $fuc0 = function($coffee) &#123; return $coffee; &#125;; $fuc1 = $fuc($fuc0, (new Mocha()); $fuc2 = $fuc($fuc1, (new Mocha()); $fuc3 = $fuc($fuc2, (new Whip()); $coffee = $fun3($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 这次，我们把之前的闭包分为两个部分，$fun负责具体类的参数传递，$fuc负责装饰者和闭包函数的参数传递。在最后一句$fun3，只需要传递一个具体类，就可以启动整个装饰链条。 闭包装饰者的自动化 到这里，我们还有一件事没有完成，那就是$fuc1、$fuc2、$fuc3这些闭包的构建还是手动的，我们需要将这个过程改为自动的：1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $fun = function($coffee) use ($fuc，$dressing) &#123; $dressing-&gt;cost($coffee, $fuc); &#125; $fuc = function($fuc，$dressing) use ($fun) &#123; return $fun; &#125;; $fuc0 = function($coffee) &#123; return $coffee; &#125;; $fucn = array_reduce( [(new Mocha(),(new Mocha(),(new Whip()], $fuc, $fuc0 ); $coffee = $fucn($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; Laravel的闭包装饰者——Pipeline 上一章我们说到了路由的注册启动与加载过程，这个过程由bootstrap()完成。当所有的路由加载完毕后，就要进行各种中间件的处理了：123456789101112131415161718protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125;public function shouldSkipMiddleware()&#123; return $this-&gt;bound('middleware.disable') &amp;&amp; $this-&gt;make('middleware.disable') === true;&#125; Laravel的中间件处理由Pipeline来完成，它是一个闭包装饰者模式，其中request是具体类，相当于我们上面的caffee类；middleware中间件是装饰者类，相当于上面的dressing类；我们先看看这个类内部的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Pipeline implements PipelineContract&#123; public function __construct(Container $container = null) &#123; $this-&gt;container = $container; &#125; public function send($passable) &#123; $this-&gt;passable = $passable; return $this; &#125; public function through($pipes) &#123; $this-&gt;pipes = is_array($pipes) ? $pipes : func_get_args(); return $this; &#125; public function then(Closure $destination) &#123; $pipeline = array_reduce( array_reverse($this-&gt;pipes), $this-&gt;carry(), $this-&gt;prepareDestination($destination) ); return $pipeline($this-&gt;passable); &#125; protected function prepareDestination(Closure $destination) &#123; return function ($passable) use ($destination) &#123; return $destination($passable); &#125;; &#125; protected function carry() &#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; list($name, $parameters) = $this-&gt;parsePipeString($pipe); $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; $parameters = [$passable, $stack]; &#125; return $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters); &#125;; &#125;; &#125;&#125; pipeline 的构造和我们上面所讲的闭包装饰者相同，我们着重来看carry()函数的代码：123function ($stack, $pipe) &#123;...&#125; 最外层的闭包相当于上个章节的 $fuc ,123function ($passable) use ($stack, $pipe) &#123;...&#125; 里面的这一层比闭包型党与上个章节的$fun，prepareDestination这个函数相当于上面的$fuc0 ,123456789101112131415if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack);&#125; elseif (! is_object($pipe)) &#123; list($name, $parameters) = $this-&gt;parsePipeString($pipe); $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters);&#125; else &#123; $parameters = [$passable, $stack];&#125;return $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters); 这一部分相当于上个章节的$dressing-&gt;cost($coffee, $fuc);这部分主要解析中间件handle()函数的参数：12345678910111213141516public function via($method)&#123; $this-&gt;method = $method; return $this;&#125;protected function parsePipeString($pipe)&#123; list($name, $parameters) = array_pad(explode(':', $pipe, 2),2, []); if (is_string($parameters)) &#123; $parameters = explode(',', $parameters); &#125; return [$name, $parameters];&#125; 这样，Laravel就实现了中间件对request的层层处理。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Queue]]></title>
    <url>%2F2020%2F05%2F12%2FLaravel-Queue%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 文件目录 Opis Closure简介与安装Opis Closure是一个库，旨在通过提供使所有闭包可序列化的包装器，来克服PHP在闭包序列化方面的限制。 1composer require opis/closure 序列化闭包如果你曾经使用过闭包，那么你可能知道闭包不可序列化。尝试序列化闭包将导致异常： 1Fatal error: Uncaught exception &apos;Exception&apos; with message &apos;Serialization of &apos;Closure&apos; is not allowed&apos; 克服此问题的解决方案是将闭包包装到一个Opis\Closure\SerializableClosure对象中，然后使用标准的serialize序列化包装对象。 1234567891011use Opis\Closure\SerializableClosure;// Recursive factorial closure$factorial = function ($n) use (&amp;$factorial) &#123; return $n &lt;= 1 ? 1 : $factorial($n - 1) * $n;&#125;;// Wrap the closure$wrapper = new SerializableClosure($factorial);// Now it can be serialized$serialized = serialize($wrapper); 反序列化闭包使用标准unserialize函数可以完成闭包反序列化。一旦包装器反序列化，就可以直接调用包装器，也可以通过调用getClosure方法提取序列化的闭包。 12345678910// Unserialize the closure$wrapper = unserialize($serialized);// You can directly invoke the wrapper...echo $wrapper(5); //&gt; 120// Or, the recommended way, extract the closure object$closure = $wrapper-&gt;getClosure();echo $closure(5); //&gt; 120 由于Opis Closure在序列化/反序列化过程中不使用eval的事实，因此所有的闭包都可以无限制地序列化和非序列化。 123456789// Once again, but this time using the previously unserialized closure$wrapper = new SerializableClosure($closure);$serialized = serialize($wrapper);$wrapper = unserialize($serialized);$closure = $wrapper-&gt;getClosure();// Now watch this...echo $closure(5); //&gt; 120// It worked! 序列化/反序列化任意对象Opis Closure允许您借助Opis\Closure\serialize函数来序列化任意对象。通过使用Opis\Closure\unserialize函数可以进行反序列化。 1234567891011121314151617181920212223use function Opis\Closure\&#123;serialize as s, unserialize as u&#125;class A&#123; private $closure; public function __construct() &#123; $this-&gt;closure = function()&#123; echo 'It works!'; &#125;; &#125; public function test() &#123; //call closure ($this-&gt;closure)(); &#125;&#125;$obj = new A();u(s($obj))-&gt;test(); // It works 源码Job Illuminate\Queue\Jobs.php 抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347namespace Illuminate\Queue\Jobs;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Queue\Events\JobFailed;use Illuminate\Queue\ManuallyFailedException;use Illuminate\Support\InteractsWithTime;abstract class Job&#123; use InteractsWithTime; /** * The job handler instance. * * @var mixed */ protected $instance; /** * The IoC container instance. * * @var \Illuminate\Container\Container */ protected $container; /** * Indicates if the job has been deleted. * * @var bool */ protected $deleted = false; /** * Indicates if the job has been released. * * @var bool */ protected $released = false; /** * Indicates if the job has failed. * * @var bool */ protected $failed = false; /** * The name of the connection the job belongs to. * * @var string */ protected $connectionName; /** * The name of the queue the job belongs to. * * @var string */ protected $queue; /** * Get the job identifier. * * @return string */ abstract public function getJobId(); /** * Get the raw body of the job. * * @return string */ abstract public function getRawBody(); /** * Get the UUID of the job. * * @return string|null */ public function uuid() &#123; return $this-&gt;payload()['uuid'] ?? null; &#125; /** * Fire the job. * * @return void */ public function fire() &#123; $payload = $this-&gt;payload(); [$class, $method] = JobName::parse($payload['job']); ($this-&gt;instance = $this-&gt;resolve($class))-&gt;&#123;$method&#125;($this, $payload['data']); &#125; /** * Delete the job from the queue. * * @return void */ public function delete() &#123; $this-&gt;deleted = true; &#125; /** * Determine if the job has been deleted. * * @return bool */ public function isDeleted() &#123; return $this-&gt;deleted; &#125; /** * Release the job back into the queue. * * @param int $delay * @return void */ public function release($delay = 0) &#123; $this-&gt;released = true; &#125; /** * Determine if the job was released back into the queue. * * @return bool */ public function isReleased() &#123; return $this-&gt;released; &#125; /** * Determine if the job has been deleted or released. * * @return bool */ public function isDeletedOrReleased() &#123; return $this-&gt;isDeleted() || $this-&gt;isReleased(); &#125; /** * Determine if the job has been marked as a failure. * * @return bool */ public function hasFailed() &#123; return $this-&gt;failed; &#125; /** * Mark the job as "failed". * * @return void */ public function markAsFailed() &#123; $this-&gt;failed = true; &#125; /** * Delete the job, call the "failed" method, and raise the failed job event. * * @param \Throwable|null $e * @return void */ public function fail($e = null) &#123; $this-&gt;markAsFailed(); if ($this-&gt;isDeleted()) &#123; return; &#125; try &#123; // If the job has failed, we will delete it, call the "failed" method and then call // an event indicating the job has failed so it can be logged if needed. This is // to allow every developer to better keep monitor of their failed queue jobs. $this-&gt;delete(); $this-&gt;failed($e); &#125; finally &#123; $this-&gt;resolve(Dispatcher::class)-&gt;dispatch(new JobFailed( $this-&gt;connectionName, $this, $e ?: new ManuallyFailedException )); &#125; &#125; /** * Process an exception that caused the job to fail. * * @param \Throwable|null $e * @return void */ protected function failed($e) &#123; $payload = $this-&gt;payload(); [$class, $method] = JobName::parse($payload['job']); if (method_exists($this-&gt;instance = $this-&gt;resolve($class), 'failed')) &#123; $this-&gt;instance-&gt;failed($payload['data'], $e); &#125; &#125; /** * Resolve the given class. * * @param string $class * @return mixed */ protected function resolve($class) &#123; return $this-&gt;container-&gt;make($class); &#125; /** * Get the resolved job handler instance. * * @return mixed */ public function getResolvedJob() &#123; return $this-&gt;instance; &#125; /** * Get the decoded body of the job. * * @return array */ public function payload() &#123; return json_decode($this-&gt;getRawBody(), true); &#125; /** * Get the number of times to attempt a job. * * @return int|null */ public function maxTries() &#123; return $this-&gt;payload()['maxTries'] ?? null; &#125; /** * Get the number of times to attempt a job after an exception. * * @return int|null */ public function maxExceptions() &#123; return $this-&gt;payload()['maxExceptions'] ?? null; &#125; /** * Get the number of seconds to delay a failed job before retrying it. * * @return int|null */ public function delaySeconds() &#123; return $this-&gt;payload()['delay'] ?? null; &#125; /** * Get the number of seconds the job can run. * * @return int|null */ public function timeout() &#123; return $this-&gt;payload()['timeout'] ?? null; &#125; /** * Get the timestamp indicating when the job should timeout. * * @return int|null */ public function timeoutAt() &#123; return $this-&gt;payload()['timeoutAt'] ?? null; &#125; /** * Get the name of the queued job class. * * @return string */ public function getName() &#123; return $this-&gt;payload()['job']; &#125; /** * Get the resolved name of the queued job class. * * Resolves the name of "wrapped" jobs such as class-based handlers. * * @return string */ public function resolveName() &#123; return JobName::resolve($this-&gt;getName(), $this-&gt;payload()); &#125; /** * Get the name of the connection the job belongs to. * * @return string */ public function getConnectionName() &#123; return $this-&gt;connectionName; &#125; /** * Get the name of the queue the job belongs to. * * @return string */ public function getQueue() &#123; return $this-&gt;queue; &#125; /** * Get the service container instance. * * @return \Illuminate\Container\Container */ public function getContainer() &#123; return $this-&gt;container; &#125;&#125; Illuminate\Queue\Jobs\RedisJob.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?phpnamespace Illuminate\Queue\Jobs;use Illuminate\Container\Container;use Illuminate\Contracts\Queue\Job as JobContract;use Illuminate\Queue\RedisQueue;class RedisJob extends Job implements JobContract&#123; /** * The Redis queue instance. * * @var \Illuminate\Queue\RedisQueue */ protected $redis; /** * The Redis raw job payload. * * @var string */ protected $job; /** * The JSON decoded version of "$job". * * @var array */ protected $decoded; /** * The Redis job payload inside the reserved queue. * * @var string */ protected $reserved; /** * Create a new job instance. * * @param \Illuminate\Container\Container $container * @param \Illuminate\Queue\RedisQueue $redis * @param string $job * @param string $reserved * @param string $connectionName * @param string $queue * @return void */ public function __construct(Container $container, RedisQueue $redis, $job, $reserved, $connectionName, $queue) &#123; // The $job variable is the original job JSON as it existed in the ready queue while // the $reserved variable is the raw JSON in the reserved queue. The exact format // of the reserved job is required in order for us to properly delete its data. $this-&gt;job = $job; $this-&gt;redis = $redis; $this-&gt;queue = $queue; $this-&gt;reserved = $reserved; $this-&gt;container = $container; $this-&gt;connectionName = $connectionName; $this-&gt;decoded = $this-&gt;payload(); &#125; /** * Get the raw body string for the job. * * @return string */ public function getRawBody() &#123; return $this-&gt;job; &#125; /** * Delete the job from the queue. * * @return void */ public function delete() &#123; parent::delete(); $this-&gt;redis-&gt;deleteReserved($this-&gt;queue, $this); &#125; /** * Release the job back into the queue. * * @param int $delay * @return void */ public function release($delay = 0) &#123; parent::release($delay); $this-&gt;redis-&gt;deleteAndRelease($this-&gt;queue, $this, $delay); &#125; /** * Get the number of times the job has been attempted. * * @return int */ public function attempts() &#123; return ($this-&gt;decoded['attempts'] ?? null) + 1; &#125; /** * Get the job identifier. * * @return string|null */ public function getJobId() &#123; return $this-&gt;decoded['id'] ?? null; &#125; /** * Get the underlying Redis factory implementation. * * @return \Illuminate\Queue\RedisQueue */ public function getRedisQueue() &#123; return $this-&gt;redis; &#125; /** * Get the underlying reserved Redis job. * * @return string */ public function getReservedJob() &#123; return $this-&gt;reserved; &#125;&#125; Queue Illuminate\Contracts\Queue\Queue.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?phpnamespace Illuminate\Contracts\Queue;interface Queue&#123; /** * Get the size of the queue. * * @param string|null $queue * @return int */ public function size($queue = null); /** * Push a new job onto the queue. * * @param string|object $job * @param mixed $data * @param string|null $queue * @return mixed */ public function push($job, $data = '', $queue = null); /** * Push a new job onto the queue. * * @param string $queue * @param string|object $job * @param mixed $data * @return mixed */ public function pushOn($queue, $job, $data = ''); /** * Push a raw payload onto the queue. * * @param string $payload * @param string|null $queue * @param array $options * @return mixed */ public function pushRaw($payload, $queue = null, array $options = []); /** * Push a new job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param string|object $job * @param mixed $data * @param string|null $queue * @return mixed */ public function later($delay, $job, $data = '', $queue = null); /** * Push a new job onto the queue after a delay. * * @param string $queue * @param \DateTimeInterface|\DateInterval|int $delay * @param string|object $job * @param mixed $data * @return mixed */ public function laterOn($queue, $delay, $job, $data = ''); /** * Push an array of jobs onto the queue. * * @param array $jobs * @param mixed $data * @param string|null $queue * @return mixed */ public function bulk($jobs, $data = '', $queue = null); /** * Pop the next job off of the queue. * * @param string|null $queue * @return \Illuminate\Contracts\Queue\Job|null */ public function pop($queue = null); /** * Get the connection name for the queue. * * @return string */ public function getConnectionName(); /** * Set the connection name for the queue. * * @param string $name * @return $this */ public function setConnectionName($name);&#125; Illuminate\Queue\SerializableClosure.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Illuminate\Queue;use Opis\Closure\SerializableClosure as OpisSerializableClosure;class SerializableClosure extends OpisSerializableClosure&#123; use SerializesAndRestoresModelIdentifiers; /** * Transform the use variables before serialization. * * @param array $data The Closure's use variables * @return array */ protected function transformUseVariables($data) &#123; foreach ($data as $key =&gt; $value) &#123; $data[$key] = $this-&gt;getSerializedPropertyValue($value); &#125; return $data; &#125; /** * Resolve the use variables after unserialization. * * @param array $data The Closure's transformed use variables * @return array */ protected function resolveUseVariables($data) &#123; foreach ($data as $key =&gt; $value) &#123; $data[$key] = $this-&gt;getRestoredPropertyValue($value); &#125; return $data; &#125;&#125; Illuminate\Queue\Queue.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290&lt;?phpnamespace Illuminate\Queue;use Closure;use DateTimeInterface;use Illuminate\Container\Container;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Str;abstract class Queue&#123; use InteractsWithTime; /** * The IoC container instance. * * @var \Illuminate\Container\Container */ protected $container; /** * The connection name for the queue. * * @var string */ protected $connectionName; /** * The create payload callbacks. * * @var callable[] */ protected static $createPayloadCallbacks = []; /** * Push a new job onto the queue. * * @param string $queue * @param string $job * @param mixed $data * @return mixed */ public function pushOn($queue, $job, $data = '') &#123; return $this-&gt;push($job, $data, $queue); &#125; /** * Push a new job onto the queue after a delay. * * @param string $queue * @param \DateTimeInterface|\DateInterval|int $delay * @param string $job * @param mixed $data * @return mixed */ public function laterOn($queue, $delay, $job, $data = '') &#123; return $this-&gt;later($delay, $job, $data, $queue); &#125; /** * Push an array of jobs onto the queue. * * @param array $jobs * @param mixed $data * @param string|null $queue * @return void */ public function bulk($jobs, $data = '', $queue = null) &#123; foreach ((array) $jobs as $job) &#123; $this-&gt;push($job, $data, $queue); &#125; &#125; /** * Create a payload string from the given job and data. * * @param \Closure|string|object $job * @param string $queue * @param mixed $data * @return string * * @throws \Illuminate\Queue\InvalidPayloadException */ protected function createPayload($job, $queue, $data = '') &#123; if ($job instanceof Closure) &#123; $job = CallQueuedClosure::create($job); &#125; $payload = json_encode($this-&gt;createPayloadArray($job, $queue, $data)); if (JSON_ERROR_NONE !== json_last_error()) &#123; throw new InvalidPayloadException( 'Unable to JSON encode payload. Error code: '.json_last_error() ); &#125; return $payload; &#125; /** * Create a payload array from the given job and data. * * @param string|object $job * @param string $queue * @param mixed $data * @return array */ protected function createPayloadArray($job, $queue, $data = '') &#123; return is_object($job) ? $this-&gt;createObjectPayload($job, $queue) : $this-&gt;createStringPayload($job, $queue, $data); &#125; /** * Create a payload for an object-based queue handler. * * @param object $job * @param string $queue * @return array */ protected function createObjectPayload($job, $queue) &#123; $payload = $this-&gt;withCreatePayloadHooks($queue, [ 'uuid' =&gt; (string) Str::uuid(), 'displayName' =&gt; $this-&gt;getDisplayName($job), 'job' =&gt; 'Illuminate\Queue\CallQueuedHandler@call', 'maxTries' =&gt; $job-&gt;tries ?? null, 'maxExceptions' =&gt; $job-&gt;maxExceptions ?? null, 'delay' =&gt; $this-&gt;getJobRetryDelay($job), 'timeout' =&gt; $job-&gt;timeout ?? null, 'timeoutAt' =&gt; $this-&gt;getJobExpiration($job), 'data' =&gt; [ 'commandName' =&gt; $job, 'command' =&gt; $job, ], ]); return array_merge($payload, [ 'data' =&gt; [ 'commandName' =&gt; get_class($job), 'command' =&gt; serialize(clone $job), ], ]); &#125; /** * Get the display name for the given job. * * @param object $job * @return string */ protected function getDisplayName($job) &#123; return method_exists($job, 'displayName') ? $job-&gt;displayName() : get_class($job); &#125; /** * Get the retry delay for an object-based queue handler. * * @param mixed $job * @return mixed */ public function getJobRetryDelay($job) &#123; if (! method_exists($job, 'retryAfter') &amp;&amp; ! isset($job-&gt;retryAfter)) &#123; return; &#125; $delay = $job-&gt;retryAfter ?? $job-&gt;retryAfter(); return $delay instanceof DateTimeInterface ? $this-&gt;secondsUntil($delay) : $delay; &#125; /** * Get the expiration timestamp for an object-based queue handler. * * @param mixed $job * @return mixed */ public function getJobExpiration($job) &#123; if (! method_exists($job, 'retryUntil') &amp;&amp; ! isset($job-&gt;timeoutAt)) &#123; return; &#125; $expiration = $job-&gt;timeoutAt ?? $job-&gt;retryUntil(); return $expiration instanceof DateTimeInterface ? $expiration-&gt;getTimestamp() : $expiration; &#125; /** * Create a typical, string based queue payload array. * * @param string $job * @param string $queue * @param mixed $data * @return array */ protected function createStringPayload($job, $queue, $data) &#123; return $this-&gt;withCreatePayloadHooks($queue, [ 'uuid' =&gt; (string) Str::uuid(), 'displayName' =&gt; is_string($job) ? explode('@', $job)[0] : null, 'job' =&gt; $job, 'maxTries' =&gt; null, 'maxExceptions' =&gt; null, 'delay' =&gt; null, 'timeout' =&gt; null, 'data' =&gt; $data, ]); &#125; /** * Register a callback to be executed when creating job payloads. * * @param callable $callback * @return void */ public static function createPayloadUsing($callback) &#123; if (is_null($callback)) &#123; static::$createPayloadCallbacks = []; &#125; else &#123; static::$createPayloadCallbacks[] = $callback; &#125; &#125; /** * Create the given payload using any registered payload hooks. * * @param string $queue * @param array $payload * @return array */ protected function withCreatePayloadHooks($queue, array $payload) &#123; if (! empty(static::$createPayloadCallbacks)) &#123; foreach (static::$createPayloadCallbacks as $callback) &#123; $payload = array_merge($payload, call_user_func( $callback, $this-&gt;getConnectionName(), $queue, $payload )); &#125; &#125; return $payload; &#125; /** * Get the connection name for the queue. * * @return string */ public function getConnectionName() &#123; return $this-&gt;connectionName; &#125; /** * Set the connection name for the queue. * * @param string $name * @return $this */ public function setConnectionName($name) &#123; $this-&gt;connectionName = $name; return $this; &#125; /** * Set the IoC container instance. * * @param \Illuminate\Container\Container $container * @return void */ public function setContainer(Container $container) &#123; $this-&gt;container = $container; &#125;&#125; Illuminate\Queue\RedisQueue.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310&lt;?phpnamespace Illuminate\Queue;use Illuminate\Contracts\Queue\Queue as QueueContract;use Illuminate\Contracts\Redis\Factory as Redis;use Illuminate\Queue\Jobs\RedisJob;use Illuminate\Support\Str;class RedisQueue extends Queue implements QueueContract&#123; /** * The Redis factory implementation. * * @var \Illuminate\Contracts\Redis\Factory */ protected $redis; /** * The connection name. * * @var string */ protected $connection; /** * The name of the default queue. * * @var string */ protected $default; /** * The expiration time of a job. * * @var int|null */ protected $retryAfter = 60; /** * The maximum number of seconds to block for a job. * * @var int|null */ protected $blockFor = null; /** * Create a new Redis queue instance. * * @param \Illuminate\Contracts\Redis\Factory $redis * @param string $default * @param string|null $connection * @param int $retryAfter * @param int|null $blockFor * @return void */ public function __construct(Redis $redis, $default = 'default', $connection = null, $retryAfter = 60, $blockFor = null) &#123; $this-&gt;redis = $redis; $this-&gt;default = $default; $this-&gt;blockFor = $blockFor; $this-&gt;connection = $connection; $this-&gt;retryAfter = $retryAfter; &#125; /** * Get the size of the queue. * * @param string|null $queue * @return int */ public function size($queue = null) &#123; $queue = $this-&gt;getQueue($queue); return $this-&gt;getConnection()-&gt;eval( LuaScripts::size(), 3, $queue, $queue.':delayed', $queue.':reserved' ); &#125; /** * Push a new job onto the queue. * * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function push($job, $data = '', $queue = null) &#123; return $this-&gt;pushRaw($this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125; /** * Push a raw payload onto the queue. * * @param string $payload * @param string|null $queue * @param array $options * @return mixed */ public function pushRaw($payload, $queue = null, array $options = []) &#123; $this-&gt;getConnection()-&gt;eval( LuaScripts::push(), 2, $this-&gt;getQueue($queue), $this-&gt;getQueue($queue).':notify', $payload ); return json_decode($payload, true)['id'] ?? null; &#125; /** * Push a new job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function later($delay, $job, $data = '', $queue = null) &#123; return $this-&gt;laterRaw($delay, $this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125; /** * Push a raw job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param string $payload * @param string|null $queue * @return mixed */ protected function laterRaw($delay, $payload, $queue = null) &#123; $this-&gt;getConnection()-&gt;zadd( $this-&gt;getQueue($queue).':delayed', $this-&gt;availableAt($delay), $payload ); return json_decode($payload, true)['id'] ?? null; &#125; /** * Create a payload string from the given job and data. * * @param string $job * @param string $queue * @param mixed $data * @return array */ protected function createPayloadArray($job, $queue, $data = '') &#123; return array_merge(parent::createPayloadArray($job, $queue, $data), [ 'id' =&gt; $this-&gt;getRandomId(), 'attempts' =&gt; 0, ]); &#125; /** * Pop the next job off of the queue. * * @param string|null $queue * @return \Illuminate\Contracts\Queue\Job|null */ public function pop($queue = null) &#123; $this-&gt;migrate($prefixed = $this-&gt;getQueue($queue)); if (empty($nextJob = $this-&gt;retrieveNextJob($prefixed))) &#123; return; &#125; [$job, $reserved] = $nextJob; if ($reserved) &#123; return new RedisJob( $this-&gt;container, $this, $job, $reserved, $this-&gt;connectionName, $queue ?: $this-&gt;default ); &#125; &#125; /** * Migrate any delayed or expired jobs onto the primary queue. * * @param string $queue * @return void */ protected function migrate($queue) &#123; $this-&gt;migrateExpiredJobs($queue.':delayed', $queue); if (! is_null($this-&gt;retryAfter)) &#123; $this-&gt;migrateExpiredJobs($queue.':reserved', $queue); &#125; &#125; /** * Migrate the delayed jobs that are ready to the regular queue. * * @param string $from * @param string $to * @return array */ public function migrateExpiredJobs($from, $to) &#123; return $this-&gt;getConnection()-&gt;eval( LuaScripts::migrateExpiredJobs(), 3, $from, $to, $to.':notify', $this-&gt;currentTime() ); &#125; /** * Retrieve the next job from the queue. * * @param string $queue * @param bool $block * @return array */ protected function retrieveNextJob($queue, $block = true) &#123; $nextJob = $this-&gt;getConnection()-&gt;eval( LuaScripts::pop(), 3, $queue, $queue.':reserved', $queue.':notify', $this-&gt;availableAt($this-&gt;retryAfter) ); if (empty($nextJob)) &#123; return [null, null]; &#125; [$job, $reserved] = $nextJob; if (! $job &amp;&amp; ! is_null($this-&gt;blockFor) &amp;&amp; $block &amp;&amp; $this-&gt;getConnection()-&gt;blpop([$queue.':notify'], $this-&gt;blockFor)) &#123; return $this-&gt;retrieveNextJob($queue, false); &#125; return [$job, $reserved]; &#125; /** * Delete a reserved job from the queue. * * @param string $queue * @param \Illuminate\Queue\Jobs\RedisJob $job * @return void */ public function deleteReserved($queue, $job) &#123; $this-&gt;getConnection()-&gt;zrem($this-&gt;getQueue($queue).':reserved', $job-&gt;getReservedJob()); &#125; /** * Delete a reserved job from the reserved queue and release it. * * @param string $queue * @param \Illuminate\Queue\Jobs\RedisJob $job * @param int $delay * @return void */ public function deleteAndRelease($queue, $job, $delay) &#123; $queue = $this-&gt;getQueue($queue); $this-&gt;getConnection()-&gt;eval( LuaScripts::release(), 2, $queue.':delayed', $queue.':reserved', $job-&gt;getReservedJob(), $this-&gt;availableAt($delay) ); &#125; /** * Get a random ID string. * * @return string */ protected function getRandomId() &#123; return Str::random(32); &#125; /** * Get the queue or return the default. * * @param string|null $queue * @return string */ public function getQueue($queue) &#123; return 'queues:'.($queue ?: $this-&gt;default); &#125; /** * Get the connection for the queue. * * @return \Illuminate\Redis\Connections\Connection */ public function getConnection() &#123; return $this-&gt;redis-&gt;connection($this-&gt;connection); &#125; /** * Get the underlying Redis instance. * * @return \Illuminate\Contracts\Redis\Factory */ public function getRedis() &#123; return $this-&gt;redis; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Queue-消息队列任务处理器源码剖析]]></title>
    <url>%2F2020%2F05%2F12%2FLaravel-Queue-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 运行队列处理器队列处理器的设置Laravel包含一个队列处理器，当新任务被推到队列中时它能处理这些任务。你可以通过queue:work命令来运行处理器。要注意，一旦queue:work命令开始，它将一直运行，直到你手动停止或者你关闭控制台：1php artisan queue:work 可以指定队列处理器所使用的连接。 1php artisan queue:work redis 可以自定义队列处理器，方式是处理给定连接的特定队列。 1php artisan queue:work redis --queue=emails 可以使用--once选项来指定仅对队列中的单一任务进行处理： 1php artisan queue:work --once 如果一个任务失败了，会被放入延时队列中去，--delay选项可以设置失败任务的延时时间： 1php artisan queue:work --delay=2 如果想要限制一个任务的内存，可以使用--memory : 1php artisan queue:work --memory=128 当队列需要处理任务时，进程将继续处理任务，它们之间没有延迟。但是，如果没有新的工作可用，--sleep参数决定了工作进程将「睡眠」多长时间： 1php artisan queue:work --sleep=3 可以指定Laravel队列处理器最多执行多长时间后就应该被关闭掉： 1php artisan queue:work --timeout=60 可以指定Laravel队列处理器失败任务重试的次数： 1php artisan queue:work --tries=60 可以看出来，队列处理器的设置大多数都可以由任务类进行设置，但是其中三个sleep、delay、memory只能由artisan来设置。 WorkCommand命令行启动任务处理器进程的命令行模式会调用Illuminate\Queue\Console\WorkCommand，这个类在初始化的时候依赖注入了Illuminate\Queue\Worker：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class WorkCommand extends Command&#123; /** * The console command name. * * @var string */ protected $signature = 'queue:work &#123;connection? : The name of the queue connection to work&#125; &#123;--queue= : The names of the queues to work&#125; &#123;--daemon : Run the worker in daemon mode (Deprecated)&#125; &#123;--once : Only process the next job on the queue&#125; &#123;--stop-when-empty : Stop when the queue is empty&#125; &#123;--delay=0 : The number of seconds to delay failed jobs&#125; &#123;--force : Force the worker to run even in maintenance mode&#125; &#123;--memory=128 : The memory limit in megabytes&#125; &#123;--sleep=3 : Number of seconds to sleep when no job is available&#125; &#123;--timeout=60 : The number of seconds a child process can run&#125; &#123;--tries=1 : Number of times to attempt a job before logging it failed&#125;'; /** * Create a new queue work command. * * @param \Illuminate\Queue\Worker $worker * @param \Illuminate\Contracts\Cache\Repository $cache * @return void */ public function __construct(Worker $worker, Cache $cache) &#123; parent::__construct(); $this-&gt;cache = $cache; $this-&gt;worker = $worker; &#125; /** * Execute the console command. * * @return void */ public function handle() &#123; if ($this-&gt;downForMaintenance() &amp;&amp; $this-&gt;option('once')) &#123; return $this-&gt;worker-&gt;sleep($this-&gt;option('sleep')); &#125; // 我们将侦听已处理的事件和失败的事件，以便在处理作业时将信息写入控制台， // 这将使开发人员可以观察到队列中正在处理哪些作业，并了解其进度。 $this-&gt;listenForEvents(); $connection = $this-&gt;argument('connection') ?: $this-&gt;laravel['config']['queue.default']; // 我们需要为应用程序的队列配置文件中设置的连接获取正确的队列。 // 我们将基于为当前正在执行的队列操作运行的设置连接来拉它。 $queue = $this-&gt;getQueue($connection); $this-&gt;runWorker( $connection, $queue ); &#125;&#125; 任务处理器启动后，会运行handle函数，在执行任务之前，程序首先会注册监听事件，主要监听任务完成与任务失败的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Listen for the queue events in order to update the console output. * * @return void */protected function listenForEvents()&#123; $this-&gt;laravel['events']-&gt;listen(JobProcessing::class, function ($event) &#123; $this-&gt;writeOutput($event-&gt;job, 'starting'); &#125;); $this-&gt;laravel['events']-&gt;listen(JobProcessed::class, function ($event) &#123; $this-&gt;writeOutput($event-&gt;job, 'success'); &#125;); $this-&gt;laravel['events']-&gt;listen(JobFailed::class, function ($event) &#123; $this-&gt;writeOutput($event-&gt;job, 'failed'); $this-&gt;logFailedJob($event); &#125;);&#125;/** * Write the status output for the queue worker. * * @param \Illuminate\Contracts\Queue\Job $job * @param string $status * @return void */protected function writeOutput(Job $job, $status)&#123; switch ($status) &#123; case 'starting': return $this-&gt;writeStatus($job, 'Processing', 'comment'); case 'success': return $this-&gt;writeStatus($job, 'Processed', 'info'); case 'failed': return $this-&gt;writeStatus($job, 'Failed', 'error'); &#125;&#125;/** * Format the status output for the queue worker. * * @param \Illuminate\Contracts\Queue\Job $job * @param string $status * @param string $type * @return void */protected function writeStatus(Job $job, $status, $type)&#123; $this-&gt;output-&gt;writeln(sprintf( "&lt;&#123;$type&#125;&gt;[%s][%s] %s&lt;/&#123;$type&#125;&gt; %s", Carbon::now()-&gt;format('Y-m-d H:i:s'), $job-&gt;getJobId(), str_pad("&#123;$status&#125;:", 11), $job-&gt;resolveName() ));&#125;/** * Store a failed job event. * * @param \Illuminate\Queue\Events\JobFailed $event * @return void */protected function logFailedJob(JobFailed $event)&#123; $this-&gt;laravel['queue.failer']-&gt;log( $event-&gt;connectionName, $event-&gt;job-&gt;getQueue(), $event-&gt;job-&gt;getRawBody(), $event-&gt;exception );&#125; 启动任务管理器runWorker，该函数默认会调用Illuminate\Queue\Worker的daemon函数，只有在命令中强制--once参数的时候，才会执行runNestJob函数：123456789101112131415/** * Run the worker instance. * * @param string $connection * @param string $queue * @return array */protected function runWorker($connection, $queue)&#123; $this-&gt;worker-&gt;setCache($this-&gt;cache); return $this-&gt;worker-&gt;&#123;$this-&gt;option('once') ? 'runNextJob' : 'daemon'&#125;( $connection, $queue, $this-&gt;gatherWorkerOptions() );&#125; Worker任务调度我们接下来接着看daemon函数： Illuminate\Queue\Worker.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Listen to the given queue in a loop. * * @param string $connectionName * @param string $queue * @param \Illuminate\Queue\WorkerOptions $options * @return void */public function daemon($connectionName, $queue, WorkerOptions $options)&#123; if ($this-&gt;supportsAsyncSignals()) &#123; $this-&gt;listenForSignals(); &#125; $lastRestart = $this-&gt;getTimestampOfLastQueueRestart(); while (true) &#123; // Before reserving any jobs, we will make sure this queue is not paused and // if it is we will just pause this worker for a given amount of time and // make sure we do not need to kill this worker process off completely. if (! $this-&gt;daemonShouldRun($options, $connectionName, $queue)) &#123; $this-&gt;pauseWorker($options, $lastRestart); continue; &#125; // First, we will attempt to get the next job off of the queue. We will also // register the timeout handler and reset the alarm for this job so it is // not stuck in a frozen state forever. Then, we can fire off this job. $job = $this-&gt;getNextJob( $this-&gt;manager-&gt;connection($connectionName), $queue ); if ($this-&gt;supportsAsyncSignals()) &#123; $this-&gt;registerTimeoutHandler($job, $options); &#125; // If the daemon should run (not in maintenance mode, etc.), then we can run // fire off this job for processing. Otherwise, we will need to sleep the // worker so no more jobs are processed until they should be processed. if ($job) &#123; $this-&gt;runJob($job, $connectionName, $options); &#125; else &#123; $this-&gt;sleep($options-&gt;sleep); &#125; if ($this-&gt;supportsAsyncSignals()) &#123; $this-&gt;resetTimeoutHandler(); &#125; // Finally, we will check to see if we have exceeded our memory limits or if // the queue should restart based on other indications. If so, we'll stop // this worker and let whatever is "monitoring" it restart the process. $this-&gt;stopIfNecessary($options, $lastRestart, $job); &#125;&#125; 信号处理listenForSignals函数用于PHP 7.1版本以上，用于脚本的信号处理。所谓的信号处理，就是由Process Monitor（如Supervisor）发送并与我们的脚本进行通信的异步通知。 123456789101112131415161718192021222324protected function listenForSignals()&#123; if ($this-&gt;supportsAsyncSignals()) &#123; pcntl_async_signals(true); pcntl_signal(SIGTERM, function () &#123; $this-&gt;shouldQuit = true; &#125;); pcntl_signal(SIGUSR2, function () &#123; $this-&gt;paused = true; &#125;); pcntl_signal(SIGCONT, function () &#123; $this-&gt;paused = false; &#125;); &#125;&#125;protected function supportsAsyncSignals()&#123; return version_compare(PHP_VERSION, '7.1.0') &gt;= 0 &amp;&amp; extension_loaded('pcntl');&#125; pcntl_async_signals()被调用来启用信号处理，然后我们为多个信号注册处理程序： 当脚本被Supervisor指示关闭时，会引发信号SIGTERM。 SIGUSR2是用户定义的信号，Laravel用来表示脚本应该暂停。 当暂停的脚本被Supervisor指示继续进行时，会引发SIGCONT。 在真正运行任务之前，程序还从cache中取了一次最后一次重启的时间：1234567protected function getTimestampOfLastQueueRestart()&#123; if ($this-&gt;cache) &#123; return $this-&gt;cache-&gt;get('illuminate:queue:restart'); &#125;&#125; 确定worker是否应该处理作业进入循环后，首先要判断当前脚本是应该处理任务，还是应该暂停，还是应该退出： 12345678protected function daemonShouldRun(WorkerOptions $options)&#123; return ! ( ($this-&gt;manager-&gt;isDownForMaintenance() &amp;&amp; ! $options-&gt;force) || $this-&gt;paused || $this-&gt;events-&gt;until(new Events\Looping) === false );&#125; 以下几种情况，循环将不会处理任务： 脚本处于维护模式并且没有--force选项。 脚本被supervisor暂停。 脚本的looping事件监听器返回false。 looping事件监听器在每次循环的时候都会被启动，如果返回false，那么当前的循环将会被暂停：pauseWorker：12345protected function pauseWorker(WorkerOptions $options, $lastRestart)&#123; $this-&gt;sleep($options-&gt;sleep &gt; 0 ? $options-&gt;sleep : 1); $this-&gt;stopIfNecessary($options, $lastRestart);&#125; 脚本在sleep一段时间之后，就要重新判断当前脚本是否需要stop：1234567891011121314151617181920212223242526272829protected function stopIfNecessary(WorkerOptions $options, $lastRestart)&#123; if ($this-&gt;shouldQuit) &#123; $this-&gt;kill(); &#125; if ($this-&gt;memoryExceeded($options-&gt;memory)) &#123; $this-&gt;stop(12); &#125; elseif ($this-&gt;queueShouldRestart($lastRestart)) &#123; $this-&gt;stop(); &#125;&#125;protected function queueShouldRestart($lastRestart)&#123; return $this-&gt;getTimestampOfLastQueueRestart() != $lastRestart;&#125;protected function getTimestampOfLastQueueRestart()&#123; if ($this-&gt;cache) &#123; return $this-&gt;cache-&gt;get('illuminate:queue:restart'); &#125;&#125; 以下情况脚本将会被stop： 脚本被supervisor退出。 内存超限。 脚本被重启过。 1234567891011121314public function kill($status = 0)&#123; if (extension_loaded('posix')) &#123; posix_kill(getmypid(), SIGKILL); &#125; exit($status);&#125;public function stop($status = 0)&#123; $this-&gt;events-&gt;fire(new Events\WorkerStopping); exit($status);&#125; 脚本被重启，当前的进程需要退出并且重新加载。 获取下一个任务当含有多个队列的时候，命令行可以用“,”连接多个队列的名字，位于前面的队列优先级更高：1234567891011121314151617181920protected function getNextJob($connection, $queue)&#123; try &#123; foreach (explode(',', $queue) as $queue) &#123; if (! is_null($job = $connection-&gt;pop($queue))) &#123; return $job; &#125; &#125; &#125; catch (Exception $e) &#123; $this-&gt;exceptions-&gt;report($e); &#125; catch (Throwable $e) &#123; $this-&gt;exceptions-&gt;report(new FatalThrowableError($e)); &#125;&#125; $connection是具体的驱动，我们这里是Illuminate\Queue\RedisQueue：12345678910111213141516171819202122232425262728293031323334353637class RedisQueue extends Queue implements QueueContract&#123; /** * Pop the next job off of the queue. * * @param string|null $queue * @return \Illuminate\Contracts\Queue\Job|null */ public function pop($queue = null) &#123; $this-&gt;migrate($prefixed = $this-&gt;getQueue($queue)); if (empty($nextJob = $this-&gt;retrieveNextJob($prefixed))) &#123; return; &#125; [$job, $reserved] = $nextJob; if ($reserved) &#123; return new RedisJob( $this-&gt;container, $this, $job, $reserved, $this-&gt;connectionName, $queue ?: $this-&gt;default ); &#125; &#125; /** * Get the queue or return the default. * * @param string|null $queue * @return string */ public function getQueue($queue) &#123; return 'queues:'.($queue ?: $this-&gt;default); &#125;&#125; 在从队列中取出任务之前，需要先将delay队列和reserved队列中已经到时间的任务放到主队列中：1234567891011121314151617181920212223242526272829/** * Migrate any delayed or expired jobs onto the primary queue. * * @param string $queue * @return void */protected function migrate($queue)&#123; $this-&gt;migrateExpiredJobs($queue.':delayed', $queue); if (! is_null($this-&gt;retryAfter)) &#123; $this-&gt;migrateExpiredJobs($queue.':reserved', $queue); &#125;&#125;/** * Migrate the delayed jobs that are ready to the regular queue. * * @param string $from * @param string $to * @return array */public function migrateExpiredJobs($from, $to)&#123; return $this-&gt;getConnection()-&gt;eval( LuaScripts::migrateExpiredJobs(), 3, $from, $to, $to.':notify', $this-&gt;currentTime() );&#125; 由于从队列取出任务、在队列删除任务、压入主队列是三个操作，为了防止并发，程序这里使用了LUA脚本，保证三个操作的原子性：12345678910111213141516171819202122232425262728293031323334/** * Get the Lua script to migrate expired jobs back onto the queue. * * KEYS[1] - The queue we are removing jobs from, for example: queues:foo:reserved * KEYS[2] - The queue we are moving jobs to, for example: queues:foo * KEYS[3] - The notification list for the queue we are moving jobs to, for example queues:foo:notify * ARGV[1] - The current UNIX timestamp * * @return string */public static function migrateExpiredJobs()&#123; return &lt;&lt;&lt;'LUA'-- Get all of the jobs with an expired "score"...local val = redis.call('zrangebyscore', KEYS[1], '-inf', ARGV[1])-- If we have values in the array, we will remove them from the first queue-- and add them onto the destination queue in chunks of 100, which moves-- all of the appropriate jobs onto the destination queue very safely.if(next(val) ~= nil) then redis.call('zremrangebyrank', KEYS[1], 0, #val - 1) for i = 1, #val, 100 do redis.call('rpush', KEYS[2], unpack(val, i, math.min(i+99, #val))) -- Push a notification for every job that was migrated... for j = i, math.min(i+99, #val) do redis.call('rpush', KEYS[3], 1) end endendreturn valLUA;&#125; 接下来，就要从主队列中获取下一个任务，在取出下一个任务之后，还要将任务放入reserved队列中，当任务执行失败后，该任务会进行重试。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Retrieve the next job from the queue. * * @param string $queue * @param bool $block * @return array */protected function retrieveNextJob($queue, $block = true)&#123; $nextJob = $this-&gt;getConnection()-&gt;eval( LuaScripts::pop(), 3, $queue, $queue.':reserved', $queue.':notify', $this-&gt;availableAt($this-&gt;retryAfter) ); if (empty($nextJob)) &#123; return [null, null]; &#125; [$job, $reserved] = $nextJob; if (! $job &amp;&amp; ! is_null($this-&gt;blockFor) &amp;&amp; $block &amp;&amp; $this-&gt;getConnection()-&gt;blpop([$queue.':notify'], $this-&gt;blockFor)) &#123; return $this-&gt;retrieveNextJob($queue, false); &#125; return [$job, $reserved];&#125;/** * Get the Lua script for popping the next job off of the queue. * * KEYS[1] - The queue to pop jobs from, for example: queues:foo * KEYS[2] - The queue to place reserved jobs on, for example: queues:foo:reserved * KEYS[3] - The notify queue * ARGV[1] - The time at which the reserved job will expire * * @return string */public static function pop()&#123; return &lt;&lt;&lt;'LUA'-- Pop the first job off of the queue...local job = redis.call('lpop', KEYS[1])local reserved = falseif(job ~= false) then -- Increment the attempt count and place job on the reserved queue... reserved = cjson.decode(job) reserved['attempts'] = reserved['attempts'] + 1 reserved = cjson.encode(reserved) redis.call('zadd', KEYS[2], ARGV[1], reserved) redis.call('lpop', KEYS[3])endreturn &#123;job, reserved&#125;LUA;&#125; 从redis中获取到job之后，就会将其包装成RedisJob类：1234567891011121314151617181920public function __construct(Container $container, RedisQueue $redis, $job, $reserved, $connectionName, $queue)&#123; $this-&gt;job = $job; $this-&gt;redis = $redis; $this-&gt;queue = $queue; $this-&gt;reserved = $reserved; $this-&gt;container = $container; $this-&gt;connectionName = $connectionName; $this-&gt;decoded = $this-&gt;payload();&#125;public function payload()&#123; return json_decode($this-&gt;getRawBody(), true);&#125;public function getRawBody()&#123; return $this-&gt;job;&#125; 超时处理如果一个脚本超时，pcntl_alarm将会启动并杀死当前的work进程。杀死进程后，work进程将会被守护进程重启，继续进行下一个任务。123456789101112131415161718protected function registerTimeoutHandler($job, WorkerOptions $options)&#123; if ($options-&gt;timeout &gt; 0 &amp;&amp; $this-&gt;supportsAsyncSignals()) &#123; pcntl_signal(SIGALRM, function () &#123; $this-&gt;kill(1); &#125;); pcntl_alarm($this-&gt;timeoutForJob($job, $options) + $options-&gt;sleep); &#125;&#125;protected function timeoutForJob($job, WorkerOptions $options)&#123; return $job &amp;&amp; ! is_null($job-&gt;timeout()) ? $job-&gt;timeout() : $options-&gt;timeout;&#125; 任务事务运行任务前后会启动两个事件JobProcessing与JobProcessed，这两个事件需要事先注册监听者：123456789101112131415161718192021222324252627282930313233343536373839404142434445protected function runJob($job, $connectionName, WorkerOptions $options)&#123; try &#123; return $this-&gt;process($connectionName, $job, $options); &#125; catch (Exception $e) &#123; $this-&gt;exceptions-&gt;report($e); &#125; catch (Throwable $e) &#123; $this-&gt;exceptions-&gt;report(new FatalThrowableError($e)); &#125;&#125;public function process($connectionName, $job, WorkerOptions $options)&#123; try &#123; $this-&gt;raiseBeforeJobEvent($connectionName, $job); $this-&gt;markJobAsFailedIfAlreadyExceedsMaxAttempts( $connectionName, $job, (int) $options-&gt;maxTries ); $job-&gt;fire(); $this-&gt;raiseAfterJobEvent($connectionName, $job); &#125; catch (Exception $e) &#123; $this-&gt;handleJobException($connectionName, $job, $options, $e); &#125; catch (Throwable $e) &#123; $this-&gt;handleJobException( $connectionName, $job, $options, new FatalThrowableError($e) ); &#125;&#125; 任务前与任务后事件raiseBeforeJobEvent函数用于触发任务处理前的事件，raiseAfterJobEvent函数用于触发任务处理后的事件：1234567891011121314151617protected function raiseBeforeJobEvent($connectionName, $job)&#123; $this-&gt;events-&gt;fire( new Events\JobProcessing( $connectionName, $job ) );&#125;protected function raiseAfterJobEvent($connectionName, $job)&#123; $this-&gt;events-&gt;fire( new Events\JobProcessed( $connectionName, $job ) );&#125; 任务异常处理任务在运行过程中会遇到异常情况，这个时候就要判断当前任务的失败次数是不是超过限制。如果没有超过限制，那么就会把当前任务重新放回队列当中；如果超过了限制，那么就要标记当前任务为失败任务，并且将任务从reserved队列中删除。 任务失败markJobAsFailedIfAlreadyExceedsMaxAttempts函数用于任务运行前，判断当前任务是否重试次数超过限制：123456789101112131415161718192021222324252627282930313233343536protected function markJobAsFailedIfAlreadyExceedsMaxAttempts($connectionName, $job, $maxTries)&#123; $maxTries = ! is_null($job-&gt;maxTries()) ? $job-&gt;maxTries() : $maxTries; if ($maxTries === 0 || $job-&gt;attempts() &lt;= $maxTries) &#123; return; &#125; $this-&gt;failJob( $connectionName, $job, $e = new MaxAttemptsExceededException( 'A queued job has been attempted too many times. The job may have previously timed out.' ) ); throw $e;&#125;public function maxTries()&#123; return array_get($this-&gt;payload(), 'maxTries');&#125;public function attempts()&#123; return Arr::get($this-&gt;decoded, 'attempts') + 1;&#125;protected function failJob($connectionName, $job, $e)&#123; return FailingJob::handle($connectionName, $job, $e);&#125; 当遇到重试次数大于限制的任务，work进程就会调用FailingJob：1234567891011121314151617181920212223242526272829303132333435363738394041424344protected function failJob($connectionName, $job, $e)&#123; return FailingJob::handle($connectionName, $job, $e);&#125;public static function handle($connectionName, $job, $e = null)&#123; $job-&gt;markAsFailed(); if ($job-&gt;isDeleted()) &#123; return; &#125; try &#123; $job-&gt;delete(); $job-&gt;failed($e); &#125; finally &#123; static::events()-&gt;fire( new JobFailed( $connectionName, $job, $e ? : new ManuallyFailedException ) ); &#125;&#125;public function markAsFailed()&#123; $this-&gt;failed = true;&#125;public function delete()&#123; parent::delete(); $this-&gt;redis-&gt;deleteReserved($this-&gt;queue, $this);&#125;public function isDeleted()&#123; return $this-&gt;deleted;&#125; FailingJob会标记当前任务failed、deleted，并且会将当前任务移除reserved队列，不会再重试：1234567public function deleteReserved($queue, $job)&#123; $this-&gt;getConnection()-&gt;zrem( $this-&gt;getQueue($queue).':reserved', $job-&gt;getReservedJob() );&#125; FailingJob还会调用RedisJob的failed函数，并且触发JobFailed事件：123456789101112public function failed($e)&#123; $this-&gt;markAsFailed(); $payload = $this-&gt;payload(); list($class, $method) = JobName::parse($payload['job']); if (method_exists($this-&gt;instance = $this-&gt;resolve($class),'failed')) &#123; $this-&gt;instance-&gt;failed($payload['data'], $e); &#125;&#125; 程序会解析job类，我们先前在redis中已经存储了：123456789[ 'job' =&gt; 'Illuminate\Queue\CallQueuedHandler@call', 'maxTries' =&gt; isset($job-&gt;tries) ? $job-&gt;tries : null, 'timeout' =&gt; isset($job-&gt;timeout) ? $job-&gt;timeout : null, 'data' =&gt; [ 'commandName' =&gt; get_class($job), 'command' =&gt; serialize(clone $job), ],]; 我们接着看failed函数：12345678public function failed(array $data, $e)&#123; $command = unserialize($data['command']); if (method_exists($command, 'failed')) &#123; $command-&gt;failed($e); &#125;&#125; 可以看到，最后程序调用了任务类的failed函数。 异常处理当任务遇到异常的时候，程序仍然会判断当前任务的重试次数，如果本次任务的重试次数已经大于或等于限制，那么就会停止重试，标记为失败；否则就会重新放入队列，记录日志。12345678910111213141516171819202122232425262728293031323334353637383940414243444546protected function handleJobException($connectionName, $job, WorkerOptions $options, $e)&#123; try &#123; $this-&gt;markJobAsFailedIfWillExceedMaxAttempts( $connectionName, $job, (int) $options-&gt;maxTries, $e ); $this-&gt;raiseExceptionOccurredJobEvent( $connectionName, $job, $e ); &#125; finally &#123; if (! $job-&gt;isDeleted()) &#123; $job-&gt;release($options-&gt;delay); &#125; &#125; throw $e;&#125;protected function markJobAsFailedIfWillExceedMaxAttempts($connectionName, $job, $maxTries, $e)&#123; $maxTries = ! is_null($job-&gt;maxTries()) ? $job-&gt;maxTries() : $maxTries; if ($maxTries &gt; 0 &amp;&amp; $job-&gt;attempts() &gt;= $maxTries) &#123; $this-&gt;failJob($connectionName, $job, $e); &#125;&#125;public function release($delay = 0)&#123; parent::release($delay); $this-&gt;redis-&gt;deleteAndRelease($this-&gt;queue, $this, $delay);&#125;public function deleteAndRelease($queue, $job, $delay)&#123; $queue = $this-&gt;getQueue($queue); $this-&gt;getConnection()-&gt;eval( LuaScripts::release(), 2, $queue.':delayed', $queue.':reserved', $job-&gt;getReservedJob(), $this-&gt;availableAt($delay) );&#125; 一旦任务出现异常错误。那么该任务将会立刻从reserved队列放入delayed队列，并且抛出异常，抛出异常后，程序会将其记录在日志中。12345678910public static function release()&#123; return &lt;&lt;&lt;'LUA'-- Remove the job from the current queue...redis.call('zrem', KEYS[2], ARGV[1])-- Add the job onto the "delayed" queue...redis.call('zadd', KEYS[1], ARGV[2], ARGV[1])return true LUA;&#125; 任务的运行任务的运行首先会调用CallQueuedHandler的call函数：123456789101112131415161718192021222324252627282930313233343536public function fire()&#123; $payload = $this-&gt;payload(); list($class, $method) = JobName::parse($payload['job']); with($this-&gt;instance = $this-&gt;resolve($class))-&gt;&#123;$method&#125;($this, $payload['data']);&#125;/** * Handle the queued job. * * @param \Illuminate\Contracts\Queue\Job $job * @param array $data * @return void */public function call(Job $job, array $data)&#123; try &#123; $command = $this-&gt;setJobInstanceIfNecessary( $job, unserialize($data['command']) ); &#125; catch (ModelNotFoundException $e) &#123; return $this-&gt;handleModelNotFound($job, $e); &#125; $this-&gt;dispatchThroughMiddleware($job, $command); if (! $job-&gt;hasFailed() &amp;&amp; ! $job-&gt;isReleased()) &#123; $this-&gt;ensureNextJobInChainIsDispatched($command); &#125; if (! $job-&gt;isDeletedOrReleased()) &#123; $job-&gt;delete(); &#125;&#125; setJobInstanceIfNecessary函数用于为任务类的trait:InteractsWithQueue的设置任务类：12345678910111213141516171819202122232425262728293031/** * Set the job instance of the given class if necessary. * * @param \Illuminate\Contracts\Queue\Job $job * @param mixed $instance * @return mixed */protected function setJobInstanceIfNecessary(Job $job, $instance)&#123; if (in_array(InteractsWithQueue::class, class_uses_recursive($instance))) &#123; $instance-&gt;setJob($job); &#125; return $instance;&#125;trait InteractsWithQueue&#123; /** * Set the base queue job instance. * * @param \Illuminate\Contracts\Queue\Job $job * @return $this */ public function setJob(JobContract $job) &#123; $this-&gt;job = $job; return $this; &#125;&#125; 接着任务的运行就要交给dispatch：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Dispatch a command to its appropriate handler in the current process. * * @param mixed $command * @param mixed $handler * @return mixed */public function dispatchNow($command, $handler = null)&#123; if ($handler || $handler = $this-&gt;getCommandHandler($command)) &#123; $callback = function ($command) use ($handler) &#123; return $handler-&gt;handle($command); &#125;; &#125; else &#123; $callback = function ($command) &#123; return $this-&gt;container-&gt;call([$command, 'handle']); &#125;; &#125; return $this-&gt;pipeline-&gt;send($command)-&gt;through($this-&gt;pipes)-&gt;then($callback);&#125;/** * Retrieve the handler for a command. * * @param mixed $command * @return bool|mixed */public function getCommandHandler($command)&#123; if ($this-&gt;hasCommandHandler($command)) &#123; return $this-&gt;container-&gt;make($this-&gt;handlers[get_class($command)]); &#125; return false;&#125;/** * Determine if the given command has a handler. * * @param mixed $command * @return bool */public function hasCommandHandler($command)&#123; return array_key_exists(get_class($command), $this-&gt;handlers);&#125; 如果不对dispatcher类进行任何map函数设置，getCommandHandler将会返回null，此时就会调用任务类的handle函数，进行具体的业务逻辑。 任务结束后，就会调用delete函数：1234567891011121314151617181920212223/** * Delete the job from the queue. * * @return void */public function delete()&#123; parent::delete(); $this-&gt;redis-&gt;deleteReserved($this-&gt;queue, $this);&#125;/** * Delete a reserved job from the queue. * * @param string $queue * @param \Illuminate\Queue\Jobs\RedisJob $job * @return void */public function deleteReserved($queue, $job)&#123; $this-&gt;getConnection()-&gt;zrem($this-&gt;getQueue($queue).':reserved', $job-&gt;getReservedJob());&#125; 这样，运行成功的任务会从reserved中删除。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Queue-消息队列任务与分发源码剖析]]></title>
    <url>%2F2020%2F05%2F11%2FLaravel-Queue-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Laravel的队列服务由两个进程控制，一个是生产者，一个是消费者。怎么理解？ 将有序集合ZSet的评分score设置为延时任务开启的时间，可以实现延迟任务的功能。怎么实现的？ 重试也是通过ZSet实现的。怎么理解？ 一个List，负责即时任务，两个ZSet，负责延时任务与待处理任务。怎么理解？ 前言在实际的项目开发中，我们经常会遇到需要轻量级队列的情形，例如发短信、发邮件等，这些任务不足以使用Kafka、RabbitMQ等重量级的消息队列，但是又的确需要异步、重试、并发控制等功能。通常来说，我们经常会使用Redis、Beanstalkd、Amazon SQS来实现相关功能，Laravel为此对不同的后台队列服务提供统一的API，本文将会介绍应用最为广泛的Redis队列。 背景知识在讲解Laravel的队列服务之前，我们要先说说基于Redis的队列服务。首先，Redis设计用来做缓存的，但是由于它自身的某种特性使得它可以用来做消息队列。 Redis队列的数据结构List链表 Redis做消息队列的特性例如FIFO（先入先出）很容易实现，只需要一个List对象从头取数据，从尾部塞数据即可。 相关的命令： （1）左侧入右侧出：lpush/rpop； （2）右侧入左侧出：rpush/lpop。 这个简单的消息队列很容易实现。 ZSet有序集合 有些任务场景，并不需要任务立刻执行，而是需要延迟执行；有些任务很重要，需要在任务失败的时候重新尝试。这些功能仅仅依靠List是无法完成的。这个时候，就需要Redis的有序集合。 Redis有序集合和Redis集合类似，是不包含相同字符串的合集。它们的差别是，每个有序集合的成员都关联着一个评分score，这个评分用于把有序集合中的成员按最低分到最高分排列。 单看有序集合和延迟任务并无关系，但是可以将有序集合的评分score设置为延时任务开启的时间，之后轮询这个有序集合，将到期的任务拿出来进行处理，这样就实现了延迟任务的功能。 对于重要的需要重试的任务，在任务执行之前，会将该任务放入有序集合中，设置任务最长的执行时间。若任务顺利执行完毕，该任务会在有序集合中删除。如果任务没有在规定时间内完成，那么该有序集合的任务将会被重新放入队列中。 相关命令： (1) ZADD 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数。 (2) ZRANGEBYSCORE 按分数返回一个成员范围的有序集合。 (3) ZREMRANGEBYRANK 在给定的索引之内删除所有成员的有序集合。 Laravel队列服务的任务调度队列服务的任务调度过程如下： Laravel的队列服务由两个进程控制，一个是生产者，一个是消费者。这两个进程操纵了Redis三个队列，其中一个List，负责即时任务，两个ZSet，负责延时任务与待处理任务。 生产者负责向Redis推送任务，如果是即时任务，默认就会向queue:default推送；如果是延时任务，就会向queue:default:delayed推送。 消费者轮询两个队列，不断的从队列中取出任务，先把任务放入queue:default:reserved中，再执行相关任务。如果任务执行成功，就会删除queue:default:reserved中的任务，否则会被重新放入queue:default:delayed队列中。 Laravel队列服务的总体流程任务分发流程： 任务处理器运作： Laravel队列服务的注册与启动Laravel队列服务需要注册的服务比较多： Illuminate/Queue/QueueServiceProvider.php 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace Illuminate\Queue;use Illuminate\Contracts\Debug\ExceptionHandler;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Queue\Connectors\RedisConnector;use Illuminate\Queue\Failed\DatabaseFailedJobProvider;use Illuminate\Support\Arr;use Illuminate\Support\ServiceProvider;use Illuminate\Support\Str;use Opis\Closure\SerializableClosure;class QueueServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;registerManager(); $this-&gt;registerConnection(); $this-&gt;registerWorker(); $this-&gt;registerListener(); $this-&gt;registerFailedJobServices(); $this-&gt;registerOpisSecurityKey(); &#125;&#125; registerManager注册门面registerManager负责注册队列服务的门面类： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Register the queue manager. * * @return void */protected function registerManager()&#123; $this-&gt;app-&gt;singleton('queue', function ($app) &#123; // Once we have an instance of the queue manager, we will register the various // resolvers for the queue connectors. These connectors are responsible for // creating the classes that accept queue configs and instantiate queues. return tap(new QueueManager($app), function ($manager) &#123; $this-&gt;registerConnectors($manager); &#125;); &#125;);&#125;/** * Register the connectors on the queue manager. * * @param \Illuminate\Queue\QueueManager $manager * @return void */public function registerConnectors($manager)&#123; foreach (['Null', 'Sync', 'Database', 'Redis', 'Beanstalkd', 'Sqs'] as $connector) &#123; $this-&gt;&#123;"register&#123;$connector&#125;Connector"&#125;($manager); &#125;&#125;/** * Register the Redis queue connector. * * @param \Illuminate\Queue\QueueManager $manager * @return void */protected function registerRedisConnector($manager)&#123; $manager-&gt;addConnector('redis', function () &#123; return new RedisConnector($this-&gt;app['redis']); &#125;);&#125; QueueManager是队列服务的总门面，提供一切与队列相关的操作接口。QueueManager中有一个成员变量$connectors，该成员变量中存储着所有Laravel支持的底层队列服务：“Database”,“Redis”,“Beanstalkd”,“SQS”。 123456789101112131415161718192021class QueueManager implements FactoryContract, MonitorContract&#123; /** * The array of resolved queue connectors. * * @var array */ protected $connectors = []; /** * Add a queue connection resolver. * * @param string $driver * @param \Closure $resolver * @return void */ public function addConnector($driver, Closure $resolver) &#123; $this-&gt;connectors[$driver] = $resolver; &#125;&#125; 成员变量$connectors会被存储各种驱动的connector，例如RedisConnector、SqsConnector、DatabaseConnector、BeanstalkdConnector。 registerConnection底层队列连接服务接下来，就要连接实现队列的底层服务了，例如Redis： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Register the default queue connection binding. * * @return void */protected function registerConnection()&#123; $this-&gt;app-&gt;singleton('queue.connection', function ($app) &#123; return $app['queue']-&gt;connection(); &#125;);&#125;/** * Resolve a queue connection instance. * * @param string|null $name * @return \Illuminate\Contracts\Queue\Queue */public function connection($name = null)&#123; $name = $name ?: $this-&gt;getDefaultDriver(); // If the connection has not been resolved yet we will resolve it now as all // of the connections are resolved when they are actually needed so we do // not make any unnecessary connection to the various queue end-points. if (! isset($this-&gt;connections[$name])) &#123; $this-&gt;connections[$name] = $this-&gt;resolve($name); $this-&gt;connections[$name]-&gt;setContainer($this-&gt;app); &#125; return $this-&gt;connections[$name];&#125;/** * Get the name of the default queue connection. * * @return string */public function getDefaultDriver()&#123; return $this-&gt;app['config']['queue.default'];&#125; connection函数首先会获取连接名，没有连接名就会从config中获取默认的连接。 1234567891011121314/** * Resolve a queue connection. * * @param string $name * @return \Illuminate\Contracts\Queue\Queue */protected function resolve($name)&#123; $config = $this-&gt;getConfig($name); return $this-&gt;getConnector($config['driver']) -&gt;connect($config) -&gt;setConnectionName($name);&#125; resolve函数利用相应的底层驱动connector进行连接操作，也就是connect函数，该函数会返回RedisQueue： Illuminate/Queue/Connectors/RedisConnector.php 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\Queue\Connectors;use Illuminate\Contracts\Redis\Factory as Redis;use Illuminate\Queue\RedisQueue;class RedisConnector implements ConnectorInterface&#123; /** * Establish a queue connection. * * @param array $config * @return \Illuminate\Contracts\Queue\Queue */ public function connect(array $config) &#123; return new RedisQueue( $this-&gt;redis, $config['queue'], $config['connection'] ?? $this-&gt;connection, $config['retry_after'] ?? 60, $config['block_for'] ?? null ); &#125;&#125; registerWorker消费者服务注册消费者的注册服务会返回Illuminate\Queue\Worker类：1234567891011121314151617181920/** * Register the queue worker. * * @return void */protected function registerWorker()&#123; $this-&gt;app-&gt;singleton('queue.worker', function ($app) &#123; $isDownForMaintenance = function () &#123; return $this-&gt;app-&gt;isDownForMaintenance(); &#125;; return new Worker( $app['queue'], $app['events'], $app[ExceptionHandler::class], $isDownForMaintenance ); &#125;);&#125; Laravel Bus服务注册与启动定义好自己想要的队列类之后，还需要将队列任务推送给底层驱动后台，例如Redis，一般会使用dispatch函数：1Job::dispatch(); 或者12$job = (new ProcessPodcast($pocast));dispatch($job); dispatch函数就是Bus服务，专门用于分发队列任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace Illuminate\Bus;use Illuminate\Contracts\Bus\Dispatcher as DispatcherContract;use Illuminate\Contracts\Bus\QueueingDispatcher as QueueingDispatcherContract;use Illuminate\Contracts\Queue\Factory as QueueFactoryContract;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\ServiceProvider;class BusServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton(Dispatcher::class, function ($app) &#123; return new Dispatcher($app, function ($connection = null) use ($app) &#123; return $app[QueueFactoryContract::class]-&gt;connection($connection); &#125;); &#125;); $this-&gt;app-&gt;alias( Dispatcher::class, DispatcherContract::class ); $this-&gt;app-&gt;alias( Dispatcher::class, QueueingDispatcherContract::class ); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [ Dispatcher::class, DispatcherContract::class, QueueingDispatcherContract::class, ]; &#125;&#125; 创建任务queue设置123456'redis' =&gt; [ 'driver' =&gt; 'redis', 'connection' =&gt; 'default', 'queue' =&gt; 'default', 'retry_after' =&gt; 90,], 一般来说，默认的redis配置如上，connection是database中redis的连接名称；queue是redis中的队列名称，值得注意的是，如果使用的是redis集群的话，这个需要使用key hash tag，也就是{default}；当任务运行超过retry_after这个时间后，该任务会被重新放入队列当中。 任务类的创建 任务类的结构很简单，一般来说只会包含一个让队列用来调用此任务的handle方法。 如果想要使得任务被推送到队列中，而不是同步执行，那么需要实现Illuminate\Contracts\Queue\ShouldQueue接口。 如果想要让任务推送到特定的连接中，例如redis或者sqs，那么需要设置conneciton变量。 如果想要让任务推送到特定的队列中去，可以设置queue变量。 如果想要让任务延迟推送，那么需要设置delay变量。 如果想要设置任务至多重试的次数，可以使用tries变量； 如果想要设置任务可以运行的最大秒数，那么可以使用timeout参数。 如果想要手动访问队列，可以使用trait:Illuminate\Queue\InteractsWithQueue。 如果队列监听器任务执行次数超过在工作队列中定义的最大尝试次数，监听器的failed方法将会被自动调用。failed方法接受事件实例和失败的异常作为参数：1234567891011121314151617181920212223242526272829class ProcessPodcast implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $podcast; public $connection = 'redis'; public $queue = 'test'; public $delay = 30; public $tries = 5; public $timeout = 30; public function __construct(Podcast $podcast) &#123; $this-&gt;podcast = $podcast; &#125; public function handle(AudioProcessor $processor) &#123; // Process uploaded podcast... if (false) &#123; $this-&gt;release(30); &#125; &#125; public function failed(OrderShipped $event, $exception) &#123; // &#125;&#125; 任务事件12345678910111213141516171819202122232425262728293031323334353637383940class AppServiceProvider extends ServiceProvider&#123; public function boot() &#123; // 任务运行前 Queue::before(function (JobProcessing $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); //任务运行后 Queue::after(function (JobProcessed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); //任务循环前 Queue::looping(function () &#123; while (DB::transactionLevel() &gt; 0) &#123; DB::rollBack(); &#125; &#125;); // 任务失败后 Queue::failing(function (JobFailed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;exception &#125;); // 异常发生后 Queue::exceptionOccurred(function (JobFailed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;exception &#125;); &#125;&#125; 任务的分发分发服务写好任务类后，就能通过dispatch辅助函数来分发它了。唯一需要传递给dispatch的参数是这个任务类的实例：12345678class PodcastController extends Controller&#123; public function store(Request $request) &#123; // 创建播客... ProcessPodcast::dispatch($podcast); &#125;&#125; 如果想延迟执行一个队列中的任务，可以用任务实例的delay方法。1ProcessPodcast::dispatch($podcast)-&gt;delay(Carbon::now()-&gt;addMinutes(10)); 通过推送任务到不同的队列，可以给队列任务分类，甚至可以控制给不同的队列分配多少任务。要指定队列的话，就调用任务实例的onQueue方法：1ProcessPodcast::dispatch($podcast)-&gt;onQueue('processing'); 如果使用了多个队列连接，可以将任务推到指定连接。要指定连接的话，可以在分发任务的时候使用onConnection方法：1ProcessPodcast::dispatch($podcast)-&gt;onConnection('redis'); 这些链式的函数是在trait：Illuminate\Foundation\Bus\Dispatchable的基础上应用的，该trait由dispatch函数启动：1234567trait Dispatchable&#123; public static function dispatch() &#123; return new PendingDispatch(new static(...func_get_args())); &#125;&#125; PendingDispatch类中定义了链式函数，该函数巧妙在析构函数中，析构函数自动调用全局函数dispatch：123456789101112131415161718192021222324252627282930class PendingDispatch&#123; public function __construct($job) &#123; $this-&gt;job = $job; &#125; public function onConnection($connection) &#123; $this-&gt;job-&gt;onConnection($connection); return $this; &#125; public function onQueue($queue) &#123; $this-&gt;job-&gt;onQueue($queue); return $this; &#125; public function delay($delay) &#123; $this-&gt;job-&gt;delay($delay); return $this; &#125; public function __destruct() &#123; dispatch($this-&gt;job); &#125;&#125; 各个函数里面的onConnection、delay、onQueue等函数是任务中的trait：Illuminate\Bus\Queueable1234567891011121314151617181920trait Queueable&#123; public function onConnection($connection) &#123; $this-&gt;connection = $connection; return $this; &#125; public function onQueue($queue) &#123; $this-&gt;queue = $queue; return $this; &#125; public function delay($delay) &#123; $this-&gt;delay = $delay; return $this; &#125;&#125; dispatch任务分发源码任务的分发离不开Bus服务，可以利用全局函数dispatch，还可以使用Dispatchable这个trait： Illuminate/Bus/Dispatcher.php 1234567891011121314151617181920212223242526272829303132333435class Dispatcher implements QueueingDispatcher&#123; /** * The queue resolver callback. * * @var \Closure|null */ protected $queueResolver; /** * Dispatch a command to its appropriate handler. * * @param mixed $command * @return mixed */ public function dispatch($command) &#123; if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123; return $this-&gt;dispatchToQueue($command); &#125; return $this-&gt;dispatchNow($command); &#125; /** * Determine if the given command should be queued. * * @param mixed $command * @return bool */ protected function commandShouldBeQueued($command) &#123; return $command instanceof ShouldQueue; &#125;&#125; 我们这里主要看异步的任务：12345678910111213141516171819202122/** * Dispatch a command to its appropriate handler behind a queue. * * @param mixed $command * @return mixed */public function dispatchToQueue($command)&#123; $connection = $command-&gt;connection ?? null; $queue = call_user_func($this-&gt;queueResolver, $connection); if (! $queue instanceof Queue) &#123; throw new RuntimeException('Queue resolver did not return a Queue implementation.'); &#125; if (method_exists($command, 'queue')) &#123; return $command-&gt;queue($queue, $command); &#125; return $this-&gt;pushCommandToQueue($queue, $command);&#125; 进行任务分发之前，首先要利用queueResolver连接底层驱动。如果任务类中含有queue函数，那么就会利用用户自己的queue对驱动进行推送任务。否则就会启动默认的程序：1234567891011121314151617181920212223/** * Push the command onto the given queue instance. * * @param \Illuminate\Contracts\Queue\Queue $queue * @param mixed $command * @return mixed */protected function pushCommandToQueue($queue, $command)&#123; if (isset($command-&gt;queue, $command-&gt;delay)) &#123; return $queue-&gt;laterOn($command-&gt;queue, $command-&gt;delay, $command); &#125; if (isset($command-&gt;queue)) &#123; return $queue-&gt;pushOn($command-&gt;queue, $command); &#125; if (isset($command-&gt;delay)) &#123; return $queue-&gt;later($command-&gt;delay, $command); &#125; return $queue-&gt;push($command);&#125; 我们以redis为例，queue这个类就是Illuminate\Queue\RedisQueue:123456789101112131415161718192021222324252627282930class RedisQueue extends Queue implements QueueContract&#123; /** * Push a new job onto the queue. * * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function push($job, $data = '', $queue = null) &#123; return $this-&gt;pushRaw($this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125; /** * Push a new job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function later($delay, $job, $data = '', $queue = null) &#123; return $this-&gt;laterRaw($delay, $this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125;&#125; 我们先看push，push函数调用pushRaw，在调用之前，要把任务类进行序列化，并且以特定的格式进行json序列化：12345678910111213141516171819202122232425262728293031323334353637383940/** * Create a payload string from the given job and data. * * @param string $job * @param string $queue * @param mixed $data * @return array */protected function createPayloadArray($job, $queue, $data = '')&#123; return array_merge(parent::createPayloadArray($job, $queue, $data), [ 'id' =&gt; $this-&gt;getRandomId(), 'attempts' =&gt; 0, ]);&#125;protected function createPayloadArray($job, $data = '', $queue = null)&#123; return is_object($job) ? $this-&gt;createObjectPayload($job) : $this-&gt;createStringPayload($job, $data);&#125;protected function createObjectPayload($job)&#123; return [ 'job' =&gt; 'Illuminate\Queue\CallQueuedHandler@call', 'maxTries' =&gt; isset($job-&gt;tries) ? $job-&gt;tries : null, 'timeout' =&gt; isset($job-&gt;timeout) ? $job-&gt;timeout : null, 'data' =&gt; [ 'commandName' =&gt; get_class($job), 'command' =&gt; serialize(clone $job), ], ];&#125;protected function createStringPayload($job, $data)&#123; return ['job' =&gt; $job, 'data' =&gt; $data];&#125; 格式化数据之后，就会将json推送到redis队列中，对于非延时的任务，直接调用rpush即可：123456public function pushRaw($payload, $queue = null, array $options = [])&#123; $this-&gt;getConnection()-&gt;rpush($this-&gt;getQueue($queue), $payload); return Arr::get(json_decode($payload, true), 'id');&#125; 对于延时的任务，会调用laterRaw，调用redis的有序集合zadd函数:1234567891011121314151617protected function availableAt($delay = 0)&#123; return $delay instanceof DateTimeInterface ? $delay-&gt;getTimestamp() : Carbon::now()-&gt;addSeconds($delay)-&gt;getTimestamp();&#125;protected function laterRaw($delay, $payload, $queue = null)&#123; $this-&gt;getConnection()-&gt;zadd( $this-&gt;getQueue($queue).':delayed', $this-&gt;availableAt($delay), $payload ); return Arr::get(json_decode($payload, true), 'id');&#125; 这样，相关任务就会被分发到redis对应的队列中去。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Redis]]></title>
    <url>%2F2020%2F05%2F10%2FLaravel-Redis%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Connector只负责连接，Connection负责操作。怎么理解？ RedisManager把Connection和Connetor组合起来。只new了PhpRedisConnector，通过Connector得到Connection。怎么理解？ 把$redis-&gt;get再封一层为$redis-&gt;command是为了触发CommandExecuted事件。怎么理解？ 管道命令当你需要在一次操作中发送多个命令到服务器的时候应该使用管道，pipeline方法接收一个参数：接收Redis实例的闭包。你可以将所有Redis命令发送到这个Redis实例，然后这些命令会在一次操作中被执行：1234567Redis::pipeline(function ($pipe) &#123; for ($i = 0; $i &lt; 1000; $i++) &#123; $pipe-&gt;set("key:$i", $i); &#125;&#125;); 源码文件结构 配置 config/database.php 12345678910111213141516171819'redis' =&gt; [ 'client' =&gt; 'predis', 'default' =&gt; [ 'host' =&gt; env('REDIS_HOST', '127.0.0.1'), 'password' =&gt; env('REDIS_PASSWORD', null), 'port' =&gt; env('REDIS_PORT', 6379), 'database' =&gt; env('REDIS_DB', 0), ], 'cache' =&gt; [ 'host' =&gt; env('REDIS_HOST', '127.0.0.1'), 'password' =&gt; env('REDIS_PASSWORD', null), 'port' =&gt; env('REDIS_PORT', 6379), 'database' =&gt; env('REDIS_CACHE_DB', 1), ], ], ConnectorConnector接口 Illuminate\Contracts\Redis\Connector.php 1234567891011121314151617181920212223242526&lt;?phpnamespace Illuminate\Contracts\Redis;interface Connector&#123; /** * Create a connection to a Redis instance. * * @param array $config * @param array $options * @return \Illuminate\Redis\Connections\Connection */ public function connect(array $config, array $options); /** * Create a connection to a Redis cluster. * * @param array $config * @param array $clusterOptions * @param array $options * @return \Illuminate\Redis\Connections\Connection */ public function connectToCluster(array $config, array $clusterOptions, array $options);&#125; Illuminate\Redis\Connectors\PhpRedisConnector.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;?phpnamespace Illuminate\Redis\Connectors;use Illuminate\Contracts\Redis\Connector;use Illuminate\Redis\Connections\PhpRedisClusterConnection;use Illuminate\Redis\Connections\PhpRedisConnection;use Illuminate\Support\Arr;use Illuminate\Support\Facades\Redis as RedisFacade;use LogicException;use Redis;use RedisCluster;class PhpRedisConnector implements Connector&#123; /** * Create a new clustered PhpRedis connection. * * @param array $config * @param array $options * @return \Illuminate\Redis\Connections\PhpRedisConnection */ public function connect(array $config, array $options) &#123; $connector = function () use ($config, $options) &#123; return $this-&gt;createClient(array_merge( $config, $options, Arr::pull($config, 'options', []) )); &#125;; return new PhpRedisConnection($connector(), $connector); &#125; /** * Create a new clustered PhpRedis connection. * * @param array $config * @param array $clusterOptions * @param array $options * @return \Illuminate\Redis\Connections\PhpRedisClusterConnection */ public function connectToCluster(array $config, array $clusterOptions, array $options) &#123; $options = array_merge($options, $clusterOptions, Arr::pull($config, 'options', [])); return new PhpRedisClusterConnection($this-&gt;createRedisClusterInstance( array_map([$this, 'buildClusterConnectionString'], $config), $options )); &#125; /** * Build a single cluster seed string from array. * * @param array $server * @return string */ protected function buildClusterConnectionString(array $server) &#123; return $server['host'].':'.$server['port'].'?'.Arr::query(Arr::only($server, [ 'database', 'password', 'prefix', 'read_timeout', ])); &#125; /** * Create the Redis client instance. * * @param array $config * @return \Redis * * @throws \LogicException */ protected function createClient(array $config) &#123; return tap(new Redis, function ($client) use ($config) &#123; if ($client instanceof RedisFacade) &#123; throw new LogicException( extension_loaded('redis') ? 'Please remove or rename the Redis facade alias in your "app" configuration file in order to avoid collision with the PHP Redis extension.' : 'Please make sure the PHP Redis extension is installed and enabled.' ); &#125; $this-&gt;establishConnection($client, $config); if (! empty($config['password'])) &#123; $client-&gt;auth($config['password']); &#125; if (isset($config['database'])) &#123; $client-&gt;select((int) $config['database']); &#125; if (! empty($config['prefix'])) &#123; $client-&gt;setOption(Redis::OPT_PREFIX, $config['prefix']); &#125; if (! empty($config['read_timeout'])) &#123; $client-&gt;setOption(Redis::OPT_READ_TIMEOUT, $config['read_timeout']); &#125; if (! empty($config['scan'])) &#123; $client-&gt;setOption(Redis::OPT_SCAN, $config['scan']); &#125; &#125;); &#125; /** * Establish a connection with the Redis host. * * @param \Redis $client * @param array $config * @return void */ protected function establishConnection($client, array $config) &#123; $persistent = $config['persistent'] ?? false; $parameters = [ $config['host'], $config['port'], Arr::get($config, 'timeout', 0.0), $persistent ? Arr::get($config, 'persistent_id', null) : null, Arr::get($config, 'retry_interval', 0), ]; if (version_compare(phpversion('redis'), '3.1.3', '&gt;=')) &#123; $parameters[] = Arr::get($config, 'read_timeout', 0.0); &#125; $client-&gt;&#123;($persistent ? 'pconnect' : 'connect')&#125;(...$parameters); &#125; /** * Create a new redis cluster instance. * * @param array $servers * @param array $options * @return \RedisCluster */ protected function createRedisClusterInstance(array $servers, array $options) &#123; $parameters = [ null, array_values($servers), $options['timeout'] ?? 0, $options['read_timeout'] ?? 0, isset($options['persistent']) &amp;&amp; $options['persistent'], ]; if (version_compare(phpversion('redis'), '4.3.0', '&gt;=')) &#123; $parameters[] = $options['password'] ?? null; &#125; return tap(new RedisCluster(...$parameters), function ($client) use ($options) &#123; if (! empty($options['prefix'])) &#123; $client-&gt;setOption(RedisCluster::OPT_PREFIX, $options['prefix']); &#125; if (! empty($options['scan'])) &#123; $client-&gt;setOption(RedisCluster::OPT_SCAN, $options['scan']); &#125; if (! empty($options['failover'])) &#123; $client-&gt;setOption(RedisCluster::OPT_SLAVE_FAILOVER, $options['failover']); &#125; &#125;); &#125;&#125; Connections Illuminate\Contracts\Redis\Connection.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace Illuminate\Contracts\Redis;use Closure;interface Connection&#123; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @return void */ public function subscribe($channels, Closure $callback); /** * Subscribe to a set of given channels with wildcards. * * @param array|string $channels * @param \Closure $callback * @return void */ public function psubscribe($channels, Closure $callback); /** * Run a command against the Redis database. * * @param string $method * @param array $parameters * @return mixed */ public function command($method, array $parameters = []);&#125; Illuminate\Redis\Connections\Connection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Redis\Events\CommandExecuted;use Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder;use Illuminate\Redis\Limiters\DurationLimiterBuilder;use Illuminate\Support\Traits\Macroable;abstract class Connection&#123; use Macroable &#123; __call as macroCall; &#125; /** * The Redis client. * * @var \Redis */ protected $client; /** * The Redis connection name. * * @var string|null */ protected $name; /** * The event dispatcher instance. * * @var \Illuminate\Contracts\Events\Dispatcher */ protected $events; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @param string $method * @return void */ abstract public function createSubscription($channels, Closure $callback, $method = 'subscribe'); /** * Funnel a callback for a maximum number of simultaneous executions. * * @param string $name * @return \Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder */ public function funnel($name) &#123; return new ConcurrencyLimiterBuilder($this, $name); &#125; /** * Throttle a callback for a maximum number of executions over a given duration. * * @param string $name * @return \Illuminate\Redis\Limiters\DurationLimiterBuilder */ public function throttle($name) &#123; return new DurationLimiterBuilder($this, $name); &#125; /** * Get the underlying Redis client. * * @return mixed */ public function client() &#123; return $this-&gt;client; &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @return void */ public function subscribe($channels, Closure $callback) &#123; return $this-&gt;createSubscription($channels, $callback, __FUNCTION__); &#125; /** * Subscribe to a set of given channels with wildcards. * * @param array|string $channels * @param \Closure $callback * @return void */ public function psubscribe($channels, Closure $callback) &#123; return $this-&gt;createSubscription($channels, $callback, __FUNCTION__); &#125; /** * Run a command against the Redis database. * * @param string $method * @param array $parameters * @return mixed */ public function command($method, array $parameters = []) &#123; $start = microtime(true); $result = $this-&gt;client-&gt;&#123;$method&#125;(...$parameters); $time = round((microtime(true) - $start) * 1000, 2); if (isset($this-&gt;events)) &#123; $this-&gt;event(new CommandExecuted($method, $parameters, $time, $this)); &#125; return $result; &#125; /** * Fire the given event if possible. * * @param mixed $event * @return void */ protected function event($event) &#123; if (isset($this-&gt;events)) &#123; $this-&gt;events-&gt;dispatch($event); &#125; &#125; /** * Register a Redis command listener with the connection. * * @param \Closure $callback * @return void */ public function listen(Closure $callback) &#123; if (isset($this-&gt;events)) &#123; $this-&gt;events-&gt;listen(CommandExecuted::class, $callback); &#125; &#125; /** * Get the connection name. * * @return string|null */ public function getName() &#123; return $this-&gt;name; &#125; /** * Set the connections name. * * @param string $name * @return $this */ public function setName($name) &#123; $this-&gt;name = $name; return $this; &#125; /** * Get the event dispatcher used by the connection. * * @return \Illuminate\Contracts\Events\Dispatcher */ public function getEventDispatcher() &#123; return $this-&gt;events; &#125; /** * Set the event dispatcher instance on the connection. * * @param \Illuminate\Contracts\Events\Dispatcher $events * @return void */ public function setEventDispatcher(Dispatcher $events) &#123; $this-&gt;events = $events; &#125; /** * Unset the event dispatcher instance on the connection. * * @return void */ public function unsetEventDispatcher() &#123; $this-&gt;events = null; &#125; /** * Pass other method calls down to the underlying client. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (static::hasMacro($method)) &#123; return $this-&gt;macroCall($method, $parameters); &#125; return $this-&gt;command($method, $parameters); &#125;&#125; Illuminate\Redis\Connections\PhpRedisConnection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Redis\Connection as ConnectionContract;use Illuminate\Support\Str;use Redis;use RedisCluster;use RedisException;/** * @mixin \Redis */class PhpRedisConnection extends Connection implements ConnectionContract&#123; /** * The connection creation callback. * * @var callable */ protected $connector; /** * Create a new PhpRedis connection. * * @param \Redis $client * @param callable|null $connector * @return void */ public function __construct($client, callable $connector = null) &#123; $this-&gt;client = $client; $this-&gt;connector = $connector; &#125; /** * Returns the value of the given key. * * @param string $key * @return string|null */ public function get($key) &#123; $result = $this-&gt;command('get', [$key]); return $result !== false ? $result : null; &#125; /** * Get the values of all the given keys. * * @param array $keys * @return array */ public function mget(array $keys) &#123; return array_map(function ($value) &#123; return $value !== false ? $value : null; &#125;, $this-&gt;command('mget', [$keys])); &#125; /** * Set the string value in argument as value of the key. * * @param string $key * @param mixed $value * @param string|null $expireResolution * @param int|null $expireTTL * @param string|null $flag * @return bool */ public function set($key, $value, $expireResolution = null, $expireTTL = null, $flag = null) &#123; return $this-&gt;command('set', [ $key, $value, $expireResolution ? [$flag, $expireResolution =&gt; $expireTTL] : null, ]); &#125; /** * Set the given key if it doesn't exist. * * @param string $key * @param string $value * @return int */ public function setnx($key, $value) &#123; return (int) $this-&gt;command('setnx', [$key, $value]); &#125; /** * Get the value of the given hash fields. * * @param string $key * @param mixed $dictionary * @return array */ public function hmget($key, ...$dictionary) &#123; if (count($dictionary) === 1) &#123; $dictionary = $dictionary[0]; &#125; return array_values($this-&gt;command('hmget', [$key, $dictionary])); &#125; /** * Set the given hash fields to their respective values. * * @param string $key * @param mixed $dictionary * @return int */ public function hmset($key, ...$dictionary) &#123; if (count($dictionary) === 1) &#123; $dictionary = $dictionary[0]; &#125; else &#123; $input = collect($dictionary); $dictionary = $input-&gt;nth(2)-&gt;combine($input-&gt;nth(2, 1))-&gt;toArray(); &#125; return $this-&gt;command('hmset', [$key, $dictionary]); &#125; /** * Set the given hash field if it doesn't exist. * * @param string $hash * @param string $key * @param string $value * @return int */ public function hsetnx($hash, $key, $value) &#123; return (int) $this-&gt;command('hsetnx', [$hash, $key, $value]); &#125; /** * Removes the first count occurrences of the value element from the list. * * @param string $key * @param int $count * @param mixed $value * @return int|false */ public function lrem($key, $count, $value) &#123; return $this-&gt;command('lrem', [$key, $value, $count]); &#125; /** * Removes and returns the first element of the list stored at key. * * @param mixed $arguments * @return array|null */ public function blpop(...$arguments) &#123; $result = $this-&gt;command('blpop', $arguments); return empty($result) ? null : $result; &#125; /** * Removes and returns the last element of the list stored at key. * * @param mixed $arguments * @return array|null */ public function brpop(...$arguments) &#123; $result = $this-&gt;command('brpop', $arguments); return empty($result) ? null : $result; &#125; /** * Removes and returns a random element from the set value at key. * * @param string $key * @param int|null $count * @return mixed|false */ public function spop($key, $count = 1) &#123; return $this-&gt;command('spop', [$key, $count]); &#125; /** * Add one or more members to a sorted set or update its score if it already exists. * * @param string $key * @param mixed $dictionary * @return int */ public function zadd($key, ...$dictionary) &#123; if (is_array(end($dictionary))) &#123; foreach (array_pop($dictionary) as $member =&gt; $score) &#123; $dictionary[] = $score; $dictionary[] = $member; &#125; &#125; $options = []; foreach (array_slice($dictionary, 0, 3) as $i =&gt; $value) &#123; if (in_array($value, ['nx', 'xx', 'ch', 'incr', 'NX', 'XX', 'CH', 'INCR'], true)) &#123; $options[] = $value; unset($dictionary[$i]); &#125; &#125; return $this-&gt;command('zadd', array_merge([$key], [$options], array_values($dictionary))); &#125; /** * Return elements with score between $min and $max. * * @param string $key * @param mixed $min * @param mixed $max * @param array $options * @return array */ public function zrangebyscore($key, $min, $max, $options = []) &#123; if (isset($options['limit'])) &#123; $options['limit'] = [ $options['limit']['offset'], $options['limit']['count'], ]; &#125; return $this-&gt;command('zRangeByScore', [$key, $min, $max, $options]); &#125; /** * Return elements with score between $min and $max. * * @param string $key * @param mixed $min * @param mixed $max * @param array $options * @return array */ public function zrevrangebyscore($key, $min, $max, $options = []) &#123; if (isset($options['limit'])) &#123; $options['limit'] = [ $options['limit']['offset'], $options['limit']['count'], ]; &#125; return $this-&gt;command('zRevRangeByScore', [$key, $min, $max, $options]); &#125; /** * Find the intersection between sets and store in a new set. * * @param string $output * @param array $keys * @param array $options * @return int */ public function zinterstore($output, $keys, $options = []) &#123; return $this-&gt;command('zinterstore', [$output, $keys, $options['weights'] ?? null, $options['aggregate'] ?? 'sum', ]); &#125; /** * Find the union between sets and store in a new set. * * @param string $output * @param array $keys * @param array $options * @return int */ public function zunionstore($output, $keys, $options = []) &#123; return $this-&gt;command('zunionstore', [$output, $keys, $options['weights'] ?? null, $options['aggregate'] ?? 'sum', ]); &#125; /** * Execute commands in a pipeline. * * @param callable|null $callback * @return \Redis|array */ public function pipeline(callable $callback = null) &#123; $pipeline = $this-&gt;client()-&gt;pipeline(); return is_null($callback) ? $pipeline : tap($pipeline, $callback)-&gt;exec(); &#125; /** * Execute commands in a transaction. * * @param callable|null $callback * @return \Redis|array */ public function transaction(callable $callback = null) &#123; $transaction = $this-&gt;client()-&gt;multi(); return is_null($callback) ? $transaction : tap($transaction, $callback)-&gt;exec(); &#125; /** * Evaluate a LUA script serverside, from the SHA1 hash of the script instead of the script itself. * * @param string $script * @param int $numkeys * @param mixed $arguments * @return mixed */ public function evalsha($script, $numkeys, ...$arguments) &#123; return $this-&gt;command('evalsha', [ $this-&gt;script('load', $script), $arguments, $numkeys, ]); &#125; /** * Evaluate a script and return its result. * * @param string $script * @param int $numberOfKeys * @param dynamic $arguments * @return mixed */ public function eval($script, $numberOfKeys, ...$arguments) &#123; return $this-&gt;command('eval', [$script, $arguments, $numberOfKeys]); &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @return void */ public function subscribe($channels, Closure $callback) &#123; $this-&gt;client-&gt;subscribe((array) $channels, function ($redis, $channel, $message) use ($callback) &#123; $callback($message, $channel); &#125;); &#125; /** * Subscribe to a set of given channels with wildcards. * * @param array|string $channels * @param \Closure $callback * @return void */ public function psubscribe($channels, Closure $callback) &#123; $this-&gt;client-&gt;psubscribe((array) $channels, function ($redis, $pattern, $channel, $message) use ($callback) &#123; $callback($message, $channel); &#125;); &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @param string $method * @return void */ public function createSubscription($channels, Closure $callback, $method = 'subscribe') &#123; // &#125; /** * Flush the selected Redis database. * * @return void */ public function flushdb() &#123; if (! $this-&gt;client instanceof RedisCluster) &#123; return $this-&gt;command('flushdb'); &#125; foreach ($this-&gt;client-&gt;_masters() as [$host, $port]) &#123; tap(new Redis)-&gt;connect($host, $port)-&gt;flushDb(); &#125; &#125; /** * Execute a raw command. * * @param array $parameters * @return mixed */ public function executeRaw(array $parameters) &#123; return $this-&gt;command('rawCommand', $parameters); &#125; /** * Run a command against the Redis database. * * @param string $method * @param array $parameters * @return mixed */ public function command($method, array $parameters = []) &#123; try &#123; return parent::command($method, $parameters); &#125; catch (RedisException $e) &#123; if (Str::contains($e-&gt;getMessage(), 'went away')) &#123; $this-&gt;client = $this-&gt;connector ? call_user_func($this-&gt;connector) : $this-&gt;client; &#125; throw $e; &#125; &#125; /** * Disconnects from the Redis instance. * * @return void */ public function disconnect() &#123; $this-&gt;client-&gt;close(); &#125; /** * Apply prefix to the given key if necessary. * * @param string $key * @return string */ private function applyPrefix($key) &#123; $prefix = (string) $this-&gt;client-&gt;getOption(Redis::OPT_PREFIX); return $prefix.$key; &#125; /** * Pass other method calls down to the underlying client. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return parent::__call(strtolower($method), $parameters); &#125;&#125; Illuminate\Redis\Connections\PredisConnection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Redis\Connection as ConnectionContract;use Predis\Command\ServerFlushDatabase;use Predis\Connection\Aggregate\ClusterInterface;/** * @mixin \Predis\Client * @deprecated Predis is no longer maintained by its original author */class PredisConnection extends Connection implements ConnectionContract&#123; /** * The Predis client. * * @var \Predis\Client */ protected $client; /** * Create a new Predis connection. * * @param \Predis\Client $client * @return void */ public function __construct($client) &#123; $this-&gt;client = $client; &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @param string $method * @return void */ public function createSubscription($channels, Closure $callback, $method = 'subscribe') &#123; $loop = $this-&gt;pubSubLoop(); call_user_func_array([$loop, $method], (array) $channels); foreach ($loop as $message) &#123; if ($message-&gt;kind === 'message' || $message-&gt;kind === 'pmessage') &#123; call_user_func($callback, $message-&gt;payload, $message-&gt;channel); &#125; &#125; unset($loop); &#125; /** * Flush the selected Redis database. * * @return void */ public function flushdb() &#123; if (! $this-&gt;client-&gt;getConnection() instanceof ClusterInterface) &#123; return $this-&gt;command('flushdb'); &#125; foreach ($this-&gt;getConnection() as $node) &#123; $node-&gt;executeCommand(new ServerFlushDatabase); &#125; &#125;&#125; RedisManager Illuminate\Redis\RedisManager.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260&lt;?phpnamespace Illuminate\Redis;use Closure;use Illuminate\Contracts\Redis\Factory;use Illuminate\Redis\Connections\Connection;use Illuminate\Redis\Connectors\PhpRedisConnector;use Illuminate\Redis\Connectors\PredisConnector;use Illuminate\Support\ConfigurationUrlParser;use InvalidArgumentException;/** * @mixin \Illuminate\Redis\Connections\Connection */class RedisManager implements Factory&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The name of the default driver. * * @var string */ protected $driver; /** * The registered custom driver creators. * * @var array */ protected $customCreators = []; /** * The Redis server configurations. * * @var array */ protected $config; /** * The Redis connections. * * @var mixed */ protected $connections; /** * Indicates whether event dispatcher is set on connections. * * @var bool */ protected $events = false; /** * Create a new Redis manager instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @param string $driver * @param array $config * @return void */ public function __construct($app, $driver, array $config) &#123; $this-&gt;app = $app; $this-&gt;driver = $driver; $this-&gt;config = $config; &#125; /** * Get a Redis connection by name. * * @param string|null $name * @return \Illuminate\Redis\Connections\Connection */ public function connection($name = null) &#123; $name = $name ?: 'default'; if (isset($this-&gt;connections[$name])) &#123; return $this-&gt;connections[$name]; &#125; return $this-&gt;connections[$name] = $this-&gt;configure( $this-&gt;resolve($name), $name ); &#125; /** * Resolve the given connection by name. * * @param string|null $name * @return \Illuminate\Redis\Connections\Connection * * @throws \InvalidArgumentException */ public function resolve($name = null) &#123; $name = $name ?: 'default'; $options = $this-&gt;config['options'] ?? []; if (isset($this-&gt;config[$name])) &#123; return $this-&gt;connector()-&gt;connect( $this-&gt;parseConnectionConfiguration($this-&gt;config[$name]), $options ); &#125; if (isset($this-&gt;config['clusters'][$name])) &#123; return $this-&gt;resolveCluster($name); &#125; throw new InvalidArgumentException("Redis connection [&#123;$name&#125;] not configured."); &#125; /** * Resolve the given cluster connection by name. * * @param string $name * @return \Illuminate\Redis\Connections\Connection */ protected function resolveCluster($name) &#123; return $this-&gt;connector()-&gt;connectToCluster( array_map(function ($config) &#123; return $this-&gt;parseConnectionConfiguration($config); &#125;, $this-&gt;config['clusters'][$name]), $this-&gt;config['clusters']['options'] ?? [], $this-&gt;config['options'] ?? [] ); &#125; /** * Configure the given connection to prepare it for commands. * * @param \Illuminate\Redis\Connections\Connection $connection * @param string $name * @return \Illuminate\Redis\Connections\Connection */ protected function configure(Connection $connection, $name) &#123; $connection-&gt;setName($name); if ($this-&gt;events &amp;&amp; $this-&gt;app-&gt;bound('events')) &#123; $connection-&gt;setEventDispatcher($this-&gt;app-&gt;make('events')); &#125; return $connection; &#125; /** * Get the connector instance for the current driver. * * @return \Illuminate\Contracts\Redis\Connector */ protected function connector() &#123; $customCreator = $this-&gt;customCreators[$this-&gt;driver] ?? null; if ($customCreator) &#123; return $customCreator(); &#125; switch ($this-&gt;driver) &#123; case 'predis': return new PredisConnector; case 'phpredis': return new PhpRedisConnector; &#125; &#125; /** * Parse the Redis connection configuration. * * @param mixed $config * @return array */ protected function parseConnectionConfiguration($config) &#123; $parsed = (new ConfigurationUrlParser)-&gt;parseConfiguration($config); return array_filter($parsed, function ($key) &#123; return ! in_array($key, ['driver', 'username'], true); &#125;, ARRAY_FILTER_USE_KEY); &#125; /** * Return all of the created connections. * * @return array */ public function connections() &#123; return $this-&gt;connections; &#125; /** * Enable the firing of Redis command events. * * @return void */ public function enableEvents() &#123; $this-&gt;events = true; &#125; /** * Disable the firing of Redis command events. * * @return void */ public function disableEvents() &#123; $this-&gt;events = false; &#125; /** * Set the default driver. * * @param string $driver * @return void */ public function setDriver($driver) &#123; $this-&gt;driver = $driver; &#125; /** * Register a custom driver creator Closure. * * @param string $driver * @param \Closure $callback * @return $this */ public function extend($driver, Closure $callback) &#123; $this-&gt;customCreators[$driver] = $callback-&gt;bindTo($this, $this); return $this; &#125; /** * Pass methods onto the default Redis connection. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return $this-&gt;connection()-&gt;&#123;$method&#125;(...$parameters); &#125;&#125; RedisServiceProvider Illuminate\Redis\RedisServiceProvider.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Illuminate\Redis;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\Arr;use Illuminate\Support\ServiceProvider;class RedisServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('redis', function ($app) &#123; $config = $app-&gt;make('config')-&gt;get('database.redis', []); return new RedisManager($app, Arr::pull($config, 'client', 'phpredis'), $config); &#125;); $this-&gt;app-&gt;bind('redis.connection', function ($app) &#123; return $app['redis']-&gt;connection(); &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return ['redis', 'redis.connection']; &#125;&#125; Application Illuminate\Foundation\Application.php 12345678910111213141516171819202122namespace Illuminate\Foundation;class Application extends Container&#123; /** * Register the core class aliases in the container. * * @return void */ public function registerCoreContainerAliases() &#123; foreach ([ 'redis' =&gt; [\Illuminate\Redis\RedisManager::class, \Illuminate\Contracts\Redis\Factory::class], 'redis.connection' =&gt; [\Illuminate\Redis\Connections\Connection::class, \Illuminate\Contracts\Redis\Connection::class], ] as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Log]]></title>
    <url>%2F2020%2F05%2F10%2FLaravel-Log%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 源码 Illuminate\Log\Logger.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;?phpnamespace Illuminate\Log;use Closuore;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Contracts\Support\Arrayable;use Illuminate\Contracts\Support\Jsonable;use Illuminate\Log\Events\MessageLogged;use Psr\Log\LoggerInterface;use RuntimeException;class Logger implements LoggerInterface&#123; /** * The underlying logger implementation. * * @var \Psr\Log\LoggerInterface */ protected $logger; /** * The event dispatcher instance. * * @var \Illuminate\Contracts\Events\Dispatcher|null */ protected $dispatcher; /** * Create a new log writer instance. * * @param \Psr\Log\LoggerInterface $logger * @param \Illuminate\Contracts\Events\Dispatcher|null $dispatcher * @return void */ public function __construct(LoggerInterface $logger, Dispatcher $dispatcher = null) &#123; $this-&gt;logger = $logger; $this-&gt;dispatcher = $dispatcher; &#125; /** * Log an emergency message to the logs. * * @param string $message * @param array $context * @return void */ public function emergency($message, array $context = []) &#123; $this-&gt;writeLog(__FUNCTION__, $message, $context); &#125; /** * Log a message to the logs. * * @param string $level * @param string $message * @param array $context * @return void */ public function log($level, $message, array $context = []) &#123; $this-&gt;writeLog($level, $message, $context); &#125; /** * Dynamically pass log calls into the writer. * * @param string $level * @param string $message * @param array $context * @return void */ public function write($level, $message, array $context = []) &#123; $this-&gt;writeLog($level, $message, $context); &#125; /** * Write a message to the log. * * @param string $level * @param string $message * @param array $context * @return void */ protected function writeLog($level, $message, $context) &#123; $this-&gt;logger-&gt;&#123;$level&#125;($message = $this-&gt;formatMessage($message), $context); $this-&gt;fireLogEvent($level, $message, $context); &#125; /** * Register a new callback handler for when a log event is triggered. * * @param \Closure $callback * @return void * * @throws \RuntimeException */ public function listen(Closure $callback) &#123; if (! isset($this-&gt;dispatcher)) &#123; throw new RuntimeException('Events dispatcher has not been set.'); &#125; $this-&gt;dispatcher-&gt;listen(MessageLogged::class, $callback); &#125; /** * Fires a log event. * * @param string $level * @param string $message * @param array $context * @return void */ protected function fireLogEvent($level, $message, array $context = []) &#123; // 如果设置了事件分配器，则将参数传递给日志侦听器。 // 这些对于构建概要分析器或其他工具（在给定的“请求”周期内汇总所有日志消息）很有用。 if (isset($this-&gt;dispatcher)) &#123; $this-&gt;dispatcher-&gt;dispatch(new MessageLogged($level, $message, $context)); &#125; &#125; /** * Format the parameters for the logger. * * @param mixed $message * @return mixed */ protected function formatMessage($message) &#123; if (is_array($message)) &#123; return var_export($message, true); &#125; elseif ($message instanceof Jsonable) &#123; return $message-&gt;toJson(); &#125; elseif ($message instanceof Arrayable) &#123; return var_export($message-&gt;toArray(), true); &#125; return $message; &#125; /** * Get the underlying logger implementation. * * @return \Psr\Log\LoggerInterface */ public function getLogger() &#123; return $this-&gt;logger; &#125; /** * Get the event dispatcher instance. * * @return \Illuminate\Contracts\Events\Dispatcher */ public function getEventDispatcher() &#123; return $this-&gt;dispatcher; &#125; /** * Set the event dispatcher instance. * * @param \Illuminate\Contracts\Events\Dispatcher $dispatcher * @return void */ public function setEventDispatcher(Dispatcher $dispatcher) &#123; $this-&gt;dispatcher = $dispatcher; &#125; /** * Dynamically proxy method calls to the underlying logger. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return $this-&gt;logger-&gt;&#123;$method&#125;(...$parameters); &#125;&#125; Illuminate\Mail\Events\MessageSending.php 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\Mail\Events;class MessageSending&#123; /** * The Swift message instance. * * @var \Swift_Message */ public $message; /** * The message data. * * @var array */ public $data; /** * Create a new event instance. * * @param \Swift_Message $message * @param array $data * @return void */ public function __construct($message, $data = []) &#123; $this-&gt;data = $data; $this-&gt;message = $message; &#125;&#125; Illuminate\Log\ParsesLogConfiguration.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960namespace Illuminate\Log;use InvalidArgumentException;use Monolog\Logger as Monolog;trait ParsesLogConfiguration&#123; /** * The Log levels. * * @var array */ protected $levels = [ 'debug' =&gt; Monolog::DEBUG, 'info' =&gt; Monolog::INFO, 'notice' =&gt; Monolog::NOTICE, 'warning' =&gt; Monolog::WARNING, 'error' =&gt; Monolog::ERROR, 'critical' =&gt; Monolog::CRITICAL, 'alert' =&gt; Monolog::ALERT, 'emergency' =&gt; Monolog::EMERGENCY, ]; /** * Get fallback log channel name. * * @return string */ abstract protected function getFallbackChannelName(); /** * Parse the string level into a Monolog constant. * * @param array $config * @return int * * @throws \InvalidArgumentException */ protected function level(array $config) &#123; $level = $config['level'] ?? 'debug'; if (isset($this-&gt;levels[$level])) &#123; return $this-&gt;levels[$level]; &#125; throw new InvalidArgumentException('Invalid log level.'); &#125; /** * Extract the log channel from the given configuration. * * @param array $config * @return string */ protected function parseChannel(array $config) &#123; return $config['name'] ?? $this-&gt;getFallbackChannelName(); &#125;&#125; Illuminate\Log\LogServiceProvider 1234567891011121314151617181920&lt;?phpnamespace Illuminate\Log;use Illuminate\Support\ServiceProvider;class LogServiceProvider extends ServiceProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('log', function ($app) &#123; return new LogManager($app); &#125;); &#125;&#125; Illuminate\Log\LogManager.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?phpnamespace Illuminate\Log;use Closure;use Illuminate\Support\Str;use InvalidArgumentException;use Monolog\Formatter\LineFormatter;use Monolog\Handler\ErrorLogHandler;use Monolog\Handler\FormattableHandlerInterface;use Monolog\Handler\HandlerInterface;use Monolog\Handler\RotatingFileHandler;use Monolog\Handler\SlackWebhookHandler;use Monolog\Handler\StreamHandler;use Monolog\Handler\SyslogHandler;use Monolog\Handler\WhatFailureGroupHandler;use Monolog\Logger as Monolog;use Psr\Log\LoggerInterface;use Throwable;class LogManager implements LoggerInterface&#123; use ParsesLogConfiguration; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The array of resolved channels. * * @var array */ protected $channels = []; /** * The registered custom driver creators. * * @var array */ protected $customCreators = []; /** * The standard date format to use when writing logs. * * @var string */ protected $dateFormat = 'Y-m-d H:i:s'; /** * Create a new Log manager instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125; /** * Register a custom driver creator Closure. * * @param string $driver * @param \Closure $callback * @return $this */ public function extend($driver, Closure $callback) &#123; $this-&gt;customCreators[$driver] = $callback-&gt;bindTo($this, $this); return $this; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的又一神器-锁]]></title>
    <url>%2F2020%2F05%2F09%2FMySQL%E7%9A%84%E5%8F%88%E4%B8%80%E7%A5%9E%E5%99%A8-%E9%94%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是锁锁的概述对于MySQL来说，锁是一个很重要的特性，数据库的锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性，这样才能保证在高并发的情况下，访问数据库的时候，数据不会出现问题。 锁的两个概念在数据库中，lock和latch都可以称为锁，但是意义却不同。 Latch一般称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差，在InnoDB引擎中，Latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。 Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。 InnoDB存储引擎中的锁锁的粒度在数据库中，锁的粒度的不同可以分为表锁、页锁、行锁，这些锁的粒度之间也是会发生升级的，锁升级的意思就是讲当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁，下面分别介绍一下这三种锁的粒度（参考自博客：https://blog.csdn.net/baolingye/article/details/102506072）。 表锁表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。 当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。 使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 页锁页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源 颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。 使用页级锁定的主要是BerkeleyDB存储引擎。 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 行锁行级锁定最大的特点就是锁定对象的粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。 虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 比较表锁我们可以发现，这两种锁的特点基本都是相反的，而从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 MySQL不同引擎支持的锁的粒度 锁的类型InnoDB存储引擎中存在着不同类型的锁，下面一一介绍一下。 S or X（共享锁、排他锁） 数据的操作其实只有两种，也就是读和写，而数据库在实现锁时，也会对这两种操作使用不同的锁；InnoDB实现了标准的行级锁，也就是共享锁（Shared Lock）和互斥锁（Exclusive Lock）。 共享锁（读锁）（S Lock），允许事务读一行数据。 排他锁（写锁）（X Lock），允许事务删除或更新一行数据。 IS or IX（共享、排他）意向锁 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB存储引擎支持一种额外的锁方式，就称为意向锁，意向锁在InnoDB中是表级锁，意向锁分为： 意向共享锁：表达一个事务想要获取一张表中某几行的共享锁。 意向排他锁：表达一个事务想要获取一张表中某几行的排他锁。 另外，这些锁之间的并不是一定可以共存的，有些锁之间是不兼容的，所谓兼容性就是指事务 A 获得一个某行某种锁之后，事务B同样的在这个行上尝试获取某种锁，如果能立即获取，则称锁兼容，反之叫冲突。 下面我们再看一下这两种锁的兼容性。 S or X（共享锁、排他锁）的兼容性 IS or IX（共享、排他）意向锁的兼容性 前面小结这里用一个思维导图把前面的概念做一个小结。 一致性非锁定读和一致性锁定读一致性锁定读（Locking Reads）在一个事务中查询数据时，普通的SELECT语句不会对查询的数据进行加锁，其他事务仍可以对查询的数据执行更新和删除操作。因此，InnoDB提供了两种类型的锁定读来保证额外的安全性： SELECT … LOCK IN SHARE MODE SELECT … FOR UPDATE SELECT … LOCK IN SHARE MODE：对读取的行添加S锁，其他事物可以对这些行添加S锁，若添加X锁，则会被阻塞。 SELECT … FOR UPDATE：会对查询的行及相关联的索引记录加X锁，其他事务请求的S锁或X锁都会被阻塞。当事务提交或回滚后，通过这两个语句添加的锁都会被释放。注意：只有在自动提交被禁用时，SELECT FOR UPDATE才可以锁定行，若开启自动提交，则匹配的行不会被锁定。 一致性非锁定读一致性非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过多版本控制（MVVC）读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。所以，非锁定读机制大大提高了数据库的并发性。 一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。 然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。 下面我们通过一个简单的例子来说明一下这两种方式的区别。 首先创建一张表; 插入一条数据；1insert into lock_test values(1); 查看隔离级别；1select @@tx_isolation; 下面分为两种事务进行操作。 在REPEATABLE READ事务隔离级别下； 在REPEATABLE READ事务隔离级别下，读取事务开始时的行数据，所以当会话B修改了数据之后，通过以前的查询，还是可以查询到数据的。 在READ COMMITTED事务隔离级别下; 在READ COMMITTED事务隔离级别下，读取该行版本最新的一个快照数据，所以，由于B会话修改了数据，并且提交了事务，所以，A读取不到数据了。 行锁的算法InnoDB存储引擎有3种行锁的算法，其分别是： Record Lock：单个行记录上的锁。 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。 Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。 Record Lock：总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。 Next-Key Lock：结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。举个例子10，20，30，那么该索引可能被Next-Key Locking的区间为： 除了Next-Key Locking，还有Previous-Key Locking技术，这种技术跟Next-Key Lock正好相反，锁定的区间是区间范围和前一个值。同样上述的值，使用Previous-Key Locking技术，那么可锁定的区间为： 不是所有索引都会加上Next-key Lock的，这里有一种特殊的情况，在查询的列是唯一索引（包含主键索引）的情况下，Next-key Lock会降级为Record Lock。 接下来，我们来通过一个例子解释一下。 12345678910CREATE TABLE test ( x INT, y INT, PRIMARY KEY(x), // x是主键索引 KEY(y) // y是普通索引);INSERT INTO test select 3, 2;INSERT INTO test select 5, 3;INSERT INTO test select 7, 6;INSERT INTO test select 10, 8; 我们现在会话A中执行如下语句；1SELECT * FROM test WHERE y = 3 FOR UPDATE 我们分析一下这时候的加锁情况。 对于主键x 辅助索引y 用户可以通过以下两种方式来显示的关闭Gap Lock： 将事务的隔离级别设为 READ COMMITED。 将参数innodb_locks_unsafe_for_binlog设置为1。 Gap Lock的作用：是为了阻止多个事务将记录插入到同一个范围内，设计它的目的是用来解决Phontom Problem（幻读问题）。在MySQL默认的隔离级别（Repeatable Read）下，InnoDB就是使用它来解决幻读问题。 幻读：是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL可能会返回之前不存在的行，也就是第一次执行和第二次执行期间有其他事务往里插入了新的行。 锁带来的问题脏读脏读：在不同的事务下，当前事务可以读到另外事务未提交的数据。另外我们需要注意的是默认的MySQL隔离级别是REPEATABLE READ是不会发生脏读的，脏读发生的条件是需要事务的隔离级别为READ UNCOMMITTED，所以如果出现脏读，可能就是这种隔离级别导致的。 下面我们通过一个例子看一下。 从上面这个例子可以看出，当我们的事务的隔离级别为READ UNCOMMITTED的时候，在会话A还没有提交时，会话B就能够查询到会话A没有提交的数据。 不可重复读不可重复读：是指在一个事务内多次读取同一集合的数据，但是多次读到的数据是不一样的，这就违反了数据库事务的一致性的原则。但是，这跟脏读还是有区别的，脏读的数据是没有提交的，但是不可重复读的数据是已经提交的数据。 我们通过下面的例子来看一下这种问题的发生。 从上面的例子可以看出，在A的一次会话中，由于会话B插入了数据，导致两次查询的结果不一致，所以就出现了不可重复读的问题。 我们需要注意的是不可重复读读取的数据是已经提交的数据，事务的隔离级别为READ COMMITTED，这种问题我们是可以接受的。 如果我们需要避免不可重复读的问题的发生，那么我们可以使用Next-Key Lock算法（设置事务的隔离级别为READ REPEATABLE）来避免，在MySQL中，不可重复读问题就是Phantom Problem，也就是幻像问题。 丢失更新丢失更新：指的是一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致。在当前数据库的任何隔离级别下都不会导致丢失更新问题，要出现这个问题，在多用户计算机系统环境下有可能出现这种问题。 如何避免丢失更新的问题呢，我们只需要让事务的操作变成串行化，不要并行执行就可以。 我们一般使用SELECT … FOR UPDATE语句，给操作加上一个排他X锁。 小结这里我们做一个小结，主要是在不同的事务的隔离级别下出现的问题的对照，这样就更加清晰了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是红黑树？]]></title>
    <url>%2F2020%2F05%2F08%2F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 红黑树是为了解决二叉查找树多次插入新节点而导致的不平衡。怎么理解？ 红黑树在什么情况下需要变色？什么情况下需要旋转？ 二叉查找树要学习红黑树，需要先来理解二叉查找树（Binary Search Tree）。 二叉查找树（BST）具备什么特性呢？ 1.左子树上所有结点的值均小于或等于它的根结点的值。 2.右子树上所有结点的值均大于或等于它的根结点的值。 3.左、右子树也分别为二叉排序树。 下图中这棵树，就是一颗典型的二叉查找树： 这样的数据结构有什么好处呢？我们来试着查找一下值为10的节点。 1.查看根节点9： 2.由于10 &gt; 9，因此查看右孩子13： 3.由于10 &lt; 13，因此查看左孩子11： 4.由于10 &lt; 11，因此查看左孩子10，发现10正是要查找的节点： 这种方式正是二分查找的思想，查找所需的最大次数等同于二叉查找树的高度。 在插入节点的时候也是利用类似的方法，通过一层一层比较大小，找到新节点适合插入的位置。 二叉查找树是个强大的数据结构，但仍然有存在它的缺陷。 缺陷体现在插入新节点的时候。让我们来看看下面这种情形： 假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12： 接下来我们依次插入如下五个节点：7，6，5，4，3。依照二叉查找树的特性，结果会变成什么样呢？ 好好的二叉树变成瘸子了。这样的形态虽然也符合二叉查找树的特性，但是查找的性能大打折扣，几乎变成了线性。 如何解决二叉查找树多次插入新节点而导致的不平衡呢？我们的主角[红黑树]应运而生了。 红黑树红黑树（Red Black Tree）是一种自平衡的二叉查找树。除了符合二叉查找树的基本特性外，它还具有下列的附加特性： 1.节点是红色或黑色。 2.根节点是黑色。 3.每个叶子节点都是黑色的空节点（NIL节点）。 4.每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点） 5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 下图中这棵树，就是一颗典型的红黑树： 因为这些规则限制，才保证了红黑树的自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍。 当插入或删除节点的时候，红黑权的规则有可能被打破。这时候就需要做出一些调整，来继续维持我们的规则。 什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的例子： 1.向原红黑树插入值为14的新节点： 由于父节点15是黑色节点，因此这种情况并不会破坏红黑树的规则，无需做任何调整。 2.向原红黑树插入值为21的新节点： 由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。 那么，我们需要做出怎样的调整，才能保证一颗红黑树始终是红黑树呢？ 调整有两种方法: [变色]和[旋转]。而旋转又分成两种形式：[左旋转]和[右旋转]。 变色： 为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。 下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色： 但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色： 此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色： 左旋转： 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图： 图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。 右旋转： 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图： 图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。 究竟什么时候用到变色，什么时候用到旋转呢？ 红黑树的插入和删除包含很多种情况，每一种情况都有不同的处理方式。在这里我们举一个典型例子，大家体会一下。 我们以刚才插入节点21的情况为例： 首先，我们需要做的是变色，把节点25及其下方的节点变色： 此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。 变色已无法解决问题，我们把节点13看做X，把节点17看做Y，像刚才的示意图那样进行左旋转： 由于根节点必须是黑色节点，所以需要变色，变色结果如下： 这样就结束了吗？并没有。因为其中两条路径（17 -&gt; 8 -&gt; 6 -&gt; NIL）的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。 这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行右旋转： 最后根据规则来进行变色： 如此一来，我们的红黑树变得重新符合规则。这一个例子的调整过程比较复杂，经历了如下步骤： 变色 -&gt; 左旋转 -&gt; 变色 -&gt; 右旋转 -&gt; 变色 红黑树的应用有很多，其中JDK的集合类TreeMap和TreeSet底层就是红黑树实现的。在Java8中，连HashMap也用到了红黑树。 几点说明： 1.关于红黑树自平衡的调整，插入和删除节点的时候都涉及到很多种Case，由于篇幅原因无法展开来一一列举，有兴趣的朋友可以参考维基百科，里面讲的非常清晰。 2.漫画中红黑树调整过程的示例是一种比较复杂的情形，没太看明白的小伙伴也不必钻牛角尖，关键要懂得红黑树自平衡调整的主体思想。 PHP实现红黑树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350&lt;?php/** * 红黑树 * 1.节点是红色或黑色 * 2.根是黑色 * 3.所有的叶子节点都是黑色 * 4.每个红色节点必须有两个黑色节点 * 5.从任一节点到其叶子节点的简单路径都包含相同数量的黑色节点 * */class Node&#123; private $id; /** * @var * 1 =&gt; red * 2 =&gt; black */ private $color = 1; private $value = null; public $parent = 0; public $left = 0; public $right = 0; public function __construct($value) &#123; $this-&gt;id = uniqid(); $this-&gt;value = $value; &#125; public function getID() &#123; return $this-&gt;id; &#125; public function getValue() &#123; return $this-&gt;value; &#125; public function setColor($color) &#123; $this-&gt;color = $color; &#125; public function getColor() &#123; return $this-&gt;color; &#125;&#125;class RedBlackTree&#123; public $root = 0; private $nodePool = []; private $nil; public function __construct() &#123; $nilNode = new Node(null); $nilNode-&gt;setColor(2); $this-&gt;addNodeToPool($nilNode-&gt;getID(), $nilNode); $this-&gt;nil = $nilNode-&gt;getID(); $this-&gt;root = $this-&gt;nil; &#125; public function addNodeToPool($id, $object) &#123; $this-&gt;nodePool[$id] = $object; &#125; /** * @param $id * @return Node */ public function getNodeFromPool($id) &#123; return isset($this-&gt;nodePool[$id]) ? $this-&gt;nodePool[$id] : null; &#125; public function find($value) &#123; $tmp = $this-&gt;getNodeFromPool($this-&gt;root); while (!is_null($tmp-&gt;getValue())) &#123; if ($tmp-&gt;getValue() &gt; $value) &#123; $tmp = $this-&gt;getNodeFromPool($tmp-&gt;left); &#125; else if ($tmp-&gt;getValue() &lt; $value) &#123; $tmp = $this-&gt;getNodeFromPool($tmp-&gt;right); &#125; else &#123; return true; &#125; &#125; return false; &#125; public function walk($nodeID) &#123; var_dump($this-&gt;root); var_dump($this-&gt;nodePool); &#125; public function insert($value) &#123; $tmpNode = $this-&gt;getNodeFromPool($this-&gt;root); $prevNode = $tmpNode; while (!is_null($tmpNode-&gt;getValue())) &#123; $prevNode = $tmpNode; if ($tmpNode-&gt;getValue() &gt; $value) &#123; $tmpNode = $this-&gt;getNodeFromPool($tmpNode-&gt;left); &#125; else &#123; $tmpNode = $this-&gt;getNodeFromPool($tmpNode-&gt;right); &#125; &#125; $newNode = new Node($value); $newNode-&gt;left = $this-&gt;nil; $newNode-&gt;right = $this-&gt;nil; $newNode-&gt;parent = $prevNode-&gt;getID(); $this-&gt;addNodeToPool($newNode-&gt;getID(), $newNode); if (is_null($prevNode-&gt;getValue())) &#123; //第一个节点 $newNode-&gt;setColor(2); $this-&gt;root = $newNode-&gt;getID(); &#125; else if ($prevNode-&gt;getValue() &gt; $newNode-&gt;getValue()) &#123; $prevNode-&gt;left = $newNode-&gt;getID(); &#125; else &#123; $prevNode-&gt;right = $newNode-&gt;getID(); &#125; $this-&gt;insertFix($newNode-&gt;getID()); return true; &#125; protected function insertFix($node) &#123; $tmpNode = $this-&gt;getNodeFromPool($node); while (!is_null($tmpNode-&gt;getValue()) &amp;&amp; ($this-&gt;getNodeFromPool($tmpNode-&gt;parent)-&gt;getColor() == 1)) &#123; $grandP = $this-&gt;getNodeFromPool($this-&gt;getNodeFromPool($tmpNode-&gt;parent)-&gt;parent); $parent = $this-&gt;getNodeFromPool($tmpNode-&gt;parent); if ($tmpNode-&gt;parent == $grandP-&gt;left) &#123; $rightUncle = $this-&gt;getNodeFromPool($grandP-&gt;right); if ($rightUncle-&gt;getColor() == 1) &#123; $parent-&gt;setColor(2); $rightUncle-&gt;setColor(2); $grandP-&gt;setColor(1); $tmpNode = $grandP; &#125; else if ($tmpNode-&gt;getID() == $parent-&gt;right) &#123; $this-&gt;leftRotate($tmpNode-&gt;getID()); $tmpNode = $parent; $this-&gt;rightRotate($tmpNode-&gt;parent, true); &#125; else &#123; $this-&gt;rightRotate($tmpNode-&gt;getID(), true); &#125; &#125; else &#123; $leftUncle = $this-&gt;getNodeFromPool($grandP-&gt;left); if ($leftUncle-&gt;getColor() == 1) &#123; $parent-&gt;setColor(2); $leftUncle-&gt;setColor(2); $grandP-&gt;setColor(1); $tmpNode = $grandP; &#125; else if ($tmpNode-&gt;getID() == $parent-&gt;left) &#123; $this-&gt;rightRotate($tmpNode-&gt;getID()); $tmpNode = $parent; $this-&gt;leftRotate($tmpNode-&gt;parent, true); &#125; else &#123; $this-&gt;leftRotate($tmpNode-&gt;getID(), true); &#125; &#125; $this-&gt;getNodeFromPool($this-&gt;root)-&gt;setColor(2); &#125; &#125; protected function leftRotate($nodeID, $changeColor = false) &#123; $node = $this-&gt;getNodeFromPool($nodeID); $parentID = $node-&gt;parent; $parent = $this-&gt;getNodeFromPool($parentID); $grandPID = $parent-&gt;parent; $grandP = $this-&gt;getNodeFromPool($grandPID); if (is_null($grandP-&gt;getValue())) &#123; $this-&gt;root = $nodeID; &#125; else &#123; if ($grandP-&gt;left == $parentID) &#123; $grandP-&gt;left = $nodeID; &#125; else &#123; $grandP-&gt;right = $nodeID; &#125; &#125; if ($changeColor) &#123; $node-&gt;setColor(2); $parent-&gt;setColor(1); &#125; $leftNode = $this-&gt;getNodeFromPool($node-&gt;left); if (!is_null($leftNode-&gt;getValue())) &#123; $leftNode-&gt;parent = $parentID; &#125; $parent-&gt;right = $node-&gt;left; $parent-&gt;parent = $nodeID; $node-&gt;parent = $grandPID; $node-&gt;left = $parentID; &#125; protected function rightRotate($nodeID, $changeColor = false) &#123; $node = $this-&gt;getNodeFromPool($nodeID); $parentID = $node-&gt;parent; $parent = $this-&gt;getNodeFromPool($parentID); $grandPID = $parent-&gt;parent; $grandP = $this-&gt;getNodeFromPool($grandPID); if (is_null($grandP-&gt;getValue())) &#123; $this-&gt;root = $nodeID; &#125; else &#123; if ($grandP-&gt;left == $parentID) &#123; $grandP-&gt;left = $nodeID; &#125; else &#123; $grandP-&gt;right = $nodeID; &#125; &#125; if ($changeColor) &#123; $node-&gt;setColor(2); $parent-&gt;setColor(1); &#125; $rightNode = $this-&gt;getNodeFromPool($node-&gt;right); if (!is_null($rightNode-&gt;getValue())) &#123; $rightNode-&gt;parent = $parentID; &#125; $parent-&gt;left = $node-&gt;right; $parent-&gt;parent = $nodeID; $node-&gt;parent = $grandPID; $node-&gt;right = $parentID; &#125; public function delete($value) &#123; //TODO &#125;&#125;$test = [12, 550, 300, 20, 1, 50, 44, 34, 24, 25, 79, 11, 21, 1000, 3000, 99];$testH = [12, 550, 300, 20, 1, 50, 44, 34, 24, 25, 79, 19, 99];echo '&lt;pre&gt;';$tree = new RedBlackTree();foreach ($test as $value) &#123; $tree-&gt;insert($value);&#125;foreach ($testH as $v) &#123; if ($tree-&gt;find($v)) &#123; echo 'true;'; &#125; else &#123; echo 'false;'; &#125;&#125;// $tree-&gt;walk($tree-&gt;root);]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解B树B+树算法]]></title>
    <url>%2F2020%2F05%2F07%2F%E5%9B%BE%E8%A7%A3B%E6%A0%91B-%E6%A0%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： B树在介绍B+树之前，先简单的介绍一下B树，这两种数据结构既有相似之处，也有他们的区别，最后，我们也会对比一下这两种数据结构的区别。 B树概念B树也称B-树，它是一颗多路平衡查找树。二叉树我想大家都不陌生，其实，B树和后面讲到的B+树也是从最简单的二叉树变换而来的，并没有什么神秘的地方，下面我们来看看B树的定义。 每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。 所以，根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。 另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。 我们再举个例子来说明一下上面的概念，比如这里有一个5阶的B树，根节点数量范围：1 &lt;= k &lt;= 4，非根节点数量范围：2 &lt;= k &lt;= 4。 下面，我们通过一个插入的例子，讲解一下B树的插入过程，接着，再讲解一下删除关键字的过程。 B树插入插入的时候，我们需要记住一个规则：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。 例子：在5阶B树中，结点最多有4个key，最少有2个key（注意：下面的节点统一用一个节点表示key和value）。 插入18，70，50，40 插入22 插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。 接着插入23，25，39 分裂，得到下面的。 更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。 B树的删除操作B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。 现在有一个初始状态是下面这样的B树，然后进行删除操作。 删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于m/2，这种情况只要直接删除即可。 接着，我们把22删除，这种情况的规则：22是非叶子节点，对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。对于删除22，需要将后继元素24移到被删除的22所在的节点。 此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点。这样就满足要求了。 我们看看操作过程就更加明白了。 接着删除28，删除叶子节点，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点。 移动之后，跟兄弟节点合并。 删除就只有上面的几种情况，根据不同的情况进行删除即可。 上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。 B+树B+树概述B+树其实和B树是非常相似的，我们首先看看相同点。 根节点至少一个元素。 非根节点元素范围：m/2 &lt;= k &lt;= m-1。 不同点 B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 父节点存有右孩子的第一个元素的索引。 下面我们看一个B+树的例子，感受感受它吧！ 插入操作对于插入操作很简单，只需要记住一个技巧即可：当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。 下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。 插入5，10，15，20 插入25，此时元素数量大于4个了，分裂 接着插入26，30，继续分裂 有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。 删除操作对于删除操作是比B树简单一些的，因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key，下面我们看看具体的实例。 初始状态 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引。 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引。 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作。 这样，B+树的删除操作也就完成了，是不是看完之后，觉得非常简单！ B树和B+树总结B+树相对于B树有一些自己的优势，可以归结为下面几点。 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。 所有的叶子节点形成了一个有序链表，更加便于查找。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么MySQL用B+树做索引？]]></title>
    <url>%2F2020%2F05%2F07%2F%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%94%A8B-%E6%A0%91%E5%81%9A%E7%B4%A2%E5%BC%95%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： B+树就是从二叉查找树，平衡二叉树和B树这三种数据结构演化来的。怎么理解？ 聚簇索引和非聚簇索引的区别在于主键。怎么理解？ 平衡二叉树又称AVL树。每个节点的左右子树的高度差不能超过1。怎么理解？ 为什么把尽量多的数据放进磁盘块中？ B+树索引按照存储方式的不同分为聚集索引和非聚集索引。为什么？ 为什么要寻找一种单个节点可以存储多个键值和数据的平衡树？ 索引这个词，相信大多数人已经相当熟悉了，很多人都知道MySQL的索引主要以B+树为主，但是要问到为什么用B+树，恐怕很少有人能把前因后果讲述的很完整。本文就来从头到尾介绍下数据库的索引。 索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在[1,2,3,4]中找到4这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。索引在MySQL数据库中分三类： B+树索引、Hash索引、全文索引 我们今天要介绍的是工作开发中最常接触到的InnoDB存储引擎中的B+树索引。 要介绍B+树索引，就不得不提二叉查找树，平衡二叉树和B树这三种数据结构。B+树就是从他们仨演化来的。 二叉查找树首先，让我们先看一张图。 从图中可以看到，我们为user表（用户信息表）建立了一个二叉查找树的索引。图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。 键对应user表中的id，数据对应user表中的行数据。二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 如果我们需要查找id=12的用户信息，利用我们创建的二叉查找树索引，查找流程如下： 1，将根节点作为当前节点，把12与当前节点的键值10比较，12大于10，接下来我们把当前节点的右子节点作为当前节点。 2，继续把12和当前节点的键值13比较，发现12小于13，把当前节点的左子节点作为当前节点。 3，把12和当前节点的键值12对比，12等于12，满足条件，我们从当前节点中取出data，即id=12,name=xm。 利用二叉查找树我们只需要3次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要6次才能找到。 平衡二叉树上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造： 这个时候可以看到我们的二叉查找树变成了一个链表。 如果我们需要查找id=17的用户信息，我们需要查找7次，也就相当于全表扫描了。 导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。 为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 平衡二叉树又称AVL树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过1。 下面是平衡二叉树和非平衡二叉树的对比： 由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。 平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。 平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 B树因为内存的易失性。一般情况下，我们都会选择将user表中的数据和索引存储在磁盘这种外围设备中。 但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。 如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。 如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。 那说明什么？ 说明每个磁盘块仅仅存储一个键值和数据！ 那如果我们要存储海量的数据呢？ 可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘IO，我们查找数据的效率将会极低！ 为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的B树。 B树（Balance Tree）即为平衡树的意思，下图即是一颗B树。 图中的p节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。图中的每个节点称为页，页就是我们上面说的磁盘块，在MySQL中数据读取的基本单位都是页，所以我们这里叫做页更符合MySQL中索引的底层数据结构。 从上图可以看出，B树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。 基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。 假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下： 1，先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。 2，将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。 3，将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。 B+树B+树是对B树的进一步优化。让我们先来看下B+树的结构图： 根据上图我们来看下B+树和B树有什么不同。 1，B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，InnoDB中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数又会再次减少，数据查询的效率也会更快。另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 2，因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。 有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。 其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在MySQL的InnoDB存储引擎中，索引就是这样存储的。也就是说上图中的B+树索引就是InnoDB中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。 通过上图可以看到，在InnoDB中，数据页之间通过双向链表连接以及叶子节点中数据通过单向链表连接的方式可以找到表中所有的数据。 MyISAM中的B+树索引实现与InnoDB中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。 聚集索引 VS 非聚集索引在上节介绍B+树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。那什么是聚集索引呢？ 在MySQL中，B+树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍InnoDB中的聚集索引和非聚集索引。 1，聚集索引（聚簇索引）：以InnoDB作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为InnoDB是把数据存放在B+树中的，而B+树的键值就是主键，在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。 2，非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。 明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。 利用聚集索引和非聚集索引查找数据前面我们讲解B+树索引的时候并没有去说怎么在B+树中进行数据的查找，主要就是因为还没有引出聚集索引和非聚集索引的概念。下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下B+树索引查找数据方法。 利用聚集索引查找数据 还是这张B+树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。现在假设我们要查找id&gt;=18并且id=18 and id &lt;40，其中id为主键。具体的查找过程如下： 1，一般根节点都是常驻内存的，也就是说页1已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。 从内存中读取到页1，要查找这个id&gt;=18 and id &lt;40或者范围值，我们首先需要找到id=18的键值。 从页1中我们可以找到键值18，此时我们需要根据指针p2，定位到页3。 2，要从页3中查找数据，我们就需要拿着p2指针去磁盘中进行读取页3。 从磁盘中读取页3后将页3放入内存中，然后进行查找，我们可以找到键值18，然后再拿到页3中的指针p1，定位到页8。 3，同样的页8也不在内存中，我们需要再去磁盘中将页8读取到内存中。 将页8读取到内存中后。 因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值18。 此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值18对应的数据。 因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页8中的键值依次进行遍历查找并匹配满足条件的数据。 我们可以一直找到键值为22的数据，然后页8中就没有数据了，此时我们需要拿着页8中的p指针去读取页9中的数据。 4，因为页9不在内存中，就又会加载页9到内存中，并通过和页8中一样的方式进行数据的查找，直到将页12加载到内存中，发现41大于40，此时不满足条件。 那么查找到此终止。 最终我们找到满足条件的所有数据为： (18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)。 总共12条记录。 下面看下具体的查找流程图： 利用非聚集索引查找数据 读者看到这张图的时候可能会蒙，这是啥东西啊？怎么都是数字。 如果有这种感觉，请仔细看下图中红字的解释。什么？还看不懂？那我再来解释下吧。首先，这个非聚集索引表示的是用户幸运数字的索引，此时表结构是这样的。 id name luckyNum 1 zs 23 2 ls 7 在叶子节点中，不再存储所有的数据了，存储的是键值和主键。 对于叶子节点中的x-y，比如1-1。左边的1表示的是索引的键值，右边的1表示的是主键值。如果我们要找到幸运数字为33的用户信息，对应的sql语句为select * from user where luckNum=33。 查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。 下面看下具体的查找流程图： 在MyISAM中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。 总结本文从二叉查找树，详细说明了为什么MySQL用B+树作为数据的索引，以及在InnoDB中数据库如何通过B+树索引来存储数据以及查找数据。我们一定要记住这句话：数据即索引，索引即数据。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B-树和B+树]]></title>
    <url>%2F2020%2F05%2F06%2FB-%E6%A0%91%E5%92%8CB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数据库索引为什么要使用树结构存储呢？ 为什么索引没有使用二叉查找树来实现呢？ B+树的实现细节是什么样？B-树和B+树有什么区别？ 联合索引在B+树中如何存储？ 卫星数据，指的是索引元素所指向的数据记录，比如数据库中的某一行。怎么理解？ B+树的非叶子节点是没有卫星数据的，非叶子节点只起到索引的作用。是什么意思？ 索引MySQL的索引主要是基于Hash表和B+树。 要弄明白B+树，先要了解什么是B-树。需要注意的是，B-树就是B树，中间的横线并不是减号（不要读成B减树）。 二叉查找树数据库索引为什么要使用树结构存储呢？ 因为树的查询效率高，而且可以保持有序。 既然这样，为什么索引没有使用二叉查找树来实现呢？ 其实从算法逻辑上来讲，二叉查找树的查找速度和比较次数都是最小的。但是，我们不得不考虑一个现实问题：磁盘IO。 数据库索引是存储在磁盘上的。当数据量比较大的时候，索引的大小可能有几个G甚至更多。 当我们利用索引查询的时候，能把整个索引全部加载到内存吗？显然不可能。能做的只有逐一加载每一个磁盘页，这里的磁盘页对应着索引树的节点。 如果我们利用二叉查找树作为索引结构，情形是什么样呢？假设树的高度是4，查找的值是10，那么流程如下: 二叉查找树的结构： 第1次磁盘IO： 第2次磁盘IO： 第3次磁盘IO： 第4次磁盘IO： 有没有从中看出，磁盘IO的次数是由什么决定？ 磁盘IO的次数是4次，索引树的高度也是4。所以最坏情况下，磁盘IO次数等于索引树的高度。为了减少磁盘IO次数，我们就需要把原本“瘦高”的树结构变得“矮胖”，这就是B-树的特征之一。 二叉查找树的查找效率是最高的，如果内存能装下完整的树，最好使用二叉查找树，B树是退而求其次的方式。 B树B树索引可以理解成是主要存储于磁盘中的数据结构。 B树是一种多路平衡查找树，它的每一个节点最多包含k个孩子，k被称为B树的阶。k的大小取决于磁盘页的大小。 下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征： 1.根结点至少有两个子女。 2.每个中间节点都包含k-1个元素和k个孩子，其中m/2 &lt;= k &lt;= m。 3.每一个叶子节点都包含k-1个元素，其中m/2 &lt;= k &lt;= m（B-树叶子节点的元素数量最多可以是阶数-1。比如一颗4阶的B-树，每个节点最多包含有4个孩子、3个元素；最少包含有2个孩子，1个元素）。 4.所有的叶子结点都位于同一层。 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 我们以一个3阶B-树为例，来看看B-树的具体结构。树中的具体元素和刚才的二叉查找树是一样的。 这棵树中，重点来看(2，6)节点。该节点有两个元素2和6，又有三个孩子1，(3，5)，8。其中1小于元素2，(3，5)在元素2，6之间，8大于(3，5)，正好符合刚刚所列的几条特征。 查询假如要查询的数值是5。 第1次磁盘IO： 在内存中定位（和9比较）： 第2次磁盘IO： 在内存中定位（和2，6比较）： 第3次磁盘IO： 在内存中定位（和3，5比较）： 通过整个流程我们可以看出，B-树在查询中的比较次数其实不比二叉查找树少，尤其当单一节点中的元素数量很多时。 可是相比磁盘IO的速度，内存中的比较耗时几乎可以忽略。所以只要树的高度足够低，IO次数足够少，就可以提升查找性能。 相比之下节点内部元素多一些也没有关系。仅仅是多了几次内存交互，只要不超过磁盘页的大小即可。这就是B-树的优势之一。 插入B-树插入新节点的过程比较复杂，而且分成很多种情况。我们只举一个最典型的例子，假如我们要插入的值是4。 自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。 节点3，5已经是两元素节点，无法再增加。父亲节点2，6也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 就为了插入一个元素，让整个B树的那么多节点都发生了连锁改变。确实有些麻烦，但也正因为如此，让B-树能够始终维持多路平衡。这也是B-树的一大优势：自平衡。 删除同样只举一个典型例子，删除元素11。 自顶向下查找元素11的节点位置。 删除11后，节点12只有一个孩子，不符合B树规范。因此找出12，13，15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋） 应用B-树主要应用于文件系统以及部分数据库索引，比如著名的非关系型数据库MongoDB。 B-树的好处是，虽然查询性能不稳定，但平均的查询速度快一些（不用每次都查找到叶子节点为止）。 而大部分关系型数据库，比如MySQL，则使用B+树作为索引。 B+树B+树是基于B-树的一种变体，有着比B-树更高的查询性能。 先回顾一下B-树的几大特征。一个m阶的B树具有如下几个特征： 1.根结点至少有两个子女。 2.每个中间节点都包含k-1个元素和k个孩子，其中m/2 &lt;= k &lt;= m。 3.每一个叶子节点都包含k-1个元素，其中m/2 &lt;= k &lt;= m。 4.所有的叶子结点都位于同一层。 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B+树和B-树有一些共同点，但是B+树也具备一些新的特征。 一个m阶的B+树具有如下几个特征： 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 具体例子 这是什么怪树？不但节点之间含有重复元素，而且叶子节点还用指针连在一起。 这些正是B+树的特点。首先，每一个父节点的元素都出现在子节点中，是子节点的最大（或最小）元素。 在上面这棵树中，根节点元素8是子节点2，5，8的最大元素，也是叶子节点6，8的最大元素。 根节点元素15是子节点11，15的最大元素，也是叶子节点13，15的最大元素。 需要注意的是，根节点的最大元素（这里是15），也就等同于整个B+树的最大元素。以后无论插入删除多少元素，始终要保持最大元素在根节点当中。 至于叶子节点，由于父节点的元素都出现在子节点，因此所有叶子节点包含了全量元素信息。 并且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。 这是以空间换时间，因为子节点都包含父节点的元素。树的层数和一个节点被重复存储成线性关系。父节点元素在子节点重复出现，增加了少量空间，换来的是范围查询的便利。 B+树还具有一个特点，这个特点是在索引之外，却是至关重要的特点。那就是[卫星数据]的位置。 所谓卫星数据，指的是索引元素所指向的数据记录，比如数据库中的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。 B-树中的卫星数据（Satellite Information）： 而在B+树当中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。 B+树中的卫星数据（Satellite Information）： 需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。 B+树设计成这样子究竟有什么好处呢？ B+树的好处主要体现在查询性能上。下面我们分别通过单行查询和范围查询来做分析。 在单元素查询的时候，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。比如我们要查找的是元素3。 第一次磁盘IO： 第二次磁盘IO： 第三次磁盘IO： 查询流程看起来跟B-树差不多。但其实有两点不同。首先，B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。 这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数也更少。 其次，B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。 因此，B-树的查找性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树的每一次查找都是稳定的。 B+树的查询每次都查到叶子节点，所以IO次数稳定。试想一个数据库的查询，有时候执行10毫秒，有时候执行100毫秒，肯定是不太合适的。还不如每次都执行30毫秒。 B-树的范围查找过程 下面我们再来看看范围查询。B-树如何做范围查询呢？只能依靠繁琐的中序遍历。比如我们要查询范围为3到11的元素： 自顶向下，查找到范围的下限（3）： 中序遍历到元素6： 中序遍历到元素8： 中序遍历到元素9： 中序遍历到元素11，遍历结束： B-树的范围查询确实很繁琐。反观B+树的范围查询，则要简单得多，只需要在链表上做遍历即可： B+树的范围查找过程 自顶向下，查找到范围的下限（3）： 通过链表指针，遍历到元素6，8： 通过链表指针，遍历到元素9，11，遍历结束： 比B-树的中序遍历要简单得多。 综合起来，B+树相比B-树的优势有三个： 1.IO次数更少； 2.查询性能稳定； 3.范围查询简便。 至于B+树的插入和删除，过程与B-树大同小异。 总结联合索引就是把多个索引值拼接成一个字符串A，字符串A像普通索引一样保存在索引树中。 最后我们来总结一下， B+树的特征和优势： B+树的特征： 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。一开始就要规定好，要么元素在子节点都是最大的要么都是最小的，不能有的是最大的，有的是最小的。 B+树的优势： 1.单一节点存储更多的元素，使得查询的IO次数更少。 2.所有查询都要查找到叶子节点，查询性能稳定。 3.所有叶子节点形成有序链表，便于范围查询。 在节点占用空间恒定的情况下，B+树单个节点的元素更多。比如同样节点大小，B树的每个节点有100个元素，B+树的每个节点就可以装下1000个元素。这样的好处就是树的高度降低了。 为什么MongoDB索引选择B-树，而MySQL选择B+树一、B-树和B+树的区别很明显，我们要想弄清楚原因就要知道B-树和B+树的区别。 1、B-树 B-树是一种自平衡的搜索树，形式很简单： 这就是一颗B-树。针对我们这个问题的最核心的特点如下： （1）多路，非二叉树。 （2）每个节点既保存索引，又保存数据。 （3）搜索时相当于二分查找。 2、B+树 B+树是B-树的变种。 最核心的特点如下： （1）多路非二叉 （2）只有叶子节点保存数据 （3）搜索时相当于二分查找 （4）增加了相邻接点的指向指针。 从上面我们可以看出最核心的区别主要有俩，一个是数据的保存位置，一个是相邻节点的指向。就是这俩造成了MongoDB和MySQL的差别。为什么呢？ 3、B-树和B+树的区别 （1）B+树查询时间复杂度固定是logn，B-树查询复杂度最好是O(1)。 （2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B-树每个节点key和data在一起，则无法区间查找。 （3）B+树更适合外部存储，也就是磁盘存储。由于内节点无data域，每个节点能索引的范围更大更精确。 （4）注意这个区别相当重要，是基于（1）（2）（3）的，B-树每个节点即保存数据又保存索引，所以磁盘IO的次数很少，B+树只有叶子节点保存，磁盘IO多，但是区间访问比较好。 有了他们的区别之后，现在我们再来解释这个原因就好多了。 二、原因解释想要解释原因，我们还必须要了解一下MongoDB和MySQL的基本概念。 1、MongoDB MongoDB是文档型的数据库，是一种NoSQL，它使用类Json格式保存数据。比如之前我们的表可能有用户表、订单表、购物篮表等等，还要建立他们之间的外键关联关系。但是类Json就不一样了。 我们可以看到这种形式更简单，通俗易懂。那为什么MongoDB使用B-树呢？ MongoDB使用B-树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于MySQL。 2、MySQL MySQL作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。 这俩区别的核心如果你能看懂B-树和B+树的区别就很容易理解。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次Laravel请求的生命周期]]></title>
    <url>%2F2020%2F04%2F29%2F%E4%B8%80%E6%AC%A1Laravel%E8%AF%B7%E6%B1%82%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 生命周期概览 第一件事Laravel应用的所有请求入口都是public/index.php文件，所有请求都会被web服务器（Apache/Nginx）导向这个文件。index.php文件包含的代码并不多，但是，这里是加载框架其它部分的起点。 index.php文件载入Composer生成的自动加载设置，然后从bootstrap/app.php脚本获取Laravel应用实例，Laravel的第一个动作就是创建服务容器实例。 HTTP/Console内核接下来，请求被发送到HTTP内核或Console内核（分别用于处理Web请求和Artisan命令），这取决于进入应用的请求类型。这两个内核是所有请求都要经过的中央处理器，现在，就让我们聚焦在位于app/Http/Kernel.php的HTTP内核。 HTTP内核继承自Illuminate\Foundation\Http\Kernel类，该类定义了一个bootstrappers数组，这个数组中的类在请求被执行前运行，这些bootstrappers配置了错误处理、日志、检测应用环境以及其它在请求被处理前需要执行的任务。 HTTP内核还定义了一系列所有请求在处理前需要经过的HTTP中间件，这些中间件处理HTTP会话的读写、判断应用是否处于维护模式、验证CSRF令牌等等。 HTTP内核的handle方法签名相当简单：获取一个Request，返回一个Response，可以把该内核想象作一个代表整个应用的大黑盒子，输入HTTP请求，返回HTTP响应。 服务提供者内核启动过程中最重要的动作之一就是为应用载入服务提供者，应用的所有服务提供者都被配置在config/app.php配置文件的providers数组中。首先，所有提供者的register方法被调用，然后，所有提供者被注册之后，boot方法被调用。 服务提供者负责启动框架的所有各种各样的组件，比如数据库、队列、验证器，以及路由组件等，正是因为他们启动并配置了框架提供的所有特性，所以服务提供者是整个Laravel启动过程中最重要的部分。 分发请求一旦应用被启动并且所有的服务提供者被注册，Request将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。 聚焦服务提供者服务提供者是启动Laravel应用中最关键的部分，应用实例被创建后，服务提供者被注册，请求被交给启动后的应用进行处理，整个过程就是这么简单！ 对Laravel应用如何通过服务提供者构建和启动有一个牢固的掌握非常有价值，当然，应用默认的服务提供者存放在app/Providers目录下。 默认情况下，AppServiceProvider是空的，这里是添加自定义启动和服务容器绑定的最佳位置，当然，对大型应用，你可能希望创建多个服务提供者，每一个都有着更加细粒度的启动。 总体流程 Web服务器对HTTP请求的处理流程大体上都是这样的：在某个端口监听请求，请求进入后运行程序，然后将程序运行结果以响应的形式发送出去。 基于Laravel框架构建的Web应用处理HTTP请求的流程也是如此。所有HTTP请求都会被转发到单入口文件public/index.php，处理HTTP请求的核心代码如下（忽略HTTP请求处理之外的代码）： 1234567891011121314151617181920212223$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../')); // 绑定处理HTTP请求的接口实现到服务容器$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);// 从服务容器中解析处理HTTP请求的Kernel实例$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);// 处理HTTP请求的核心代码$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture());// 发送响应$response-&gt;send();// 终止程序，做一些善后及清理工作$kernel-&gt;terminate($request, $response); 在上面这段程序中，首先会创建一个Application实例，作为全局的服务容器，然后将处理请求的核心类Kernel实现实例绑定到该容器中，以便后续通过它处理HTTP请求。我们通过服务器捕获请求并将其传递给Kernel实例进行处理，处理结果是准备好的响应实例，调用该响应实例的send()方法即可将其发送给发起请求的客户端。最后，我们执行Kernel实例上的terminate()终止程序，退出脚本。 以上就是Laravel框架处理HTTP请求的一般流程，所有核心逻辑都位于$kernel-&gt;handle()方法调用中。下面我们就来一探究竟。 服务容器Laravel框架提供了一个功能强大的服务容器，用于管理类之间的依赖关系，关于其底层原理还可以参考学徒到工匠系列中的介绍，这里我们就不深入展开了。服务容器封装了绑定到某个接口的对应实现类的实例化过程，你可以在需要对应实现实例的时候通过接口从容器中获取。 在上面的代码中，$app对应的就是服务容器实例，并且在我们获取到该实例后就注册了Kernel接口及其实现类到容器中：1234$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class); singleton方法会以单例方式在服务容器中将App\Http\Kernel实例绑定到Illuminate\Contracts\Http\Kernel接口，后续我们要获取App\Http\Kernel实例，就可以通过Illuminate\Contracts\Http\Kernel接口从服务容器中获取，获取方法是$app-&gt;make()：1$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class); 回到Kernel下面我们就正式进入$kernel-&gt;handle()方法内部看看HTTP请求是被如何处理的。打开Illuminate\Foundation\Http\Kernel（App\Http\Kernel的父类），查看handle方法，可以看到核心处理逻辑通过sendRequestThroughRouter方法实现：12345678910111213protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 在发送请求到路由之前，先调用bootstrap()方法运用应用的启动类：12345678protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class,]; 这些个启动类在路由解析之前执行，相当于对整个应用进行初始化。通过类名就能窥探出对应的操作意图，分别是加载环境变量和全局配置、配置异常处理逻辑、注册门面和服务提供者（根据config/app.php中的providers和alias配置值）、以及执行所有已注册服务提供者的boot方法，具体的实现逻辑我这里就不一一展开的，你可以自己去看下。 然后就是真正的HTTP请求处理了： 1234return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter()); Laravel框架以管道模式来处理HTTP请求，首先通过全局中间件对请求进行处理，如果返回false直接退出，不会做路由解析处理。 全局中间件都校验通过才会将请求分发到路由器进行处理，路由器会将请求URL路径与应用注册的所有路由进行匹配，如果有匹配的路由，则先收集该路由所分配的所有路由中间件，通过这些路由中间件对请求进行过滤，所有路由中间件校验通过才会运行对应的匿名函数或控制器方法，执行相应的请求处理逻辑，最后准备好待发送给客户端的响应。 终止Kernel响应准备就绪后，就会通过$response-&gt;send()发送给发起请求的客户端，之后还要运行$kernel-&gt;terminate()做一些善后清理工作，并最终退出脚本。这些善后清理工作主要包括运行终止中间件，以及注册到服务容器的一些终止回调： 123456public function terminate($request, $response)&#123; $this-&gt;terminateMiddleware($request, $response); $this-&gt;app-&gt;terminate();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现IoC容器和服务提供者是什么概念]]></title>
    <url>%2F2020%2F04%2F27%2F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0IoC%E5%AE%B9%E5%99%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%98%AF%E4%BB%80%E4%B9%88%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： IoC容器和服务提供者上一节我们的代码还是没有完全达到解耦，假如我们项目里有很多功能用到了这个login功能，我们则在这几个页面反复写。但是突然我们有一天换需求了，觉得数据库记录日志不太好，想要改成文件的，那我们不是每个页面用到login功能的都去替换成new FileLog()吗？那该如何修改呢？ 我们可以借助一个容器，提前把log，user都绑定到Ioc容器中。User的创建交给这个容器去做。比如下面这样的，你在任何地方使用login，都不需要关心是用什么记录日志了，哪怕后期需要修改只需要在IoC容器修改绑定其他记录方式日志就行了。 具体代码实现的思路 1、Ioc容器维护binding数组记录bind方法传入的键值对如：log=&gt;FileLog，user=&gt;User。 2、在ioc-&gt;make(‘user’)的时候，通过反射拿到User的构造函数，拿到构造函数的参数，发现参数是User的构造函数参数log，然后根据log得到FileLog。 3、这时候我们只需要通过反射机制创建$filelog = new FileLog(); 4、通过newInstanceArgs然后再去创建new User($filelog); 123456// 实例化ioc容器$ioc = new Ioc();$ioc-&gt;bind('log','FileLog');$ioc-&gt;bind('user','User');$user = $ioc-&gt;make('user');$user-&gt;login(); 这里的容器就是指Ioc容器，服务提供者就是User。 上一节遗留一个问题，如果参数是接口该怎么处理，其实就是通过IoC容器提前绑定好。 核心IoC容器代码编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100interface log&#123; public function write();&#125;// 文件记录日志class FileLog implements Log&#123; public function write() &#123; echo 'file log write...'; &#125;&#125;// 数据库记录日志class DatabaseLog implements Log&#123; public function write() &#123; echo 'database log write...'; &#125;&#125;class User&#123; protected $log; public function __construct(Log $log) &#123; $this-&gt;log = $log; &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;log-&gt;write(); &#125;&#125;class Ioc&#123; public $binding = []; public function bind($abstract, $concrete) &#123; // 这里为什么要返回一个closure呢？因为bind的时候还不需要创建User对象，所以采用closure等make的时候再创建FileLog; $this-&gt;binding[$abstract]['concrete'] = function ($ioc) use ($concrete) &#123; return $ioc-&gt;build($concrete); &#125;; &#125; public function make($abstract) &#123; // 根据key获取binding的值 $concrete = $this-&gt;binding[$abstract]['concrete']; return $concrete($this); &#125; // 创建对象 public function build($concrete) &#123; $reflector = new ReflectionClass($concrete); $constructor = $reflector-&gt;getConstructor(); if(is_null($constructor)) &#123; return $reflector-&gt;newInstance(); &#125; else &#123; $dependencies = $constructor-&gt;getParameters(); $instances = $this-&gt;getDependencies($dependencies); return $reflector-&gt;newInstanceArgs($instances); &#125; &#125; // 获取参数的依赖 protected function getDependencies($paramters) &#123; $dependencies = []; foreach ($paramters as $paramter) &#123; $dependencies[] = $this-&gt;make($paramter-&gt;getClass()-&gt;name); &#125; return $dependencies; &#125;&#125;// 实例化IoC容器$ioc = new Ioc();$ioc-&gt;bind('log','FileLog');$ioc-&gt;bind('user','User');$user = $ioc-&gt;make('user');$user-&gt;login(); 至此，我们的IoC就已经实现了。 Laravel中的服务容器和服务提供者1234567891011121314151617181920212223242526272829$providers = [ Illuminate\Auth\AuthServiceProvider::class, Illuminate\Broadcasting\BroadcastServiceProvider::class, Illuminate\Bus\BusServiceProvider::class, Illuminate\Cache\CacheServiceProvider::class, ...]...// 随便打开一个类比如CacheServiceProvider，这个服务提供者都是通过调用register方法注册到ioc容器中，其中的app就是Ioc容器。// singleton可以理解成我们的上面例子中的bind方法。只不过这里singleton指的是单例模式。class CacheServiceProvider&#123; public function register() &#123; $this-&gt;app-&gt;singleton('cache', function ($app) &#123; return new CacheManager($app); &#125;); $this-&gt;app-&gt;singleton('cache.store', function ($app) &#123; return $app['cache']-&gt;driver(); &#125;); $this-&gt;app-&gt;singleton('memcached.connector', function () &#123; return new MemcachedConnector; &#125;); &#125;&#125; 可以在config目录找到app.php中providers，这个数组定义的都是已经写好的服务提供者。 具体服务提供者register方法是什么时候执行的，我们到讲Laravel生命周期的时候再详细说。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入、控制反转、反射各个概念的理解和使用]]></title>
    <url>%2F2020%2F04%2F27%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E3%80%81%E5%8F%8D%E5%B0%84%E5%90%84%E4%B8%AA%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 用递归的方式创建参数依赖。怎么理解？ 概念理解我们先来介绍控制反转，依赖注入，这两个概念我们可以认为他们表达的同一种意思，举个通俗的例子，我们用户登录需要提供记录日志的功能，可以选择使用文件或者数据库。下面我们用代码来演示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义写日志的接口规范interface log&#123; public function write(); &#125;// 文件记录日志class FileLog implements Log&#123; public function write() &#123; echo 'file log write...'; &#125; &#125;// 数据库记录日志class DatabaseLog implements Log&#123; public function write() &#123; echo 'database log write...'; &#125; &#125;// 程序操作类class User &#123; protected $fileLog; public function __construct() &#123; $this-&gt;fileLog = new FileLog(); &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;fileLog-&gt;write(); &#125;&#125;$user = new User();$user-&gt;login(); 上面的写法可以实现记录日志的功能，但是有一个问题，假设现在想用数据库记录日志的话，我们就得修改User类，这份代码没达到解耦合，也不符合编程开放封闭原则，那如何修改呢？我们可以把日志处理类通过构造函数方式传递进去。下面我们试着修改User类的代码。 1234567891011121314151617181920class User &#123; protected $log; public function __construct(Log $log) &#123; $this-&gt;log = $log; &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;log-&gt;write(); &#125;&#125;$user = new User(new DatabaseLog());$user-&gt;login(); 这样想用任何方式记录操作日志都不需要去修改User类了，只需要通过构造函数传递参数就可以实现，其实这就是“控制反转”。不需要自己内容修改，改成由外部传递。这种由外部负责其依赖需求的行为，我们可以称其为 “控制反转（IoC）”。 那什么是依赖注入呢？其实上面的例子也算是依赖注入，不是由自己内部new对象或者实例，通过构造函数，或者方法传入的都属于依赖注入（DI） 。 依赖注入初学Laravel的同学应该都比较好奇，很多对象实例通过方法参数定义就能传递进来，调用的时候不需要我们自己去手动传入。下面举一个Laravel中实际的例子，Request对象会被自动的注入到函数里。 123456789101112131415// routes/web.phpRoute::get('/post/store', 'PostController@store');// App\Http\Controllersclass PostController extends Controller &#123; public function store(Illuminate\Http\Request $request) &#123; $this-&gt;validate($request, [ 'category_id' =&gt; 'required', 'title' =&gt; 'required|max:255|min:4', 'body' =&gt; 'required|min:6', ]); &#125;&#125; 反射理解我们现在已经明白了依赖注入的概念。那Laravel那种用法怎么实现呢？可能有些同学已经想到了这里面肯定会用到反射机制去创建动态Post，然后去调用store方法。 反射的概念其实可以理解成根据类名返回该类的任何信息，比如该类有什么方法，参数，变量等等。我们先来学习下反射要用到的api。拿User举例。 1234567891011121314// 获取User的reflectionClass对象$class = new ReflectionClass(User::class);// 拿到User的构造函数$constructor = $class-&gt;getConstructor();// 拿到User的构造函数的所有依赖参数$dependencies = $constructor-&gt;getParameters();// 创建user对象$user = $reflector-&gt;newInstance();// 创建user对象，需要传递参数的$user = $reflector-&gt;newInstanceArgs($dependencies = []); 这时候我们可以创建一个make方法，传入User，利用反射机制拿到User的构造函数，进而得到构造函数的参数对象。用递归的方式创建参数依赖。最后调用newInstanceArgs方法生成User实例。下面我们用代码去简单模拟下。 1234567891011121314function make($concrete)&#123; // 获得User的反射类 $reflector = new ReflectionClass($concrete); // User构造函数 $constructor = $reflector-&gt;getConstructor(); // User构造函数参数 $dependencies = $constructor-&gt;getParameters(); // 最后生成User return $reflector-&gt;newInstanceArgs($dependencies);&#125;$user = make('User');$user-&gt;login(); 具体代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 注意我们这里需要修改一下User的构造函数// 如果不去修改。反射是不能动态创建接口的，那如果非要用接口该怎么处理呢？// 下一节我们讲Ioc容器的时候会去解决。class User &#123; protected $log; public function __construct(FileLog $log) &#123; $this-&gt;log = $log; &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;log-&gt;write(); &#125;&#125;function make($concrete)&#123; $reflector = new ReflectionClass($concrete); $constructor = $reflector-&gt;getConstructor(); // 为什么这样写的? 主要是递归。比如创建FileLog不需要传入参数。 if(is_null($constructor)) &#123; return $reflector-&gt;newInstance(); &#125; else &#123; // 构造函数依赖的参数 $dependencies = $constructor-&gt;getParameters(); // 根据参数返回实例，如FileLog $instances = $this-&gt;getDependencies($dependencies); return $reflector-&gt;newInstanceArgs($instances); &#125;&#125;function getDependencies($paramters)&#123; $dependencies = []; foreach ($paramters as $paramter) &#123; $dependencies[] = make($paramter-&gt;getClass()-&gt;name); &#125; return $dependencies;&#125;$user = make('User');$user-&gt;login(); 到这里，我们依赖注入，控制翻转，反射也就讲完了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container tag解析机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-tag%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介先说作用，给某一类的绑定分配一个标记来表示他们是一类的，可以通过这个标记取出同一类下面的所有的绑定。 看看怎么用就知道了：123456789101112// 定义两个实体类，都标记名字为currency// 然后使用tagged取出currency就是可以取出abstract的实体对象。public function testTags()&#123; $this-&gt;app-&gt;tag(Rmb::class, 'currency'); $this-&gt;app-&gt;tag(Dollar::class, 'currency'); $currencyArray = $this-&gt;app-&gt;tagged('currency'); $this-&gt;assertTrue($currencyArray[0] instanceof Rmb); $this-&gt;assertTrue($currencyArray[1] instanceof Dollar);&#125; 注意这里：我们绑定的时候还是一个abstract，就是说容器中还没有对象，但是我们tagged取出的时候都变成对象了。因为make可以直接解析类路径，而tagged使用了make方法。 实例测试测试提供类：1234567891011121314151617181920212223242526272829303132333435363738394041class AusDollars&#123; private $amount; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125;&#125;class Rmb&#123;&#125;class Dollar&#123; public function __construct() &#123; &#125; public function getAmount() &#123; return 1; &#125;&#125;Class Currency&#123; private $dollar; public function __construct(Dollar $dollar) &#123; $this-&gt;dollar = $dollar; &#125; public function getAmount() &#123; return $this-&gt;dollar-&gt;getAmount(); &#125;&#125; 1.测试多个参数情况，以及直接使用类路径。 123456789101112131415public function testTags()&#123; $this-&gt;app-&gt;bind('rmb', Rmb::class); // 多个参数 $this-&gt;app-&gt;tag('rmb', 'currency', 'money'); // 直接使用类路径 $this-&gt;app-&gt;tag(Dollar::class, 'currency', 'money'); $currencyArray = $this-&gt;app-&gt;tagged('money'); $this-&gt;assertTrue($currencyArray[0] instanceof Rmb); $this-&gt;assertTrue($currencyArray[1] instanceof Dollar);&#125; 2.测试使用tag直接绑定有依赖的类路径，会报错。 12345678910111213public function testTagsWithDependency()&#123; $this-&gt;app-&gt;tag(AusDollars::class, 'currency', 'money'); try &#123; $this-&gt;app-&gt;tagged('money'); &#125; catch(\Exception $e) &#123; $this-&gt;assertContains('Unresolvable dependency resolving',$e-&gt;getMessage()); &#125;&#125; 会报这样的错：1`Unresolvable dependency resolving [Parameter #0 [ &lt;required&gt; $amount ]] in class ...` 源码1.tag方法源代码 123456789101112131415161718192021222324/** * Assign a set of tags to a given binding. * * @param array|string $abstracts * @param array|mixed ...$tags * @return void */public function tag($abstracts, $tags)&#123; $tags = is_array($tags) ? $tags : array_slice(func_get_args(), 1); foreach ($tags as $tag) &#123; if (! isset($this-&gt;tags[$tag])) &#123; $this-&gt;tags[$tag] = []; &#125; foreach ((array) $abstracts as $abstract) &#123; $this-&gt;tags[$tag][] = $abstract; &#125; &#125;&#125; 1.0 还是先说参数，传入的$abstracts可以是类路径，也可以是一个绑定的别名或者字符串。如果是后者，需要事先使用bind方法绑定对应的concrete。如果是类路径则可以直接使用，参见前面make方法。 1.1 判断第二个参数$tags是不是一个数组，如果不是数组，他可以是一个参数。 这里可以看到，这里也可以传入多个参数。array_slice会把第二个参数，以及后面所有的参数都转换成一个数组返回。1$tags = is_array($tags) ? $tags : array_slice(func_get_args(), 1); 什么意思呢，举例：123456// 可以这样$this-&gt;app-&gt;tag(Rmb::class, 'currency');// 也可以传入数组$this-&gt;app-&gt;tag(Rmb::class, ['currency', 'money']);// 也可以这样$this-&gt;app-&gt;tag(Rmb::class, 'currency'，‘money’); 最后一种，我们看源码就知道可以这样使用，虽然我感觉可能不是一个好的写法。 1.2 下面就简单了，主要分两步： a.遍历这个tags数组，如果在tags数组（protected $tags = [];）中不存在这个tag那么创建一个空的子数组。 b.遍历前面的第一个参数$abstracts，他会强行转换成一个数组，说明$abstract可以是一个字符串，也可以是一个数组。把当前的abstract对应的值存储到上面我们创建的子数组tag中。 这里我们同时知道了tags数组作用以及存储格式。123456789101112foreach ($tags as $tag) &#123; if (! isset($this-&gt;tags[$tag])) &#123; $this-&gt;tags[$tag] = []; &#125; foreach ((array) $abstracts as $abstract) &#123; $this-&gt;tags[$tag][] = $abstract; &#125;&#125; 这是tags的存储过程。 2.tagged方法源代码，看看以tag标记的一类绑定如何获取。1234567891011121314151617181920/** * Resolve all of the bindings for a given tag. * * @param string $tag * @return iterable */public function tagged($tag)&#123; if (! isset($this-&gt;tags[$tag])) &#123; return []; &#125; return new RewindableGenerator(function () use ($tag) &#123; foreach ($this-&gt;tags[$tag] as $abstract) &#123; yield $this-&gt;make($abstract); &#125; &#125;, count($this-&gt;tags[$tag]));&#125; 2.1 其实很简单，也是两个逻辑： a.先判断当前容器的tags数组中有没有对应的值，如果没有直接返回空数组。 b.如果有，遍历这个子tag数组，分别使用make函数解析这个$abstract。 这里我们就能明白，为什么我们可以不用事先绑定类路径，而直接使用就能绑定成功，因为我们知道make解析的时候，如果在binding数组中找不到对应的值，他会使用build函数直接解析。 但是我们，也看到，这个make解析的时候是没有第二个参数parameters的，说明什么呢，如果这个类路径有自定义的依赖并且这个依赖没有默认值，它是无法实例化的。因为make他需要我们传入第二个参数才能实例化。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container build解析机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-build%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么把concrete存入数组buildStack中，等下用？ 简介build的作用就是根据不同情况生成对象。 实例测试1、直接使用build，没有依赖的闭包函数，如下代码第16行。 12345678910111213141516171819202122232425&lt;?php// 一个普通的类，没有构造函数，没有依赖class Money&#123; public function getAmount() &#123; return 100; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; // 参数是一个闭包，闭包返回实例对象 $boss = app()-&gt;build(function()&#123; return new Money(); &#125;); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, 100); &#125;&#125; 2、使用make解析，make通过build创建对象，有依赖的闭包函数的测试。 123456789101112131415161718192021222324252627282930&lt;?php// 有构造函数，有依赖class Money&#123; // 依赖 private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; $this-&gt;app-&gt;bind('money', function($app, $parameters)&#123; return new Money($parameters[0]); &#125;); $boss = app()-&gt;make('money', [$amount = 1000]); &#125;&#125; 3.使用make解析，make通过build对象，有依赖的类路径测试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php// 有依赖class Money&#123; private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;class Dollar extends Money&#123; //private $amount = 0; public function __construct() &#123; &#125; public function getAmount() &#123; return 1; &#125;&#125;Class Currency&#123; private $dollar; // 依赖一个类 public function __construct(Dollar $dollar) &#123; $this-&gt;dollar = $dollar; &#125; public function getAmount() &#123; return $this-&gt;dollar-&gt;getAmount(); &#125;&#125;public function testFunctionBuildWithDependenceOfClass()&#123; $obj = app()-&gt;make(Currency::class); $this-&gt;assertEquals($obj-&gt;getAmount(), 1);&#125; 我们读通源码后，我们可以解决很多找不到答案的问题，比如： 12345678910111213141516class Money&#123; private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;$obj = app()-&gt;make(Money::class, [$amount =&gt; 1000]); 尝试解析这个类，发现总是提示找不到amount依赖，我们追踪下去会发现，with数组中的parameter是：123array(1) &#123; [0]=&gt;int(1000)&#125; 由此我们知道我们传入的parameter没有key值，正确的做法是： 1$obj = app()-&gt;make(Money::class, ['amount' =&gt; 1000]); 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 实例化给定类型的具体实例 * * @param \Closure|string $concrete * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException *///0 -&gt; 参数public function build($concrete)&#123; // 如果$concrete实际上是闭包，我们将执行这个闭包并返回执行的结果， // 这允许将函数用作解析器以更精细地解析这些对象。 // 1 if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride()); &#125; try &#123; // 2 $reflector = new ReflectionClass($concrete); &#125; catch (ReflectionException $e) &#123; throw new BindingResolutionException("Target class [$concrete] does not exist.", 0, $e); &#125; // 如果该类型不是可实例化的，则开发人员正在尝试解析一个抽象类型， // 例如Interface或Abstract Class，并且没有为抽象注册任何绑定，因此我们需要补救。 if (! $reflector-&gt;isInstantiable()) &#123; return $this-&gt;notInstantiable($concrete); &#125; // 3 $this-&gt;buildStack[] = $concrete; $constructor = $reflector-&gt;getConstructor(); // 如果没有构造函数，则意味着没有依赖关系，那么我们可以立即解析对象的实例， // 而无需从这些容器中解析任何其他类型或依赖关系。 if (is_null($constructor)) &#123; array_pop($this-&gt;buildStack); return new $concrete; &#125; // 4 $dependencies = $constructor-&gt;getParameters(); // 一旦有了所有构造函数的参数，就可以创建每个依赖项实例， // 然后使用反射实例创建此类的新实例，将创建的依赖项注入其中。 try &#123; $instances = $this-&gt;resolveDependencies($dependencies); &#125; catch (BindingResolutionException $e) &#123; array_pop($this-&gt;buildStack); throw $e; &#125; array_pop($this-&gt;buildStack); return $reflector-&gt;newInstanceArgs($instances);&#125; 0.还是从参数说起，传入的实例concrete，可以是闭包函数，可以是一个类路径。还是重新提一下，concrete并不是实体类对象，而是可以产生对象的类或者闭包。和实体对象集合instance有区别。 1.如果这个concrete是一个闭包函数，我们就直接执行这个闭包。1234if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride());&#125; 这里的闭包的形式为：1$concrete($this, $this-&gt;getLastParameterOverride()); 有两个参数，但是不传参数也是可以的。 第二个参数$this-&gt;getLastParameterOverride()，我们看下源代码：123456789/** * Get the last parameter override. * * @return array */protected function getLastParameterOverride()&#123; return count($this-&gt;with) ? end($this-&gt;with) : [];&#125; make解析那章，解析的时候把parameters存入了with数组，这个时候就是使用getLastParameterOverride获取with数组的最后一个值，也就是我们make时候刚刚放入的对象的parameters。 2、创建一个php的ReflectionClass对象，包含类的信息，ReflectionClass针对类，ReflectionObject则是针对对象。 所以这里concrete是一个类路径。正如前面提到的。1$reflector = new ReflectionClass($concrete); 2.1、如果这不是一个可以初始化的类，那么notInstantiable方法会抛出一个异常。1234if (! $reflector-&gt;isInstantiable()) &#123; return $this-&gt;notInstantiable($concrete);&#125; notInstantiable方法源代码：123456789101112131415161718192021222324/** * Throw an exception that the concrete is not instantiable. * 如果具体类不能实例化，就抛出异常 * * @param string $concrete * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function notInstantiable($concrete)&#123; if (! empty($this-&gt;buildStack)) &#123; $previous = implode(', ', $this-&gt;buildStack); $message = "Target [$concrete] is not instantiable while building [$previous]."; &#125; else &#123; $message = "Target [$concrete] is not instantiable."; &#125; throw new BindingResolutionException($message);&#125; 发现他无非就是组织一个message，然后抛出了一个异常。返回的异常提示是Target … is not instantiable. 3、这里通过php反射机制，用Concrete类产生对象。如何实现呢？如下步骤。 3.1、首先把concrete存入数组buildStack中，等下用。为什么一定要先存入一个数组呢？下面会讲。如果细看上一章，也许你知道。 1$this-&gt;buildStack[] = $concrete; 3.2、然后利用前面得到的反射对象通过getConstructor方法得到他的构造函数，如果构造函数是空的，就是默认没有参数的构造函数，从buildStack取出concrete使用new创建这个对象返回。12345678$constructor = $reflector-&gt;getConstructor();if (is_null($constructor)) &#123; array_pop($this-&gt;buildStack); return new $concrete;&#125; 4、否则就是类里有自定义构造函数，或者说可能构造函数存在依赖的情况。我们要先获取依赖再去创建对象。 4.1 通过构造函数我们获取参数依赖。就是构造函数中的参数，如果没有，返回一个空的数组。 1$dependencies = $constructor-&gt;getParameters(); 在进行下面的分析前，先明确getParameters()会返回的数组的形式，帮助后面的分析，下面为一个例子：1234567891011121314151617181920&lt;?phpclass dollar&#123; public function __construct($import) &#123; &#125; public function getAmount() &#123; return 100; &#125;&#125;$reflect = new ReflectionClass('dollar');$constructor = $reflect-&gt;getConstructor();var_dump($constructor-&gt;getParameters()); 最后他输出的结构是：12345array(1) &#123; [0] =&gt; object(ReflectionParameter)#3 (1) &#123; [&quot;name&quot;]=&gt;string(6) &quot;import&quot; &#125;&#125; 4.2 有了上面的例子。使用resolveDependencies方法解析然后获取这个依赖。（不想看具体实现可以跳过到4.3）1$instances = $this-&gt;resolveDependencies($dependencies); 看下整个源码，然后再一步一步看。1234567891011121314151617181920212223242526272829303132333435363738394041/** * 从ReflectionParameters解析所有依赖项 * * @param array $dependencies * @return array * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveDependencies(array $dependencies)&#123; $results = []; foreach ($dependencies as $dependency) &#123; // 如果此依赖项覆盖了这个特殊的build，则将其用作值。 // 否则，我们将继续执行这些决议，并让反射尝试确定结果。 if ($this-&gt;hasParameterOverride($dependency)) &#123; $results[] = $this-&gt;getParameterOverride($dependency); continue; &#125; // 如果该类为null，则表示依赖项是字符串或其他一些原始类型， // 由于它不是类，因此我们无法解析，并且由于无处可去，因此我们将抛出错误。 $result = is_null($dependency-&gt;getClass()) ? $this-&gt;resolvePrimitive($dependency) : $this-&gt;resolveClass($dependency); if ($dependency-&gt;isVariadic()) &#123; $results = array_merge($results, $result); &#125; else &#123; $results[] = $result; &#125; &#125; return $results;&#125; 4.2.1 首先遍历这个依赖，然后使用方法$this-&gt;hasParameterOverride($dependency)判断是否参数有覆盖。什么意思呢，看hasParameterOverride源码，如下：123456789101112/** * 确定给定的依赖项是否具有参数替代。 * * @param \ReflectionParameter $dependency * @return bool */protected function hasParameterOverride($dependency)&#123; return array_key_exists( $dependency-&gt;name, $this-&gt;getLastParameterOverride() );&#125; $this-&gt;getLastParameterOverride()上面提到过，获取make时候存入with数组的参数。$dependency-&gt;name是什么，就是构造函数中参数的名字，上面的例子中，就是‘import’。简单说就是我们在make解析的时候是不是传递了这个依赖的值（就是make方法的第二个参数parameters）。 4.2.2 继续，如果有这个覆盖，使用getParameterOverride获取这个依赖的值，存入result数组中。 1$results[] = $this-&gt;getParameterOverride($dependency); 严谨的再看下getParameterOverride怎么实现的： 12345678910/** * Get a parameter override for a dependency. * * @param \ReflectionParameter $dependency * @return mixed */protected function getParameterOverride($dependency)&#123; return $this-&gt;getLastParameterOverride()[$dependency-&gt;name];&#125; 很简单还是通过getLastParameterOverride获取with数组，然后在数组中通过name（这里就是import）获取。 4.2.3 然后continue循环下一个依赖。 4.2.4 如果在with数组中找不到对应的依赖。也就是这个依赖不是我们make时候设定的，故意要传入的parameters，可能是其他的类。那么我们先判断这个依赖类是不是存在于当前代码中。 I. 如果不存在，则使用resolvePrimitive方法，看看上下文绑定中有没有对应的值，再看看依赖自己有没有默认值（具体看下面4.2.5resolvePrimitive方法源码分析）。 II. 如果存在使用resolveClass方法，就是使用make函数解析这个依赖（具体看下面4.2.6resolveClass方法源码）。 12345// 如果该类为null，则表示依赖项是字符串或其他一些原始类型，// 由于它不是类，因此我们无法解析，并且由于无处可去，因此我们将抛出错误。$result = is_null($dependency-&gt;getClass()) ? $this-&gt;resolvePrimitive($dependency) : $this-&gt;resolveClass($dependency); 4.2.5 resolvePrimitive方法源码： 12345678910111213141516171819202122/** * 解析非类提示的原始依赖项。 * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolvePrimitive(ReflectionParameter $parameter)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete('$'.$parameter-&gt;name))) &#123; return $concrete instanceof Closure ? $concrete($this) : $concrete; &#125; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; $this-&gt;unresolvablePrimitive($parameter);&#125; a. 首先判断这个依赖的name是不是在上下文绑定中（又来了）。 b. 如果这个依赖在上下文绑定中，再次提醒，我们记得上下文绑定有两个类型，一个是闭包，一个是类路径。这里如果是闭包直接执行，如果是类路径，返回类路径。 c. 否则是否存在依赖有默认值，有默认值直接返回默认值。什么意思呢，这里的例子，如果是$import=”100”是这个情况。 d. 都没有那说明没办法解析，执行unresolvablePrimitive方法，直接排除一个无法解析的异常。源码： 1234567891011121314/** * 为无法解析的原始类型抛出异常。 * * @param \ReflectionParameter $parameter * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function unresolvablePrimitive(ReflectionParameter $parameter)&#123; $message = "Unresolvable dependency resolving [$parameter] in class &#123;$parameter-&gt;getDeclaringClass()-&gt;getName()&#125;"; throw new BindingResolutionException($message);&#125; 4.2.6 resolveClass方法源码： 12345678910111213141516171819202122232425262728293031323334/** * 解析容器中基于类的依赖关系 * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveClass(ReflectionParameter $parameter)&#123; try &#123; return $parameter-&gt;isVariadic() ? $this-&gt;resolveVariadicClass($parameter) : $this-&gt;make($parameter-&gt;getClass()-&gt;name); &#125; // 如果无法解析类实例，则将检查该值是否为可选值， // 如果为可选值，则将返回可选参数值作为依赖项的值，这与使用标量的方式类似。 catch (BindingResolutionException $e) &#123; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; if ($parameter-&gt;isVariadic()) &#123; return []; &#125; throw $e; &#125;&#125; a.很明显，既然在代码中存在这个类，使用make函数解析这个类。（又进入解析了，又会调用build。）这个时候才是buildstack有值的时候，就是说在resolve函数中，getContextualConcrete才起到了真正的作用，会检查上下文绑定。回看上一章。 b.有一个情况我们要考虑，如果这个类不能被解析，就是解析失败了，（比如：这个类是抽象类）。怎么办，我们上面提过，他会抛出一个BindingResolutionException异常吧，这里捕获这个异常，判断这个依赖$import是不是一个optional的参数，什么意思，还是这个情况 ($import == 100) 有没有默认值，如果有则取他的默认值（100）返回，不解析了，有默认值先用下再说。如果不是，没办法继续抛这个异常。 4.2.7 最后返回包含了所有依赖的result数组，我们前面有种情况，如果有自定义构造方法但是没有传入参数，就是result[]是空，不影响结果。往下看。 4.3 得到了依赖了，我们使用newInstanceArgs方法创建对象不再使用new了，依赖$instances为参数. 4.3.1 这里再次使用array_pop从buildStack取出类。我们一开始为什么要存到buildStack这个数组中，这个时候可以总结了： 逻辑上来说：就是为了给不一样的逻辑情况提供未污染的变量。简单说就是把这个变量放起来，谁先来谁先用。具体情况来说，为了给解析依赖的时候提供一个及时的当前build的concretion。123array_pop($this-&gt;buildStack);return $reflector-&gt;newInstanceArgs($instances); 这就是整个流程。 总结build方法主要是这样的流程： 1、判断是不是闭包，闭包就执行。 2、如果不是闭包，利用php反射，生成php反射对象。 3、这个类有没有自定义构造函数，如果没有，就直接new返回。 4、如果有自定义构造函数。 4.1、我们先看看有没有在make的时候传入第二个参数，有的话获取返回这个依赖。 4.2、没有传入的话，说明不是我们故意要的，有其他的依赖。 a、看看这个依赖能不能解析，不能解析，我们看看上下文绑定有没有，这个依赖的默认值有没有，都没有，没办法抛出异常。 b、要是能解析，就直接解析，返回。 4.3、有了依赖了，使用反射通过依赖生成对象。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container make解析机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-make%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： make解析的时候会调用build函数实例化对象。 make($abstract, array $parameters = []); 简介make和resolve都是从容器中解析实例（这个实例是指concrete）出来。简单说就是从容器中把前面bind进去的东西拿出来用。 这里需要明确的是，make解析的时候会调用build函数实例化对象，就是说理论上如果绑定的是一个字符串，Laravel默认这是一个可以实例化对象的类路径。 而我们如果想要绑定一个纯粹的字符串或者数字，我们可以使用闭包函数。让闭包返回我们需要的类型。具体看下面的源码。 把resolve和make放在一起是因为其实在Container类中，make就是resolve的一个包装。 我们看看make方法：很简单直接调用了resolve方法，类似的还有makeWith方法。 12345678910111213/** * 从容器解析给定类型 * * @param string $abstract * @param array $parameters * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */public function make($abstract, array $parameters = [])&#123; return $this-&gt;resolve($abstract, $parameters);&#125; 1234567891011/** * An alias function name for make(). * * @param string $abstract * @param array $parameters * @return mixed */public function makeWith($abstract, array $parameters = [])&#123; return $this-&gt;make($abstract, $parameters);&#125; 源码先整体看下resolve函数源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 从容器解析给定类型 * * @param string $abstract * @param array $parameters * @param bool $raiseEvents * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolve($abstract, $parameters = [], $raiseEvents = true)&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null( $this-&gt;getContextualConcrete($abstract) ); // 如果当前正在以单例方式管理类型的实例，我们将仅返回一个现有实例， // 而不是实例化新实例，以便开发人员每次都可以继续使用相同的对象实例。 if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); // 我们已经准备好实例化为绑定注册的具体类型的实例。 // 这将实例化类型，并递归地解决其所有“嵌套”依赖项，直到所有问题都解决为止。 if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; // 如果我们为此类型定义了任何扩展程序，则需要遍历它们并将其应用于正在构建的对象。 // 这允许扩展服务，例如更改配置或装饰对象。 foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; // 如果将请求的类型注册为单例，我们将要缓存“内存”中的实例， // 这样我们以后就可以返回它，而无需在每次后续请求上创建对象的全新实例。 if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; if ($raiseEvents) &#123; $this-&gt;fireResolvingCallbacks($abstract, $object); &#125; // 返回之前，我们还将解析标记设置为“ true”，并弹出此构建的参数替代。 // 完成这两件事之后，我们将准备好返回完整构造的类实例。 $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; 还是从参数说起： 参数$abstract，获取在容器中的服务的名字，或者叫id。 参数$parameters，有些实例对象实例化的时候会需要参数，这个$parameters就是我们传入的参数。 举例：看代码，上一章我们知道，bind只是绑定一个闭包，啥也不干，所以不用传入参数，因为压根没有实例化对象。但是当我们这里要make解析的时候，即实例化Boss::class的时候，我们要把这个Object类型的对象传进去，Boss::class才能实例化。12345678910111213141516&lt;?phpclass Boss()&#123; private $obj; // 这里构造函数需要一个对象才能实例化。 public function __construct(Object $obj) &#123; $this-&gt;obj = $obj; &#125;&#125;app()-&gt;bind('Boss', Boss::class);app()-&gt;make('Boss', [new Object()]); 1.获取$abstract的别名。请参看。1$abstract = $this-&gt;getAlias($abstract); 2.设置一个变量$needsContextualBuild来做标记，标记当前这个解析的实例需不需要上下文绑定。123$needsContextualBuild = ! empty($parameters) || ! is_null( $this-&gt;getContextualConcrete($abstract) ); 在上下文绑定那章我们也说了，上下文绑定其实就是依赖绑定，就是判断当前的make的实例需不需要依赖。满足下面两个条件中的任意一个就需要： a.传入的参数不为空。很好理解，你都传入参数了，这个参数上面刚刚讲了就是为了当前实例化的时候传入作为依赖的。 b.通过函数getContextualConcrete，获取到了当前解析的这个类，是否已经有了上下文绑定的依赖。（就是事先已经使用上下文绑定过了），这个其实虚的没有任何作用，往下细看。 2.1.那让我们看看getContextualConcrete($abstract)方法如何获取事先绑定的上下文依赖的。 getContextualConcrete代码如下：123456789101112131415161718192021222324252627/** * 获取给定抽象类的上下文concrete绑定。 * * @param string $abstract * @return \Closure|string|null */protected function getContextualConcrete($abstract)&#123; if (! is_null($binding = $this-&gt;findInContextualBindings($abstract))) &#123; return $binding; &#125; // 接下来，我们需要查看是否可以在给定抽象类型的别名下绑定上下文绑定。 因此，我们将需要检查此类型是否存在别名，然后对其进行旋转并检查这些别名的上下文绑定。 if (empty($this-&gt;abstractAliases[$abstract])) &#123; return; &#125; foreach ($this-&gt;abstractAliases[$abstract] as $alias) &#123; if (! is_null($binding = $this-&gt;findInContextualBindings($alias))) &#123; return $binding; &#125; &#125;&#125; 2.1.1.首先判断是否在上下文绑定的数组中存在abstract的实例concrete，如果有就返回。直接从数组中找。 2.1.2.如果没有，看看这个$abstractAliases数组里面有没有$abstract别名，这个数组前面“别名”章节我们提过，和$aliases数据保存相反格式，保存abstract和alias关系的数组。注意，后面的数组value值才是别名，键值‘app’是abstract，格式如下：123456789$abstractAliases = [ app = &#123;array&#125; [3] 0 = &quot;Illuminate\Foundation\Application&quot; 1 = &quot;Illuminate\Contracts\Container\Container&quot; 2 = &quot;Illuminate\Contracts\Foundation\Application&quot; blade.compiler = &#123;array&#125; [1] 0 = &quot;Illuminate\View\Compilers\BladeCompiler&quot; ...] 继续看源代码。如果这个数组是空的，直接返回了。 2.1.3.如果这个数组不是空的，遍历所有abstract的别名，这个别名在binding数组中是否存在。 简单说就是abstract如果不在上下文绑定的数组中，那么看看abstract的别名是否在上下文绑定数组中。最后判断一下返回。 2.1.3.1重点来了，我们去看看findInContextualBindings源码:12345678910/** * Find the concrete binding for the given abstract in the contextual binding array. * * @param string $abstract * @return \Closure|string|null */protected function findInContextualBindings($abstract)&#123; return $this-&gt;contextual[end($this-&gt;buildStack)][$abstract] ?? null;&#125; 还记得上下文绑定那章的存储结构就是这样:contextual[when][give]=implement。这里就是取对应的值。 但是我们发现他在取[give]值的时候它使用了end($this-&gt;buildStack)。buildStack是build的实例的堆栈，我们上下文绑定的流程中完全没有这个绑定。也就是说我们从resolve进来你是找不到这个值的，这完全是虚的没有任何作用，getContextualConcrete不会取得任何值。他的存在其实是给build函数创建依赖对象的时候，会递归再次回来make解析依赖类用的。看下一章build方法解析。 总结第二点，其实我们这里主要判断是就是有没有parameters，getContextualConcrete似乎完全不会取得任何值。 3.回到主线resolve函数，如果在数组instances中已经存在这个abstract的对象了并且不需要上下文绑定，直接调用这个instances中的值返回。我们前面章节知道instances数组是保存可以shared的实体对象。既然有了，并且没有依赖，就直接返回。 这里有个问题，如果有依赖，instances中的值为什么不能直接返回，因为依赖可能会变化，仔细想想是不是。你前面使用instance传入的有依赖的对象的参数，和这次我们要求的对象传入的依赖参数，可能是不同的。比如以前存储的new A(‘1’)，这次需要的newA(‘2’)，一个对象参数不同。1234if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract];&#125; 这里有一个问题，通过instance()方法是可以保存任何类型数据的。但是如果instances数组中没有事先存在的值，那么make解析的字符串默认被当做一个类路径的。（后面章节有instace绑定源码分析）举例如下：123456789101112131415// 使用instance存入字符串绑定。成功$this-&gt;app-&gt;instance('money', "11");$re = $this-&gt;app-&gt;make('money'); // success// 通过闭包绑定字符串类型的值 成功$this-&gt;app-&gt;bind('money', function()&#123; return "11";&#125;);$re = $this-&gt;app-&gt;make('money'); // success// 直接绑定字符串，同时instances数组中不存在任何值，11被当做一个类路径处理。失败$this-&gt;app-&gt;bind('money', '11');$re = $this-&gt;app-&gt;make('money'); // fail 4.1前面的条件没成立的话，接下来，把参数parameters存入with数组，前面讲过了，parameters是实例化的时候需要的依赖，所以暂存于with数组。1$this-&gt;with[] = $parameters; 4.2.接下来通过函数getConcrete($abstract)获取concrete。1$concrete = $this-&gt;getConcrete($abstract); 我们看getConcrete源代码:1234567891011121314151617181920212223/** * Get the concrete type for a given abstract. * * @param string $abstract * @return mixed $concrete */protected function getConcrete($abstract)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $concrete; &#125; // If we don't have a registered resolver or concrete for the type, we'll just // assume each type is a concrete name and will attempt to resolve it as is // since the container should be able to resolve concretes automatically. if (isset($this-&gt;bindings[$abstract])) &#123; return $this-&gt;bindings[$abstract]['concrete']; &#125; return $abstract;&#125; 主要的思路是： a. 看看上下文绑定数组中有没有$abstract对应的concrete值，如果有，太好了，最复杂的情况就是上下文绑定。直接返回就好了。连依赖都已经添加了。（参看上下文绑定存储结构和使用方法） 这里要特别注意，上下文绑定获取的concrete值可以是一个类路径，也可以是一个闭包（看看文档如何使用上下文绑定就知道了，可以传入类路径也可以是闭包。）。但是在后面的处理对两个情况是不一样的。 和上面情况雷同，其实这里getConcrete还是调用了getContextualConcrete，但buildstack中没有值，所以这个是虚的。暂时是没有值的。build解析依赖类的时候递归回来才有这个buildstack值。 b.如果没找到上下文绑定，就是一个普通绑定，就去bindings的数组中看看有没有$abstract对应的concrete值，从而确认是不是以前有绑定过。同样的$concrete可以是一个闭包，也可以是一个类路径。 c.都没有，说明没有绑定！！直接返回$abstract。 这里说明什么呢，我猜想我们是可以不用绑定bind函数，而直接make的，这样的话可以直接把$abstract当做$concrete来解析。12// 实测有效，直接返回Money::class 对象。$boss= app()-&gt;make(Money::class); 这个方法处理的结果也有三种可能： a.上下文绑定的concrete（这个其实没有） b.binding 数组中的concrete c.把$concrete===$abstract相等。 这里的c步骤到底做了什么，怎么处理的？我们往下看代码。第五步。 5.获取解析的对象了。123456789// 我们已经准备好实例化为绑定注册的具体类型的实例。 // 这将实例化类型，并递归地解决其所有“嵌套”依赖项，直到所有问题都解决为止。if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete);&#125; else &#123; $object = $this-&gt;make($concrete);&#125; 5.1 首先，我们要看下函数isBuildable函数是什么要求。如果$concrete===$abstract或者 concrete是一个闭包，好办返回true。1234567891011/** * Determine if the given concrete is buildable. * * @param mixed $concrete * @param string $abstract * @return bool */protected function isBuildable($concrete, $abstract)&#123; return $concrete === $abstract || $concrete instanceof Closure;&#125; 5.2 如果是true，那么使用build函数处理这个object。 我们在这里简单说下build具体的会在下一章build源码中分析。 build的作用是这样的： a.如果concrete是闭包，build执行闭包函数。 b.不是闭包，build函数会使用反射产生当前$concrete类的对象。和前面我们的猜想一样。既然$abstract===$concrete，那么直接解析，都不用绑定。 5.3 如果isBuildable返回的是false呢？就是$concrete的值是・类路径・的情况，调用make进入递归。如下give给的不是一个闭包是一个类路径。则进入make。1234$container -&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(S3Filesystem::class); make再去getConcrete函数，去上下文绑定数组和binding数组，查询这个时候这个・类路径下・（就是 abstract）有没有对应的闭包或类路径。但不管怎么样。最后下来要么闭包，要么相等，他都会进入build函数创建对象。 6.到此，我们得到了解析出来的object对象。 然后第六步我们要看看是否有扩展绑定entend的处理，参看0.2章节，执行：12345// 如果我们为此类型定义了任何扩展程序，则需要遍历它们并将其应用于正在构建的对象。 // 这允许扩展服务，例如更改配置或装饰对象。foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this);&#125; 7.是否是单例分享的，如果是的话就存入instance，参看0.4章节12345// 如果将请求的类型注册为单例，我们将要缓存“内存”中的实例，// 这样我们以后就可以返回它，而无需在每次后续请求上创建对象的全新实例if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object;&#125; 8.接着触发各个回调函数，参看0.3章节，执行回调，这个函数就是触发3个地方的回调函数。1$this-&gt;fireResolvingCallbacks($abstract, $object); 9.标记已经解析了。并且把参数从with中pop掉，没用了。这个with在build方法中使用了，在make方法中没有用到。12345// 返回之前，我们还将解析标记设置为“true”，并弹出此构建的参数替代。 // 完成这两件事之后，我们将准备好返回完整构造的类实例。$this-&gt;resolved[$abstract] = true;array_pop($this-&gt;with); 最后返回对象。 总结make（解析）相对复杂。但是主要关注几个大步骤就能明白流程。 1.首先获取最终的别名。 2.设置是否是・上下文绑定・的标记。 3.如果在shared的instances数组中找到了，同时又不是有上下文绑定需求的。直接返回对象。结束程序。 4.否则，把实例化对象所依赖的参数parameters暂存with数组。 5.通过getConcrete方法获取$concrete.注意这里的concrete还不是对象，是类路径或者是一个闭包函数。 6.有了$concrete，如果是闭包，我们利用build函数生成对象。 7.如果是类路径，我们要再递归，看看这个路径下是否还有$concrete的绑定。如果有再递归，像别名一样，找到真正那个。如果没有，使用build函数反射原理生成对象返回，with数组将在build反射中使用。 8.完成对象生成，看看有没有extend扩展。 9.看看是否需要shard，把对象存入instance中。 10.触发各个回调函数。 11.记录这个abstract已经解析过了。 12.把with数组中parameters清空掉。 13.返回对象。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container bind机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-bind%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 闭包函数不触发，它是不会创建对象的。也就是所谓的懒加载。是什么意思？ 简介 Illuminate\Container\Container类的最重要的方法：bind。 绑定是把关系存起来了，只有到make的时候才产生对象。 绑定分为几种： 1、bind把接口和其实现类绑定，当make解析接口的时候创建其实现类的实例对象。 2、singleton把接口和其实现类绑定，当第一次make解析的时候创建实例，后面都返回该实例不再创建。 3、instance把接口和其实现类的实例绑定，直接绑定实例对象。 4、上下文绑定。 5、自动绑定。 6、tag绑定。 7、extends扩展绑定。 实例测试测试1：使用闭包函数返回有依赖的对象。 12345678910111213141516171819class Money&#123; private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;// 注意闭包的形式$this-&gt;app-&gt;bind('money', function($app, $parameters)&#123; return new Money($parameters[0]);&#125;); 测试2：使用闭包函数返回没有依赖的对象。1234567891011class Dollar&#123; public function getAmount() &#123; return 100; &#125;&#125;$this-&gt;app-&gt;bind('dollar', function()&#123; return new Dollar();&#125;); 源码先大概看bind下源代码： 123456789101112131415161718192021222324252627282930313233343536373839/** * 在容器中注册绑定 * 绑定到容器的对象只会被解析一次，之后的调用都返回相同的实例 * * @param string $abstract * @param \Closure|string|null $concrete * @param bool $shared * @return void */public function bind(string $abstract, $concrete = null, bool $shared = false)&#123; // 移除旧的实例 $this-&gt;dropStaleInstances($abstract); // 如果没有给出具体类型，我们将简单地将具体类型设置为抽象类型。之后，要注册为共享的具体类型，而不必强制在两个参数中声明其类。 if (is_null($concrete)) &#123; $concrete = $abstract; &#125; // 如果工厂不是Closure，则意味着它只是一个类名称，该类名称已绑定到此容器中的抽象类型，我们将其包装在其自己的Closure中，以便在扩展时提供更多便利。 if (! $concrete instanceof Closure) &#123; if (! is_string($concrete)) &#123; throw new \TypeError(self::class.'::bind(): Argument #2 ($concrete) must be of type Closure|string|null'); &#125; $concrete = $this-&gt;getClosure($abstract, $concrete); &#125; $this-&gt;bindings[$abstract] = compact('concrete', 'shared'); // 如果抽象类型已在此容器中解析，则将触发反弹侦听器，以便已解析的任何对象都可以通过侦听器回调更新其对象副本。 if ($this-&gt;resolved($abstract)) &#123; $this-&gt;rebound($abstract); &#125;&#125; 参数： 1、首先明确第一个参数$abstract简单说就是id，可以当做是存入容器中的名字。可以是一个字符串，一个类，甚至是一个接口。 2、第二个参数$concrete简单说就是真实的值，可以当做是一个真正存入容器的实体。他可以是一个实现类，实例，或者一个闭包（闭包可以返回一个实现类的实例）。 3、第三个参数控制shared的值。 方法体： 1、绑定前，先清空instances和aliases数组中中存在的同名字的服务。1$this-&gt;dropStaleInstances($abstract); dropStaleInstances($abstract)如下： 12345678910/** * 删除所有过时的实例和别名。 * * @param string $abstract * @return void */protected function dropStaleInstances(string $abstract)&#123; unset($this-&gt;instances[$abstract], $this-&gt;aliases[$abstract]);&#125; 2、然后判断第二个参数$concrete是不是空，如果是空，就视$abstract和$concrete一样。比如：app()-&gt;bind(Boss::class)。 1234if (is_null($concrete))&#123; $concrete = $abstract;&#125; 3、如果当前这个$concrete不是一个闭包。就调用getClosure，返回一个闭包便于后面的操作。1234if (! $concrete instanceof Closure)&#123; $concrete = $this-&gt;getClosure($abstract, $concrete);&#125; 我们去看看这个getClosure方法是怎么返回一个闭包的。 1234567891011121314151617181920/** * 获取要在构建类型时使用的闭包。 * * @param string $abstract * @param string $concrete * @return \Closure */protected function getClosure(string $abstract, string $concrete)&#123; return function ($container, $parameters = []) use ($abstract, $concrete) &#123; if ($abstract == $concrete) &#123; return $container-&gt;build($concrete); &#125; return $container-&gt;resolve( $concrete, $parameters, $raiseEvents = false ); &#125;;&#125; 很简单代码最后直接返回了一个这样形式的闭包：function($container,$parameters=[])。 一些细节： 使用use关键字调用父类就是getClosure传入的$abstract和$concrete两个参数。 如果$abstract和$concrete是一样的，就是如果只有一个参数，或者确实两个参数一样，像这样app-&gt;bind(User::class, User::class)，那么就调用build方法。否则使用resolve方法。（build方法和resolve方法，参看后面章节） 不管怎么样，代码最后直接返回了一个这样形式的闭包：function($container,$parameters=[])。赋值给变量$concrete。而这个闭包内返回的是通过build或者resolve解析的值。 4、我们回到bind方法，上面$concrete得到一个闭包函数后，调用compact把$concrete和$shard（第三个参数判断是否shared）组成一个key分别为concrete和shared的数组，存入binding数组中，而binding数组的key是当前的抽象类。 1$this-&gt;bindings[$abstract] = compact('concrete', 'shared'); 处理后结构是这样的： 1234$binding[$abstract] =&gt; [ 'concrete' =&gt; function($container, $parameters=[]), //getClosure()得到的 'shared' =&gt; true/false, // shared的值是bind的第三个参数] 5、接下来下一句，如果当前的抽象类曾经被解析过。那再次绑定的时候，我们要使用rebound函数触发reboundCallbacks数组中的回调函数。 关于回调函数参看前面章节。 1234if ($this-&gt;resolved($abstract))&#123; $this-&gt;rebound($abstract);&#125; 如何判断当前的$abstract曾经被解析过呢，我们看下resolved函数。12345678910111213141516/** * 确定给定的抽象类型是否已解析。 * * @param string $abstract * @return bool */public function resolved(string $abstract)&#123; if ($this-&gt;isAlias($abstract)) &#123; $abstract = $this-&gt;getAlias($abstract); &#125; return isset($this-&gt;resolved[$abstract]) || isset($this-&gt;instances[$abstract]);&#125; 两个条件： 1.简单判断当前resolved数组中是否存在$abstract。 2.或者instances数组中是存在对应的值。但我们注意，先前在bind方法的第一句$this-&gt;dropStaleInstances($abstract);的时候我们清空了instances对应的$abstract的值，所以这边主要是考虑$abstract的别名在instances中是否存在残留的情况。 总结在bind方法中： 1、首先移除旧的实例，如果参数$concrete不是闭包，是类名，会通过getClosure函数将类名封装进闭包中，返回这个闭包。总之container就要闭包。 注意：build和resolve都是在一个闭包函数中，闭包函数不触发，它是不会创建对象的。也就是所谓的懒加载。关于build和resolve是如何操作的，下几章讲解。 2、然后把返回的闭包函数和share的值组合放入$this-&gt;bindings数组中。 3、最后判断当前这个$abstract是否以前被解析过，如果是，要触发对应的回调函数。 最简单的来说，就是原来在容器中，绑定的是一个id和一个闭包函数的组合。你传入闭包最好，不是闭包，Laravel会转成闭包存起来。 暂时从代码来看，我们可以猜想，最后从容器解析出来的对象是运行这个闭包产生返回的。 那我们就会有这样的猜想了，我们可以通过闭包绑定任何类型的值，因为只要在闭包中返回我们想要的任何类型的值就好了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container share机制与alias别名]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-share%E6%9C%BA%E5%88%B6%E4%B8%8Ealias%E5%88%AB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： class Application extends Container，Application是Container的子类。Application的$this-alias()调用的是Container父类里的方法。怎么理解？ 别名分两块，一个是Laravel自己注册的，另一种是提供了alias()函数给用户调用。怎么理解？ app()-&gt;alias(‘money’,’alias_money’);是这样使用吗？ Share机制简介Laravel的Container中有个shared机制。 123456789101112/** * Determine if a given type is shared. * * @param string $abstract * @return bool */public function isShared($abstract)&#123; return isset($this-&gt;instances[$abstract]) || (isset($this-&gt;bindings[$abstract]['shared']) &amp;&amp; $this-&gt;bindings[$abstract]['shared'] === true);&#125; 满足shared只要满足两个条件中的任意一个： 1.instances数组中存在，说明这个数组中的所有数据都是shard。我们通过名字就知道存储的是实例化的对象。 2.或者，还未实例化，但是已经绑定在数组bindings中并且参数shard==true的类。 总结通过shared我们知道，share就是一个标记。 1.instances这个实例化的数组中都是shared的。 2.未实例化但是已经绑定的数组binging中要注明sharde是true他才是sharde的。 sharde我猜想首先可以用作单例，和其他类共享单个实例，直接从instance中获取便可以了，总的来说就是一个标记。 Alias别名简介服务别名也相对重要，在很多地方使用。 通过服务绑定的别名，在解析服务的时候，跟不使用别名的效果一致。别名的作用也是为了同时支持全类型的服务绑定名称以及简短的服务绑定名称考虑的。 通俗的讲，假如我们想要创建auth服务，我们既可以这样写：1$this-&gt;app-&gt;make('auth'); 又可以写成：1$this-&gt;app-&gt;make('\Illuminate\Auth\AuthManager::class'); 还可以写成1$this-&gt;app-&gt;make('\Illuminate\Contracts\Auth\Factory::class'); 后面两个服务的名字都是auth的别名，使用别名和使用auth的效果是相同的。 这里特别注意，谁是谁的别名。 已测示例我们用别名alias_money重新命名了Money::class，别名先找到‘money’再去找到Money::class 123456789101112131415161718192021class Money&#123; public function getAmount() &#123; return 100; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; app()-&gt;bind('money', Money::class); app()-&gt;alias('money', 'alias_money'); $boss= app()-&gt;make('alias_money'); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, 100); &#125;&#125; 服务别名的获取我们看下源码： 1、看看有没有对应的$abstract的别名。如果没有就返回当前$abstract。 2、进一步递归，查看这个别名是否还有别名的别名。 123456789101112/** * Get the alias for an abstract if available. * * @param string $abstract * @return string */public function getAlias($abstract)&#123; return isset($this-&gt;aliases[$abstract]) ? $this-&gt;getAlias($this-&gt;aliases[$abstract]) : $abstract;&#125; 服务别名的实现那么这些别名是如何加载到服务容器里面的呢？ 两种方法： 1、通过调用Container中的alias方法，我们看下源代码： 1234567891011121314151617181920/** * Alias a type to a different name. * * @param string $abstract * @param string $alias * @return void * * @throws \LogicException */public function alias($abstract, $alias)&#123; // 如果发现别名和$abstract一样，抛出异常，别名不能和自己一样。 if ($alias === $abstract) &#123; throw new LogicException("[&#123;$abstract&#125;] is aliased to itself."); &#125; $this-&gt;aliases[$alias] = $abstract; $this-&gt;abstractAliases[$abstract][] = $alias;&#125; 这里有两个数组：aliases和abstractAliases，他们保存一样的数据，但是键值对相反。简单说就是aliases的key值是abstractAliases的value值。把key和value分别存储到对应的数组中。 2、外部配置引入。 其实原理也是一样，使用alias()方法，但是laravel在初始化的时候自己读取配置文件去存入对应数组中。 有两个地方，一个是app.php文件下的alias数组中，还有一个是在laravel/framwork/src/Illuminate/Foundation/Application.php下的registerCoreContainerAliases方法，这个方法在Application初始化的时候会加载。Application是Container的子类，应用容器。后面再讨论。 看部分代码实例：123456789101112131415161718192021222324&lt;?php$aliases = [ 'app' =&gt; [ \Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class ], 'auth' =&gt; [ \Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class ], 'auth.driver' =&gt; [ \Illuminate\Contracts\Auth\Guard::class ], 'blade.compiler' =&gt; [ \Illuminate\View\Compilers\BladeCompiler::class ], 'cache' =&gt; [ \Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class ],...] 运行的registerCoreContainerAliases方法。我们可以看到还是调用了alias()方法。12345678910111213/** * Register the core class aliases in the container. * * @return void */public function registerCoreContainerAliases()&#123; foreach ([$aliases] as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125;&#125; 加载后，服务容器的aliases和abstractAliases数组实例：123456789101112$aliases = [ 'Illuminate\Foundation\Application' = "app" 'Illuminate\Contracts\Container\Container' = "app" 'Illuminate\Contracts\Foundation\Application' = "app" 'Illuminate\Auth\AuthManager' = "auth" 'Illuminate\Contracts\Auth\Factory' = "auth" 'Illuminate\Contracts\Auth\Guard' = "auth.driver" 'Illuminate\View\Compilers\BladeCompiler' = "blade.compiler" 'Illuminate\Cache\CacheManager' = "cache" 'Illuminate\Contracts\Cache\Factory' = "cache" ...］ 1234567891011121314151617$abstractAliases = [ app = &#123;array&#125; [3] 0 = &quot;Illuminate\Foundation\Application&quot; 1 = &quot;Illuminate\Contracts\Container\Container&quot; 2 = &quot;Illuminate\Contracts\Foundation\Application&quot; auth = &#123;array&#125; [2] 0 = &quot;Illuminate\Auth\AuthManager&quot; 1 = &quot;Illuminate\Contracts\Auth\Factory&quot; auth.driver = &#123;array&#125; [1] 0 = &quot;Illuminate\Contracts\Auth\Guard&quot; blade.compiler = &#123;array&#125; [1] 0 = &quot;Illuminate\View\Compilers\BladeCompiler&quot; cache = &#123;array&#125; [2] 0 = &quot;Illuminate\Cache\CacheManager&quot; 1 = &quot;Illuminate\Contracts\Cache\Factory&quot; ...] 我们在这里还是要特别强调： 数组$abstractAliases中，app是abstract，后面跟着的三个数组元素才是‘app’的别名（alias） 1234app = &#123;array&#125; [3] 0 = &quot;Illuminate\Foundation\Application&quot; 1 = &quot;Illuminate\Contracts\Container\Container&quot; 2 = &quot;Illuminate\Contracts\Foundation\Application&quot; 这里的这个结构需要指出的是，不管这个app别名有多少个，这些别名都指向一个abstract，这个abstract又会指向数组binding，binding数组是建立abstract和concrete关系的数组，而这个$abstractAliases和$aliases则是建立abstruc和alias之间关系的数组。 总结别名机制就是用一个别名来命名具体对象，类或者闭包函数。他在Facade中有运用到，以及在容器绑定和解析都有用到。我们只要记住，他存储的两个数组名字： 1.abstractAliases 2.abstracts 我觉得他主要的作用可能就是让代码简洁吧。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container callbacks回调函数机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-callbacks%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在某些操作的节点，比如解析后，插入必要的一些操作。怎么理解？ call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] ) : mixed; app()-&gt;rebinding(‘money’, Closure);是这样使用吗？ 简介回调函数在容器中，用的也很多。先说作用，在某些操作的节点，比如解析后，插入必要的一些操作。感觉就像hook和事件Event一样。 在Container中，有好几种callbacks：12345protected $reboundCallbacks = []; // 所有注册的回调protected $globalResolvingCallbacks = []; // 所有全局解析回调protected $globalAfterResolvingCallbacks = []; // 所有全局解析之后回调protected $resolvingCallbacks = []; // 所有类的解析回调protected $afterResolvingCallbacks = []; // 所有类的解析之后回调 他们分别出现在不一样的地方被调用。 我们以第一个rebound举例，其他几个大同小异。 实测例子在extend之前rebinding一个回调函数，当extend完成，会输出this is rebinding callbacks12345678910111213141516171819202122232425262728293031323334class Money&#123; public function getAmount()&#123; return 100; &#125;&#125;class Dollar extends Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; app()-&gt;bind('money', Money::class); app()-&gt;rebinding('money', function()&#123; var_dump("this is rebinding callbacks"); &#125;); app()-&gt;extend('money',function()&#123; return new Dollar(); &#125;); $boss= app()-&gt;make('money'); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, 1); &#125;&#125; 源码触发rebound()回调函数的源码如下： 1234567891011121314/** * Fire the "rebound" callbacks for the given abstract type. * * @param string $abstract * @return void */protected function rebound($abstract)&#123; $instance = $this-&gt;make($abstract); foreach ($this-&gt;getReboundCallbacks($abstract) as $callback) &#123; call_user_func($callback, $this, $instance); &#125;&#125; 1.解析当前的对象。 2.然后查看当前容器中是否存在对应的rebound回调函数，如果有，遍历所有对应的回调函数，使用call_user_func执行回调函数。 2.1 看下getReboundCallbacks，获取对应所有的回调函数,是通过reboundCallbacks数组获得。源码如下： 12345678910/** * Get the rebound callbacks for a given type. * * @param string $abstract * @return array */protected function getReboundCallbacks($abstract)&#123; return $this-&gt;reboundCallbacks[$abstract] ?? [];&#125; 3.最后这个rebound()方法我们上一章1.2中知道，它会在extend绑定完成后会调用触发。 回调函数的绑定 我们上面涉及了调用，我们下面看下如何绑定。 回调函数的绑定是通过函数rebinding处理的，很简单，就是把对应的回调函数存入reboundCallbacks数组。 最后一句，如果这个对象已经绑定过了，还会贴心的返回这个对象。123456789101112131415/** * Bind a new callback to an abstract's rebind event. * * @param string $abstract * @param \Closure $callback * @return mixed */public function rebinding($abstract, Closure $callback)&#123; $this-&gt;reboundCallbacks[$abstract = $this-&gt;getAlias($abstract)][] = $callback; if ($this-&gt;bound($abstract)) &#123; return $this-&gt;make($abstract); &#125;&#125; 总结回调函数也很简单，我们只要知道在这个例子中，他通过方法rebinding，把回调函数存储在数组reboundCallbacks中，然后使用rebound以及其他几个函数在不同的地方触发。（extend扩展中触发了。）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container extend扩展机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-extend%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： extend()在make()之前调用，里面并没有任何实例化处理，只是判断然后放进两个数组，instances和extenders。是什么判断？ extend的机制就是如果instance中存在实例，就用extend中的闭包执行结果替换掉。如果instances实例列表中不存在就存起来以后备用。怎么理解？ extend($abstract, Closure $closure)第二个闭包参数接不接收参数有什么区别？ 实测实例 实例1：替换依赖的实例对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 接口interface Money&#123; public function getAmount();&#125;class Dollar implements Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class Cheque implements Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;// 老板class Boss&#123; private $money; public function __construct(Money $money) &#123; $this-&gt;money = $money; // prints '100000' &#125; public function getA()&#123; return $this-&gt;money-&gt;getAmount(); &#125;&#125;// 老板发钱给员工public function testClosure()&#123; // 1、绑定 app()-&gt;bind('boss', Boss::class); // 老板的钱是支票 $this-&gt;app-&gt;when(Boss::class) -&gt;needs(Money::class) -&gt;give(Cheque::class); // 把支票扩展为美元 app()-&gt;extend(Money::class, function() &#123; // 闭包没有接收参数 return new Dollar(); &#125;); // 2、解析得到老板实例 $boss = app()-&gt;make('boss'); $output = $boss-&gt;getA(); $this-&gt;assertEquals($output, 1); // 实际最后是美元&#125; 本来的Boss实例的依赖Money是一个Cheque对象，最后解析的时候，被替换成了Dollar对象。 实例2：子类替换父类，向下拓展 12345678910111213141516171819202122232425262728293031323334class Money&#123; public function getAmount()&#123; return 100; &#125;&#125;class Dollar extends Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class Cheque extends Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;public function testClosure()&#123; // 父类被替换成子类 app()-&gt;extend(Money::class, function() &#123; // 闭包没有接收参数 return new Dollar(); &#125;); $money= app()-&gt;make(Money::class); $output = $money-&gt;getAmount(); $this-&gt;assertEquals($output, 1);&#125; 实例3：向其他地方拓展 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Money&#123; public function getAmount()&#123; return 100; &#125;&#125;class Dollar extends Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class Cheque extends Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;class Currenty&#123; protected $money; public function __construct(Money $money) &#123; $this-&gt;money = $money; &#125; public function getAmount() &#123; return "harveynorman"; &#125;&#125;public function testClosure()&#123; app()-&gt;bind('money', Money::class); app()-&gt;extend('money', function($money) &#123; // 闭包接收了参数 return new Currenty($money); &#125;); $boss = app()-&gt;make('money'); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, "harveynorman");&#125; extend的第二个参数是闭包，闭包的第一个参数就是extend第一个参数的实例，在这里就是我们事先绑定的Money::class实例。 简介extend方法可以修改解析的服务。例如，当一个服务被解析后，你可以添加额外的代码去修饰或配置这个服务。extend方法接受一个闭包，闭包的唯一参数和返回值都是一个服务： 123$this-&gt;app-&gt;extend(Service::class, function($service) &#123; return new DecoratedService($service);&#125;); extend主要的作用是在解析后，使用一个闭包函数产生的值（通常为当前实体类的子类）替换对应父实体类，从而对其产生扩展影响。这个闭包的参数和返回值都必须是对象。比如：123app()-&gt;extend('Service', function ($service, $app) &#123; return new DecoratedService($service);&#125;); 这里DecoratedService是Service的子类。 更简单来说，当我们从Container容器中取出一个实例后，用这个类的子类实例替换掉当前这个父类实例，达到扩展的作用。 当然这是一种用法。还有一些细节，我们去看下源代码。 源码12345678910111213141516171819202122232425/** * "Extend" an abstract type in the container. * * @param string $abstract * @param \Closure $closure * @return void * * @throws \InvalidArgumentException */public function extend($abstract, Closure $closure)&#123; $abstract = $this-&gt;getAlias($abstract); if (isset($this-&gt;instances[$abstract])) &#123; $this-&gt;instances[$abstract] = $closure($this-&gt;instances[$abstract], $this); $this-&gt;rebound($abstract); &#125; else &#123; $this-&gt;extenders[$abstract][] = $closure; if ($this-&gt;resolved($abstract)) &#123; $this-&gt;rebound($abstract); &#125; &#125;&#125; 1、先获取Container中这个id($abstract)的别名。 2、查看容器已有的实例数组instance里面有没有对应的实例，如果有，直接执行我们extend的这个闭包方法，返回值存入这个数组中，就是替换了原来的实例。 然后使用了rebound()，目的是看看有没有附带的回调函数，触发它，这个我们在回调函数中会提。 这说明extend的时候会触发回调函数。 3、如果instance中没有找到对应的实例，就把这个闭包函数存入extenders数组，做个记录，以后用。 并且如果这个id已经被resolved过了，还要触发rebound函数，触发一些对应的回调函数。 总结extend的机制就是如果instance中存在实例，就用extend中的闭包执行结果替换掉。如果instances实例列表中不存在就存起来以后备用。 某个适用场景可以是：用子类实例替换父类实例达到扩展的作用。 但不管怎么样，都会触发当前存在的回调函数一次。下一章讲一下回调函数。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container contextual上下文绑定机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-Contextual%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。怎么理解？ 上下文绑定把数据存入了这样的数组contextual[PhotoController::class][Filesystem::class] = 闭包函数（也可以是一个类路径）。怎么理解？只有这个数组contextual，在make的时候会用到。 闭包函数可以实现懒加载，怎么理解？ Container类的属性基本都是数组。为什么？ $resolved数组存储的[‘abstractClassName’=&gt;true/false]。$bindings存储的是二维数组[‘abstractClassName’=&gt;[]]。methodBindings存储的是[‘methodName’=&gt;$closure]。$instances存储[‘abstractClassName’=&gt;$instance对象实例]。 $alias数组存储的是[‘别名’=&gt;’abstractClassName’]。$buildStack一维数组[concrete]是要构建的具体类。$with数组是参数的数组。 有三种角色，需要实例化的类A，A的依赖抽象类B，B的具体实现C。怎么理解？ 简介上下文绑定在分析Container源码的时候是一个比较重要的部分，在了解上下文绑定之前，先解释下什么是上下文： 每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。 简单说就是解析一个对象的时候，有些对象是需要外部的一些依赖的。那他在创建的时候就要用到“上下文”把依赖引入。 而上下文绑定的意思就是专门处理实例化时候，有依赖关系情况的一种绑定。 上下文绑定在Laravel文档中给出了相关示例：12345678910111213141516use Illuminate\Support\Facades\Storage;use App\Http\Controllers\PhotoController;use App\Http\Controllers\VideoController;use Illuminate\Contracts\Filesystem\Filesystem;$this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('local'); &#125;);$this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('s3'); &#125;); 这是项目中常会用到的存储功能，得益于Laravel内置集成了FlySystem的Filesystem接口，我们很容易实现多种存储服务的项目。 示例中将用户头像存储到本地，将用户上传的小视频存储到云服务。那么这个时候就需要区分这样不同的使用场景（即上下文或者说环境）。 当用户存储头像（PhotoController::class）需要使用存储服务（Filesystem::class）时，我们将本地存储驱动，作为实现给到PhotoController::class。123function () &#123; return Storage::disk('local');&#125; 而当用户上传视频VideoController::class，需要使用存储服务（Filesystem::class）时，我们则将云服务驱动，作为实现给到VideoController::class。123function () &#123; return Storage::disk('s3');&#125; 实测用例12345678910111213141516171819if (! function_exists('app')) &#123; /** * Get the available container instance. * * @param string|null $abstract * @param array $parameters * @return mixed|\Illuminate\Contracts\Foundation\Application */ function app($abstract = null, array $parameters = []) &#123; if (is_null($abstract)) &#123; return Container::getInstance(); &#125; return Container::getInstance()-&gt;make($abstract, $parameters); &#125;&#125; Illuminate/Container/Container.php 123456789101112131415161718192021222324class Container implements ArrayAccess, ContainerContract&#123; /** * The current globally available container (if any). * * @var static */ protected static $instance; /** * Get the globally available instance of the container. * * @return static */ public static function getInstance() &#123; if (is_null(static::$instance)) &#123; static::$instance = new static; &#125; return static::$instance; &#125;&#125; 提供的类关系： 123456789101112131415161718192021222324252627282930// interface接口moneyinterface Money&#123; public function getAmount();&#125;// 实现类Cheque（支票）class Cheque implements Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;// Boss类class Boss&#123; private $money; public function __construct(Money $money) &#123; $this-&gt;money = $money; // prints '100000' &#125; public function getA() &#123; return $this-&gt;money-&gt;getAmount(); &#125;&#125; 测试1：绑定Boss类，Boss类依赖Money类的一个对象。最后绑定的实现是Cheque类。 123456789101112public function testClosure()&#123; $this-&gt;app-&gt;when(Boss::class) -&gt;needs(Money::class) -&gt;give(Cheque::class); $boss = app()-&gt;make(Boss::class); $output = $boss-&gt;getA(); $this-&gt;assertEquals($output, 100000);&#125; 源码 Illuminate\Container\Util.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace Illuminate\Container;use Closure;class Util&#123; /** * If the given value is not an array and not null, wrap it in one. * * From Arr::wrap() in Illuminate\Support. * * @param mixed $value * @return array */ public static function arrayWrap($value) &#123; if (is_null($value)) &#123; return []; &#125; return is_array($value) ? $value : [$value]; &#125; /** * Return the default value of the given value. * * From global value() helper in Illuminate\Support. * * @param mixed $value * @return mixed */ public static function unwrapIfClosure($value) &#123; return $value instanceof Closure ? $value() : $value; &#125;&#125; 1、看下when方法。 illuminate\Container\Container.php 1234567891011121314151617/** * Define a contextual binding. * * @param array|string $concrete * @return \Illuminate\Contracts\Container\ContextualBindingBuilder */public function when($concrete)&#123; $aliases = []; foreach (Util::arrayWrap($concrete) as $c) &#123; $aliases[] = $this-&gt;getAlias($c); &#125; return new ContextualBindingBuilder($this, $aliases);&#125; 这个方法直接生成一个ContextualBindingBuilder对象，传入container对象和$concrete。 $concrete在这个例子中就是PhotoController::class和VideoController::class。 我们暂且用PhotoController::class为例。 2、然后进入这个ContextualBindingBuilder类看下。 Illuminate\Contracts\Container\ContextualBindingBuilder.php 12345678910111213141516171819202122&lt;?phpnamespace Illuminate\Contracts\Container;interface ContextualBindingBuilder&#123; /** * Define the abstract target that depends on the context. * * @param string $abstract * @return $this */ public function needs($abstract); /** * Define the implementation for the contextual binding. * * @param \Closure|string $implementation * @return void */ public function give($implementation);&#125; Illuminate\Container\ContextualBindingBuilder.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpnamespace Illuminate\Container;use Illuminate\Contracts\Container\Container;use Illuminate\Contracts\Container\ContextualBindingBuilder as ContextualBindingBuilderContract;class ContextualBindingBuilder implements ContextualBindingBuilderContract&#123; /** * The underlying container instance. * * @var \Illuminate\Contracts\Container\Container */ protected $container; /** * The concrete instance. * * @var string|array */ protected $concrete; /** * The abstract target. * * @var string */ protected $needs; /** * Create a new contextual binding builder. * * @param \Illuminate\Contracts\Container\Container $container * @param string|array $concrete * @return void */ public function __construct(Container $container, $concrete) &#123; $this-&gt;concrete = $concrete; $this-&gt;container = $container; &#125; /** * Define the abstract target that depends on the context. * * @param string $abstract * @return $this */ public function needs($abstract) &#123; $this-&gt;needs = $abstract; return $this; &#125; /** * Define the implementation for the contextual binding. * * @param \Closure|string $implementation * @return void */ public function give($implementation) &#123; foreach (Util::arrayWrap($this-&gt;concrete) as $concrete) &#123; $this-&gt;container-&gt;addContextualBinding($concrete, $this-&gt;needs, $implementation); &#125; &#125;&#125; 这个类不大，提供了两个方法，needs和give。 先看下needs方法，很简单就是把$abstract存储起来。 这个例子中的$abstract就是Filesystem::class类。 然后返回当前对象，以致可以继续链式操作。123456789101112/** * Define the abstract target that depends on the context. * * @param string $abstract * @return $this */public function needs($abstract)&#123; $this-&gt;needs = $abstract; return $this;&#125; 3、再看下give方法： 12345678910111213/** * Define the implementation for the contextual binding. * * @param \Closure|string $implementation * @return void */public function give($implementation)&#123; foreach (Util::arrayWrap($this-&gt;concrete) as $concrete) &#123; $this-&gt;container-&gt;addContextualBinding($concrete, $this-&gt;needs, $implementation); &#125;&#125; 很简单又重新调用了Container中的addContextualBinding()，这个就是添加上下文绑定的方法，分别传入的是： concrete：PhotoController::class的别名（如果有的话）。 abstract：Filesystem::class。 implementation：闭包Storage::disk(“local”);的返回值。 4、然后我们回到Container看看方法addContextualBinding()。 123456789101112/** * Add a contextual binding to the container. * * @param string $concrete * @param string $abstract * @param \Closure|string $implementation * @return void */public function addContextualBinding($concrete, $abstract, $implementation)&#123; $this-&gt;contextual[$concrete][$this-&gt;getAlias($abstract)] = $implementation;&#125; 也很简单，就是把这些参数存入contextual数组。 （这个特别重要）数组结构形式为： contextual[PhotoController::class][Filesystem::class] = 闭包函数（也可以是一个类路径） 这就完成了一个上下文绑定。说到底和普通绑定雷同，只不过是处理有依赖的对象。 总结当一个类实例化需要一些外部依赖的时候，就要用到上下文绑定。把外部依赖通过needs传递给他。还可以通过give存储when对应的实现（针对抽象类或者接口甚至是子类）。存入到容器中那个负责上下文的那个数组中，这个数组将会在解析的时候（就是取出某个对象的时候，他对应绑定的依赖也会被取出）做判断。 必须指出，我们通过源码观察，（存储的结构：contextual[when][needs] = implement）我们发现这个implement可以传入任何类型的值，理论上来说绑定的时候没有任何问题，但是当解析的时候，他必须是一个闭包或者是needs的子类或实现类，不然它是无法解析的。在build章节中有分析。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的事务隔离级别]]></title>
    <url>%2F2020%2F04%2F23%2FMySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 脏读是一个事务在处理过程中读取了另外一个事务未提交的数据。为什么会发生脏读？ 不可重复读，是指一个事务范围内，多次查询某个数据，却得到不同的结果。怎么理解？ 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。怎么理解？ 隔离程度越强，事务的执行效率越低。为什么？ MySQL的默认事务隔离级别是哪个？ 使用过关系型数据库的，应该对事务的概念有所了解，知道事务有ACID四个基本属性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），今天我们主要来理解一下事务的隔离性。 什么是事务？ 数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。 事务的概念看上去不难，但是需要注意以下几个点： 1、首先，事务就是要保证一组数据库操作，要么全部成功，要么全部失败； 2、在MySQL中，事务支持是在引擎层实现的； 3、并不是所有引擎都支持事务，如MyISAM就不支持，InnoDB就支持； 今天，我们的主角是隔离性，隔离性是指当多个用户并发操作数据库时，数据库为每一个用户开启不同的事务，这些事务之间相互不干扰，相互隔离。 为什么需要隔离性？如果事务之间不是互相隔离的，可能将会出现以下问题。 1、脏读脏读（dirty read），简单来说，就是一个事务在处理过程中读取了另外一个事务未提交的数据。 这种未提交的数据我们称之为脏数据。依据脏数据所做的操作可能是不正确的。 还记得上节中我们提到的dirty page吗？这种临时处理的未提交的，都是「脏」的。 但是，若该事务未提交成功，最终所有操作都会回滚，小编看到的一分钱也只是镜花水月。比如，你给小编赞赏1分钱，整个事务需要两个步骤： ①给小编账号加一分钱，这时小编看到了，觉得很欣慰；②你的账号减一分钱； 2、不可重复读不可重复读（non-repeatable read），是指一个事务范围内，多次查询某个数据，却得到不同的结果。 在第一个事务中的两次读取数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能就是不一样的。 接着上一个例子，假设你真给小编打赏了一分钱，小编乐得屁颠屁颠地去准备提现，一查，发现真多了一分钱。 在这同时，在我还没有提现成功之前，小编的老婆已经提前将这一分钱支走了，小编此时再次查账，发现一分钱也没了。 脏读和不可重复读区别 二者的区别是，脏读是某一事务读取了另外一个事务未提交的数据，不可重复读是读取了其他事务提交的数据。 其实，有些情况下，不可重复读不是问题，比如，小编提现期间，一分钱被老婆支走了，这不是问题！ 而脏读，是可以通过设置隔离级别避免的。 3、幻读幻读（phantom read），是事务非独立执行时发生的一种现象。 例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项为“1”的数据，并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现数据怎么还是1？其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 其实上面的解释已经是一个例子了，但是还是要举个例子。 比如，小编准备提取你打赏的一分钱，提取完了，这时又有其他热心网友打赏了一分钱，小编一看，明明已经取出了，怎么又有一分钱！？ 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 事务的隔离级别为了解决上面可能出现的问题，我们就需要设置隔离级别，也就是事务之间按照什么规则进行隔离，将事务隔离到什么程度。 首先，需要明白一点，隔离程度越强，事务的执行效率越低。 ANSI/ISO SQL定义了4种标准隔离级别： ① Serializable（串行化）：花费最高代价但最可靠的事务隔离级别。 “写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 事务100%隔离，可避免脏读、不可重复读、幻读的发生。 ② Repeatable read（可重复读，默认级别）：多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。 但如果这个事务在读取某个范围内的记录时，其他事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，这就是幻读。 可避免脏读、不可重复读的发生。但是可能会出现幻读。 ③ Read committed（读已提交）：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。 可避免脏读的发生，但是可能会造成不可重复读。 大多数数据库的默认级别就是Read committed，比如Sql Server，Oracle。 ④ Read uncommitted（读未提交）：最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。 任何情况都无法保证。 隔离级别 下图中是一个很好的例子，分别解释了四种事务隔离级别下，事务B能够读取到的结果。 看着还是有点懵逼？那我们再举个例子。 A，B两个事务，分别做了一些操作，操作过程中，在不同隔离级别下查看变量的值： 隔离级别是串行化，则在事务B执行「将1改成2」的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。 再次总结 读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。串行：我的事务尚未提交，别人就别想改数据。 这4种隔离级别，并行性能依次降低，安全性依次提高。 总的来说，事务隔离级别越高，越能保证数据的完整性和一致性，但是付出的代价却是并发执行效率的低下。 隔离级别的实现事务的机制是通过视图（read-view）来实现的并发版本控制（MVCC），不同的事务隔离级别创建读视图的时间点不同。 可重复读是每个事务重建读视图，整个事务存在期间都用这个视图。 读已提交是每条SQL创建读视图，在每个SQL语句开始执行的时候创建的。隔离作用域仅限该条SQL语句。 读未提交是不创建，直接返回记录上的最新值 串行化隔离级别下直接用加锁的方式来避免并行访问。 这里的视图可以理解为数据副本，每次创建视图时，将当前已持久化的数据创建副本，后续直接从副本读取，从而达到数据隔离效果。 隔离级别的实现我们每一次的修改操作，并不是直接对行数据进行操作。 比如我们设置id为3的行的A属性为0，并不是直接修改表中的数据，而是新加一行。 同时数据表其实还有一些隐藏的属性，比如每一行的事务id，所以每一行数据可能会有多个版本，每一个修改过它的事务都会有一行，并且还会有关联的undo日志，表示这个操作原来的数据是什么，可以用它做回滚。 那么为什么要这么做？ 因为如果我们直接把数据修改了，那么其他事务就用不了原先的值了，违反了事务的一致性。 那么一个事务读取某一行的数据到底返回什么结果呢？ 取决于隔离级别，如果是 Read Committed，那么返回的是最新的事务的提交值，所以未提交的事务修改的值是不会读到的，这就是Read Committed实现的原理。 如果是Read Repeatable级别，那么只能返回发起时间比当前事务早的事务的提交值，和比当前事务晚的删除事务删除的值。这其实就是MVCC方式。 undo logundo log中存储的是老版本数据。假设修改表中id=2的行数据，把Name=’B’修改为Name=’B2’，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。 当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。 假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。 当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。 如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-viewA，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。 同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。 另外，在回滚段中的undo log分为: insert undo log 和update undo log： insert undo log：事务对insert新记录时产生的undolog，只在事务回滚时需要，并且在事务提交后就可以立即丢弃。（谁会对刚插入的数据有可见性需求呢！！） update undo log：事务对记录进行delete和update操作时产生的undo log。不仅在事务回滚时需要，一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。 何时删除？ 在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 就是当系统里没有比这个回滚日志更早的read-view的时候。 长事务直观感觉，一个事务花费很长时间不能够结束，就是一个长的事务，简称长事务（Long Transaction）。 长事务是数据库用户经常会碰到且是非常令人头疼的问题。长事务处理需要恰当进行，如处理不当可能引起数据库的崩溃，为用户带来不必要的损失。 根据上面的论述，长事务意味着系统里面会存在很老的事务视图。 由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的undo log都必须保留，这就会导致大量占用存储空间。 在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。 因此，我们要尽量避免长事务。 小结这一节主要是事务的隔离级别，主要需要记住几个隔离级别、了解一下实现方式。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的static延迟静态绑定功能]]></title>
    <url>%2F2020%2F04%2F21%2FPHP%E7%9A%84static%E5%BB%B6%E8%BF%9F%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 从这个名字的定义提取出两个关键点，第一点静态，也就是说这个功能只适用于静态属性或静态方法。 第二点延迟绑定，这个根据下面代码就可以很好的理解。 看一下这个例子：12345678910111213141516171819202122232425262728293031class A&#123; static $name = "Tom"; public function printName() &#123; echo self::$name."\n"; self::fun(); &#125; static function fun() &#123; echo "A Class\n"; &#125;&#125;class B extends A&#123; static $name = "Jon"; static function fun() &#123; echo "B Class\n"; &#125;&#125;$obj = new B();$obj-&gt;printName();// 输出结果// Tom// A Class 我在printName函数里面使用了self关键字，self是指向当前类的”指针”，所以很多人会理想的认为输出结果会是这样：12// Join// B Class 是这样的，在定义A类的时候，在函数printName里面使用self关键字调用了静态方法或属性，但是这个函数一旦定义好，A类的静态方法和属性就被绑定到函数了，不要去追究为什么，php就是这么实现的，但是我们现在要实现这样的效果，就是函数定义好后里面使用到的静态方法和属性不要立即绑定死，而是根据最终继承的类来确定绑定。 所以php在5.5以后使用了static关键字来解决这个问题，解决后的代码例子如下：12345678910111213141516171819202122232425262728293031class A&#123; static $name = "Tom"; public function printName() &#123; echo static::$name."\n"; static::fun(); &#125; static function fun() &#123; echo "A Class\n"; &#125;&#125;class B extends A&#123; static $name = "Jon"; static function fun() &#123; echo "B Class\n"; &#125;&#125;$obj = new B();$obj-&gt;printName();// 输出结果// Join// B Class 大家可以在项目中自行挖掘使用场景，比如一个会员父类class Vip，下面两个子类分别是超级会员svip和年费会员yvip，可以在两个子类中分别重写static usergroup()方法或者其他静态属性，父类中使用延迟静态绑定，这样可以写出很优雅的代码。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Throttle]]></title>
    <url>%2F2020%2F04%2F17%2FLaravel-Throttle%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 使用可以使用时间或并发（Laravel-Funnel）来控制队列任务。该功能特性在队列任务与有频率限制的API交互时很有帮助。 通过throttle方法，你可以限定给定类型任务每60秒只运行10次。如果不能获取锁，需要将任务释放回队列以便可以再次执行： 123456789Redis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic... // 1分钟点击了100下，但是1分钟只有10条数据写入文件 // file_put_contents('1.txt', date('Y-m-d H:i:s').PHP_EOL, FILE_APPEND);&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 注：在上面的例子中，key可以是任意可以唯一标识你想要限定访问频率的任务类型的字符串。举个例子，这个键可以基于任务类名和操作Eloquent模型的ID进行构建。 源码 Illuminate\Redis\Limiters\DurationLimiter.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;?phpnamespace Illuminate\Redis\Limiters;use Illuminate\Contracts\Redis\LimiterTimeoutException;class DurationLimiter&#123; /** * The Redis factory implementation. * * @var \Illuminate\Redis\Connections\Connection */ private $redis; /** * The unique name of the lock. * * @var string */ private $name; /** * The allowed number of concurrent tasks. * * @var int */ private $maxLocks; /** * The number of seconds a slot should be maintained. * * @var int */ private $decay; /** * The timestamp of the end of the current duration. * * @var int */ public $decaysAt; /** * The number of remaining slots. * * @var int */ public $remaining; /** * Create a new duration limiter instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $maxLocks * @param int $decay * @return void */ public function __construct($redis, $name, $maxLocks, $decay) &#123; $this-&gt;name = $name; $this-&gt;decay = $decay; $this-&gt;redis = $redis; $this-&gt;maxLocks = $maxLocks; &#125; /** * Attempt to acquire the lock for the given number of seconds. * * @param int $timeout * @param callable|null $callback * @return mixed * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException */ public function block($timeout, $callback = null) &#123; $starting = time(); while (! $this-&gt;acquire()) &#123; if (time() - $timeout &gt;= $starting) &#123; throw new LimiterTimeoutException; &#125; usleep(750 * 1000); &#125; if (is_callable($callback)) &#123; return $callback(); &#125; return true; &#125; /** * Attempt to acquire the lock. * * @return bool */ public function acquire() &#123; $results = $this-&gt;redis-&gt;eval( $this-&gt;luaScript(), 1, $this-&gt;name, microtime(true), time(), $this-&gt;decay, $this-&gt;maxLocks ); $this-&gt;decaysAt = $results[1]; $this-&gt;remaining = max(0, $results[2]); return (bool) $results[0]; &#125; /** * Get the Lua script for acquiring a lock. * * KEYS[1] - The limiter name * ARGV[1] - Current time in microseconds * ARGV[2] - Current time in seconds * ARGV[3] - Duration of the bucket * ARGV[4] - Allowed number of tasks * * @return string */ protected function luaScript() &#123; return &lt;&lt;&lt;'LUA'local function reset() redis.call('HMSET', KEYS[1], 'start', ARGV[2], 'end', ARGV[2] + ARGV[3], 'count', 1) return redis.call('EXPIRE', KEYS[1], ARGV[3] * 2)endif redis.call('EXISTS', KEYS[1]) == 0 then return &#123;reset(), ARGV[2] + ARGV[3], ARGV[4] - 1&#125;endif ARGV[1] &gt;= redis.call('HGET', KEYS[1], 'start') and ARGV[1] &lt;= redis.call('HGET', KEYS[1], 'end') then return &#123; tonumber(redis.call('HINCRBY', KEYS[1], 'count', 1)) &lt;= tonumber(ARGV[4]), redis.call('HGET', KEYS[1], 'end'), ARGV[4] - redis.call('HGET', KEYS[1], 'count') &#125;endreturn &#123;reset(), ARGV[2] + ARGV[3], ARGV[4] - 1&#125;LUA; &#125;&#125; Illuminate\Redis\Limiters\DurationLimiterBuilder.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phpnamespace Illuminate\Redis\Limiters;use Illuminate\Contracts\Redis\LimiterTimeoutException;use Illuminate\Support\InteractsWithTime;class DurationLimiterBuilder&#123; use InteractsWithTime; /** * The Redis connection. * * @var \Illuminate\Redis\Connections\Connection */ public $connection; /** * The name of the lock. * * @var string */ public $name; /** * The maximum number of locks that can obtained per time window. * * @var int */ public $maxLocks; /** * The amount of time the lock window is maintained. * * @var int */ public $decay; /** * The amount of time to block until a lock is available. * * @var int */ public $timeout = 3; /** * Create a new builder instance. * * @param \Illuminate\Redis\Connections\Connection $connection * @param string $name * @return void */ public function __construct($connection, $name) &#123; $this-&gt;name = $name; $this-&gt;connection = $connection; &#125; /** * Set the maximum number of locks that can obtained per time window. * * @param int $maxLocks * @return $this */ public function allow($maxLocks) &#123; $this-&gt;maxLocks = $maxLocks; return $this; &#125; /** * Set the amount of time the lock window is maintained. * * @param int $decay * @return $this */ public function every($decay) &#123; $this-&gt;decay = $this-&gt;secondsUntil($decay); return $this; &#125; /** * Set the amount of time to block until a lock is available. * * @param int $timeout * @return $this */ public function block($timeout) &#123; $this-&gt;timeout = $timeout; return $this; &#125; /** * Execute the given callback if a lock is obtained, otherwise call the failure callback. * * @param callable $callback * @param callable|null $failure * @return mixed * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException */ public function then(callable $callback, callable $failure = null) &#123; try &#123; return (new DurationLimiter( $this-&gt;connection, $this-&gt;name, $this-&gt;maxLocks, $this-&gt;decay ))-&gt;block($this-&gt;timeout, $callback); &#125; catch (LimiterTimeoutException $e) &#123; if ($failure) &#123; return $failure($e); &#125; throw $e; &#125; &#125;&#125; Illuminate\Redis\Connections\Connection.php 12345678910111213141516171819202122232425262728&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Redis\Events\CommandExecuted;use Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder;use Illuminate\Redis\Limiters\DurationLimiterBuilder;use Illuminate\Support\Traits\Macroable;abstract class Connection&#123; use Macroable &#123; __call as macroCall; &#125; /** * Throttle a callback for a maximum number of executions over a given duration. * * @param string $name * @return \Illuminate\Redis\Limiters\DurationLimiterBuilder */ public function throttle($name) &#123; return new DurationLimiterBuilder($this, $name); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel中通过Macroable宏来扩展类的能力]]></title>
    <url>%2F2020%2F04%2F15%2FLaravel%E4%B8%AD%E9%80%9A%E8%BF%87Macroable%E5%AE%8F%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 闭包函数为Closure类的实例对象。怎么理解？ $new_closure = Closure::bind($closure, new ClassName(), ClassName::class);和$new_closure = $closure-&gt;bindTo(new ClassName(), ClassName::class);有什么区别？ PHP闭包中的绑定bindTo和bind123456789101112131415161718192021final class Closure &#123; // 用于禁止实例化 private function __construct() &#123; &#125; // 复制一个闭包，绑定指定的$this对象和类作用域。这个方法是 Closure::bindTo() 的静态版本 static function bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) : Closure // 复制当前闭包对象，绑定指定的$this对象和类作用域。 public function bindTo ( object $newthis [, mixed $newscope = 'static' ] ) : Closure // 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 public function __invoke ([ $... ] ) : mixed // Temporarily binds the closure to newthis, and calls it with any given parameters. // 一次性的，绑定$this，并可以传入参数，直接发起调用 // @since 7.0 function call ($newThis, ...$parameters) &#123;&#125; // 将给定的函数转化为匿名函数，可传入函数名 public static function fromCallable (callable $callable) &#123;&#125;&#125; fromCallable等价于： 12$reflexion = new ReflectionFunction('addDiscount');$closure = $reflexion-&gt;getClosure(); bindTo和bind函数的功能相同，一个是静态调用，一个实例调用，请看下面的示例： 创建一个匿名函数： 12345$clo = function ($name) &#123; echo $name;&#125;;var_dump($clo); 结果为：1234567object(Closure)#1 (1) &#123; ["parameter"]=&gt; array(1) &#123; ["$name"]=&gt; string(10) "&lt;required&gt;" &#125;&#125; 由此可见$clo为Closure类的实例对象。所以Closure类是不能使用通过构造函数来实例化，也没这个必要，所以构造函数被定义为私有的。 所以上面说的实例调用是指$clo-&gt;bindTo($newthis, $newscope)，静态调用是指Closure::bind($clo, $newthis, $newscope)都能够得到一个新的闭包。 那么，它的使用场景是什么？ 有时候我们在闭包内部想要访问某个类或者对象的属性和方法，但是它们是由访问修饰符控制的，也就存在作用域的问题。 并且想要使用$this来访问的话，必须是在对象的内部，鉴于这些问题，我们有必要来操作一下闭包，使其具有这些能力。 1、具有“本类内部”同等效果的作用域 2、将$this传递到闭包里面，绑定到具体的实例，可使用$this访问。 看例子：123456789101112131415161718192021222324252627class Test &#123; public static $name = "rao"; protected static $color = "red"; private static $height = "188"; public $age = 12; protected $sex = 1; private $weight = 100; function a() &#123; $fun = function ()&#123; var_dump(Test::$name); var_dump(Test::$color); var_dump(Test::$height); var_dump($this-&gt;age); var_dump($this-&gt;sex); var_dump($this-&gt;weight); &#125;; var_dump($fun); $fun(); &#125;&#125;(new Test())-&gt;a(); 打印： 1234567891011121314151617object(Closure)#2 (1) &#123; ["this"]=&gt; object(Test)#1 (3) &#123; ["age"]=&gt; int(12) ["sex":protected]=&gt; int(1) ["weight":"Test":private]=&gt; int(100) &#125;&#125;string(3) "rao"string(3) "red"string(3) "188"int(12)int(1)int(100) 由于$fun是定义在类的内部，于是它已经具备了这两个能力，这叫自动绑定。如果不想被自动绑定$this，可以使用静态闭包： 12345$fun = static function ()&#123; var_dump(Test::$name); var_dump(Test::$color); var_dump(Test::$height);&#125;; 但是”本类内部“的功能还在。 但是对于一个外来的闭包，是不具备这些能力的。 $fun2不在类里面定义。 12345678$fun2 = function ()&#123; var_dump(Test::$name); // 可以访问 var_dump(Test::$color); // 无法访问 var_dump(Test::$height); // 无法访问 var_dump($this-&gt;age); // 无法访问 var_dump($this-&gt;sex); // 无法访问 var_dump($this-&gt;weight); // 无法访问&#125;; 好，我们来使用bind()方法。 12345$fun22 = Closure::bind($fun2, new Test(), Test::class);// 或者 $fun22 = $fun2-&gt;bindTo(new Test(), Test::class);var_dump($fun22);$fun22(); 打印： 1234567891011121314151617object(Closure)#3 (1) &#123; ["this"]=&gt; object(Test)#2 (3) &#123; ["age"]=&gt; int(12) ["sex":protected]=&gt; int(1) ["weight":"Test":private]=&gt; int(100) &#125;&#125;string(3) "rao"string(3) "red"string(3) "188"int(12)int(1)int(100) 如果只想绑定$this的话，PHP7.0以后可以直接使用call，绑定并调用。 1$fun2-&gt;call(new Test()); 和上面的结果一模一样，这就是bind和bindTo的作用。当然根据需要也可以只赋予某一种能力。newthis需要绑定到匿名函数的对象，或者NULL创建未绑定的闭包。 newscope想要绑定给闭包的类作用域，或者‘static’表示不改变。如果传入一个对象，则使用这个对象的类型名。 类作用域用来决定在闭包中$this对象的 私有、保护方法的可见性。 这种操作一般用在框架里面，来扩展类或者实例的功能。 比如Laravel框架中的Illuminate\Support\Traits\Macroable宏。Laravel提供的Macroable可以在不改变类结构的情况为其扩展功能 Macroable我们以Illuminate\Support\Traits\Macroable为例分析。 通过trait可以很方便的在任何类中使用。 Laravel提供的Macroable可以在不改变类结构的情况下为其扩展功能。也就是为一个类动态注入一些方法，并且和该类本身的方法拥有同样的作用域和调用方式。 Macroable的核心是基于匿名函数的绑定功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104trait Macroable&#123; /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @return void */ public static function macro($name, $macro) &#123; static::$macros[$name] = $macro; &#125; /** * Mix another object into the class. * * @param object $mixin * @return void * * @throws \ReflectionException */ public static function mixin($mixin) &#123; $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) &#123; $method-&gt;setAccessible(true); static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125; &#125; /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) &#123; return isset(static::$macros[$name]); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; if (static::$macros[$method] instanceof Closure) &#123; return call_user_func_array(Closure::bind(static::$macros[$method], null, static::class), $parameters); &#125; return call_user_func_array(static::$macros[$method], $parameters); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; $macro = static::$macros[$method]; if ($macro instanceof Closure) &#123; return call_user_func_array($macro-&gt;bindTo($this, static::class), $parameters); &#125; return call_user_func_array($macro, $parameters); &#125;&#125; 我们可以看到执行绑定是在__callStatic和__call里面，如果一个类想要借助Macroable来提升能力，基本操作是： 1、use Macroable; 2、调用macro添加一个方法到$macros macro可以添加匿名函数和对象，之所能通过调用匿名函数的方式调用对象，前提是该对象要实现__invoke()方法，也就是说，调用这个对象的入口是__invoke()方法。 例如： 123456789101112131415class Foo&#123; use Macroable;&#125;final class Join&#123; public function __invoke(...$string) &#123; return implode('-', $string); &#125;&#125;Foo::macro('join', new Join()); 或者 123Foo::macro('join', function(...$string)&#123; return implode('-', $string);&#125;); 3、或者调用mixin将一个对象包含的全部方法都注册到当前类中。 使用了反射类获取到public和protected的方法，并且将protected方法设置为可访问，最后调用了这些方法，将返回值注入到 $macros；我们知道注册进去的都是可以被当作闭包调用的，因此我们反射的这个对象里面的方法的返回值应该是闭包，例如： 123456789101112131415161718192021final class Str&#123; public function join() &#123; // 返回匿名函数 return function(...$string)&#123; return implode('-', $string); &#125;; &#125; public function split() &#123; // 返回匿名函数 return function(string $string)&#123; return explode('-', $string); &#125;; &#125;&#125;// 执行注入mixin(new Str()) 为了更便捷的扩展一个类的功能，macro，mixin，hasMacro三个方法都被设计为静态调用，可以通过类直接调用来扩展方法。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Macroable]]></title>
    <url>%2F2020%2F04%2F12%2FLaravel-Macroable%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Macro的中文是什么意思？ static延迟静态绑定是什么意思？Traits中使用static是什么意思？ Macroable Traits维护一个string=&gt;obj/callable的数组并提供静态写入macro和查询hasMacro函数。怎么理解？ __call()函数可以直接调用吗？(new Test(‘construct_param’))-&gt;__call(‘method’, ‘parameter’);可以这样写吗？ 简介计算机科学里的宏（Macro），是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。它能使日常工作变得更容易。 今天我们讲讲Laravel中的宏操作。 源码Laravel中通过Macroable宏来扩展类的能力 使用macro 123456789101112131415161718class Father&#123; // 通过增加魔术方法__invoke我们就可以把对象当做闭包来使用了。 public function __invoke() &#123; echo __CLASS__; &#125;&#125;class Child&#123; use \Illuminate\Support\Traits\Macroable;&#125;// 增加了宏指令之后，我们就能调用Child对象中不存在的方法了Child::macro('show', new Father);// 输出:Father(new Child)-&gt;show(); 1234567891011121314class Child&#123; use \Illuminate\Support\Traits\Macroable; protected $name = 'father';&#125;// 闭包的特殊处理，需要做的就是绑定$this, 如Child::macro('show', function () &#123; echo $this-&gt;name;&#125;);// 输出:father(new Child)-&gt;show(); mixin 12345678910111213141516171819202122232425262728293031323334353637383940// 实际使用class Father&#123; public function say() &#123; return function () &#123; echo 'say'; &#125;; &#125; public function show() &#123; return function () &#123; echo 'show'; &#125;; &#125; protected function eat() &#123; return function () &#123; echo 'eat'; &#125;; &#125;&#125;class Child&#123; use \Illuminate\Support\Traits\Macroable;&#125;// 批量绑定宏指令Child::mixin(new Father);$child = new Child;// 输出:say$child-&gt;say();// 输出:show$child-&gt;show();// 输出:eat$child-&gt;eat(); 源码PHP的static延迟静态绑定功能 Illuminate\Support\Traits\Macroable.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?phpnamespace Illuminate\Support\Traits;use Closure;use ReflectionClass;use ReflectionMethod;use BadMethodCallException;trait Macroable&#123; /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @return void */ public static function macro($name, $macro) &#123; static::$macros[$name] = $macro; &#125; /** * Mix another object into the class. * * @param object $mixin * @param bool $replace * @return void * * @throws \ReflectionException */ public static function mixin($mixin, $replace = true) &#123; $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) &#123; if ($replace || ! static::hasMacro($method-&gt;name)) &#123; $method-&gt;setAccessible(true); static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125; &#125; &#125; /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) &#123; return isset(static::$macros[$name]); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; $macro = static::$macros[$method]; if ($macro instanceof Closure) &#123; return call_user_func_array(Closure::bind($macro, null, static::class), $parameters); &#125; return $macro(...$parameters); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; $macro = static::$macros[$method]; if ($macro instanceof Closure) &#123; return call_user_func_array($macro-&gt;bindTo($this, static::class), $parameters); &#125; return $macro(...$parameters); &#125;&#125; Macroable::macro方法 1234public static function macro($name, $macro)&#123; static::$macros[$name] = $macro;&#125; 很简单的代码，根据参数的注释，$macro可以传一个闭包或者对象，之所以可以传对象，多亏了PHP中的魔术方法。 Macroable::mixin方法 这个方法是把一个对象的方法的返回结果注入到原对象中。12345678910111213public static function mixin($mixin, $replace = true)&#123; $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) &#123; if ($replace || ! static::hasMacro($method-&gt;name)) &#123; $method-&gt;setAccessible(true); static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125; &#125;&#125; 在上面的代码可以看出mixin可以将一个类的方法绑定到宏类中。需要注意的就是，方法必须是返回一个闭包类型。 Macroable::hasMacro方法 1234public static function hasMacro($name)&#123; return isset(static::$macros[$name]);&#125; 这个方法就比较简单没什么复杂可言，就判断是否存在宏指令。通常是使用宏指令之前判断一下。 Macroable::__call和Macroable::__callStatic方法 正是由于这两个方法，我们才能进行宏操作，两个方法除了执行方式不同，代码大同小异。这里讲一下__call。123456789101112131415161718public function __call($method, $parameters)&#123; // 如果不存在这个宏指令，直接抛出异常 if (! static::hasMacro($method)) &#123; throw new BadMethodCallException("Method &#123;$method&#125; does not exist."); &#125; // 得到存储的宏指令 $macro = static::$macros[$method]; // 闭包做一点点特殊的处理 if ($macro instanceof Closure) &#123; return call_user_func_array($macro-&gt;bindTo($this, static::class), $parameters); &#125; // 不是闭包，比如对象的时候，直接通过这种方法运行，但是要确保对象有`__invoke`方法 return call_user_func_array($macro, $parameters);&#125; 在上面的操作中我们绑定宏时，在闭包中可以通过$this来调用Child的属性，是因为在__call方法中我们使用Closure::bindTo方法。 官网对Closure::bindTo的解释：复制当前闭包对象，绑定指定的$this对象和类作用域。 Laravel中对类增加宏指令Laravel中很多类都使用了宏这个trait。 比如Illuminate\Filesystem\Filesystem::class，我们想为这个类增加一个方法，但不会动到里面的代码。 Illuminate\Filesystem\Filesystem.php 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Illuminate\Filesystem;use ErrorException;use FilesystemIterator;use Illuminate\Contracts\Filesystem\FileNotFoundException;use Illuminate\Support\Traits\Macroable;use Symfony\Component\Finder\Finder;class Filesystem&#123; use Macroable; /** * Determine if a file or directory exists. * * @param string $path * @return bool */ public function exists($path) &#123; return file_exists($path); &#125; /** * Determine if a file or directory is missing. * * @param string $path * @return bool */ public function missing($path) &#123; return ! $this-&gt;exists($path); &#125;&#125; 我们只需要到App\Providers\AppServiceProvider::register方法增加宏指令（你也可以专门新建一个服务提供者专门处理）。 App\Providers\AppServiceProvider.php 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Providers;use Illuminate\Support\Facades\Schema;use Illuminate\Support\ServiceProvider;use Illuminate\Filesystem\Filesystem;class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Filesystem::macro('readFile', function ($fileName, $useIncludePath = null, $context = null)&#123; readfile($fileName, $useIncludePath, $context); &#125;); &#125;&#125; 然后增加一条测试路由，测试我们新增加的方法。 12345&lt;?phpRoute::get('/', function (\Illuminate\Filesystem\Filesystem $filesystem)&#123; $filesystem-&gt;readFile(__DIR__.'/../.env.example');&#125;); 然后打开浏览器运行，你就会发现，我们的代码可以正常的运行了并输出结果了。 MacroableLaravel提供的Macroable可以在不改变类结构的情况为其扩展功能，本文将教你从零开始构建一个Macroable。 Macroable的核心是基于匿名函数的绑定功能，先来回顾下匿名函数的绑定功能。 预备知识PHP可通过匿名函数的绑定功能来扩展类或者实例的功能。 定义类： 123class Foo&#123;&#125; 定义匿名函数： 123$join = function(...$string)&#123; return implode('-', $string);&#125; 使用bindTo为类的实例添加join功能：123$foo = new Foo();$bindFoo = $join-&gt;bindTo($foo, Foo::class);$bindFoo('a', 'b', 'c'); // "a-b-c" PHP7之后引入了call方法更高效的实现了该功能：12$foo = new Foo();$join-&gt;call($foo, 'a', 'b', 'c'); // "a-b-c" 对于本例而言，使用bind方法进行静态绑定更贴合实际场景：12$bindClass = \Closure::bind($join, null, Foo::class);$bindClass('a', 'b', 'c'); // "a-b-c" 如果还没看懂的话，可以参考我之前写的PHP核心特性-匿名函数。 通过匿名函数扩展类的功能了解了匿名函数的绑定功能后，就可以对其进行简单的封装了。首先，定义一个数组用来保存要添加的功能列表123456789101112&lt;?phptrait Macroable &#123; // 保存要扩展的功能 protected static $macros = []; // 添加要扩展功能 public static function macro($name, $macro) &#123; static::$macros[$name] = $macro; &#125;&#125; macros属性保存了要添加的功能名及实现，在类中使用该Trait：1234class Foo &#123; use Macroable;&#125; 添加join功能：123Foo::macro('join', function(...$string)&#123; return implode('-', $string);&#125;); join功能及对应的实现已经保存到了macros数组中。接下来是调用join方法：1Foo::join('a', 'b', 'c') 由于Foo中的join静态方法不存在，会自动将方法名和参数转发到__callStatic魔术方法中。因此，在魔术方法中手动调用绑定的匿名函数即可：1234567891011public static function __callStatic($name, $parameters)&#123; // 获取匿名函数 $macro = static::$macros[$name]; // 绑定到类 $bindClass = \Closure::bind($macro, null, static::class); // 调用并返回调用结果 return $bindClass(...$parameters);&#125; 测试：1echo Foo::join('a', 'b', 'c'); // a-b-c 动态扩展与静态扩展的实现原理完全一样：12345678public function __call($name, $parameters) &#123; // 获取匿名函数 $macro = static::$macros[$name]; // 调用并返回调用结果 return $macro-&gt;call($this, ...$parameters);&#125; 测试：12$foo = new Foo();echo $foo-&gt;join('a', 'b', 'c'); // 'a-b-c' 通过对象实例来扩展类的功能之前，我们通过匿名函数的方式扩展类的功能：123Foo::macro('join', function(...$string)&#123; return implode('-', $string);&#125;); 现在，我们考虑如何通过对象的方式来实现同样的功能。首先，将匿名函数改造成类：1234567final class Join&#123; public function __invoke(...$string) &#123; return implode('-', $string); &#125;&#125; 当以函数的方式调用该类时，就会激活__invoke方法：12$join = new Join();$join('a', 'b', 'c'); // a-b-c 现在，将Join的实例添加到类中，实现同样的效果1Foo::macro('join', new Join()); 只需要对原有的__callStatic 方法增加一层判断即可。如果是匿名函数则绑定该匿名函数并调用，如果是对象则以函数的方式调用对象，激活对象的__invoke 方法。123456789101112131415161718192021222324public function __call($name, $parameters) &#123; $macro = static::$macros[$name]; if($macro instanceof Closure)&#123; return $macro-&gt;call($this, ...$parameters); &#125; return $macro(...$parameters);&#125;public static function __callStatic($name, $parameters)&#123; $macro = static::$macros[$name]; // 闭包 if($macro instanceof Closure)&#123; $bindClass = \Closure::bind($macro, null, static::class); return $bindClass(...$parameters); &#125; // 对象实例，则激活该对象 return $macro(...$parameters);&#125; 测试1Foo::join('a', 'b', 'c'); // a-b-c 同时扩展多个方法最后，Laravel的Macroable还实现了同时扩展多个方法。 原理其实很简单，将功能类似的方法定义在一个类中123456789101112131415161718final class Str&#123; public function join() &#123; // 返回匿名函数 return function(...$string)&#123; return implode('-', $string); &#125;; &#125; public function split() &#123; // 返回匿名函数 return function(string $string)&#123; return explode('-', $string); &#125;; &#125;&#125; 每个方法都返回了匿名函数，我们只需要将每个匿名函数添加到$macros列表中即可，只需要用到PHP的反射功能即可实现。1234567891011121314public static function mixin($mixin) &#123; // 通过反射获取对象的 ReflectionMethod 列表 $methods = (new \ReflectionClass($mixin))-&gt;getMethods( \ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED ); // 遍历 ReflectionMethod 列表，依次保存到 $macros 中 foreach ($methods as $method) &#123; $method-&gt;setAccessible(true); // 依次激活该对象的每个方法，每个方法返回的匿名函数刚好保存在 $macros 中 static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125;&#125; 测试123Foo::mixin(new Str());Foo::join('a', 'b', 'c');Foo::split('a-b-c'); 当然，这个功能没多大作用，还不如直接用Trait来的直观方便。 利用Laravel Macroable特性优化多态参数传递的技巧分享准备如果我们现在需要设计这样一个接口：获取指定文章的所有评论Or获取指定视频的所有评论。 我们有三张表：视频表：videos文章表：posts评论表：comments评论表中有这两个字段：commentable_type、commentable_id 分别存储评论主体信息。他们之间的模型关系为多态关联，就不再多解释了，哈哈。 当接收到这个需求的时候，你可能会困惑，主体不确定该怎么去设计呢。通过 commentable_type 判断是什么模型，然后再根据确定的类型和 commentable_id 获取到具体的对象吗？此时你脑中的代码是什么样子的呢，反正当时我的脑子里面是一堆乱糟糟的代码，哈哈。现在就来给大家介绍这种优雅的实现方式。 获取可评论对象 首先我们利用macro给Request定义一个commentable：1234567891011121314151617Request::macro(('commentable'), function(bool $required = false)&#123; if (!request()-&gt;has('commentable_type')) &#123; return $required ? abort(422, '目标对象不存在') : null; &#125; $model = request()-&gt;get('commentable_type'); $model = Relation::getMorphedModel($model) ?? $mode; $commentable = call_user_func([$model, 'find'], request()-&gt;get('commentable_id')); if (!$commentable)&#123; return $required ? abort(422, '目标对象不存在') : null; &#125; return $commentable;&#125;); 可以看到，目标对象的转换就是通过commentable_type，commentable_id这两个参数来的，这段代码不是很难，大家研究一下就看懂哒。可以在服务提供者中定义。 控制器123456789101112131415class CommentController extends Controller&#123; /** * Display a listing of the resource. * * @param \Illuminate\Http\Request $request * * @return \Illuminate\Http\Resources\Json\AnonymousResourceCollection */ public function index(Request $request) &#123; return CommentResource::collection($request-&gt;commentable(true)-&gt;comments()-&gt;get()); &#125;&#125; 大家会发现现在已经可以通过 $request-&gt;commentable(true)来获取可评论对象了，但是少了验证，但是这个验证该怎么写呢，现在我们来看一下。 验证规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Polymorphic extends Rule&#123; /** * @var string */ protected $name; /** * @var string */ protected $message; /** * Create a new rule instance. * * @param string $name * @param string|null $message */ public function __construct(string name, string $message = null) &#123; $this-&gt;name = $name; $this-&gt;message = $message; &#125; /** * Determine if the validation rule passes. * * @param string $attribute * @param mixed $value * * @return bool */ public function passes($attribute, $value) &#123; $model = request()-&gt;get(\sprintf('%s_type'), $this-&gt;name); $model = Relation::getMorphedModel($model) ?? $mode; return \class_exists($model) &amp;&amp; (bool) \call_user_func([$model, 'find'], \request()-&gt;get(\sprintf('%s_id'), $this-&gt;name))); &#125; /** * Get the validation error message. * * @return string */ public function message() &#123; return $this-&gt;message ?: '未指定目标对象或目标不存在'; &#125;&#125; 现在规则定义好了，我们来使用：1234567891011121314151617/** * Display a listing of the resource. * * @param \Illuminate\Http\Request $request * * @return \Illuminate\Http\Resources\Json\AnonymousResourceCollection * * @throws \Illuminate\Validation\ValidationException */public function index(Request $request)&#123; $this-&gt;validate($request, [ 'commentable_id' =&gt; ['required', new Polymorphic('commentable', '未指定评论对象或对象不存在')], ]); return CommentResource::collection($request-&gt;commentable(true)-&gt;comments()-&gt;get());&#125; 宏（Macros）宏是一种挂接到框架并扩展某些附加功能而无需显式继承该类的方法。许多Illuminate组件都使用了Macroable特性，该特性允许您为类扩展更多功能。如果我们深入研究代码并了解其特征，则可以看到静态属性$macros。该静态属性的作用是全局访问。如果将宏分配给Collection类，则所有Collection实例将能够访问同一宏。 使用方法注册宏 通过调用静态方法macro($name，$macro)将宏绑定到类中。该方法从字面上通过键$name将$macro（关闭执行功能）绑定到$macros数组中。用它可以扩展更多用法，例如，像文档中所述的Collection类。请注意，这通常是在服务提供者中完成的。 macro详解 我们还可以看到__call和__callStatic魔术方法。只要在类上调用了不可访问的方法，PHP就会自动调用这两个魔术方法。 我们想重写它以查看宏是否存在（static :: hasMacro（$ macro），如果存在，则从数组中解析 macro 并调用它。 macro 通常是个可以被任何类调用的闭包。 请注意，如果愿意，可以通过调用 mixin 方法在另一个对象中建立宏。 您可能没有注意到，在 Closure 中宏调用 $this 将访问该类本身的当前实例。 这怎么可能？ 我如何使用$this访问Closure 中的对象的属性和方法？ 好吧，PHP 的闭包中有一种称为 bindTo 的方法，而 Laravel 则利用了这种方法。 它将当前宏对象绑定到 Closure ，因此 $this 引用类本身，而不是 Closure。 冲突 如果使用 Macroable 特性的类具有 __call 方法，则将发生冲突。 两种方法都不能被调用，因此当我们使用 Macroable 时，我们应该将 Macroable 的 __call 方法重命名为其他名称，但是请确保在对象的__call 方法中调用你重命名的方法。 可以在 Cache\Repository 类中看到示例。 我们导入 trait，同时将 __call 重命名为 macrocrock。 然后在 Repository 的__call 中，如果类具有宏，请确保调用 macroCall 方法 ，否则默认调用 b 本地方法，这样既可解决冲突。 注意:不要过度使用它。如果您有很多宏，或者有一些非常复杂的逻辑，那么继承类并执行相应的逻辑要比用宏扩展服务提供者要好得多。 我比较喜欢使用一个宏来检查 Request 类，以确定是否选中了表单中的复选框：123Request::macro('checked', function ($attribute) &#123; return in_array($this-&gt;input($attribute, false), [true, 1, '1', 'on']);&#125;);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Cache]]></title>
    <url>%2F2020%2F04%2F12%2FLaravel-Cache%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： use Macroable {__call as macroCall;}为什么这样写？ CacheManager维护了一个[string=&gt;Repository对象]的数组，并管理了各种Cache种类，是一个工厂。怎么理解？ 源码文件结构 Cache门面 Illuminate\Support\Facades\Cache.php 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Illuminate\Support\Facades;/** * @method static \Illuminate\Contracts\Cache\Repository store(string|null $name = null) * @method static bool has(string $key) * @method static bool missing(string $key) * @method static mixed get(string $key, mixed $default = null) * @method static mixed pull(string $key, mixed $default = null) * @method static bool put(string $key, $value, \DateTimeInterface|\DateInterval|int $ttl = null) * @method static bool add(string $key, $value, \DateTimeInterface|\DateInterval|int $ttl = null) * @method static int|bool increment(string $key, $value = 1) * @method static int|bool decrement(string $key, $value = 1) * @method static bool forever(string $key, $value) * @method static mixed remember(string $key, \DateTimeInterface|\DateInterval|int $ttl, \Closure $callback) * @method static mixed sear(string $key, \Closure $callback) * @method static mixed rememberForever(string $key, \Closure $callback) * @method static bool forget(string $key) * @method static \Illuminate\Contracts\Cache\Store getStore() * * @see \Illuminate\Cache\CacheManager * @see \Illuminate\Cache\Repository */class Cache extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'cache'; &#125;&#125; CacheServiceProvider Illuminate\Cache\CacheServiceProvider.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\ServiceProvider;use Symfony\Component\Cache\Adapter\Psr16Adapter;class CacheServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('cache', function ($app) &#123; return new CacheManager($app); &#125;); $this-&gt;app-&gt;singleton('cache.store', function ($app) &#123; return $app['cache']-&gt;driver(); &#125;); $this-&gt;app-&gt;singleton('cache.psr6', function ($app) &#123; return new Psr16Adapter($app['cache.store']); &#125;); $this-&gt;app-&gt;singleton('memcached.connector', function () &#123; return new MemcachedConnector; &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [ 'cache', 'cache.store', 'cache.psr6', 'memcached.connector', ]; &#125;&#125; 工厂 Illuminate\Contracts\Cache\Factory.php 1234567891011121314&lt;?phpnamespace Illuminate\Contracts\Cache;interface Factory&#123; /** * Get a cache store instance by name. * * @param string|null $name * @return \Illuminate\Contracts\Cache\Repository */ public function store($name = null);&#125; Illuminate\Cache\Repository.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656namespace Illuminate\Cache;use ArrayAccess;use BadMethodCallException;use Closure;use DateTimeInterface;use Illuminate\Cache\Events\CacheHit;use Illuminate\Cache\Events\CacheMissed;use Illuminate\Cache\Events\KeyForgotten;use Illuminate\Cache\Events\KeyWritten;use Illuminate\Contracts\Cache\Repository as CacheContract;use Illuminate\Contracts\Cache\Store;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Support\Carbon;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Traits\Macroable;/** * @mixin \Illuminate\Contracts\Cache\Store */class Repository implements ArrayAccess, CacheContract&#123; use InteractsWithTime; use Macroable &#123; __call as macroCall; &#125; /** * The cache store implementation. * * @var \Illuminate\Contracts\Cache\Store */ protected $store; /** * The event dispatcher implementation. * * @var \Illuminate\Contracts\Events\Dispatcher */ protected $events; /** * The default number of seconds to store items. * * @var int|null */ protected $default = 3600; /** * Create a new cache repository instance. * * @param \Illuminate\Contracts\Cache\Store $store * @return void */ public function __construct(Store $store) &#123; $this-&gt;store = $store; &#125; /** * Determine if an item exists in the cache. * * @param string $key * @return bool */ public function has($key) &#123; return ! is_null($this-&gt;get($key)); &#125; /** * Determine if an item doesn't exist in the cache. * * @param string $key * @return bool */ public function missing($key) &#123; return ! $this-&gt;has($key); &#125; /** * Retrieve an item from the cache by key. * * @param string $key * @param mixed $default * @return mixed */ public function get($key, $default = null) &#123; if (is_array($key)) &#123; return $this-&gt;many($key); &#125; $value = $this-&gt;store-&gt;get($this-&gt;itemKey($key)); // If we could not find the cache value, we will fire the missed event and get // the default value for this cache value. This default could be a callback // so we will execute the value function which will resolve it if needed. if (is_null($value)) &#123; $this-&gt;event(new CacheMissed($key)); $value = value($default); &#125; else &#123; $this-&gt;event(new CacheHit($key, $value)); &#125; return $value; &#125; /** * Retrieve multiple items from the cache by key. * * Items not found in the cache will have a null value. * * @param array $keys * @return array */ public function many(array $keys) &#123; $values = $this-&gt;store-&gt;many(collect($keys)-&gt;map(function ($value, $key) &#123; return is_string($key) ? $key : $value; &#125;)-&gt;values()-&gt;all()); return collect($values)-&gt;map(function ($value, $key) use ($keys) &#123; return $this-&gt;handleManyResult($keys, $key, $value); &#125;)-&gt;all(); &#125; /** * &#123;@inheritdoc&#125; */ public function getMultiple($keys, $default = null) &#123; $defaults = []; foreach ($keys as $key) &#123; $defaults[$key] = $default; &#125; return $this-&gt;many($defaults); &#125; /** * Handle a result for the "many" method. * * @param array $keys * @param string $key * @param mixed $value * @return mixed */ protected function handleManyResult($keys, $key, $value) &#123; // If we could not find the cache value, we will fire the missed event and get // the default value for this cache value. This default could be a callback // so we will execute the value function which will resolve it if needed. if (is_null($value)) &#123; $this-&gt;event(new CacheMissed($key)); return isset($keys[$key]) ? value($keys[$key]) : null; &#125; // If we found a valid value we will fire the "hit" event and return the value // back from this function. The "hit" event gives developers an opportunity // to listen for every possible cache "hit" throughout this applications. $this-&gt;event(new CacheHit($key, $value)); return $value; &#125; /** * Retrieve an item from the cache and delete it. * * @param string $key * @param mixed $default * @return mixed */ public function pull($key, $default = null) &#123; return tap($this-&gt;get($key, $default), function () use ($key) &#123; $this-&gt;forget($key); &#125;); &#125; /** * Store an item in the cache. * * @param string $key * @param mixed $value * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function put($key, $value, $ttl = null) &#123; if (is_array($key)) &#123; return $this-&gt;putMany($key, $value); &#125; if ($ttl === null) &#123; return $this-&gt;forever($key, $value); &#125; $seconds = $this-&gt;getSeconds($ttl); if ($seconds &lt;= 0) &#123; return $this-&gt;forget($key); &#125; $result = $this-&gt;store-&gt;put($this-&gt;itemKey($key), $value, $seconds); if ($result) &#123; $this-&gt;event(new KeyWritten($key, $value, $seconds)); &#125; return $result; &#125; /** * &#123;@inheritdoc&#125; */ public function set($key, $value, $ttl = null) &#123; return $this-&gt;put($key, $value, $ttl); &#125; /** * Store multiple items in the cache for a given number of seconds. * * @param array $values * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function putMany(array $values, $ttl = null) &#123; if ($ttl === null) &#123; return $this-&gt;putManyForever($values); &#125; $seconds = $this-&gt;getSeconds($ttl); if ($seconds &lt;= 0) &#123; return $this-&gt;deleteMultiple(array_keys($values)); &#125; $result = $this-&gt;store-&gt;putMany($values, $seconds); if ($result) &#123; foreach ($values as $key =&gt; $value) &#123; $this-&gt;event(new KeyWritten($key, $value, $seconds)); &#125; &#125; return $result; &#125; /** * Store multiple items in the cache indefinitely. * * @param array $values * @return bool */ protected function putManyForever(array $values) &#123; $result = true; foreach ($values as $key =&gt; $value) &#123; if (! $this-&gt;forever($key, $value)) &#123; $result = false; &#125; &#125; return $result; &#125; /** * &#123;@inheritdoc&#125; */ public function setMultiple($values, $ttl = null) &#123; return $this-&gt;putMany(is_array($values) ? $values : iterator_to_array($values), $ttl); &#125; /** * Store an item in the cache if the key does not exist. * * @param string $key * @param mixed $value * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function add($key, $value, $ttl = null) &#123; if ($ttl !== null) &#123; if ($this-&gt;getSeconds($ttl) &lt;= 0) &#123; return false; &#125; // If the store has an "add" method we will call the method on the store so it // has a chance to override this logic. Some drivers better support the way // this operation should work with a total "atomic" implementation of it. if (method_exists($this-&gt;store, 'add')) &#123; $seconds = $this-&gt;getSeconds($ttl); return $this-&gt;store-&gt;add( $this-&gt;itemKey($key), $value, $seconds ); &#125; &#125; // If the value did not exist in the cache, we will put the value in the cache // so it exists for subsequent requests. Then, we will return true so it is // easy to know if the value gets added. Otherwise, we will return false. if (is_null($this-&gt;get($key))) &#123; return $this-&gt;put($key, $value, $ttl); &#125; return false; &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function increment($key, $value = 1) &#123; return $this-&gt;store-&gt;increment($key, $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function decrement($key, $value = 1) &#123; return $this-&gt;store-&gt;decrement($key, $value); &#125; /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return bool */ public function forever($key, $value) &#123; $result = $this-&gt;store-&gt;forever($this-&gt;itemKey($key), $value); if ($result) &#123; $this-&gt;event(new KeyWritten($key, $value)); &#125; return $result; &#125; /** * Get an item from the cache, or execute the given Closure and store the result. * * @param string $key * @param \DateTimeInterface|\DateInterval|int|null $ttl * @param \Closure $callback * @return mixed */ public function remember($key, $ttl, Closure $callback) &#123; $value = $this-&gt;get($key); // If the item exists in the cache we will just return this immediately and if // not we will execute the given Closure and cache the result of that for a // given number of seconds so it's available for all subsequent requests. if (! is_null($value)) &#123; return $value; &#125; $this-&gt;put($key, $value = $callback(), $ttl); return $value; &#125; /** * Get an item from the cache, or execute the given Closure and store the result forever. * * @param string $key * @param \Closure $callback * @return mixed */ public function sear($key, Closure $callback) &#123; return $this-&gt;rememberForever($key, $callback); &#125; /** * Get an item from the cache, or execute the given Closure and store the result forever. * * @param string $key * @param \Closure $callback * @return mixed */ public function rememberForever($key, Closure $callback) &#123; $value = $this-&gt;get($key); // If the item exists in the cache we will just return this immediately // and if not we will execute the given Closure and cache the result // of that forever so it is available for all subsequent requests. if (! is_null($value)) &#123; return $value; &#125; $this-&gt;forever($key, $value = $callback()); return $value; &#125; /** * Remove an item from the cache. * * @param string $key * @return bool */ public function forget($key) &#123; return tap($this-&gt;store-&gt;forget($this-&gt;itemKey($key)), function ($result) use ($key) &#123; if ($result) &#123; $this-&gt;event(new KeyForgotten($key)); &#125; &#125;); &#125; /** * &#123;@inheritdoc&#125; */ public function delete($key) &#123; return $this-&gt;forget($key); &#125; /** * &#123;@inheritdoc&#125; */ public function deleteMultiple($keys) &#123; $result = true; foreach ($keys as $key) &#123; if (! $this-&gt;forget($key)) &#123; $result = false; &#125; &#125; return $result; &#125; /** * &#123;@inheritdoc&#125; */ public function clear() &#123; return $this-&gt;store-&gt;flush(); &#125; /** * Begin executing a new tags operation if the store supports it. * * @param array|mixed $names * @return \Illuminate\Cache\TaggedCache * * @throws \BadMethodCallException */ public function tags($names) &#123; if (! method_exists($this-&gt;store, 'tags')) &#123; throw new BadMethodCallException('This cache store does not support tagging.'); &#125; $cache = $this-&gt;store-&gt;tags(is_array($names) ? $names : func_get_args()); if (! is_null($this-&gt;events)) &#123; $cache-&gt;setEventDispatcher($this-&gt;events); &#125; return $cache-&gt;setDefaultCacheTime($this-&gt;default); &#125; /** * Format the key for a cache item. * * @param string $key * @return string */ protected function itemKey($key) &#123; return $key; &#125; /** * Get the default cache time. * * @return int|null */ public function getDefaultCacheTime() &#123; return $this-&gt;default; &#125; /** * Set the default cache time in seconds. * * @param int|null $seconds * @return $this */ public function setDefaultCacheTime($seconds) &#123; $this-&gt;default = $seconds; return $this; &#125; /** * Get the cache store implementation. * * @return \Illuminate\Contracts\Cache\Store */ public function getStore() &#123; return $this-&gt;store; &#125; /** * Fire an event for this cache instance. * * @param string $event * @return void */ protected function event($event) &#123; if (isset($this-&gt;events)) &#123; $this-&gt;events-&gt;dispatch($event); &#125; &#125; /** * Get the event dispatcher instance. * * @return \Illuminate\Contracts\Events\Dispatcher */ public function getEventDispatcher() &#123; return $this-&gt;events; &#125; /** * Set the event dispatcher instance. * * @param \Illuminate\Contracts\Events\Dispatcher $events * @return void */ public function setEventDispatcher(Dispatcher $events) &#123; $this-&gt;events = $events; &#125; /** * Determine if a cached value exists. * * @param string $key * @return bool */ public function offsetExists($key) &#123; return $this-&gt;has($key); &#125; /** * Retrieve an item from the cache by key. * * @param string $key * @return mixed */ public function offsetGet($key) &#123; return $this-&gt;get($key); &#125; /** * Store an item in the cache for the default time. * * @param string $key * @param mixed $value * @return void */ public function offsetSet($key, $value) &#123; $this-&gt;put($key, $value, $this-&gt;default); &#125; /** * Remove an item from the cache. * * @param string $key * @return void */ public function offsetUnset($key) &#123; $this-&gt;forget($key); &#125; /** * Calculate the number of seconds for the given TTL. * * @param \DateTimeInterface|\DateInterval|int $ttl * @return int */ protected function getSeconds($ttl) &#123; $duration = $this-&gt;parseDateInterval($ttl); if ($duration instanceof DateTimeInterface) &#123; $duration = Carbon::now()-&gt;diffInRealSeconds($duration, false); &#125; return (int) $duration &gt; 0 ? $duration : 0; &#125; /** * Handle dynamic calls into macros or pass missing methods to the store. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (static::hasMacro($method)) &#123; return $this-&gt;macroCall($method, $parameters); &#125; return $this-&gt;store-&gt;$method(...$parameters); &#125; /** * Clone cache repository instance. * * @return void */ public function __clone() &#123; $this-&gt;store = clone $this-&gt;store; &#125;&#125; RedisStore Illuminate\Cache\RedisStore.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306namespace Illuminate\Cache;use Illuminate\Contracts\Cache\LockProvider;use Illuminate\Contracts\Redis\Factory as Redis;class RedisStore extends TaggableStore implements LockProvider&#123; /** * The Redis factory implementation. * * @var \Illuminate\Contracts\Redis\Factory */ protected $redis; /** * A string that should be prepended to keys. * * @var string */ protected $prefix; /** * The Redis connection that should be used. * * @var string */ protected $connection; /** * Create a new Redis store. * * @param \Illuminate\Contracts\Redis\Factory $redis * @param string $prefix * @param string $connection * @return void */ public function __construct(Redis $redis, $prefix = '', $connection = 'default') &#123; $this-&gt;redis = $redis; $this-&gt;setPrefix($prefix); $this-&gt;setConnection($connection); &#125; /** * Retrieve an item from the cache by key. * * @param string|array $key * @return mixed */ public function get($key) &#123; $value = $this-&gt;connection()-&gt;get($this-&gt;prefix.$key); return ! is_null($value) ? $this-&gt;unserialize($value) : null; &#125; /** * Retrieve multiple items from the cache by key. * * Items not found in the cache will have a null value. * * @param array $keys * @return array */ public function many(array $keys) &#123; $results = []; $values = $this-&gt;connection()-&gt;mget(array_map(function ($key) &#123; return $this-&gt;prefix.$key; &#125;, $keys)); foreach ($values as $index =&gt; $value) &#123; $results[$keys[$index]] = ! is_null($value) ? $this-&gt;unserialize($value) : null; &#125; return $results; &#125; /** * Store an item in the cache for a given number of seconds. * * @param string $key * @param mixed $value * @param int $seconds * @return bool */ public function put($key, $value, $seconds) &#123; return (bool) $this-&gt;connection()-&gt;setex( $this-&gt;prefix.$key, (int) max(1, $seconds), $this-&gt;serialize($value) ); &#125; /** * Store multiple items in the cache for a given number of seconds. * * @param array $values * @param int $seconds * @return bool */ public function putMany(array $values, $seconds) &#123; $this-&gt;connection()-&gt;multi(); $manyResult = null; foreach ($values as $key =&gt; $value) &#123; $result = $this-&gt;put($key, $value, $seconds); $manyResult = is_null($manyResult) ? $result : $result &amp;&amp; $manyResult; &#125; $this-&gt;connection()-&gt;exec(); return $manyResult ?: false; &#125; /** * Store an item in the cache if the key doesn't exist. * * @param string $key * @param mixed $value * @param int $seconds * @return bool */ public function add($key, $value, $seconds) &#123; $lua = "return redis.call('exists',KEYS[1])&lt;1 and redis.call('setex',KEYS[1],ARGV[2],ARGV[1])"; return (bool) $this-&gt;connection()-&gt;eval( $lua, 1, $this-&gt;prefix.$key, $this-&gt;serialize($value), (int) max(1, $seconds) ); &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return int */ public function increment($key, $value = 1) &#123; return $this-&gt;connection()-&gt;incrby($this-&gt;prefix.$key, $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return int */ public function decrement($key, $value = 1) &#123; return $this-&gt;connection()-&gt;decrby($this-&gt;prefix.$key, $value); &#125; /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return bool */ public function forever($key, $value) &#123; return (bool) $this-&gt;connection()-&gt;set($this-&gt;prefix.$key, $this-&gt;serialize($value)); &#125; /** * Get a lock instance. * * @param string $name * @param int $seconds * @param string|null $owner * @return \Illuminate\Contracts\Cache\Lock */ public function lock($name, $seconds = 0, $owner = null) &#123; return new RedisLock($this-&gt;connection(), $this-&gt;prefix.$name, $seconds, $owner); &#125; /** * Restore a lock instance using the owner identifier. * * @param string $name * @param string $owner * @return \Illuminate\Contracts\Cache\Lock */ public function restoreLock($name, $owner) &#123; return $this-&gt;lock($name, 0, $owner); &#125; /** * Remove an item from the cache. * * @param string $key * @return bool */ public function forget($key) &#123; return (bool) $this-&gt;connection()-&gt;del($this-&gt;prefix.$key); &#125; /** * Remove all items from the cache. * * @return bool */ public function flush() &#123; $this-&gt;connection()-&gt;flushdb(); return true; &#125; /** * Begin executing a new tags operation. * * @param array|mixed $names * @return \Illuminate\Cache\RedisTaggedCache */ public function tags($names) &#123; return new RedisTaggedCache( $this, new TagSet($this, is_array($names) ? $names : func_get_args()) ); &#125; /** * Get the Redis connection instance. * * @return \Illuminate\Redis\Connections\Connection */ public function connection() &#123; return $this-&gt;redis-&gt;connection($this-&gt;connection); &#125; /** * Set the connection name to be used. * * @param string $connection * @return void */ public function setConnection($connection) &#123; $this-&gt;connection = $connection; &#125; /** * Get the Redis database instance. * * @return \Illuminate\Contracts\Redis\Factory */ public function getRedis() &#123; return $this-&gt;redis; &#125; /** * Get the cache key prefix. * * @return string */ public function getPrefix() &#123; return $this-&gt;prefix; &#125; /** * Set the cache key prefix. * * @param string $prefix * @return void */ public function setPrefix($prefix) &#123; $this-&gt;prefix = ! empty($prefix) ? $prefix.':' : ''; &#125; /** * Serialize the value. * * @param mixed $value * @return mixed */ protected function serialize($value) &#123; return is_numeric($value) &amp;&amp; ! in_array($value, [INF, -INF]) &amp;&amp; ! is_nan($value) ? $value : serialize($value); &#125; /** * Unserialize the value. * * @param mixed $value * @return mixed */ protected function unserialize($value) &#123; return is_numeric($value) ? $value : unserialize($value); &#125;&#125; RedisLock Illuminate\Cache\Lock.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Lock as LockContract;use Illuminate\Contracts\Cache\LockTimeoutException;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Str;abstract class Lock implements LockContract&#123; use InteractsWithTime; /** * The name of the lock. * * @var string */ protected $name; /** * The number of seconds the lock should be maintained. * * @var int */ protected $seconds; /** * The scope identifier of this lock. * * @var string */ protected $owner; /** * Create a new lock instance. * * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($name, $seconds, $owner = null) &#123; if (is_null($owner)) &#123; $owner = Str::random(); &#125; $this-&gt;name = $name; $this-&gt;owner = $owner; $this-&gt;seconds = $seconds; &#125; /** * Attempt to acquire the lock. * * @return bool */ abstract public function acquire(); /** * Release the lock. * * @return bool */ abstract public function release(); /** * Returns the owner value written into the driver for this lock. * * @return string */ abstract protected function getCurrentOwner(); /** * Attempt to acquire the lock. * * @param callable|null $callback * @return mixed */ public function get($callback = null) &#123; $result = $this-&gt;acquire(); if ($result &amp;&amp; is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return $result; &#125; /** * Attempt to acquire the lock for the given number of seconds. * * @param int $seconds * @param callable|null $callback * @return bool * * @throws \Illuminate\Contracts\Cache\LockTimeoutException */ public function block($seconds, $callback = null) &#123; $starting = $this-&gt;currentTime(); while (! $this-&gt;acquire()) &#123; usleep(250 * 1000); if ($this-&gt;currentTime() - $seconds &gt;= $starting) &#123; throw new LockTimeoutException; &#125; &#125; if (is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return true; &#125; /** * Returns the current owner of the lock. * * @return string */ public function owner() &#123; return $this-&gt;owner; &#125; /** * Determines whether this lock is allowed to release the lock in the driver. * * @return bool */ protected function isOwnedByCurrentProcess() &#123; return $this-&gt;getCurrentOwner() === $this-&gt;owner; &#125;&#125; Illuminate\Cache\RedisLock 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpnamespace Illuminate\Cache;class RedisLock extends Lock&#123; /** * The Redis factory implementation. * * @var \Illuminate\Redis\Connections\Connection */ protected $redis; /** * Create a new lock instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($redis, $name, $seconds, $owner = null) &#123; parent::__construct($name, $seconds, $owner); $this-&gt;redis = $redis; &#125; /** * Attempt to acquire the lock. * * @return bool */ public function acquire() &#123; if ($this-&gt;seconds &gt; 0) &#123; return $this-&gt;redis-&gt;set($this-&gt;name, $this-&gt;owner, 'EX', $this-&gt;seconds, 'NX') == true; &#125; else &#123; return $this-&gt;redis-&gt;setnx($this-&gt;name, $this-&gt;owner) === 1; &#125; &#125; /** * Release the lock. * * @return bool */ public function release() &#123; return (bool) $this-&gt;redis-&gt;eval(LuaScripts::releaseLock(), 1, $this-&gt;name, $this-&gt;owner); &#125; /** * Releases this lock in disregard of ownership. * * @return void */ public function forceRelease() &#123; $this-&gt;redis-&gt;del($this-&gt;name); &#125; /** * Returns the owner value written into the driver for this lock. * * @return string */ protected function getCurrentOwner() &#123; return $this-&gt;redis-&gt;get($this-&gt;name); &#125;&#125; CacheManager Illuminate\CacheManager.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313namespace Illuminate\Cache;use Closure;use Illuminate\Contracts\Cache\Factory as FactoryContract;use Illuminate\Contracts\Cache\Store;use Illuminate\Contracts\Events\Dispatcher as DispatcherContractuse Illuminate\Support\Arr;use InvalidArgumentException;/** * @mixin \Illuminate\Contracts\Cache\Repository */class CacheManager implements FactoryContract&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The array of resolved cache stores. * * @var array */ protected $stores = []; /** * The registered custom driver creators. * * @var array */ protected $customCreators = []; /** * Create a new Cache manager instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125; /** * Get a cache store instance by name, wrapped in a repository. * * @param string|null $name * @return \Illuminate\Contracts\Cache\Repository */ public function store($name = null) &#123; $name = $name ?: $this-&gt;getDefaultDriver(); return $this-&gt;stores[$name] = $this-&gt;get($name); &#125; /** * Get a cache driver instance. * * @param string|null $driver * @return \Illuminate\Contracts\Cache\Repository */ public function driver($driver = null) &#123; return $this-&gt;store($driver); &#125; /** * Attempt to get the store from the local cache. * * @param string $name * @return \Illuminate\Contracts\Cache\Repository */ protected function get($name) &#123; return $this-&gt;stores[$name] ?? $this-&gt;resolve($name); &#125; /** * Resolve the given store. * * @param string $name * @return \Illuminate\Contracts\Cache\Repository * * @throws \InvalidArgumentException */ protected function resolve($name) &#123; $config = $this-&gt;getConfig($name); if (is_null($config)) &#123; throw new InvalidArgumentException("Cache store [&#123;$name&#125;] is not defined."); &#125; if (isset($this-&gt;customCreators[$config['driver']])) &#123; return $this-&gt;callCustomCreator($config); &#125; else &#123; $driverMethod = 'create'.ucfirst($config['driver']).'Driver'; if (method_exists($this, $driverMethod)) &#123; return $this-&gt;&#123;$driverMethod&#125;($config); &#125; else &#123; throw new InvalidArgumentException("Driver [&#123;$config['driver']&#125;] is not supported."); &#125; &#125; &#125; /** * Call a custom driver creator. * * @param array $config * @return mixed */ protected function callCustomCreator(array $config) &#123; return $this-&gt;customCreators[$config['driver']]($this-&gt;app, $config); &#125; /** * Create an instance of the array cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createArrayDriver(array $config) &#123; return $this-&gt;repository(new ArrayStore($config['serialize'] ?? false)); &#125; /** * Create an instance of the file cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createFileDriver(array $config) &#123; return $this-&gt;repository(new FileStore($this-&gt;app['files'], $config['path'], $config['permission'] ?? null)); &#125; /** * Create an instance of the Null cache driver. * * @return \Illuminate\Cache\Repository */ protected function createNullDriver() &#123; return $this-&gt;repository(new NullStore); &#125; /** * Create an instance of the Redis cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createRedisDriver(array $config) &#123; $redis = $this-&gt;app['redis']; $connection = $config['connection'] ?? 'default'; return $this-&gt;repository(new RedisStore($redis, $this-&gt;getPrefix($config), $connection)); &#125; /** * Create an instance of the database cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createDatabaseDriver(array $config) &#123; $connection = $this-&gt;app['db']-&gt;connection($config['connection'] ?? null); return $this-&gt;repository( new DatabaseStore( $connection, $config['table'], $this-&gt;getPrefix($config) ) ); &#125; /** * Create a new cache repository with the given implementation. * * @param \Illuminate\Contracts\Cache\Store $store * @return \Illuminate\Cache\Repository */ public function repository(Store $store) &#123; return tap(new Repository($store), function ($repository) &#123; $this-&gt;setEventDispatcher($repository); &#125;); &#125; /** * Set the event dispatcher on the given repository instance. * * @param \Illuminate\Cache\Repository $repository * @return void */ protected function setEventDispatcher(Repository $repository) &#123; if (! $this-&gt;app-&gt;bound(DispatcherContract::class)) &#123; return; &#125; $repository-&gt;setEventDispatcher( $this-&gt;app[DispatcherContract::class] ); &#125; /** * Re-set the event dispatcher on all resolved cache repositories. * * @return void */ public function refreshEventDispatcher() &#123; array_map([$this, 'setEventDispatcher'], $this-&gt;stores); &#125; /** * Get the cache prefix. * * @param array $config * @return string */ protected function getPrefix(array $config) &#123; return $config['prefix'] ?? $this-&gt;app['config']['cache.prefix']; &#125; /** * Get the cache connection configuration. * * @param string $name * @return array */ protected function getConfig($name) &#123; return $this-&gt;app['config']["cache.stores.&#123;$name&#125;"]; &#125; /** * Get the default cache driver name. * * @return string */ public function getDefaultDriver() &#123; return $this-&gt;app['config']['cache.default']; &#125; /** * Set the default cache driver name. * * @param string $name * @return void */ public function setDefaultDriver($name) &#123; $this-&gt;app['config']['cache.default'] = $name; &#125; /** * Unset the given driver instances. * * @param array|string|null $name * @return $this */ public function forgetDriver($name = null) &#123; $name = $name ?? $this-&gt;getDefaultDriver(); foreach ((array) $name as $cacheName) &#123; if (isset($this-&gt;stores[$cacheName])) &#123; unset($this-&gt;stores[$cacheName]); &#125; &#125; return $this; &#125; /** * Register a custom driver creator Closure. * * @param string $driver * @param \Closure $callback * @return $this */ public function extend($driver, Closure $callback) &#123; $this-&gt;customCreators[$driver] = $callback-&gt;bindTo($this, $this); return $this; &#125; /** * Dynamically call the default driver instance. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return $this-&gt;store()-&gt;$method(...$parameters); &#125;&#125; 缓存缓存使用原子锁 注：要使用这个功能，应用必须使用Memcached、Redis缓存驱动作为应用默认的缓存驱动，此外，所有服务器必须和同一台中央缓存服务器进行通信。 原子锁允许你对分布式锁进行操作而不必担心竞争条件，例如，Laravel Forge使用原子锁来确保在一台服务器上同时只有一个远程任务在执行，你可以通过Cache::lock方法来创建和管理锁： 12345if (Cache::lock('foo', 10)-&gt;get()) &#123; // Lock acquired for 10 seconds... Cache::lock('foo')-&gt;release();&#125; get方法还可以接收一个闭包，在闭包执行之后，Laravel会自动释放锁： 123Cache::lock('foo')-&gt;get(function () &#123; // Lock acquired indefinitely and automatically released...&#125;); 如果锁在你请求的时候无效，可以告知Laravel等待直到锁有效。如果锁在指定限制时间内无法获取，会抛出Illuminate\Contracts\Cache\LockTimeoutException异常： 1234567891011121314151617use Illuminate\Contracts\Cache\LockTimeoutException;$lock = Cache::lock('foo', 10);try &#123; $lock-&gt;block(5); // Lock acquired after waiting maximum of 5 seconds...&#125; catch (LockTimeoutException $e) &#123; // Unable to acquire lock...&#125; finally &#123; optional($lock)-&gt;release();&#125;Cache::lock('foo', 10)-&gt;block(5, function () &#123; // Lock acquired after waiting maximum of 5 seconds...&#125;); 管理跨进程的锁 有时候，你可能想要在一个进程中获取锁，在另一个进程中释放锁。例如，你可以在Web请求期间获取锁，然后在该请求触发的某个队列任务最后释放这把锁。在这种场景下，你应该传递锁的域「所有者令牌」到队列任务以便该任务可以使用给定令牌重新实例化锁： 1234567891011// 在控制器中...$podcast = Podcast::find($id);$lock = Cache::lock('foo', 120);if ($result = $lock-&gt;get()) &#123; ProcessPodcast::dispatch($podcast, $lock-&gt;owner());&#125;// 在 ProcessPodcast 任务中...Cache::restoreLock('foo', $this-&gt;owner)-&gt;release(); 如果你想要在不管当前所有者的情况下释放锁，可以使用forceRelease方法：1Cache::lock('foo')-&gt;forceRelease(); 缓存标签 注：缓存标签目前不支持file或database缓存驱动，此外，当使用多标签的缓存被设置为永久存储时，使用Memcached驱动的缓存有着最佳性能表现，因为Memcached会自动清除陈旧记录。 存储被打上标签的缓存项缓存标签允许你给相关缓存项打上同一个标签以便于后续清除这些缓存值，被打上标签的缓存可以通过传递一个被排序的标签数组来访问。例如，我们可以通过以下方式在添加缓存的时候设置标签：12Cache::tags(['people', 'artists'])-&gt;put('John', $john, $seconds);Cache::tags(['people', 'authors'])-&gt;put('Anne', $anne, $seconds); 访问被打上标签的缓存项要获取被打上标签的缓存项，传递同样的有序标签数组到tags方法然后使用你想要获取的key来调用get方法： 12$john = Cache::tags(['people', 'artists'])-&gt;get('John');$anne = Cache::tags(['people', 'authors'])-&gt;get('Anne'); 移除被打上标签的数据项你可以同时清除被打上同一标签/标签列表的所有缓存项，例如，以下语句会移除被打上people或authors标签的所有缓存： 1Cache::tags(['people', 'authors'])-&gt;flush(); 这样，上面设置的Anne和John缓存项都会从缓存中移除。 相反，以下语句只移除被打上authors标签的语句，所以只有Anne会被移除而John不会：1Cache::tags('authors')-&gt;flush(); 源码 Illuminate\Cache\TaggableStore.php 12345678910111213141516171819&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Store;abstract class TaggableStore implements Store&#123; /** * Begin executing a new tags operation. * * @param array|mixed $names * @return \Illuminate\Cache\TaggedCache */ public function tags($names) &#123; return new TaggedCache($this, new TagSet($this, is_array($names) ? $names : func_get_args())); &#125;&#125; Illuminate\Cache\TaggedCache.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123namespace Illuminate\Cache;use Illuminate\Contracts\Cache\Store;class TaggedCache extends Repository&#123; use RetrievesMultipleKeys &#123; putMany as putManyAlias; &#125; /** * The tag set instance. * * @var \Illuminate\Cache\TagSet */ protected $tags; /** * Create a new tagged cache instance. * * @param \Illuminate\Contracts\Cache\Store $store * @param \Illuminate\Cache\TagSet $tags * @return void */ public function __construct(Store $store, TagSet $tags) &#123; parent::__construct($store); $this-&gt;tags = $tags; &#125; /** * Store multiple items in the cache for a given number of seconds. * * @param array $values * @param int|null $ttl * @return bool */ public function putMany(array $values, $ttl = null) &#123; if ($ttl === null) &#123; return $this-&gt;putManyForever($values); &#125; return $this-&gt;putManyAlias($values, $ttl); &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function increment($key, $value = 1) &#123; $this-&gt;store-&gt;increment($this-&gt;itemKey($key), $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function decrement($key, $value = 1) &#123; $this-&gt;store-&gt;decrement($this-&gt;itemKey($key), $value); &#125; /** * Remove all items from the cache. * * @return bool */ public function flush() &#123; $this-&gt;tags-&gt;reset(); return true; &#125; /** * &#123;@inheritdoc&#125; */ protected function itemKey($key) &#123; return $this-&gt;taggedItemKey($key); &#125; /** * Get a fully qualified key for a tagged item. * * @param string $key * @return string */ public function taggedItemKey($key) &#123; return sha1($this-&gt;tags-&gt;getNamespace()).':'.$key; &#125; /** * Fire an event for this cache instance. * * @param string $event * @return void */ protected function event($event) &#123; parent::event($event-&gt;setTags($this-&gt;tags-&gt;getNames())); &#125; /** * Get the tag set instance. * * @return \Illuminate\Cache\TagSet */ public function getTags() &#123; return $this-&gt;tags; &#125;&#125; Illuminate\Cache\TagSet.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Store;class TagSet&#123; /** * The cache store implementation. * * @var \Illuminate\Contracts\Cache\Store */ protected $store; /** * The tag names. * * @var array */ protected $names = []; /** * Create a new TagSet instance. * * @param \Illuminate\Contracts\Cache\Store $store * @param array $names * @return void */ public function __construct(Store $store, array $names = []) &#123; $this-&gt;store = $store; $this-&gt;names = $names; &#125; /** * Reset all tags in the set. * * @return void */ public function reset() &#123; array_walk($this-&gt;names, [$this, 'resetTag']); &#125; /** * Reset the tag and return the new tag identifier. * * @param string $name * @return string */ public function resetTag($name) &#123; $this-&gt;store-&gt;forever($this-&gt;tagKey($name), $id = str_replace('.', '', uniqid('', true))); return $id; &#125; /** * Get a unique namespace that changes when any of the tags are flushed. * * @return string */ public function getNamespace() &#123; return implode('|', $this-&gt;tagIds()); &#125; /** * Get an array of tag identifiers for all of the tags in the set. * * @return array */ protected function tagIds() &#123; return array_map([$this, 'tagId'], $this-&gt;names); &#125; /** * Get the unique tag identifier for a given tag. * * @param string $name * @return string */ public function tagId($name) &#123; return $this-&gt;store-&gt;get($this-&gt;tagKey($name)) ?: $this-&gt;resetTag($name); &#125; /** * Get the tag identifier key for a given tag. * * @param string $name * @return string */ public function tagKey($name) &#123; return 'tag:'.$name.':key'; &#125; /** * Get all of the tag names in the set. * * @return array */ public function getNames() &#123; return $this-&gt;names; &#125;&#125; Illuminate\Cache\RedisTaggedCache.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;?phpnamespace Illuminate\Cache;class RedisTaggedCache extends TaggedCache&#123; /** * Forever reference key. * * @var string */ const REFERENCE_KEY_FOREVER = 'forever_ref'; /** * Standard reference key. * * @var string */ const REFERENCE_KEY_STANDARD = 'standard_ref'; /** * Store an item in the cache. * * @param string $key * @param mixed $value * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function put($key, $value, $ttl = null) &#123; if ($ttl === null) &#123; return $this-&gt;forever($key, $value); &#125; $this-&gt;pushStandardKeys($this-&gt;tags-&gt;getNamespace(), $key); return parent::put($key, $value, $ttl); &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function increment($key, $value = 1) &#123; $this-&gt;pushStandardKeys($this-&gt;tags-&gt;getNamespace(), $key); parent::increment($key, $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function decrement($key, $value = 1) &#123; $this-&gt;pushStandardKeys($this-&gt;tags-&gt;getNamespace(), $key); parent::decrement($key, $value); &#125; /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return bool */ public function forever($key, $value) &#123; $this-&gt;pushForeverKeys($this-&gt;tags-&gt;getNamespace(), $key); return parent::forever($key, $value); &#125; /** * Remove all items from the cache. * * @return bool */ public function flush() &#123; $this-&gt;deleteForeverKeys(); $this-&gt;deleteStandardKeys(); return parent::flush(); &#125; /** * Store standard key references into store. * * @param string $namespace * @param string $key * @return void */ protected function pushStandardKeys($namespace, $key) &#123; $this-&gt;pushKeys($namespace, $key, self::REFERENCE_KEY_STANDARD); &#125; /** * Store forever key references into store. * * @param string $namespace * @param string $key * @return void */ protected function pushForeverKeys($namespace, $key) &#123; $this-&gt;pushKeys($namespace, $key, self::REFERENCE_KEY_FOREVER); &#125; /** * Store a reference to the cache key against the reference key. * * @param string $namespace * @param string $key * @param string $reference * @return void */ protected function pushKeys($namespace, $key, $reference) &#123; $fullKey = $this-&gt;store-&gt;getPrefix().sha1($namespace).':'.$key; foreach (explode('|', $namespace) as $segment) &#123; $this-&gt;store-&gt;connection()-&gt;sadd($this-&gt;referenceKey($segment, $reference), $fullKey); &#125; &#125; /** * Delete all of the items that were stored forever. * * @return void */ protected function deleteForeverKeys() &#123; $this-&gt;deleteKeysByReference(self::REFERENCE_KEY_FOREVER); &#125; /** * Delete all standard items. * * @return void */ protected function deleteStandardKeys() &#123; $this-&gt;deleteKeysByReference(self::REFERENCE_KEY_STANDARD); &#125; /** * Find and delete all of the items that were stored against a reference. * * @param string $reference * @return void */ protected function deleteKeysByReference($reference) &#123; foreach (explode('|', $this-&gt;tags-&gt;getNamespace()) as $segment) &#123; $this-&gt;deleteValues($segment = $this-&gt;referenceKey($segment, $reference)); $this-&gt;store-&gt;connection()-&gt;del($segment); &#125; &#125; /** * Delete item keys that have been stored against a reference. * * @param string $referenceKey * @return void */ protected function deleteValues($referenceKey) &#123; $values = array_unique($this-&gt;store-&gt;connection()-&gt;smembers($referenceKey)); if (count($values) &gt; 0) &#123; foreach (array_chunk($values, 1000) as $valuesChunk) &#123; call_user_func_array([$this-&gt;store-&gt;connection(), 'del'], $valuesChunk); &#125; &#125; &#125; /** * Get the reference key for the segment. * * @param string $segment * @param string $suffix * @return string */ protected function referenceKey($segment, $suffix) &#123; return $this-&gt;store-&gt;getPrefix().$segment.':'.$suffix; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Collection]]></title>
    <url>%2F2020%2F04%2F12%2FLaravel-Collection%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 集合是“macroable”的，怎么理解？ new static是什么意思？ get_class()函数是什么意思？ 简介Illuminate\Support\Collection类为处理数组数据提供了流式、方便的封装。例如，查看下面的代码，我们使用辅助函数collect创建一个新的集合实例，为每一个元素运行strtoupper函数，然后移除所有空元素： 12345$collection = collect(['taylor', 'abigail', null])-&gt;map(function ($name) &#123; return strtoupper($name);&#125;)-&gt;reject(function ($name) &#123; return empty($name);&#125;); 正如你所看到的，Collection类允许你使用方法链对底层数组执行匹配和移除操作，通常，每个Collection方法都会返回一个新的Collection实例。 创建集合正如上面所提到的，辅助函数collect为给定数组返回一个新的Illuminate\Support\Collection实例，所以，创建集合很简单：1$collection = collect([1, 2, 3]); 注：默认情况下，Eloquent查询的结果总是返回Collection实例。 扩展集合集合是“macroable”的，这意味着我们可以在运行时动态添加方法到Collection类，例如，下面的代码添加了toUpper方法到Collection类：12345678910111213use Illuminate\Support\Str;Collection::macro('toUpper', function () &#123; return $this-&gt;map(function ($value) &#123; return Str::upper($value); &#125;);&#125;);$collection = collect(['first', 'second']);$upper = $collection-&gt;toUpper();// ['FIRST', 'SECOND'] 通常，我们需要在服务提供者中声明集合宏。 懒集合简介为了继续完善功能已经很强大的Collection类，LazyCollection类使用了PHP的生成器，从而可以通过极低的内存处理极大的数据集。 例如，假设你的应用需要通过Laravel提供的集合方法来解析并处理几个GB大小的日志文件，这个时候就可以使用懒集合（LazyCollection），它不会一次性将整个文件读入内存，而是每次只读取文件的一小部分：1234567891011121314use App\LogEntry;use Illuminate\Support\LazyCollection;LazyCollection::make(function () &#123; $handle = fopen('log.txt', 'r'); while (($line = fgets($handle)) !== false) &#123; yield $line; &#125;&#125;)-&gt;chunk(4)-&gt;map(function ($lines) &#123; return LogEntry::fromLines($lines);&#125;)-&gt;each(function (LogEntry $logEntry) &#123; // Process the log entry...&#125;); 或者，假设你需要迭代10000个Eloquent模型实例，使用传统的Laravel集合，所有10000个Eloquent模型实例必须一次性加载到内存中： 123$users = App\User::all()-&gt;filter(function ($user) &#123; return $user-&gt;id &gt; 500;&#125;); 而现在，查询构建器的cursor方法会返回一个LazyCollection实例，这样一来，我们仍然只需对数据库做一次查询，但是一次只会加载一个Eloquent模型实例到内存。在这个例子中，filter回调只有在迭代到每个独立用户时才会执行，从而大幅降低对内存的占用：1234567$users = App\User::cursor()-&gt;filter(function ($user) &#123; return $user-&gt;id &gt; 500;&#125;);foreach ($users as $user) &#123; echo $user-&gt;id;&#125; 创建懒集合要创建一个懒集合实例，需要传递一个PHP生成器函数到集合的make方法：123456789use Illuminate\Support\LazyCollection;LazyCollection::make(function () &#123; $handle = fopen('log.txt', 'r'); while (($line = fgets($handle)) !== false) &#123; yield $line; &#125;&#125;); new static无论是new static()还是new self()都是new一个对象，这两个方法new出来的对象有什么区别呢？说白了就是new出来的到底是同一个类的实例还是不同类的实例。 为了探究上面的问题，我们先上一段简单的代码。 1234567891011121314151617class Father&#123; public function getNewFather() &#123; return new self(); &#125; public function getNewCaller() &#123; return new static(); &#125;&#125; $f = new Father(); var_dump(get_class($f-&gt;getNewFather())); // Fathervar_dump(get_class($f-&gt;getNewCaller())); // Father 这里无论是getNewFather还是getNewCaller都是返回的Father这个实例，到这里貌似new self()还是new static()是没有区别的，我们接着走。123456789class Sun1 extends Father&#123; &#125; $sun1 = new Sun1(); var_dump($sun1-&gt;getNewFather()); // object(Father)#4 (0) &#123; &#125;var_dump($sun1-&gt;getNewCaller()); // object(Sun1)#4 (0) &#123; &#125; 这里我们发现了getNewFather返回的是Father的实例，而getNewCaller返回的是调用者的实例。 他们的区别只有在继承中才能体现出来、如果没有任何继承、那么二者没有任何区别。 然后new self()返回的实例是不会变的，无论谁去调用，都返回的一个类的实例，而new static则是由调用者决定的。 LazyCollection Illuminate\Support\LazyCollection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109namespace Illuminate\Support;use ArrayIterator;use Closure;use Illuminate\Support\Traits\EnumeratesValues;use Illuminate\Support\Traits\Macroable;use IteratorAggregate;use stdClass;class LazyCollection implements Enumerable&#123; use EnumeratesValues, Macroable; /** * The source from which to generate items. * * @var callable|static */ public $source; /** * Create a new lazy collection instance. * * @param mixed $source * @return void */ public function __construct($source = null) &#123; if ($source instanceof Closure || $source instanceof self) &#123; $this-&gt;source = $source; &#125; elseif (is_null($source)) &#123; $this-&gt;source = static::empty(); &#125; else &#123; $this-&gt;source = $this-&gt;getArrayableItems($source); &#125; &#125; /** * Create a new instance with no items. * * @return static */ public static function empty() &#123; return new static([]); &#125; /** * Create a new instance by invoking the callback a given amount of times. * * @param int $number * @param callable|null $callback * @return static */ public static function times($number, callable $callback = null) &#123; if ($number &lt; 1) &#123; return new static; &#125; $instance = new static(function () use ($number) &#123; for ($current = 1; $current &lt;= $number; $current++) &#123; yield $current; &#125; &#125;); return is_null($callback) ? $instance : $instance-&gt;map($callback); &#125; /** * Create an enumerable with the given range. * * @param int $from * @param int $to * @return static */ public static function range($from, $to) &#123; return new static(function () use ($from, $to) &#123; for (; $from &lt;= $to; $from++) &#123; yield $from; &#125; &#125;); &#125; /** * Get all items in the enumerable. * * @return array */ public function all() &#123; if (is_array($this-&gt;source)) &#123; return $this-&gt;source; &#125; return iterator_to_array($this-&gt;getIterator()); &#125; /** * Eager load all items into a new lazy collection backed by an array. * * @return static */ public function eager() &#123; return new static($this-&gt;all()); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-tap]]></title>
    <url>%2F2020%2F04%2F10%2FLaravel-tap%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： tap()的实现，不再需要临时变量。怎么理解？ 在本文，我们将讨论Laravel中的tap。我们将详细讨论tap帮助函数和collection中的tap方法。 Tap帮助函数旧的实现方式Laravel5.3提出了一个tap函数。这是一个非常奇怪的函数，受Ruby的启发，允许你去tap成链。这是tap助手函数的基本实现。 123456function tap($value, $callback)&#123; $callback($value); return $value;&#125; 需要传一个值和一个回调到方法中，值作为回调的参数，回调将执行，最后值被返回。让我们看看我们如何以有意义的方式使用它。例如：12345678&lt;?php$photo = App\Photo::find(1);return tap($photo, function($photo) &#123; $photo-&gt;validated = true; $photo-&gt;save();&#125;); 在上面的例子中，我们传递一个参数（Photo模型）和一个回调函数，该函数简单地将validated设置为true并保存模型。这个函数然后将Photo模型实例返回给调用者。 新的实现方式在最新版本中，更高级的tap来了。它引入了更短的使用方式。这里是tap函数的新实现。12345678910function tap($value, $callback = null)&#123; if (is_null($callback)) &#123; return new HigherOrderTapProxy($value); &#125; $callback($value); return $value;&#125; 回调函数现在是可选的。你还可以链式使用参数中的多个方法，这里其实也就是PhotoModel中支持的方法。例如：1234567&lt;?php$photo = App\Photo::find(1);return tap($photo)-&gt;update([ 'validated' =&gt; 'true',]) 我们能够将任何模型的方法通过tap链式调用。此更新方法通常返回true或false，但是这里使用了tap函数。在这种情况下，它将返回Photo模型。tap可以帮助你返回作为参数传递的对象。 它是如何工作的tap是一个非常有用的功能，但有时它很难理解它是如何工作的。这里来解释它是如何工作的。 如果没有给出回调函数，因为它是可选的，Laravel将返回HigherOrderTapProxy的新实例。在HigherOrderTapProxy类中定义了调用魔术方法。调用魔术方法是由语言动态调用的（所谓的方法在类中没有定义）。因为除了调用魔术方法，HigherOrderTapProxy类中没有定义方法，所以每次使用tap函数任何方法调用时都会调用它。在调用魔术方法中，我们的更新方法或任何我们调用的方法将被参数调用，并且它将返回我们最初传递给tap函数的参数。 Illuminate/Support/HigherOrderTapProxy.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Illuminate\Support;class HigherOrderTapProxy&#123; /** * The target being tapped. * * @var mixed */ public $target; /** * Create a new tap proxy instance. * * @param mixed $target * @return void */ public function __construct($target) &#123; $this-&gt;target = $target; &#125; /** * Dynamically pass method calls to the target. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; $this-&gt;target-&gt;&#123;$method&#125;(...$parameters); return $this-&gt;target; &#125;&#125; 在上面的代码中，target属性是我们在tap中传递的参数。 Laravel collection中的tap方法Laravel还在collection类中有一个tap方法，可让你在特定的地方传入参数到tap中，并对这些结果进行处理。tap不会影响主要collection的结果。这对调试代码和查找在处理集合时出现错误的地方很有帮助。我们用一个例子来解释这个方法。初始化以下数组。123456789101112131415161718192021222324252627282930313233343536373839404142$photos = [ [ 'file_name' =&gt; 'wallpaper', 'validated' =&gt; true, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'spring', 'validated' =&gt; true, 'extension' =&gt; 'png' ], [ 'file_name' =&gt; 'flowers', 'validated' =&gt; false, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'mac', 'validated' =&gt; true, 'extension' =&gt; 'png' ], [ 'file_name' =&gt; 'books', 'validated' =&gt; false, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'mobiles', 'validated' =&gt; false, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'glass', 'validated' =&gt; false, 'extension' =&gt; 'png' ], [ 'file_name' =&gt; 'fruit', 'validated' =&gt; true, 'extension' =&gt; 'jpg' ],]; 现在让我们尝试在这个数组上使用tap方法。首先，我们必须将这个数组转换为一个集合，然后在特定点处tap这个集合。123456return collect($photos) -&gt;where('validated', true) -&gt;tap(function ($validated) &#123; return var_dump($validated-&gt;pluck('file_name')); &#125;);&#125;); 上面的代码将会输出以下结果：1234wallpaperspringmacfruit tap VS Pipe（管道）在Laravel中，也有类似的方法叫管道。它们在某种意义上是相似的，因为它们都在集合管道中使用。tap和pipe之间有一个区别。tap允许你使用数据，但不会修改原始返回值。另一方面，pipe根据返回值修改数据。例如：123456return collect($photos) -&gt;where('validated', true) -&gt;pipe(function ($validated) &#123; return $validated-&gt;where('extension', 'jpg')-&gt;pluck('file_name'); &#125;);&#125;); 输出结果为：12wallpaperfruit 另一方面，如果我们像这样使用上面的代码：123456return collect($photos) -&gt;where('validated', true) -&gt;tap(function ($validated) &#123; return $validated-&gt;where('extension', 'jpg')-&gt;pluck('file_name'); &#125;);&#125;); 它将返回验证设置为true的所有照片数组。 结果为：12345678910111213141516171819200: &#123; file_name: &quot;wallpaper&quot;, validated: true, extension: &quot;jpg&quot;&#125;,1: &#123; file_name: &quot;spring&quot;, validated: true, extension: &quot;png&quot;&#125;,3: &#123; file_name: &quot;mac&quot;, validated: true, extension: &quot;png&quot;&#125;,7: &#123; file_name: &quot;fruit&quot;, validated: true, extension: &quot;jpg&quot;&#125; 1234$user = User::find(1);$data = [...];$user-&gt;update($data);$user-&gt;notify(); 如果用tap，可以：1tap(User::find(1))-&gt;update($data)-&gt;notify(); 写起来更简洁。 执行中间操作从一个简单的例子开始，提取Laravel的AuthenticateSession@handle()的一些代码：12345$response = $next($request); $this-&gt;storePasswordHashInSession($request); return $response; 使用tap()帮助函数：123return tap($next($request), function () use ($request) &#123; $this-&gt;storePasswordHashInSession($request);&#125;); 另外的一个简单的例子，让我们看看Illuminate\Cache\Repository下的pull方法，此函数将从指定键的缓存中获取值，并将其删除。pull方法的实现：12345678public function pull($key, $default = null)&#123; $value = $this-&gt;get($key, $default); $this-&gt;forget($key) // returns a boolean; return $value;&#125; 上面的例子中，$this-&gt;forget()返回一个布尔值，所以要使我们的函数返回原始值，需要将其储存到临时变量$value中。以下是tap()的实现，不再需要临时变量：123456public function pull($key, $default = null)&#123; return tap($this-&gt;get($key, $default), function ($value) use ($key) &#123; $this-&gt;forget($key); &#125;);&#125; 恢复状态Eloquent的create和update方法支持[‘timestamps’=&gt;false]选项。如果这被实现成链式方法，结果的可读性会更好。123456789101112// Method defined in App\Model that App\Message extends.public function keepingTimestamps(callable $callback)&#123; try &#123; $timestamps = $this-&gt;timestamps; $this-&gt;timestamps = false; return tap($this, $callback); &#125; finally &#123; $this-&gt;timestamps = $timestamps; &#125;&#125; 现在Message模型可以链式使用以上的方法：123request()-&gt;user()-&gt;latestMessage-&gt;keepingTimestamps(function ($message) &#123; $message-&gt;markRead(); // updates a 'read_at' timestamp instead&#125;); // returns the latestMessage 如果你写的代码有DB::transaction()相同的模式，你可以在Laravel 5.4使用tap() 帮助函数重写。 CollectionLaravel 5.4中也可以在Collection类中使用tap()方法。你可以在任何地方使用，而不需要破坏链式。对于Laravel 5.3及更早的版本，你只需要复制粘贴五行代码的方法作为Collection macro到你项目的AppServiceProvider@boot()即可。 这里有一个例子，用于Laravel网站支持英语和法语。取代月份的语言翻译文件，使用Carbon列出一年每个月份的&#60;option&#62;。因此这个模型的修饰方法：12345678910111213141516171819public function monthOptions()&#123; return collect(range(1, 12)) -&gt;keyByValue() // custom Collection macro -&gt;tap(function () &#123; if (App::getLocale() === 'fr') &#123; setlocale(LC_TIME, 'fr_CA'); &#125; &#125;) -&gt;map(function ($month) &#123; return sprintf('%02d - %s', $month, Carbon::now()-&gt;month($month)-&gt;formatLocalized('%B')); &#125;) -&gt;tap(function () &#123; if (App::getLocale() === 'fr') &#123; setlocale(LC_TIME, ''); &#125; &#125;);&#125; 对于更多的语言支持，设置/恢复状态将提取到其他方法，使其更加可读。 使用Collection tap()处理控制台命令进度条这是在集合中最典型的用例。你甚至可以在handle()处理过程中保持其方法链。12345678910111213141516171819202122232425public function handle()&#123; Club::findOrFail($this-&gt;option('club')) -&gt;members() -&gt;subscribed() -&gt;get() -&gt;tap(function ($members) &#123; $this-&gt;output-&gt;progressStart($members-&gt;count()); &#125;) -&gt;each(function ($member) &#123; Mail::to($member)-&gt;queue(new Newsletter($member, $this-&gt;matchReport()); $this-&gt;output-&gt;progressAdvance(); &#125;) -&gt;tap(function () &#123; $this-&gt;output-&gt;progressFinish(); &#125;);&#125; public function matchReport()&#123; return once(function () &#123; return MatchReport::ofRound($this-&gt;option('round'))-&gt;firstOrFail(); &#125;);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Funnel]]></title>
    <url>%2F2020%2F04%2F10%2FLaravel-Funnel%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： ConcurrencyLimiterBuilder是干什么用的？为什么用Builder结尾？ 使用频率限制 队列可以指定可以同时处理给定任务的最大进程数量。这个功能在队列任务正在编辑一次只能由一个任务进行处理的资源时很有用。例如，使用funnel方法你可以给定类型任务一次只能由一个工作进程进行处理： 1234567Redis::funnel('key')-&gt;limit(1)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 源码12345678910111213141516171819202122232425262728&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Redis\Events\CommandExecuted;use Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder;use Illuminate\Redis\Limiters\DurationLimiterBuilder;use Illuminate\Support\Traits\Macroable;abstract class Connection&#123; use Macroable &#123; __call as macroCall; &#125; /** * Funnel a callback for a maximum number of simultaneous executions. * * @param string $name * @return \Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder */ public function funnel($name) &#123; return new ConcurrencyLimiterBuilder($this, $name); &#125;&#125; Illuminate\Contracts\Redis\LimiterTimeoutException.php 12345678910&lt;?phpnamespace Illuminate\Contracts\Redis;use Exception;class LimiterTimeoutException extends Exception&#123; //&#125; Illuminate\Redis\Limiters\ConcurrencyLimiter.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;?phpnamespace Illuminate\Redis\Limiters;use Exception;use Illuminate\Contracts\Redis\LimiterTimeoutException;use Illuminate\Support\Str;class ConcurrencyLimiter&#123; /** * The Redis factory implementation. * * @var \Illuminate\Redis\Connections\Connection */ protected $redis; /** * The name of the limiter. * * @var string */ protected $name; /** * The allowed number of concurrent tasks. * * @var int */ protected $maxLocks; /** * The number of seconds a slot should be maintained. * * @var int */ protected $releaseAfter; /** * Create a new concurrency limiter instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $maxLocks * @param int $releaseAfter * @return void */ public function __construct($redis, $name, $maxLocks, $releaseAfter) &#123; $this-&gt;name = $name; $this-&gt;redis = $redis; $this-&gt;maxLocks = $maxLocks; $this-&gt;releaseAfter = $releaseAfter; &#125; /** * Attempt to acquire the lock for the given number of seconds. * * @param int $timeout * @param callable|null $callback * @return bool * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException * @throws \Exception */ public function block($timeout, $callback = null) &#123; $starting = time(); $id = Str::random(20); while (! $slot = $this-&gt;acquire($id)) &#123; if (time() - $timeout &gt;= $starting) &#123; throw new LimiterTimeoutException; &#125; usleep(250 * 1000); &#125; if (is_callable($callback)) &#123; try &#123; return tap($callback(), function () use ($slot, $id) &#123; $this-&gt;release($slot, $id); &#125;); &#125; catch (Exception $exception) &#123; $this-&gt;release($slot, $id); throw $exception; &#125; &#125; return true; &#125; /** * Attempt to acquire the lock. * * @param string $id A unique identifier for this lock * @return mixed */ protected function acquire($id) &#123; $slots = array_map(function ($i) &#123; return $this-&gt;name.$i; &#125;, range(1, $this-&gt;maxLocks)); return $this-&gt;redis-&gt;eval(...array_merge( [$this-&gt;lockScript(), count($slots)], array_merge($slots, [$this-&gt;name, $this-&gt;releaseAfter, $id]) )); &#125; /** * Get the Lua script for acquiring a lock. * * KEYS - The keys that represent available slots * ARGV[1] - The limiter name * ARGV[2] - The number of seconds the slot should be reserved * ARGV[3] - The unique identifier for this lock * * @return string */ protected function lockScript() &#123; return &lt;&lt;&lt;'LUA'for index, value in pairs(redis.call('mget', unpack(KEYS))) do if not value then redis.call('set', KEYS[index], ARGV[3], "EX", ARGV[2]) return ARGV[1]..index endendLUA; &#125; /** * Release the lock. * * @param string $key * @param string $id * @return void */ protected function release($key, $id) &#123; $this-&gt;redis-&gt;eval($this-&gt;releaseScript(), 1, $key, $id); &#125; /** * Get the Lua script to atomically release a lock. * * KEYS[1] - The name of the lock * ARGV[1] - The unique identifier for this lock * * @return string */ protected function releaseScript() &#123; return &lt;&lt;&lt;'LUA'if redis.call('get', KEYS[1]) == ARGV[1]then return redis.call('del', KEYS[1])else return 0endLUA; &#125;&#125; ConcurrencyLimiterBuilder Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?phpnamespace Illuminate\Redis\Limiters;use Illuminate\Contracts\Redis\LimiterTimeoutException;use Illuminate\Support\InteractsWithTime;class ConcurrencyLimiterBuilder&#123; use InteractsWithTime; /** * The Redis connection. * * @var \Illuminate\Redis\Connections\Connection */ public $connection; /** * The name of the lock. * * @var string */ public $name; /** * The maximum number of entities that can hold the lock at the same time. * * @var int */ public $maxLocks; /** * The number of seconds to maintain the lock until it is automatically released. * * @var int */ public $releaseAfter = 60; /** * The amount of time to block until a lock is available. * * @var int */ public $timeout = 3; /** * Create a new builder instance. * * @param \Illuminate\Redis\Connections\Connection $connection * @param string $name * @return void */ public function __construct($connection, $name) &#123; $this-&gt;name = $name; $this-&gt;connection = $connection; &#125; /** * Set the maximum number of locks that can obtained per time window. * * @param int $maxLocks * @return $this */ public function limit($maxLocks) &#123; $this-&gt;maxLocks = $maxLocks; return $this; &#125; /** * Set the number of seconds until the lock will be released. * * @param int $releaseAfter * @return $this */ public function releaseAfter($releaseAfter) &#123; $this-&gt;releaseAfter = $this-&gt;secondsUntil($releaseAfter); return $this; &#125; /** * Set the amount of time to block until a lock is available. * * @param int $timeout * @return $this */ public function block($timeout) &#123; $this-&gt;timeout = $timeout; return $this; &#125; /** * Execute the given callback if a lock is obtained, otherwise call the failure callback. * * @param callable $callback * @param callable|null $failure * @return mixed * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException */ public function then(callable $callback, callable $failure = null) &#123; try &#123; return (new ConcurrencyLimiter( $this-&gt;connection, $this-&gt;name, $this-&gt;maxLocks, $this-&gt;releaseAfter ))-&gt;block($this-&gt;timeout, $callback); &#125; catch (LimiterTimeoutException $e) &#123; if ($failure) &#123; return $failure($e); &#125; throw $e; &#125; &#125;&#125; Illuminate\Support\InteractsWithTime.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Illuminate\Support;use DateInterval;use DateTimeInterface;trait InteractsWithTime&#123; /** * Get the number of seconds until the given DateTime. * * @param \DateTimeInterface|\DateInterval|int $delay * @return int */ protected function secondsUntil($delay) &#123; $delay = $this-&gt;parseDateInterval($delay); return $delay instanceof DateTimeInterface ? max(0, $delay-&gt;getTimestamp() - $this-&gt;currentTime()) : (int) $delay; &#125; /** * Get the "available at" UNIX timestamp. * * @param \DateTimeInterface|\DateInterval|int $delay * @return int */ protected function availableAt($delay = 0) &#123; $delay = $this-&gt;parseDateInterval($delay); return $delay instanceof DateTimeInterface ? $delay-&gt;getTimestamp() : Carbon::now()-&gt;addRealSeconds($delay)-&gt;getTimestamp(); &#125; /** * If the given value is an interval, convert it to a DateTime instance. * * @param \DateTimeInterface|\DateInterval|int $delay * @return \DateTimeInterface|int */ protected function parseDateInterval($delay) &#123; if ($delay instanceof DateInterval) &#123; $delay = Carbon::now()-&gt;add($delay); &#125; return $delay; &#125; /** * Get the current system time as a UNIX timestamp. * * @return int */ protected function currentTime() &#123; return Carbon::now()-&gt;getTimestamp(); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP管道插件League\Pipeline]]></title>
    <url>%2F2020%2F04%2F06%2FPHP%E7%AE%A1%E9%81%93%E6%8F%92%E4%BB%B6League-Pipeline%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 责任链模式是什么样子的？属于什么类型模式？ Pipeline设计模式水管太长，只要有一处破了，就会漏水了，而且不利于复杂环境弯曲转折使用。所以我们都会把水管分成很短的一节一节管道，然后最大化的让管道大小作用不同，因地制宜，组装在一起，满足各种各样的不同需求。 由此得出Pipeline的设计模式，就是将复杂冗长的流程 (processes) 截成各个小流程，小任务。每个最小量化的任务就可以复用，通过组装不同的小任务，构成复杂多样的流程（processes）。 最后将「输入」引入管道，根据每个小任务对输入进行操作（加工、过滤），最后输出满足需要的结果。 gulpgulp是基于NodeJS的自动任务运行器，她能自动化地完成Javascript、sass、less等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 12345678910111213141516171819202122var gulp = require('gulp');var less = require('gulp-less');var minifyCSS = require('gulp-csso');var concat = require('gulp-concat');var sourcemaps = require('gulp-sourcemaps');gulp.task('css', function()&#123; return gulp.src('client/templates/*.less') .pipe(less()) .pipe(minifyCSS()) .pipe(gulp.dest('build/css'))&#125;);gulp.task('js', function()&#123; return gulp.src('client/javascript/*.js') .pipe(sourcemaps.init()) .pipe(concat('app.min.js')) .pipe(sourcemaps.write()) .pipe(gulp.dest('build/js'))&#125;);gulp.task('default', [ 'html', 'css', 'js' ]); 上面的两个task主要是将less、所有js文件进行解析、压缩、输出等流程操作，然后存到对应的文件夹下；每一步操作的输出就是下一步操作的输入，犹如管道的流水一般。 Illuminate\Pipeline12345678910111213141516171819202122232425&lt;?phpclass Demo &#123; public function demo(Request $request) &#123; $pipe1 = function ($payload, Closure $next) &#123; $payload = $payload + 1; return $next($payload); &#125;; $pipe2 = function ($payload, Closure $next) &#123; $payload = $payload * 3; return $next($payload); &#125;; $pipeline = new Pipeline(); $pipeline-&gt;send(8) -&gt;through([$pipe1, $pipe2]) -&gt;then(function ($data) &#123; return $data; &#125;); // 27 &#125;&#125; League\Pipeline安装1composer require league/pipeline 使用两个角色 Pipelines实现为不变的stage链。当你pipe一个新的stage时，将使用添加的stage创建一个新pipeline。这使得pipelines易于重用，并将副作用最小化。 1、pipeline 2、stage Closure 在管道中，stage可以是满足可调用类型提示的任何类型。所以闭包和任何可调用的东西都是可以的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace app\api\controller;use League\Pipeline\Pipeline;use League\Pipeline\PipelineBuilder;class Test&#123; public function testPipeline() &#123; // 创建两个闭包函数 $stage1 = function ($payload) &#123; return $payload + 1; &#125;; $stage2 = function ($payload) &#123; return $payload * 3; &#125;; // 正常使用 $pipeline1 = (new Pipeline) -&gt;pipe($stage1) -&gt;pipe($stage2); $callback1 = $pipeline1-&gt;process(10); print_r($callback1.PHP_EOL); // 33 // 使用魔术方法 $pipeline2 = (new Pipeline()) -&gt;pipe($stage1) -&gt;pipe($stage2); $callback2 = $pipeline2(3); print_r($callback2.PHP_EOL); // 12 // 使用Builder // 因为pipelines本身是不可变的，所以引入PipelineBuilder来便利pipeline的分布式组合。 // PipelineBuilder收集stages并允许在任何给定时间创建pipeline。 $builder = new PipelineBuilder(); $pipeline3 = $builder -&gt;add($stage1) -&gt;add($stage2) -&gt;build(); $callback3 = $pipeline3(6); print_r($callback3.PHP_EOL); // 21 &#125;&#125; Class 基于类的stage也是可以的。可以实现StageInterface，以确保您拥有正确的方法签名以实现__invoke方法。 123456789101112131415161718192021222324252627&lt;?phpuse League\Pipeline\Pipeline;use League\Pipeline\StageInterface;class TimesTwoStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload * 2; &#125;&#125;class AddOneStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload + 1; &#125;&#125;$pipeline = (new Pipeline) -&gt;pipe(new TimesTwoStage) -&gt;pipe(new AddOneStage);// Returns 21$pipeline-&gt;process(10); Reuse 因为PipelineInterface是StageInterface的扩展，所以pipeline可以作为stage重用。这将创建一个高度组合的模型，以创建复杂的执行模式，同时保持较低的认知负载。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpuse League\Pipeline\Pipeline;use League\Pipeline\StageInterface;class TimesTwoStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload * 2; &#125;&#125;class AddOneStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload + 1; &#125;&#125;class DivisionFourStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload / 4; &#125;&#125;class ReduceThreeStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload - 3; &#125;&#125;$pipeline1 = (new Pipeline) -&gt;pipe(new TimesTwoStage) -&gt;pipe(new AddOneStage);$pipeline2 = (new Pipeline) -&gt;pipe(new ReduceThreeStage) -&gt;pipe($pipeline1) -&gt;pipe(new DivisionFourStage);$pipeline2-&gt;process(12); // 4.75 Exception 这个包在处理异常时是完全透明的。在任何情况下，此包都不会捕获异常或使错误静音。在stage内或在pipeline处理有效负载时，应根据具体情况处理Exception。 1234567891011121314151617181920212223&lt;?phpnamespace app\api\controller;use League\Pipeline\Pipeline;use LogicException;class Test&#123; function testException() &#123; $pipeline = (new Pipeline)-&gt;pipe(function () &#123; throw new LogicException('这个阶段出错了'); &#125;); try &#123; $pipeline-&gt;process(10); &#125; catch(LogicException $e) &#123; // Handle the exception. echo $e-&gt;getMessage(); // 这个阶段出错了 &#125; &#125;&#125; 源码整个插件就这几个文件： Pipeline StageInterface.php 12345678910111213141516&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface StageInterface&#123; /** * Process the payload. * * @param mixed $payload * * @return mixed */ public function __invoke($payload);&#125; PipelineInterface.php 1234567891011121314&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface PipelineInterface extends StageInterface&#123; /** * Create a new pipeline with an appended stage. * * @return static */ public function pipe(callable $operation): PipelineInterface;&#125; 该接口主要是利用链式编程的思想，不断添加管道「pipe」，然后增加一个魔术方法，来让传入的参数运转起来。 先看看这个魔术方法的作用：1mixed __invoke ([ $... ] ) 当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用。 如：12345678910111213&lt;?phpclass CallableClass &#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5);var_dump(is_callable($obj)); 返回结果：123int(5)bool(true)Pipeline 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class Pipeline implements PipelineInterface&#123; /** * @var callable[] */ private $stages = []; /** * @var ProcessorInterface */ private $processor; public function __construct(ProcessorInterface $processor = null, callable ...$stages) &#123; $this-&gt;processor = $processor ?? new FingersCrossedProcessor; $this-&gt;stages = $stages; &#125; public function pipe(callable $stage): PipelineInterface &#123; $pipeline = clone $this; $pipeline-&gt;stages[] = $stage; return $pipeline; &#125; public function process($payload) &#123; return $this-&gt;processor-&gt;process($payload, ...$this-&gt;stages); &#125; public function __invoke($payload) &#123; return $this-&gt;process($payload); &#125;&#125; 其中核心类Pipeline的作用主要就是两个： 1、添加组装各个管道「pipe」；2、组装后，引水流动，执行sprocess($payload)，输出结果。 Processor 接好各种管道后，那就要「引水入渠」了。该插件提供了两个基础执行类，比较简单，直接看代码就能懂。 FingersCrossedProcessor.php 按照$stages数组顺序，遍历执行管道方法，再将结果传入下一个管道，让「水」一层层「流动」起来 12345678910111213141516&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class FingersCrossedProcessor implements ProcessorInterface&#123; public function process($payload, callable ...$stages) &#123; foreach ($stages as $stage) &#123; $payload = $stage($payload); &#125; return $payload; &#125;&#125; InterruptibleProcessor.php 增加一个额外的「过滤网」，经过每个管道后的结果，都需要check，一旦满足则终止，直接输出结果。 1234567891011121314151617181920212223242526272829303132&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class InterruptibleProcessor implements ProcessorInterface&#123; /** * @var callable */ private $check; public function __construct(callable $check) &#123; $this-&gt;check = $check; &#125; public function process($payload, callable ...$stages) &#123; $check = $this-&gt;check; foreach ($stages as $stage) &#123; $payload = $stage($payload); if (true !== $check($payload)) &#123; return $payload; &#125; &#125; return $payload; &#125;&#125; ProcessorInterface.php 12345678910111213141516&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface ProcessorInterface&#123; /** * Process the payload using multiple stages. * * @param mixed $payload * * @return mixed */ public function process($payload, callable ...$stages);&#125; 我们完全也可以利用该接口，实现我们的方法来组装管道和「过滤网」。 PipelineBuilder 最后提供了一个Builder，这个也很好理解： PipelineBuilderInterface.php 12345678910111213141516171819&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface PipelineBuilderInterface&#123; /** * Add an stage. * * @return self */ public function add(callable $stage): PipelineBuilderInterface; /** * Build a new Pipeline object. */ public function build(ProcessorInterface $processor = null): PipelineInterface;&#125; PipelineBuilder.php 123456789101112131415161718192021222324252627&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class PipelineBuilder implements PipelineBuilderInterface&#123; /** * @var callable[] */ private $stages = []; /** * @return self */ public function add(callable $stage): PipelineBuilderInterface &#123; $this-&gt;stages[] = $stage; return $this; &#125; public function build(ProcessorInterface $processor = null): PipelineInterface &#123; return new Pipeline($processor, ...$this-&gt;stages); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Pipeline组件的实现]]></title>
    <url>%2F2020%2F04%2F06%2FLaravel-Pipeline%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： (new Pipeline)是什么意思？ Laravel框架中有一个非常有趣的功能，就是HTTP中间件，我们在定义路由的时候，通过中间件对访问进行过滤。来自外部的请求首先经过全局中间件，若通过，则会继续穿过层层路由组所设置的中间件，再到达目的路由，当然，目的路由也可能定义了个中间件，通过后，该路由的处理对象（如控制器），得到的就是一个经过过滤的请求了。 开始本文当然不是讨论中间件如何使用，而是其实现的基础。Laravel框架中有一个组件叫做Illuminate\Pipeline，意味“管道”，我们看看下面这个代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpuse Illuminate\Pipeline\Pipeline;use Closure;$pipe1 = function ($poster, Closure $next) &#123; $poster += 1; echo "pipe1: $poster\n"; return $next($poster);&#125;;$pipe2 = function ($poster, Closure $next) &#123; if ($poster &gt; 7) &#123; return $poster; &#125; $poster += 3; echo "pipe2: $poster\n"; return $next($poster);&#125;;$pipe3 = function ($poster, Closure $next) &#123; $result = $next($poster); echo "pipe3: $result\n"; return $result * 2;&#125;;$pipe4 = function ($poster, Closure $next) &#123; $poster += 2; echo "pipe4 : $poster\n"; return $next($poster);&#125;;$pipes = [$pipe1, $pipe2, $pipe3, $pipe4];function dispatcher($poster, $pipes)&#123; echo "result: " . (new Pipeline)-&gt;send($poster)-&gt;through($pipes)-&gt;then(function ($poster) &#123; echo "received: $poster\n"; return 3; &#125;) . "\n";&#125;echo "==&gt; action 1:\n";dispatcher(5, $pipes);echo "==&gt; action 2:\n";dispatcher(7, $pipes); 上述代码执行结果如下：12345678910==&gt; action 1:pipe1: 6pipe2: 9pipe4 : 11received: 11pipe3: 3result: 6==&gt; action 2:pipe1: 8result: 8 流程概览Pipeline 组件实现了一个过滤流程: 原始数据 ---> 【前置管道】 ---> 目标处理逻辑 ---> 【后置管道】 ---> 结果数据 通过这种机制，可以将目标处理逻辑与过滤、认证等机制的代码分离开来，这样我们就更容易让代码清晰和易于维护。通过前置、后置管道，在其中“放置”我们需要过滤的逻辑即可，如上述代码，虽然只是一个简单的示例，就已经能够看得出，整个流程的动向，譬如我们在上面示例中准备了四个过滤组件（中间件）：pipe1、pipe2、pipe3、pipe4，其中1、2、4是前置，3为后置。 输入的原始数据为5，执行过程首先通过1号过滤组件，然后是2号，再然后是4号，到达目标处理逻辑后，再通过3号过滤组件，最终输出结果。 输入原始数据为7，同样是先经过1号过滤组件，随后是2号，不过在2号中，直接返回了结果，这意味着过程被拦截，不再继续向下传递数据，至此结束并返回结果。 Laravel框架中，原始数据是一个Request对象，通过所定义的前置中间件，开发者可在中间件中获取Request的信息，比如用户的Session/Cookie以及Header等，验证数据是否完备等等，不完备或不符合要求的，则被拦截并返回一个响应告知。若能正常通过则继续传递至最终的处理逻辑，如控制器的某个方法或者一个匿名函数。通过这种模式，我们就实现了请求校验和业务逻辑的分离，而且这样十分便于开发和维护。 实现Pipeline这个组件的功能十分明确，实现这种类似功能的肯定不少，选择其作为代表分析，原因就是其实现的方式非常简洁、有力，不但其实现原理如此，面对开发人员，它的调用方式也十分清晰，利用匿名函数使得前置与后置的调用都很直观，本文分析的重点就在这里。 实现的思路即使有了，在没有很好地基础之前，估计也很难去完成。当然很多人愿意去阅读其代码，这样就少走了不少弯路，在这里，我的建议也是这样。不过，很多人看到源码也很迷惑，因为中间存在着非常多的回调，只要基础不够扎实，就很容易在期间产生诸多困惑。 不过，逐步分析和对基础知识的补完，就会发现再复杂的框架也不过是零碎的功能有序的构建起来的。 array_reduce的妙用12345678910public function then(Closure $destination)&#123; $firstSlice = $this-&gt;getInitialSlice($destination); $callable = array_reduce( array_reverse($this-&gt;pipes), $this-&gt;getSlice(), $firstSlice ); return $callable($this-&gt;passable);&#125; 上面的代码就是Pipeline启动过程的起点，当然在调用then方法之前我们还有必要调用send和through，send是传递初始数据，through则是传递需要通过的中间件构成的数组。 then方法接受一个要求匿名函数的参数，该参数所接受的匿名函数，就是用于整个流程的逻辑处理部分的，数据穿过层层中间件，最终到达这里，所以该匿名函数可接受一个参数，就是经过过滤的数据啦。该方法囊括着所有功能，但是代码不过几行，因此肯定有额外的调度过程。 代码中首先映入眼帘的就是$this-&gt;getInitialSlice()，该方法顾名思义，创建了一个初始化用的Slice，这块我们先不细说，因为随后就是本文的重点，亦是组件实现的核心功能：array_reduce 函数！。 其作用本质就是通过用户自定义的方式去将一个数组合并成单一的一个值，因此该函数要求三个参数：待合并的数组、用于合并逻辑的回调函数、初始合并的值（亦或者特殊情境下的最终值），用于合并逻辑的回调须接受两个参数值，分别是上一次处理逻辑处理的结果（第一次不存在处理结果，则默认为空，若设置了array_reduce的第三个参数，则以该参数为初始值）和待处理的数组项。 Pipeline组件恰到好处的使用了它。我们看得到，Pipeline首先将我们用于处理的中间件数组通过array_reverse取相反顺序（至于为什么这么做后面你们就知道了），传递至array_reduce 的第一个参数。第三个参数作为array_reduce认定的默认处理对象，Pipeline用的是先前通过getInitalSlice获取到的（实际上是用户传进来的目标逻辑处理函数）作为值传递。 然后就是本文第二个介绍的重点，array_reduce所接受的第二个参数，通过调用$this-&gt;getSlice()获取的一个匿名函数！ 实现的核心array_reduce的第二个参数要求传递一个回调函数用于处理数组合并，$this-&gt;getSlice()返回的正是这个处理函数，我相信你们一定看到了getSlice返回的值，那么我就将这个匿名函数单独拿出来：1234567891011function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return call_user_func($pipe, $passable, $stack); &#125; // 省略了一部分，该部分是针对中间件 “类”而不是中间件匿名函数的， // 先前例子中我们用的都是以匿名函数作为数组传递进来的，因此只会进入上面那个条件， // 当然Laravel框架中，传递进来的则基本是中间件对象的类名，这段省略的代码， // 和上面那个if中的本质的区别就是，省略的代码中包含了中间件类的实例化过程并调用的是其handle方法而不是直接调用函数，仅此~~ &#125;;&#125;; 我知道大家看到的代码有很多行，但是实际上就只有一行return function() { … };，被执行的也只有它。对于一些初学者，很容易产生一种错觉：那个返回的function会在return前执行。既然是错觉，那就意味着不会被执行，而是作为一个值被返回，可能会被后续某个地方所调用！可能会被后续某个地方所调用！可能会被后续某个地方所调用！这里只是个值！重要的事情说三遍。 虽说会被后面所调用，但我们依旧要在这里提一下这个被返回的匿名函数，在这里，它又有着另一个名称：闭包。闭包是由匿名函数（也成闭包函数）构成的一个整体，和普通的匿名函数有所不同，闭包中一定存在引用了外部数据并在内部操作的情况。 这里需要注意，返回的不仅仅是个匿名函数，更是一个闭包，该闭包中引用了两个外部值，分别是array_reduce提供给第二参数中的回调的两个参数，即数组合并结果和当前待合并的值。 第一次执行时，$stack就是我们的目标处理逻辑代码段，$pipe则是第一个中间件； 第二次执行时，$stack是第一次执行所返回的闭包，$pipe则是第二个中间件，随后以此类推。 最后一次执行，返回的结果仍旧是一个闭包，该闭包中所引用的外部数据是倒数第二次的执行返回的闭包，$pipe是最后一个中间件。随后，该闭包在then方法中被调用，传递进了我们通过send方法传递的值。 上面的描述可能异常抽象，我们让其变得稍微直观一些，我会将所有遍历每一次执行带来的变化体现出来。不过为了方便理解，我需要改一下示例代码，去掉中间的条件判断，因为我们现在重点是理解这个流程而不是其功能，新的代码与执行结果如下：1234567891011121314151617181920212223&lt;?phpuse Illuminate\Pipeline\Pipeline;$pipes = [ function ($poster, $callback) &#123; $poster += 1; return $callback($poster); &#125;, function ($poster, $callback) &#123; $result = $callback($poster); return $result - 1; &#125;, function ($poster, $callback) &#123; $poster += 2; return $callback($poster); &#125;];echo (new Pipeline)-&gt;send(0)-&gt;through($pipes)-&gt;then(function ($poster) &#123; return $poster;&#125;); // 执行输出为 2 上述代码，我们定义了三个中间件，同时我们的目标逻辑代码并没做什么特殊的事情，这样我们就可以专注在执行流程上。下面便于分析，我做了一份伪代码以及等式方便理解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152poster = 0f^0 = f(z)-&gt;&#123; z &#125; // 定义目标处理逻辑f^1 = f(z, y)-&gt;&#123; f^y( z + 1 ) &#125; // 定义中间件 1f^2 = f(z, y)-&gt;&#123; result = f^y(z); result - 1 &#125; // 定义中间件 2f^3 = f(z, y)-&gt;&#123; f^y( z + 2 ) &#125; // 定义中间件 3f^getSlice = f(y, x)-&gt;&#123; f(z)-&gt;&#123; call( f^x(z, y) ) &#125;&#125;callback = array_reduce([f^3, f^2, f^1], f^getSlice, f^0);callback(poster)&gt;&gt;&gt; 执行上述过程exec^1: // 第一次进行 reduce，y 是目标逻辑片段，x 是最后一个中间件，被闭包引用， // 闭包则作为合并结果返回，在此定义为 f^a。 y = f^0(z); x = f^3; f^a = f(z)-&gt;&#123; call( f^x(z, y) ) &#125;exec^2: // 第二次进行，y 是上次处理返回的闭包（即 f^a），x 是第二个中间件，再次生成闭包返回。 y = f^a; x = f^2; f^b = f(z)-&gt;&#123; call( f^x(z, y) ) &#125;exec^3: // 第三次也是最后一次合并，同第二次。现在三个数组项被合并， // 合并结果为最后一次合并所返回的闭包。 y = f^b; x = f^1; f^c = f(z)-&gt;&#123; call( f^x(z, y) ) &#125;exec^4: // 该闭包（最后一次合并结果）返回后，被调用，第一个参数为 z = poster = 1，开始执行。 // 该闭包的 z 参数即为 1，其余如 x、y 值见 exec^3。 call( f^c(0) ) = call( f^1(0, f^b) )exec^5: // 继续等式替换 call( f^b(0 + 1) ) = call( f^2(0 + 1, f^a) )exec^6: // 根据上已执行过程返回结果，已执行至中间件 2 的回调，继续等式替换 result = f^a(0 + 1); result - 1exec^7: result = call( f^3(0 + 1 , f^0) ); result - 1exec^8: result = call( f^0(0 + 1 + 2) ); result - 1exec^9: result = 3; result - 1// 处理结果result: 2 分析根据伪代码，和执行过程，我们能了解到先前通过array_reverse反序排列的中间件，由于在本文中，此处闭包逆向传递下去的特性（因为所引用的外部参数中，是前一执行结果所返回的闭包），实际上依旧是按顺序执行的，我们在这里也看到了如何利用该特性，实现前置和后置调用的原理以及拦截的原理。 前置调用时，先处理自上传递下来的结果，随后调用下一个（由中间件构成的）闭包。后置调用时，先调用下一个（有中间件构成的）闭包，里面仍旧可能无数的引用，直到其中的目标处理逻辑，最终返回结果，再处理。 拦截的原理就更简单了，由于拦截只存在于前置中间件，而前置中间件是先处理，然后调用传递进来的闭包并返回其值，而若这个值不是来自于一个闭包调用的结果，就意味着肯定中间不存在调用关系，也就根本不会执行到闭包中的下一个中间件。 总结以上就是整个Pipeline以及中间件的实现，我知道很多人依旧十分纠结，内心充满困惑。我仍旧建议老老实实，从 array_reduce 这个函数的实际功能着手，然后把每一步执行过程，写下来，慢慢的就明白了。这篇文章不仅仅只是Laravel组件的一个讲解，更多是从中发现PHP的一些基础概念和知识，要知道在强大的PHP框架也是用PHP写出的，本质上仍旧是在一个大的基础上构建的小世界而已。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Pipeline]]></title>
    <url>%2F2020%2F04%2F05%2FLaravel-Pipeline%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 责任链模式是什么样子的？属于什么类型模式？ array_reduce的第一个参数数组是闭包函数集合，第三个参数是闭包。怎么理解？ 为什么要用array_reverse反转闭包集合？ Laravel中管道设计模式的使用——中间件实现原理探究管道模式可以看作责任链模式的一种具体实现。 所谓管道（Pipeline）设计模式就是将数据传递到一个任务序列中，管道扮演着流水线的角色，数据在这里被处理然后传递到下一个步骤。 使用管道有很多好处，尤其是在单个任务中编写复杂处理代码时管道为我们提供了极大的便利，而且可以在管道中轻松添加、移除或者替换阶段任务。 Laravel在框架中的很多地方用到了Pipeline设计模式，这意味着所有我们需要实现管道设计模式的地方已然是应用底层的一部分了。 我们可以使用Laravel的内部组件在框架顶层构建自己的功能。今天的教程我们将讨论管道设计模式以及如何使用Laravel的内部管道。 什么是管道设计模式管道模式用于将复杂的进程分解成多个独立的子任务。每个独立的任务都是可复用的，因此这些任务可以被组合成复杂的进程。 这种模式允许你将庞大的进程分解成更小的子任务，这些子任务将数据进行处理并将处理后的结果传递给下一个子任务。就像流水线一样，有条不紊，从原料加工到成品，实现一道完整的工序。 管道中的每一个任务都会接受并返回同一类型的数据，这样子任务可以在管道中被添加、移除或者替换，而不影响其它子任务。 如果你熟悉Unix系统的话，你可能对管道并不陌生，因为在shell命令中我们经常会使用管道命令，例如： 1cat helloworld.txt | grep "hello world" | rev | &gt; output.txt 在这个例子中，我们读取文件内容，并在其中查询字符串“hello world”，反转字符串，并最终将其添加到output.txt文件中。 如何使用管道模式Laravel在框架中的很多地方使用了管道设计模式，最常见的就是中间件的实现。 当请求最终到达控制器动作被处理前，会先经过一系列的中间件。每个中间件都有一个独立的职责，例如，设置Cookie、判断是否登录以及阻止CSRF攻击等等。 每个阶段都会对请求进行处理，如果请求通过就会被传递给下一个处理，不通过就会返回相应的HTTP响应。 这种机制使得我们很容易在请求最终到达应用代码前添加处理操作，当然如果不需要这个处理操作你也可以随时移除而不影响请求的生命周期。 管道模式的优点管道模式有很多优点： 首先，将复杂的处理流程分解成独立的子任务，从而方便测试每个子任务； 其次，被分解的子任务可以被不同的处理进程复用，避免代码冗余； 最后，在复杂进程中添加、移除和替换子任务非常轻松，对已存在的进程没有任何影响。 管道模式的缺点当然，管道模式也有缺点： 虽然每个子任务变得简单了，但是当你再度尝试将这些子任务组合成完整进程时有一定复杂性； 此外你还需要保证独立子任务测试通过后整体的流程能正常工作，这有一定的不确定性； 最后，当你看到的都是一个个子任务时，对理解整体流程带来困难（盲人摸象的故事想必大家很熟悉，正是此理）。 如何使用Laravel的管道使用Laravel提供的管道很简单，首先需要创建一个新的Illuminate\Pipeline\Pipeline对象，并将其注入到某个Illuminate\Contracts\Container\Container的实例： 1$pipeline = app('Illuminate\Pipeline\Pipeline'); 接下来将你想要传递的对象发送这个管道：1$pipeline-&gt;send($request); 然后将其传递到接受并处理请求的任务数组：1$pipeline-&gt;through($middleware); 最后运行管道任务并编写回调处理：123$pipeline-&gt;then(function ($request) &#123; // Do something&#125;); 这就是中间件的基本工作原理：接收HTTP请求，让请求经过定义好的路由中间件，最后到达目的地进行处理。 结论管道设计模式很有用，中间件只是一个特别的例子，Laravel在框架底层中充分利用了该设计模式，当然你也可以在自己的项目中使用Laravel提供的管道。 Laravel管道流原理Laravel管道流原理强烈依赖array_reduce函数，我们先来了解下array_reduce函数的使用。 array_reducearray_reduce()将回调函数callback迭代地作用到array数组中的每一个单元中，从而将数组简化为单一的值。 1mixed array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] ) 1.array 输入的array。 2.callback 1mixed callback ( mixed $carry , mixed $item ) $carry包括上次迭代的值，如果本次迭代是第一次，那么这个值是initial，item携带了本次迭代的值 3.initial 如果指定了可选参数initial，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。 从文档说明可以看出，array_reduce函数是把数组的每一项，都通过给定的callback函数来简化的。 那我们就来看看是怎么简化的。 12345$arr = ['AAAA', 'BBBB', 'CCCC'];$res = array_reduce($arr, function($carry, $item)&#123; return $carry . $item;&#125;); 给定的数组长度为3，故总迭代三次。 第一次迭代时$carry=null，$item=AAAA返回AAAA第二次迭代时$carry=AAAA，$item=BBBB返回AAAABBBB第三次迭代时$carry=AAAABBBB，$item=CCCC返回AAAABBBBCCCC 这种方式将数组简化为一串字符串AAAABBBBCCCC 带初始值的情况12345$arr = ['AAAA', 'BBBB', 'CCCC'];$res = array_reduce($arr, function($carry, $item)&#123; return $carry . $item;&#125;, 'INITIAL-'); 第一次迭代时（$carry = INITIAL-），（$item = AAAA）返回INITIAL-AAAA第二次迭代时（$carry = INITIAL-AAAA），（$item = BBBB）， 返回INITIAL-AAAABBBB第三次迭代时（$carry = INITIAL-AAAABBBB），（$item = CCCC），返回INITIAL-AAAABBBBCCCC 这种方式将数组简化为一串字符串INITIAL-AAAABBBBCCCC 闭包12345678$arr = ['AAAA', 'BBBB', 'CCCC'];// 没带初始值$res = array_reduce($arr, function($carry, $item)&#123; return function() use ($item)&#123; // 这里只use了item return strtolower($item) . '-'; &#125;;&#125;); 第一次迭代时，$carry：null，$item=AAAA，返回一个use了$item=AAAA的闭包第二次迭代时，$carry：use了$item=AAAA的闭包，$item=BBBB，返回一个use了$item=BBBB的闭包第三次迭代时，$carry：use了$item=BBBB的闭包，$item=CCCC，返回一个use了$item=CCCC的闭包 这种方式将数组简化为一个闭包，即最后返回的闭包，当我们执行这个闭包时$res()得到返回值CCCC- 上面这种方式只use($item)，每次迭代返回的闭包在下次迭代时，我们都没有用起来。只是又重新返回了一个use了当前item值的闭包。 闭包USE闭包123456789$arr = ['AAAA'];$res = array_reduce($arr, function($carry, $item)&#123; return function () use ($carry, $item) &#123; if (is_null($carry)) &#123; return 'Carry IS NULL' . $item; &#125; &#125;;&#125;); 注意，此时的数组长度为1，并且没有指定初始值。 由于数组长度为1，故只迭代一次，返回一个use($carry = null, $item = ‘AAAA’)的闭包，当我们执行$res()这个闭包时，得到的结果为Carry IS NULLAAAA。 接下来我们重新改造下：123456789101112$arr = ['AAAA', 'BBBB'];$res = array_reduce($arr, function($carry, $item)&#123; return function () use ($carry, $item) &#123; if (is_null($carry)) &#123; return 'Carry IS NULL' . $item; &#125; if ($carry instanceof \Closure) &#123; return $carry() . $item; &#125; &#125;;&#125;); 我们新增了一个条件判断，若当前迭代的值是一个闭包，返回该闭包的执行结果。 第一次迭代时，$carry的值为null，$item的值为AAAA，返回一个闭包。123456789// 伪代码function () use ($carry = null, $item = AAAA) &#123; if (is_null($carry)) &#123; return 'Carry IS NULL' . $item; &#125; if ($carry instanceof \Closure) &#123; return $carry() . $item; &#125;&#125; 假设我们直接执行该闭包，将会返回Carry IS NULLAAAA的结果。 第二次迭代时，$carry的值为上述返回的闭包（伪代码），$item的值为BBBB，返回一个闭包，当我们执行这个闭包时，满足$carry instanceof \Closure，得到结果Carry IS NULLAAAABBBB。 Laravel中的array_reverse大致了解了array_reverse函数的使用后，我们来瞅瞅laravel管道流里使用array_reverse的情况。 php内置方法array_reduce把所有要通过的中间件都通过callback方法并压缩为一个Closure。最后再执行Initial。 Laravel中通过全局中间件的核心代码如下：12345678910111213141516// Illuminate\Foundation\Http\Kernel.phpprotected function sendRequestThroughRouter($request)&#123; return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125;protected function dispatchToRouter()&#123; return function ($request) &#123; $this-&gt;app-&gt;instance('request', $request); return $this-&gt;router-&gt;dispatch($request); &#125;;&#125; 正如我前面说的，我们发送一个$request对象通过middleware中间件数组，最后再执行dispatchToRouter方法。 假设有两个全局中间件，我们来看看这两个中间件是如何通过管道压缩为一个Closure的。12Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,App\Http\Middleware\AllowOrigin::class, // 自定义中间件 Illuminate\Pipeline\Pipeline为laravel的管道流核心类。 在Illuminate\Pipeline\Pipeline的then方法中，$destination为上述的dispatchToRouter闭包，pipes为要通过的中间件数组，passable为Request对象。1234567public function then(Closure $destination)&#123; $pipeline = array_reduce( array_reverse($this-&gt;pipes), $this-&gt;carry(), $this-&gt;prepareDestination($destination) ); return $pipeline($this-&gt;passable);&#125; array_reverse函数将中间件数组的每一项都通过$this-&gt;carry()，初始值为上述dispatchToRouter 方法返回的闭包。12345678910111213141516171819202122232425protected function prepareDestination(Closure $destination)&#123; return function ($passable) use ($destination) &#123; return $destination($passable); &#125;;&#125;protected function carry()&#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; //解析中间件参数 list($name, $parameters) = $this-&gt;parsePipeString($pipe); $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; $parameters = [$passable, $stack]; &#125; return $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters); &#125;; &#125;;&#125; 第一次迭代时，返回一个闭包，use了$stack和$pipe，$stack的值为初始值闭包，$pipe为中间件类名，此处是App\Http\Middleware\AllowOrigin::class（注意array_reverse函数把传进来的中间件数组倒叙了）。 假设我们直接运行该闭包，由于此时$pipe是一个String类型的中间件类名，只满足!is_object($pipe)这个条件，我们将直接从容器中make一个该中间件的实例出来，在执行该中间件实例的handle方法（默认$this-&gt;method为handle）。并且将request对象和初始值作为参数，传给这个中间件。1234public function handle($request, Closure $next)&#123; //......&#125; 在这个中间件的handle方法中，当我们直接执行return $next($request)时，相当于我们开始执行array_reduce函数的初始值闭包了，即上述的dispatchToRouter方法返回的闭包。1234567protected function dispatchToRouter()&#123; return function ($request) &#123; $this-&gt;app-&gt;instance('request', $request); return $this-&gt;router-&gt;dispatch($request); &#125;;&#125; 好，假设结束。在第二次迭代时，也返回一个use了$stack和$pipe的闭包，$stack的值为我们第一次迭代时返回的闭包，$pipe 为中间件类名，此处是Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class。 两次迭代结束，回到then方法中，我们手动执行了第二次迭代返回的闭包。1return $pipeline($this-&gt;passable); 当执行第二次迭代返回的闭包时，当前闭包use的$pipe为Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class，同样只满足!is_object($pipe)这个条件，我们将会从容器中make出CheckForMaintenanceMode中间件的实例，在执行该实例的handle方法，并且把第一次迭代返回的闭包作为参数传到handle方法中。 当我们在CheckForMaintenanceMode中间件的handle方法中执行return $next($request)时，此时的$next为我们第一次迭代返回的闭包，将回到我们刚才假设的流程那样。从容器中make 一个App\Http\Middleware\AllowOrigin实例，在执行该实例的handle方法，并把初始值闭包作为参数传到AllowOrigin中间件的handle方法中。当我们再在AllowOrigin中间件中执行return $next($request)时，代表我们所有中间件都通过完成了，接下来开始执行dispatchToRouter。 1.中间件是区分先后顺序的，从这里你应该能明白为什么要把中间件用array_reverse倒叙了。 2.并不是所有中间件在运行前都已经实例化了的，用到的时候才去向容器取。 3.中间件不执行$next($request)后续所有中间件无法执行。 Pipeline Illuminate\Contracts\Pipeline\Hub.php 123456789101112131415&lt;?phpnamespace Illuminate\Contracts\Pipeline;interface Hub&#123; /** * Send an object through one of the available pipelines. * * @param mixed $object * @param string|null $pipeline * @return mixed */ public function pipe($object, $pipeline = null);&#125; Illuminate\Contracts\Pipeline\Pipeline.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Illuminate\Contracts\Pipeline;use Closure;interface Pipeline&#123; /** * Set the traveler object being sent on the pipeline. * * @param mixed $traveler * @return $this */ public function send($traveler); /** * Set the stops of the pipeline. * * @param dynamic|array $stops * @return $this */ public function through($stops); /** * Set the method to call on the stops. * * @param string $method * @return $this */ public function via($method); /** * Run the pipeline with a final destination callback. * * @param \Closure $destination * @return mixed */ public function then(Closure $destination);&#125; Illuminate\Pipeline\PipelineServiceProvider.php 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace Illuminate\Pipeline;use Illuminate\Contracts\Pipeline\Hub as PipelineHubContract;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\ServiceProvider;class PipelineServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton( PipelineHubContract::class, Hub::class ); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [ PipelineHubContract::class, ]; &#125;&#125; Illuminate\Pipeline\Pipeline.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244namespace Illuminate\Pipeline;use Closure;use Illuminate\Contracts\Container\Container;use Illuminate\Contracts\Pipeline\Pipeline as PipelineContract;use RuntimeException;use Throwable;class Pipeline implements PipelineContract&#123; /** * The container implementation. * * @var \Illuminate\Contracts\Container\Container */ protected $container; /** * The object being passed through the pipeline. * * @var mixed */ protected $passable; /** * The array of class pipes. * * @var array */ protected $pipes = []; /** * The method to call on each pipe. * * @var string */ protected $method = 'handle'; /** * Create a new class instance. * * @param \Illuminate\Contracts\Container\Container|null $container * @return void */ public function __construct(Container $container = null) &#123; $this-&gt;container = $container; &#125; /** * Set the object being sent through the pipeline. * * @param mixed $passable * @return $this */ public function send($passable) &#123; $this-&gt;passable = $passable; return $this; &#125; /** * Set the array of pipes. * * @param array|mixed $pipes * @return $this */ public function through($pipes) &#123; $this-&gt;pipes = is_array($pipes) ? $pipes : func_get_args(); return $this; &#125; /** * Set the method to call on the pipes. * * @param string $method * @return $this */ public function via($method) &#123; $this-&gt;method = $method; return $this; &#125; /** * Run the pipeline with a final destination callback. * * @param \Closure $destination * @return mixed */ public function then(Closure $destination) &#123; $pipeline = array_reduce( array_reverse($this-&gt;pipes()), $this-&gt;carry(), $this-&gt;prepareDestination($destination) ); return $pipeline($this-&gt;passable); &#125; /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() &#123; return $this-&gt;then(function ($passable)&#123; return $passable; &#125;); &#125; /** * Get the final piece of the Closure onion. * * @param \Closure $destination * @return \Closure */ protected function prepareDestination(Closure $destination) &#123; return function ($passable) use ($destination) &#123; try &#123; return $destination($passable); &#125; catch (Throwable $e) &#123; return $this-&gt;handleException($passable, $e); &#125; &#125; &#125; /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() &#123; return function($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; try &#123; if (is_callable($pipe)) &#123; // If the pipe is a callable, then we will call it directly, but otherwise we // will resolve the pipes out of the dependency container and call it with // the appropriate method and arguments, returning the results back out. return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; [$name, $parameters] = $this-&gt;parsePipeString($pipe); // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; &#125; $carry = method_exists($pipe, $this-&gt;method) ? $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters) : $pipe(...$parameters); return $this-&gt;handleCarry($carry); &#125; catch (Throwable $e) &#123; return $this-&gt;handleException($passable, $e); &#125; &#125; &#125; &#125; /** * Parse full pipe string to get name and parameters. * * @param string $pipe * @return array */ protected function parsePipeString($pipe) &#123; [$name, $parameters] = array_pad(explode(':', $pipe, 2), 2, []); if (is_string($parameters)) &#123; $parameters = explode(',', $parameters); &#125; return [$name, $parameters]; &#125; /** * Get the array of configured pipes. * * @return array */ protected function pipes() &#123; return $this-&gt;pipes; &#125; /** * Get the container instance. * * @return \Illuminate\Contracts\Container\Container * * @throws \RuntimeException */ protected function getContainer() &#123; if (! $this-&gt;container) &#123; throw new RuntimeException('A container instance has not been passed to the Pipeline.'); &#125; return $this-&gt;container; &#125; /** * Handle the value returned from each pipe before passing it to the next. * * @param mixed $carry * @return mixed */ protected function handleCarry($carry) &#123; return $carry; &#125; /** * Handle the given exception. * * @param mixed $passable * @param \Throwable $e * @return mixed * * @throws \Throwable */ protected function handleException($passable, Throwable $e) &#123; throw $e; &#125;&#125; 1.管道处理的核心方法then，实际上是一个非常有用的PHP函数array_reduce($array, $callback, $initial)的应用，只不过待处理数组变成了可调用的中间件函数（字符串或closure表示的）； 2.处理函数因为有额外参数$passable（即Request实例）需要传入，所以多包了一层闭包函数【注：关于多层包含的闭包函数，在Python装饰器原理中可以充分理解，尤其是阮一峰的逐步递进写完善的装饰器过程】； 3.初始值也是一个闭包函数，这个是真正的response响应函数。 $this-&gt;method = ‘handle’ 这个方法名，可通过via函数修改。 中间件类方法handle($request, Closure $next)有2个参数，这个对应闭包处理过后的中间件函数的返回值 1return $pipe($passable, $stack)。 Laravel中间件逻辑，是闭包函数强大功能的一大体现。于是我们使用闭包函数，以函数式编程风格实现简化版的中间件流程：12345678910111213141516171819202122232425262728293031function f1($f)&#123; return function($x) use ($f)&#123; echo 'middleware 1 begin.'.PHP_EOL; $x += 1; $x = $f($x); echo 'middleware 1 end.'.PHP_EOL; return $x; &#125;;&#125;function f2($f)&#123; return function($x) use($f)&#123; echo 'middleware 2 begin: '.PHP_EOL; $x += 2; $x = $f($x); echo 'middleware 2 end.'.PHP_EOL; return $x; &#125;;&#125;function respond()&#123; return function($x)&#123; echo 'Generate some response.'.PHP_EOL; return $x; &#125;;&#125;$x = 1;$response = f2(f1(respond()))($x);echo $response; 输出： 123456middleware 2 begin:middleware 1 begin.Generate some response.middleware 1 end.middleware 2 end.4 可以看出为什么Laravel的Pipeline的实现需要反转中间件数组。 高阶函数的实现，可以通过层层传递“函数名字符串”的原始方法来实现，但是通过闭包函数实现更加简单。 array_reduce写法12345678910111213141516171819202122232425262728293031$f1 = function($x, $f)&#123; echo 'middleware 1 begin.'.PHP_EOL; $x += 1; $x = $f($x); echo 'middleware 1 end.'.PHP_EOL; return $x; &#125;;$f2 = function($x, $f)&#123; echo 'middleware 2 begin: '.PHP_EOL; $x += 2; $x = $f($x); echo 'middleware 2 end.'.PHP_EOL; return $x;&#125;;$respond = function($x)&#123; echo 'Generate some response.'.PHP_EOL; return $x;&#125;;$middlewares = [$f1, $f2];$initial = $respond;$foo = array_reduce($middlewares, function($stack, $item)&#123; return function($request) use ($stack, $item)&#123; return $item($request, $stack); &#125;;&#125;, $initial);$x = 1;echo $foo($x); 输出： 12345middleware 2 begin:middleware 1 begin.Generate some response.middleware 1 end.middleware 2 end.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Dispatcher]]></title>
    <url>%2F2020%2F04%2F03%2FLaravel-Dispatcher%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Dispatcher类维护一个$listeners[]数组。$this-&gt;listeners[$event][]=closure;怎么理解？ listen($events,$listener)往$listeners[]数组里写。dispatch();函数执行闭包。怎么理解？ 源码Laravel Event-事件系统的启动与运行源码分析 Illuminate\Contracts\Events\Dispatcher.php 接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?phpnamespace Illuminate\Contracts\Events;interface Dispatcher&#123; /** * Register an event listener with the dispatcher. * * @param string|array $events * @param mixed $listener * @return void */ public function listen($events, $listener); /** * Determine if a given event has listeners. * * @param string $eventName * @return bool */ public function hasListeners($eventName); /** * Register an event subscriber with the dispatcher. * * @param object|string $subscriber * @return void */ public function subscribe($subscriber); /** * Dispatch an event until the first non-null response is returned. * * @param string|object $event * @param mixed $payload * @return array|null */ public function until($event, $payload = []); /** * Dispatch an event and call the listeners. * * @param string|object $event * @param mixed $payload * @param bool $halt * @return array|null */ public function dispatch($event, $payload = [], $halt = false); /** * Register an event and payload to be fired later. * * @param string $event * @param array $payload * @return void */ public function push($event, $payload = []); /** * Flush a set of pushed events. * * @param string $event * @return void */ public function flush($event); /** * Remove a set of listeners from the dispatcher. * * @param string $event * @return void */ public function forget($event); /** * Forget all of the queued listeners. * * @return void */ public function forgetPushed();&#125; Illuminate\Events\Dispatcher.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609&lt;?phpnamespace Illuminate\Events;use Exception;use Illuminate\Container\Container;use Illuminate\Contracts\Broadcasting\Factory as BroadcastFactory;use Illuminate\Contracts\Broadcasting\ShouldBroadcast;use Illuminate\Contracts\Container\Container as ContainerContract;use Illuminate\Contracts\Events\Dispatcher as DispatcherContract;use Illuminate\Contracts\Queue\ShouldQueue;use Illuminate\Support\Arr;use Illuminate\Support\Str;use Illuminate\Support\Traits\Macroable;use ReflectionClass;class Dispatcher implements DispatcherContract&#123; use Macroable; /** * The IoC container instance. * * @var \Illuminate\Contracts\Container\Container */ protected $container; /** * The registered event listeners. * * @var array */ protected $listeners = []; /** * The wildcard listeners. * * @var array */ protected $wildcards = []; /** * The cached wildcard listeners. * * @var array */ protected $wildcardsCache = []; /** * The queue resolver instance. * * @var callable */ protected $queueResolver; /** * Create a new event dispatcher instance. * * @param \Illuminate\Contracts\Container\Container|null $container * @return void */ public function __construct(ContainerContract $container = null) &#123; $this-&gt;container = $container ?: new Container; &#125; /** * Register an event listener with the dispatcher. * * @param string|array $events * @param \Closure|string $listener * @return void */ public function listen($events, $listener) &#123; foreach ((array) $events as $event) &#123; if (Str::contains($event, '*')) &#123; $this-&gt;setupWildcardListen($event, $listener); &#125; else &#123; $this-&gt;listeners[$event][] = $this-&gt;makeListener($listener); &#125; &#125; &#125; /** * Setup a wildcard listener callback. * * @param string $event * @param \Closure|string $listener * @return void */ protected function setupWildcardListen($event, $listener) &#123; $this-&gt;wildcards[$event][] = $this-&gt;makeListener($listener, true); $this-&gt;wildcardsCache = []; &#125; /** * Determine if a given event has listeners. * * @param string $eventName * @return bool */ public function hasListeners($eventName) &#123; return isset($this-&gt;listeners[$eventName]) || isset($this-&gt;wildcards[$eventName]) || $this-&gt;hasWildcardListeners($eventName); &#125; /** * Determine if the given event has any wildcard listeners. * * @param string $eventName * @return bool */ public function hasWildcardListeners($eventName) &#123; foreach ($this-&gt;wildcards as $key =&gt; $listeners) &#123; if (Str::is($key, $eventName)) &#123; return true; &#125; &#125; return false; &#125; /** * Register an event and payload to be fired later. * * @param string $event * @param array $payload * @return void */ public function push($event, $payload = []) &#123; $this-&gt;listen($event.'_pushed', function () use ($event, $payload) &#123; $this-&gt;dispatch($event, $payload); &#125;); &#125; /** * Flush a set of pushed events. * * @param string $event * @return void */ public function flush($event) &#123; $this-&gt;dispatch($event.'_pushed'); &#125; /** * Register an event subscriber with the dispatcher. * * @param object|string $subscriber * @return void */ public function subscribe($subscriber) &#123; $subscriber = $this-&gt;resolveSubscriber($subscriber); $events = $subscriber-&gt;subscribe($this); if (is_array($events)) &#123; foreach ($events as $event =&gt; $listeners) &#123; foreach ($listeners as $listener) &#123; $this-&gt;listen($event, $listener); &#125; &#125; &#125; &#125; /** * Resolve the subscriber instance. * * @param object|string $subscriber * @return mixed */ protected function resolveSubscriber($subscriber) &#123; if (is_string($subscriber)) &#123; return $this-&gt;container-&gt;make($subscriber); &#125; return $subscriber; &#125; /** * Fire an event until the first non-null response is returned. * * @param string|object $event * @param mixed $payload * @return array|null */ public function until($event, $payload = []) &#123; return $this-&gt;dispatch($event, $payload, true); &#125; /** * Fire an event and call the listeners. * * @param string|object $event * @param mixed $payload * @param bool $halt * @return array|null */ public function dispatch($event, $payload = [], $halt = false) &#123; // When the given "event" is actually an object we will assume it is an event // object and use the class as the event name and this event itself as the // payload to the handler, which makes object based events quite simple. [$event, $payload] = $this-&gt;parseEventAndPayload( $event, $payload ); if ($this-&gt;shouldBroadcast($payload)) &#123; $this-&gt;broadcastEvent($payload[0]); &#125; $responses = []; foreach ($this-&gt;getListeners($event) as $listener) &#123; $response = $listener($event, $payload); // If a response is returned from the listener and event halting is enabled // we will just return this response, and not call the rest of the event // listeners. Otherwise we will add the response on the response list. if ($halt &amp;&amp; ! is_null($response)) &#123; return $response; &#125; // If a boolean false is returned from a listener, we will stop propagating // the event to any further listeners down in the chain, else we keep on // looping through the listeners and firing every one in our sequence. if ($response === false) &#123; break; &#125; $responses[] = $response; &#125; return $halt ? null : $responses; &#125; /** * Parse the given event and payload and prepare them for dispatching. * * @param mixed $event * @param mixed $payload * @return array */ protected function parseEventAndPayload($event, $payload) &#123; if (is_object($event)) &#123; [$payload, $event] = [[$event], get_class($event)]; &#125; return [$event, Arr::wrap($payload)]; &#125; /** * Determine if the payload has a broadcastable event. * * @param array $payload * @return bool */ protected function shouldBroadcast(array $payload) &#123; return isset($payload[0]) &amp;&amp; $payload[0] instanceof ShouldBroadcast &amp;&amp; $this-&gt;broadcastWhen($payload[0]); &#125; /** * Check if event should be broadcasted by condition. * * @param mixed $event * @return bool */ protected function broadcastWhen($event) &#123; return method_exists($event, 'broadcastWhen') ? $event-&gt;broadcastWhen() : true; &#125; /** * Broadcast the given event class. * * @param \Illuminate\Contracts\Broadcasting\ShouldBroadcast $event * @return void */ protected function broadcastEvent($event) &#123; $this-&gt;container-&gt;make(BroadcastFactory::class)-&gt;queue($event); &#125; /** * Get all of the listeners for a given event name. * * @param string $eventName * @return array */ public function getListeners($eventName) &#123; $listeners = $this-&gt;listeners[$eventName] ?? []; $listeners = array_merge( $listeners, $this-&gt;wildcardsCache[$eventName] ?? $this-&gt;getWildcardListeners($eventName) ); return class_exists($eventName, false) ? $this-&gt;addInterfaceListeners($eventName, $listeners) : $listeners; &#125; /** * Get the wildcard listeners for the event. * * @param string $eventName * @return array */ protected function getWildcardListeners($eventName) &#123; $wildcards = []; foreach ($this-&gt;wildcards as $key =&gt; $listeners) &#123; if (Str::is($key, $eventName)) &#123; $wildcards = array_merge($wildcards, $listeners); &#125; &#125; return $this-&gt;wildcardsCache[$eventName] = $wildcards; &#125; /** * Add the listeners for the event's interfaces to the given array. * * @param string $eventName * @param array $listeners * @return array */ protected function addInterfaceListeners($eventName, array $listeners = []) &#123; foreach (class_implements($eventName) as $interface) &#123; if (isset($this-&gt;listeners[$interface])) &#123; foreach ($this-&gt;listeners[$interface] as $names) &#123; $listeners = array_merge($listeners, (array) $names); &#125; &#125; &#125; return $listeners; &#125; /** * Register an event listener with the dispatcher. * * @param \Closure|string $listener * @param bool $wildcard * @return \Closure */ public function makeListener($listener, $wildcard = false) &#123; if (is_string($listener)) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; if (is_array($listener) &amp;&amp; isset($listener[0]) &amp;&amp; is_string($listener[0])) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return $listener($event, $payload); &#125; return $listener(...array_values($payload)); &#125;; &#125; /** * Create a class based listener using the IoC container. * * @param string $listener * @param bool $wildcard * @return \Closure */ public function createClassListener($listener, $wildcard = false) &#123; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return call_user_func($this-&gt;createClassCallable($listener), $event, $payload); &#125; return call_user_func_array( $this-&gt;createClassCallable($listener), $payload ); &#125;; &#125; /** * Create the class based event callable. * * @param array|string $listener * @return callable */ protected function createClassCallable($listener) &#123; [$class, $method] = is_array($listener) ? $listener : $this-&gt;parseClassCallable($listener); if ($this-&gt;handlerShouldBeQueued($class)) &#123; return $this-&gt;createQueuedHandlerCallable($class, $method); &#125; return [$this-&gt;container-&gt;make($class), $method]; &#125; /** * Parse the class listener into class and method. * * @param string $listener * @return array */ protected function parseClassCallable($listener) &#123; return Str::parseCallback($listener, 'handle'); &#125; /** * Determine if the event handler class should be queued. * * @param string $class * @return bool */ protected function handlerShouldBeQueued($class) &#123; try &#123; return (new ReflectionClass($class))-&gt;implementsInterface( ShouldQueue::class ); &#125; catch (Exception $e) &#123; return false; &#125; &#125; /** * Create a callable for putting an event handler on the queue. * * @param string $class * @param string $method * @return \Closure */ protected function createQueuedHandlerCallable($class, $method) &#123; return function () use ($class, $method) &#123; $arguments = array_map(function ($a) &#123; return is_object($a) ? clone $a : $a; &#125;, func_get_args()); if ($this-&gt;handlerWantsToBeQueued($class, $arguments)) &#123; $this-&gt;queueHandler($class, $method, $arguments); &#125; &#125;; &#125; /** * Determine if the event handler wants to be queued. * * @param string $class * @param array $arguments * @return bool */ protected function handlerWantsToBeQueued($class, $arguments) &#123; $instance = $this-&gt;container-&gt;make($class); if (method_exists($instance, 'shouldQueue')) &#123; return $instance-&gt;shouldQueue($arguments[0]); &#125; return true; &#125; /** * Queue the handler class. * * @param string $class * @param string $method * @param array $arguments * @return void */ protected function queueHandler($class, $method, $arguments) &#123; [$listener, $job] = $this-&gt;createListenerAndJob($class, $method, $arguments); $connection = $this-&gt;resolveQueue()-&gt;connection( $listener-&gt;connection ?? null ); $queue = method_exists($listener, 'viaQueue') ? $listener-&gt;viaQueue() : $listener-&gt;queue ?? null; isset($listener-&gt;delay) ? $connection-&gt;laterOn($queue, $listener-&gt;delay, $job) : $connection-&gt;pushOn($queue, $job); &#125; /** * Create the listener and job for a queued listener. * * @param string $class * @param string $method * @param array $arguments * @return array */ protected function createListenerAndJob($class, $method, $arguments) &#123; $listener = (new ReflectionClass($class))-&gt;newInstanceWithoutConstructor(); return [$listener, $this-&gt;propagateListenerOptions( $listener, new CallQueuedListener($class, $method, $arguments) )]; &#125; /** * Propagate listener options to the job. * * @param mixed $listener * @param mixed $job * @return mixed */ protected function propagateListenerOptions($listener, $job) &#123; return tap($job, function ($job) use ($listener) &#123; $job-&gt;tries = $listener-&gt;tries ?? null; $job-&gt;retryAfter = method_exists($listener, 'retryAfter') ? $listener-&gt;retryAfter() : ($listener-&gt;retryAfter ?? null); $job-&gt;timeout = $listener-&gt;timeout ?? null; $job-&gt;timeoutAt = method_exists($listener, 'retryUntil') ? $listener-&gt;retryUntil() : null; &#125;); &#125; /** * Remove a set of listeners from the dispatcher. * * @param string $event * @return void */ public function forget($event) &#123; if (Str::contains($event, '*')) &#123; unset($this-&gt;wildcards[$event]); &#125; else &#123; unset($this-&gt;listeners[$event]); &#125; foreach ($this-&gt;wildcardsCache as $key =&gt; $listeners) &#123; if (Str::is($event, $key)) &#123; unset($this-&gt;wildcardsCache[$key]); &#125; &#125; &#125; /** * Forget all of the pushed listeners. * * @return void */ public function forgetPushed() &#123; foreach ($this-&gt;listeners as $key =&gt; $value) &#123; if (Str::endsWith($key, '_pushed')) &#123; $this-&gt;forget($key); &#125; &#125; &#125; /** * Get the queue implementation from the resolver. * * @return \Illuminate\Contracts\Queue\Queue */ protected function resolveQueue() &#123; return call_user_func($this-&gt;queueResolver); &#125; /** * Set the queue resolver implementation. * * @param callable $resolver * @return $this */ public function setQueueResolver(callable $resolver) &#123; $this-&gt;queueResolver = $resolver; return $this; &#125;&#125; Illuminate\Events\EventServiceProvider.php 1234567891011121314151617181920212223&lt;?phpnamespace Illuminate\Events;use Illuminate\Contracts\Queue\Factory as QueueFactoryContract;use Illuminate\Support\ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('events', function ($app) &#123; return (new Dispatcher($app))-&gt;setQueueResolver(function () use ($app) &#123; return $app-&gt;make(QueueFactoryContract::class); &#125;); &#125;); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实现反转链表]]></title>
    <url>%2F2020%2F04%2F02%2FPHP%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能应用的策略]]></title>
    <url>%2F2020%2F04%2F02%2F%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%94%E7%94%A8%E7%9A%84%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Listing 5-1 manual.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php$time1 = microtime(true);$memory1 = memory_get_usage();$a_string = (function () &#123; $output = ''; for ($counter = 0; $counter &lt; 10; $counter++) &#123; usleep(10); $output .= 'a'; &#125;; return $output;&#125;)(); $memory2 = memory_get_usage();$time2 = microtime(true);$b_string = (function () &#123; $output = ''; for ($counter = 0; $counter &lt; 10; $counter++) &#123; usleep(100); $output .= str_repeat('abc',1000); &#125;; return $output;&#125;)(); $memory3 = memory_get_usage();$time3 = microtime(true);echo "1st function : ".($time2-$time1)." secs, ". ($memory2-$memory1)." bytes\n";echo "2nd function : ".($time3-$time2)." secs, ". ($memory3-$memory2)." bytes\n";echo ("Peak memory usage : ". memory_get_peak_usage()." bytes\n"); Listing 5-2 manual-output.txt 1231st function : 0.0007178783416748 secs, 40 bytes2nd function : 0.0016269683837891 secs, 32768 bytesPeak memory usage : 392504 bytes 如您所见，第二个函数比第一个函数需要更长的时间。现在，您知道使脚本变慢的问题是第二个循环，您可以通过删除usleep语句并完全删除该循环并使用str_repeat(‘abc’，1000000)填充字符串来解决此问题。 记忆化如果您已经编程了一段时间，尤其是在Web领域，那么您将遇到缓存的概念。缓存是一个过程，通过该过程，您可以获取“昂贵的”计算结果，存储结果，然后在下次调用该计算时使用存储的结果，而不必再次运行计算本身。昂贵意味着运行时间长，占用大量内存，进行大量外部API调用或出于成本或性能原因而希望将其最小化的任何其他操作。缓存失效是您选择从缓存中删除项目的过程。例如，如果要花费很多精力来生成新闻网站的首页，则需要缓存该页面，这样就不必在每次访问者访问网站时都生成它。但是，一旦发生下一个重大故事，您将要更新首页，并且您不希望访问者点击缓存的版本并获取旧消息，因此您将使缓存“无效”并重新生成页面。如果您曾经参与编写或使用缓存系统，那么毫无疑问，您会根据Phil Karlton的说法熟悉以下说法（或至少了解它的来历）： 在计算机科学中，只有两件困难的事情：命名事物，缓存无效化和一次性错误。 您已经研究了递归如何减少一次性错误，并且没有人希望解决命名问题，那么如何解决缓存失效呢？举起手来，如果你认为函数编程有其窍门。好，金星为您服务！确实如此，诀窍是永远不要使缓存无效。问题解决了！我实际上是认真的。函数式编程提供了一种称为备忘录的技术，该技术植根于纯函数固有的属性中。在较早的理论章节中，您研究了纯函数如何具有参照透明性。给定一组特定的输入参数，纯函数将始终产生相同的返回值，并且（对于该组输入）该函数可以简单地由返回值替换。这听起来应该有点像缓存：对于给定的一组输入（例如，您的新闻报道），您想用其返回值（缓存的输出）替换（运行昂贵）功能。获取纯函数的输出并将其缓存的过程是备忘录，这只是缓存的一种特殊情况。假设您正在记忆一个昂贵的功能，并将结果缓存到磁盘。每次使用不同的参数运行该函数时，您可能会得到不同的结果。您要消除的是在同一参数上多次运行该函数的成本，因为每次（纯）函数都可以保证获得相同的结果。因此，您可以缓存结果，例如，通过创建代表所使用输入参数的哈希并将其用作文件名来存储该运行的返回值。下次运行该函数时，将再次对输入参数进行哈希处理，查看是否存在该名称的缓存文件，如果存在则返回其内容（而不是重新运行昂贵的函数）。到目前为止，这是典型的缓存。但是，如何避免不得不使缓存无效？答案是你不知道。记忆有效地为您做到了。您的功能是纯净的，这意味着没有副作用。因此，如果在您的虚构新闻网站上有新故事中断，则该故事的详细信息将仅通过（纯）功能通过该功能的输入参数创建您的首页。例如，您可能将一系列标题作为一个参数。突然，您的参数的哈希值已更改，因此备注函数将无法在具有该哈希值的磁盘上找到文件，因此将运行完整功能并将新结果缓存到以新哈希值命名的文件中的磁盘上值。回顾一下，作为您唯一的输入是参数，如果所有参数均未更改，则必须可以使用缓存。但是，如果参数已更改，则将没有相应的缓存文件，因此无需使其无效。当然，旧的缓存文件仍然存在，因此当您不小心发布错误地声称这本书是垃圾的故事时，您可以立即将其撤回，该功能将返回使用旧的缓存文件，因为哈希将再次出现匹配参数。到现在为止还挺好。但是，函数式编程并没有止于其优点，哦，不。如果您正在考虑如何编写函数来进行记忆，请停止操作。通常，您不需要。您可以简单地将函数包装在另一个为您自动记住的函数中。这样的包装器函数易于编写，因为您所关心的只是纯函数的输入和输出，而不是其内部的功能。因此，让我们来看一个备忘录的示例。在清单5-3中，您会将纯函数的结果缓存到磁盘。为简便起见，将不纯磁盘功能分成单独的功能，而不是煮一些IO monad，但是您当然可以根据需要这样做。 Listing 5-3 memoize.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?php# We're going to cache our results on disk, so let's# define a directory and file prefixdefine('CACHE_PREFIX', sys_get_temp_dir().'/memo-cache-');# This is a helper function to read a cached file# from disk. I've broken it out as a separate function# as it is necessarily impure. You can replace it# with an IO monad or similar in production if you wish$get_value = function($hash) &#123; # return null if the file doesn't exist if (!file_exists(CACHE_PREFIX.$hash)) &#123; return null; &#125; # read the file into $value $value = file_get_contents(CACHE_PREFIX.$hash); # return null if the file exists but couldn't be read if ($value === false) &#123; return null; &#125; # return our value if all is good return $value;&#125;;# Likewise, this is an impure helper function to write# the value to a cache file.$store_value = function($hash, $value) &#123; if (file_put_contents(CACHE_PREFIX.$hash, $value) === false) &#123; $value = null; &#125; # return the value that was stored, or null if the # storage failed return $value;&#125;;# Finally, this is our actual memoization function.# It returns a closure which is a "memoized" version# of the function you call it on, i.e. a version# of your function which automatically caches return# values and automatically uses those cached values# without further coding from you.# $func is the function (closure or other callable) that# you want to memoize$memoize = function($func) use ($get_value, $store_value)&#123; # We're returning a memoized function return function() use ($func, $get_value, $store_value) &#123; # Get the parameters you (the end user) call # your memoized function with $params = func_get_args(); # Get a unique hash of those parameters, to # use as our cache's key. We needs to convert # the params array to a string first, we use # json_encode rather than serialize here as # it is a lot faster in most cases $hash = sha1( json_encode( $params ) ); # Check the cache for any return value that # has already been cached for that particular # set of input parameters (as identified by # its hash) $value = $get_value($hash); # If there was no pre-cached version available, # $value will be null. We check this with the ?? # null coalescing operator, returning either : # a) the cached $value if it's not null, or # b) the results of actually calling the user # function. Note that we wrap the call in the # $store_value function to cache the results, # and $store_value passes the value back # through as its result and so it is also # returned to the user in this case return $value ?? $store_value( $hash, call_user_func_array($func, $params) ); &#125;;&#125;; 首先，您的备忘录功能通过将输入参数编码为JSON来使输入参数具有唯一的字符串表示形式。 例如，如果您想知道为什么不简单使用implode（“ |”，$ params），请考虑以下两个函数调用： 12func("Hello","|There");func("Hello|","There"); 这将导致两者实际上都被编码为Hello || There，因此实际上被视为相同的一组参数。如果可以保证，可以使用带有粘合字符的爆破该字符永远不会出现在您的参数中，但是通常以防万一，最好使用防御性代码并使用适当的序列化功能。您可以使用PHP的serialize（）函数代替json_encode因为在某些工作负载下它可能会更快。两者都具有一些极端的情况，您可能需要在选择一种情况之前就熟悉一下这些情况，例如，serialize（）无法使用某些类型的对象。有关这两者的更多信息，请参见PHP手册。一旦有了输入的字符串表示形式，就需要将其转换为另一个适合用作文件名的字符串。您的JSON字符串可能包含对文件无效的字符名称，因此您将为其创建一个SHA1哈希。 MD5散列的创建速度会稍快一些，但发生散列冲突的可能性更大（对于两个不同的输入会生成相同的散列）。即使SHA1也会发生冲突，尽管风险通常很小。如果您绝对无法解决冲突，那么您将需要编写一些代码来解析序列化的字符串并替换无效字符，依此类推，以一致的方式确保对缓存介质（文件例如，写入磁盘的名称长度）。现在，您有了哈希（或其他描述输入参数的独特方式）。然后，您尝试从缓存中加载以哈希为名称的文件内容。如果您无法读取它（通常是因为它不存在，因为这是您第一次使用这些参数调用），则可以使用call_user_func_array（）运行纯函数，获取其返回值并创建缓存文件，最后返回所获取的值你返回值。如果您可以读取文件，则只需返回内容作为返回值，然后跳过执行该函数。您会注意到这里没有使用任何形式的严格输入。如果您从pure函数返回的值是一个int（例如），那么当您第一次运行pure函数时，您会将其写入磁盘并将int返回给调用者。但是，在随后的运行中，您将缓存文件的内容作为字符串获取并返回，因此返回值为字符串。如果在应用程序中键入很重要，则始终可以将值序列化到磁盘，并在读回时再次将其反序列化。现在让我们看一个如何实际使用此备忘功能的示例。您将使用另一个经典的示例任务，即一种算法来生成斐波那契数列。我正在使用此功能，因为它是一个简短易懂的功能，而且恰好是递归的。记忆可用于任何功能，无论是否具有递归功能，但它通常特别有用，因为如前所述，递归功能通常会占用大量资源。如果您不熟悉斐波那契数列，它是一系列数字，其中前两个（如果从零开始，则为三个）之后的每个数字都是前两个数字的和，因此： 10, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946 and so on… 该算法采用整数n并计算序列中的第n个数字。因此，$fibonacci（7）将返回13（13是上一个序列中的第7个数字，从0开始）。您将创建两个函数：该函数的标准版本和包装在早期$ memoize函数中的一个版本。 通常，您将只创建一个函数并将其包装在$ memoize中。 但是，正如我想演示一个递归调用该记忆版本的递归版本（并将其与未记忆形式进行对比），您将在此处创建两个。 而且对于现代人来说，斐波那契并不是一项特别繁重的任务PC，您将以usleep语句的形式添加一些人为的“费用”，以使每次计算花费的时间更长。 这将说明备忘录对真正长时间运行的功能的影响。 参见清单5-4和清单5-5。 Listing 5-4 memo_example.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php# Get our memoize function and helpersrequire('memoize.php');# Define a plain old recursive fibonacci function$fibonacci = function ($n) use (&amp;$fibonacci) &#123; usleep(100000); # make this time-expensive! return ($n &lt; 2) ? $n : $fibonacci($n - 1) + $fibonacci($n - 2); &#125;;# Define the same fibonacci function again in exactly the# same way (except for the name), but this time wrap the# function body in a call to $memoize to get a memoized version$memo_fibonacci = $memoize( function ($n) use (&amp;$memo_fibonacci) &#123; usleep(100000); return ($n &lt; 2) ? $n : $memo_fibonacci($n - 1) + $memo_fibonacci($n - 2); &#125;);# Let's define a timer function, to time a run of a function,# and return the parameters, results and timings.$timer = function($func, $params) &#123; $start_time = microtime(true); $results = call_user_func_array($func, $params); $time_taken = round(microtime(true) - $start_time, 2); return [ "Param" =&gt; implode($params), "Result" =&gt; $results, "Time" =&gt; $time_taken ];&#125;;# And now let's do a set of runs of both our# ordinary function and it's memoized sister.# I've added an extra * parameter to the# non-memoized runs so that you can spot them# easier in the output (the '*' isn't used# by the fibonacci functions, it's just passed# through to the output of the timer function)print_r( $timer( $fibonacci, [6, '*'] ) );print_r( $timer( $memo_fibonacci, [6] ) );print_r( $timer( $fibonacci, [6, '*'] ) );print_r( $timer( $memo_fibonacci, [6] ) );print_r( $timer( $memo_fibonacci, [10] ) );print_r( $timer( $memo_fibonacci, [11] ) );print_r( $timer( $memo_fibonacci, [8] ) ); Listing 5-5. memo_example-output.txt 123456789101112131415161718192021222324252627282930313233343536373839404142Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.5)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0.7)Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.5)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0)Array( [Param] =&gt; 10 [Result] =&gt; 55 [Time] =&gt; 0.4)Array( [Param] =&gt; 11 [Result] =&gt; 89 [Time] =&gt; 0.1)Array( [Param] =&gt; 8 [Result] =&gt; 21 [Time] =&gt; 0) 如果查看清单5-5中的第一次运行的输出，您会看到标准函数需要2.5秒才能计算出第六个斐波那契数，而备忘录版本仅需0.7秒。当然，它们应该在第一轮操作相同，因为尚未缓存任何内容。好吧，由于您的函数是递归的，因此实际上您每次计算都会多次调用该函数，并且由于已记忆的版本会使用相同的参数多次调用自身，因此将使用缓存。第三次运行表明，下次使用参数6再次调用标准函数仍需要2.5秒，这很明显，因为它不进行缓存。但是，在6上调用记忆版本需要0秒（向下舍入！），因为计算中的每个递归调用都将命中缓存。接下来计算第十个数字，您只需花费0.4秒。这比计算第6个数字要快，因为它们共享一些步骤（每个人都需要计算第1、2、3等个数字），这些步骤已经被缓存了，而第10个数字只需要实际计算第7、8、9和最后10个数字。下一轮进一步展示了这一点。现在，计算第11个数字仅需0.1秒（因为它只有一个未缓存的函数调用），而最后一次计算第8个数字的运行时间为0秒，因为它是从生成第10个数字起已经在缓存中。如果您第二次调用该脚本，则会发现所有使用备注功能的运行都在0秒内完成，因为您的缓存已经存在所有需要的值，因为您已至少一次生成了所有这些值。除非有人改变了数学的基本原理，否则您可以永久保留高速缓存，因为高速缓存的结果对于给定的输入始终是正确的。如果您想知道高速缓存的外观，则运行/ tmp / memo-cache- *可以得到清单5-6的输出。如您所见，有12个文件，这很有意义，因为您计算了第11个斐波那契数（从0开始计数），因此使用12个不同的参数调用了记忆功能。 Listing 5-6. cache_files.txt 123456789101112131415161718192021222324252627282930313233343536::::::::::::::/tmp/memo-cache-10ae24979c5028fa873651bca338152dc04842455::::::::::::::/tmp/memo-cache-1184f5b8d4b6dd08709cf1513f26744167065e0d0::::::::::::::/tmp/memo-cache-1fb0856518ee0490ff78e43d1b6dae12ad6ec68621::::::::::::::/tmp/memo-cache-2499831338ca5dc8c44f3d063e076799bea9bdff1::::::::::::::/tmp/memo-cache-3ad009a144b1e8e065a75ca775c76b2fc2e5ff7689::::::::::::::/tmp/memo-cache-4a0a63ce33cc030f270c607ea7bf90a6717572bb8::::::::::::::/tmp/memo-cache-7a60554107407bfe358bedce2bfcb95c90a8ea0d34::::::::::::::/tmp/memo-cache-8f4e345e7cd51e4e633816f5a52a47df465da1893::::::::::::::/tmp/memo-cache-bd703dc0b11593277a5a82dd893f2880b8d0f32a13::::::::::::::/tmp/memo-cache-e9310b0c165be166c43d717718981dd6c9379fbe55::::::::::::::/tmp/memo-cache-f1e31df9806ce94c5bdbbfff9608324930f4d3f12::::::::::::::/tmp/memo-cache-f629ae44b7b3dcfed444d363e626edf411ec69a81 在这些示例中，您缓存到了磁盘，这使您可以创建持久的缓存，该缓存可以在重新启动后幸存下来并由多个进程使用。 但是，有时磁盘速度太慢，并且如果您的函数参数经常更改，您可能只想在单个脚本运行期间进行缓存。 另一种方法是在内存中缓存，实际上PHP提供了一种创建变量的方法，这些变量的作用类似于全局变量，但仅限于给定的函数，非常适合在脚本的一次运行中进行缓存。 这些称为静态变量，如果您不熟悉它们，清单5-7（和清单5-8）是静态变量（$ sta）与全局参数（$ glo），参数（$ 参数）和普通函数作用域（$ nor）变量。 Listing 5-7. static.php 123456789101112131415161718192021222324&lt;?php$my_func = function ($par) &#123; static $sta; global $glo; var_dump( "static : ". $sta += 1 ); var_dump( "global : ". $glo += 1 ); var_dump( "param : ". $par += 1 ); var_dump( "normal : ". $nor += 1 ); return $sta;&#125;;while ( $my_func(1) &lt; 5) &#123; echo "-----\n"; &#125;;echo "*****\n";var_dump( "static : ". $sta );var_dump( "global : ". $glo );var_dump( "param : ". $par );var_dump( "normal : ". $nor ); Listing 5-8. static-output.txt 1234567891011121314151617181920212223242526272829string(10) &quot;static : 1&quot;string(10) &quot;global : 1&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 2&quot;string(10) &quot;global : 2&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 3&quot;string(10) &quot;global : 3&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 4&quot;string(10) &quot;global : 4&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 5&quot;string(10) &quot;global : 5&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;*****string(9) &quot;static : &quot;string(10) &quot;global : 5&quot;string(9) &quot;param : &quot;string(9) &quot;normal : &quot; 如您所见，即使每次都使用相同的参数（1）调用my_func，每次$sta的值也不同。 因此，尽管您无法从函数外部的任何范围访问它，但通常仍将其视为“副作用”，因为对于函数的任何特定调用，您都无法确定其处于何种状态（在这种情况下， 不知道该函数已被调用多少次）。 那么，如何在功能程序中使用静态变量？ 答案是，小心。 让我们看一个示例（参见清单5-9）。 您将创建备忘录功能的一个版本，该版本使用静态数组来保存缓存而不是写入磁盘。 Listing 5-9. memoize-mem.php 12345678910111213141516&lt;?php$memoize = function($func)&#123; return function() use ($func) &#123; static $cache; $params = func_get_args(); $hash = sha1( json_encode( $params ) ); $cache["$hash"] = $cache["$hash"] ?? call_user_func_array($func, $params); return $cache["$hash"]; &#125;;&#125;; 因此，您放入$ cache数组中的所有内容，然后再从中读取，完全取决于您使用（通过散列）调用函数的参数，而放入其中的则是该函数的值。您对static变量的使用实际上是参照透明的，因此在这种情况下，您不会产生任何潜在的副作用。 如果调用与以前相同的memoize-example.php脚本，但改用此基于内存的备忘录功能，则会得到清单5-10的输出。 Listing 5-10. memo_mem_example-output.txt 123456789101112131415161718192021222324252627282930313233343536373839404142Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.51)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0.7)Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.51)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0)Array( [Param] =&gt; 10 [Result] =&gt; 55 [Time] =&gt; 0.4)Array( [Param] =&gt; 11 [Result] =&gt; 89 [Time] =&gt; 0.1)Array( [Param] =&gt; 8 [Result] =&gt; 21 [Time] =&gt; 0) 如您所见，它的输出与基于文件的示例完全相同。实际上，它的运行速度要快一点，因为您没有在进行磁盘I / O，但是在这里四舍五入到最接近的0.1秒。与基于磁盘的示例相比，唯一的不同之处在于，如果您第二次运行该脚本，您将再次获得此输出（而不是用于记忆调用的全零），因为用于缓存的静态变量为脚本结束时销毁。除了基于磁盘和基于会话的内存缓存之外，还有一种替代方法是普通的RAM磁盘。在Linux类型的系统上，有一个名为tmpfs的文件系统，该文件系统允许您创建和使用存储在其中的文件。内存而不是磁盘。这些虚拟文件的行为和操作类似于磁盘上的普通文件，因此可以像使用普通“磁盘上”文件一样，允许不同的PHP进程读取和写入文件中的缓存数据。 tmpfs带来的好处是双重的。首先，它很快，其次，一切都是暂时的。因为文件保存在内存中，所以没有机械硬盘可以等待，因此I / O非常快。而且由于它们保留在内存中，因此它们只是临时的，如果您尚未删除它们，则在重新启动后会消失。另一个优点是，它们是普通文件，不是特定于PHP的技术，因此可以根据需要从其他软件进行访问。您可以使用与普通文件和流相同的方式来访问tmpfs文件系统上的文件。它们在内存中的事实对您的PHP脚本是透明的。较早的基于文件的示例将与RAM磁盘完美配合。要在Linux上创建tmpfs文件系统，请首先在磁盘上创建一个目录，用于将存储设备“附加”到文件系统。然后将存储设备安装在该位置并开始使用它。清单5-11中的shell脚本（清单5-12中的输出）给出了安装和卸下tmpfs RAM磁盘的示例。 Listing 5-11. ramdisk.sh 1234567#!/usr/bin/env bashmkdir /tmp/myMemoryDrivesudo mount -t tmpfs /mnt/tmpfs /tmp/myMemoryDrivephp -r "file_put_contents('/tmp/myMemoryDrive/test.txt',\"Hello\n\");"cat /tmp/myMemoryDrive/test.txtsudo umount /mnt/tmpfscat /tmp/myMemoryDrive/test.txt Listing 5-12. ramdisk-output.txt 12Hellocat: /tmp/myMemoryDrive/test.txt: No such file or directory 在清单5-11中，您在/ tmp / myMemoryDrive中创建一个目录来附加存储设备，然后将其安装在该目录中。您可以执行一行PHP来演示如何像创建其他任何文件一样创建内存文件，然后将其编入目录，该文件应输出Hello。最后，您卸载了设备并尝试再次保存文件，但是正如您所期望的，文件已经消失了。它永远不会保存到物理磁盘。您可以使用mount命令挂载tmpfs设备，如您每次引导系统或每次使用它们时所显示的那样，也可以将其添加到fstab文件中，以使其在每次系统引导时自动创建。无论以哪种方式安装它，在关闭或重新启动时，请始终记住它及其中的所有文件都会被破坏。由于tmpfs的运行方式与普通文件系统相同，因此您需要确保设置了相关的文件许可权，以允许所有应用程序对其进行访问（或阻止那些不应该使用能够干预）。还请记住，如果系统内存不足，则可能会发生内存交换到磁盘的情况，因此在这种情况下，数据可能会暂时碰到硬盘，在某些情况下，此后可以从磁盘恢复。请始终考虑您选择的任何缓存系统的安全性。如果出于性能原因考虑使用tmpfs代替物理硬盘，则还应记住，现代操作系统（包括现代Linux）可以使用主动内存缓存来访问磁盘。这意味着操作系统透明地将经常读取的基于磁盘的文件缓存到动态分配的未使用的内存中（通常您甚至不知道）以提高明显的物理磁盘性能。在这些情况下，当您从tmpfs内存磁盘读取某些文件并遍历目录树时，可能不会看到预期的性能改进。写磁盘和访问较少的文件通常不会被缓存，因此在这种情况下，tmpfs仍然可以为您带来预期的收益。在Windows中，没有内置的方法来创建基于内存的文件系统。存在用于创建RAM磁盘的各种第三方软件，但尚未标准化，并且大多数应用程序需要GUI才能在每个系统上手动设置磁盘。接下来列出的Wikipedia页面为您提供了更多指示，以供您探索是否仍然感兴趣。 记忆化的缺点如您所见，通过记忆进行缓存通常是一件好事，但正如我母亲一直说的：“您可以拥有太多的好东西。”在默认情况下，开始记忆所有功能的诱惑可能会蔓延开来，但与所有其他功能一样，首先要考虑一些折衷。记住的函数会带来一些开销，用于每次运行时检查缓存版本是否可用以及获取或存储生成的任何缓存版本。如果您要记住要加快脚本的执行速度，并且您的缓存与前面的主要示例一样位于磁盘上，那么磁盘I / O会花费额外的时间（与内存存储或实际上许多仅用于计算的功能相比，这通常很慢）可能比运行中低复杂度功能所需的时间更长。当然，如果您要缓存以优化低内存系统，减少对外部API的调用次数或将其他与时间无关的资源使用量降到最低，那么这可能是可以接受的折衷方案。使用备注进行缓存时，要考虑的另一个考虑因素是某些数据的短暂性是否会限制您从中获得的成本价值。例如，如果您的功能的参数之一是客户ID，但您的客户很少对您的网上商店进行多次访问/购买，则对该功能的任何缓存都可能仅在那一次访问期间受益。与更一般的缓存情况相比，使用纯函数记忆化的好处之一是，您不必担心缓存失效，因为您的缓存永远不会无效。但是，这导致了诱惑，便简单地忘记了缓存而将其保留，从编程的角度来看这是完全可以的。您的代码将继续以正确的输出正常运行。但是，您的系统管理员可能很快就会出现并开始询问您是否真的需要昂贵的SAN上的所有磁盘空间。磁盘空间的成本可能超过脚本的有限加速。在这些情况下，您有三个选择。•删除备忘录：接受一些运行时间更长的脚本。•缓存到磁盘上的内存或每个会话文件，而不是长期磁盘上：这样可以在一次访问中加快多个呼叫的速度，但会暂时占用一些内存。•执行某种形式的缓存逐出：删除已存在一个月以上的缓存文件。 懒惰评估懒惰评估是一种艺术，它仅进行最少的工作即可获得所需的结果。PHP程序员应该自然而然地做到这一点！ 考虑以下伪代码： 1if ( do_something_easy() OR do_something_hard() ) &#123; return &#125; 该代码说明“如果do_something_easy（）或do_something_hard（）为true，则返回。”因此，要确定是否应返回，可以调用两个函数，如果其中一个返回true，则知道要返回。但是，请考虑一下，如果do_something_easy（）返回true，则do_something_hard（）返回什么都无所谓，因为无论如何您都将返回。因此，在运行do_something_easy（）之后，实际上没有必要运行第二个函数调用，并且您可以节省这样做的开销。相反，如果返回的是false，则需要运行第二个，但是，与第一个同时自动调用两者的情况相比，您的情况不会更糟。这称为惰性评估；您只评估需要的内容，而没有声明更多。在评估布尔表达式时，PHP使用一种称为短路评估的惰性评估类型，这取决于逻辑运算符的先例。因此，如果要从这样的表达式中调用函数以确保您不会使短路短路，那么除了注意手册中的以下几页之外，您无需执行其他任何操作！ 迭代器但是，您可以采用这种惰性求值的概念，并将其应用到您的函数中以加快执行速度。在上一章中介绍的功能组合示例中，通常会获取一个数据数组，对其进行处理，将该数组传递给下一个函数，然后执行其他操作，等等。即使实际上不需要数组中的所有数据，也通常将其传递给整个数组，然后将函数和转换应用于整个数组。您看过array_filter，它确实使用某些过滤器函数将数组的大小缩减为某些元素，但是即使那样，过滤器函数也将应用于数组的每个单个元素。如果只需要前10个匹配元素并且有100个匹配元素，那么您就浪费了时间，在找到前10个匹配元素之后应用filter函数，还需要执行其他步骤，例如使用array_slice将结果100缩减为10 。PHP有一个称为生成器的有用语言工具，它在PHP 5.5中引入。生成器允许您创建函数，该函数返回有点像数组的东西，但是其数据是在访问元素时“实时”生成的。您可以使用生成器来创建仅执行最少必需工作的惰性函数。将生成器功能链接在一起时，执行将向后执行。考虑如下三个标准函数的伪链： array_filter some_function(); array_filter another_function(); array_slice 0, 10; 首先将对整个数组进行过滤，然后对整个结果再次进行过滤，然后将第二个结果减少到十个项目。 在基于生成器的系统中，您可以编写如下所示的链： lazy_filter some_function(); lazy_filter another_function(); lazy_slice 0, 10; 它看起来是一样的，但是执行时，操作实际上是从lazy_slice开始，它会拉动整个链中的值。 slice函数从第二个过滤器请求值，直到有十个为止。每次第二个过滤器收到一个值请求时，它都会向第一个过滤器请求值，并向它们应用another_function（）直到匹配为止。并且，每当第一个过滤器获取一个值请求时，它都会从数组中获取值，并对它们应用some_function（）直到获得匹配。因此，当lazy_slice获得其十个值时，这两个lazy_filter函数仅足够多次调用了它们（可能昂贵的）过滤函数，以生成那十个，而不是（不必要）生成原始数据的所有项。稍后，您将看到一个发电机的基本示例。但是在您这样做之前，让我们创建一个函数以重复调用一个函数。当您查看时间时，同一台PC上无关的任务可能会暂时降低脚本的运行速度。多次运行脚本或函数可以限制这种暂时性的延迟对基准计时编号的影响。参见清单5-13。 Listing 5-13 repeat.php 12345678910111213&lt;?php// 为了获得基准测试结果，最好重复运行该函数，以最大程度地降低任何外部变慢的影响。// 以下函数仅使用参数$ args调用函数$func $n次，并返回上一次调用的返回值。$repeat = function ($func, $n, ...$args) &#123; for ($i=0; $i &lt; $n; $i++) &#123; $result = $func(...$args); &#125; return $result;&#125;; 现在，让我们看一个生成器的简单示例（请参见清单5-14，输出如清单5-15所示）。生成器是具有yield语句而不是return语句的函数。 与普通函数在返回时会丢失其状态不同，yield的函数会保持其状态直到下一次调用。PHP具有一个名为range（）的本地函数，该函数返回从$ start到$ end的数字数组，并带有可选的$ step值。 您将创建一个生成器版本gen_range（），该版本会产生相同的输出，但会产生延迟。 您将使用相同的参数调用这两者，以生成介于1到1000万之间的第四个数字，然后在得到一个可被123整除的数字时退出运行函数。 Listing 5-14 generators.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php# Get our repeat functionrequire('repeat.php');# PHP's native function range() takes a# $start int, $end in and $step value, and# returns an array of ints from $start to $end# stepping up by $step each time. We'll create# a generator version that takes the same# parameters and does the same task, called gen_range()function gen_range($start, $end, $step) &#123; for ($i = $start; $i &lt;= $end; $i += $step) &#123; # yield turns this function into a generator yield $i; &#125;&#125;;# We'll create a function to run either range() or# gen_range() (as specified in $func) with the# same paramters, and to iterate through the# returned values until we find a number exactly# divisible by 123 (which in this case is 369)$run = function ($func) &#123; # Get a range from 1 to ten million in steps of 4, # so 1,4,9,13,18,...,9999989,9999993,9999997 foreach ( $func(1, 10000000, 4) as $n ) &#123; if ($n % 123 == 0) &#123; # exit the function once we've found one, reporting # back the memory in use (as it will be freed once # we have returned). return memory_get_usage(); &#125;; &#125;;&#125;;# A function to get the time/memory use for the runs$profile = function ($func, ...$args) &#123; $start = [ "mem" =&gt; memory_get_usage(), "time" =&gt; microtime(true) ]; $end = [ "mem" =&gt; $func(...$args), "time" =&gt; microtime(true) ]; return [ "Memory" =&gt; $end["mem"] - $start["mem"], "Time" =&gt; $end["time"] - $start["time"] ];&#125;;# Finally let's run each of range() and gen_range() 100 times,# and output the time taken for each and memory usedEcho "*** range() ***\n";print_r ( $profile($repeat, $run, 100, 'range') );Echo "*** gen_range() ***\n";print_r ( $profile($repeat, $run, 100, 'gen_range') ); Listing 5-15. generators-output.txt 123456789101112*** range() ***Array( [Memory] =&gt; 134222280 [Time] =&gt; 8.9564578533173)*** gen_range() ***Array( [Memory] =&gt; 4952 [Time] =&gt; 0.0016660690307617) 因此，如您所见，惰性版本使用的内存量比正常的range（）函数少得多。这是因为range（）必须在开始迭代之前生成值的整个数组通过foreach遍历它们，而gen_range（）仅保存序列中的当前值。 gen_range（）所花费的时间也少得多，因为一旦您达到369，就完成了，而range（）必须甚至在开始之前就生成序列中的每个单个值。注意，使用的内存是$ run函数返回时返回的值memory_get_usage，这对于您的函数来说可能只是每个函数中使用的最大内存量。因此，这就是生成器的外观。现在，让我们看一下如何在功能组合中使用它们，以最大程度地减少功能链要做的工作量。您将创建一个脚本，该脚本需要莎士比亚的名副其实的完整著作（作为纯文本文件），获得提及英雄一词的行，并获得任何长度超过60个字符的行，然后返回前三个匹配项。清单5-16展示了如何以一种非延迟的方式进行操作，清单5-17中显示了输出。 Listing 5-16. filter.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?php# Borrow some functions from Chapter 3,# and our repeat functionrequire('../Chapter 3/compose.php');require('../Chapter 3/partial_generator.php');require('repeat.php');# A helper function to fix parameters from the right,# as we'll otherwise call partial(reverse()) a lot below.$partial_right = function ($func, ...$params) &#123; return partial(reverse($func), ...$params);&#125;;# Get the start time, to see how long the script takes$start_time = microtime(true);# A function to return true if $word is in $str# (not comprehensive, but matches a word bounded# by non-A-Z chars, so matches "hero" but not "heroes")$match_word = function($word, $str) &#123; return preg_match("/[^a-z]$&#123;word&#125;[^a-z]/i", $str);&#125;;# A function to return true if $str is longer than $len chars$longer_than = function($len, $str) &#123; return strlen($str) &gt; $len;&#125;;# A partial function, fixing hero as the word to search for$match_hero = partial($match_word, 'hero');# Another partial function, picking out strings longer than 60 chars$over_sixty = partial($longer_than, 60);# A partial function which uses array_filter to apply $match_hero# to all elements of an array and return only those with 'hero' in$filter_hero = $partial_right('array_filter', $match_hero );# Similarly, we'll filter an array with the $over_sixty function$filter_sixty = $partial_right('array_filter', $over_sixty );# A function to grab the first 3 elements from an array$first_three = $partial_right('array_slice', 3, 0);# Let's now compose the function above to create a# function which grabs the first three long# sentences mentioning hero.$three_long_heros = compose( $filter_hero, $filter_sixty, $first_three );# Finally, let's actually call our composed function 100 times# on the contents of all_shakespeare.txt# Note that calling file() as a parameter means that it is# only evaluated once (and not 100 times), so the time for disk# IO won't be a major element of our timings$result = $repeat( $three_long_heros, file('all_shakespeare.txt'), 100 );# Print out the result of the last call (which should be the# same as all of the rest, as all of our composed functions are# pure and are called on exactly the same input parameter)print_r($result);# and the time takenecho 'Time taken : '.(microtime(true) - $start_time); Listing 5-17. filter-output.txt 12345678Array([0] =&gt; Enter DON PEDRO, DON JOHN, LEONATO, FRIAR FRANCIS, CLAUDIO, BENEDICK, HERO,BEATRICE, and Attendants[1] =&gt; Sweet Hero! She is wronged, she is slandered, she is undone.[2] =&gt; Think you in your soul the Count Claudio hath wronged Hero?)Time taken : 6.2691030502319 这为您提供了三行所需的信息，在我的薄弱笔记本电脑上运行100次大约需要6秒钟。 清单5-18懒惰地重写了此脚本，输出如清单5-19所示。 Listing 5-18. lazy_filter.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?php# Again we'll borrow some functions from Chapter 3,# and our repeat functionrequire('../Chapter 3/compose.php');require('../Chapter 3/partial_generator.php');require('repeat.php');# and start timing$start_time = microtime(true);# We'll now define a lazy version of array_filter, using# a generator (note the yield statement)$lazy_filter = function ($func, $array) &#123;# Loop through the array foreach ($array as $item) &#123; # Call the function on the array item, and # if it evaluates to true, return the item if ( $func($item) ) &#123; yield $item; &#125; &#125;;&#125;;# The following functions are exactly the same as# in the non-lazy filter.php example$match_word = function($word, $str) &#123; return preg_match("/[^a-z]$&#123;word&#125;[^a-z]/i", $str);&#125;;$longer_than = function($len, $str) &#123; return strlen($str) &gt; $len;&#125;;$match_hero = partial($match_word, 'hero');$over_sixty = partial($longer_than, 60);# Our $filter_hero function is almost the same,# but note that it calls $lazy_filter instead of# array_filter (and it uses partial() rather than# $partial_right, as I've implemented $lazy_filter# with the parameters in the opposite order to# array_filter.$filter_hero = partial($lazy_filter, $match_hero );# Again $filter_sixty uses $lazy_filter rather than array_filter$filter_sixty = partial($lazy_filter, $over_sixty );# As the output from filter_sixty will be a generator object# rather than an array, we can't use array_slice to# get the first three items (as data doesn't exist in a# generator until you call for it). Instead, we'll create# a $gen_slice function which calls the generator $n times# and returns the $n returned values as an array. We'll take# advantage of that fact that a generator is an iterable object,# and so has current() and next() methods to get each value.# We'll practice our recursion, rather than just using# a for loop!$gen_slice = function ($n, $output = [], $generator) use (&amp;$gen_slice) &#123; $output[] = $generator-&gt;current(); $generator-&gt;next(); if ($n &gt; 1) &#123; $output = $gen_slice(--$n, $output, $generator); &#125;return $output;&#125;;# $first_three uses $gen_slice rather than array_slice$first_three = partial($gen_slice, 3, []);# We'll compose them together, repeatedly call them# and output the results using exactly the same# code as in the non-lazy version$three_long_heros = compose( $filter_hero, $filter_sixty, $first_three );$result = $repeat( $three_long_heros, file('all_shakespeare.txt'), 100 );print_r($result);echo 'Time taken : '.(microtime(true) - $start_time); Listing 5-19. lazy_filter-output.txt 12345678Array([0] =&gt; Enter DON PEDRO, DON JOHN, LEONATO, FRIAR FRANCIS, CLAUDIO, BENEDICK, HERO,BEATRICE, and Attendants[1] =&gt; Sweet Hero! She is wronged, she is slandered, she is undone.[2] =&gt; Think you in your soul the Count Claudio hath wronged Hero?)Time taken : 2.1842160224915 您得到相同的结果，但仅需2秒钟，大约快了三倍。 那么，这是如何工作的呢？ 好吧，您的lazy_filter不会返回任何数据，而是“产生”一个生成器对象。 该对象实现了PHP的迭代器接口，因此诸如foreach之类的功能会自动知道如何使用它，就好像它是任何其他可迭代的数据类型一样。 当您使用gen_slice（）函数时，这一点变得尤为明显。该函数不是假装您正在使用数组，而是仅调用生成器对象的current（）和next（）方法来请求下三个数据。 如果您不熟悉迭代器，则PHP手册的以下部分将对您进行分类。 顺便说一句，当我编写以前的脚本时，我首先使用compose语句命名了它链接在一起的三个功能，然后向后进行工作以找出实现它们所需的功能。 在进行功能编程时，您经常会发现这种模式。 声明式的性质使其适用于自上而下的程序设计方法。 懒惰评估的缺点生成器很棒，并且惰性评估通常是一个非常有用的工具。 但是，正如您可能期望的那样，值得一提的是可能会有不利之处。 如果再次运行您的generators.php示例，但是这次不是寻找一个可被123整除的数字，而是使用值9999989，清单5-20和清单5-21显示了发生的情况。 Listing 5-20. generators2-output.txt 123456789101112*** range() ***Array( [Memory] =&gt; 134222280 [Time] =&gt; 26.05708694458)*** gen_range() ***Array( [Memory] =&gt; 4952 [Time] =&gt; 41.604923009872) 标准range（）函数需要26秒，但是您的gen_range（）惰性函数几乎将其翻了一番，达到41秒。为什么？好的，发电机中存在固有的开销。寻找一个可以被9999989整除的数字（在这种情况下，它本身就是数字）意味着您必须一直进行直到找到数字序列的末尾为止。但是您必须对序列中的每个数字都调用一个函数（通过foreach），而不是对range（）进行一次函数调用，而且每次函数调用都会产生少量开销。此外，您要调用的函数是由您用PHP编写的，而不是由整个PHP核心开发人员团队使用C编写的，因此，高度优化的代码要少得多。因此，通常会出现一个问题，即与最初进行全面评估相比，生成器的时间效率较低。通常这是最小的，并且在评估过程即将结束时，并且如果您的运行输入值“分散”了，即使其中一些花费的时间比完整的评估方法花费的时间更长，通常也可以总体上领先。不过，始终值得考虑您的用例，并确保根据实际数据对代码进行性能分析。 不过，这也不是个坏消息。 如果查看一下内存使用情况的数字，您会发现它们与第一个示例中的数字完全相同，在第一个示例中，您寻找的数字可以被123整除。在这种情况下，您可能会考虑由于 如果您正在使用内存受限的设备，则每次更改值（而不是预先生成所有值）都值得偶尔的额外执行时间。 并行编程在写书的漫长过程中，我经常希望自己的双手可以同时写不同的章节。这样一来，我完成本书的速度就会快两倍。不幸的是，当我意识到我微不足道的大脑一次只能跟踪一组单词时，我的狡猾计划受到了挫败。幸运的是，现代计算机并没有我这么有限，可以一次执行并跟踪许多任务。计算机以各种方式（并行计算，多任务，多线程，多处理等）执行此操作，但是它们全都归结为一件事：您同时执行的次数越多，完成任务的速度就越快。不过，即使您同时执行不同的操作，即使拥有现代PC的智能功能，也可以确保一切顺利。资源争用，死锁，争用条件：当多个线程或进程试图同时访问相同的资源（变量，数据，文件，硬件等）时，这些都是发生的事情。像这样的编程中最难的部分可能是在考虑脚本执行在不同路径上可能发生的所有可能性。函数式编程可以使此操作更容易。当您的程序需要执行并行任务时，它们将剥离一些线程，子进程或类似任务以完成任务，并且它们通常会合并结果或在线程或进程返回时采取某些措施。如果您使用本书中介绍的功能原理编写这些任务工作程序，则每个工作程序都可以成为一连串的纯函数，其中：•任务仅取决于其给定的输入（例如函数的参数），而不取决于外部状态。•由于不受其他任务的影响，因此可以很容易地对任务进行单独推理。这意味着您不必（过多）担心其他任务在做什么，它们可能正在使用的所需资源等，等等。您的任务具有调用时所需要的一切作为输入的一部分，并且它将返回其输出以供父脚本使用，以担心处理/存储等问题。即使它不是严格的函数，也可以像编写脚本一样编写工作脚本，接受来自父文件的输入，就好像它是参数一样，并返回单个最后返回给父级的值，就像返回值一样。PHP并非自然而然地用于并行编程，但是有多种实现并行计算的方法，可以在需要时将其付诸实践。也许最简单的方法是使用PHP的内置过程控制功能并行启动多个PHP脚本来完成工作。让我们看一个以这种方式使用流程控制的示例。您将创建一个程序来对莎士比亚的完整作品进行一些分析。您将创建一个以正常线性方式进行分析的函数，以及一个生成的函数多个“客户端” PHP工作程序脚本并行进行分析。首先，您将看到主要的parallel.php控制脚本，然后是并行版本中使用的client.php脚本，最后您将看到functions.php脚本，其中包含各种分析和并行化功能。您的脚本将从文本中挑选出符合特定条件的单词，将这些单词在整个文本中出现的次数相加，然后报告该集合中出现次数最多的十个单词。您将重复每个功能100次以对其进行基准测试。 Listing 5-21. parallel.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php# Get a set of functions that we'll look at shortlyrequire('functions.php');# The text to work on.$shakespeare = file_get_contents('all_shakespeare.txt');# How many times we're going to run each function, for# benchmarking purposes$repeats = 100;# Compose our single process "standard" function.$analyze_single = compose( $only_letters_and_spaces, # simplify the text 'strtolower', # all lowercase, please $analyze_words, # do the analysis $sort_results, # sort the results 'array_reverse', # get the results in descending order $top_ten # return the top ten results);# Run the single process version $repeats time on $shakespeare input# Time the runs$checkpoint1 = microtime(true);print_r( $repeat($analyze_single, $repeats, $shakespeare) );$checkpoint2 = microtime(true);# Now create a parallel process version$analyze_parallel = compose ( $launch_clients, # Launch a set of client processes to do # the analysis $report_clients, # Tell us how many clients were launched $get_results, # Get the results back from the clients $combine_results, # Combine their results into one set $sort_results, # sort the combined results 'array_reverse', # get the results in descending order $top_ten # return the top ten results);# Run the parallel version and time it$checkpoint3 = microtime(true);print_r ( $repeat($analyze_parallel, $repeats, $shakespeare) );$checkpoint4 = microtime(true);# Finally, dump the timings for comparisonvar_dump( 'Single : '.($checkpoint2 - $checkpoint1));var_dump( 'Parallel : '.($checkpoint4- $checkpoint3)); 在$ analyse_parallel组合中，$ launch_clients函数将并行启动清单5-22中的脚本多次运行。 Listing 5-22. client.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire('functions.php');# Get the chunk of text for the client to analyze# by reading the contents of STDIN which are piped to# this script by the fwrite($clients[$key]["pipes"][0], $string)# line in the $launch_clients function in the parent process$string = stream_get_contents(STDIN);# Compose a function to do the analysis. This is the same# as the first three steps of the single process analysis# function, with a step to encode the results as JSON at# the end so we can safely pass them back$client_analyze = compose( $only_letters_and_spaces, 'strtolower', $analyze_words, 'json_encode');# Run the function and write the results to STDOUT,# which will be read by the stream_get_contents($client["pipes"][1])# line in the $get_results function in the parent process. In most cases# you can use echo to write to STDOUT, but sometimes it can be# redirected, and so explicitly writing like this is better practicefwrite(STDOUT, $client_analyze($string) ); 最后，清单5-23显示了functions.php脚本，该脚本实现了您在先前脚本中组成的所有功能。 我将它们分开，以使脚本更易于阅读，也因为两个脚本都可以访问许多脚本。 Listing 5-23. functions.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&lt;?php# Borrow some utility functions from previous examplesrequire('../Chapter 3/compose.php');require('repeat.php');# To simplify our analysis, replace anything that's not# a letter with a space.$only_letters_and_spaces = function($string) &#123; return preg_replace('/[^A-Za-z]+/', ' ', $string);&#125;;# This is the "expensive" deliberately un-optimized function# that does our "analysis".$analyze_words = function ($string) &#123; # Split our text into an array, one word per element $array = preg_split('/ /i', $string, -1, PREG_SPLIT_NO_EMPTY); # Filter our array for words that... $filtered = array_filter($array, function ($word) &#123; return ( # ... contain any of the letters from the word shakespeare preg_match('/[shakespeare]/', $word) != false) # ... AND has at least 1 character in common with this sentence &amp;&amp; (similar_text($word, 'William is the best bard bar none') &gt; 1) # ... AND sound like the word "bard" &amp;&amp; (metaphone($word) == metaphone('bard')) # ... AND have more than three characters in them &amp;&amp; ( (strlen($word) &gt; 3 ) ); &#125;); # Finally, count up the number of times each of the filtered # words appears in the analyzed text, and return that return array_count_values($filtered);&#125;;# Slice the top 10 items off the top of the array$top_ten = function ($array) &#123; return array_slice($array, 0 ,10);&#125;;# Sort the results numerically# asort mutates the array, so we wrap it in a function$sort_results = function($array) &#123; asort($array, SORT_NUMERIC); return $array;&#125;;# The following functions manage the execution of parallel client scripts# A function to split the text into chunks and launch the# appropriate number of clients to process it$launch_clients = function ($string) &#123; # Split the string into chunks of 1 million characters, # a value which I found by trial and error to give the # best results on this machine for this process $strings = str_split($string, 1000000); # An array to hold the resource identifiers for the client scripts $clients = []; # Descriptors for "pipes" to read/write the data to/from our client # scripts $descriptors = [ 0 =&gt; ["pipe", "r"], #STDIN, to get data 1 =&gt; ["pipe", "w"] #STDOUT, to send data ]; # Iterate through the chunks... foreach ($strings as $key =&gt; $string) &#123; # $key will be the array index, 0, 1, 2, 3... etc. # We'll use it as a handy way to number our clients # Define the command that runs the client $command = "php client.php"; # Open the clients with proc_open. This returns a resource identifier. # We'll store it, although our script won't actually use it. $clients[$key]["resource"] = proc_open( $command, $descriptors, $clients[$key]["pipes"] ); # Note the third parameter above is a variable passed by reference. # This is used by proc_open to store an array of file pointers # identifying PHP's end of the pipes that are created. # We use that info here to write our text chunk to. This writes # it to STDOUT, and our client script reads it in through STDIN # at its end of the pipe. fwrite($clients[$key]["pipes"][0], $string); # Close the pipe now we're done writing to this client. fclose($clients[$key]["pipes"][0]); &#125;; # Once all of the clients have been launched, return their # resource identifiers and pipe details return $clients;&#125;;# Simple impure function to report how many clients were# launched. You could use a writer monad instead if you wanted$report_clients = function ($clients) &#123; # The escape code at the end minimizes our output when # when running the script many times, by going up one line # and overwriting the output each time. echo("Launched ".sizeof($clients)." clients\n\033[1A"); return $clients;&#125;;# A function to get the results back from the clients.# The clients will send a JSON encoded array back to us$get_results = function ($clients) &#123; # An array to gather the results. Each clients' result # will be stored as an element of the array $results = []; # Iterate through the client resource identifiers foreach ($clients as $key =&gt; $client) &#123; # Clients write output to STDOUT, which corresponds to the # STDIN Pipe at our end. We'll read that JSON data and # decode it to a PHP array. Each client's results will be # stored as a separate element of the $results array. $results[] = json_decode( stream_get_contents($client["pipes"][1]), true); # We've done reading from the client, so we can close the pipe. fclose($clients[$key]["pipes"][1]); &#125;; # And finally return all of the results from all of the clients return $results;&#125;;# This function takes the results array from $get_results above and# combines it into a single array$combine_results = function ($results) &#123;# Reduce and return the input array by... return array_reduce($results, function($output, $array) &#123; #... iterating over each individual clients results array # and either creating or adding the count for each word to # the output depending on whether that word already exists in # the output foreach ($array as $word =&gt; $count) &#123; isset($output[$word]) ? $output[$word] += $count : $output[$word] = $count ; &#125; # return $output through to the next iteration of array_reduce return $output; &#125;, []); # starting with a blank array [] as output&#125;; 让我们运行parallel.php看看会发生什么（参见清单5-24）。 Listing 5-24. parallel-output.txt 1234567891011121314151617181920212223242526272829Array( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)Launched 4 clientsAArray( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)string(24) &quot;Single : 48.808692932129&quot;string(25) &quot;Parallel : 25.10250711441&quot; 如您所见，从单个流程版本和并行流程版本的分析中都可以得到相同的结果，但是并行版本大约需要执行一半的时间。 如您所做的那样，将文本分块可以并行地给您提供四个客户端流程来分析所有文本。 考虑到两个版本的函数使用的是完全相同的昂贵函数（$ analyze_words），您可能想知道为什么有四个客户端在四分之一的时间内都没有完成。 原因是要并行运行需要大量的设置，包括以下内容：•将文本分成大块•启动新的PHP流程•写入和读取过程管道•最后将结果组合在一起因此，如果您想进一步加快速度，难道您不能简单地同时增加更多的客户吗？ 让我们尝试一下，将文本分成100,000个字符的块，这需要38个客户端来并行计算（请参见清单5-25）。 Listing 5-25. parallel-output2.txt 1234567891011121314151617181920212223242526272829Array( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)Launched 38 clientsArray( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)string(24) &quot;Single : 49.230798959732&quot;string(26) &quot;Parallel : 145.74519586563&quot; 在这种情况下，您的速度从原来的两倍提高到了将近三倍！这再次是因为协调所有客户端并将结果汇​​总在一起的开销。因此，使用这种技术，并行处理的数量通常会达到最佳效果。这在很大程度上取决于手头的任务，对于具有以下特征的功能，您可能会获得更好的结果：•不需要大量后处理的功能（例如，来自不同客户的结果的顺序或内容无关紧要）•设置便宜的功能（例如，最少的处理以拆分输入数据，最少的数据传输到客户端）•运行时间更长的功能（与函数执行时间相比，时间开销最小）如您所见，没有很多额外的代码来管理并行化，就不会提高速度。在进入并行化代码阶段之前，您可以做很多事情加快执行速度，包括以下步骤：•使用懒惰求值，首先对单词进行计数和排序（便宜的操作）然后将分析作为生成器功能的一部分•重新排列array_filter中的操作以利用PHP的延迟评估，在调用更昂贵的preg_match之前，先使用strlen等廉价函数对数据进行缩减•预先计算metaphone（’bard’）并存储在变量中，而不是每次都计算•用便宜的strpbrk PHP函数替换preg_match如果这不足以使您达到性能目标，并且需要并行运行，则可以做一些其他事情来加快并行版本的速度（我还没有这样做）为了使代码简单和节省书中的空间）。•仅在每个脚本中包括所需的功能，也许使用构建步骤来内联它们。•直接在共享内存中传递数据，而不是通过管道传递数据，这样可以更快。•不要等待每个客户端发送数据之后再继续从下一个客户端读取数据，以无阻塞的方式反复遍历它们，直到每个客户端都准备好数据为止。 使用并行脚本很难进行惰性求值，因为每个脚本都以适合其本地输入的顺序返回数据，而不一定代表整个数据。例如，使用此脚本，每个客户都可以计算自己的最佳结果，但是您不能只接受您收到的前十个结果，因为它们可能不是莎士比亚作品中前十个，而仅仅是那些经过分析并先返回。如您所见，并行化工作需要一些思考，即使函数式编程通过消除考虑副作用的额外负担来帮助您。还请考虑一下，如果您的一个客户未能完成或挂起，我什至没有涉及该怎么办，您将了解为什么只有在真正必要时才考虑使用此类技术。 多线程编程多线程编程的工作方式与您在上一节中介绍的多进程示例类似。关键区别在于并行执行发生在同一流程而不是单独的流程中。 PHP不是多线程的；但是，使用Pthreads扩展可以实现多线程。 Pthreads是基于OOP的可靠实现，其性能可以明显优于多进程脚本。但是，由于线程在同一进程中共存，因此实​​现起来比多进程代码更复杂。另外，请注意，Pthreads扩展只能与PHP的“线程安全”版本一起使用，该版本与许多PHP扩展都不兼容。 Linux上的大多数程序包管理器都不包含线程安全版本，因此将要求您手动编译PHP（如果需要自己编译PHP的信息，请参阅附录A），或者对于Windows，则需要下载线程安全的可执行文件。从PHP网站。尽管如此，采用前面所示的函数式编程原理仍可以帮助您绕过多线程编程常见的一些问题领域。可以在Pthreads网站上找到有关扩展的更多信息和使用示例。 标准PHP库（SPL）在本章的开头，我讨论了一个事实，即PHP存在一些明显的性能问题，这是因为为用户提供易于使用和通用的数据结构和功能所需的开销。如果您发现这种开销开始限制脚本，则可以调用的标准端口库是标准PHP库（SPL），它是包含通用和深奥的数据结构和功能的核心PHP扩展。它们旨在解决常见的编程问题，尽管与PHP较常见的结构（如普通的PHP数组类型）相比，需要使用更多的思想。没有什么是独家的SPL中的函数式编程，但是您可以在本书中介绍的函数式技术中使用一些有用的函数和结构。因此，例如，如果您发现传递大量数据导致脚本达到内存限制，则可能需要查看SplFixedArray类。它有一些限制（您只能使用整数作为索引，并且必须预先指定数组的长度），但是提供了比普通数组使用更少内存的更快实现。如果您不熟悉SPL中的某些数据结构（例如堆，链接列表等），那么计算机科学的大多数基本介绍（或使用更传统的语言进行编程）都可以为您提供帮助。 SPL还包含用于常见的基于迭代器的任务的函数和类，您可以将它们与之前查看的生成器一起使用。 清单5-26中的示例脚本向您介绍了iterator_to_array函数，SplFixedArray结构和FilterIterator类。 Listing 5-26. spl.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;?php# Borrow our simple generator examplefunction gen_range($start, $end, $step) &#123; for ($i = $start; $i &lt;= $end; $i += $step) &#123; yield $i; &#125;&#125;;# Call the generator...$gen_obj = gen_range(1,10,1);# ... and check what we have is a generator objectprint_r($gen_obj);# Generators are iterators, so when we need a full array# of data instead of a generator, we can convert# it to an array using SPL's iterator_to_array function$array = iterator_to_array($gen_obj);print_r($array);# An SplFixedArray is SPLs fixed size array data structure.# Let's create an empty SPL fixed array and a standard PHP array.# Note we need to specify a size for the SPL array$spl_array = new SplFixedArray(10000);$std_array = [];# Let's create a function to fill an array with data. As both# array types can be written to in the same way, we can# use the same function here for both$fill_array = function($array, $i = 0) use (&amp;$fill_array) &#123; # recursively fill the $array with data if ($i &lt; 10000) &#123; $array[$i] = $i * 2; return $fill_array($array, ++$i); &#125;; return ($array);&#125;;# Let's do some operations with the arrays. We'll measure# the memory in use before and after each operation.$mem1 = memory_get_usage();# Fill the standard array with data$std_array = $fill_array($std_array);$mem2 = memory_get_usage(); # 528384 bytes# Fill the SPL array with data$spl_array = $fill_array($spl_array);$mem3 = memory_get_usage(); # 0 bytes# It took no memory to fill!# This is because this type of array allocates all of its memory# up-front when you create it# Create a new SPL array and fill with data$spl_array2 = new SplFixedArray(10000);$spl_array2 = $fill_array($spl_array2);$mem4 = memory_get_usage(); # 163968 bytes# This time it did, as we declared it within the section we# were measuring# Create a new empty standard array$std_array2 = [];$mem5 = memory_get_usage(); # 56 bytes - a small amount# Create a new empty SPL array$spl_array3 = new SplFixedArray(10000);$mem6 = memory_get_usage(); # 163968 bytes - for an empty array!# This shows that you need to use it with care. A Standard# array may use more memory for the same amount of data, but# the memory also shrinks with the array contents too.echo "Filled Standard Array : ".($mem2 - $mem1). " bytes \n";echo "1st Filled SPLFixedArray : ".($mem3 - $mem2). " bytes \n";echo "2nd Filled SPLFixedArray : ".($mem4 - $mem3). " bytes \n";echo "Empty Standard Array : ".($mem5 - $mem4). " bytes \n";echo "Empty SPLFixedArray : ".($mem6 - $mem5). " bytes \n";# The SPL provides various iterator classes that you can extend# to work with iterable structures like the SPLFixedArray and# generators# Let's create a class to filter for values that are divisible by threeclass by_three extends FilterIterator &#123; # We extend the FilterIterator class, and implement the accept() class # with our filtering function public function accept() &#123; $value = $this-&gt;current(); if ($value % 3 == 0) &#123; # return true to include the value in the output return true; &#125; # or false to filter it out return false; &#125;&#125;;# Let's use it to filter our previous SPL array$nums = new by_three($spl_array);var_dump(iterator_count($nums)); # int(3334) (~third of the array is returned) 总结在本章中，您研究了性能改进领域中函数编程的一些常见应用程序。 即使您不会全力以赴地用功能代码编写应用程序，也可以挑选出导致瓶颈的关键功能，并牢记功能原理进行重写，这可以使您将这些提高性能的技术应用于代码的这些部分。 当然，如果您确实以一种功能样式从头开始编写应用程序，那么在发现问题功能时应用备忘等技术便可以快速简便地完成。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在面向对象和面向过程中使用函数式编程]]></title>
    <url>%2F2020%2F03%2F31%2F%E5%9C%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 到目前为止，您已经了解了什么是函数式编程以及如何使用它来解决一些常见的编程问题的基础知识。在本章中，您将了解如何将功能代码放入现有或新应用程序中。具体来说，您将看到以下内容： 如何构造函数式应用程序以及使其充分发挥功能 如何以及何时混合和匹配范式，例如功能和面向对象的编程 PHP范式的历史函数的引用透明性（referential transparency） 基础初学程序设计时，比较容易混淆的两个概念是数学函数（math function）和程序中使用的函数。 在数学函数中 y=f(x)，一个输入值有固定的输出值。例如，无论计算多少次，sinπ 的结果总是 0。如果 f(x)=x/2，那么 f(10) 无论计算 100 次还是 1000 次，其结果都是 5. 程序设计中的函数却不具备这种稳定的特性，因为函数的执行不仅依赖于输入值，而且会受到全局变量，输入文件，类的成员变量等诸多因素的影响。如下：1234int counter = 0;int count()&#123; return ++counter;&#125; 此函数输入没有输入值，但每次都返回不同的结果。当然，就像数学函数那样，程序中函数还可以设计成“对同一输入值每次都返回相同结果”的形式。 函数的返回值只依赖于其输入值，这种特性就称为引用透明性（referential transparency） 动态规划的缓存显然，动态规划所使用的制表法（也即缓存）只能应用于具有引用透明性的函数。如果外在因素使相同输入值返回不同结果值，则不能缓存。 也即缓存对应的 map，实现的是同一个输入（key），同一个输出（value），而不可能出现同一个输入，可以得到不同的输出，也即输出结果的不确定性。 使事情简单明了的最佳方法是将您的代码分为功能和非功能代码块。 一个明显的安排是用功能代码编写业务逻辑，高性能算法等，并将其夹在不纯的OO或过程代码之间以处理输入和输出，如图7-1所示。 通过这样的安排，您可以使用干净的功能代码块来进行推理和测试，并且当问题确实发生时，更容易找出它们可能位于的位置。 当您面对使用功能性技术更新现有代码库时，一种好的方法是首先确定适合图7-1中间部分的代码部分，然后优先确定它们的优先级。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php# Create a class to encapsulate a valueclass my_class&#123; # The value we want to encapsulate private $value = 0; # Constructor to set the value (or default to -1) public function __construct($initial_value = -1) &#123; $this-&gt;value = $initial_value; &#125; # Method to get the value public function get_value() &#123; return $this-&gt;value; &#125; # Method to set the value public function set_value($new_value) &#123; $this-&gt;value = $new_value; &#125;&#125;# Let's create a new object with a value of 20$my_object = new my_class(20);# Check the valuevar_dump ($my_object-&gt;get_value()); # int(20)# Demonstrate we can mutate the value to 30$my_object-&gt;set_value(30);var_dump ($my_object-&gt;get_value()); # int (30)# Now let's create a function which doubles the value# of the object. Note that the function parameter# doesn't have a "&amp;" to indicate it's passed by reference$double_object = function ($an_object) &#123; # Get the value from $an_object, double it and set it back $an_object-&gt;set_value( $an_object-&gt;get_value() * 2 ); # return the object return $an_object;&#125;;# Now we call the function on our $my_object object from# above, and assign the returned object to a new variable$new_object = $double_object($my_object);# Check that the returned object has double the value (30)# of the object we passed in as a parametervar_dump( $new_object-&gt;get_value() ); # int(60)# Let's just check the value on the original objectvar_dump( $my_object-&gt;get_value()); # int(60)# It's also changed. Let's var_dump the original object# and returned object, and check their object reference number# (look for the number after the #)var_dump ($my_object); # #1var_dump ($new_object); # #1# They're both the same. Just for clarity, create a new# object from scratch and check it's reference number$last_object = new my_class();var_dump ($last_object); # #3 (#2 was our closure object $double_object) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php# use our trusty compose functioninclude('../Chapter 3/compose.php');# The same class as before, but with an added static methodclass new_class&#123; private $value = 0; public function __construct($initial_value = -1) &#123; $this-&gt;value = $initial_value; &#125; public function get_value() &#123; return $this-&gt;value; &#125; public function set_value($new_value) &#123; $this-&gt;value = $new_value; &#125; # a static method to halve the provided value public static function halve($value) &#123; return $value / 2; &#125;&#125;# Let's create a new object with an initial value of 25$my_object = new new_class(73.4);# Let's stack some math functions together including our# static method above$do_math = compose ( 'acosh', 'new_class::halve', 'floor');# Now let's actually do the math. We set the object value# to the result of $do_math being called on the original value.$my_object-&gt;set_value( $do_math( $my_object-&gt;get_value() ) );# Show that our object value has been changed. Note that nothing changed# while we were in our functional (compose) code.var_dump ( $my_object-&gt;get_value() ); # float(2) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php# use our trusty compose functioninclude('../Chapter 3/compose.php');# The same class as previouslyclass my_class&#123; private $value = 0; public function __construct($initial_value = -1) &#123; $this-&gt;value = $initial_value; &#125; public function get_value() &#123; return $this-&gt;value; &#125; public function set_value($new_value) &#123; $this-&gt;value = $new_value; &#125;&#125;# A function to triple the value of the object$triple_object = function ($an_object) &#123; # First clone it to make sure we don't mutate the object that # $an_object refers to $cloned_object = clone $an_object; # Then set the value to triple the current value $cloned_object-&gt;set_value( $cloned_object-&gt;get_value() * 3 ); # and return the new object return $cloned_object;&#125;;# A function to multiply the value of the object by Pi.# Again we clone the object first and return the mutated clone$multiply_object_by_pi = function ($an_object) &#123; $cloned_object = clone $an_object; $cloned_object-&gt;set_value( $cloned_object-&gt;get_value() * pi() ); return $cloned_object;&#125;;# Let's create an object encapsulating the value 10.$my_object = new my_class(10);# We'll compose the above functions together$more_maths = compose( $triple_object, $multiply_object_by_pi, $triple_object);# and then call that composition on our object.var_dump ( $more_maths($my_object) );# Let's check our original object remains unchangedvar_dump ($my_object); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?php# Create a class to represent an immutable array# Make the clas "final" so that it can't be extended to add# methods to mutate our arrayfinal class const_array &#123; # Our array property, we use a private property to prevent # outside access private $stored_array; # Our constructor is the one and only place that we set the value # of our array. We'll use a type hint here to make sure that we're # getting an array, as it's the only "way in" to set/change the # data, our other methods can be sure they are then only dealing # with an array type public function __construct(array $an_array) &#123; # PHP allows us to call the __construct method of an already created # object whenever we want as if it was a normal method. We # don't want this, as it would allow our array to be over written # with a new one, so we'll throw an exception if it occurs if (isset($this-&gt;stored_array)) &#123; throw new BadMethodCallException( 'Constructor called on already created object' ); &#125;; # And finally store the array passed in as our immutable array. $this-&gt;stored_array = $an_array; &#125; # A function to get the array public function get_array() &#123; return $this-&gt;stored_array; &#125; # We don't want people to be able to set additional properties on this # object, as it de facto mutates it by doing so. So we'll throw an # exception if they try to public function __set($key,$val) &#123; throw new BadMethodCallException( 'Attempted to set a new property on immutable class.' ); &#125; # Likewise, we don't want people to be able to unset properties, so # we'll do the same again. As it happens, we don't have any public # properties, and the methods above stop the user adding any, so # it's redundant in this case, but here for completeness. public function __unset($key) &#123; throw new BadMethodCallException( 'Attempted to unset a property on immutable object.' ); &#125;&#125;# Let's create a normal array$mutable_array = ["country" =&gt; "UK", "currency" =&gt; "GBP", "symbol" =&gt; "£"];# and create an const_array object from it$immutable_array = new const_array($mutable_array);var_dump ($immutable_array);# Let's mutate our original array$mutable_array["currency"] = "EURO";# our const_array is unaffectedvar_dump ($immutable_array);# We can read the array values like normalforeach ( $immutable_array-&gt;get_array() as $key =&gt; $value) &#123; echo "Key [$key] is set to value [$value] \n\n";&#125;;# And use dereferencing to get individual elementsecho "The currency symbol is ". $immutable_array-&gt;get_array()["symbol"]."\n\n";# Need to copy it? Just clone it like any other object, and the methods# which make it immutable will be cloned too.$new_array = clone $immutable_array;var_dump ($new_array);# The following operations aren't permitted though, and will throw exceptions# $immutable_array-&gt;stored_array = [1,2,3];# BadMethodCallException: Attempted to set a new property on immutable class# $immutable_array-&gt;__construct([1,2,3]);# BadMethodCallException: Constructor called on already created object# unset($immutable_array-&gt;get_array);# BadMethodCallException: Attempted to unset a property on immutable object.# $immutable_array-&gt;new_prop = [1,2,3];# BadMethodCallException: Attempted to set a new property on immutable class# $test = new const_array();# TypeError: Argument 1 passed to const_array::__construct()# must be of the type array, none given# class my_mutable_array extends const_array &#123;## function set_array ($new_array) &#123;## $this-&gt;stored_array = $new_array;## &#125;## &#125;;# Fatal error: Class my_mutable_array may not inherit from final# class (const_array)# Unfortunately, there is no practical way to stop us overwriting the object# completely, either by unset()ing it or by assigning a new value to the# object variable, such as by creating a new const_array on it$immutable_array = new const_array([1,2,3]);var_dump($immutable_array); # new values stored 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php# Get our compose functionrequire '../Chapter 3/compose.php';# This class will provide a set of methods to work with taxclass tax_functions &#123; # Store the rate of tax private $tax_rate; # Our constructor sets the tax rate initially public function __construct($rate) &#123; $this-&gt;tax_rate = $rate; &#125; # Provide a method to set the tax rate at any point public function set_rate($rate) &#123; $this-&gt;tax_rate = $rate; &#125; # A method to add tax at the $tax_rate to the $amount public function add_tax($amount) &#123; return $amount * (1 + $this-&gt;tax_rate / 100); &#125; # A method to round the $amount down to the nearest penny public function round_to($amount) &#123; return floor($amount * 100) / 100; &#125; # A function to format the $amount for display public function display_price($amount) &#123; return '£'.$amount.' inc '.$this-&gt;tax_rate.'% tax'; &#125;&#125;# So let's create an object for our program containing the# methods, with the tax rate set at 10%$funcs = new tax_functions(10);# Now let's compose our methods into a flow that adds tax, rounds# the figure and then formats it for display.# Note that to pass a method of an object as a callable, you need# to give an array of the object and method name. If you are using# static class methods, you can use the class::method notation instead$add_ten_percent = compose ( [$funcs, 'add_tax'], [$funcs, 'round_to'], [$funcs, 'display_price'] );# We've composed our $add_ten_percent function, but we may not want to use it# until much later in our script.# In the mean-time, another programmer inserts the following line in our# code in between...$funcs-&gt;set_rate(-20);# and then we try to use our $add_ten_percent function to add# tax to 19.99, hopefully getting the answer £21.98 inc 10% taxvar_dump( $add_ten_percent(19.99) ); # £15.99 inc -20% tax 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php# Grab our compose functionrequire('../Chapter 3/compose.php');# Define some maths functions$add_two = function ( $a ) &#123; return $a + 2;&#125;;$triple = function ( $a ) &#123; return $a * 3;&#125;;# Now we're going to create a "dirty" function to do some logging.$log_value = function ( $value ) &#123; # Do our impure stuff. echo "Impure Logging : $value\n"; # Oops, we mutated the parameter value... $value = $value * 234; # ...and returned it even more mutated return $value.' is a number';&#125;;# Now we're going to create a higher-order function which returns a# wrapped function which executes our impure function but returns# the original input parameter rather than any output from our impure# function. Note that we must pass $value to $impure_func by value and# not by reference (&amp;) to ensure it doesn't mess with it. Also see# the sections on the mutability of objects if you pass those through,# as the same concerns will apply here.$transparent = function ($impure_func) &#123; return function ($value) use ($impure_func) &#123; $impure_func($value); return $value; &#125;;&#125;;# Compose the maths functions together, with the $log_value impure function# made transparent by our wrapper function$do_sums = compose( $add_two, $transparent($log_value), $triple, $transparent($log_value) );# We should get the expected resultvar_dump( $do_sums(5) ); # 21 123456789101112131415161718192021&lt;?php# This is some typical procedural codeecho ("a is $a\n");$number = $a + 5;$number = $number * 2;for ($i = 0; $i &lt; 5; $i++) &#123; echo "We're doing procedural stuff here\n";&#125;;$b = 50;# Note the addition of a return statement.return $number; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php# First set some variables in global scope$a = 25;$b = 0;# Do a simple require of the file.$return_value = require "procedural.php";var_dump ( $return_value ); #60 - the script operated on our $a value of 25var_dump ( $a ); # 25var_dump ( $b ); # 50 - the script has mutated $b in the global scope# Reset $b$b = 0;# This function executes the file as if it were a function, within the# scope of the function. You can pass in a set of parameters as an array,# and the extract line creates variables in the function scope which# the code in the file can access. Finally, it requires the file and# returns the files return value as its own.$file_as_func = function ($filename, $params) &#123; extract ($params); return require $filename;&#125;;# We'll call it on our procedural.php file, with a couple of parameters# that have the same name but different values to our global $a and $bvar_dump ( $file_as_func( 'procedural.php', ['a'=&gt;50, 'b'=&gt;100] ) ); # 110# this clearly operated on our parameter "a" and not the global $avar_dump ( $a ); # 25var_dump ( $b ); # 0 - unchanged this time]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用函数式开发商业逻辑]]></title>
    <url>%2F2020%2F03%2F31%2F%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E5%BC%80%E5%8F%91%E5%95%86%E4%B8%9A%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在本章中，您将了解函数式编程的其他一些常见用法。您将首先查看功能代码如何帮助您管理程序中实现的业务逻辑。然后，您将了解什么是基于事件的编程，以及函数式编程如何帮助您应对管理传入事件的复杂性并保持数据流的顺畅。最后，您将快速了解异步编程，并了解为什么函数式编程在该领域也是有用的工具。 处理业务逻辑 Listing 6-1 business_data.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?php# First let's create core business data.# Rather than just define arrays, we're going to create functions# that return arrays. We'll discuss why in the chapter.# Every sale is either local, within our own country, or beyond$locations = function () &#123; return [ 'local', 'country', 'global' ];&#125;;# Each category of products that we sell has a different tax rate,# and that rate varies depending on where our purchaser is located$rates = function () &#123; return [ 'clothes' =&gt; [ 'local' =&gt; 0, 'country' =&gt; 5, 'global' =&gt; 10 ], 'books' =&gt; [ 'local' =&gt; 0, 'country' =&gt; 5, 'global' =&gt; 5 ], 'cheeses' =&gt; [ 'local' =&gt; 20, 'country' =&gt; 17.5, 'global' =&gt; 2 ] ];&#125;;# A list of our products, with their category and price$products = function () &#123; return [ 'T-shirt' =&gt; [ 'Category' =&gt; 'clothes', 'Price' =&gt; 15.99 ], 'Shorts' =&gt; [ 'Category' =&gt; 'clothes', 'Price' =&gt; 9.99 ], 'The Dictionary' =&gt; [ 'Category' =&gt; 'books', 'Price' =&gt; 4.99 ], 'War and Peace' =&gt; [ 'Category' =&gt; 'books', 'Price' =&gt; 29.45 ], 'Camembert' =&gt; [ 'Category' =&gt; 'cheeses', 'Price' =&gt; 3.50 ], 'Brie' =&gt; [ 'Category' =&gt; 'cheeses', 'Price' =&gt; 7.00 ] ];&#125;;# We only sell in dollars, but we format the prices differently# depending on the location of the purchaser.$price_formats = function () &#123; return [ 'local' =&gt; [ 'symbol' =&gt; '$', 'separator' =&gt; '.' ], 'country' =&gt; [ 'symbol' =&gt; '$', 'separator' =&gt; '.' ], 'global' =&gt; [ 'symbol' =&gt; 'USD ', 'separator' =&gt; ',' ] ];&#125;; Listing 6-2 business_logic.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php# Now we're going to create a set of functions which describe our business# logic. We're going to keep them as simple as possible, and reference# other functions within this file where possible to keep a# "single source of truth" for when we need to update them.# Load our business datarequire('business_data.php');# Fetch the details of a single product from the list of products$get_product_details = function ($product) use ($products) &#123; return $products()[$product];&#125;;# Get the category name from the details of a single product$get_category = function ($product_details) &#123; return $product_details['Category'];&#125;;# Get the tax rate for a category of products based on the location# of the purchaser$get_tax_rate = function ($category, $location) use ($rates)&#123; return $rates()[$category][$location];&#125;;# Get the net (tax exclusive) price of a product by name.$get_net_price = function ($product) use ($get_product_details) &#123; return $get_product_details($product)["Price"];&#125;;# Roll the above functions together to create a function that gets# the gross (tax inclusive) price for a certain quantity of products# based on the location of our purchaser.# Note that the tax is rounded using the PHP_ROUND_HALF_DOWN constant# to indicate the particular rounding method.$get_gross_price = function ($product, $quantity, $location) use ( $get_net_price, $get_tax_rate, $get_category, $get_product_details ) &#123; return round( $get_net_price($product) * $quantity * ( 1 + ( $get_tax_rate( $get_category( $get_product_details($product) ), $location) /100 ) ), 2, PHP_ROUND_HALF_DOWN );&#125;;# A function to get the actual amount of tax charged. Note that this doesn't# simply use the tax rate, as the actual amount charged may differ depending on# the rounding performed and any future logic added to $get_gross_price.# Instead we call $get_net_price and $get_gross_price and return the difference.$get_tax_charged = function ($product, $quantity, $location) use ($get_gross_price, $get_net_price) &#123; return $get_gross_price($product, $quantity, $location) - ( $quantity * $get_net_price($product) );&#125;;# Finally, a function to format a string to display the price, based# on the purchasers location.$format_price = function ($price, $location) use ($price_formats) &#123; $format = $price_formats()[$location]; return $format["symbol"] . str_replace('.', $format["separator"], (string) $price );&#125;; Listing 6-3 shopping.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?php# Import our set of pure functions which encapsulate our business logic.require('business_logic.php');# Now we can use them in our not so pure, not so functional code, safe in the# knowledge that they (should) provide us with consistent, correct results# regardless of what we do to the global or external state here.# Let's generate a shopping cart of products for a user in Bolivia$cart = ['Brie' =&gt; 3, 'Shorts' =&gt; 1, 'The Dictionary' =&gt; 2 ];$user = ["location" =&gt; 'global'];# One common function is to list the contents of the cart. Let's do# that hereecho "Your shopping cart contains :\n\n";echo "Item - Quantity - Net Price Each - Total Price inc. Tax\n";echo "=======================================================\n\n";foreach ($cart as $product =&gt; $quantity) &#123; $net_price = $get_net_price($product); $total = $get_gross_price($product, $quantity, $user["location"]); echo "$product - $quantity - $net_price - $total \n";&#125;;echo "=======================================================\n\n";# In a confirmation e-mail we may want to just list a (formatted) total price...$total_price = array_reduce( array_keys($cart), # loop through the cart and add gross price for each item function ($running_total, $product) use ( $user, $get_gross_price, $cart ) &#123; return $running_total + $get_gross_price( $product, $cart[$product], $user["location"] );&#125;, 0);echo "Thank you for your order.\n";echo $format_price($total_price, $user["location"]).' will ';echo "be charged to your card when your order is dispatched.\n\n";# And on the backend system we may have a routine that keeps details of# all the tax charged, ready to send to the Government. Let's create a# summary of the tax for this order.$tax_summary = array_reduce( array_keys($cart), # Loop through each item and add the tax charged to the relevant category function ($taxes, $product) use ( $user, $get_tax_charged, $cart, $get_category, $get_product_details ) &#123; $category = $get_category($get_product_details($product)); $tax = $get_tax_charged($product, $cart[$product], $user["location"]); isset($taxes[$category]) ? $taxes[$category] =+ $tax : $taxes[$category] = $tax; return $taxes;&#125;, []);echo "Tax Summary for this order :\n\n";var_dump($tax_summary); 基于事件的编程 Listing 6-5 install_event.txt 12345678910111213141516171819202122# Install the libevent library and it header filessudo apt-get install libevent-2.0-5 libevent-dev# Ensure that PECL (which comes as part of the PEAR package)# and the phpize command which PECL needs are installedsudo apt-get install php-pear php-dev# Install the event extensionsudo pecl install event# Finally make the extension available to the PHP CLI binary# by editing php.inisudo nano /etc/php/7.0/cli/php.ini# and adding the following line in the section where other .so# extensions are includeextension=event.so Listing 6-6 server_functions.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;?php# We'll create a set of functions that implement the logic that should# occur in response to the events that we'll handle.# Use our trusty partial function generatorrequire('../Chapter 3/partial_generator.php');# A generic function to output an HTTP header. $req is an object representing# the current HTTP request, which ensures that our function deals with the# right request at all times.$header = function ($name, $value, $req) &#123; $req-&gt;addHeader( $name , $value, EventHttpRequest::OUTPUT_HEADER );&#125;;# We are going to be serving different types of content (html, images etc.)# so we need to output a content header each time. Let's create a# partial function based on $header...$content_header = partial($header, 'Content-Type' );# and then make it specific for each type of content...$image_header = partial($content_header, "image/jpeg");$text_header = partial($content_header, "text/plain; charset=ISO-8859-1");$html_header = partial($content_header, "text/html; charset=utf-8");# The following function creates a "buffer" to hold our $content and# then sends it to the browser along with an appropriate HTTP status# code (Let's assume our requests always work fine so send 200 for everything).# Note that it's a pure function right up until we call sendReply. You could# return the EventBuffer instead, and wrap it all into an IO or Writer monad to# put the impure sendReply at the end if you wish.$send_content = function($req, $content) &#123; $output = new EventBuffer; $output-&gt;add($content); $req-&gt;sendReply(200, "OK", $output);&#125;;# The input parameters for our maths functions are held in the URI parameters.# The URI is held in the $req request object as a string. Let's get the# URI and parse out the parameters into an associative array.$parse_uri_params = function ($req) &#123; $uri = $req-&gt;getUri(); parse_str ( # Grab just the parameters (everything after the ?) substr( $uri, strpos( $uri, '?' ) + 1 ), # and parse it into $params array $params ); return $params;&#125;;# Get the URI "value" parameter$current_value = function($req) use ($parse_uri_params) &#123; return $parse_uri_params($req)["value"];&#125;;# Get the URL "amount" parameter$amount = function($req) use ($parse_uri_params) &#123; return $parse_uri_params($req)["amount"];&#125;;# A function to send the results of one of our maths functions which follow.$send_sum_results = function($req, $result) use ( $html_header, $send_content) &#123; # Create some HTML output, with the current result, plus some links # to perform more maths functions. Note the uri parameters contain # all of the state needed for the function to give a deterministic, # reproducable result each time. We also include some links to # the other utility functions. When you visit them, note that you # can use your browser back button to come back to the maths functions # and carry on where you left off, as the parameters the functions # need are provided by the URI parameters and no "state" has been # altered of lost $output = &lt;&lt;&lt;ENDCONTENT &lt;p&gt;&lt;b&gt;The current value is : $result&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/add?value=$result&amp;amount=3"&gt;Add 3&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/add?value=$result&amp;amount=13"&gt;Add 13&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/add?value=$result&amp;amount=50"&gt;Add 50&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/subtract?value=$result&amp;amount=2"&gt;Subtract 2&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/subtract?value=$result&amp;amount=5"&gt;Subtract 5&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/multiply?value=$result&amp;amount=2"&gt;Multiply by 2&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/multiply?value=$result&amp;amount=4"&gt;Multiply by 4&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/divide?value=$result&amp;amount=2"&gt;Divide by 2&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/divide?value=$result&amp;amount=3"&gt;Divide by 3&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/floor?value=$result"&gt;Floor&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;A href="/show_headers"&gt;[Show headers]&lt;/a&gt;&amp;nbsp; &lt;a href="/really/cute"&gt;[Get cat]&lt;/a&gt;&amp;nbsp; &lt;a href="/close_server"&gt;[Close down server]&lt;/a&gt;&lt;/p&gt;ENDCONTENT; # Send the content header and content. $html_header($req); $send_content($req, $output);&#125;;# These are our key maths functions. Each one operates like a good Functional# function by only using the values supplied as input parameters, in this# case as part of $req. We call a couple of helper functions ($current_value# and $amount) to help extract those values, $req isn't necessarily# immutable (we could alter values or call methods), but we'll use# our discipline to keep it so right up until we're ready to send_contents.# While we don't formally "return" a value, $send_sum_results effectively# acts a return statement for us. Any return value would simply go back to# libevent (which is the caller, and it just ignore it).# If we want to keep to strictly using explicit return statements, we could# wrap this in another function that does the same as $send_sum_results, (and# for the same reason wouldn't have a return statement) or we could create an# Writer monad or similar to gather the results and only output to the browser# at the end. For this simple example we'll go with using $send_sum_results# though for simplicity and clarity.$add = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) + $amount($req) );&#125;;$subtract = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) - $amount($req) );&#125;;$multiply = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) * $amount($req) );&#125;;$divide = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) / $amount($req) );&#125;;$floor = function ($req) use ($send_sum_results, $current_value) &#123; $send_sum_results($req, floor($current_value($req)) );&#125;;# Now we'll define some utility functions# Grab the HTTP headers from the current request and return them as an array$get_input_headers = function ($req) &#123; return $req-&gt;getInputHeaders();&#125;;# A recursive function to loop through an array of headers and return# an HTML formatted string$format_headers = function ($headers, $output = '') use (&amp;$format_headers) &#123; # if we've done all the headers, return the $output if (!$headers) &#123; return $output; &#125; else &#123; # else grab a header off the top of the array, add it to the # $output and recursively call this function on the remaining headers. $output .= '&lt;pre&gt;'.array_shift($headers).'&lt;/pre&gt;'; return $format_headers($headers, $output); &#125;;&#125;;# Use the function above to format the headers of the current request for# viewing$show_headers = function ($req) use ($html_header, $send_content, $format_headers) &#123; $html_header($req); $send_content($req, $format_headers( $req-&gt;getInputHeaders() ) );&#125;;# Let's handle all requests, so there are no 404's$default_handler = function ($req) use ($html_header, $send_content) &#123; $html_header($req); $output = '&lt;h1&gt;This is the default response&lt;/h1&gt;'; $output .= '&lt;p&gt;Why not try &lt;a href="/add?value=0&amp;amount=0"&gt;some math&lt;/a&gt;&lt;/p&gt;'; $send_content($req, $output);&#125;;# Ensure that there are sufficient supplies of cat pictures available# in all corners of the Internet$send_cat = function($req) use ($image_header, $send_content) &#123; # Note we send a different header so that the browser knows # a binary image is coming $image_header($req); # An impure function, you could alway use an IO monad or # embed the image binary data here! $send_content($req, file_get_contents('cat.jpg'));&#125;;# A function to shut down the web server script by visiting a particular URI.$close_server = function($req, $base) use ($html_header, $send_content) &#123; $html_header($req); $send_content($req, '&lt;h1&gt;Server is now shutting down&lt;/h1&gt;'); $base-&gt;exit();&#125;; Listing 6-7 web_server.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?php# Let's get all of our functions that implement our# business logicrequire('server_functions.php');# Now we're ready to build up our event framework# First we create an "EventBase", which is libevent's vehicle for holding# and polling a set of events.$base = new EventBase();# Then we add an EventHttp object to the base, which is the Event# extension's helper for HTTP connections/events.$http = new EventHttp($base);# We'll choose to respond to just GET HTTP requests$http-&gt;setAllowedMethods( EventHttpRequest::CMD_GET );# Next we'll tie our functions we created above to specific URIs using# function callbacks. We've created them all as anonymous/closure functions# and so we just bind the variable holding them to the URI. We# could use named functions if we want, suppling the name in "quotes".# In fact, you can use any kind of callable here. All will be called# with the EventHttpRequest object representing the current request as# the first paramter. If you need other parameters here for your callback,# you can specify them as an optional third parameter below.# Our set of maths functions...$http-&gt;setCallback("/add", $add);$http-&gt;setCallback("/subtract", $subtract);$http-&gt;setCallback("/multiply", $multiply);$http-&gt;setCallback("/divide", $divide);$http-&gt;setCallback("/floor", $floor);# A function to shut down the server, which needs access to the server $base$http-&gt;setCallback("/close_server", $close_server, $base);# A utility function to explore the headers your browser is sending$http-&gt;setCallback("/show_headers", $show_headers);# And a compulsory function for all internet connected devices$http-&gt;setCallback("/really/cute", $send_cat);# Finally we'll add a default function callback to handle all other URIs.# You could, in fact, just specify this default handler and not those# above, and then handle URIs as you wish from inside this function using# it as a router function.$http-&gt;setDefaultCallback($default_handler);# We'll bind our script to an address and port to enable it to listen for# connections. In this case, 0.0.0.0 will bind it to the localhost, and# we'll choose port 12345$http-&gt;bind("0.0.0.0", 12345);# Then we start our event loop using the loop() function of our base. Our# script will remain in this loop indefinitely, servicing http requests# with the functions above, until we exit it by killing the script or,# more ideally, calling $base-&gt;exit() as we do in the close_server()# function above.$base-&gt;loop();# We'll only hit this point in the script if some code has called# $base-&gt;exit();echo "Server has been gracefully closed\n";]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP7的函数式编程]]></title>
    <url>%2F2020%2F03%2F31%2FPHP7%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 函数式编程函数式编程是一种声明式编程范式，它将代码抽象为纯的，不可变的，无副作用的函数，从而使程序员可以将这些函数组合在一起，从而使程序易于推理。 函数式编程的函数通常称为纯函数，具有几个重要特征，可以用PHP的语法模仿但不强制使用。纯函数具有以下特征： 引用透明 无副作用 没有外部依赖性 在接下来的几章中，我将详细讨论这些函数的含义，但它们归结为一个功能齐全的小型“黑盒子”，该函数接受定义明确的输入，产生定义明确的输出，以及给定相同的输入总是产生相同的输出。 特别是，该函数仅作用于给定的输入（它不考虑任何外部状态或数据，而仅依赖于被调用的参数），并且它唯一的作用就是返回一些输出（ 每次您输入相同的输入时，输入的内容都会相同）； 因此，它不会改变程序或系统自身之外的状态。 我将讨论不变性，即本质上是无法更改值的。起初这似乎是一个弊端，而不是收益，但是当在接下来的两章中将所有这些概念综合在一起时，您会发现不变性在函数式编程的灵活配方性质中起着关键作用，并且是其中之一。 这些因素使您可以轻松地推断出函数式代码。 Listing 2-3 backtrace.php 123456789101112131415161718192021222324&lt;?phpfunction prepare_text($text) &#123; return make_headline($text);&#125;function make_headline($text) &#123; return add_h_tags( upper_case($text) );&#125;function upper_case($text) &#123; return strtoupper($text);&#125;function add_h_tags($text) &#123; debug_print_backtrace(); return '&lt;h1&gt;'.$text.'&lt;/h1&gt;';&#125;$title = prepare_text('testing');echo $title; Listing 2-4 backtrace-output.txt 1234#0 add_h_tags(TESTING) called at [backtrace.php:12]#1 make_headline(testing) called at [backtrace.php:6]#2 prepare_text(testing) called at [backtrace.php:30]&lt;h1&gt;TESTING&lt;/h1&gt; 可变性和不变性如果某些东西是可变的，则意味着您可以更改它。 变量是可变的。 在函数式编程中，您希望值（由函数表示）是不可变的。 PHP对不变性的支持有限，主要表现为使用define（）函数或const关键字定义的“常量”形式。 在使用define（）和const时，如何以及如何声明常量的声明之间有一些区别，但是一旦声明，由这两种方法创建的常量都是相同的。 两者的共同点是只有标量或数组才能为常数。 清单2-7尝试从包含匿名函数的变量中创建一个常量。 清单2-8显示了输出。 Listing 2-7. constant-func.php 12345678910&lt;?php$double = function ($input) &#123; return $input * 2;&#125;;define('DOUBLE', $double);echo "Double 2 is " . $double(2) . "\n";echo "Double 2 is " . DOUBLE(2) . "\n"; Listing 2-8. constant-func-output.txt 12345678PHP Warning: Constants may only evaluate to scalar values or arrays in constant-func.php online 8Double 2 is 4PHP Fatal error: Uncaught Error: Call to undefined function DOUBLE() in constant-func.php:12Stack trace:#0 &#123;main&#125;thrown in constant-func.php on line 12 在这里，您可以看到在尝试使用在define（）中包含函数的变量时收到警告，并且当您尝试使用DOUBLE常量时，您将得到确认（通过致命错误），该确确实定义失败。 因此，在没有PHP太多帮助的情况下，您将需要在编码时通过纪律确保自己不变。帮助实现这一目标的关键方法之一是避免使用分配，而在阅读本书时，您将研究实现这一目标的方法。当您告诉他们您正在使用PHP进行函数式编程时，人们会指出PHP中缺乏对不变性的支持（与其他语言相比）。但是，它丝毫不会阻止您使用PHP编写功能程序。您只需要在编写代码时牢记它。 在观看自己的工作的同时，还需要留意PHP的工作。需要考虑的关键是PHP自身的函数如何对变量进行操作。例如，函数sort（）对传递的数组进行突变（即排序），而不是返回作为旧数组排序版本的新数组（并使旧数组保持不变）。但是，您可以很容易地使自己的sort（）的不可变版本（请参见清单2-9和清单2-10）。 Listing 2-9. sort.php 123456789101112131415161718192021&lt;?phpfunction immutable_sort($array) &#123; sort($array); return $array;&#125;$vegetables = ['Carrot', 'Beetroot', 'Asparagus'];# Sort using our immutable function$ordered = immutable_sort( $vegetables );print_r( $ordered );# Check that $vegetables remains unmutatedprint_r( $vegetables );# Do it the mutable waysort( $vegetables );# And see that the original array is mutatedprint_r( $vegetables ); Listing 2-10. sort-output.txt 123456789101112131415161718Array( [0] =&gt; Asparagus [1] =&gt; Beetroot [2] =&gt; Carrot)Array( [0] =&gt; Carrot [1] =&gt; Beetroot [2] =&gt; Asparagus)Array( [0] =&gt; Asparagus [1] =&gt; Beetroot [2] =&gt; Carrot) 之所以可行，是因为默认情况下，PHP函数参数是通过值而不是通过引用传递的。 这意味着在调用函数时，它会获取您作为参数提供的任何变量的副本，而不是对变量本身的引用。 该函数对该副本所做的任何操作均不会影响原始变量。PHP确实允许您通过引用传递参数（sort（）用来改变原始数组的引用），但这不是默认值。 传入对象或资源时，就是传入对象或资源变量，它是指向该对象或资源的指针。 该变量仍按值传递； 但是，变量的新副本仍指向原始对象或资源，因此它的行为与按值传递相似。 您将在第7章中深入探讨该问题。 在大多数情况下，显而易见的是，哪些函数会改变其参数。 他们通常不提供其输出作为返回值，但有些人则将按值和按引用参数混合使用，因此如果不确定，请务必查阅PHP手册。 什么是函数？我将从头开始介绍函数，因为必须了解PHP如何实现函数的基础知识以及处理函数的不同方法，才能理解如何在PHP中实现函数编程。 在本章的过程中，您将对函数的确切功能有了更好的了解。 但这是一个很好的开始定义： 函数是一组指令，封装在一个独立的，可重用的代码块中。 PHP使您可以使用几种不同的函数调用，接下来将依次介绍。 命名函数以下是命名函数的主要限制： 它们不能被销毁。 一旦定义，其功能（功能中的代码）就无法更改。 它们很难“传递”，因为它们无法分配给变量。 只能将函数名称分配给变量，而不是函数本身。 尽管可以通过动态方式处理已命名函数，但是call_user_func()函数确实提供了一种以这种方式工作的方法，如清单2-15和清单2-16所示，该方法的功能有限。 Listing 2-15. userfunc.php 1234567891011&lt;?phpfunction list_fruit($item) &#123;return ['apple','orange','mango'][$item];&#125;function list_meat($item) &#123;return ['pork','beef','human'][$item];&#125;$the_list = 'list_fruit';var_dump( call_user_func($the_list, 2) );$the_list = 'list_meat';var_dump( call_user_func($the_list, 1) ); Listing 2-16. userfunc-output.txt 12string(5) &quot;mango&quot;string(4) &quot;beef&quot; 如您所见，您可以将函数的名称（作为字符串）传递给call_user_func（）（加上要提供该函数的任何参数），并且call_user_func（）将从您自己调用的函数中返回返回值返回值。如您所见，您可以在$ the_list中更改该函数的名称（因为它是一个字符串变量），然后再次运行call_user_func（），这一次运行另一个函数。 这可以使您具有一点活力，但功能有限。一种类似的方法称为变量函数，您将在下一节中对其进行介绍。从PHP 7.0开始，您还可以使用PHP闭包对象的fromCallable静态方法将命名函数包装到称为闭包的对象中，稍后将进行介绍。 命名函数的范围也不直观。正如您将在本章后面的“范围”部分中看到的那样，当您在函数中创建变量时，默认情况下，该函数之外的代码将无法使用该变量。但是，在另一个函数中实例化一个命名函数时，会在全局范围内创建该函数，以便可以从任何地方调用它，因此还需要具有全局唯一名称。考虑清单2-17中嵌套函数的演示，该函数返回一个字符串来说明其嵌套（清单2-18显示了输出）。 123456789101112131415161718192021222324252627282930313233343536&lt;?phpfunction a() &#123; function b() &#123; return "a -&gt; b"; &#125; return "a";&#125;function c() &#123; function d() &#123; function e() &#123; return "c -&gt; d -&gt; e"; &#125; return "c -&gt; d"; &#125; return "c";&#125;var_dump( a() );var_dump( b() );var_dump( c() );var_dump( d() );var_dump( e() ); Listing 2-18. name-scope-output.txt 12345string(1) &quot;a&quot;string(6) &quot;a -&gt; b&quot;string(1) &quot;c&quot;string(6) &quot;c -&gt; d&quot;string(11) &quot;c -&gt; d -&gt; e&quot; Listing 2-19. name-scope2.php 12345678910111213141516171819202122232425262728&lt;?phpfunction a() &#123; function b() &#123; return "a -&gt; b"; &#125; return "a";&#125;function c() &#123; function d() &#123; function e() &#123; return "c -&gt; d -&gt; e"; &#125; return "c -&gt; d"; &#125; return "c";&#125;var_dump( a() );var_dump( b() );var_dump( d() );var_dump( c() );var_dump( e() ); Listing 2-20. name-scope2-output.txt 123456string(1) &quot;a&quot;string(6) &quot;a -&gt; b&quot;PHP Fatal error: Uncaught Error: Call to undefined function d() in name-scope2.php:38Stack trace:#0 &#123;main&#125;thrown in name-scope2.php on line 38 Listing 2-21. name-scope3.php 12345678910111213141516171819202122&lt;?phpfunction f() &#123; function g() &#123; return "1st g()"; &#125;; return "f()";&#125;function h() &#123; function g() &#123; return "2nd g()"; &#125;; return "h()";&#125;var_dump( f() );var_dump( g() );var_dump( h() ); Listing 2-22. name-scope3-output.txt 1234string(3) &quot;f()&quot;string(7) &quot;1st g()&quot;PHP Fatal error: Cannot redeclare g() (previously declared in name-scope3.php:7) in name-scope3.php on line 17 可变函数Listing 2-23. variable.php 1234567891011121314151617181920212223242526272829303132&lt;?phpfunction vehicles( $index ) &#123; $types = ["car", "motorbike", "tractor"]; return $types[$index];&#125;function animals( $index ) &#123; $types = ["cow", "pig", "chicken", "horse"]; return $types[$index];&#125;$get_thing = 'animals'; # string with the name of a functionvar_dump( $get_thing(2) ); # add ($index) to call it$get_thing = 'vehicles'; # change the functionvar_dump( $get_thing(2) ); #same "code", different function# Just to show that $get_thing is just a# standard string, and nothing special...$get_thing = strrev('selcihev'); # do string thingsvar_dump( $get_thing ); # it's a stringvar_dump( $get_thing(2) ); # call itvar_dump( $get_thing ); # afterwards, still just a stringunset( $get_thing ); # we can destroy it, because it's a stringvar_dump( $get_thing );var_dump( vehicles(2) ); # But the function still exists# However, it needs to be set to a function that exists$get_thing = 'people';var_dump( $get_thing(2) ); Listing 2-24. variable-output.txt 123456789101112string(7) &quot;chicken&quot;string(7) &quot;tractor&quot;string(8) &quot;vehicles&quot;string(7) &quot;tractor&quot;string(8) &quot;vehicles&quot;PHP Notice: Undefined variable: get_thing in variable.php on line 41NULLstring(7) &quot;tractor&quot;PHP Fatal error: Uncaught Error: Call to undefined function people() in variable.php:49Stack trace:#0 &#123;main&#125;thrown in variable.php on line 49 Listing 2-25. constructs.php 123&lt;?php$var_func = 'echo';$var_func('hello world!'); Listing 2-26. constructs-output.php 1234PHP Fatal error: Uncaught Error: Call to undefined function echo() in constructs.php:5Stack trace:#0 &#123;main&#125;thrown in constructs.php on line 5 Listing 2-27. constructs2.php 1234567&lt;?phpfunction my_echo($string) &#123; echo $string;&#125;$var_func = 'my_echo';$var_func('hello world!'); Listing 2-28. constructs2-output.php 1hello world! 返回值Listing 2-29. null-return.php 12345678910111213141516171819202122&lt;?phpfunction reverse($string) &#123; $string = strrev($string);&#125;function capitals($string) &#123; if ($string != 'banana') &#123; $string = strtoupper($string); return $string; &#125;&#125;# no return statementvar_dump( reverse('hello') );# returns a valuevar_dump( capitals('peaches') );# execution flow misses return statementvar_dump( capitals('banana') ); Listing 2-30. null-return-output.txt 123NULLstring(7) &quot;PEACHES&quot;NULL Listing 2-31. null-return2.php 12345678910111213141516&lt;?phpfunction fruits($type) &#123; if ($type == 'mango') &#123; return 'Yummy!'; &#125; else &#123; return; &#125;&#125;var_dump( fruits('kiwi') );var_dump( fruits('pomegranate') );var_dump( fruits('mango') ); Listing 2-32. null-return2-output.txt 123NULLNULLstring(6) &quot;Yummy!&quot; Listing 2-33. return.php 1234567891011&lt;?phpfunction my_funct() &#123; $a = 23; return $a; $a = 45; return $a;&#125;var_dump( my_funct() ); Listing 2-34. return-output.txt 1int(23)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级函数式技巧]]></title>
    <url>%2F2020%2F03%2F30%2F%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 到目前为止，您已经对编程的功能风格和优点有了一定的了解它可以带来。您可以将这些技术从今天开始使用，而无需进一步阅读。理想情况下，不过，我激发了您的胃口，以进一步发展它，并了解更多可用于您的功能性技术程序员的工具箱。在本章中，您将了解函数式编程的一些更高级的方面，这些方面将使您以越来越实用的方式构建PHP代码。本章是您之前的“理论”的最后一部分在本书的下一部分中开始讲一些实际的例子。您将从查看curring开始，扩展了部分函数应用程序的概念，将其分解为可自动化的方式较低种族的版本。接下来，您将了解寓言中的monad，它们可帮助您进行程序流控制和让您处理在现实世界中工作时会遇到的讨厌的副作用。之后，您将了解蹦床，这是一种可控制递归的方法。最后，我会讲关于使用类型声明的严格类型与动态类型的讨论很少，尽管这不是严格的功能概念在某些方面可能有用（在其他方面则没有）。 柯里化函数柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。 实例首先我们定义一个函数:1def add(x:Int,y:Int)=x+y 那么我们应用的时候，应该是这样用：add(1,2) 现在我们把这个函数变一下形：1def add(x:Int)(y:Int) = x + y 那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。 实现过程add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。 实质上最先演变成这样一个方法：1def add(x:Int)=(y:Int)=&gt;x+y 那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。1val result = add(1) 返回一个result，那result的值应该是一个匿名函数：(y:Int)=&gt;1+y 所以为了得到结果，我们继续调用result。1val sum = result(2) 最后打印出来的结果就是3。 完整实例下面是一个完整实例：1234567891011object Test &#123; def main(args: Array[String]) &#123; val str1:String = "Hello, " val str2:String = "Scala!" println( "str1 + str2 = " + strcat(str1)(str2) ) &#125; def strcat(s1: String)(s2: String) = &#123; s1 + s2 &#125;&#125; 执行以上代码，输出结果为： $ scalac Test.scala$ scala Teststr1 + str2 = Hello, Scala! 名义上只接受部分参数，但其实底下偷偷补足其他参数 123456789101112131415var bind = function(fn, a)&#123; return function(b)&#123; return fn(a, b) &#125;&#125;var mult = function(a, b)&#123; return a*b&#125;// 绑定mult的第一个参数a，譬如指定该参数为2var time2 = bind(mult, 2)// 调用新函数time2time(1) // 得2time(3) // 得6 严谨一点来说，currying之后的函数只接受一个参数，这比一般的部分绑定函数形式上更加精炼。 柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。 柯里化一个求和函数按照分步求值，我们看一个简单的例子 var concat3Words = function (a, b, c) { return a+b+c;}; var concat3WordsCurrying = function(a) { return function (b) { return function (c) { return a+b+c; }; };};console.log(concat3Words(“foo “,”bar “,”baza”)); // foo bar bazaconsole.log(concat3WordsCurrying(“foo “)); // [Function]console.log(concat3WordsCurrying(“foo “)(“bar “)(“baza”)); // foo bar baza可以看到， concat3WordsCurrying(“foo “) 是一个 Function，每次调用都返回一个新的函数，该函数接受另一个调用，然后又返回一个新的函数，直至最后返回结果，分布求解，层层递进。（PS：这里利用了闭包的特点） 那么现在我们更进一步，如果要求可传递的参数不止3个，可以传任意多个参数，当不传参数时输出结果？ 首先来个普通的实现： var add = function(items){ return items.reduce(function(a,b){ return a+b });};console.log(add([1,2,3,4]));但如果要求把每个数乘以10之后再相加，那么：12345678var add = function (items,multi) &#123; return items.map(function (item) &#123; return item*multi; &#125;).reduce(function (a, b) &#123; return a + b &#125;);&#125;;console.log(add([1, 2, 3, 4],10)); 好在有 map 和 reduce 函数，假如按照这个模式，现在要把每项加1,再汇总，那么我们需要更换map中的函数。 下面看一下柯里化实现：1234567891011121314151617181920var adder = function () &#123; var _args = []; return function () &#123; if (arguments.length === 0) &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; [].push.apply(_args, [].slice.call(arguments)); return arguments.callee; &#125;&#125;; var sum = adder();console.log(sum); // Functionsum(100,200)(300); // 调用形式灵活，一次调用可输入一个或者多个参数，并且支持链式调用sum(400);console.log(sum()); // 1000 （加总计算） ` 上面 adder是柯里化了的函数，它返回一个新的函数，新的函数接收可分批次接受新的参数，延迟到最后一次计算。 通用的柯里化函数更典型的柯里化会把最后一次的计算封装进一个函数中，再把这个函数作为参数传入柯里化函数，这样即清晰，又灵活。例如 每项乘以10, 我们可以把处理函数作为参数传入：123456789101112131415161718192021222324var currying = function (fn) &#123; var _args = []; return function () &#123; if (arguments.length === 0) &#123; return fn.apply(this, _args); &#125; Array.prototype.push.apply(_args, [].slice.call(arguments)); return arguments.callee; &#125;&#125;;var multi=function () &#123; var total = 0; for (var i = 0, c; c = arguments[i++];) &#123; total += c; &#125; return total;&#125;;var sum = currying(multi); sum(100,200)(300);sum(400);console.log(sum()); // 1000 （空白调用时才真正计算） 这样 sum = currying(multi)，调用非常清晰，使用效果也堪称绚丽，例如要累加多个值，可以把多个值作为做个参数 sum(1,2,3)，也可以支持链式的调用，sum(1)(2)(3) 柯里化的基础上面的代码其实是一个高阶函数（high-order function）, 高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，并返回一个新函数。此外，还依赖与闭包的特性，来保存中间过程中输入的参数。即： 函数可以作为参数传递函数能够作为函数的返回值闭包柯里化的作用延迟计算。上面的例子已经比较好低说明了。参数复用。当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化候选。动态创建函数。这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了重复计算。或者可以通过将要传入调用函数的参数子集，部分应用到函数中，从而动态创造出一个新函数，这个新函数保存了重复传入的参数（以后不必每次都传）。例如，事件浏览器添加事件的辅助方法： 1234567891011var addEvent = function(el, type, fn, capture) &#123; if (window.addEventListener) &#123; el.addEventListener(type, function(e) &#123; fn.call(el, e); &#125;, capture); &#125; else if (window.attachEvent) &#123; el.attachEvent("on" + type, function(e) &#123; fn.call(el, e); &#125;); &#125; &#125;; 每次添加事件处理都要执行一遍 if…else…，其实在一个浏览器中只要一次判定就可以了，把根据一次判定之后的结果动态生成新的函数，以后就不必重新计算。 123456789101112131415var addEvent = (function()&#123; if (window.addEventListener) &#123; return function(el, sType, fn, capture) &#123; el.addEventListener(sType, function(e) &#123; fn.call(el, e); &#125;, (capture)); &#125;; &#125; else if (window.attachEvent) &#123; return function(el, sType, fn, capture) &#123; el.attachEvent("on" + sType, function(e) &#123; fn.call(el, e); &#125;); &#125;; &#125;&#125;)(); 这个例子，第一次 if…else… 判断之后，完成了部分计算，动态创建新的函数来处理后面传入的参数，这是一个典型的柯里化。 您在上一章中了解了部分函数的优点，并且我提到了一种用于自动分解功能。分解是分解多arar函数的行为通过固定一个或多个参数的值，将其转换为具有较小签名的函数。方法您要查看的自动分解称为currying，并以Haskell Curry（一个男人其名称（字面上）是整个函数式编程！咖喱确实与部分功能的应用密切相关，乍看之下它是咖喱功能看起来很像您创建的部分函数生成器。但是，有一些微妙但重要的差异。就是说，部分功能应用程序只是一种currying（或者相反），取决于您与谁交谈），因此每种方法的好处是相似的。您选择使用哪个取决于什么根据您的情况为您工作。在部分函数生成器中，您获取了一个函数，以及一个绑定到第一个参数的值，然后返回了一个签名短了一个参数的函数。在currying中，您可以使其更加灵活通过获取一个函数和一个或多个参数的列表并将所有给定的参数绑定到新函数回到。到目前为止，咖喱相似（如果更笼统）。要获得功能的实际结果，您需要到达已绑定和/或传递函数所有参数的位置，函数将然后执行并返回一个值。 生成器和currying函数返回的部分函数（在两种情况下均为闭包）是把握两者之间差异的关键。使用您看过的简单的部分生成器，返回的函数是签名减少的函数（即，叫它）。如果您想进一步减少它来创建另一个局部函数，则可以调用局部函数在返回的闭包上再次生成函数。相反，闭包是由一个循环例程返回的是一项独立功能，可以自动自动进行进一步处理。例如，如果您有一个具有五个参数的函数，并且通过固定两个参数来进行咖喱处理，则将得到一个接受三个闭包参数。如果然后再用一个参数调用该闭包，则不要执行不完整的闭包参数集（如前面显示的部分函数所示），它将自动咖喱自身并返回另一个接受两个参数的闭包（如果使用，则再次具有进一步咖喱自己的能力另一个参数）。将此与生成器的部分功能进行对比；如果您提供一个接受三个部分函数的参数，它将尝试使用简化的参数集执行，通常会导致错误。 与往常一样，用一个例子可能会更清楚。编写适当形式的currying函数并非易事，您将使用Matteo Giachino编写的名为php-curry的库来帮助您。这是可用的在GitHub上的[https://github.com/matteosister/php-curry]上，可以通过Composer或如清单4-1和清单4-2所示，直接包含它。 Listing 4-1. currying.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpinclude('Curry/Placeholder.php');include('Curry/functions.php');use Cypress\Curry as C;# Let's make a function place an order with our chef# for some delicious curry (the food, not the function)$make_a_curry = function($meat, $chili, $amount, $extras, $where) &#123;return ["Meat type"=&gt;$meat,"Chili hotness"=&gt;$chili,"Quantity to make"=&gt;$amount,"Extras"=&gt;$extras,"Eat in or take out"=&gt;$where];&#125;;# We think that everyone will want a mild Rogan Josh, so# let's curry the function with the first two parameters$rogan_josh = C\curry($make_a_curry, 'Lamb','mild');# $rogan_josh is now a closure that will continue to# curry with the arguments we give it$dishes = $rogan_josh("2 portions");# likewise $dishes is now a closure that will continue# to curry$meal = $dishes('Naan bread');# and so on for meal. However, we only have 1 parameter# which we've not used, $where, and so when we add# that, rather than returning another closure, $meal# will execute and return the result of $make_a_curry$order = $meal('Eat in');print_r( $order );# To show that our original function remains unmutated, when# we realize that actually people only want 1 portion of curry# at a time, with popadoms, and they want to eat it at home, we# can curry it again. This time, the parameters we want to bind# are at the end, so we use curry_right.$meal_type = C\curry_right($make_a_curry, 'Take out', 'Poppadoms', '1 portion');$madrass = $meal_type('hot', 'Chicken');print_r( $madrass );# We could curry the function with all of the parameters# provided, this creates a parameter-less closure but doesn't# execute it until we explicitly do so.$korma = C\curry($make_a_curry,'Chicken', 'Extra mild', 'Bucket full', 'Diet cola', 'Eat in');print_r($korma()); Listing 4-2. currying-output.txt 123456789101112131415161718192021222324Array( [Meat type] =&gt; Lamb [Chili hotness] =&gt; mild [Quantity to make] =&gt; 2 portions [Extras] =&gt; Naan bread [Eat in or take out] =&gt; Eat in)Array( [Meat type] =&gt; Chicken [Chili hotness] =&gt; hot [Quantity to make] =&gt; 1 portion [Extras] =&gt; Poppadoms [Eat in or take out] =&gt; Take out)Array( [Meat type] =&gt; Chicken [Chili hotness] =&gt; Extra mild [Quantity to make] =&gt; Bucket full [Extras] =&gt; Diet cola [Eat in or take out] =&gt; Eat in)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程入门]]></title>
    <url>%2F2020%2F03%2F29%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么要使用诸如map，filter和reduce之类的函数代替foreach循环？ 一个函数调用多次，函数状态会在内存中新生成一个“副本”吗？ Map,Filter,Reduce Listing 3-1 map_filter_reduce.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?php// 配料$ingredients = [ "cod", // 鳕鱼 "beef", "kiwi", // 奇异果 "egg", "vinegar" // 醋];// 菜式$dish_types = [ "pie", "smoothie", // 冰沙 "tart", // 果馅饼 "ice cream", "crumble" // 酥皮水果甜点 ];// 烘焙食品$baked = [ "pie", "tart", "crumble", "cake"];# 通过将一种配料与一道菜相结合来创建食谱$make_recipe = function ($ingredient, $dish) &#123; return $ingredient.' '.$dish;&#125;;# 通过查看其中是否包含$baked数组中的任何单词，来检查某个食谱是否包含烘焙食品$is_baked = function ($recipe) use ($baked) &#123; return array_filter($baked, function($item) use ($recipe) &#123; return strpos($recipe, $item) !== false; &#125; );&#125;;# 得到最长菜谱的函数$get_longest = function ($current_longest, $recipe) &#123; return strlen($recipe) &gt; strlen($current_longest) ? $recipe : $current_longest;&#125;;# PHP函数shuffle并非一成不变，它更改了给定的数组。# 因此，我们创建了自己的不可变的$reshuffle函数。# 请注意，shuffle还具有副作用（它使用外部熵源使数组随机化），因此不是参照透明的。但这现在就可以了。// shuffle 洗牌$reshuffle = function ($array) &#123; shuffle($array); return $array;&#125;;$all_recipes = array_map($make_recipe, $reshuffle($ingredients), $reshuffle($dish_types));print_r($all_recipes);$baking_recipes = array_filter($all_recipes, $is_baked);print_r($baking_recipes);$best_recipe = array_reduce($baking_recipes, $get_longest, '');print_r($best_recipe); Listing 3-2 map_filter_reduce-output.txt 123456789101112131415Array( [0] =&gt; vinegar ice cream [1] =&gt; kiwi tart [2] =&gt; cod crumble [3] =&gt; egg smoothie [4] =&gt; beef pie)Array( [1] =&gt; kiwi tart [2] =&gt; cod crumble [4] =&gt; beef pie)cod crumble 递归函数 Listing 3-3 shopping_list1.php 1234567891011121314151617&lt;?php$shopping = [ "fruits" =&gt; [ "apples" =&gt; 7, "pears" =&gt; 4, // 梨 "bananas" =&gt; 6 ], "bakery" =&gt; [ // 面包店 "bread" =&gt; 1, "apple pie" =&gt; 2 ], "meat" =&gt; [ "sausages" =&gt; 10, // 香肠 "steaks" =&gt; 3, "chorizo" =&gt; 1 // 乔里索香肠 ]]; Listing 3-4 foreach.php 1234567891011121314&lt;?phprequire('shopping_list1.php');$total = 0;foreach ($shopping as $group) &#123; foreach ($group as $food =&gt; $count) &#123; $total += $count; &#125;&#125;echo "Total items to purchase : $total\n"; Listing 3-5 foreach-output.txt 1Total items to purchase : 34 Listing 3-6 shopping_list2.php 1234567891011121314151617181920&lt;?php$shopping = [ "fruits" =&gt; [ "apples" =&gt; [ "red" =&gt; 3, "green" =&gt; 4 ], "pears" =&gt; 4, "bananas" =&gt; 6 ], "bakery" =&gt; [ "bread" =&gt; 1, "apple pie" =&gt; 2 ], "meat" =&gt; [ "sausages" =&gt; 10, "steaks" =&gt; 3, "chorizo" =&gt; 1 ]]; Listing 3-7 foreach2-output.txt 1234PHP Fatal error: Uncaught Error: Unsupported operand types in foreach.php:11Stack trace:#0 &#123;main&#125;thrown in foreach.php on line 11 Listing 3-8 recursive.php 1234567891011121314151617181920212223242526272829&lt;?phpfunction count_total($list) &#123; # 用一个变量来保存总数 $total = 0; # 遍历数组中的每个值 foreach ($list as $food =&gt; $value) &#123; # 对于数组中的每个值，该值是否实际上是另一个数组 if (is_array ($value)) &#123; # 在新的（子）数组上调用这个函数，并将结果添加到$total中。 这是递归的部分。 $total += count_total ($value); &#125; else &#123; $total += $value; &#125; &#125; return $total;&#125;require('shopping_list1.php');echo "List 1 : ".count_total($shopping)."\n";require('shopping_list2.php');echo "List 2 : ".count_total($shopping)."\n"; Listing 3-9 recursive-output.txt 123List 1 : 34List 2 : 34List 3 : 34 每次您调用一个函数（无论是从内部调用还是从外部调用），则在内存中创建函数状态的新“副本”。这意味着该函数的每次调用与其他相同函数的调用实际上是分开的。调用它们时，每个函数调用的状态被放置到内存中的调用堆栈中，查看调用堆栈可以帮助您可视化递归。 Listing 3-10 recursive_stack.php 12345678910111213141516&lt;?phpfunction sum($start) &#123; echo "---\n"; debug_print_backtrace(); if ($start &lt; 2) &#123; return 1; &#125; else &#123; return $start + sum($start-1); &#125;&#125;echo "The result is : ".sum(4); Listing 3-11 recursive_stack-output.txt 123456789101112131415---#0 sum(4) called at [recursive_stack.php:17]---#0 sum(3) called at [recursive_stack.php:13]#1 sum(4) called at [recursive_stack.php:17]---#0 sum(2) called at [recursive_stack.php:13]#1 sum(3) called at [recursive_stack.php:13]#2 sum(4) called at [recursive_stack.php:17]---#0 sum(1) called at [recursive_stack.php:13]#1 sum(2) called at [recursive_stack.php:13]#2 sum(3) called at [recursive_stack.php:13]#3 sum(4) called at [recursive_stack.php:17]The result is : 10 递归是好的，但是您必须小心以确保递归循环一定会终止于一点。 Listing 3-12 forever.php 123456789&lt;?phpini_set('memory_limit','1G');function forever() &#123; forever();&#125;forever(); Listing 3-13 forever-output.txt 1PHP Fatal error: Allowed memory size of 1073741824 bytes exhausted (tried to allocate 262144 bytes) in forever.php on line 6 每次调用函数时，都会在其中创建一个副本内存，在这种情况下，由于无法退出函数，每个内存消耗越来越多的内存调用，并且永远不会通过退出函数来释放。请注意，我为脚本显式设置了内存限制ini_set。与Web脚本不同，PHP CLI脚本默认情况下没有内存限制。没有限制，这脚本可能会消耗所有可用内存，从而使您的机器瘫痪。 调用函数时，在函数中使用的每个变量，每个调试语句以及分配的每个其他资源都占用宝贵的内存。调用一次，它的总和可能不多，但调用递归进行数百或数千次，可能很快成为一个问题。因此，您应始终尝试将递归函数中的每种状态形式保持在绝对最小值。 尾递归是递归的一种形式，其中递归调用是函数的最后一部分。在许多语言中，编译器可以优化尾部递归，因为它不需要“堆栈框架”即可让编译器将状态存储回去。不幸的是，PHP虚拟机没有提供这样的优化，因此，我不会详细介绍尾递归。 在下一章中，您将转而关注“蹦床”，通过自动将递归函数展平到循环中，您可以得到类似的优化。 实现递归函数 Listing 3-14 all_recipes.php 12345678910111213141516171819202122232425262728&lt;?php$ingredients = [ "cod", "beef", "kiwi", "egg", "vinegar"];$dish_types = [ "pie", "smoothie", "tart", "ice cream", "crumble"];$all_recipes = [];foreach ($ingredients as $ingredient) &#123; foreach ($dish_types as $dish) &#123; $all_recipes[] = $ingredient.' '.$dish; &#125;&#125;print_r($all_recipes); Listing 3-15 all_recipes-output.txt 12345678910111213141516171819202122232425262728Array( [0] =&gt; cod pie [1] =&gt; cod smoothie [2] =&gt; cod tart [3] =&gt; cod ice cream [4] =&gt; cod crumble [5] =&gt; beef pie [6] =&gt; beef smoothie [7] =&gt; beef tart [8] =&gt; beef ice cream [9] =&gt; beef crumble [10] =&gt; kiwi pie [11] =&gt; kiwi smoothie [12] =&gt; kiwi tart [13] =&gt; kiwi ice cream [14] =&gt; kiwi crumble [15] =&gt; egg pie [16] =&gt; egg smoothie [17] =&gt; egg tart [18] =&gt; egg ice cream [19] =&gt; egg crumble [20] =&gt; vinegar pie [21] =&gt; vinegar smoothie [22] =&gt; vinegar tart [23] =&gt; vinegar ice cream [24] =&gt; vinegar crumble) Listing 3-16 recipe_functions.php 12345678910111213141516171819202122232425262728&lt;?phpfunction combine($a,$b) &#123; $combinations = []; if (is_array($a)) &#123; foreach ($a as $i) &#123; $combinations = array_merge( $combinations, combine($i, $b) ); &#125; &#125; else &#123; foreach ($b as $i) &#123; $combinations[] = $a.' '.$i; &#125; &#125; return $combinations;&#125;function print_first($items, $count) &#123; for ($counter=0; $counter&lt;$count; $counter++) &#123; echo "$counter. $&#123;items[$counter]&#125; \n"; &#125;&#125; Listing 3-17 all_recipes_recursive.php 123456789101112131415161718192021&lt;?phprequire_once('recipe_functions.php');$ingredients = [ "cod", "beef", "kiwi", "egg", "vinegar"];$dish_types = [ "pie", "smoothie", "tart", "ice cream", "crumble"];$all_recipes = combine($ingredients, $dish_types);print_first($all_recipes, 5); Listing 3-18 all_recipes_recursive_output.txt 123456Showing 5 of 25 items:1. cod pie2. cod smoothie3. cod tart4. cod ice cream5. cod crumble Listing 3-19 new_ingredients.php 12345678910111213141516171819202122232425&lt;?phprequire_once('recipe_functions.php');$ingredients = [ [ "ham", "beef" ], [ "apple", "kumquat" ], "vinegar"];$dish_types = [ "pie", "smoothie", "tart", "ice cream", "crumble"];$all_recipes = combine($ingredients, $dish_types);print_first($all_recipes, 11); Listing 3-20 new_ingredients-output.txt 123456789101112Showing 11 of 25 items:1. ham pie2. ham smoothie3. ham tart4. ham ice cream5. ham crumble6. beef pie7. beef smoothie8. beef tart9. beef ice cream10. beef crumble11. apple pie 偏函数在第1章中，您研究了函数式编程如何体现OOP的SOLID原理。一在这些原则中，接口隔离原则（ISP）意味着仅对于完成当前任务应该是您需要传递给函数的任务。在上一节中，考虑recipe_functions.php中的print_first函数。需要两个参数，要打印的项目数组和要打印的项目数。通常这是合理的需要两个参数，因为通常它们对于给定任务都会有所不同。但是，如果您正在编写新的网站theTopFiveBestEverListsOfStuff.com，您将永远只想打印第一个列出的任何五个项目。当然，您可以在整个过程中重复输入print_first（$ list，5）脚本。但是，当排在前五名的名单的市场饱和时，您需要继续前进，有史以来十大最佳市场，您需要找到所有这些5并将其替换为10。如果您不小心输入了4而不是5或1而不是10，您在一下午的市场份额将损失一半。您当然可以用变量$ count替换5，然后在需要时设置$ count = 10。但在全局范围内执行此操作意味着要进行额外的工作，以确保其他功能范围内的调用都可以使用它，并且当另一个程序员在某处意外地将$ count用作循环计数器时，奇怪的错误将比比皆是。 偏函数可为您解决这些问题。偏函数是采用现有功能并通过将值绑定到一个（或多个）参数来减少其复杂性。 放另一个方式，部分功能通过修复一个或多个现有功能的一个或多个功能，可提供现有功能的更具体版本参数设置为特定值，从而减少了调用它所需的参数数量。让我们创建一个在前五名站点上打印列表的部分功能。 请参见清单3-21和清单3-22。 Listing 3-21 top_five.php 12345678910111213141516171819&lt;?phprequire_once('print_first.php');# Some data ...$best_names = ["Rob", "Robert", "Robbie", "Izzy", "Ellie", "Indy", "Parv", "Mia", "Joe", "Surinder", "Lesley"];# Calling the function in fullprint_first($best_names, 5);# Now let's define a partial function, print_top_list, which# binds the value 5 to the second parameter of print_firstfunction print_top_list($list) &#123; print_first($list, 5);&#125;;# Calling the new partial function will give the same# output as the full function call above.print_top_list($best_names); Listing 3-22 top_five-output.txt 123456789101112Showing 5 of 11 items:1. Rob2. Robert3. Robbie4. Izzy5. EllieShowing 5 of 11 items:1. Rob2. Robert3. Robbie4. Izzy5. Ellie 您现在可以在整个网站上愉快地使用print_top_list部分功能，在知道a）您可以随时在一个中央位置将数字5更改为10，b）您仍然可以受益于对基础print_first函数的任何更新或更改，并且c）您仍然可以调用在任何其他脚本中，print_first函数直接使用任何数字表示第二个参数中的第二个参数使用相同的功能，但需要不同的编号。尽管这展示了部分函数的好处，但是您手动创建它的过程有点笨拙并且不可重用。因此，让我们成为真正的函数式程序员，并创建一个函数来创建您的部分函数职能！我在第二章中谈到了高阶函数。提醒一下，这些功能可以其他功能作为输入和/或作为输出返回。您将定义一个名为partial的函数，该函数需要一个函数和一个或多个绑定到它的参数，并吐出一个现成的部分函数供您使用。参见清单3-23，清单3-24和清单3-25。 Listing 3-23 partial_generator.php 12345678910111213141516171819202122232425262728293031&lt;?php# Our function to create a partial function. $func is# a "callable", i.e. a closure or the name of a function, and# $args is one or more arguments to bind to the function.function partial($func, ...$args) &#123; # We return our partial function as a closure return function() use ($func, $args) &#123; # The partial function we return consists of # a call to the full function using "call_user_func_array" # with a list of arguments made up of our bound # argument(s) in $args plus any others supplied at # calltime (via func_get_args) return call_user_func_array($func, array_merge($args, func_get_args() ) ); &#125;;&#125;# The partial function generator above binds the given# n arguments to the *first* n arguments. In our case# we want to bind the *last* argument, so we'll create# another function that returns a function with the# arguments reversed.function reverse($func) &#123; return function() use ($func) &#123; return call_user_func_array($func, array_reverse(func_get_args()) ); &#125;;&#125; Listing 3-24 partial.php 12345678910&lt;?phprequire_once('print_first.php');require_once('partial_generator.php');$foods = ["mango", "apple pie", "cheese", "steak", "yoghurt", "chips"];$print_top_five = partial(reverse('print_first'), 5);$print_top_five($foods);$print_best = partial(reverse('print_first'), 1);$print_best($foods); Listing 3-25 partial-output.txt 12345678Showing 5 of 6 items:1. mango2. apple pie3. cheese4. steak5. yoghurtShowing 1 of 6 items:1. mango 尽管我说过有关named的内容，但本示例使用了一个命名函数而不是闭包功能更早。 这是为本书的范围而故意设计的； 您稍后将再次使用它，并且在您正在编写的简单程序，将其用作命名函数意味着您不需要在每个程序中您要从中调用的每个函数。 在程序中，您可能希望将其更改为闭包给您带来好处。如您所见，局部函数生成器允许您使用可重用的方式来创建多个局部函数您可以根据需要使用它们，并制作了两个不同的部分（$ print_top_five和$ print_best）。 您可以使用此功能来减少任何功能的数量。 考虑清单3-26中的函数，的Arity为4，您将减少2。 清单3-27显示了输出。 Listing 3-26 concatenate.php 12345678910&lt;?phprequire_once("partial_generator.php");$concatenate = function ($a, $b, $c, $d) &#123; return $a.$b.$c.$d;&#125;;echo $concatenate("what ", "is ", "your ", "name\n");$whatis = partial($concatenate, "what ", "is ");echo $whatis("happening ", "here\n"); Listing 3-27 concatenate-output.txt 12what is your namewhat is happening here 偏函数可帮助您将函数分解为单一用途，可重用和可维护的功能。 它们使您可以共享更广泛的“单片式”功能的核心功能几个不同的任务，同时仍然受益于功能的集中化。 他们还允许您（如果需要）使用纯数学函数来实现奇偶校验，该函数仅接受一个单论点。 在下一章中，您将研究curring，尽管我专注于食物，但它并不是功能化印度菜，而是一种将多种功能自动分解为一连串的单参数函数。 函数式表达式函数式编程倾向于使用“函数式表达式”进行程序控制，而不是使用传统的命令式控制结构，您已经间接查看了其中的一些示例。您可以使用已经探索的技术来组合一些更有用的表达方式。某些易于转换和理解的示例往往是数字函数。 毕竟，函数式编程源于数学。 在许多语言中，函数inc和dec存在用于递增和递减整数。 在PHP中，您习惯使用++和-运算符而是，但是没有理由不能使用称为的函数编写自己的函数表达式公司和十二月 您可能会很想创建清单3-28所示的这些函数来实现此目的（使用输出如清单3-29所示）。 Listing 3-28 inc_dec.php 123456789101112131415&lt;?phpfunction inc($number) &#123; $number++; return $number;&#125;function dec($number) &#123; $number--; return $number;&#125;var_dump( inc(3) );var_dump( dec(3) ); Listing 3-29 inc_dec-output.txt 12int(4)int(2) 完全正确，但是让我们考虑使用部分函数技术的不同方法您之前看过的。 参见清单3-30和清单3-31。 Listing 3-30 inc_dec_partial.php 123456789101112131415161718192021222324&lt;?phprequire_once('partial_generator.php');# First define a generic adding functionfunction add($a,$b) &#123; return $a + $b;&#125;# Then create our inc and dec as partial functions# of the add() function.$inc = partial('add', 1);$dec = partial('add', -1);var_dump( $inc(3) );var_dump( $dec(3) );# Creating variations is then a simple one-liner$inc_ten = partial('add', 10);var_dump( $inc_ten(20) );# and we still have our add function. We can start# to build more complex functional expressions$answer = add( $inc(3), $inc_ten(20) );var_dump ( $answer ); Listing 3-31 inc_dec_partial-output.txt 1234int(4)int(2)int(30)int(34) 请注意，您可以根据需要混合和匹配命名函数和匿名函数技术。 最初，您只需付出一点额外的努力，即可获得更大的灵活性，并轻松创建其他派生类职能。 另一个示例可能是根据用例创建功能版本的能力。例如，您和我可能会认为一打是12，但对面包师来说是13。请参见清单3-32和清单3-33。 Listing 3-32 dsl.php 12345678910111213141516&lt;?phprequire_once('partial_generator.php');# Define a multiply functionfunction multiply($a,$b) &#123; return $a * $b;&#125;# And then create two ways to count in# dozens, depending on your industry$programmers_dozens = partial('multiply', 12);$bakers_dozens = partial('multiply', 13);var_dump( $programmers_dozens(2) );var_dump( $bakers_dozens(2) ); Listing 3-33 dsl-output.txt 12int(24)int(26) 这种创建功能的功能描述了他们将要做什么，而不是详细说明如何去做，是使函数式编程非常适合创建领域特定语言的属性之一（DSL）。 DSL是为特定应用量身定制的语言或现有语言的改编“域”（例如，特定行业或软件类型）。 您已经讨论了一种通过减少现有功能的繁琐性来创建新功能的方法，但是如果您想要通过合并多个现有功能来制作新功能？您可以在其他带有中间变量的变量将输出从一个传递到下一个。或者，您可以连锁通过直接使用一个函数作为下一个函数的参数将它们组合在一起。这是一种功能形式组合，并且一如既往，有一种更好的“功能性”方法可以做到这一点。假设您有一个秘密的公式可以计算出使世界上最好的温度的最佳温度芒果雪糕。该公式计算您正在使用的芒果数量（例如6），将其加倍（12），取反（-12），再加上2（-10°C）。您需要将此公式作为函数嵌入到运行的PHP软件中您的冰淇淋机。但是，您会制作其他口味的冰淇淋，每种口味都有自己独特的配方。因此，您需要从一组可重用的基本数学函数开始并进行组合到专门用于芒果的配方中，同时仍留有空间轻松实现该配方待会儿再来吃草莓冰淇淋。一种方法是将几个函数一起组成一个mango_temp函数，如清单3-34和清单3-35所示。 Listing 3-34 sums1.php 1234567891011121314151617181920212223242526272829&lt;?phpfunction double($number) &#123; return $number * 2; &#125;;function negate($number) &#123; return -$number; &#125;;function add_two($number) &#123; return $number + 2; &#125;;function mango_temp ($num_mangos) &#123; return add_two( negate ( double ( $num_mangos ) ) );&#125;;echo mango_temp(6)."°C\n"; Listing 3-35 sums1-output.txt 1-10°C 可以，但是阅读起来不太直观。 由于每个函数都嵌套在前一个函数中，您必须有效地从右向后阅读它，以了解执行顺序。纯函数语言通常具有语法或函数，用于像这样将函数组合在一起，但是在一种更易于阅读的方式。 PHP没有，但不要担心，因为创建自己的PHP很容易（请参见清单3-36）。 Listing 3-36 compose.php 1234567891011121314151617181920212223242526272829303132&lt;?php# This is a special function which simply returns it's input,# and is called the "identity function" in functional programming.function identity ($value) &#123; return $value; &#125;;# This function takes a list of "callables" (function names, closures etc.)# and returns a function composed of all of them, using array_reduce to# reduce them into a single chain of nested functions.function compose(...$functions)&#123; return array_reduce( # This is the array of functions, that we are reducing to one. $functions, # This is the function that operates on each item in $functions and # returns a function with the chain of functions thus far wrapped in # the current one. function ($chain, $function) &#123; return function ($input) use ($chain, $function) &#123; return $function( $chain($input) ); &#125;; &#125;, # And this is the starting point for the reduction, which is where # we use our $identity function as it effectively does nothing 'identity' );&#125; Listing 3-37 sums2.php 123456789101112131415161718192021222324252627&lt;?phpinclude('compose.php');function double($number) &#123; return $number * 2; &#125;;function negate($number) &#123; return -$number; &#125;;function add_two($number) &#123; return $number + 2; &#125;;$mango_temp = compose( 'double', 'negate', 'add_two');echo $mango_temp(6)."°C\n\n ";print_r ($mango_temp); Listing 3-38 sums2-output.txt 1234567891011121314151617181920212223242526272829303132333435-10°CClosure Object( [static] =&gt; Array ( [chain] =&gt; Closure Object ( [static] =&gt; Array ( [chain] =&gt; Closure Object ( [static] =&gt; Array ( [chain] =&gt; identity [function] =&gt; double ) [parameter] =&gt; Array ( [$input] =&gt; &lt;required&gt; ) ) [function] =&gt; negate ) [parameter] =&gt; Array ( [$input] =&gt; &lt;required&gt; ) ) [function] =&gt; add_two ) [parameter] =&gt; Array ( [$input] =&gt; &lt;required&gt; )) 您可以在链的开头（此输出的中间）看到身份函数，每个后续功能依次作为每个“链”闭合的属性。在第1章中，您查看了功能类型代码的样本。 我不想介绍构图在那个阶段发挥作用，以免在早期使水变得浑浊。 但是，现在您知道了组成，您可以重写该示例，如清单3-39所示。 Listing 3-39 example2.php 123456789101112131415&lt;?phprequire_once('image_functions.php');require_once('stats_functions.php');require_once('data_functions.php');require_once('compose.php');$csv_data = file_get_contents('my_data.csv');$make_chart = compose( 'data_to_array', 'generate_stats', 'make_chart_image');file_put_contents('my_chart.png', $make_chart( $csv_data ) ); 这些示例中要注意的一件事是，您的compose函数仅适用于取一个参数。这是故意的，因为函数只能返回单个返回值。如果有功能接受两个参数，compose函数将如何知道从何处使用单个返回值上一个函数调用？您可以使用我已经介绍过的部分函数之类的技术来创建单个函数配合使用。当然，单个参数可以是数组或类似的数据结构，如果您需要在函数之间移动数据集。强制执行单个参数还有助于确保您的功能应保持简单并尽可能限制范围。但是，这通常很实用（有时如果您正在使用其他人的功能或代码，则可以使用此功能）具有多个参数的函数。函数式编程在这里也有介绍。你只是将函数包装在另一个返回函数的函数中！清单3-40和清单3-41显示了使用PHP的本机的str_repeat函数（带有两个参数：字符串和重复次数）应该使这一点更加清楚。 Listing 3-40 strrepeat.php 12345678910111213141516171819202122232425262728293031&lt;?phpinclude('compose.php');# A function to format a string for displayfunction display($string) &#123; echo "The string is : ".$string."\n";&#125;;# Our function to wrap str_repeat.# Note it takes one parameter, the $countfunction repeat_str($count) &#123; # This function returns another (closure) function, # which binds $count, and accepts a single parameter # $string. Note that *this* returned closure is the # actual function that gets used in compose(). return function ($string) use ($count) &#123; return str_repeat($string, $count); &#125;;&#125;;# Now let's compose those two functions together.$ten_chars = compose( repeat_str(10), 'display');# and run our composed functionecho $ten_chars('*'); Listing 3-41 strrepeat-output.txt 1The string is : ********** 理解您在此脚本中所做的工作的关键是要认识到，当您在脚本中使用repeat_str（10）compose语句，不是您要传入的函数。在函数名称后加上括号在此处执行它，然后将其自身替换为返回值。 因此，您正在调用中的repeat_str（10）编写语句定义，而repeat_str（10）返回的函数实际上是由组成为参数。 repeat_str（10）返回一个接受一个参数的闭包（这是您所需要的）（对于您的compose函数）为$ string，但通过使用（$ count）绑定了第二个参数（10）。当然，您不必这样做。 例如，您可以开始创建部分函数（例如repeat_ten_times（$ string）函数），但这是编写多arar函数的更实用的方法在许多情况下。 总结您现在就开始编写功能代码。 在本章中，您研究了各种结构化方式以“函数式”方式运行函数，并研究了诸如递归和部分函数之类的技术如何使您编写更灵活的功能。 您可以使用到目前为止所研究的技术来使其他通用程序控制结构，当您阅读本书的其余部分时，将对其进行研究。 下一个本章中，您将开始研究一些更高级的函数式编程主题。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Provider]]></title>
    <url>%2F2020%2F03%2F24%2FLaravel-Provider%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介服务提供者是Laravel应用启动的中心，你自己的应用以及所有Laravel的核心服务都是通过服务提供者启动。 但是，我们所谓的「启动」指的是什么？通常，这意味着注册服务，包括注册服务容器绑定、事件监听器、中间件甚至路由。服务提供者是应用配置的中心。 如果你打开Laravel自带的config/app.php文件，将会看到一个providers数组，这里就是应用所要加载的所有服务提供者类，当然，其中很多是延迟加载的，也就是说不是每次请求都会被加载，只有真的用到它们的时候才会加载。 通过本文档，你将会学习如何编写自己的服务提供者并在Laravel应用中注册它们。 编写服务提供者所有的服务提供者都继承自Illuminate\Support\ServiceProvider类。大部分服务提供者都包含两个方法：register和boot。在register方法中，你唯一要做的事情就是绑定服务到服务容器，不要尝试在该方法中注册事件监听器，路由或者任何其它功能。 通过Artisan命令make:provider即可生成一个新的提供者： 1php artisan make:provider RiakServiceProvider register方法正如前面所提到的，在register方法中只绑定服务到服务容器，而不要做其他事情，否则，一不小心就可能用到一个尚未被加载的服务提供者提供的服务。 现在让我们来看看一个基本的服务提供者长什么样，在任何服务提供者方法中，都可以通过$app属性来访问服务容器： 1234567891011121314151617181920&lt;?phpnamespace App\Providers;use Riak\Connection;use Illuminate\Support\ServiceProvider;class RiakServiceProvider extends ServiceProvider&#123; /** * 在容器中注册绑定. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton(Connection::class, function ($app) &#123; return new Connection(config('riak')); &#125;); &#125;&#125; 该服务提供者只定义了一个register方法，并使用该方法在服务容器中定义了一个Riak\Connection的实现。如果你不知道服务容器是如何工作的，请参考其文档。 bindings和singletons属性 如果你的服务提供者注册了很多简单的绑定，你可能希望使用bindings和singletons属性来替代手动注册每个容器绑定以简化代码。当服务提供者被框架加载后，会自动检查这些属性并注册相应绑定： 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Providers;use App\Contracts\ServerProvider;use App\Contracts\DowntimeNotifier;use App\Services\ServerToolsProvider;use Illuminate\Support\ServiceProvider;use App\Services\PingdomDowntimeNotifier;use App\Services\DigitalOceanServerProvider;class AppServiceProvider extends ServiceProvider&#123; /** * All of the container bindings that should be registered. * * @var array */ public $bindings = [ ServerProvider::class =&gt; DigitalOceanServerProvider::class, ]; /** * All of the container singletons that should be registered. * * @var array */ public $singletons = [ DowntimeNotifier::class =&gt; PingdomDowntimeNotifier::class, ServerToolsProvider::class =&gt; ServerToolsProvider::class, ];&#125; boot方法如果我们想要在服务提供者中注册视图Composer该怎么做？这就要用到boot方法了。该方法在所有服务提供者被注册以后才会被调用，这就是说我们可以在其中访问框架已注册的所有其它服务： 12345678910111213141516171819&lt;?phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;class ComposerServiceProvider extends ServiceProvider&#123; /** * Perform post-registration booting of services. * * @return void */ public function boot() &#123; view()-&gt;composer('view', function () &#123; // &#125;); &#125;&#125; boot方法的依赖注入 我们可以在boot方法中对依赖进行类型提示，服务容器会自动注入你所需要的依赖： 1234567use Illuminate\Contracts\Routing\ResponseFactory;public function boot(ResponseFactory $response)&#123; $response-&gt;macro('caps', function ($value) &#123; // &#125;);&#125; 注册服务提供者所有服务提供者都是通过配置文件config/app.php中进行注册，该文件包含了一个列出所有服务提供者名字的providers数组，默认情况下，其中列出了所有核心服务提供者，这些服务提供者启动 Laravel核心组件，比如邮件、队列、缓存等等。 要注册你自己的服务提供者，只需要将其追加到该数组中即可： 1234'providers' =&gt; [ // 其它服务提供者 App\Providers\ComposerServiceProvider::class,], 延迟加载服务提供者如果你的提供者仅仅只是在服务容器中注册绑定，你可以选择延迟加载该绑定直到注册绑定的服务真的需要时再加载，延迟加载这样的一个提供者将会提升应用的性能，因为它不会在每次请求时都从文件系统加载。 Laravel编译并保存所有延迟服务提供者提供的服务及服务提供者的类名。然后，只有当你尝试解析其中某个服务时Laravel才会加载其服务提供者。 想要延迟加载一个提供者，需要实现\Illuminate\Contracts\Support\DeferrableProvider接口并定义一个provides方法，provides方法会返回通过服务提供者注册的服务容器绑定： 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Providers;use Riak\Connection;use Illuminate\Support\ServiceProvider;use Illuminate\Contracts\Support\DeferrableProvider;class RiakServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton(Connection::class, function ($app) &#123; return new Connection($app['config']['riak']); &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [Connection::class]; &#125;&#125; 源码 Illuminate\Support\ServiceProvider.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306&lt;?phpnamespace Illuminate\Support;use Illuminate\Console\Application as Artisan;use Illuminate\Contracts\Support\DeferrableProvider;abstract class ServiceProvider&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The paths that should be published. * * @var array */ public static $publishes = []; /** * The paths that should be published by group. * * @var array */ public static $publishGroups = []; /** * Create a new service provider instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Merge the given configuration with the existing configuration. * * @param string $path * @param string $key * @return void */ protected function mergeConfigFrom($path, $key) &#123; if (! $this-&gt;app-&gt;configurationIsCached()) &#123; $this-&gt;app['config']-&gt;set($key, array_merge( require $path, $this-&gt;app['config']-&gt;get($key, []) )); &#125; &#125; /** * Load the given routes file if routes are not already cached. * * @param string $path * @return void */ protected function loadRoutesFrom($path) &#123; if (! $this-&gt;app-&gt;routesAreCached()) &#123; require $path; &#125; &#125; /** * Register a view file namespace. * * @param string|array $path * @param string $namespace * @return void */ protected function loadViewsFrom($path, $namespace) &#123; if (is_array($this-&gt;app-&gt;config['view']['paths'])) &#123; foreach ($this-&gt;app-&gt;config['view']['paths'] as $viewPath) &#123; if (is_dir($appPath = $viewPath.'/vendor/'.$namespace)) &#123; $this-&gt;app['view']-&gt;addNamespace($namespace, $appPath); &#125; &#125; &#125; $this-&gt;app['view']-&gt;addNamespace($namespace, $path); &#125; /** * Register a translation file namespace. * * @param string $path * @param string $namespace * @return void */ protected function loadTranslationsFrom($path, $namespace) &#123; $this-&gt;app['translator']-&gt;addNamespace($namespace, $path); &#125; /** * Register a JSON translation file path. * * @param string $path * @return void */ protected function loadJsonTranslationsFrom($path) &#123; $this-&gt;app['translator']-&gt;addJsonPath($path); &#125; /** * Register a database migration path. * * @param array|string $paths * @return void */ protected function loadMigrationsFrom($paths) &#123; $this-&gt;app-&gt;afterResolving('migrator', function ($migrator) use ($paths) &#123; foreach ((array) $paths as $path) &#123; $migrator-&gt;path($path); &#125; &#125;); &#125; /** * Register paths to be published by the publish command. * * @param array $paths * @param mixed $groups * @return void */ protected function publishes(array $paths, $groups = null) &#123; $this-&gt;ensurePublishArrayInitialized($class = static::class); static::$publishes[$class] = array_merge(static::$publishes[$class], $paths); foreach ((array) $groups as $group) &#123; $this-&gt;addPublishGroup($group, $paths); &#125; &#125; /** * Ensure the publish array for the service provider is initialized. * * @param string $class * @return void */ protected function ensurePublishArrayInitialized($class) &#123; if (! array_key_exists($class, static::$publishes)) &#123; static::$publishes[$class] = []; &#125; &#125; /** * Add a publish group / tag to the service provider. * * @param string $group * @param array $paths * @return void */ protected function addPublishGroup($group, $paths) &#123; if (! array_key_exists($group, static::$publishGroups)) &#123; static::$publishGroups[$group] = []; &#125; static::$publishGroups[$group] = array_merge( static::$publishGroups[$group], $paths ); &#125; /** * Get the paths to publish. * * @param string $provider * @param string $group * @return array */ public static function pathsToPublish($provider = null, $group = null) &#123; if (! is_null($paths = static::pathsForProviderOrGroup($provider, $group))) &#123; return $paths; &#125; return collect(static::$publishes)-&gt;reduce(function ($paths, $p) &#123; return array_merge($paths, $p); &#125;, []); &#125; /** * Get the paths for the provider or group (or both). * * @param string|null $provider * @param string|null $group * @return array */ protected static function pathsForProviderOrGroup($provider, $group) &#123; if ($provider &amp;&amp; $group) &#123; return static::pathsForProviderAndGroup($provider, $group); &#125; elseif ($group &amp;&amp; array_key_exists($group, static::$publishGroups)) &#123; return static::$publishGroups[$group]; &#125; elseif ($provider &amp;&amp; array_key_exists($provider, static::$publishes)) &#123; return static::$publishes[$provider]; &#125; elseif ($group || $provider) &#123; return []; &#125; &#125; /** * Get the paths for the provider and group. * * @param string $provider * @param string $group * @return array */ protected static function pathsForProviderAndGroup($provider, $group) &#123; if (! empty(static::$publishes[$provider]) &amp;&amp; ! empty(static::$publishGroups[$group])) &#123; return array_intersect_key(static::$publishes[$provider], static::$publishGroups[$group]); &#125; return []; &#125; /** * Get the service providers available for publishing. * * @return array */ public static function publishableProviders() &#123; return array_keys(static::$publishes); &#125; /** * Get the groups available for publishing. * * @return array */ public static function publishableGroups() &#123; return array_keys(static::$publishGroups); &#125; /** * Register the package's custom Artisan commands. * * @param array|mixed $commands * @return void */ public function commands($commands) &#123; $commands = is_array($commands) ? $commands : func_get_args(); Artisan::starting(function ($artisan) use ($commands) &#123; $artisan-&gt;resolveCommands($commands); &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return []; &#125; /** * Get the events that trigger this service provider to register. * * @return array */ public function when() &#123; return []; &#125; /** * Determine if the provider is deferred. * * @return bool */ public function isDeferred() &#123; return $this instanceof DeferrableProvider; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Container]]></title>
    <url>%2F2020%2F03%2F22%2FLaravel-Container%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： $a实例 = 服务容器（Container）::getInstance(‘A’);自动注入是这样用的。怎么理解？ bound是bind的过去式，是否被绑定。 简介深入理解Laravel服务容器对于构建功能强大的大型Laravel应用而言至关重要，对于贡献代码到Laravel核心也很有帮助。 Laravel服务容器是一个用于管理类依赖和执行依赖注入的强大工具。依赖注入其实质是通过构造函数或者某些情况下通过「setter」方法将类依赖注入到类中。 让我们看一个简单的例子：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\Http\Controllers;use App\User;use App\Repositories\UserRepository;use App\Http\Controllers\Controller;class UserController extends Controller&#123; /** * The user repository implementation. * * @var UserRepository */ protected $users; /** * Create a new controller instance. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125; /** * Show the profile for the given user. * * @param int $id * @return Response */ public function show($id) &#123; $user = $this-&gt;users-&gt;find($id); return view('user.profile', ['user' =&gt; $user]); &#125;&#125; 在本例中，UserController需要从数据源获取用户，所以，我们注入了一个可以获取用户的服务UserRepository，其扮演的角色类似使用Eloquent从数据库获取用户信息。注入UserRepository后，我们可以在其基础上封装其他实现，也可以模拟或者创建一个假的UserRepository实现用于测试。 绑定绑定基础几乎所有的服务容器绑定都是在服务提供者中完成。因此本文档的演示例子用到的容器都是在服务提供者中绑定。 注：如果一个类没有基于任何接口那么就没有必要将其绑定到容器。容器并不需要被告知如何构建对象，因为它会使用PHP的反射服务自动解析出具体的对象。 简单的绑定 在一个服务提供者中，可以通过$this-&gt;app变量访问容器，然后使用bind方法注册一个绑定，该方法需要两个参数，第一个参数是我们想要注册的类名或接口名称，第二个参数是返回类的实例的闭包：1234// API类依赖HttpClient$this-&gt;app-&gt;bind('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;); 注意到我们将容器本身作为解析器的一个参数，然后我们可以使用该容器来解析我们正在构建的对象的子依赖。 绑定一个单例 singleton方法绑定一个只会解析一次的类或接口到容器，然后接下来对容器的调用将会返回同一个对象实例： 123$this-&gt;app-&gt;singleton('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;); 绑定实例 你还可以使用instance方法绑定一个已存在的对象实例到容器，随后调用容器将总是返回给定的实例： 123$api = new HelpSpot\API(new HttpClient);$this-&gt;app-&gt;instance('HelpSpot\API', $api); 绑定原始值 你可能有一个接收注入类的类，同时需要注入一个原生的数值比如整型，可以结合上下文轻松注入这个类需要的任何值： 123$this-&gt;app-&gt;when('App\Http\Controllers\UserController') -&gt;needs('$variableName') -&gt;give($value); 绑定接口到实现服务容器的一个非常强大的功能是其绑定接口到实现。我们假设有一个EventPusher接口及其实现类RedisEventPusher，编写完该接口的RedisEventPusher实现后，就可以将其注册到服务容器：1234$this-&gt;app-&gt;bind( 'App\Contracts\EventPusher', 'App\Services\RedisEventPusher'); 这段代码告诉容器当一个类需要EventPusher的实现时将会注入RedisEventPusher，现在我们可以在构造器或者任何其它通过服务容器注入依赖的地方进行EventPusher接口的依赖注入：123456789101112use App\Contracts\EventPusher;/** * 创建一个新的类实例 * * @param EventPusher $pusher * @return void */public function __construct(EventPusher $pusher)&#123; $this-&gt;pusher = $pusher;&#125; 上下文绑定有时侯我们可能有两个类使用同一个接口，但我们希望在每个类中注入不同实现，例如，两个控制器依赖Illuminate\Contracts\Filesystem\Filesystem契约的不同实现。Laravel为此定义了简单、平滑的接口：12345678910111213141516use Illuminate\Support\Facades\Storage;use App\Http\Controllers\VideoController;use App\Http\Controllers\PhotoControllers;use Illuminate\Contracts\Filesystem\Filesystem;$this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('local'); &#125;);$this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('s3'); &#125;); 标签少数情况下，我们需要解析特定分类下的所有绑定，例如，你正在构建一个接收多个不同Report接口实现的报告聚合器，在注册完Report实现之后，可以通过tag方法给它们分配一个标签： 123456789$this-&gt;app-&gt;bind('SpeedReport', function () &#123; //&#125;);$this-&gt;app-&gt;bind('MemoryReport', function () &#123; //&#125;);$this-&gt;app-&gt;tag(['SpeedReport', 'MemoryReport'], 'reports'); 这些服务被打上标签后，可以通过tagged方法来轻松解析它们： 123$this-&gt;app-&gt;bind('ReportAggregator', function ($app) &#123; return new ReportAggregator($app-&gt;tagged('reports'));&#125;); 扩展绑定extend方法允许对解析服务进行修改。例如，当服务被解析后，可以运行额外代码装饰或配置该服务。extend方法接收一个闭包来返回修改后的服务： 123$this-&gt;app-&gt;extend(Service::class, function($service) &#123; return new DecoratedService($service);&#125;); 解析make方法 有很多方式可以从容器中解析对象，首先，你可以使用make方法，该方法接收你想要解析的类名或接口名作为参数：1$fooBar = $this-&gt;app-&gt;make('HelpSpot\API'); 如果你所在的代码位置访问不了$app变量，可以使用辅助函数resolve： 1$api = resolve('HelpSpot\API'); 某些类的依赖不能通过容器来解析，你可以通过关联数组方式将其传递传递到makeWith方法来注入： 1$api = $this-&gt;app-&gt;makeWith('HelpSpot\API', ['id' =&gt; 1]); 自动注入 最后，也是最常用的，你可以简单的通过在类的构造函数中对依赖进行类型提示来从容器中解析对象，控制器、事件监听器、中间件等都是通过这种方式。此外，你还可以在队列任务的handle方法中进行类型提示。在具体实践中，这是大多数对象从容器中解析的方式。 容器会自动为其解析类注入依赖，例如，你可以在控制器的构造函数中为应用定义的仓库进行类型提示，该仓库会自动解析并注入该类： 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\Http\Controllers;use App\Users\Repository as UserRepository;class UserController extends Controller&#123; /** * 用户仓库实例 */ protected $users; /** * 创建一个控制器实例 * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125; /** * 通过指定ID显示用户 * * @param int $id * @return Response */ public function show($id) &#123; // &#125;&#125; 容器事件服务容器在每一次解析对象时都会触发一个事件，可以使用resolving方法监听该事件： 1234567$this-&gt;app-&gt;resolving(function ($object, $app) &#123; // Called when container resolves object of any type...&#125;);$this-&gt;app-&gt;resolving(HelpSpot\API::class, function ($api, $app) &#123; // Called when container resolves objects of type "HelpSpot\API"...&#125;); 正如你所看到的，被解析的对象将会传递给回调函数，从而允许你在对象被传递给消费者之前为其设置额外属性。 PSR-11Laravel的服务容器实现了PSR-11接口。所以，你可以通过类型提示PSR-11容器接口来获取Laravel容器的实例： 1234567use Psr\Container\ContainerInterface;Route::get('/', function (ContainerInterface $container) &#123; $service = $container-&gt;get('Service'); //&#125;); 如果传入的标识不能被解析则会抛出异常。如果该标识未被绑定的话抛出的异常会是Psr\Container\NotFoundExceptionInterface接口实例；如果标识已绑定但未能成功解析则抛出的异常是Psr\Container\ContainerExceptionInterface接口实例。 源码Container.php不依赖任何类，只实现了接口，复制到别的框架或单独使用都是可以的。 ArrayAccess首先是ArrayAccess。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpnamespace Illuminate\Container;use ArrayAccess;class Container implements ArrayAccess&#123; /** * Determine if a given offset exists. * * @param string $key * @return bool */ public function offsetExists($key) &#123; return $this-&gt;bound($key); &#125; /** * Get the value at a given offset. * * @param string $key * @return mixed */ public function offsetGet($key) &#123; return $this-&gt;make($key); &#125; /** * Set the value at a given offset. * * @param string $key * @param mixed $value * @return void */ public function offsetSet($key, $value) &#123; $this-&gt;bind($key, $value instanceof Closure ? $value : function () use ($value) &#123; return $value; &#125;); &#125; /** * Unset the value at a given offset. * * @param string $key * @return void */ public function offsetUnset($key) &#123; unset($this-&gt;bindings[$key], $this-&gt;instances[$key], $this-&gt;resolved[$key]); &#125; /** * Dynamically access container services. * * @param string $key * @return mixed */ public function __get($key) &#123; return $this[$key]; &#125; /** * Dynamically set container services. * * @param string $key * @param mixed $value * @return void */ public function __set($key, $value) &#123; $this[$key] = $value; &#125;&#125; 单例相关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpnamespace Illuminate\Container;use ArrayAccess;class Container implements ArrayAccess&#123; /** * The current globally available container (if any). * * 这是Container自身的实例 * * @var static */ protected static $instance; /** * Drop all of the stale instances and aliases. * * @param string $abstract * @return void */ protected function dropStaleInstances($abstract) &#123; unset($this-&gt;instances[$abstract], $this-&gt;aliases[$abstract]); &#125; /** * Remove a resolved instance from the instance cache. * * @param string $abstract * @return void */ public function forgetInstance($abstract) &#123; unset($this-&gt;instances[$abstract]); &#125; /** * Clear all of the instances from the container. * * @return void */ public function forgetInstances() &#123; $this-&gt;instances = []; &#125; /** * Flush the container of all bindings and resolved instances. * * @return void */ public function flush() &#123; $this-&gt;aliases = []; $this-&gt;resolved = []; $this-&gt;bindings = []; $this-&gt;instances = []; $this-&gt;abstractAliases = []; &#125; /** * Get the globally available instance of the container. * * @return static */ public static function getInstance() &#123; if (is_null(static::$instance)) &#123; static::$instance = new static; &#125; return static::$instance; &#125; /** * Set the shared instance of the container. * * @param \Illuminate\Contracts\Container\Container|null $container * @return \Illuminate\Contracts\Container\Container|static */ public static function setInstance(ContainerContract $container = null) &#123; return static::$instance = $container; &#125;&#125; 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?phpnamespace Illuminate\Container;use ArrayAccess;class Container implements ArrayAccess&#123; /** * An array of the types that have been resolved. * * @var bool[] */ protected $resolved = []; /** * The container's bindings. * * @var array[] */ protected $bindings = []; /** * The container's method bindings. * * @var \Closure[] */ protected $methodBindings = []; /** * The container's shared instances. * * 这是Container维护的实例 * * * @var object[] */ protected $instances = []; /** * The registered type aliases. * * @var string[] */ protected $aliases = []; /** * The registered aliases keyed by the abstract name. * * @var array[] */ protected $abstractAliases = []; /** * The extension closures for services. * * @var array[] */ protected $extenders = []; /** * All of the registered tags. * * @var array[] */ protected $tags = []; /** * The stack of concretions currently being built. * * @var array[] */ protected $buildStack = []; /** * The parameter override stack. * * @var array[] */ protected $with = []; /** * The contextual binding map. * * @var array[] */ public $contextual = []; /** * All of the registered rebound callbacks. * * @var array[] */ protected $reboundCallbacks = []; /** * All of the global resolving callbacks. * * @var \Closure[] */ protected $globalResolvingCallbacks = []; /** * All of the global after resolving callbacks. * * @var \Closure[] */ protected $globalAfterResolvingCallbacks = []; /** * All of the resolving callbacks by class type. * * @var array[] */ protected $resolvingCallbacks = []; /** * All of the after resolving callbacks by class type. * * @var array[] */ protected $afterResolvingCallbacks = [];&#125; 从下往上从build开始： build和其相关函数。只有build是public，其他都是protected。 有用到反射来创建实例和依赖的类的实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/** * Instantiate a concrete instance of the given type. * * @param \Closure|string $concrete * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */public function build($concrete)&#123; // If the concrete type is actually a Closure, we will just execute it and // hand back the results of the functions, which allows functions to be // used as resolvers for more fine-tuned resolution of these objects. // 先忽略，看不是闭包的参数 if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride()); &#125; try &#123; $reflector = new ReflectionClass($concrete); &#125; catch (ReflectionException $e) &#123; throw new BindingResolutionException("Target class [$concrete] does not exist.", 0, $e); &#125; // If the type is not instantiable, the developer is attempting to resolve // an abstract type such as an Interface or Abstract Class and there is // no binding registered for the abstractions so we need to bail out. if (! $reflector-&gt;isInstantiable()) &#123; // Instantiable able 形容词 可实例化的。判断类是否可以实例化 return $this-&gt;notInstantiable($concrete); // 这个函数专门用于抛出异常 &#125; $this-&gt;buildStack[] = $concrete; // buildStack是个包含string类型的数组 concrete是一个类路径 $constructor = $reflector-&gt;getConstructor(); // If there are no constructors, that means there are no dependencies then // we can just resolve the instances of the objects right away, without // resolving any other types or dependencies out of these containers. if (is_null($constructor)) &#123; array_pop($this-&gt;buildStack); // 删除数组中的最后一个元素 return new $concrete; &#125; $dependencies = $constructor-&gt;getParameters(); // Once we have all the constructor's parameters we can create each of the // dependency instances and then use the reflection instances to make a // new instance of this class, injecting the created dependencies in. try &#123; $instances = $this-&gt;resolveDependencies($dependencies); &#125; catch (BindingResolutionException $e) &#123; array_pop($this-&gt;buildStack); throw $e; &#125; array_pop($this-&gt;buildStack); return $reflector-&gt;newInstanceArgs($instances);&#125;/** * Resolve all of the dependencies from the ReflectionParameters. * * 构造函数的参数有可能是类，也有可能是数值，字符串等类型 * * @param \ReflectionParameter[] $dependencies * @return array * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveDependencies(array $dependencies)&#123; $results = []; foreach ($dependencies as $dependency) &#123; // If the dependency has an override for this particular build we will use // that instead as the value. Otherwise, we will continue with this run // of resolutions and let reflection attempt to determine the result. if ($this-&gt;hasParameterOverride($dependency)) &#123; $results[] = $this-&gt;getParameterOverride($dependency); continue; &#125; // If the class is null, it means the dependency is a string or some other // primitive type which we can not resolve since it is not a class and // we will just bomb out with an error since we have no-where to go. $result = is_null(Util::getParameterClassName($dependency)) // 判断是类还是非类 ? $this-&gt;resolvePrimitive($dependency) // 非类类型 : $this-&gt;resolveClass($dependency); // 类 if ($dependency-&gt;isVariadic()) &#123; // Variadic 可变 检查是否是可变参数 // 可变参数 function demo( ...$parameter)&#123;&#125; $results = array_merge($results, $result); &#125; else &#123; $results[] = $result; &#125; &#125; return $results;&#125;/** * Resolve a non-class hinted primitive dependency. * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolvePrimitive(ReflectionParameter $parameter)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete('$'.$parameter-&gt;getName()))) &#123; return $concrete instanceof Closure ? $concrete($this) : $concrete; &#125; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; $this-&gt;unresolvablePrimitive($parameter);&#125;/** * Resolve a class based dependency from the container. * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveClass(ReflectionParameter $parameter)&#123; try &#123; return $parameter-&gt;isVariadic() ? $this-&gt;resolveVariadicClass($parameter) : $this-&gt;make(Util::getParameterClassName($parameter)); &#125; // If we can not resolve the class instance, we will check to see if the value // is optional, and if it is we will return the optional parameter value as // the value of the dependency, similarly to how we do this with scalars. catch (BindingResolutionException $e) &#123; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; if ($parameter-&gt;isVariadic()) &#123; return []; &#125; throw $e; &#125;&#125;/** * Resolve a class based variadic dependency from the container. * * @param \ReflectionParameter $parameter * @return mixed */protected function resolveVariadicClass(ReflectionParameter $parameter)&#123; $className = Util::getParameterClassName($parameter); $abstract = $this-&gt;getAlias($className); if (! is_array($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $this-&gt;make($className); &#125; return array_map(function ($abstract) &#123; return $this-&gt;resolve($abstract); &#125;, $concrete);&#125;/** * Throw an exception that the concrete is not instantiable. * * @param string $concrete * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function notInstantiable($concrete)&#123; if (! empty($this-&gt;buildStack)) &#123; $previous = implode(', ', $this-&gt;buildStack); $message = "Target [$concrete] is not instantiable while building [$previous]."; &#125; else &#123; $message = "Target [$concrete] is not instantiable."; &#125; throw new BindingResolutionException($message);&#125;/** * Throw an exception for an unresolvable primitive. * * @param \ReflectionParameter $parameter * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function unresolvablePrimitive(ReflectionParameter $parameter)&#123; $message = "Unresolvable dependency resolving [$parameter] in class &#123;$parameter-&gt;getDeclaringClass()-&gt;getName()&#125;"; throw new BindingResolutionException($message);&#125; 然后是Resolve 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Resolve the given type from the container. * * @param string $abstract * @param array $parameters * @param bool $raiseEvents * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolve($abstract, $parameters = [], $raiseEvents = true)&#123; $abstract = $this-&gt;getAlias($abstract); $concrete = $this-&gt;getContextualConcrete($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null($concrete); // If an instance of the type is currently being managed as a singleton we'll // just return an existing instance instead of instantiating new instances // so the developer can keep using the same objects instance every time. if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; if (is_null($concrete)) &#123; $concrete = $this-&gt;getConcrete($abstract); &#125; // We're ready to instantiate an instance of the concrete type registered for // the binding. This will instantiate the types, as well as resolve any of // its "nested" dependencies recursively until all have gotten resolved. if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; // If we defined any extenders for this type, we'll need to spin through them // and apply them to the object being built. This allows for the extension // of services, such as changing configuration or decorating the object. foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; // If the requested type is registered as a singleton we'll want to cache off // the instances in "memory" so we can return it later without creating an // entirely new instance of an object on each subsequent request for it. if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; if ($raiseEvents) &#123; $this-&gt;fireResolvingCallbacks($abstract, $object); &#125; // Before returning, we will also set the resolved flag to "true" and pop off // the parameter overrides for this build. After those two things are done // we will be ready to return back the fully constructed class instance. $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; with属性： 123456789101112131415161718192021222324252627282930313233/** * Determine if the given dependency has a parameter override. * * @param \ReflectionParameter $dependency * @return bool */protected function hasParameterOverride($dependency)&#123; return array_key_exists( $dependency-&gt;name, $this-&gt;getLastParameterOverride() );&#125;/** * Get a parameter override for a dependency. * * @param \ReflectionParameter $dependency * @return mixed */protected function getParameterOverride($dependency)&#123; return $this-&gt;getLastParameterOverride()[$dependency-&gt;name];&#125;/** * Get the last parameter override. * * @return array */protected function getLastParameterOverride()&#123; return count($this-&gt;with) ? end($this-&gt;with) : [];&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的闭包]]></title>
    <url>%2F2020%2F03%2F12%2FPHP%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 闭包是个Closure类吗？ 闭包在创建时就会为传入的参数、use中的变量创建新的内存，相当于clone一份。怎么理解？ Closure的bind方法是什么意思？ 可以在匿名函数中使用$this关键字吗？ 在PHP中闭包与匿名函数是一个概念：123$sayHello = function($name)&#123; echo("Hello $name");&#125;; 在PHP中闭包是像函数的对象，是个Closure类，只是能够像函数一样调用：1$sayHello("world"); 输出：1Hello world 1var_dump($sayHello instanceof Closure); 输出：1boolean(true) 闭包在创建时就会为传入的参数、use中的变量创建新的内存，相当于clone一份，因此与函数外部的变量变化无关；1234567891011$name = 'world'; $sayHello = function() use($name)&#123; echo("Hello $name");&#125;; // 这里不要忘记结束的;号 $sayHello(); // 必须函数方式调用，即用(), 输出Hello world $name = 'zj'; $sayHello();// 输出Hello world 如果想使闭包内和外部的变量同步，则use中传入引用即可，就是加个&amp;：1234567891011$name = 'world'; $sayHello = function() use(&amp;$name)&#123; // 传入了引用 echo("Hello $name");&#125;;//这里不要忘记结束的;号 $sayHello(); // 必须函数方式调用，即用(), 输出Hello world $name = 'zj'; $sayHello();// 输出Hello zj Closure类有两个方法：bind()和bindTo() Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。 Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 通过这两个方法可以给类扩展复杂功能，类似策略模式，将实际操作与类定义解耦。比如通过bing为用户类增加行为：1234567891011121314151617181920Class User&#123; public $name = 'Tom'; public $age = 10; private $action = []; //...&#125;$sayHello = function()&#123; echo("Hello &#123;$this-&gt;name&#125;\n");&#125;; $swimming = function()&#123; echo("&#123;$this-&gt;name&#125; is swimming\n");&#125;; $bindSayHello = Closure::bind($sayHello, new User());$bindSwimming = Closure::bind($swimming, new User());$bindSayHello();$bindSwimming(); 输出：12Hello Tom Tom is swimming 可以把类写的更优雅点：123456789101112131415161718192021222324252627282930313233343536Class user&#123; public $name = 'Tom'; public $age = 10; private $action = []; public function addAction($actionName, $actionFunction)&#123; $this-&gt;action[$actionName] = Closure::bind($actionFunction, $this); &#125; public function doAction()&#123; foreach ($this-&gt;action as $actionFunction) &#123; $actionFunction($this-&gt;name); &#125; &#125;&#125; $sayHello = function()&#123; echo("Hello &#123;$this-&gt;name&#125;\n");&#125;; $swimming = function()&#123; echo("&#123;$this-&gt;name&#125; is swimming\n");&#125;; $bindSayHello = Closure::bind($sayHello, new user());$bindSayHello(); $user = new user(); $user-&gt;addAction('sayHello', $sayHello);$user-&gt;addAction('swimming', $swimming);$user-&gt;doAction();// 输出：// Hello Tom // Hello Tom // Tom is swimming bindTo方法与bind类似，只是通过闭包调用的，将自身绑定到对象或类上。 bind及bindTo方法都有第三个参数，确定绑定的作用域。 发现一个闭包实现中间件的例子，搬来作为补充学习： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php// 框架核心应用层$application = function($name) &#123; echo "this is a &#123;$name&#125; application\n";&#125;; // 前置校验中间件$auth = function($handler) &#123; return function($name) use ($handler) &#123; echo "&#123;$name&#125; need a auth middleware\n"; return $handler($name); &#125;;&#125;; // 前置过滤中间件$filter = function($handler) &#123; return function($name) use ($handler) &#123; echo "&#123;$name&#125; need a filter middleware\n"; return $handler($name); &#125;;&#125;; // 后置日志中间件$log = function($handler) &#123; return function($name) use ($handler) &#123; $return = $handler($name); echo "&#123;$name&#125; need a log middleware\n"; return $return; &#125;;&#125;; // 中间件栈$stack = []; // 打包function pack_middleware($handler, $stack)&#123; foreach (array_reverse($stack) as $key =&gt; $middleware) &#123; $handler = $middleware($handler); &#125; return $handler;&#125; // 注册中间件// 这里用的都是全局中间件，实际应用时还可以为指定路由注册局部中间件$stack['log'] = $log;$stack['filter'] = $filter;$stack['auth'] = $auth; $run = pack_middleware($application, $stack); 输出：1234Laravle need a filter middlewareLaravle need a auth middlewarethis is a Laravle applicationLaravle need a log middleware 打包程序 中间件的执行顺序是由打包函数(pack_middleware)决定，这里返回的闭包实际上相当于:12$run = $log($filter($auth($application)));$run('Laravle'); 编写规范中间件要要满足一定的规范：总是返回一个闭包，闭包中总是传入相同的参数（由主要逻辑决定）， 闭包总是返回句柄(handler)的执行结果； 如果中间件的逻辑在返回句柄return $handler($name)前完成，就是前置中间件，否则为后置中间件。 一、什么是闭包 理论上讲，闭包和匿名函数是不同的概念，不过，php将其视作相同的概念。 闭包和匿名函数其实是伪装成函数的对象，如果审查php闭包和匿名函数，会发现他们是Closure类的实例，闭包和字符串或整数一样，也是一等值类型。 二、创建一个闭包12345$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;; echo $closure('Yee Jason'); 输出 Hello Yee Jason. 之所以能调用$closure变量，是因为这个变量的值是一个闭包，而且闭包对象实现了__invoke()魔术方法，只要变量名后面有()，php就会查并调用__invoke() 方法。 我通常把闭包当做函数和方法的回调使用，很多php函数都会用到回调函数，例如array_map和preg_replace_callback()是使用匿名函数的绝佳时机，记住，闭包和其他值一样，可以作为参数传入其他php函数。12345$numberPlusOne = array_map(function($number) &#123; return $number + 1;&#125;, [1, 2, 3]); print_r($numberPlusOne); 在PHP闭包之前, php开发者无法选择，只能单独创建具名函数，然后引用那个函数，这么做，代码执行的稍微慢一点， 而且把回调的实现和使用场所隔离开了，传统的php代码：1234567function incrementNumber($number)&#123; return $number + 1;&#125; $numberPlusOne = array_map('incrementNumber', [1, 2, 3]);print_r($numberPlusOne); 以上两个例子输出：1Array ( [0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4 ) 三、附加状态 前面演示了如何把匿名函数当成回调使用，下面探讨如何为php闭包附加并封装状态，javascript开发者可能对php的闭包感到奇怪，因为php闭包不会像真正的javascript闭包那样自动封装应用的状态，在php中，必须手动调用闭包对象的bindTo()方法或者使用use关键字，把状态附加到php闭包上。 使用use关键字附加闭包状态常见的多，因此我们先看这种方式，使用use关键字把变量附加到闭包上时，附加的变量会记住附件时付给他的值。12345678910function enclosePerson($name)&#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125; $clay = enclosePerson('Clay'); echo $clay('get me sweet tea!'); 以上代码输出：Clay get me sweet tea 使用use关键字，把多个参数传入闭包时，需要还是用，号分隔开。 具名函数enclosePerson()有个名为$name的参数，这个函数返回一个闭包对象，而且这个闭包对象封装了 $name参数， 即便 返回的闭包对象跳出了enclosePerson()函数的作用域，它也会记住$name参数的值，因为$name变量仍在闭包中。 使用bindTo方法附加闭包的状态 别忘了php 闭包是对象，与任何其他的php对象类似，每个闭包实例都可以使用$this关键字获取闭包的内部状态。闭包对象的默认状态没什么用，不过有一个 __invoke()魔术方法和bindTo()方法，仅此而已。但是bindTo() 方法为闭包增加了一些有趣的潜力，我们可以使用这个方法把Closure对象的内部状态绑定到其他的对象上，bindTo() 方法的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的php类，因此闭包可以访问绑定闭包的对象中受保护和私有的成员变量。 你会发现，php框架经常使用bindTo()方法把路由URL映射到匿名回调函数上，框架会把匿名函数绑定到应用对象上，这么做可以在这个匿名函数中使用$this关键字引用重要的对象。 例子：123456789101112131415161718192021222324252627class APP&#123; protected $routes = array(); protected $responseStatus = '200 ok'; protected $responseContentType = 'text/html'; protected $responseBody = 'hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this, __CLASS__); &#125; public function dispath($currentPath) &#123; foreach ($this-&gt;routes as $routePath =&gt; $callback) &#123; if ($routePath == $currentPath) &#123; $callback(); &#125; &#125; header('HTTP/1.1'. $this-&gt;responseStatus); header('Content-type' . $this-&gt;responseContentType); header('Content-length' . $this-&gt;responseBody); echo $this-&gt;responseBody; &#125;&#125; 我们要特别注意addRoute方法，这个方法的参数分别是一个路由路径和路由回调，dispatch() 方法的参数是当前的HTTP请 求的 路径，它会调用匹配的路由回调，我们把路由绑定到当前的App实例上，这么做就能再回调函数中处理App实例的状态 。123456$app = new App();$app-&gt;addRoute('/users/josh', function () &#123; $this-&gt;responseContentType = 'application/json; charset=utf8'; $this-&gt;responseBody = '&#123;"name" : "yee Jason"&#125;';&#125;);$app-&gt;dispatch('/users/josh'); 匿名函数提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样：123$func = function() &#123; &#125;; //带结束符 可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：123456$func = function( $param ) &#123; echo $param;&#125;;$func( 'some string' );//输出：//some string 顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。 实现闭包将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。 下边有三个例子 12345678910111213141516171819202122232425262728293031323334//例一//在函数里定义一个匿名函数，并且调用它function printStr() &#123; $func = function( $str ) &#123; echo $str; &#125;; $func( 'some string' );&#125;printStr();//例二//在函数中把匿名函数返回，并且调用它function getPrintStrFunc() &#123; $func = function( $str ) &#123; echo $str; &#125;; return $func;&#125;$printStrFunc = getPrintStrFunc();$printStrFunc( 'some string' );//例三//把匿名函数当做参数传递，并且调用它function callFunc( $func ) &#123; $func( 'some string' );&#125;$printStrFunc = function( $str ) &#123; echo $str;&#125;;callFunc( $printStrFunc );//也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉callFunc( function( $str ) &#123; echo $str;&#125;); 连接闭包和外界变量的关键字：USE12345678910111213function getMoney() &#123; $rmb = 1; $dollar = 6; $func = function() use ( $rmb ) &#123; echo $rmb; echo $dollar; &#125;; $func();&#125;getMoney();//输出：//1//报错，找不到dorllar变量 闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。 换一个例子看看： 可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。 有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的： 1234567891011121314function getMoney() &#123; $rmb = 1; $func = function() use ( $rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney();//输出：//1//1 啊，原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。 要达到这种效果，其实在变量前加一个 &amp; 符号就可以了： 1234567891011121314function getMoney() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney();//输出：//1//2 好，这样匿名函数就可以引用上下文的变量了。如果将匿名函数返回给外界，匿名函数会保存use所引用的变量，而外界则不能得到这些变量，这样形成‘闭包’这个概念可能会更清晰一些。 12345678910111213141516function getMoneyFunc() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; return $func;&#125;$getMoney = getMoneyFunc();$getMoney();$getMoney();$getMoney();//输出：//1//2//3 总结PHP闭包的特性并没有太大惊喜，其实用CLASS就可以实现类似甚至强大得多的功能，更不能和js的闭包相提并论，只能期待PHP以后对闭包支持的改进。不过匿名函数还是挺有用的，比如在使用preg_replace_callback等之类的函数可以不用在外部声明回调函数了。 一、闭包总结把一个闭包转换为某个类的方法(只是这个方法不需要通过对象调用), 这样闭包中的$this、static、self就转换成了对应的对象或类 把闭包当成对象的成员方法或者静态成员方法.12Closure::bind($cl1, null, 'A'); //就相当于在类里面加了个静态成员方法Closure::bind($cl2, new A(), 'A'); //相当于在类里面加了个成员方法 成员方法中使用$this访问对象, 静态成员方法直接使用类名::成员的方法.但是因为是匿名函数, 没有函数名, 所以返回一个已经绑定$this对象和类作用域的闭包给你使用. 二、闭包基本用法闭包（Closure）又叫做匿名函数，也就是没有定义名字的函数。比如下面的例子：12345678910111213141516171819202122232425262728// 定义一个闭包，并把它赋给变量 $f$f = function () &#123; return 7;&#125;// 使用闭包也很简单$f(); //这样就调用了闭包，输出 7// 当然更多的时候是把闭包作为参数(回调函数)传递给函数function testClosure (Closure $callback) &#123; return $callback();&#125;// $f 作为参数传递给函数 testClosure，如果是普遍函数是没有办法作为testClosure的参数的testClosure($f);// 也可以直接将定义的闭包作为参数传递，而不用提前赋给变量testClosure (function () &#123; return 7;&#125;);// 闭包不止可以做函数的参数，也可以作为函数的返回值function getClosure () &#123; return function () &#123; return 7; &#125;;&#125;$c = getClosure(); // 函数返回的闭包就复制给 $c 了$c(); // 调用闭包，返回 7 三、闭包类（Closure）定义一个闭包函数，其实是产生了一个闭包类（Closure）的对象，Closure 类摘要如下1234Closure &#123; public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) public Closure bindTo (object $newthis [, mixed $newscope = 'static' ]) &#125; 方法说明：Closure::bind： 复制一个闭包，绑定指定的 $this 对象和类作用域。Closure::bindTo： 复制当前闭包对象，绑定指定的 $this 对象和类作用域。下面将介绍Closure::bind和Closure::bindTo参数和返回值说明：closure：表示需要绑定的闭包对象。newthis：表示需要绑定到闭包对象的对象，或者 NULL 创建未绑定的闭包。newscope：表示想要绑定给闭包的类作用域，可以传入类名或类的示例，默认值是’static’， 表示不改变。该方法成功时返回一个新的 Closure 对象，失败时返回 FALSE。123456789101112131415161718192021222324252627282930313233343536class Animal &#123; private static $cat = "cat"; private $dog = "dog"; public $pig = "pig"; &#125; /* * 获取Animal类静态私有成员属性 */ $cat = static function() &#123; return Animal::$cat; &#125;; /* * 获取Animal实例私有成员属性 */ $dog = function() &#123; return $this-&gt;dog; &#125;; /* * 获取Animal实例公有成员属性 */ $pig = function() &#123; return $this-&gt;pig; &#125;; $bindCat = Closure::bind($cat, null, new Animal());// 给闭包绑定了Animal实例的作用域，但未给闭包绑定$this对象 $bindDog = Closure::bind($dog, new Animal(), 'Animal');// 给闭包绑定了Animal类的作用域，同时将Animal实例对象作为$this对象绑定给闭包 $bindPig = Closure::bind($pig, new Animal());// 将Animal实例对象作为$this对象绑定给闭包,保留闭包原有作用域 echo $bindCat(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过作用域限定操作符获取Animal类静态私有成员属性 echo $bindDog(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象(Animal实例对象)获取Animal实例私有成员属性 echo $bindPig(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象获取Animal实例公有成员属性// bindTo与bind类似，是面向对象的调用方式，这里只举一个，其他类比就可以$bindCat = $cat-&gt;bindTo(null, 'Animal'); 以上示例输出：123catdogpig 四、连接闭包和外界变量的关键字：USE 闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用 use 关键字。12345678910111213function getMoney() &#123; $rmb = 1; $dollar = 6; $func = function() use ( $rmb ) &#123; echo $rmb; echo $dollar; &#125;; $func();&#125;getMoney();//输出：//1//报错，找不到dorllar变量 可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。 有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的：1234567891011121314function getMoney() &#123; $rmb = 1; $func = function() use ( $rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney();//输出：//1//1 原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。要达到这种效果，其实在变量前加一个 &amp; 符号就可以了：1234567891011121314151617function getMoneyFunc() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; return $func;&#125;$getMoney = getMoneyFunc();$getMoney();$getMoney();$getMoney();//输出：//1//2//3 匿名函数实现一个简单的匿名函数： 上面就是一个简单的匿名函数，定义一个函数体，将函数体赋值给一个变量（php5.3之后支持该写法）。 实现闭包1、当做参数传递： 2、将匿名函数返回： 捕获外界变量闭包： 闭包是词法作用于的体现，一个持有外部环境自由变量的函数就是闭包。闭包体现的是在程序运行过程中，由 “不确定”变为“ 确定” 的过程。 捕获外部变量：在PHP中对捕获这一动作有了更清晰的表现，使用use关键字。如上面例2。 在上面的例2中，匿名函数$func通过use关键字捕获了外部的自由变量$param，在调用时通过传入cFunc()函数的参数123（$param此时会变为“确定”状态），进而调用匿名函数时输出“params:456 123”。 use引入的是自由变量的副本。 golang闭包： 在golang中同样通过匿名函数实现了闭包，和PHP不同的是，golang中的闭包是默认会引入上下文的自由变量，且引入的地址，即在闭包函数内部修改变量会在函数外部生效。 PHP Closure类用于代表匿名函数类。在PHP中定义一个闭包函数其实就是一个Closure类的实例。 类摘要123456789Closure &#123;/* 方法 */__construct ( void )public static bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) : Closurepublic bindTo ( object $newthis [, mixed $newscope = 'static' ] ) : Closure Closure::__construct — 用于禁止实例化的构造函数 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。Closure::bind复制一个闭包，绑定指定的$this对象和类作用域，返回一个新的匿名函数 参数说明：closure： 需要绑定的匿名函数。newthis： 需要绑定到匿名函数的对象，或者 NULL 创建未绑定的闭包。（ 理解：可以选择是否将匿名函数绑定到一个类对象，若绑定到了一个类对象，则可以在匿名函数内使用 $this ，否则不可使用。 ）newscope： 想要绑定给闭包的类作用域，或者 ‘static’ 表示不改变。如果传入一个对象，则使用这个对象的类型名。类作用域用来决定在闭包中 $this 对象的 私有、保护方法 的可见性。（ 理解：如果传入一个类，则可以访问类的static、private、protected属性，否则只能访问public属性。 ）简单理解：可以简单理解为将该匿名函数绑定到一个类或实例。根据参数的不同，可以访问不同的类的属性。 输出：1234567891011bind catstring(3) &quot;cat&quot;bind dogstring(3) &quot;dog&quot;bind dog2Fatal error: Using $this when not in object context Closure::bindToClosure::bind()的非静态形式。 小结PHP通过匿名函数实现闭包。可以通过将匿名函数作为参数或返回值实现闭包。可以通过use关键字引入外部变量，且引入的变量副本。匿名函数均实现了Closure类，且可以通过Closure::bind()方法将匿名函数绑定到某个类。以上是文章全部内容，有需要学习交流的友人请加入Swoole交流群的咱们一起，有问题一起交流，一起进步！前提是你是学技术的。感谢阅读！ 面向对象变成语言代码的复用主要采用继承来实现，而函数的复用，就是通过闭包来实现。这就是闭包的设计初衷。 注：PHP里面闭包函数是为了复用函数而设计的语言特性，如果在闭包函数里面访问指定域的变量，使用use关键字来实现。 PHP具有面向函数的编程特性，但是也是面向对象编程语言，PHP 会自动把闭包函数转换成内置类 Closure 的对象实例，依赖Closure 的对象实例又给闭包函数添加了更多的能力。 闭包不能被实例(私有构造函数)，也不能被继承(finally 类)。可以通过反射来判断闭包实例是否能被实例，继承。 匿名函数 提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185$func = function() &#123; &#125;; //带结束符``` 可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：```php$func = function( $param ) &#123; echo $param;&#125;;$func( 'some string' ); //输出：//some string``` 顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。 实现闭包将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。 连接闭包和外界变量的关键字：USEPHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。```phpfunction getMoney() &#123; $rmb = 1; $func = function() use ( $rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb; //闭包内的变量改变了，但是闭包外没有改变。&#125;getMoney(); //输出：//1//1``` 注：use所引用的是变量的复制(副本而），并不是完全引用变量。如果要达到引用的效果，就需要使用 &amp; 符号，进行引用传递参数。```phpfunction getMoney() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney(); //输出：//1//2``` 总结： 闭包函数不能直接访问闭包外的变量，而是通过use 关键字来调用上下文变量(闭包外的变量)，也就是说通过use来引用上下文的变量；闭包内所引用的变量不能被外部所访问(即，内部对变量的修改，外部不受影响)，若想要在闭包内对变量的改变从而影响到上下文变量的值，需要使用&amp;的引用传参。PHP Closure 类是用于代表匿名函数的类，匿名函数（在 PHP 5.3 中被引入）会产生这个类型的对象，Closure类摘要如下：```phpClosure &#123; __construct ( void ) public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) public Closure bindTo (object $newthis [, mixed $newscope = 'static' ])&#125;``` 方法说明：Closure::\_\_construct — 用于禁止实例化的构造函数Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 除了此处列出的方法，还有一个 \_\_invoke 方法。这是为了与其他实现了 \_\_invoke()魔术方法 的对象保持一致性，但调用闭包对象的过程与它无关。 参数说明：closure表示需要绑定的闭包对象。newthis表示需要绑定到闭包对象的对象，或者NULL创建未绑定的闭包。newscope表示想要绑定给闭包的类作用域，可以传入类名或类的示例，默认值是 'static'， 表示不改变。 返回值：成功时返回一个新的 Closure 对象，失败时返回FALSE。 Closure::bind是Closure::bindTo的静态版本 例子：```phpclass Animal &#123; public $cat = 'cat'; public static $dog = 'dog'; private $pig = 'pig'; private static $duck = 'duck';&#125; //不能通过 $this 访问静态变量//不同通过 类名::私有静态变量，只能通过self,或者static,在类里面访问私有静态变量 $cat = function() &#123; return $this-&gt;cat;&#125;; $dog = static function () &#123; return Animal::$dog;&#125;; $pig = function() &#123; return $this-&gt;pig;&#125;; $duck = static function() &#123; //return Animal::$duck; 这样写，会报错，提示不能通过类名访问私有静态变量 return self::$duck; // return static::$duck&#125;; $bindCat = Closure::bind($cat, new Animal(), 'Animal');$bindCat2 = Closure::bind($cat, new Animal(), new Animal());echo $bindCat() . PHP_EOL;echo $bindCat2() . PHP_EOL; $bindDog = Closure::bind($dog, null, 'Animal');$bindDog2 = Closure::bind($dog, null, new Animal());echo $bindDog() . PHP_EOL;echo $bindDog2() . PHP_EOL; $bindPig = Closure::bind($pig, new Animal(), 'Animal');$bindPig2 = Closure::bind($pig, new Animal(), new Animal());echo $bindPig() . PHP_EOL;echo $bindPig2() . PHP_EOL; $bindDuck = Closure::bind($duck, null, 'Animal');$bindDuck2 = Closure::bind($duck, null, new Animal());echo $bindDuck() . PHP_EOL;echo $bindDuck2() . PHP_EOL;``` 通过上面的例子，可以看出函数复用得，可以把函数挂在不同的类上，或者对象上。 总结：1. 闭包内如果用 $this, 则 $this 只能调用非静态的属性，这和实际类中调用原则是一致的，且 Closure::bind() 方法的第2个参数不能为null，必须是一个实例 (因为$this,必须在实例中使用)，第三个参数可以是实例，可以是类字符串，或 static；2. 闭包内调用静态属性时，闭包必须声明为 static,同时Closure::bind()方法的第2个参数需要为null,因为 静态属性不需要实例，第3个参数可以是类字符串，实例，staic.php的闭包（Closure）也就是匿名函数。是PHP5.3引入的。闭包的语法很简单，需要注意的关键字就只有use，use意思是连接闭包和外界变量。```php$a = function() use($b) &#123; &#125; 闭包的几个作用：1 减少foreach的循环的代码比如手册http://php.net/manual/en/functions.anonymous.php 中的例子Cart1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php// 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。// 其中有一个方法用来计算购物车中所有商品的总价格。该方法使用了一个closure作为回调函数。class Cart&#123; const PRICE_BUTTER = 1.00; const PRICE_MILK = 3.00; const PRICE_EGGS = 6.95; protected $products = array(); public function add($product, $quantity) &#123; $this-&gt;products[$product] = $quantity; &#125; public function getQuantity($product) &#123; return isset($this-&gt;products[$product]) ? $this-&gt;products[$product] : FALSE; &#125; public function getTotal($tax) &#123; $total = 0.00; $callback = function ($quantity, $product) use ($tax, &amp;$total) &#123; $pricePerItem = constant(__CLASS__ . "::PRICE_" . strtoupper($product)); $total += ($pricePerItem * $quantity) * ($tax + 1.0); &#125;; array_walk($this-&gt;products, $callback); return round($total, 2);; &#125;&#125; $my_cart = new Cart; // 往购物车里添加条目$my_cart-&gt;add('butter', 1);$my_cart-&gt;add('milk', 3);$my_cart-&gt;add('eggs', 6); // 打出出总价格，其中有 5% 的销售税.print $my_cart-&gt;getTotal(0.05) . "\n";// The result is 54.29?&gt;``` 这里如果我们改造getTotal函数必然要使用到foreach 2 减少函数的参数```phpfunction html ($code , $id="", $class="")&#123; if ($id !== "") $id = " id = \"$id\"" ; $class = ($class !== "")? " class =\"$class\"":"&gt;"; $open = "&lt;$code$id$class"; $close = "&lt;/$code&gt;"; return function ($inner = "") use ($open, $close)&#123; return "$open$inner$close";&#125;; &#125; 如果是使用平时的方法，我们会把inner放到html函数参数中，这样不管是代码阅读还是使用都不如使用闭包 3 解除递归函数123456789101112131415161718192021&lt;?php $fib = function($n) use(&amp;$fib) &#123; if($n == 0 || $n == 1) return 1; return $fib($n - 1) + $fib($n - 2); &#125;; echo $fib(2) . "\n"; // 2 $lie = $fib; $fib = function()&#123;die('error');&#125;;//rewrite $fib variable echo $lie(5); // error because $fib is referenced by closure``` 注意上题中的use使用了&amp;，这里不使用&amp;会出现错误fib(n-1)是找不到function的（前面没有定义fib的类型）所以想使用闭包解除循环函数的时候就需要使用```php&lt;?php$recursive = function () use (&amp;$recursive)&#123;// The function is now available as $recursive&#125; 这样的形式 4 关于延迟绑定如果你需要延迟绑定use里面的变量，你就需要使用引用，否则在定义的时候就会做一份拷贝放到use中1234567891011121314151617&lt;?php$result = 0; $one = function()&#123; var_dump($result); &#125;; $two = function() use ($result)&#123; var_dump($result); &#125;; $three = function() use (&amp;$result)&#123; var_dump($result); &#125;; $result++; $one(); // outputs NULL: $result is not in scope$two(); // outputs int(0): $result was copied$three(); // outputs int(1) 使用引用和不使用引用就代表了是调用时赋值，还是申明时候赋值 PHP Closure类是用于代表匿名函数的类，匿名函数（在PHP5.3中被引入）会产生这个类型的对象，Closure类摘要如下：12345Closure &#123; __construct ( void ) public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) public Closure bindTo (object $newthis [, mixed $newscope = 'static' ])&#125; 方法说明： Closure::__construct — 用于禁止实例化的构造函数 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。 Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 除了此处列出的方法，还有一个__invoke 方法。这是为了与其他实现了__invoke()魔术方法 的对象保持一致性，但调用闭包对象的过程与它无关。 下面将介绍Closure::bind和Closure::bindTo。 Closure::bind是Closure::bindTo的静态版本，其说明如下：1public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) closure表示需要绑定的闭包对象。 newthis表示需要绑定到闭包对象的对象，或者NULL创建未绑定的闭包。 newscope表示想要绑定给闭包的类作用域，可以传入类名或类的示例，默认值是 ‘static’， 表示不改变。 该方法成功时返回一个新的Closure对象，失败时返回FALSE。 例子说明：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php/** * 复制一个闭包，绑定指定的$this对象和类作用域。 * * @author 疯狂老司机 */class Animal &#123; private static $cat = "cat"; private $dog = "dog"; public $pig = "pig";&#125; /* * 获取Animal类静态私有成员属性 */$cat = static function() &#123; return Animal::$cat;&#125;; /* * 获取Animal实例私有成员属性 */$dog = function() &#123; return $this-&gt;dog;&#125;; /* * 获取Animal实例公有成员属性 */$pig = function() &#123; return $this-&gt;pig;&#125;; $bindCat = Closure::bind($cat, null, new Animal());// 给闭包绑定了Animal实例的作用域，但未给闭包绑定$this对象$bindDog = Closure::bind($dog, new Animal(), 'Animal');// 给闭包绑定了Animal类的作用域，同时将Animal实例对象作为$this对象绑定给闭包$bindPig = Closure::bind($pig, new Animal());// 将Animal实例对象作为$this对象绑定给闭包,保留闭包原有作用域echo $bindCat(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过作用域限定操作符获取Animal类静态私有成员属性echo $bindDog(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象(Animal实例对象)获取Animal实例私有成员属性echo $bindPig(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象获取Animal实例公有成员属性?&gt; 输出：123catdogpig Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域，其说明如下：1public Closure Closure::bindTo (object $newthis [, mixed $newscope = 'static' ]) newthis表示绑定给闭包对象的一个对象，或者NULL来取消绑定。newscope表示关联到闭包对象的类作用域，可以传入类名或类的示例，默认值是 ‘static’， 表示不改变。该方法创建并返回一个闭包对象，它与当前对象绑定了同样变量，但可以绑定不同的对象，也可以绑定新的类作用域。绑定的对象决定了返回的闭包对象中的$this的取值，类作用域决定返回的闭包对象能够调用哪些方法，也就是说，此时$this可以调用的方法，与newscope类作用域相同。 例子1：12345678&lt;?phpfunction __autoload($class) &#123; require_once "$class.php";&#125; $template = new Template;$template-&gt;render(new Article, 'tpl.php');?&gt; Template.php 模板类12345678910111213141516171819202122232425&lt;?php/** * 模板类，用于渲染输出 * * @author 疯狂老司机 */class Template&#123; /** * 渲染方法 * * @access public * @param obj 信息类 * @param string 模板文件名 */ public function render($context, $tpl)&#123; $closure = function($tpl)&#123; ob_start(); include $tpl; return ob_end_flush(); &#125;; $closure = $closure-&gt;bindTo($context, $context); $closure($tpl); &#125; &#125; Article.php 信息类12345678910&lt;?php/** * 文章信息类 * * @author 疯狂老司机 */class Article&#123; private $title = "这是文章标题"; private $content = "这是文章内容";&#125; tpl.php 模板文件12345678910&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;?php echo $this-&gt;title;?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $this-&gt;content;?&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 运行时确保以上文件位于同级目录。输出：12这是文章标题这是文章内容 例子2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php/** * 给类动态添加新方法 * * @author 疯狂老司机 */trait DynamicTrait &#123; /** * 自动调用类中存在的方法 */ public function __call($name, $args) &#123; if(is_callable($this-&gt;$name))&#123; return call_user_func($this-&gt;$name, $args); &#125;else&#123; throw new \RuntimeException("Method &#123;$name&#125; does not exist"); &#125; &#125; /** * 添加方法 */ public function __set($name, $value) &#123; $this-&gt;$name = is_callable($value)? $value-&gt;bindTo($this, $this): $value; &#125;&#125; /** * 只带属性不带方法动物类 * * @author 疯狂老司机 */class Animal &#123; use DynamicTrait; private $dog = 'dog';&#125; $animal = new Animal; // 往动物类实例中添加一个方法获取实例的私有属性$dog$animal-&gt;getdog = function() &#123; return $this-&gt;dog;&#125;; echo $animal-&gt;getdog(); ?&gt; 输出：1dog 例子3：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * 一个基本的购物车，包括一些已经添加的商品和每种商品的数量 * * @author 疯狂老司机 */class Cart &#123; // 定义商品价格 const PRICE_BUTTER = 1.00; const PRICE_MILK = 3.33; const PRICE_EGGS = 8.88; protected $products = array(); /** * 添加商品和数量 * * @access public * @param string 商品名称 * @param string 商品数量 */ public function add($item, $quantity) &#123; $this-&gt;products[$item] = $quantity; &#125; /** * 获取单项商品数量 * * @access public * @param string 商品名称 */ public function getQuantity($item) &#123; return isset($this-&gt;products[$item]) ? $this-&gt;products[$item] : FALSE; &#125; /** * 获取总价 * * @access public * @param string 税率 */ public function getTotal($tax) &#123; $total = 0.00; $callback = function ($quantity, $item) use ($tax, &amp;$total) &#123; $pricePerItem = constant(__CLASS__ . "::PRICE_" . strtoupper($item)); $total += ($pricePerItem * $quantity) * ($tax + 1.0); &#125;; array_walk($this-&gt;products, $callback); return round($total, 2);; &#125;&#125; $my_cart = new Cart; // 往购物车里添加商品及对应数量$my_cart-&gt;add('butter', 10);$my_cart-&gt;add('milk', 3);$my_cart-&gt;add('eggs', 12); // 打出出总价格，其中有 5% 的销售税.echo $my_cart-&gt;getTotal(0.05); ?&gt; 输出：1132.88 补充说明：闭包可以使用USE关键连接外部变量。 总结：合理使用闭包能使代码更加简洁和精炼。 PHP核心特性-匿名函数提出在匿名函数出现之前，所有的函数都需要先命名才能使用：123456function increment($value)&#123; return $value + 1;&#125;array_map('increment', [1, 2, 3]); 有的时候函数可能只需要使用一次，这时候使用匿名函数会使得代码更加简洁直观，同时也避免了函数在其他地方被使用：123array_map(function($value)&#123; return $value + 1;&#125;, [1, 2, 3]); 定义和使用PHP将闭包和匿名函数视为同等概念（本文统称为匿名函数），本质上都是伪装成函数的对象。 匿名函数的本质是对象，因此跟对象一样可将匿名函数赋值给某一变量：12345$greet = function(string $name)&#123; echo "hello &#123;$name&#125;";&#125;$greet("jack") // hello jack 所有的匿名函数都是Closure对象的实例：1$greet instanceof Closure // true 对象并没有什么父作用域可言，所以需要使用use来手动声明使用的变量：1234567$num = 1;$func = function() use($num)&#123; $num = $num + 1; echo $num;&#125;$func(); // 2echo $num; // 还是 1 如果要让匿名函数中的变量生效，需要使用引用传值：1234567$num = 1;$func = function() use(&amp;$num)&#123; $num = $num + 1; echo $num;&#125;$func(); // 2echo $num; // 2 从PHP5.4开始，在类里面使用匿名函数时，匿名函数的$this将自动绑定到当前类：123456789101112class Foo &#123; public function bar() &#123; return function() &#123; return $this; &#125;; &#125;&#125;$foo = new Foo();$obj = $foo-&gt;bar(); // Closure()$obj(); // Foo 如果不想让自动绑定生效，可使用静态匿名函数：1234567891011class Foo &#123; public function bar() &#123; return static function() &#123; return $this; &#125;; &#125;&#125;$foo = new Foo();$obj = $foo-&gt;bar(); // Closure()$obj(); // Using $this when not in object context 匿名函数的本质匿名函数的本质是Closure对象，包括了以下五个方法1234567Closure &#123; private __construct ( void ) public static bind ( Closure $closure , object $newthis [, mixed $newscope = "static" ] ) : Closure public bindTo ( object $newthis [, mixed $newscope = "static" ] ) : Closure public call ( object $newthis [, mixed $... ] ) : mixed public static fromCallable ( callable $callable ) : Closure&#125; __construct - 防止匿名函数被实例化12$closure = new \Closure();// PHP Error: Instantiation of 'Closure' is not allowed Closure::bindTo - 复制当前匿名函数对象，绑定指定的 $this 对象和类作用域。通俗的说，就是手动将匿名函数与指定对象绑定，利用这点，可以扩展对象的功能。123456789101112131415161718192021222324// 定义商品类class Good &#123; private $price; public function __construct(float $price) &#123; $this-&gt;price = $price; &#125;&#125;// 定义一个匿名函数，计算商品的促销价$addDiscount = function(float $discount = 0.8)&#123; return $this-&gt;price * $discount;&#125;$good = new Good(100);// 将匿名函数绑定到 $good 实例，同时指定作用域为 Good$count = $addDiscount-&gt;bindTo($good, Good::class); $count(); // 80// 将匿名函数绑定到 $good 实例，但是不指定作用域，将无法访问 $good 的私有属性$count = $addDiscount-&gt;bindTo($good); $count(); // 报错 Closure::bind - bindTo 方法的静态版本，有两种用法： 用法一：实现与bindTo方法同样的效果1$count = \Closure::bind($addDiscount, $good, Good::class); 用法二：将匿名函数与类（而不是对象）绑定，记得要将第二个参数设置为 null123456789101112131415// 商品库存为 10class Good &#123; static $num = 10;&#125;// 每次销售后返回当前库存$sell = static function() &#123; return"当前库存为". --static::$num ;&#125;;// 将静态匿名函数绑定到 Good 类中$sold = \Closure::bind($sell, null, Good::class);$sold(); // 当前库存为 9$sold(); // 当前库存为 8 call - PHP7新增的call方法可以实现绑定并调用匿名函数，除了语法更加简洁外，性能也更高123456// call 版本$addDiscount-&gt;call($good, 0.5); // 绑定并传入参数 0.5，结果为 50// bindTo 版本$count = $addDiscount-&gt;bindTo($good, Good::class); $count(0.5); // 50 fromCallable - 将给定的 callable 函数转化成匿名函数123456789101112131415161718class Good &#123; private $price; public function __construct(float $price) &#123; $this-&gt;price = $price; &#125;&#125;function addDiscount(float $discount = 0.8)&#123; return $this-&gt;price * $discount;&#125;$closure = \Closure::fromCallable('addDiscount');$good = new Good(100);$count = $closure-&gt;bindTo($good); $count = $closure-&gt;bindTo($good, Good::class); // 报错，不能重复绑定作用域$count(); // 报错，无法访问私有属性 fromCallable 等价于12$reflexion = new ReflectionFunction('addDiscount');$closure = $reflexion-&gt;getClosure(); 这里有一点需要特别注意的是，无论是fromCallable转化成的闭包，还是使用反射得到的闭包，在使用 bindTo 时，如果第二个参数指定绑定类，会报错1Cannot rebind scope of closure created by ReflectionFunctionAbstract::getClosure()]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Facade]]></title>
    <url>%2F2020%2F03%2F10%2FLaravel-Facade%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介门面为应用服务容器中的绑定类提供了一个「静态」接口。Laravel内置了很多门面，你可能在不知道的情况下正在使用它们。Laravel的门面作为服务容器中底层类的「静态代理」，相比于传统静态方法，在维护时能够提供更加易于测试、更加灵活、简明优雅的语法。 Laravel的所有门面都定义在Illuminate\Support\Facades命名空间下，所以我们可以轻松访问到门面：12345use Illuminate\Support\Facades\Cache;Route::get('/cache', function () &#123; return Cache::get('key');&#125;); 在整个Laravel文档中，很多例子使用了门面来演示框架的各种功能特性。 何时使用门面门面有诸多优点，其提供了简单、易记的语法，让我们无需记住长长的类名即可使用Laravel提供的功能特性，此外，由于他们对PHP动态方法的独到用法，使得它们很容易测试。 但是，使用门面也有需要注意的地方，一个最主要的危险就是类范围蠕变。由于门面如此好用并且不需要注入，在单个类中使用过多门面，会让类很容易变得越来越大。使用依赖注入则会让此类问题缓解，因为一个巨大的构造函数会让我们很容易判断出类在变大。因此，使用门面的时候要尤其注意类的大小，以便控制其有限职责。 注：构建与Laravel交互的第三方扩展包时，最好注入Laravel契约而不是使用门面，因为扩展包在Laravel之外构建，你将不能访问Laravel的门面测试辅助函数。 门面 vs. 依赖注入依赖注入的最大优点是可以替换注入类的实现，这在测试时很有用，因为你可以注入一个模拟或存根并且在存根上断言不同的方法。 但是在静态类方法上进行模拟或存根却行不通，不过，由于门面使用了动态方法对服务容器中解析出来的对象方法调用进行了代理，我们也可以像测试注入类实例那样测试门面。例如，给定以下路由： 12345use Illuminate\Support\Facades\Cache;Route::get('/cache', function () &#123; return Cache::get('key');&#125;); 我们可以这样编写测试来验证 Cache::get 方法以我们期望的方式被调用： 12345678910111213141516use Illuminate\Support\Facades\Cache;/** * A basic functional test example. * * @return void */public function testBasicExample()&#123; Cache::shouldReceive('get') -&gt;with('key') -&gt;andReturn('value'); $this-&gt;visit('/cache') -&gt;see('value');&#125; 门面 vs. 辅助函数除了门面之外，Laravel还内置了许多辅助函数用于执行通用任务，比如生成视图、触发事件、分配任务，以及发送 HTTP 响应等。很多辅助函数提供了和相应门面一样的功能，例如，下面这个门面调用和辅助函数调用是等价的：12return View::make('profile');return view('profile'); 门面和辅助函数之间并不存在实质性差别，使用辅助函数的时候，可以像测试相应门面那样测试它们。例如，给定以下路由：123Route::get('/cache', function () &#123; return cache('key');&#125;); 在调用底层，cache方法会去调用Cache门面上的get方法，因此，尽管我们使用这个辅助函数，我们还是可以编写如下测试来验证这个方法以我们期望的方式和参数被调用：12345678910111213141516use Illuminate\Support\Facades\Cache;/** * A basic functional test example. * * @return void */public function testBasicExample()&#123; Cache::shouldReceive('get') -&gt;with('key') -&gt;andReturn('value'); $this-&gt;visit('/cache') -&gt;see('value');&#125; 门面工作原理在Laravel应用中，门面就是一个为容器中对象提供访问方式的类。该机制原理由Facade类实现。Laravel自带的门面，以及我们创建的自定义门面，都会继承自Illuminate\Support\Facades\Facade基类。 门面类只需要实现一个方法：getFacadeAccessor。正是getFacadeAccessor方法定义了从容器中解析什么，然后Facade基类使用魔术方法__callStatic()从你的门面中调用解析对象。 下面的例子中，我们将会调用Laravel的缓存系统，浏览代码后，也许你会觉得我们调用了Cache 的静态方法get：123456789101112131415161718192021&lt;?phpnamespace App\Http\Controllers;use Cache;use App\Http\Controllers\Controller;class UserController extends Controller&#123; /** * 为指定用户显示属性 * * @param int $id * @return Response */ public function showProfile($id) &#123; $user = Cache::get('user:'.$id); return view('profile', ['user' =&gt; $user]); &#125;&#125; 注意我们在顶部位置引入了Cache门面。该门面作为代理访问底层Illuminate\Contracts\Cache\Factory接口的实现。我们对门面的所有调用都会被传递给Laravel缓存服务的底层实例。 如果我们查看Illuminate\Support\Facades\Cache类的源码，将会发现其中并没有静态方法get：1234567891011class Cache extends Facade&#123; /** * 获取组件注册名称 * * @return string */ protected static function getFacadeAccessor() &#123; return 'cache'; &#125;&#125; Cache门面继承Facade基类并定义了getFacadeAccessor方法，该方法的工作就是返回服务容器绑定类的别名，当用户引用Cache类的任何静态方法时，Laravel从服务容器中解析cache绑定，然后在解析出的对象上调用所有请求方法（本例中是 get）。 实时门面使用实时门面，可以将应用中的任意类当做门面来使用。为了说明如何使用这个功能，我们先看一个替代方案。例如我们假设Podcast模型有一个publish方法，尽管如此，为了发布博客，我们需要注入Publisher实例： 12345678910111213141516171819202122&lt;?phpnamespace App;use App\Contracts\Publisher;use Illuminate\Database\Eloquent\Model;class Podcast extends Model&#123; /** * Publish the podcast. * * @param Publisher $publisher * @return void */ public function publish(Publisher $publisher) &#123; $this-&gt;update(['publishing' =&gt; now()]); $publisher-&gt;publish($this); &#125;&#125; 因为可以模拟注入的发布服务，所以注入发布实现到该方法后允许我们轻松在隔离状态下测试该方法。不过，这要求我们每次调用 publish 方法都要传递一个发布服务实例，使用实时门面，我们可以在维持这种易于测试的前提下不必显式传递Publisher实例。要生成一个实时门面，在导入类前面加上Facades命名空间前缀即可：123456789101112131415161718192021&lt;?phpnamespace App;use Facades\App\Contracts\Publisher;use Illuminate\Database\Eloquent\Model;class Podcast extends Model&#123; /** * Publish the podcast. * * @return void */ public function publish() &#123; $this-&gt;update(['publishing' =&gt; now()]); Publisher::publish($this); &#125;&#125; 使用实时门面后，发布服务实现将会通过使用Facades前缀后的接口或类名在服务容器中解析。在测试的时候，我们可以使用Laravel自带的门面测试辅助函数来模拟这个方法调用： 123456789101112131415161718192021222324252627&lt;?phpnamespace Tests\Feature;use App\Podcast;use Tests\TestCase;use Facades\App\Contracts\Publisher;use Illuminate\Foundation\Testing\RefreshDatabase;class PodcastTest extends TestCase&#123; use RefreshDatabase; /** * A test example. * * @return void */ public function test_podcast_can_be_published() &#123; $podcast = factory(Podcast::class)-&gt;create(); Publisher::shouldReceive('publish')-&gt;once()-&gt;with($podcast); $podcast-&gt;publish(); &#125;&#125; Facade123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137namespace Illuminate\Support\Facades;use Closure;use Mockery;use Mockery\MockInterface;use RuntimeException;abstract class Facade&#123; /** * The application instance being facaded. * * @var \Illuminate\Contracts\Foundation\Application */ protected static $app; // 两个函数有这个有关 /** * The resolved object instances. * * @var array */ protected static $resolvedInstance; // 重点在维护这个数组，有两个清除函数 public static function resolved(Closure $callback) &#123; $accessor = static::getFacadeAccessor(); if (static::$app-&gt;resolved($accessor) === true) &#123; $callback(static::getFacadeRoot()); &#125; &#125; /** * Get the registered name of the component. * * @return string * * @throws \RuntimeException */ protected static function getFacadeAccessor() &#123; throw new RuntimeException('Facade does not implement getFacadeAccessor method.'); &#125; /** * Get the root object behind the facade. * * @return mixed */ public static function getFacadeRoot() &#123; return static::resolveFacadeInstance(static::getFacadeAccessor()); &#125; /** * Resolve the facade root instance from the container. * * @param object|string $name * @return mixed */ protected static function resolveFacadeInstance($name) &#123; if (is_object($name)) &#123; return $name; &#125; if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; if (static::$app) &#123; return static::$resolvedInstance[$name] = static::$app[$name]; &#125; &#125; /** * Clear a resolved facade instance. * * @param string $name * @return void */ public static function clearResolvedInstance($name) &#123; unset(static::$resolvedInstance[$name]); &#125; /** * Clear all of the resolved instances. * * @return void */ public static function clearResolvedInstances() &#123; static::$resolvedInstance = []; &#125; /** * Get the application instance behind the facade. * * @return \Illuminate\Contracts\Foundation\Application */ public static function getFacadeApplication() &#123; return static::$app; &#125; /** * Set the application instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public static function setFacadeApplication($app) &#123; static::$app = $app; &#125; /** * Handle dynamic, static calls to the object. * * @param string $method * @param array $args * @return mixed * * @throws \RuntimeException */ public static function __callStatic($method, $args) &#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException('A facade root has not been set.'); &#125; return $instance-&gt;$method(...$args); &#125;&#125; Event12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpnamespace Illuminate\Support\Facades;use Illuminate\Database\Eloquent\Model;use Illuminate\Support\Testing\Fakes\EventFake;/** * @method static void listen(string|array $events, \Closure|string $listener) * @method static bool hasListeners(string $eventName) * @method static void push(string $event, array $payload = []) * @method static void flush(string $event) * @method static void subscribe(object|string $subscriber) * @method static array|null until(string|object $event, mixed $payload = []) * @method static array|null dispatch(string|object $event, mixed $payload = [], bool $halt = false) * @method static array getListeners(string $eventName) * @method static \Closure makeListener(\Closure|string $listener, bool $wildcard = false) * @method static \Closure createClassListener(string $listener, bool $wildcard = false) * @method static void forget(string $event) * @method static void forgetPushed() * @method static \Illuminate\Events\Dispatcher setQueueResolver(callable $resolver) * @method static void assertDispatched(string $event, callable|int $callback = null) * @method static void assertDispatchedTimes(string $event, int $times = 1) * @method static void assertNotDispatched(string $event, callable|int $callback = null) * * @see \Illuminate\Events\Dispatcher */class Event extends Facade&#123; /** * Replace the bound instance with a fake. * * @param array|string $eventsToFake * @return \Illuminate\Support\Testing\Fakes\EventFake */ public static function fake($eventsToFake = []) &#123; static::swap($fake = new EventFake(static::getFacadeRoot(), $eventsToFake)); Model::setEventDispatcher($fake); Cache::refreshEventDispatcher(); return $fake; &#125; /** * Replace the bound instance with a fake during the given callable's execution. * * @param callable $callable * @param array $eventsToFake * @return callable */ public static function fakeFor(callable $callable, array $eventsToFake = []) &#123; $originalDispatcher = static::getFacadeRoot(); static::fake($eventsToFake); return tap($callable(), function () use ($originalDispatcher) &#123; static::swap($originalDispatcher); Model::setEventDispatcher($originalDispatcher); Cache::refreshEventDispatcher(); &#125;); &#125; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'events'; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中钩子函数的实现与认识]]></title>
    <url>%2F2020%2F03%2F06%2FPHP%E4%B8%AD%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 假如有这么一段程序：12345function fun()&#123; fun1(); fun2();&#125; 首先程序执行完fun1()之后执行fun2()然后fun()结束。 但是，假如我们想对函数做一些变化。比如说，fun是一个解析函数，我们希望后期可以提供丰富的解析函数，而究竟用哪个函数解析，我们希望在配置文件中配置。这个时候就可以发挥钩子的力量了。 我们可以在function fun(){}中加入一个挂钩点H，然后在执行H这个函数之前，将钩子函数配置好，那么就可以根据需要来解析了。 例如:1234567// 从配置文件中获得相应的配置信息$h = config_item("parser_fun");function fun($data)&#123; global $h; return $h();&#125; 除此以外，PHP还可以根据字符串提供自己的类，然后调用类的一个方法，传递某些参数，这些就为PHP程序的编写，以及后期的维护扩展奠定了相当坚实的基础。 123$c=get_class_name(); //获得类的名字$m=get_method_name(); //获得方法的名字$k=$c-&gt;$m(); //执行类的某一个方法 1、钩子函数是预设并在特定的条件下触发的。2、钩子函数接管程序后可以影响到程序的走向。 钩子的完整实现应该叫事件驱动。事件驱动分为两个阶段，第一个阶段是注册事件，目的是给未来可能发生的“事件”起一个名字，简单的实现方法 是用单例模式产生一个持久的对象或者注册一个全局变量，然后将事件名称，以及该事件对应的类与方法插入全局变量即可。也就是挂载一个钩子。 第二个阶段是触发事件，本质上就是在事件的全局变量中查询要触发的事件名称，然后找到注册好的类与方法，实例化并运行。这样子就可以摆脱传统方式中程序必须按顺序的规则，进一步实现解除耦合的目的。 钩子函数可以截获并处理其他应用程序的消息。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用php数组函数进行函数式编程]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%88%A9%E7%94%A8php%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 函数式编程是什么样子的代码？ 绝大多数的for、foreach和while都可以用数组函数代替吗？ foreach有代码副作用怎么理解？array_walk有吗？ 数组内的值互相比较，累加的时候用array_reduce。怎么理解？ 旧代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for ($index = 0; $index &lt; count($scope) -1; $index++) &#123; $total = 0; $online = []; $tmp_k = []; foreach ($rs as $k =&gt; $v) &#123; if ($max == 0) &#123; $max = $v['online']; $data['max']['value'] = $v['online']; $data['max']['time'] = $v['time']; &#125; else &#123; if ($max &lt;= $v['online']) &#123; $data['max']['value'] = $v['online']; $data['max']['time'] = $v['time']; $max = $v['online']; &#125; &#125; $stamp = $v['stamp']; if ($stamp &gt; $scope[$index] &amp;&amp; $stamp &lt; $scope[$index + 1]) &#123; array_push($online, $v['online']); array_push($tmp_k, $k); &#125; else &#123; break; &#125; &#125; foreach ($tmp_k as $key) &#123; unset($rs[$key]); &#125; if(count($online)) &#123; array_push($data['info'], max($online)); &#125; else &#123; array_push($data['info'], 'null'); &#125;&#125; 这段代码实现了两个功能。 第一个是在一个从数据库中读取的列表数组中找出某个值是最大的一条记录， 并且把这个最大的值和跟这个值相关的时间给取出来。 第二个比较复杂，是将这个列表数组中的值映射到另外一个列表数组中，可以把这个过程看作是SQL中的JOIN操作，只是JOIN的条件异常复杂 ，在这里我也不详述了，阅读的同学也不必去深入探究。 重构123456789101112131415161718192021$maxInfo = array_reduce($rs, function($result, $item)&#123; if ($result['value'] &lt; $item['online']) &#123; $result['value'] = $item['online']; $result['time'] = $item['time']; &#125; return $result;&#125;, ['value' =&gt; 0]);$onlineInfo = array_map(function($item) use ($rs, $interval)&#123; $result = array_reduce($rs, function($value, $onlineItem) use ($item)&#123; $0 = abs($item - $onlineItem['stamp']); if($diff &lt;= $value['diff']) &#123; $value['diff'] = $diff; $value['val'] = $onlineItem['online']; &#125; return $value; &#125;, ['diff' =&gt; $interval, 'val' =&gt; 'null']); return $result['val'];&#125;, $scope); 从代码结构上来看， 重构后的代码的确清晰了不少。 我将原本拥挤在一起的两个功能进行了拆分，上面部份是求最大值，下面部份是对两个数组进行映射。这里我用到了两个PHP中数组的函数array_map和array_reduce，这篇文章想表达的思想就是利用此类函数来提高PHP代码的可读性。这类函数主要包括以下4个函数： array_filter array_map array_walk array_reduce 这4个函数威力巨大， 在处理列表数组方面可以完全替换掉for、foreach、while这些循环控制语句，这也是函数式编程方式在PHP的一部份体现。 数组函数array_filter1234567891011121314151617181920$data = [ ['id' =&gt; 1, 'name' =&gt; '张三', '性别' =&gt; '男', 'age' =&gt; 20], ['id' =&gt; 2, 'name' =&gt; '李四', '性别' =&gt; '男', 'age' =&gt; 21], ['id' =&gt; 3, 'name' =&gt; '王五', '性别' =&gt; '男', 'age' =&gt; 22], ['id' =&gt; 4, 'name' =&gt; '甲', '性别' =&gt; '女', 'age' =&gt; 20], ['id' =&gt; 5, 'name' =&gt; '乙', '性别' =&gt; '女', 'age' =&gt; 27], ['id' =&gt; 6, 'name' =&gt; '丙', '性别' =&gt; '女', 'age' =&gt; 19], ['id' =&gt; 7, 'name' =&gt; '丁', '性别' =&gt; '女', 'age' =&gt; 18],];$result = [];foreach ($data as $item) &#123; if ($item['性别'] == '女') &#123; array_push($result, $item); &#125;&#125; 这段代码将数组中性别字段为女的数据项提取出来。这是原汁原味的命令式程序代码。 如果data变量中的数据并非存放于php数组中，而是存在于关系数库的表之中，那如何取得性别为女的数据结果呢？ 对于程序员来说这貌似是一个更加简单的问题，一句SQL语句就搞定了。1select * from data where 性别='女'; 显然， 利用SQL查询数据更加方便，意途也更加清晰，毕竟一个SQL表达式就将所有的程序逻辑都给表达了现来。这句SQL只表达了：“我需要性别为女的数据，至于怎么拿，我不管”，除了结果，其它的它一概不知。 我们不妨把这种思路引入到PHP程序设计之中，不也意味着我们的PHP程序的逻辑表达也更加清晰，代码的可读性也更高。所幸， 这种利用表达式编程的方法在PHP中也完全可以实现。123$result = array_filter($data, function($item)&#123; return $item['性别'] == '女';&#125;); 利用array_filter函数，可以轻松的完成这个任务， 仔细观察一下， 是不是原来的程序逻辑都不见了，包括定义数组、循环、条件判断这些都不见了，逻辑方面是只剩下了一个性别比较语句，这对于代码所实现的功能一目了然。 和上面的SQL比较一下，这里的性别判断语句就是SQL中where子句后面的条件判断，而array_filter函数其实就是SQL中的where子句。 这就是SQL语句面向结果编程的逻辑原封不变的在PHP中的体现，也就是时下最流行的“声明性编程”或者也称为“表达式编程”。 此外，代码中性别判断语句所在的位置称之为lambda表达式， 更通俗一些的叫法是匿名函数。不难看出，在SQL的where条件中编写条件判断远不如在匿名函数中写PHP代码来的灵活，在where条件中只能执行or和and逻辑，而在php匿名函数中可以随便怎么写，只要函数的返回值是个布尔值就可以了，这也是php声明性编程优于SQL声明性编程的地方。 array_map12345678$result = [];foreach ($data as $item) &#123; $item['gender'] = $item['性别'] == '男' ? 'male' : 'female'; unset($item['性别']); array_push($result, $item); &#125; 数据中的性别字段是中文的，值也是中文的，现在想把字段名和字段值都改为英文的，就可以用上面这段代码实现。 下面是利用SQL的实现方式： 1select id, name case 性别 when '男' then 'male' else 'female' end as gender from data; SQL中case when语句好像不太好看， 但是不影响整体逻辑的表达。将这段SQL转换成PHP的方式实现。1234567$result = array_map(function($item)&#123; return [ 'id' =&gt; $item['id'], 'name' =&gt; $item['name'], 'gender' =&gt; $item['性别'] == '男' ? 'male' : 'female' ]&#125;, $data); 相比之前的PHP实现， 是不是简洁明了了许多。 在这里使用到了array_map函数。在SQL语句中以select语句最为常用，select的字面意思是“选择”，而select语句也被称之为选择查询，事实上从关系数据库的角度来说，select被称之为“投影”，并不是查询什么的。换言之，select语句只是将SQL的查询结果以一定的方式（选字段、计算值等等）提取出来了。php中的array_map表达的也是这层意思，“映射”与“投影”完全是一种意思的不同表达。 很多情况下，迭代的数据一般为一个二维关联数组，但array_map本身在回调函数的函数体内无法获取到关联数组的下标的。 目的：在回调体内获取迭代关联数组的下标值。 解决：可以把关联数组的下标通过array_map()的第三个形参把下标传进去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php$arr = [ 'goods' =&gt; '辣条', 'spec' =&gt; [ 'attr' =&gt; [ '颜色', '口感', '副作用'], 'value' =&gt; [ '红色', '辣', 'The `菊花` is hot' ] ]];print_r($arr);/*Array( [goods] =&gt; 辣条 [spec] =&gt; Array ( [attr] =&gt; Array ( [0] =&gt; 颜色 [1] =&gt; 口感 [2] =&gt; 副作用 ) [value] =&gt; Array ( [0] =&gt; 红色 [1] =&gt; 辣 [2] =&gt; The `菊花` is hot ) ))*/$arr['spec'] = array_map(function($item, $key)&#123; return [ 'attr' =&gt; $key, 'value' =&gt; $item, ]; &#125;, $arr['spec']['value'], $arr['spec']['attr']);print_r($arr);/*Array( [goods] =&gt; 辣条 [spec] =&gt; Array ( [0] =&gt; Array ( [attr] =&gt; 颜色 [value] =&gt; 红色 ) [1] =&gt; Array ( [attr] =&gt; 口感 [value] =&gt; 辣 ) [2] =&gt; Array ( [attr] =&gt; 副作用 [value] =&gt; The `菊花` is hot ) ))*/ array_walkarray_walk函数没有像array_map和array_filter那样深刻的意义，但是它在设计可读性良好的代码时也是不可或缺的。 array_walk是for或foreach语句的替代函数。12345678foreach ($data as $item) &#123; echo $item['id'];&#125;array_walk($data, funcname($item)&#123; echo $item['id'];&#125;) 以上代码分别是foreach和array_walk对于遍历数组的实现方式。看起来，好像array_walk的实现方式更加复杂，但是在更深层次的语义方面foreach表达的是循环遍历，但是在这个循环的过程中，要做什么样的处理，是没有任何约束的， 删除被遍历的数组的某一项，或者修改一个十万八千里以外的变量的值，这便是所谓的“代码副作用”，俗话说“白蚁虽小，危害无穷”，当这些看似微不足道的副作用发展壮大时，便会给程序员维护程序代码带来的障碍是致命的。 而array_walk函数缺省情况下所有执行代码的作用域都在匿名函数内，如果要依赖或操作函数之外的数据，必须通过匿名函数的use关键字导入。通俗一点的请，array_walk函数的权限不如foreach来的大，因此，使用array_walk函数后，虽然无法让你随心所欲的编程，但是大限度的减少了你代码的副作用，两相权衡array_walk所带来的好处还是有值得使用它的理由的。 首先，大多数时候写代码根本不需要太大的“权限”，其次，把代码所影响的范围控制到最小好处不言而喻。微信张小龙讲过，微信做的最好的一点便是“克制”，我们写代码又何尝不是。这一点array_filter和array_map中也有体现，宽泛的讲，所有使用匿名函数的地方都能享受到这个好处。 array_walk所表达的语义就是“假如你需要用到我，那么你除了遍历以外，其它的事情最好都别干，否则你还是去用原生的foreach吧”。 第3个参数 1array_walk(array, myfunction, parameter...) 第3个参数规定用户自定义函数的参数，可以为函数设置一个或多个参数。 123456789$color = [ "a" =&gt; "red", "b" =&gt; "green", "c" =&gt; "blue"];array_walk($color, function($value, $key, $p)&#123; echo "$key $p $value&lt;br&gt;";&#125;, "has the value"); 输出结果：123a has the value redb has the value greenc has the value blue 向二维数组中追加元素 12345678910111213141516171819202122$addDataArr = [ [ 'order_id' =&gt; 6, 'add_time' =&gt; "2020-03-05 19:50:05", 'add_time_sync' =&gt; "0000-00-00 00:00:00", 'status' =&gt; 0, 'item_id' =&gt; 24353454 ], [ 'order_id' =&gt; 7, 'add_time' =&gt; "2020-03-05 19:55:12", 'add_time_sync' =&gt; "0000-00-00 00:00:00", 'status' =&gt; 0, 'item_id' =&gt; 12454758 ]];$appendArr = ['add_time_sync' =&gt; date('Y-m-d H:i:s')];array_walk($addDataArr, function(&amp;$val, $k, $appendArr)&#123; $val = array_merge($val, $appendArr);&#125;, $appendArr); 输出结果：1234567891011121314151617181920Array( [0] =&gt; Array ( [order_id] =&gt; 6 [add_time] =&gt; 2020-03-05 19:50:05 [add_time_sync] =&gt; 2020-03-05 19:54:17 [status] =&gt; 0 [item_id] =&gt; 24353454 ) [1] =&gt; Array ( [order_id] =&gt; 7 [add_time] =&gt; 2020-03-05 19:52:12 [add_time_sync] =&gt; 2020-03-05 19:54:17 [status] =&gt; 0 [item_id] =&gt; 12454758 )) array_reducearray_reduce是上面所讲的三个函数的集大成者，这三个函数的底层完全可以由array_reduce实现。 先看一下下面的php代码。12345678910111213141516171819202122// 求最大年龄$maxAge = 0;$result = null;foreach ($data as $item) &#123; if($item['age'] &gt; $maxAge) &#123; $maxAge = $item['age']; $result = $item; &#125;&#125;// 计算平均年龄$total = 0;foreach ($data as $item) &#123; $total += $item['age'];&#125;$avg = $total / count($data); 常规的PHP写法，代码分别用于计算数组记录中平均年龄和最大年龄，代码需要循环数组，并把计算结果存入一个标量（单个值，区分于列表变量）。 假如要以表达式编程的方式完成编写这两个功能，利用array_filter、array_walk、array_map三个函数是很难一步到位实现的。 于是，就到了array_reduce大显身手的时候了。1234567$result = array_reduce($data, function($curr, $item)&#123; return $curr['age'] &lt; $item['age'] ? $item : $curr;&#125;, ['age' =&gt; 0]);$avg = array_reduce($data, function($curr, $item)&#123; return $curr + $item['age'];&#125;, 0) / count($data); 上面的代码是求平均年龄和最大年龄的表达式编程的实现，如果对array_reduce函数的工作机制不了解，看上面两段代码会觉得在看天书。12345678function array_reduce($data, $callback, $initial)&#123; foreach ($data as $index =&gt; $val) &#123; $initial = $callback($initial, $val); &#125; return $initial;&#125; 这是array_reduce函数的实现代码，函数有3个参数，3个参数的作用分别是： 第一个参数$data，就要是处理的数据源。 第二个参数$callback，循环遍历时会被调用的函数，函数返回的结果在下一次循环调用时会被再次当成参数传入。 第三个参数$initial，作为$callback函数被初次调用时的参数传递。 再来一个递归版本的array_reduce实现，帮助更好的理解这个函数的使用意义。12345678910function array_reduce($data, $callback, $initial)&#123; if(count($data) == 0) &#123; return $initial; &#125; $item = array_shift($data); $initial = $callback($initial, $item); return array_reduce($data, $callback, $initial);&#125; 善用array_reduce函数几乎可以替换掉绝大多数需要使用foreach、for、while语句的代码。 123456789$arr = [ ["id" =&gt; 1, 'name' =&gt; "a"], ["id" =&gt; 2, "name" =&gt; "c"], ["id" =&gt; 3, "name" =&gt; "d"]];echo ltrim(array_reduce($arr , function($result , $v)&#123; return $result.','.$v['id'];&#125;), ','); 在标准的函数式编程语言中，是没有循环控制语句的，假如要进行循环计算，都是使用此类函数来实现的，如果某些极端的情况下这些函数无法满足需求，那么就以手动写递归来实现循环，以达到表达式编程的目的。 array_walk与array_map区别1、array_map里面的函数可以是自定义函数，也可以是php自带的函数，比如trim去除空格等。而array_walk里面的函数只能是自定义的函数。 2、array_map必须要有返回值，因为要填充数组。而array_walk可以没有返回值，输出的话要在调用的函数中通过echo来输出。 3、map主要是为了得到你的回调函数处理后的新数组，要的是结果。walk主要是对每个参数都使用一次你的回调函数，要的是处理的过程。 总结1.通过函数本身的意义就能表达出代码实现了什么样的功能，而不用去琢磨代码具体细节来理解代码的作用。 2.表达式编程相对于命令式编程能极大的简化功能的实现过程， 提升编码效率。 3.表达式编程对于代码的可读性、可维护性具有非凡的意义。 4.利用匿名函数控制代码的副作用。 5.由传统的面向过程式程序设计向现代化的函数式编程靠拢。 通过前面示例的讲解，利用这4个函数实现的代码相对于传统的实现方式并没有不可思议的变化，然而，当需要解决的问题复杂到一定程度时，合理利用这4个函数会使代码的复杂性大规模下降。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hyperf-AOP面向切面编程]]></title>
    <url>%2F2020%2F03%2F05%2FHyperf-AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 适合和一起查看。 概念AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过动态代理等技术实现程序功能的统一维护的一种技术。AOP 是 OOP 的延续，也是 Hyperf 中的一个重要内容，是函数式编程的一种衍生范型。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 用通俗的话来讲，就是在Hyperf里可以通过切面(Aspect) 介入到由hyperf/di管理的任意类的任意方法的执行流程中去，从而改变或加强原方法的功能，这就是 AOP。 使用 AOP 功能必须使用 hyperf/di 来作为依赖注入容器 介绍相对于其它框架实现的 AOP 功能的使用方式，我们进一步简化了该功能的使用不做过细的划分，仅存在 环绕(Around) 一种通用的形式： 切面(Aspect) 为对流程织入的定义类，包括要介入的目标，以及实现对原方法的修改加强处理代理类(ProxyClass) ，每个被介入的目标类最终都会生成一个代理类，来达到执行 切面(Aspect) 方法的目的，而非通过原类定义切面(Aspect)每个切面(Aspect) 必须实现 Hyperf\Di\Aop\AroundInterface 接口，并提供public的$classes和$annotations 属性，为了方便使用，我们可以通过继承 Hyperf\Di\Aop\AbstractAspect 来简化定义过程，我们通过代码来描述一下。 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace App\Aspect;use App\Service\SomeClass;use App\Annotation\SomeAnnotation;use Hyperf\Di\Annotation\Aspect;use Hyperf\Di\Aop\AbstractAspect;use Hyperf\Di\Aop\ProceedingJoinPoint;/** * @Aspect */class FooAspect extends AbstractAspect&#123; // 要切入的类，可以多个，亦可通过 :: 标识到具体的某个方法，通过 * 可以模糊匹配 public $classes = [ SomeClass::class, 'App\Service\SomeClass::someMethod', 'App\Service\SomeClass::*Method', ]; // 要切入的注解，具体切入的还是使用了这些注解的类，仅可切入类注解和类方法注解 public $annotations = [ SomeAnnotation::class, ]; public function process(ProceedingJoinPoint $proceedingJoinPoint) &#123; // 切面切入后，执行对应的方法会由此来负责 // $proceedingJoinPoint 为连接点，通过该类的 process() 方法调用原方法并获得结果 // 在调用前进行某些处理 $result = $proceedingJoinPoint-&gt;process(); // 在调用后进行某些处理 return $result; &#125;&#125; 每个 切面(Aspect) 必须定义 @Aspect 注解或在 config/autoload/aspects.php 内配置均可发挥作用。 使用 @Aspect 注解时需 use Hyperf\Di\Annotation\Aspect; 命名空间； 代理类缓存所有被 AOP 影响的类，都会在./runtime/container/proxy/文件夹内生成对应的代理类缓存，服务启动时，如果类所对应的代理类缓存存在，则不会重新生成直接使用缓存，即使Aspect的切入范围发生了改变。不存在时，则会自动重新生成新的代理类缓存。 在部署生产环境时，我们可能会希望 Hyperf 提前将所有代理类提前生成，而不是使用时动态的生成，可以通过 php bin/hyperf.php di:init-proxy 命令来生成所有代理类，该命令会忽视现有的代理类缓存，全部重新生成。 基于以上，我们可以将生成代理类的命令和启动服务的命令结合起来，vendor/bin/init-proxy.sh &amp;&amp; php bin/hyperf.php start 来达到自动重新生成所有代理类缓存然后启动服务的目的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Hyperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hyperf-注解]]></title>
    <url>%2F2020%2F03%2F05%2FHyperf-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： PHP为什么要专门引入注解？和C#的特性有什么区别？ 体会不同语言使用注解此类功能的异曲同工之妙。 注解是Hyperf非常强大的一项功能，可以通过注解的形式减少很多的配置，以及实现很多非常方便的功能。 概念什么是注解什么是注释？ 注释：给程序员看，帮助理解代码，对代码起到解释、说明的作用。 注解：给应用程序看，用于元数据的定义，单独使用时没有任何作用，需配合应用程序对其元数据进行利用才有作用。 注解解析如何实现？Hyperf使用了doctrine/annotations包来对代码内的注解进行解析，注解必须写在下面示例的标准注释块才能被正确解析，其它格式均不能被正确解析。 注释块示例：123/** * @AnnotationClass() */ 在标准注释块内通过书写@AnnotationClass()这样的语法即表明对当前注释块所在位置的对象（类、类方法、类属性）进行了注解的定义，AnnotationClass对应的是一个注解类的类名，可写全类的命名空间，亦可只写类名，但需要在当前类 use 该注解类以确保能够根据命名空间找到正确的注解类。 注解是如何发挥作用的？我们有说到注解只是元数据的定义，需配合应用程序才能发挥作用，在Hyperf里，注解内的数据会被收集到Hyperf\Di\Annotation\AnnotationCollector类供应用程序使用，当然根据您的实际情况，也可以收集到您自定义的类去，随后在这些注解本身希望发挥作用的地方对已收集的注解元数据进行读取和利用，以达到期望的功能实现。 使用注解注解一共有3种应用对象，分别是类、类方法和类属性。 使用类注解类注解定义是在 class 关键词上方的注释块内，比如常用的 @Controller 和 @AutoController 就是类注解的使用典范，下面的代码示例则为一个正确使用类注解的示例，表明 @ClassAnnotation 注解应用于 Foo 类。1234/** * @ClassAnnotation() */class Foo &#123;&#125; 使用类方法注解类方法注解定义是在方法上方的注释块内，比如常用的 @RequestMapping 就是类方法注解的使用典范，下面的代码示例则为一个正确使用类方法注解的示例，表明 @MethodAnnotation 注解应用于 Foo::bar() 方法。12345678910class Foo&#123; /** * @MethodAnnotation() */ public function bar() &#123; // some code &#125;&#125; 使用类属性注解类属性注解定义是在属性上方的注释块内，比如常用的 @Value 和 @Inject 就是类属性注解的使用典范，下面的代码示例则为一个正确使用类属性注解的示例，表明 @PropertyAnnotation 注解应用于 Foo 类的 $bar 属性。1234567class Foo&#123; /** * @PropertyAnnotation() */ private $bar;&#125; 注解参数传递传递主要的单个参数 @DemoAnnotation(“value”)传递字符串参数 @DemoAnnotation(key1=”value1”, key2=”value2”)传递数组参数 @DemoAnnotation(key={“value1”, “value2”}) 自定义注解创建一个注解类在任意地方创建注解类，如下代码示例：123456789101112131415161718192021namespace App\Annotation;use Hyperf\Di\Annotation\AbstractAnnotation;/** * @Annotation * @Target(&#123;"METHOD","PROPERTY"&#125;) */class Bar extends AbstractAnnotation&#123; // some code&#125;/** * @Annotation * @Target("CLASS") */class Foo extends AbstractAnnotation&#123; // some code&#125; 注意注解类的 @Annotation 和 @Target 注解为全局注解，无需 use 其中 @Target 有如下参数： METHOD 注解允许定义在类方法上PROPERTY 注解允许定义在类属性上CLASS 注解允许定义在类上ALL 注解允许定义在任何地方我们注意一下在上面的示例代码中，注解类都继承了 Hyperf\Di\Annotation\AbstractAnnotation 抽象类，对于注解类来说，这个不是必须的，但对于 Hyperf 的注解类来说，继承 Hyperf\Di\Annotation\AnnotationInterface 接口类是必须的，那么抽象类在这里的作用是提供极简的定义方式，该抽象类已经为您实现了注解参数自动分配到类属性、根据注解使用位置自动按照规则收集到 AnnotationCollector 这样非常便捷的功能。 自定义注解收集器注解的收集时具体的执行流程也是在注解类内实现的，相关的方法由 Hyperf\Di\Annotation\AnnotationInterface 约束着，该接口类要求了下面 3 个方法的实现，您可以根据自己的需求实现对应的逻辑： public function collectClass(string $className): void; 当注解定义在类时被扫描时会触发该方法public function collectMethod(string $className, ?string $target): void; 当注解定义在类方法时被扫描时会触发该方法public function collectProperty(string $className, ?string $target): void 当注解定义在类属性时被扫描时会触发该方法 利用注解数据在没有自定义注解收集方法时，默认会将注解的元数据统一收集在Hyperf\Di\Annotation\AnnotationCollector 类内，通过该类的静态方法可以方便的获取对应的元数据用于逻辑判断或实现。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Hyperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的函数式编程]]></title>
    <url>%2F2020%2F03%2F05%2FPHP%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： function a() { return (function(){}); }返回什么类型？ 第一等公民是什么意思？ 只用“表达式”，不用“语句”是什么意思？ 闭包和函数式编程密切相关，可以说函数式编程就是闭包。怎么理解？ 只要函数里有相同代码就可以使用闭包，尤其是if else里面有相同的代码。怎么理解？ 处理一个数组。 12345678&lt;?phpdeclare(strict_types=1);for ($i=0; $i &lt; 101; $i++) &#123; $results[] = $i;&#125; 最终都是返回Generator生成器。 常见写法12345678910111213141516171819202122232425262728/** * 返回闭包对象 * */function handleArrYield1(array $data)&#123; return (function ($data) &#123; foreach ($data as $value) &#123; yield $value; &#125; &#125;);&#125;$yield1 = handleArrYield1($results);print_r($yield1); // Closure Object ( [parameter] =&gt; Array ( [$data] =&gt; ) )print_r($yield1($results)); // Generator Object ( )echo '&lt;br/&gt;';foreach ($yield1($results) as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 常规函数 12345678910111213$data = function ($results)&#123; foreach ($results as $v) &#123; yield $v; &#125;&#125;;foreach ($data($results) as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 闭包 12345678910111213$data = function () use ($results)&#123; foreach ($results as $v) &#123; yield $v; &#125;&#125;;foreach ($data() as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 抽象写法1234567891011121314151617181920212223242526/** * 返回生成器对象 * */function handleArrYield2(array $data)&#123; return (function ($data) &#123; foreach ($data as $value) &#123; yield $value; &#125; &#125;)($data);&#125;$yield2 = handleArrYield2($results);print_r($yield2); // Generator Object ( )echo "&lt;br/&gt;";foreach ($yield2 as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 函数式编程闭包closure是函数式编程。 闭包可以理解成“定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 实现同样的功能函数式编程所需要的代码比面向对象编程要少很多，代码更加简洁明晰。 函数式编程的特点：函数可以赋给变量，所以，可作为参数传递，可作为返回值返回。PHP返回闭包。 array_walk、array_map等都是函数式编程。 什么是函数式编程与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。 最主要的特征是，函数是第一等公民。 强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成的MapReduce算法。 只有纯的、没有副作用的函数，才是合格的函数。 PHP中的函数例子：1234567891011121314151617$grade = [ [ 'id' =&gt; 1, 'subject' =&gt; 'chinese', 'score' =&gt; 82 ], [ 'id' =&gt; 2, 'subject' =&gt; 'math', 'score' =&gt; 98 ], [ 'id' =&gt; 3, 'subject' =&gt; 'english', 'score' =&gt; 78 ],]; array_filter — 用回调函数过滤数组中的单元 1234// 获取成绩大于80分的学科$arrayFilter = array_filter($grade, function($item)&#123; return $item['score'] &gt; 80 ;&#125;); array_map() - 为数组的每个元素应用回调函数 123456789// 不影响原数组，返回一个新数组$arrayMap = array_map(function($item)&#123; return [ 'id' =&gt; $item['id'], 'subject' =&gt; $item['subject'], 'score' =&gt; $item['score'], 'grade' =&gt; $item['score'] &gt;= 60 ? '合格' : '不合格', ];&#125;, $grade); array_reduce() - 用回调函数迭代地将数组简化为单一的值 123456789// 求分数最高的科目,返回最大科目信息$maxScore = array_reduce($grade, function($init, $val)&#123; return $init['score'] &gt; $val['score'] ? $init : $val;&#125;, ['score' =&gt; 0]); // 求平均成绩$avgScore = array_reduce($grade, function($init, $item)&#123; return $init + $item['score'];&#125;, 0) / count($grade); array_walk() - 使用用户自定义函数对数组中的每个元素做回调处理 1234// 修改原数组array_walk($grade, function(&amp;$item, $index)&#123; $item['grade'] = $item['score'] &gt;= 60 ? '合格' : '不合格';&#125;); 定义简单说，“函数式编程”是一种“编程范式”（programming paradigm），也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 函数编程式是一种编程风格，它将关注点从执行命令转移到表达式计算。这些表达式是使用函数构成的，结合这些函数可以得到我们要查找的结果。 闭包通常出现在允许将函数处理为第一类值（First-class value）的语言中，这意味着函数可以动态创建并作为参数传递给其他语言。 函数式编程的特点函数是“第一等公民” 所谓“第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。 只用“表达式”，不用“语句” “表达式”（expression）是一个单纯的运算过程，总是有返回值；“语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。“语句”属于对系统的读写操作，所以就被排斥在外。 当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。 函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。 副作用 所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。在纯函数式语言中，函数只能读取其参数提供给它的内容，并且它对世界产生影响的唯一方式就是通过它返回的值。 递归和迭代 对于函数式而言，循环体有一个无法避免的副作用，就是它会修改某些对象的状态，通常这些对象又是和其他部分共享的。而且也因为变量值是不可变的，纯函数编程语言也无法实现循环。 所以纯函数编程语言通常不包含像while和for这样的迭代构造器，而是采用的无需修改的递归。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法学习之分治法]]></title>
    <url>%2F2020%2F03%2F05%2FPHP%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介分治法，顾名思义就是分而治之，即把问题拆解为性质相同的小问题再处理。 分治法除了分治，名字里还少了一步，那就是合，也就是怎样通过小问题的答案得到拆分之前大问题的答案。 分治法的时间复杂度：分治法并没有像二分法一样每次丢掉一半无用的解，它只是做了分离，而分离的两部分都是需要处理的，所以分治法的时间复杂度是O(n)。特例情况是当分离的两部分继续分治处理出现重复计算的情况时，就会比O(n)大了！所以请确保你的分治尽量不要出现重叠计算的情况。 那么什么问题适合用分治的思想解决呢？ 二叉树！ 二叉树这种左右子树的结构天生就非常适合分治，所以它的大部分问题都能用分治解决，碰到一个问题你只需要问问左子树你怎么处理，右子树你怎么办，得到左右子树的答案后，你再想想最后的答案是个啥。 除了二叉树，快速排序归并排序这两个著名的排序算法也是分治的思想。下面就举几个解题的例子来加深一下对分治法的学习。 1、前序遍历二叉树 12345678910111213141516171819202122232425262728293031323334class TreeNode&#123; public $val; public $left; public $right; function __construct($val, $left = null, $right = null) &#123; $this-&gt;val = intval($val); $this-&gt;left = $left; $this-&gt;right = $right; &#125;&#125;function preorder(TreeNode $root = null)&#123; $result = []; // 治：当节点不存在时，返回空数组 if ($root == null) &#123; return $result; &#125; // 分：分别求出当前节点左右子树的前序遍历结果 $left = preorder($root-&gt;left); $right = preorder($root-&gt;right); // 合：因为是前序遍历，所以先添加当前节点的val，然后是左子树右子树 $result[] = $root-&gt;val; $result = array_merge($result, $left, $right); return $result;&#125; 2、求二叉树的最大路径和 给一棵二叉树，找出从根节点出发的路径中，和最大的一条。 这条路径可以在任何二叉树中的节点结束，但是必须包含至少一个点。 12345678910111213141516171819202122function maxPathSum(TreeNode $root = null)&#123; // 治：当节点不存在时，返回0 if ($root == null) &#123; return 0; &#125; // 分：分别求出当前节点左右子树的最大路径和 $left = maxPathSum($root-&gt;left); $right = maxPathSum($root-&gt;right); // 合：此处有坑，注意左右子树和都为负数的情况 if ($left &lt; 0 &amp;&amp; $right &lt; 0) &#123; return $root-&gt;val; &#125; else &#123; return $root-&gt;val + max($left, $right); &#125;&#125; 3、求最近公共祖先 给定一棵二叉树，找到两个节点的最近公共父节点(LCA)，给出的两个节点都在树中存在。 123456789101112131415161718192021222324252627function lca(TreeNode $root = null, TreeNode $A, TreeNode $B)&#123; if ($root == null || $root == $A || $root == $B) &#123; return $root; &#125; $left = lca($root-&gt;left, $A, $B); $right = lca($root-&gt;right, $A, $B); if ($left &amp;&amp; $right) &#123; return $root; &#125; elseif($left) &#123; return $left; &#125; elseif($right) &#123; return $right; &#125; else &#123; return null; &#125;&#125; 4、快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php $arr = [25,133,452,364,5876,293,607,365,8745,534,18,33]; function quick_sort($arr)&#123; // 判断是否需要继续 if (count($arr) &lt;= 1) &#123; return $arr; &#125; $middle = $arr[0]; // 中间值 $left = array(); // 小于中间值 $right = array();// 大于中间值 // 循环比较 for ($i=1; $i &lt; count($arr); $i++) &#123; if ($middle &lt; $arr[$i]) &#123; // 大于中间值 $right[] = $arr[$i]; &#125; else &#123; // 小于中间值 $left[] = $arr[$i]; &#125; &#125; // 递归排序两边 $left = quick_sort($left); $right = quick_sort($right); // 合并排序后的数据，别忘了合并中间值 return array_merge($left, array($middle), $right);&#125; var_dump($arr);var_dump(quick_sort($arr));]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反射机制实现自动依赖注入]]></title>
    <url>%2F2020%2F03%2F04%2FPHP%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 依赖注入为什么又叫控制反转？ 只要知道类的名字就能实例化该类。依赖注入就是传类名做参数，然后保证有这个类就好了。怎么理解？ 手动和自动依赖注入的区别是什么？ PHP支持可变长度参数吗？ 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class A&#123; protected $bObj; /** * 构造函数依赖注入 * 用于测试多级依赖注入 A依赖B，B依赖C * * @param B $b [使用依赖注入B] */ public function __construct(B $b) &#123; $this-&gt;bObj = $b; &#125; /** * 方法调用依赖注入 * * @param C $c [依赖注入C] * @param string $param [这个是自己手动填写的参数] * @return void */ public function aa(C $c, $param) &#123; $c-&gt;cc(); echo "&lt;br/&gt;"; echo 'params:' . $param; &#125; /** * 验证依赖注入是否成功 * @return void */ public function aaa() &#123; $this-&gt;bObj-&gt;bbc(); &#125;&#125;class B&#123; protected $cObj; /** * 构造函数依赖注入 * * @param C $c [使用依赖注入C] */ public function __construct(C $c) &#123; $this-&gt;cObj = $c; &#125; public function bb() &#123; echo 'this is B-&gt;bb()'; &#125; public function bbc() &#123; $this-&gt;cObj-&gt;cc(); &#125;&#125;class C&#123; public function cc() &#123; echo 'this is C-&gt;cc()'; &#125;&#125; 测试构造函数的依赖注入 12345678910111213141516171819// 使用IOC来创建A类的实例，A的构造函数依赖B类，B的构造函数依赖C类。$aObj = IOC::getInstance('A');$aObj-&gt;aaa(); // 输出：this is C-&gt;cc() ， 说明依赖注入成功。// 打印$aObjprint_r($aObj);// 打印结果，可以看出A中有B实例，B中有C实例，说明依赖注入成功。/*A Object( [bObj:protected] =&gt; B Object ( [cObj:protected] =&gt; C Object ( ) ))*/ 测试方法依赖注入 123456789$methodResult = IOC::make('A', 'aa', ['this is param a']);print_r($methodResult);// 输出结果，可以看出依赖注入成功。/*this is C-&gt;cc()params:this is param a*/ 从上面两个例子可以看出我们创建对象或者调用方法时，根本就不用知道该类或该方法依赖了哪个类。使用反射机制可以轻松的为我们自动注入所需要的类。 源码使用php的反射函数，创建一个容器类，使用该类来实现其他类的依赖注入功能。依赖注入分为两种，一种是构造函数的依赖注入，一种是方法的依赖注入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * 工具类，使用该类来实现自动依赖注入。 * */class IOC&#123; /* * 获得类的对象实例 * * @param string $className [类名] * @return object 实例对象 */ public static function getInstance($className) &#123; $paramArr = self::getMethodParams($className); return (new ReflectionClass($className))-&gt;newInstanceArgs($paramArr); /* A Object ( [bObj:protected] =&gt; B Object ( [cObj:protected] =&gt; C Object ( ) ) ) */ &#125; /** * 执行类的方法 * * @param string $className [类名] * @param string $methodName [方法名称] * @param array $params [额外的参数] * @return */ public static function make($className, $methodName, $params = []) &#123; // 获取类的实例 $instance = self::getInstance($className); // 获取该方法所需要依赖注入的参数 $paramArr = self::getMethodParams($className, $methodName); return $instance-&gt;&#123;$methodName&#125;(...array_merge($paramArr, $params)); &#125; /** * 获得类的方法参数，只获得有类型的参数 * * @param string $className [类名] * @param string $methodsName [构造函数] * @return array [参数数组] */ protected static function getMethodParams($className, $methodsName = '__construct') &#123; // 获得该类的反射类 $class = new ReflectionClass($className); // ReflectionClass Object ( [name] =&gt; A ) $paramArr = []; // 记录参数，和参数类型 // 判断该类是否有构造函数 if ($class-&gt;hasMethod($methodsName)) &#123; // 获得构造函数 $construct = $class-&gt;getMethod($methodsName); // ReflectionMethod Object ( [name] =&gt; __construct [class] =&gt; A ) // 判断构造函数是否有参数 $params = $construct-&gt;getParameters(); // Array ( [0] =&gt; ReflectionParameter Object ( [name] =&gt; b ) ) if (count($params) &gt; 0) &#123; // 判断参数类型 foreach ($params as $key =&gt; $param) &#123; if ($paramClass = $param-&gt;getClass()) // ReflectionClass Object ( [name] =&gt; B ) &#123; // 获得参数类型名称 $paramClassName = $paramClass-&gt;getName(); // B // 获得参数类型 // 递归 $args = self::getMethodParams($paramClassName); // print_r($args); /* Array ( ) Array ( [0] =&gt; C Object ( ) ) */ $paramArr[] = (new ReflectionClass($paramClass-&gt;getName()))-&gt;newInstanceArgs($args); // $args这个参数以array形式传递到类的构造函数。 &#125; &#125; &#125; &#125; // print_r($paramArr); /* Array ( ) Array ( [0] =&gt; C Object ( ) ) Array ( [0] =&gt; B Object ( [cObj:protected] =&gt; C Object ( ) ) ) */ return $paramArr; &#125;&#125; laravel中利用反射实现依赖注入在一个类中经常会依赖于其他的对象，先看一下经典的写法。 12345678910class Foo &#123; public $bar; public function __construct() &#123; $this-&gt;bar = new Bar(); &#125;&#125;$foo = new Foo(); 当类的依赖发生改变时，比如Bar这个类需要实例化参数时，而依赖于它的类有很多，总不能一个一个地去修改吧。 再看一下使用依赖注入怎么做、 123456789101112class Foo &#123; public $bar; public function __construct($bar) &#123; $this-&gt;bar = $bar; &#125;&#125;$bar = new Bar();$foo = new Foo($bar); 将Bar类在外部实例化好后，作为一个参数传入进Foo类，从而实现了控制反转，假如现在Bar类需要参数了，外部修改就好了，不必一个个地去修改依赖于它的类。 在laravel中，经常写出下面这种代码： 1234567class SomeController &#123; public function index(Request $request) &#123; dd($request-&gt;all()); &#125;&#125; 只要在方法参数中申明Request $request，就可以直接使用$request对象了，非常地方便。 其实laravel在背后利用PHP的反射机制为我们做了$request = new Request这一步。反射是一种类的反省能力，可以导出类的详细信息包括属性、方法、甚至注释等等。 实现，看代码：1234567891011$method = new ReflectionMethod('SomeController', 'index');$args = [];foreach($method-&gt;getParameters() as $parameter) &#123; if ($class = $parameter-&gt;getClass()) &#123; $args[] = new $class-&gt;name; //$request = new Request &#125;&#125;$method-&gt;invokeArgs(new SomeController, $args); 通过ReflectionMethod获取类方法的参数，如果参数是其他的类，就实例化后作为参数使用ReflectionMethod::invokeArgs 传入到类方法中，原理就是这么简单。 通常使用new ReflectionClass(‘className’) 来反射类，ReflectionMethod来反射类方法。 总结只要熟悉php的反射机制，依赖注入并不难实现，上面的代码为了方便理解，所以写的简单粗暴，在实际的项目中肯定不会这么简单，比如：会对注入的类和参数进行配置，比如会缓存实例化过的类，下次需要该类的实例时，可以直接使用，而不用在重新初始化，等等。不过相信原理了解了，其他的可以随着项目的需求自己去完善。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hyperf-依赖注入]]></title>
    <url>%2F2020%2F03%2F03%2FHyperf-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 依赖注入的思想，无论什么语言都是相通的。怎么理解？ 类的关系及注入是无需显性定义的。怎么理解？ 简介Hyperf默认采用hyperf/di作为框架的依赖注入管理容器，hyperf/di是一个强大的用于管理类的依赖关系并完成自动注入的组件，与传统依赖注入容器的区别在于更符合长生命周期的应用使用、提供了注解及注解注入的支持、提供了无比强大的AOP面向切面编程能力。 绑定对象关系简单对象注入通常来说，类的关系及注入是无需显性定义的，这一切Hyperf都会默默的为您完成，我们通过一些代码示例来说明一下相关的用法。 假设我们需要在IndexController内调用UserService类的getInfoById(int $id)方法。12345678910namespace App\Service;class UserService&#123; public function getInfoById(int $id) &#123; // 我们假设存在一个Info实体 return (new Info())-&gt;fill($id); &#125;&#125; 通过构造方法注入123456789101112131415161718192021222324namespace App\Controller;use App\Service\UserService;class IndexController&#123; /** * @var UserService */ private $userService; // 通过在构造函数的参数上声明参数类型完成自动注入 public function __construct(UserService $userService) &#123; $this-&gt;userService = $userService; &#125; public function index() &#123; $id = 1; // 直接使用 return $this-&gt;userService-&gt;getInfoById($id); &#125;&#125; 注意调用方也就是IndexController必须是由DI创建的对象才能完成自动注入，而Controller默认是由DI创建的，所以可以直接使用构造函数注入，直接new该对象不会生效。 当您希望定义一个可选的依赖项时，可以通过给参数定义为nullable或将参数的默认值定义为null，即表示该参数如果在DI容器中没有找到或无法创建对应的对象时，不抛出异常而是直接使用null来注入。12345678910111213141516171819202122232425262728&lt;?phpnamespace App\Controller;use App\Service\UserService;class IndexController&#123; /** * @var null|UserService */ private $userService; // 通过设置参数为 nullable，表明该参数为一个可选参数 public function __construct(?UserService $userService) &#123; $this-&gt;userService = $userService; &#125; public function index() &#123; $id = 1; if ($this-&gt;userService instanceof UserService) &#123; // 仅值存在时 $userService 可用 return $this-&gt;userService-&gt;getInfoById($id); &#125; return null; &#125;&#125; 通过@Inject注解注入1234567891011121314151617181920212223&lt;?phpnamespace App\Controller;use App\Service\UserService;use Hyperf\Di\Annotation\Inject;class IndexController&#123; /** * 通过 `@Inject` 注解注入由 `@var` 注解声明的属性类型对象 * * @Inject * @var UserService */ private $userService; public function index() &#123; $id = 1; // 直接使用 return $this-&gt;userService-&gt;getInfoById($id); &#125;&#125; 使用@Inject注解时需use Hyperf\Di\Annotation\Inject;命名空间； Required参数 Required参数仅可在1.1.0版本或更高版本使用。 @Inject注解存在一个required参数，默认值为true，当将该参数定义为false时，则表明该成员属性为一个可选依赖，当对应@var的对象不存在于DI容器或不可创建时，将不会抛出异常而是注入一个null，如下： 123456789101112131415161718192021222324252627&lt;?phpnamespace App\Controller;use App\Service\UserService;use Hyperf\Di\Annotation\Inject;class IndexController&#123; /** * 通过 `@Inject` 注解注入由 `@var` 注解声明的属性类型对象 * 当 UserService 不存在于 DI 容器内或不可创建时，则注入 null * * @Inject(required=false) * @var UserService */ private $userService; public function index() &#123; $id = 1; if ($this-&gt;userService instanceof UserService) &#123; // 仅值存在时 $userService 可用 return $this-&gt;userService-&gt;getInfoById($id); &#125; return null; &#125;&#125; 抽象对象注入基于上面的例子，从合理的角度上来说，Controller面向的不应该直接是一个UserService类，可能更多的是一个UserServiceInterface的接口类，此时我们可以通过config/autoload/dependencies.php来绑定对象关系达到目的。 定义一个接口类：1234567&lt;?phpnamespace App\Service;interface UserServiceInterface&#123; public function getInfoById(int $id);&#125; UserService实现接口类：1234567891011&lt;?phpnamespace App\Service;class UserService implements UserServiceInterface&#123; public function getInfoById(int $id) &#123; // 我们假设存在一个 Info 实体 return (new Info())-&gt;fill($id); &#125;&#125; 在config/autoload/dependencies.php内完成关系配置：1234&lt;?phpreturn [ \App\Service\UserServiceInterface::class =&gt; \App\Service\UserService::class]; 这样配置后就可以直接通过UserServiceInterface来注入UserService对象了，我们仅通过注解注入的方式来举例，构造函数注入也是一样的：123456789101112131415161718192021&lt;?phpnamespace App\Controller;use App\Service\UserServiceInterface;use Hyperf\Di\Annotation\Inject;class IndexController&#123; /** * @Inject * @var UserServiceInterface */ private $userService; public function index() &#123; $id = 1; // 直接使用 return $this-&gt;userService-&gt;getInfoById($id); &#125;&#125; 工厂对象注入我们假设UserService的实现会更加复杂一些，在创建UserService对象时构造函数还需要传递进来一些非直接注入型的参数，假设我们需要从配置中取得一个值，然后UserService需要根据这个值来决定是否开启缓存模式。 我们需要创建一个工厂来生成UserService对象：123456789101112131415161718&lt;?php namespace App\Service;use Hyperf\Contract\ConfigInterface;use Psr\Container\ContainerInterface;class UserServiceFactory&#123; // 实现一个 __invoke() 方法来完成对象的生产，方法参数会自动注入一个当前的容器实例 public function __invoke(ContainerInterface $container) &#123; $config = $container-&gt;get(ConfigInterface::class); // 我们假设对应的配置的 key 为 cache.enable $enableCache = $config-&gt;get('cache.enable', false); // make(string $name, array $parameters = []) 方法等同于 new ，使用 make() 方法是为了允许 AOP 的介入，而直接 new 会导致 AOP 无法正常介入流程 return make(UserService::class, compact('enableCache')); &#125;&#125; UserService 也可以在构造函数提供一个参数接收对应的值：12345678910111213141516171819202122&lt;?phpnamespace App\Service;class UserService implements UserServiceInterface&#123; /** * @var bool */ private $enableCache; public function __construct(bool $enableCache) &#123; // 接收值并储存于类属性中 $this-&gt;enableCache = $enableCache; &#125; public function getInfoById(int $id) &#123; return (new Info())-&gt;fill($id); &#125;&#125; 在 config/autoload/dependencies.php 调整绑定关系：1234&lt;?phpreturn [ \App\Service\UserServiceInterface::class =&gt; \App\Service\UserServiceFactory::class]; 这样在注入 UserServiceInterface 的时候容器就会交由 UserServiceFactory 来创建对象了。 当然在该场景中可以通过 @Value 注解来更便捷的注入配置而无需构建工厂类，此仅为举例 懒加载Hyperf 的长生命周期依赖注入在项目启动时完成。这意味着长生命周期的类需要注意： 构造函数时还不是协程环境，如果注入了可能会触发协程切换的类，就会导致框架启动失败。 构造函数中要避免循环依赖（比较典型的例子为 Listener 和 EventDispatcherInterface），不然也会启动失败。 目前解决方案是：只在实例中注入 Psr\Container\ContainerInterface ，而其他的组件在非构造函数执行时通过 container 获取。但 PSR-11 中指出: 「用户不应该将容器作为参数传入对象然后在对象中通过容器获得对象的依赖。这样是把容器当作服务定位器来使用，而服务定位器是一种反模式」 也就是说这样的做法虽然有效，但是从设计模式角度来说并不推荐。 另一个方案是使用 PHP 中常用的惰性代理模式，注入一个代理对象，在使用时再实例化目标对象。Hyperf DI 组件设计了懒加载注入功能。 添加 Hyperf\Di\Listener\LazyLoaderBootApplicationListener 到 config/autoload/listeners.php 中。 监听器会监听 BootApplication 事件，自动读取 lazy_loader 配置，并通过 spl_autoload_register 注册懒加载模式。12345678910111213141516171819&lt;?phpdeclare(strict_types=1);return [ Hyperf\Di\Listener\LazyLoaderBootApplicationListener::class,];Copy to clipboardErrorCopied添加 config/autoload/lazy_loader.php 文件并绑定懒加载关系：&lt;?phpreturn [ /** * 格式为：代理类名 =&gt; 原类名 * 代理类此时是不存在的，Hyperf会在runtime文件夹下自动生成该类。 * 代理类类名和命名空间可以自由定义。 */ 'App\Service\LazyUserService' =&gt; \App\Service\UserServiceInterface::class]; 这样在注入 App\Service\LazyUserService 的时候容器就会创建一个 懒加载代理类 注入到目标对象中了。12345678use App\Service\LazyUserService;class Foo&#123; public $service; public function __construct(LazyUserService $sevice)&#123; $this-&gt;service = $service; &#125;&#125; 您还可以通过注解 @Inject(lazy=true) 注入懒加载代理。通过注解实现懒加载不用创建配置文件。12345678910use Hyperf\Di\Annotation\Inject;use App\Service\UserServiceInterface;class Foo&#123; /** * @Inject(lazy=true) * @var UserServiceInterface */ public $service;&#125; 注意：当该代理对象执行下列操作时，被代理对象才会从容器中真正实例化。 1234567891011121314// 方法调用$proxy-&gt;someMethod();// 读取属性echo $proxy-&gt;someProperty;// 写入属性$proxy-&gt;someProperty = 'foo';// 检查属性是否存在isset($proxy-&gt;someProperty);// 删除属性unset($proxy-&gt;someProperty); 注意事项容器仅管理长生命周期的对象换种方式理解就是容器内管理的对象都是单例，这样的设计对于长生命周期的应用来说会更加的高效，减少了大量无意义的对象创建和销毁，这样的设计也就意味着所有需要交由 DI 容器管理的对象均不能包含 状态 值。状态 可直接理解为会随着请求而变化的值，事实上在 协程 编程中，这些状态值也是应该存放于 协程上下文 中的，即 Hyperf\Utils\Context。 短生命周期对象通过 new 关键词创建的对象毫无疑问的短生命周期的，那么如果希望创建一个短生命周期的对象但又希望通过依赖注入容器注入相关的依赖呢？这是我们可以通过 make(string $name, array $parameters = []) 函数来创建 $name 对应的的实例，代码示例如下： $userService = make(UserService::class, [‘enableCache’ =&gt; true]);Copy to clipboardErrorCopied注意仅 $name 对应的对象为短生命周期对象，该对象的所有依赖都是通过 get() 方法获取的，即为长生命周期的对象 获取容器对象有些时候我们可能希望去实现一些更动态的需求时，会希望可以直接获取到 容器(Container) 对象，在绝大部分情况下，框架的入口类（比如命令类、控制器、RPC 服务提供者等）都是由 容器(Container) 创建并维护的，也就意味着您所写的绝大部分业务代码都是在 容器(Container) 的管理作用之下的，也就意味着在绝大部分情况下您都可以通过在 构造函数(Constructor) 声明或通过 @Inject 注解注入 Psr\Container\ContainerInterface 接口类都能够获得 Hyperf\Di\Container 容器对象，我们通过代码来演示一下： 12345678910111213141516171819&lt;?phpnamespace App\Controller;use Hyperf\HttpServer\Annotation\AutoController;use Psr\Container\ContainerInterface;class IndexController&#123; /** * @var ContainerInterface */ private $container; // 通过在构造函数的参数上声明参数类型完成自动注入 public function __construct(ContainerInterface $container) &#123; $this-&gt;container = $container; &#125;&#125; 在某些更极端动态的情况下，或者非 容器(Container) 的管理作用之下时，想要获取到 容器(Container) 对象还可以通过 \Hyperf\Utils\ApplicationContext::getContaienr() 方法来获得 容器(Container) 对象。1$container = \Hyperf\Utils\ApplicationContext::getContainer(); 源码12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpdeclare(strict_types=1);/** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://doc.hyperf.io * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */namespace Hyperf\Di;interface MetadataCollectorInterface&#123; /** * Retrieve the metadata via key. * @param null|mixed $default */ public static function get(string $key, $default = null); /** * Set the metadata to holder. * @param mixed $value */ public static function set(string $key, $value): void; /** * Serialize the all metadata to a string. */ public static function serialize(): string; /** * Deserialize the serialized metadata and set the metadata to holder. */ public static function deserialize(string $metadata): bool; /** * Return all metadata array. */ public static function list(): array;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpdeclare(strict_types=1);/** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://doc.hyperf.io * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */namespace Hyperf\Di;use Hyperf\Utils\Arr;abstract class MetadataCollector implements MetadataCollectorInterface&#123; /** * Subclass MUST override this property. * * @var array */ protected static $container = []; /** * Retrieve the metadata via key. * @param null|mixed $default */ public static function get(string $key, $default = null) &#123; return Arr::get(static::$container, $key) ?? $default; &#125; /** * Set the metadata to holder. * @param mixed $value */ public static function set(string $key, $value): void &#123; Arr::set(static::$container, $key, $value); &#125; /** * Determine if the metadata exist. * If exist will return true, otherwise return false. */ public static function has(string $key): bool &#123; return Arr::has(static::$container, $key); &#125; /** * Serialize the all metadata to a string. */ public static function serialize(): string &#123; return serialize(static::$container); &#125; /** * Deserialize the serialized metadata and set the metadata to holder. */ public static function deserialize(string $metadata): bool &#123; $data = unserialize($metadata); static::$container = $data; return true; &#125; public static function list(): array &#123; return static::$container; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpdeclare(strict_types=1);/** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://doc.hyperf.io * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */namespace Hyperf\Di;use InvalidArgumentException;use ReflectionClass;use ReflectionMethod;use ReflectionProperty;class ReflectionManager extends MetadataCollector&#123; /** * @var array */ protected static $container = []; public static function reflectClass(string $className): ReflectionClass &#123; if (! isset(static::$container['class'][$className])) &#123; if (! class_exists($className) &amp;&amp; ! interface_exists($className)) &#123; throw new InvalidArgumentException("Class &#123;$className&#125; not exist"); &#125; static::$container['class'][$className] = new ReflectionClass($className); &#125; return static::$container['class'][$className]; &#125; public static function reflectMethod(string $className, string $method): ReflectionMethod &#123; $key = $className . '::' . $method; if (! isset(static::$container['method'][$key])) &#123; // TODO check interface_exist if (! class_exists($className)) &#123; throw new InvalidArgumentException("Class &#123;$className&#125; not exist"); &#125; static::$container['method'][$key] = static::reflectClass($className)-&gt;getMethod($method); &#125; return static::$container['method'][$key]; &#125; public static function reflectProperty(string $className, string $property): ReflectionProperty &#123; $key = $className . '::' . $property; if (! isset(static::$container['property'][$key])) &#123; if (! class_exists($className)) &#123; throw new InvalidArgumentException("Class &#123;$className&#125; not exist"); &#125; static::$container['property'][$key] = static::reflectClass($className)-&gt;getProperty($property); &#125; return static::$container['property'][$key]; &#125; public static function clear(): void &#123; static::$container = []; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Hyperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章：树]]></title>
    <url>%2F2020%2F01%2F18%2F%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 层数是对节点而言的，高度是对树而言的。怎么理解？ 前序遍历、中序遍历和后序遍历分别是什么样的？ 本章知识点 理解树这种数据结构及其用法。 了解如何用树实现映射。 用类和引用实现树。 将树实现为递归数据结构。 用堆实现优先级队列。 术语及定义 图1 用树表示一些常见动物的分类 树的属性 第一个属性是层次性，即树是按层级构建的，越笼统就越靠近顶部，越具体则越靠近底部。树的层次性衍生出另一个重要属性，即可以将树的某个部分（称作子树）整体移到另一个位置，而不影响下面的层。 树的第二个属性是，一个节点的所有子节点都与另一个节点的所有子节点无关。 第三个属性是，叶子节点都是独一无二的。 节点 节点是树的基础部分。它可以有自己的名字，我们称作“键”。节点也可以带有附加信息，我们称作“有效载荷”。有效载荷信息对于很多树算法来说不是重点，但它常常在使用树的应用中很重要。 边 边是树的另一个基础部分。两个节点通过一条边相连，表示它们之间存在关系。除了根节点以外，其他每个节点都仅有一条入边，出边则可能有多条。 根节点 根节点是树中唯一没有入边的节点。 路径 路径是由边连接的有序节点列表。 子节点 一个节点通过出边与子节点相连。 父节点 一个节点是其所有子节点的父节点。 兄弟节点 具有同一父节点的节点互称为兄弟节点。 子树 一个父节点及其所有后代的节点和边构成一棵子树。 叶子节点 叶子节点没有子节点。 层数 节点n的层数是从根节点到n的唯一路径长度。在图1中，猫属的层数是5。由定义可知，根节点的层数是 0。 高度 树的高度是其中节点层数的最大值。图1中的树高度为7。 树有两种定义，其中一种涉及节点和边，另一种涉及递归。你在后面会看到，递归定义很有用。 定义一：树由节点及连接节点的边构成。树有以下属性： 有一个根节点； 除根节点外，其他每个节点都与其唯一的父节点相连； 从根节点到其他每个节点都有且仅有一条路径； 如果每个节点最多有两个子节点，我们就称这样的树为二叉树。 图2展示了一棵符合定义一的树。边的箭头表示连接方向。 图2 由节点和边构成的树 定义二：一棵树要么为空，要么由一个根节点和零棵或多棵子树构成，子树本身也是一棵树。每棵子树的根节点通过一条边连到父树的根节点。图3展示了树的递归定义。 图3 树的递归定义 从树的递归定义可知，图中的树至少有4个节点，因为三角形代表的子树必定有一个根节点。这棵树或许有更多的节点，但必须更深入地查看子树后才能确定。 实现根据上节给出的定义，可以使用以下函数创建并操作二叉树。 BinaryTree() 创建一个二叉树实例。 getLeftChild() 返回当前节点的左子节点所对应的二叉树。 getRightChild() 返回当前节点的右子节点所对应的二叉树。 setRootVal(val) 在当前节点中存储参数val中的对象。 getRootVal() 返回当前节点存储的对象。 insertLeft(val) 新建一棵二叉树，并将其作为当前节点的左子节点。 insertRight(val) 新建一棵二叉树，并将其作为当前节点的右子节点。 我们将定义一个类，其中有根节点和左右子树的属性。 图3 “节点与引用”表示法的简单示例 首先定义一个简单的类，如代码清单1所示。“节点与引用”表示法的要点是，属性left和right会指向BinaryTree类的其他实例。举例来说，在向树中插入新的左子树时，我们会创建另一个BinaryTree实例，并将根节点的self.leftChild改为指向新树。 代码清单1 BinaryTree类 12345class BinaryTree: def __init__(self, rootObj): self.key = rootObj self.leftChild = None self.rightChild = None 在代码清单1中，构造方法接受一个对象，并将其存储到根节点中。正如能在列表中存储任何对象，根节点对象也可以成为任何对象的引用。就之前的例子而言，我们将节点名作为根的值存储。采用“节点与引用”法表示图3中的树，将创建6个BinaryTree实例。 下面看看基于根节点构建树所需要的函数。为了给树添加左子树，我们新建一个二叉树对象，将根节点的left属性指向新对象。代码清单2给出了insertLeft函数的代码。 代码清单2 插入左子节点 1234567def insertLeft(self, newNode): if self.leftChild == None: self.leftChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.left = self.leftChild self.leftChild = t 在插入左子树时，必须考虑两种情况。第一种情况是原本没有左子节点。此时，只需往树中添加一个节点即可。第二种情况是已经存在左子节点。此时，插入一个节点，并将已有的左子节点降一层。代码清单2中的else语句处理的就是第二种情况。 insertRight函数也要考虑相应的两种情况：要么原本没有右子节点，要么必须在根节点和已有的右子节点之间插入一个节点。代码清单3给出了insertRight函数的代码。 代码清单3 插入右子节点 1234567def insertRight(self, newNode): if self.rightChild == None: self.rightChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.right = self.rightChild self.rightChild = t 为了完成对二叉树数据结构的定义，我们来编写一些访问左右子节点与根节点的函数，如代码清单4所示。 代码清单4 二叉树的访问函数 1234567891011def getRightChild(self): return self.rightChilddef getLeftChild(self): return self.leftChilddef setRootVal(self, obj): self.key = objdef getRootVal(self): return self.key 有了创建与操作二叉树的所有代码，现在用它们来进一步了解结构。我们创建一棵简单的树，并为根节点a添加子节点b和c。下面的Python会话创建了这棵树，并查看key、left和right中存储的值。注意，根节点的左右子节点本身都是BinaryTree类的实例。正如递归定义所言，二叉树的所有子树也都是二叉树。1234567891011121314151617181920&gt;&gt;&gt; from pythonds.trees import BinaryTree&gt;&gt;&gt; r = BinaryTree('a')&gt;&gt;&gt; r.getRootVal()'a'&gt;&gt;&gt; print(r.getLeftChild())None&gt;&gt;&gt; r.insertLeft('b')&gt;&gt;&gt; print(r.getLeftChild())&lt;__main__.BinaryTree instance at 0x6b238&gt;&gt;&gt;&gt; print(r.getLeftChild().getRootVal())b&gt;&gt;&gt; r.insertRight('c')&gt;&gt;&gt; print(r.getRightChild())&lt;__main__.BinaryTree instance at 0x6b9e0&gt;&gt;&gt;&gt; print(r.getRightChild().getRootVal())c&gt;&gt;&gt; r.getRightChild().setRootVal('hello')&gt;&gt;&gt; print(r.getRightChild().getRootVal())hello&gt;&gt;&gt; 二叉树的应用解析树树的实现已经齐全了，现在来看看如何用树解决一些实际问题。本节介绍解析树，可以用它来表示现实世界中像句子（如图4所示）或数学表达式这样的构造。 图4 一个简单句子的解析树 图4展示了一个简单句子的层次结构。用树状结构表示句子让我们可以使用子树处理句子的独立部分。 我们也可以将((7 + 3) * (5 - 2))这样的数学表达式表示成解析树，如图5所示。 图5 ((7 + 3) * (5 - 2))的解析树 这是完全括号表达式，乘法的优先级高于加法和减法，但因为有括号，所以在做乘法前必须先做括号内的加法和减法。树的层次性有助于理解整个表达式的计算次序。在计算顶层的乘法前，必须先计算子树中的加法和减法。加法（左子树）的结果是10，减法（右子树）的结果是3。利用树的层次结构，在计算完子树的表达式后，只需用一个节点代替整棵子树即可。应用这个替换过程后，便得到如图6所示的简化树。 图6 ((7 + 3) * (5 - 2))的简化解析树 本节的剩余部分将仔细考察解析树，重点如下： 如何根据完全括号表达式构建解析树； 如何计算解析树中的表达式； 如何将解析树还原成最初的数学表达式。 构建解析树的第一步是将表达式字符串拆分成标记列表。需要考虑4种标记：左括号、右括号、运算符和操作数。我们知道，左括号代表新表达式的起点，所以应该创建一棵对应该表达式的新树。反之，遇到右括号则意味着到达该表达式的终点。我们也知道，操作数既是叶子节点，也是其运算符的子节点。此外，每个运算符都有左右子节点。 有了上述信息，便可以定义以下4条规则： (1) 如果当前标记是(，就为当前节点添加一个左子节点，并下沉至该子节点； (2) 如果当前标记在列表[‘+’, ‘-‘, ‘/‘, ‘*‘]中，就将当前节点的值设为当前标记对应的运算符；为当前节点添加一个右子节点，并下沉至该子节点； (3) 如果当前标记是数字，就将当前节点的值设为这个数并返回至父节点； (4) 如果当前标记是)，就跳到当前节点的父节点。 编写Python代码前，我们先通过一个例子来理解上述规则。将表达式(3 + (4 * 5))拆分成标记列表[‘(‘, ‘3’, ‘+’, ‘(‘, ‘4’, ‘*‘, ‘5’, ‘)’, ‘)’]。起初，解析树只有一个空的根节点，随着对每个标记的处理，解析树的结构和内容逐渐充实，如图7所示。 图7 一步步地构建解析树 以图7为例，我们来一步步地构建解析树。 (a) 创建一棵空树。 (b) 读入第一个标记(。根据规则1，为根节点添加一个左子节点。 (c) 读入下一个标记3。根据规则3，将当前节点的值设为3，并回到父节点。 (d) 读入下一个标记+。根据规则2，将当前节点的值设为+，并添加一个右子节点。新节点成为当前节点。 (e) 读入下一个标记(。根据规则1，为当前节点添加一个左子节点，并将其作为当前节点。 (f) 读入下一个标记4。根据规则3，将当前节点的值设为4，并回到父节点。 (g) 读入下一个标记*。根据规则2，将当前节点的值设为*，并添加一个右子节点。新节点成为当前节点。 (h) 读入下一个标记5。根据规则3，将当前节点的值设为5，并回到父节点。 (i) 读入下一个标记)。根据规则4，将*的父节点作为当前节点。 (j) 读入下一个标记)。根据规则4，将+的父节点作为当前节点。因为+没有父节点，所以工作完成。 本例表明，在构建解析树的过程中，需要追踪当前节点及其父节点。可以通过getLeftChild与getRightChild获取子节点，但如何追踪父节点呢？一个简单的办法就是在遍历这棵树时使用栈记录父节点。每当要下沉至当前节点的子节点时，先将当前节点压到栈中。当要返回到当前节点的父节点时，就将父节点从栈中弹出来。 利用前面描述的规则以及Stack和BinaryTree，就可以编写创建解析树的Python函数。代码清单5给出了解析树构建器的代码。 代码清单5 解析树构建器 1234567891011121314151617181920212223242526272829from pythonds.basic import Stackfrom pythonds.trees import BinaryTreedef buildParseTree(fpexp): fplist = fpexp.split() pStack = Stack() eTree = BinaryTree('') pStack.push(eTree) currentTree = eTree for i in fplist: if i == '(': currentTree.insertLeft('') pStack.push(currentTree) currentTree = currentTree.getLeftChild() elif i not in '+-*/)': currentTree.setRootVal(eval(i)) parent = pStack.pop() currentTree = parent elif i in '+-*/': currentTree.setRootVal(i) currentTree.insertRight('') pStack.push(currentTree) currentTree = currentTree.getRightChild() elif i == ')': currentTree = pStack.pop() else: raise ValueError("Unknown Operator: " + i) return eTree 在代码清单5中，第11、15、19和24行的if语句体现了构建解析树的4条规则，其中每条语句都通过调用BinaryTree和Stack的方法实现了前面描述的规则。这个函数中唯一的错误检查在else从句中，如果遇到一个不能识别的标记，就抛出一个ValueError异常。 有了一棵解析树之后，我们能对它做些什么呢？作为第一个例子，我们可以写一个函数计算解析树，并返回计算结果。要写这个函数，我们将利用树的层次性。针对图7中的解析树，可以用图8中的简化解析树替换。由此可见，可以写一个算法，通过递归计算每棵子树得到整棵解析树的结果。 和之前编写递归函数一样，设计递归计算函数要从确定基本情况开始。就针对树进行操作的递归算法而言，一个很自然的基本情况就是检查叶子节点。解析树的叶子节点必定是操作数。由于像整数和浮点数这样的数值对象不需要进一步翻译，因此evaluate函数可以直接返回叶子节点的值。为了向基本情况靠近，算法将执行递归步骤，即对当前节点的左右子节点调用evaluate函数。递归调用可以有效地沿着各条边往叶子节点靠近。 若要结合两个递归调用的结果，只需将父节点中存储的运算符应用于子节点的计算结果即可。从图8中可知，根节点的两个子节点的计算结果就是它们自身，即10和3。应用乘号，得到最后的结果30。 递归函数evaluate的实现如代码清单10所示。首先，获取指向当前节点的左右子节点的引用。如果左右子节点的值都是None，就说明当前节点确实是叶子节点。第7行执行这项检查。如果当前节点不是叶子节点，则查看当前节点中存储的运算符，并将其应用于左右子节点的递归计算结果。 代码清单6 计算二叉解析树的递归函数 1234567891011def evaluate(parseTree): opers = &#123;'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv&#125; leftC = parseTree.getLeftChild() rightC = parseTree.getRightChild() if leftC and rightC: fn = opers[parseTree.getRootVal()] return fn(evaluate(leftC), evaluate(rightC)) else: return parseTree.getRootVal() 我们使用具有键+、-、*和/的字典实现。字典中存储的值是operator模块的函数。该模块给我们提供了常用运算符的函数版本。在字典中查询运算符时，对应的函数对象被取出。既然取出的对象是函数，就可以用普通的方式function(param1, param2)调用。因此，opers[\\’+\\’](2, 2)等价于operator.add(2, 2)。 最后，让我们通过图9中的解析树构建过程来理解evaluate函数。第一次调用evaluate函数时，将整棵树的根节点作为参数parseTree传入。然后，获取指向左右子节点的引用，检查它们是否存在。第9行进行递归调用。从查询根节点的运算符开始，该运算符是+，对应operator.add函数，要传入两个参数。和普通的Python函数调用一样，Python做的第一件事是计算入参的值。本例中，两个入参都是对evaluate函数的递归调用。由于入参的计算顺序是从左到右，因此第一次递归调用是在左边。对左子树递归调用evaluate函数，发现节点没有左右子节点，所以这是一个叶子节点。处于叶子节点时，只需返回叶子节点的值作为计算结果即可。本例中，返回整数3。 至此，我们已经为顶层的operator.add调用计算出一个参数的值了，但还没完。继续从左到右的参数计算过程，现在进行一个递归调用，计算根节点的右子节点。我们发现，该节点不仅有左子节点，还有右子节点，所以检查节点存储的运算符——是*，将左右子节点作为参数调用函数。这时可以看到，两个调用都已到达叶子节点，计算结果分别是4和5。算出参数之后，返回operator.mul(4, 5)的结果。至此，我们已经算出了顶层运算符（+）的操作数，剩下的工作就是完成对operator.add(3, 20)的调用。因此，表达式(3 + (4 * 5))的计算结果就是23。 树的遍历我们将对所有节点的访问称为“遍历”，共有3种遍历方式，分别为前序遍历、中序遍历和后序遍历。接下来，我们先仔细地定义这3种遍历方式，然后通过一些例子看看它们的用法。 前序遍历 在前序遍历中，先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树。 中序遍历 在中序遍历中，先递归地中序遍历左子树，然后访问根节点，最后递归地中序遍历右子树。 后序遍历 在后序遍历中，先递归地后序遍历右子树，然后递归地后序遍历左子树，最后访问根节点。 首先看看前序遍历。我们将一本书的内容结构表示为一棵树，整本书是根节点，每一章是根节点的子节点，每一章中的每一节是这章的子节点，每小节又是这节的子节点，依此类推。图10展示了一本书的树状结构，它包含两章。 图10 一本书的树状结构 假设我们从前往后阅读这本书，那么阅读顺序就符合前序遍历的次序。从根节点“书”开始，遵循前序遍历指令，对左子节点“第1章”递归调用preorder函数。然后，对“第1章”的左子节点递归调用preorder函数，得到节点“1.1节”。由于该节点没有子节点，因此不必再进行递归调用。沿着树回到节点“第1章”，接下来访问它的右子节点，即“1.2节”。和前面一样，先访问左子节点“1.2.1节”，然后访问右子节点“1.2.2节”。访问完“1.2节”之后，回到“第1章”。接下来，回到根节点，以同样的方式访问节点“第2章”。 遍历树的代码格外简洁，这主要是因为遍历是递归的。 你可能会想，前序遍历算法的最佳实现方式是什么呢？是一个将树用作数据结构的函数，还是树本身的一个方法？代码清单11给出了前序遍历算法的外部函数版本，该函数将二叉树作为参数，其代码尤为简洁，这是因为算法的基本情况仅仅是检查树是否存在。如果参数tree是None，函数直接返回。 代码清单11 将前序遍历算法实现为外部函数 12345def preorder(tree): if tree: print(tree.getRootVal()) preorder(tree.getLeftChild()) preorder(tree.getRightChild()) 我们也可以将preorder实现为BinaryTree类的方法，如代码清单12所示。请留意将代码从外部移到内部后有何变化。通常来说，不仅需要用self代替tree，还需要修改基本情况。内部方法必须在递归调用preorder前，检查左右子节点是否存在。 代码清单12 将前序遍历算法实现为BinaryTree类的方法 123456def preorder(self): print(self.key) if self.leftChild: self.left.preorder() if self.rightChild: self.right.preorder() 哪种实现方式更好呢？在本例中，将preorder实现为外部函数可能是更好的选择。原因在于，很少会仅执行遍历操作，在大多数情况下，还要通过基本的遍历模式实现别的目标。在下一个例子中，我们就会通过后序遍历来计算解析树。所以，我们在此采用外部函数版本。 在代码清单13中，后序遍历函数postorder与前序遍历函数preorder几乎相同，只不过对print的调用被移到了函数的末尾。 代码清单13 后序遍历函数 12345def postorder(tree): if tree != None: postorder(tree.getLeftChild()) postorder(tree.getRightChild()) print(tree.getRootVal()) 我们已经见识过后序遍历的一个常见用途，那就是计算解析树。回顾代码清单10，我们所做的就是先计算左子树，再计算右子树，最后通过根节点运算符的函数调用将两个结果结合起来。假设二叉树只存储一个表达式的数据。让我们来重写计算函数，使之更接近于代码清单13中的后序遍历函数。 代码清单14 后序求值函数 123456789101112def postordereval(tree): opers = &#123;'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv&#125; res1 = None res2 = None if tree: res1 = postordereval(tree.getLeftChild()) res2 = postordereval(tree.getRightChild()) if res1 and res2: return opers[tree.getRootVal()](res1, res2) else: return tree.getRootVal() 注意，代码清单14与代码清单13在形式上很相似，只不过求值函数最后不是打印节点，而是返回节点。这样一来，就可以保存从第7行和第8行的递归调用返回的值，然后在第10行使用这些值和运算符进行计算。 最后来了解中序遍历。中序遍历的访问顺序是左子树、根节点、右子树。代码清单15给出了中序遍历函数的代码。注意，3个遍历函数的区别仅在于print语句与递归调用语句的相对位置。 代码清单15 中序遍历函数 12345def inorder(tree): if tree != None: inorder(tree.getLeftChild()) print(tree.getRootVal()) inorder(tree.getRightChild()) 通过中序遍历解析树，可以还原不带括号的表达式。接下来修改中序遍历算法，以得到完全括号表达式。唯一要做的修改是：在递归调用左子树前打印一个左括号，在递归调用右子树后打印一个右括号。代码清单16是修改后的函数。 代码清单16 修改后的中序遍历函数，它能还原完全括号表达式 1234567def printexp(tree): sVal = "" if tree: sVal = '(' + printexp(tree.getLeftChild()) sVal = sVal + str(tree.getRootVal()) sVal = sVal + printexp(tree.getRightChild()) + ')' return sVal 以下Python会话展示了printexp和postordereval的用法。1234567891011121314&gt;&gt;&gt; from pythonds.trees import BinaryTree&gt;&gt;&gt; x = BinaryTree('*')&gt;&gt;&gt; x.insertLeft('+')&gt;&gt;&gt; l = x.getLeftChild()&gt;&gt;&gt; l.insertLeft(4)&gt;&gt;&gt; l.insertRight(5)&gt;&gt;&gt; x.insertRight(7)&gt;&gt;&gt;&gt;&gt;&gt; print(printexp(x))(((4) + (5)) * (7))&gt;&gt;&gt;&gt;&gt;&gt; print(postordereval(x))63&gt;&gt;&gt; 注意，printexp函数给每个数字都加上了括号。尽管不能算错误，但这些括号显然是多余的。在章末的练习中，请修改printexp函数，移除这些括号。 利用二叉堆实现优先级队列第3章介绍过队列这一先进先出的数据结构。队列有一个重要的变体，叫作优先级队列。和队列一样，优先级队列从头部移除元素，不过元素的逻辑顺序是由优先级决定的。优先级最高的元素在最前，优先级最低的元素在最后。因此，当一个元素入队时，它可能直接被移到优先级队列的头部。你在第7章会看到，对于一些图算法来说，优先级队列是一个有用的数据结构。 你或许可以想到一些使用排序函数和列表实现优先级队列的简单方法。但是，就时间复杂度而言，列表的插入操作是O(n)，排序操作是O(n log n)。其实，效率可以更高。实现优先级队列的经典方法是使用叫作二叉堆的数据结构。二叉堆的入队操作和出队操作均可达到O(log n)。 二叉堆学起来很有意思，它画出来很像一棵树，但实现时只用一个列表作为内部表示。二叉堆有两个常见的变体：最小堆（最小的元素一直在队首）与最大堆（最大的元素一直在队首）。 本节将实现最小堆，并将最大堆的实现留作练习。 二叉堆的操作我们将实现以下基本的二叉堆方法。 BinaryHeap()新建一个空的二叉堆。 insert(k)往堆中加入一个新元素。 findMin()返回最小的元素，元素留在堆中。 delMin()返回最小的元素，并将该元素从堆中移除。 isEmpty()在堆为空时返回True，否则返回False。 size()返回堆中元素的个数。 buildHeap(list)根据一个列表创建堆。 以下 Python会话展示了一些二叉堆方法的用法。12345678910111213&gt;&gt;&gt; from pythonds.trees import BinaryHeap&gt;&gt;&gt; bh = BinaryHeap()&gt;&gt;&gt; bh.insert(5)&gt;&gt;&gt; bh.insert(7)&gt;&gt;&gt; bh.insert(3)&gt;&gt;&gt; bh.insert(11)&gt;&gt;&gt; print(bh.delMin())3&gt;&gt;&gt; print(bh.delMin())5&gt;&gt;&gt; print(bh.delMin())7&gt;&gt;&gt; print(bh.delMin()) 二叉堆的实现1.结构属性 为了使二叉堆能高效地工作，我们利用树的对数性质来表示它。你会在6.7.3节学到，为了保证对数性能，必须维持树的平衡。平衡的二叉树是指，其根节点的左右子树含有数量大致相等的节点。在实现二叉堆时，我们通过创建一棵完全二叉树来维持树的平衡。在完全二叉树中，除了最底层，其他每一层的节点都是满的。在最底层，我们从左往右填充节点。图11展示了完全二叉树的一个例子。 图11 完全二叉树 完全二叉树的另一个有趣之处在于，可以用一个列表来表示它，而不需要采用“列表之列表”或“节点与引用”表示法。由于树是完全的，因此对于在列表中处于位置p的节点来说，它的左子节点正好处于位置2p；同理，右子节点处于位置2p+1。若要找到树中任意节点的父节点，只需使用Python的整数除法即可。给定列表中位置 n处的节点，其父节点的位置就是 n/2。图6-15展示了一棵完全二叉树，并给出了列表表示。树的列表表示——加上这个“完全”的结构性质——让我们得以通过一些简单的数学运算遍历完全二叉树。我们会看到，这也有助于高效地实现二叉堆。 图12 一棵完全二叉树及其列表表示 2.堆的有序性 我们用来存储堆元素的方法依赖于堆的有序性。堆的有序性是指：对于堆中任意元素x及其父元素p，p都不大于x。图12也展示出完全二叉树具备堆的有序性。 3.堆操作 首先实现二叉堆的构造方法。既然用一个列表就可以表示整个二叉堆，那么构造方法要做的就是初始化这个列表与属性currentSize，用于记录堆的当前大小。代码清单17给出了构造方法的Python代码。列表heapList的第一个元素是0，它的唯一用途是为了使后续的方法可以使用整数除法。 代码清单17 新建二叉堆 123def __init__(self): self.heapList = [0] self.currentSize = 0 接下来实现insert方法。将元素加入列表的最简单、最高效的方法就是将元素追加到列表的末尾。追加操作的优点在于，它能保证完全树的性质，但缺点是很可能会破坏堆的结构性质。 不过可以写一个方法，通过比较新元素与其父元素来重新获得堆的结构性质。如果新元素小于其父元素，就将二者交换。图16展示了将新元素放到正确位置上所需的一系列交换操作。 图13 将新元素往上移到正确位置 注意，将元素往上移时，其实是在新元素及其父元素之间重建堆的结构性质。此外，也保留了兄弟元素之间的堆性质。当然，如果新元素很小，需要继续往上一层交换。代码清单18给出了percUp方法的代码，该方法将元素一直沿着树向上移动，直到重获堆的结构性质。此时，heapList中的元素0正好能发挥重要作用。我们使用整数除法计算任意节点的父节点。就当前节点而言，父节点的下标就是当前节点的下标除以2。 代码清单18 percUp方法 1234567def percUp(self, i): while i // 2 &gt; 0: if self.heapList[i] &lt; self.heapList[i // 2]: tmp = self.heapList[i // 2] self.heapList[i // 2] = self.heapList[i] self.heapList[i] = tmp i = i // 2 现在准备好编写insert方法了。代码清单19给出了该方法的Python代码。其实，insert方法的大部分工作是由percUp方法完成的。当元素被追加到树中之后，percUp方法将其移到正确的位置。 代码清单19 向二叉堆中新加元素 1234def insert(self, k): self.heapList.append(k) self.currentSize = self.currentSize + 1 self.percUp(self.currentSize) 正确定义insert方法后，就可以编写delMin方法。既然堆的结构性质要求根节点是树的最小元素，那么查找最小值就很简单。delMin方法的难点在于，如何在移除根节点之后重获堆的结构性质和有序性。可以分两步重建堆。第一步，取出列表中的最后一个元素，将其移到根节点的位置。移动最后一个元素保证了堆的结构性质，但可能会破坏二叉堆的有序性。第二步，将新的根节点沿着树推到正确的位置，以重获堆的有序性。图6-17展示了将新的根节点移动到正确位置所需的一系列交换操作。 图14 将根节点往下移到正确位置 为了维持堆的有序性，只需交换根节点与它的最小子节点即可。重复节点与子节点的交换过程，直到节点比其两个子节点都小。代码清单20给出了percDown方法和minChild方法的Python代码。 代码清单20 percDown方法和minChild方法 1234567891011121314151617def percDown(self, i): while (i * 2) &lt;= self.currentSize: mc = self.minChild(i) if self.heapList[i] &gt; self.heapList[mc]: tmp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = tmp i = mcdef minChild(self, i): if i * 2 + 1 &gt; self.currentSize: return i * 2 else: if self.heapList[i*2] &lt; self.heapList[i*2+1]: return i * 2 else: return i * 2 + 1 delMin方法如代码清单21所示。同样，主要工作也由辅助函数完成。本例中的辅助函数是percDown。 代码清单21 从二叉堆中删除最小的元素 1234567def delMin(self): retval = self.heapList[1] self.heapList[1] = self.heapList[self.currentSize] self.currentSize = self.currentSize - 1 self.heapList.pop() self.percDown(1) return retval 关于二叉堆，还有最后一点需要讨论。我们来看看根据元素列表构建整个堆的方法。你首先想到的方法或许是这样的：给定元素列表，每次插入一个元素，构建一个堆。由于是从列表只有一个元素的情况开始，并且列表是有序的，因此可以采用二分搜索算法找到下一个元素的正确插入位置，时间复杂度约为O(log n)。但是，为了在列表的中部插入元素，可能需要移动其他元素，以为新元素腾出空间，这种操作的时间复杂度为O(n)。因此，将n个元素插入堆中的操作为O(n log n)。然而，如果从完整的列表开始，构建整个堆只需O(n)。代码清单22给出了构建整个堆的代码。 代码清单22 根据元素列表构建堆 1234567def buildHeap(self, alist): i = len(alist) // 2 self.currentSize = len(alist) self.heapList = [0] + alist[:] while (i &gt; 0): self.percDown(i) i = i – 1 图15 根据列表[9, 6, 5, 2, 3]构建堆 图15展示了buildHeap方法进行的交换过程，它将各节点从最初状态移到各自的正确位置上。尽管从树的中间开始，向根的方向操作，但是percDown方法保证了最大的节点总是沿着树向下移动。在这棵完全二叉树中，超过中点的节点都是叶子节点，没有任何子节点。当i=1时，从树的根节点往下移，可能需要经过多次交换。如你所见，9先被移出根节点，然后percDown会沿着树检查子节点，以确保尽量将它往下移。在本例中，9的第2次交换对象是3。这样一来，9就移到了树的底层，不需要再做交换了。比较一系列交换操作后的列表表示将有助于理解，如图16所示。 图16 根据列表[9, 6, 5, 2, 3]构建堆 前面说过，构建堆的时间复杂度是O(n)，这乍一听可能很难理解，证明过程超出了本书范畴。不过，要点在于，因子log n是由树的高度决定的。在buildHeap的大部分工作中，树的高度不足log n。 利用建堆的时间复杂度为O(n)这一点，可以构造一个使用堆为列表排序的算法，使它的时间复杂度为O(n log n)。这个算法留作练习。 二叉搜索树我们已经学习了两种从集合中获取键–值对的方法。回想一下，我们讨论过映射抽象数据类型的两种实现，它们分别是列表二分搜索和散列表。本节将探讨二叉搜索树，它是映射的另一种实现。我们感兴趣的不是元素在树中的确切位置，而是如何利用二叉树结构提供高效的搜索。 搜索树的操作在实现搜索树之前，我们来复习一下映射抽象数据类型提供的接口。你会发现，这个接口类似于Python字典。 Map()新建一个空的映射。 put(key, val)往映射中加入一个新的键–值对。如果键已经存在，就用新值替换旧值。 get(key)返回key对应的值。如果key不存在，则返回None。 del通过del map[key]这样的语句从映射中删除键–值对。 len()返回映射中存储的键–值对的数目。 in通过key in map这样的语句，在键存在时返回True，否则返回False 。 搜索树的实现二叉搜索树依赖于这样一个性质：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。我们称这个性质为二叉搜索性，它会引导我们实现上述映射接口。图6-20描绘了二叉搜索树的这个性质，图中只展示了键，没有展示对应的值。注意，每一对父节点和子节点都具有这个性质。左子树的所有键都小于根节点的键，右子树的所有键则都大于根节点的键。 图6-20 简单的二叉搜索树 接下来看看如何构造二叉搜索树。图6-20中的节点是按如下顺序插入键之后形成的：70、31、93、94、14、23、73。因为70是第一个插入的键，所以是根节点。31小于70，所以成为70的左子节点。93大于70，所以成为70的右子节点。现在树的两层已经满了，所以下一个键会成为31或93的子节点。94比70和93都要大，所以它成了93的右子节点。同理，14比70和31都要小，所以它成了31的左子节点。23也小于31，所以它必定在31的左子树中。而它又大于14，所以成了14的右子节点。 我们将采用“节点与引用”表示法实现二叉搜索树，它类似于我们在实现链表和表达式树时采用的方法。不过，由于必须创建并处理一棵空的二叉搜索树，因此我们将使用两个类。一个称作BinarySearchTree，另一个称作TreeNode。BinarySearchTree类有一个引用，指向作为二叉搜索树根节点的TreeNode类。大多数情况下，外面这个类的方法只是检查树是否为空。如果树中有节点，请求就被发往BinarySearchTree类的私有方法，这个方法以根节点作为参数。当树为空，或者想删除根节点的键时，需要采取特殊措施。代码清单23是BinarySearchTree类的构造方法及一些其他的方法。 代码清单23 BinarySearchTree类 1234567891011121314class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size def __iter__(self): return self.root.__iter__() TreeNode类提供了很多辅助函数，这大大地简化了BinarySearchTree类的工作。代码清单24是TreeNode类的构造方法以及辅助函数。可以看到，很多辅助函数有助于根据子节点的位置（是左还是右）以及自己的子节点类型来给节点归类。 代码清单24 TreeNode类 12345678910111213141516171819202122232425262728293031323334353637383940414243class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def hasLeftChild(self): return self.leftChild def hasRightChild(self): return self.rightChild def isLeftChild(self): return self.parent and \ self.parent.leftChild == self def isRightChild(self): return self.parent and \ self.parent.rightChild == self def isRoot(self): return not self.parent def isLeaf(self): return not (self.rightChild or self.leftChild) def hasAnyChildren(self): return self.rightChild or self.leftChild def hasBothChildren(self): return self.rightChild and self.leftChild def replaceNodeData(self, key, value, lc, rc): self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.hasLeftChild(): self.leftChild.parent = self if self.hasRightChild(): self.rightChild.parent = self TreeNode类与6.4.2节中的BinaryTree类有一个很大的区别，那就是显式地将每个节点的父节点记录为它的一个属性。在讨论del操作的实现时，你会看到这一点为何重要。 在TreeNode类的实现中，另一个有趣之处是使用Python的可选参数。可选参数使得在多种环境下创建TreeNode更方便。有时，我们想构造一个已有parent和child的TreeNode。可以将父节点和子节点作为参数传入。其他时候，只通过键–值对创建TreeNode，而不传入parent和child。在这种情况下，可选参数使用默认值。 现在有了BinarySearchTree和TreeNode，是时候写一个帮我们构建二叉搜索树的put方法了。put是BinarySearchTree类的一个方法。它检查树是否已经有根节点，若没有，就创建一个TreeNode，并将其作为树的根节点；若有，就调用私有的递归辅助函数_put，并根据以下算法在树中搜索。 从根节点开始搜索二叉树，比较新键与当前节点的键。如果新键更小，搜索左子树。如果新键更大，搜索右子树。 当没有可供搜索的左（右）子节点时，就说明找到了新键的插入位置。 向树中插入一个节点，做法是创建一个TreeNode对象，并将其插入到前一步发现的位置上。 向树中插入新节点的方法如代码清单25所示。按照上述步骤，我们将_put写成递归函数。注意，在向树中插入新的子节点时，currentNode被作为父节点传入新树。 代码清单25 为二叉搜索树插入新节点 123456789101112131415161718def put(self, key, val): if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size = self.size + 1def _put(self, key, val, currentNode): if key &lt; currentNode.key: if currentNode.hasLeftChild(): self._put(key, val, currentNode.leftChild) else: currentNode.leftChild = TreeNode(key, val, parent=currentNode) else: if currentNode.hasRightChild(): self._put(key, val, currentNode.rightChild) else: currentNode.rightChild = TreeNode(key, val, parent=currentNode) 插入方法有个重要的问题：不能正确地处理重复的键。遇到重复的键时，它会在已有节点的右子树中创建一个具有同样键的节点。这样做的结果就是搜索时永远发现不了较新的键。要处理重复键插入，更好的做法是用关联的新值替换旧值。这个修复工作留作练习。 定义put方法后，就可以方便地通过让__setitem__方法调用put方法来重载[]运算符。如此一来，就可以写出像myZipTree[‘Plymouth’] = 55446这样的Python语句，就如同访问Python字典一样。__setitem__方法如代码清单26所示。 代码清单26 __setitem__方法 12def __setitem__(self, k, v): self.put(k, v) 图6-21展示了向二叉搜索树中插入新节点的过程。浅灰色节点表示在插入过程中被访问过的节点。 构造出树后，下一个任务就是实现为给定的键取值。get方法比put方法还要简单，因为它只是递归地搜索二叉树，直到访问到叶子节点或者找到匹配的键。在后一种情况下，它会返回节点中存储的值。 图6-21 插入键为19的新节点 get、_get和__getitem__的实现如代码清单27所示。_get方法中的搜索代码和_put方法中选择左右子节点的逻辑相同。注意，_get方法返回一个TreeNode给get。这样一来，对于其他BinarySearchTree方法来说，如果需要使用TreeNode有效载荷之外的数据，_get可以作为灵活的辅助函数使用。 通过实现__getitem__方法，可以写出类似于访问字典的Python语句——而实际上使用的是二叉搜索树——比如z = myZipTree[‘Fargo’]。从代码清单27可以看出，__getitem__方法要做的就是调用get方法。 代码清单27 查找键对应的值 12345678910111213141516171819202122def get(self, key): if self.root: res = self._get(key, self.root) if res: return res.payload else: return None else: return Nonedef _get(self, key, currentNode): if not currentNode: return None elif currentNode.key == key: return currentNode elif key &lt; currentNode.key: return self._get(key, currentNode.leftChild) else: return self._get(key, currentNode.rightChild)def __getitem__(self, key): return self.get(key) 利用get方法，可以通过为BinarySearchTree编写__contains方法来实现in操作。\contains方法只需调用get方法，并在get方法返回一个值时返回True，或在get方法返回None时返回False。代码清单28实现了\contains__方法。 代码清单28 检查树中是否有某个键 12345def __contains__(self, key): if self._get(key, self.root): return True else: return False 你应该记得，__contains__方法重载了in运算符，因此我们可以写出这样的语句：12if 'Northfield' in myZipTree: print("oom ya ya") 最后，我们将注意力转向二叉搜索树中最有挑战性的方法——删除一个键。第一个任务是在树中搜索并找到要删除的节点。如果树中不止一个节点，使用_get方法搜索，找到要移除的TreeNode。如果树中只有一个节点，则意味着要移除的是根节点，不过仍要确保根节点的键就是要删除的键。无论哪种情况，如果找不到要删除的键，delete方法都会抛出一个异常，如代码清单29所示。 代码清单29 delete方法 12345678910111213141516def delete(self, key): if self.size &gt; 1: nodeToRemove = self._get(key, self.root) if nodeToRemove: self.remove(nodeToRemove) self.size = self.size – 1 else: raise KeyError('Error, key not in tree') elif self.size == 1 and self.root.key == key: self.root = None self.size = self.size – 1 else: raise KeyError('Error, key not in tree')def __delitem__(self, key): self.delete(key) 一旦找到待删除键对应的节点，就必须考虑3种情况。 (1)待删除节点没有子节点（如图22所示）。 图6-22 待删除节点16没有子节点 (2)待删除节点只有一个子节点（如图23所示）。 图6-23 待删除节点25有一个子节点 (3)待删除节点有两个子节点（如图24所示）。 图6-24 待删除节点5有两个子节点 情况1很简单。如果当前节点没有子节点，要做的就是删除这个节点，并移除父节点对这个节点的引用，如代码清单30所示。 代码清单30 情况1：待删除节点没有子节点 12345if currentNode.isLeaf(): if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None 情况2稍微复杂些。如果待删除节点只有一个子节点，那么可以用子节点取代待删除节点，如代码清单31所示。查看这段代码后会发现，它考虑了6种情况。由于左右子节点的情况是对称的，因此只需要讨论当前节点有左子节点的情况。 (1)如果当前节点是一个左子节点，只需将当前节点的左子节点对父节点的引用改为指向当前节点的父节点，然后将父节点对当前节点的引用改为指向当前节点的左子节点。 (2)如果当前节点是一个右子节点，只需将当前节点的右子节点对父节点的引用改为指向当前节点的父节点，然后将父节点对当前节点的引用改为指向当前节点的右子节点。 (3)如果当前节点没有父节点，那它肯定是根节点。调用replaceNodeData方法，替换根节点的key、payload、leftChild和rightChild数据。 代码清单31 情况2：待删除节点只有一个子节点 12345678910111213141516171819202122232425else: # 只有一个子节点 if currentNode.hasLeftChild(): if currentNode.isLeftChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.leftChild elif currentNode.isRightChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.leftChild else: currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) else: if currentNode.isLeftChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.rightChild elif currentNode.isRightChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.rightChild else: currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) 情况3最难处理。如果一个节点有两个子节点，那就不太可能仅靠用其中一个子节点取代它来解决问题。不过，可以搜索整棵树，找到可以替换待删除节点的节点。候选节点要能为左右子树都保持二叉搜索树的关系，也就是树中具有次大键的节点。我们将这个节点称为后继节点，有一种方法能快速找到它。后继节点的子节点必定不会多于一个，所以我们知道如何按照已实现的两种删除方法来移除它。移除后继节点后，只需直接将它放到树中待删除节点的位置上即可。 处理情况3的代码如代码清单32所示。注意，我们用辅助函数findSuccessor和findMin来寻找后继节点，并用spliceOut方法移除它（如代码清单34所示）。之所以用spliceOut方法，是因为它可以直接访问待拼接的节点，并进行正确的修改。虽然也可以递归调用delete，但那样做会浪费时间重复搜索键的节点。 代码清单32 情况3：待删除节点有两个子节点 12345elif currentNode.hasBothChildren(): # 内部 succ = currentNode.findSuccessor() succ.spliceOut() currentNode.key = succ.key currentNode.payload = succ.payload 寻找后继节点的代码如代码清单33所示。可以看出，这是TreeNode类的一个方法。它利用的二叉搜索树属性，也是从小到大打印出树节点的中序遍历所利用的。在查找后继节点时，要考虑以下3种情况。 (1)如果节点有右子节点，那么后继节点就是右子树中最小的节点。 (2)如果节点没有右子节点，并且其本身是父节点的左子节点，那么后继节点就是父节点。 (3)如果节点是父节点的右子节点，并且其本身没有右子节点，那么后继节点就是除其本身外父节点的后继节点。 在试图从一棵二叉搜索树中删除节点时，上述第一个条件是唯一重要的。但是，findSuccessor方法还有其他用途，本章末会进行探索。 findMin方法用来查找子树中最小的键。可以确定，在任意二叉搜索树中，最小的键就是最左边的子节点。鉴于此，findMin方法只需沿着子树中每个节点的leftChild引用走，直到遇到一个没有左子节点的节点。代码清单35给出了完整的remove方法。 代码清单33 寻找后继节点 12345678910111213141516171819def findSuccessor(self): succ = None if self.hasRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succdef findMin(self): current = self while current.hasLeftChild(): current = current.leftChild return current 代码清单34 spliceOut方法 12345678910111213141516171819def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.hasLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent 代码清单35 remove方法 1234567891011121314151617181920212223242526272829303132333435363738def remove(self, currentNode):if currentNode.isLeaf(): # 叶子节点 if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = Noneelse: currentNode.parent.rightChild = Noneelif currentNode.hasBothChildren(): # 内部succ = currentNode.findSuccessor()succ.spliceOut()currentNode.key = succ.keycurrentNode.payload = succ.payloadelse: # 只有一个子节点if currentNode.hasLeftChild(): if currentNode.isLeftChild(): currentNode.leftChild.parent = currentNode.parentcurrentNode.parent.leftChild = currentNode.leftChildelif currentNode.isRightChild():currentNode.leftChild.parent = currentNode.parentcurrentNode.parent.rightChild = currentNode.leftChildelse: currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload,currentNode.leftChild.leftChild,currentNode.leftChild.rightChild) else:if currentNode.isLeftChild(): currentNode.rightChild.parent = currentNode.parentcurrentNode.parent.leftChild = currentNode.rightChildelif currentNode.isRightChild():currentNode.rightChild.parent = currentNode.parentcurrentNode.parent.rightChild = currentNode.rightChildelse: currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload,currentNode.rightChild.leftChild,currentNode.rightChild.rightChild) 现在来看看最后一个二叉搜索树接口方法。假设我们想按顺序遍历树中的键。我们在字典中就是这么做的，为什么不在树中试试呢？我们已经知道如何按顺序遍历二叉树——使用中序遍历算法。不过，为了创建迭代器，还需要做更多工作，因为迭代器每次调用只返回一个节点。 Python为创建迭代器提供了一个很强大的函数，即yield。与return类似，yield每次向调用方返回一个值。除此之外，yield还会冻结函数的状态，因此下次调用函数时，会从这次离开之处继续。创建可迭代对象的函数被称作生成器。 二叉搜索树迭代器的代码如代码清单36所示。请仔细看看这份代码。乍看之下，你可能会认为它不是递归的。但是，因为 __iter__ 重载了循环的for x in操作，所以它真的是递归的！由于在TreeNode实例上递归，因此__iter__方法被定义在TreeNode类中。 代码清单 6-36 二叉搜索树迭代器 123456789def __iter__(self):if self:if self.hasLeftChild(): for elem in self.leftChild: yield elemyield self.key if self.hasRightChild():for elem in self.rightChild:yield elem 搜索树的分析至此，我们已经完整地实现了二叉搜索树，接下来简单地分析它的各个方法。先分析put方法，限制其性能的因素是二叉树的高度。6.3节曾说过，树的高度是其中节点层数的最大值。高度之所以是限制因素，是因为在搜索合适的插入位置时，每一层最多需要做一次比较。 那么，二叉树的高度是多少呢？答案取决于键的插入方式。如果键的插入顺序是随机的，那么树的高度约为log2n，其中n为树的节点数。这是因为，若键是随机分布的，那么小于和大于根节点的键大约各占一半。二叉树的顶层有1个根节点，第1层有2个节点，第2层有4个节点，依此类推。在完全平衡的二叉树中，节点总数是2h+1-1，其中h代表树的高度。 在完全平衡的二叉树中，左右子树的节点数相同。最坏情况下，put的时间复杂度是O(log2n)，其中n是树的节点数。注意，这是上一段所述运算的逆运算。所以，log2n是树的高度，代表put在搜索合适的插入位置时所需的最大比较次数。 不幸的是，按顺序插入键可以构造出一棵高度为n的搜索树！图6-25就是一个例子，这时put方法的时间复杂度为O(n)。 图25 偏斜的二叉搜索树 既然理解了为何说put的性能由树的高度决定，你应该可以猜到，get、in和del也都如此。get在树中查找键，最坏情况就是沿着树一直搜到底也没找到。乍看之下，del可能更复杂，因为在删除节点前可能还得找到后继节点。但是查找后继节点的最坏情况也受限于树的高度，也就是把工作量加一倍。所以，对于不平衡的树来说，最坏情况下的时间复杂度仍是O(n)。 平衡二叉搜索树在 6.7节中，我们了解了二叉搜索树的构建过程。我们已经知道，当二叉搜索树不平衡时，get 和 put 等操作的性能可能降到 ( ) O n 。本节将介绍一种特殊的二叉搜索树，它能自动维持平衡。这种树叫作 AVL 树，以其发明者 G. M. Adelson-Velskii和 E. M. Landis的姓氏命名。 AVL树实现映射抽象数据类型的方式与普通的二叉搜索树一样，唯一的差别就是性能。实现AVL树时，要记录每个节点的平衡因子。我们通过查看每个节点左右子树的高度来实现这一点。更正式地说，我们将平衡因子定义为左右子树的高度之差。 ( ) ( ) balanceFactor height left SubTree height rightSubTree  根据上述定义，如果平衡因子大于零，我们称之为左倾；如果平衡因子小于零，就是右倾；如果平衡因子等于零，那么树就是完全平衡的。为了实现AVL树并利用平衡树的优势，我们将平衡因子为–1、0和 1的树都定义为平衡树。一旦某个节点的平衡因子超出这个范围，我们就需要通过一个过程让树恢复平衡。图26展示了一棵右倾树及其中每个节点的平衡因子。 图26 带平衡因子的右倾树 AVL 树的性能我们先看看限定平衡因子带来的结果。我们认为，保证树的平衡因子为–1、0或1，可以使关键操作获得更好的大O性能。首先考虑平衡因子如何改善最坏情况。有左倾与右倾这两种可能性。如果考虑高度为0、1、2和 3的树，图27展示了应用新规则后最不平衡的左倾树。 图27 左倾 AVL 树的最坏情况 查看树中的节点数之后可知，高度为 0时有 1个节点，高度为 1时有 2个节点（1 + 1 = 2），高度为 2时有 4个节点（1 + 1 + 2 = 4），高度为 3时有 7个节点（1 + 2 + 4 = 7）。也就是说，当高度为 h时，节点数hN 是：   你或许觉得这个公式很眼熟，因为它与斐波那契数列很相似。可以根据它推导出由AVL树的节点数计算高度的公式。在斐波那契数列中，第 i个数是： 一个重要的事实是，随着斐波那契数列的增长， F F 逐渐逼近黄金分割比例  ， = 。如果你好奇这个等式的推导过程，可以找一本数学书看看。我们在此直接使用这个等式，将iF 近似为 / 5iiF   。由此，可以将hN 的等式重写为：N h = F h+2 1, h≥1用黄金分割近似替换，得到：  移项，两边以 2为底取对数，求 h，得到：  在任何时间，AVL树的高度都等于节点数取对数再乘以一个常数（1.44）。对于搜索AVL树来说，这是一件好事，因为时间复杂度被限制为 (log ) O N 。 AVL 树的实现我们已经证明，保持 AVL 树的平衡会带来很大的性能优势，现在看看如何往树中插入一个键。所有新键都是以叶子节点插入的，因为新叶子节点的平衡因子是零，所以新插节点没有什么限制条件。但插入新节点后，必须更新父节点的平衡因子。新的叶子节点对其父节点平衡因子的影响取决于它是左子节点还是右子节点。如果是右子节点，父节点的平衡因子减一。如果是左子节点，则父节点的平衡因子加一。这个关系可以递归地应用到每个祖先，直到根节点。既然更新平衡因子是递归过程，就来检查以下两种基本情况： 递归调用抵达根节点； 父节点的平衡因子调整为零；可以确信，如果子树的平衡因子为零，那么祖先节点的平衡因子将不会有变化。 我们将 AVL 树实现为 BinarySearchTree 的子类。首先重载_put方法，然后新写updateBalance辅助方法，如代码清单 6-37 所示。可以看到，除了在第 8 行和第 15 行调用updateBalance 以外， _put 方法的定义和代码清单 6-25中的几乎一模一样。 代码清单 6-37 更新平衡因子 12345678910111213141516171819202122232425262728def _put(self, key, val, currentNode):if key &lt; currentNode.key:if currentNode.hasLeftChild():self._put(key, val, currentNode.leftChild) else:currentNode.leftChild = TreeNode(key, val,parent=currentNode) self.updateBalance(currentNode.leftChild) else: if currentNode.hasRightChild(): self._put(key, val, currentNode.rightChild) else: currentNode.rightChild = TreeNode(key, val, parent=currentNode) self.updateBalance(currentNode.rightChild) def updateBalance(self, node): if node.balanceFactor &gt; 1 or node.balanceFactor &lt; -1: self.rebalance(node) return if node.parent != None: if node.isLeftChild(): node.parent.balanceFactor += 1 elif node.isRightChild(): node.parent.balanceFactor -= 1 if node.parent.balanceFactor != 0: self.updateBalance(node.parent) 新方法updateBalance做了大部分工作，它实现了前面描述的递归过程。updateBalance方法先检查当前节点是否需要再平衡（第 18行）。如果符合判断条件，就进行再平衡，不需要更新父节点；如果当前节点不需要再平衡，就调整父节点的平衡因子。如果父节点的平衡因子非零，那么沿着树往根节点的方向递归调用updateBalance 方法。 如果需要进行再平衡，该怎么做呢？高效的再平衡是让AVL树发挥作用同时不损性能的关键。为了让AVL树恢复平衡，需要在树上进行一次或多次旋转。 要理解什么是旋转，来看一个简单的例子。考虑图6-28中左边的树。这棵树失衡了，平衡因子是–2。要让它恢复平衡，我们围绕以节点 A为根节点的子树做一次左旋。 图28 通过左旋让失衡的树恢复平衡 本质上，左旋包括以下步骤。 将右子节点（节点 B）提升为子树的根节点。 将旧根节点（节点 A）作为新根节点的左子节点。 如果新根节点（节点B）已经有一个左子节点，将其作为新左子节点（节点A）的右子节点。注意，因为节点 B之前是节点 A的右子节点，所以此时节点 A必然没有右子节点。 因此，可以为它添加新的右子节点，而无须过多考虑。 左旋过程在概念上很简单，但代码细节有点复杂，因为需要将节点挪来挪去，以保证二叉搜索树的性质。另外，还要保证正确地更新父指针。我们来看一棵稍微复杂一点的树，并理解右旋过程。图29 左边的是一棵左倾的树，根节点的平衡因子是 2。右旋步骤如下。 将左子节点（节点 C）提升为子树的根节点。 将旧根节点（节点 E）作为新根节点的右子节点。 如果新根节点（节点 C）已经有一个右子节点（节点 D），将其作为新右子节点（节点 E）的左子节点。注意，因为节点 C 之前是节点 E 的左子节点，所以此时节点 E 必然没有左子节点。因此，可以为它添加新的左子节点，而无须过多考虑。 图29通过右旋让失衡的树恢复平衡了解旋转的基本原理之后，来看看代码。代码清单38给出了左旋的代码。第2行创建一个临时变量，用于记录子树的新根节点。如前所述，新根节点是旧根节点的右子节点。既然临时变量存储了指向右子节点的引用，便可以将旧根节点的右子节点替换为新根节点的左子节点。 下一步是调整这两个节点的父指针。如果新根节点有左子节点，那么这个左子节点的新父节点就是旧根节点。将新根节点的父指针指向旧根节点的父节点。如果旧根节点是整棵树的根节点，那么必须将树的根节点设为新根节点；如果不是，则当旧根节点是左子节点时，将左子节点的父指针指向新根节点；当旧根节点是右子节点时，将右子节点的父指针指向新根节点（第 10~13行）。 最后，将旧根节点的父节点设为新根节点。这一系列描述很复杂，所以建议你根据图6-28的例子运行一遍函数。 rotateRight 与 rotateLeft 对称，所以留作练习。 代码清单 6-38 左旋 12345678910111213141516171819def rotateLeft(self, rotRoot): newRoot = rotRoot.rightChild rotRoot.rightChild = newRoot.leftChild if newRoot.leftChild != None: newRoot.leftChild.parent = rotRoot newRoot.parent = rotRoot.parent if rotRoot.isRoot(): self.root = newRoot else: if rotRoot.isLeftChild(): rotRoot.parent.leftChild = newRoot else: rotRoot.parent.rightChild = newRoot newRoot.leftChild = rotRoot rotRoot.parent = newRoot rotRoot.balanceFactor = rotRoot.balanceFactor + 1 \ - min(newRoot.balanceFactor, 0) newRoot.balanceFactor = newRoot.balanceFactor + 1 \ + max(rotRoot.balanceFactor, 0) 第16~19行需要特别解释一下。这几行更新了旧根节点和新根节点的平衡因子。由于其他移动操作都是针对整棵子树，因此旋转后其他节点的平衡因子都不受影响。但在没有完整地重新计算新子树高度的情况下，怎么能更新平衡因子呢？下面的推导过程能证明，这些代码是对的。 图30 左旋 图30 展示了左旋结果。B 和 D 是关键节点，A、C、E 是它们的子树。针对根节点为 x 的子树，将其高度记为xh 。由定义可知：( )( )A CA DnewBal B h holdBal B h h  D 的旧高度也可以定义为 1 max( , )C Eh h  ，即 D 的高度等于两棵子树的高度的大值加一。因为Ch 与Eh 不变，所以代入第 2 个等式，得到 ( ) (1 max( , ))A C EoldBal B h h h    。然后，将两个等式相减，并运用代数知识简化 ( ) newBal B 的等式。( ) ( ) ( (1 max( , )))( ) ( ) (1 max( , ))( ) ( ) 1 max( , )( ) ( ) 1 max( , )A C A C EA C A C EA A C E CC E CnewBal B oldBal B h h h h hnewBal B oldBal B h h h h hnewBal B oldBal B h h h h hnewBal B oldBal B h h h                  下面将 ( ) oldBal B 移到等式右边，并利用性质 max( , ) max( , ) a b c a c b c     得到：( ) ( ) 1 max( , )C C E CnewBal B oldBal B h h h h     由于E Ch h  就等于 ( ) oldBal D  ，因此可以利用另一个性质 max( , ) min( , ) a b a b     。最后几步推导如下：( ) ( ) 1 max(0, ( ))( ) ( ) 1 min(0, ( ))newBal B oldbal B oldBal DnewBal B oldBal B oldBal D    至此，我们已经做好所有准备了。如果还记得B是rotRoot而D是newRoot，那么就能看到以上等式对应于代码清单6-38中的第16行： 12rotRoot.balanceFactor = rotRoot.balanceFactor + 1 \- min(newRoot.balanceFactor, 0) 通过类似的推导，可以得到节点D的等式，以及右旋后的平衡因子。这个推导过程留作练习。 现在你可能认为大功告成了。我们已经知道如何左旋和右旋，也知道应该在什么时候旋转，但请看看图31。节点A的平衡因子为–2，应该做一次左旋。但是，围绕节点A左旋后会怎样呢？ 图31 更难平衡的树 左旋后得到另一棵失衡的树，如图32所示。如果在此基础上做一次右旋，就回到了图31的状态。 图32 左旋后，树朝另一个方向失衡 要解决这种问题，必须遵循以下规则。 如果子树需要左旋，首先检查右子树的平衡因子。如果右子树左倾，就对右子树做一次右旋，再围绕原节点做一次左旋。 如果子树需要右旋，首先检查左子树的平衡因子。如果左子树右倾，就对左子树做一次左旋，再围绕原节点做一次右旋。 图33展示了如何通过以上规则解决图31和图32中的困境。围绕节点C做一次右旋，再围绕节点A做一次左旋，就能让子树恢复平衡。 图33 先右旋，再左旋 rebalance方法实现了上述规则，如代码清单6-39所示。第2行的if语句实现了规则1，第8行的elif语句实现了规则2。 在6.11节中，你将尝试通过先左旋再右旋的方式恢复一棵树的平衡，还会试着为一些更复杂的树恢复平衡。 代码清单6-39 实现再平衡 12345678910111213def rebalance(self, node): if node.balanceFactor &lt; 0: if node.rightChild.balanceFactor &gt; 0: self.rotateRight(node.rightChild) self.rotateLeft(node) else: self.rotateLeft(node) elif node.balanceFactor &gt; 0: if node.leftChild.balanceFactor &lt; 0: self.rotateLeft(node.leftChild) self.rotateRight(node) else: self.rotateRight(node) 通过维持树的平衡，可以保证get方法的时间复杂度为$O(\log_2n)$。但这会给put操作的性能带来多大影响呢？我们来看看put操作。因为新节点作为叶子节点插入，所以更新所有父节点的平衡因子最多需要$\log_2n$次操作——每一层一次。如果树失衡了，恢复平衡最多需要旋转两次。每次旋转的时间复杂度是$O(1)$，所以put操作的时间复杂度仍然是$O(\log_2n)$。 至此，我们已经实现了一棵可用的AVL树，不过还没有实现删除节点的功能。我们将删除节点及后续的更新和再平衡的实现留作练习。 映射实现总结本章和第5章介绍了可以用来实现映射这一抽象数据类型的多种数据结构，包括有序列表、散列表、二叉搜索树以及AVL树。表6-1总结了每个数据结构的性能。 表6-1 映射的不同实现间的性能对比 有序列表 散列表 二叉搜索树 AVL树 put $O(n)$ $O(1)$ $O(n)$ $O(\log_2n)$ get $O(\log_2n)$ $O(1)$ $O(n)$ $O(\log_2n)$ in $O(\log_2n)$ $O(1)$ $O(n)$ $O(\log_2n)$ del $O(n)$ $O(1)$ $O(n)$ $O(\log_2n)$ 小结本章介绍了树这一数据结构。有了树，我们可以写出很多有趣的算法。我们用树做了以下这些事。 用二叉树解析并计算表达式。 用二叉树实现映射。 用平衡二叉树（AVL树）实现映射。 用二叉树实现最小堆。 用最小堆实现优先级队列。 关键术语AVL树 边 层数 堆的有序性二叉堆 二叉树 二叉搜索树 父节点高度 根节点 后继节点 后序遍历节点 路径 前序遍历 树完全二叉树 兄弟节点 旋转 叶子节点映射 优先级队列 中序遍历 子节点子树 最小堆/最大堆 讨论题1.画出下列函数调用后的树结构。123456789101112&gt;&gt;&gt; r = BinaryTree(3)&gt;&gt;&gt; insertLeft(r, 4)[3, [4, [], []], []]&gt;&gt;&gt; insertLeft(r, 5)[3, [5, [4, [], []], []], []]&gt;&gt;&gt; insertRight(r, 6)[3, [5, [4, [], []], []], [6, [], []]]&gt;&gt;&gt; insertRight(r, 7)[3, [5, [4, [], []], []], [7, [], [6, [], []]]]&gt;&gt;&gt; setRootVal(r, 9)&gt;&gt;&gt; insertLeft(r, 11)[9, [11, [5, [4, [], []], []], []], [7, [], [6, [], []]]] 2.为表达式 (4 * 8) / 6 - 3 创建对应的表达式树。3.针对整数列表 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ，给出插入列表中整数得到的二叉搜索树。4.针对整数列表 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ，给出插入列表中整数得到的二叉搜索树。5.生成一个随机整数列表。给出插入列表中整数得到的二叉堆。6.将前一道题得到的列表作为 buildHeap 方法的参数，给出得到的二叉堆。以树和列表两种形式展示。7.画出按次序插入这些键之后的二叉搜索树：68、88、61、89、94、50、4、76、66、82。8.生成一个随机整数列表。画出插入列表中整数得到的二叉搜索树。9.针对整数列表 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ，给出插入列表中整数得到的二叉堆。10.针对整数列表 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ，给出插入列表中整数得到的二叉堆。11.考虑本章实现二叉树的两种方式。在实现为方法时，为什么必须在调用preorder前检查，而在实现为函数时，可以在调用内部检查？12.给出构建下面这棵二叉树所需的函数调用。13.对下面这棵树，实施恢复平衡所需的旋转操作。14.以图30作为出发点，推导出节点 D在更新后的平衡因子等式。 编程练习 1.扩展buildParseTree方法，使其能处理字符间没有空格的数学表达式。 2.修改buildParseTree和evaluate，使它们支持逻辑运算符（and、or、not）。注意，not是一元运算符，这会让代码有点复杂。 3.使用findSuccessor方法，写一个非递归的二叉搜索树中序遍历方法。 4.修改二叉搜索树的实现代码，从而实现线索二叉搜索树。为线索二叉搜索树写一个非递归的中序遍历方法。线索二叉搜索树为其中的每个节点都维护着指向后继节点的引用。 5.修改二叉搜索树的实现代码，以正确处理重复的键。也就是说，如果键已在树中，就替换有效载荷，而不是用同一个键插入一个新节点。 6.创建限定大小的二叉堆。也就是说，堆只保持n个最重要的元素。如果堆的大小超过了n，就会舍弃最不重要的元素。 7.整理printexp函数，去掉数字周围多余的括号。 8.使用buildHeap方法，针对列表写一个时间复杂度为$O(n\log n)$的排序函数。 9.写一个函数，以数学表达式解析树为参数，计算各变量的导数。 10.将二叉堆实现为最大堆。 11.使用BinaryHeap类，实现一个叫作PriorityQueue的新类。为PriorityQueue类实现构造方法，以及enqueue方法和dequeue方法。 12.实现AVL树的delete方法。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Python数据结构与算法分析（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章：算法分析]]></title>
    <url>%2F2020%2F01%2F16%2F%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章目标 理解算法分析的重要性。 能够使用大O符号描述执行时间。 针对Python列表和字典的常见操作，理解用大O符号表示的执行时间。 理解Python数据的实现如何影响算法分析。 理解如何对简单的Python程序进行基准测试。 何谓算法分析刚接触计算机科学的同学常常拿自己的程序和别人的做比较。你可能已经注意到了，计算机程序看起来很相似，尤其是简单的程序。这就产生了一个有趣的问题：当两个看上去不同的程序解决同一个问题时，会有优劣之分么？ 要回答这个问题，需要记住，程序和它所代表的算法是不同的。第1章说过，算法是为逐步解决问题而设计的一系列通用指令。给定某个输入，算法能得到对应的结果——算法就是解决问题的方法。程序则是用某种编程语言对算法编码。同一个算法可以对应许多程序，这取决于程序员和编程语言。 为了进一步说明算法和程序的区别，来看看代码清单2-1中的函数。该函数解决了一个常见的问题，即计算前n个整数之和。算法的思路是使用一个初始值为0的累加器变量，然后遍历n个整数，并将值加到累加器上。 代码清单2-1 计算前n个整数之和 123456def sumOfN(n): theSum = 0 for i in range(1, n+1): theSum = theSum + i return theSum 下面看看代码清单2-2。乍看会觉得有些奇怪，但是仔细观察后，你会发现这个函数所做的工作在本质上和前一个相同。之所以不能一眼看出来，是因为代码写得太差。没有用好的变量名提高可读性，而且在累加时还使用了一条多余的赋值语句。 代码清单2-2 计算前n个整数之和的另一种写法 1234567def foo(tom): fred = 0 for bill in range(1, tom+1): barney = bill fred = fred + barney return fred 前面提出过一个问题：程序是否有优劣之分？答案取决于你的标准。如果你关心的是可读性，那么sumOfN当然比foo更好。实际上，你可能已经在编程入门课上看过很多例子，毕竟入门课的一个目标就是帮你写出易读的程序。不过，除了可读性，本书还对描述算法感兴趣。（我们当然希望你继续向着写出易读代码的目标努力。） 算法分析关心的是基于所使用的计算资源比较算法。我们说甲算法比乙算法好，依据是甲算法有更高的资源利用率或使用更少的资源。从这个角度来看，上面两个函数其实差不多，它们本质上都利用同一个算法解决累加问题。 计算资源究竟指什么？思考这个问题很重要。有两种思考方式。一是考虑算法在解决问题时要占用的空间或内存。解决方案所需的空间总量一般由问题实例本身决定，但算法往往也会有特定的空间需求，后文会详细介绍。 另一种思考方式是根据算法执行所需的时间进行分析和比较。这个指标有时称作算法的执行时间或运行时间。要衡量sumOfN函数的执行时间，一个方法就是做基准分析。也就是说，我们会记录程序计算出结果所消耗的实际时间。在Python中，我们记录下函数就所处系统而言的开始时间和结束时间。time模块中有一个time函数，它会以秒为单位返回自指定时间点起到当前的系统时钟时间。在首尾各调用一次这个函数，计算差值，就可以得到以秒为单位的执行时间（多数情况下非常短）。 在代码清单2-3中，sumOfN函数在累加前后调用time。函数返回一个元组，由结果与计算时间（单位为秒）构成。如果调用5次，每次计算前10 000个整数之和，会得到如下结果。 12345678&gt;&gt;&gt; for i in range(5): print("Sum is %d required %10.7f seconds" % sumOfN(10000))Sum is 50005000 required 0.0018950 secondsSum is 50005000 required 0.0018620 secondsSum is 50005000 required 0.0019171 secondsSum is 50005000 required 0.0019162 secondsSum is 50005000 required 0.0019360 seconds&gt;&gt;&gt; 代码清单2-3 计算执行时间 123456789101112import timedef sumOfN2(n): start = time.time() theSum = 0 for i in range(1, n+1): theSum = theSum + i end = time.time() return theSum, end-start 可以看出，执行时间基本上是一致的，平均约为0.0019秒。如果计算前100 000个整数之和，又会如何呢？12345678&gt;&gt;&gt; for i in range(5): print("Sum is %d required %10.7f seconds" % sumOfN(100000))Sum is 5000050000 required 0.0199420 secondsSum is 5000050000 required 0.0180972 secondsSum is 5000050000 required 0.0194821 secondsSum is 5000050000 required 0.0178988 secondsSum is 5000050000 required 0.0188949 seconds&gt;&gt;&gt; 执行时间都变长了，但还是很一致，差不多都是之前的10倍。如果n取1 000 000，结果如下。12345678&gt;&gt;&gt; for i in range(5): print("Sum is %d required %10.7f seconds" % sumOfN(1000000))Sum is 500000500000 required 0.1948988 secondsSum is 500000500000 required 0.1850290 secondsSum is 500000500000 required 0.1809771 secondsSum is 500000500000 required 0.1729250 secondsSum is 500000500000 required 0.1646299 seconds&gt;&gt;&gt; 这次的平均执行时间差不多是前一个例子的10倍。 现在来看看代码清单2-4，其中给出了解决累加问题的新方法。函数sumOfN3使用以下公式计算前n个整数之和，不必使用循环。 \sum^n_{i=1}i=\frac{(n)(n+1)}{2} 代码清单2-4 不使用循环来计算前n个整数之和 12def sumOfN3(n): return (n*(n+1))/2 对sumOfN3做同样的基准测试，n取5个值（10 000、100 000、1 000 000、10 000 000和100 000 000），会得到以下结果。12345Sum is 50005000 required 0.00000095 secondsSum is 5000050000 required 0.00000191 secondsSum is 500000500000 required 0.00000095 secondsSum is 50000005000000 required 0.00000095 secondsSum is 5000000050000000 required 0.00000119 seconds 关于这个结果，有两点要注意。首先，记录的耗时比之前的例子都要短。其次，不管n取什么值，耗时都很稳定。看起来sumOfN3不太受整数数目的影响。 不过，以上基准测试结果的意义到底是什么呢？直觉上，循环方案看上去工作量更大，因为有些步骤重复。这好像是耗时更久的原因。而且，循环方案的耗时会随着n一起增长。然而，这里有个问题。如果在另一台计算机上运行这个函数，或用另一种编程语言来实现，很可能会得到不同的结果。如果计算机再旧些，sumOfN3的执行时间甚至更长。 所以，我们需要更好的方式来描述算法的执行时间。基准测试计算的是执行算法的实际时间。这不是一个有用的指标，因为它依赖于特定的计算机、程序、时间、编译器与编程语言。我们希望找到一个独立于程序或计算机的指标。这样的指标在评价算法方面会更有用，可以用来比较不同实现下的算法。 大O记法试图摆脱程序或计算机的影响而描述算法的效率时，量化算法的操作或步骤很重要。如果将每一步看成基本计算单位，那么可以将算法的执行时间描述成解决问题所需的步骤数。确定合适的基本计算单位很复杂，也依赖于算法的实现。 对于累加算法，计算总和所用的赋值语句的数目就是一个很好的基本计算单位。在sumOfN函数中，赋值语句数是1（theSum = 0）加上n（theSum = theSum + i的运行次数）。可以将其定义成函数$T$，令$T(n)=1+n$。参数n常被称作问题规模，可以将函数解读为“当问题规模为n时，解决问题所需的时间是$T(n)$，即需要$1+n$步”。 在前面给出的累加函数中，用累加次数定义问题规模是合理的。这样一来，就可以说处理前100 000个整数的问题规模比处理前1000个整数的大。鉴于此，前者花的时间要比后者长。接下来的目标就是揭示算法的执行时间如何随问题规模而变化。 计算机科学家将分析向前推进了一步。精确的步骤数并没有$T(n)$函数中起决定性作用的部分重要。也就是说，随着问题规模的增长，$T(n)$函数的某一部分会比其余部分增长得更快。最后比较的其实就是这一起决定性作用的部分。数量级函数描述的就是，当n增长时，$T(n)$增长最快的部分。数量级（order of magnitude）常被称作大$\boldsymbol{O}$记法（O指order），记作$O(f(n))$。它提供了步骤数的一个有用的近似方法。$f(n)$函数为$T(n)$函数中起决定性作用的部分提供了简单的表示。 对于$T(n)=1+n$，随着n越来越大，常数1对最终结果的影响越来越小。如果要给出$T(n)$的近似值，可以舍去1，直接说执行时间是$O(n)$。注意，1对于$T(n)$来说是重要的。但是随着n的增长，没有1也不会太影响近似值。 再举个例子，假设某算法的步骤数是$T(n)=5n^2+27n+1005$。当n很小时，比如说1或2，常数1005看起来是这个函数中起决定性作用的部分。然而，随n着增长，$n^2$变得更重要。实际上，当n很大时，另两项的作用对于最终结果来说就不显著了，因此可以忽略这两项，只关注$5n^2$。另外，当n变大时，系数5的作用也不显著了。因此可以说，函数$T(n)$的数量级是$f(n)=n^2$，或者直接说是$O(n^2)$。 累加的例子没有体现的一点是，算法的性能有时不仅依赖于问题规模，还依赖于数据值。对于这种算法，要用最坏情况、最好情况和普通情况来描述性能。最坏情况指的是某一个数据集会让算法的性能极差；另一个数据集可能会让同一个算法的性能极好（最好情况）。大部分情况下，算法的性能介于两个极端之间（普通情况）。计算机科学家要理解这些区别，以免被某个特例误导。 在学习算法的路上，常见的函数会反复出现，如表2-1所示。要判断哪一个才是$T(n)$的决定性部分，必须了解它们在n变大时彼此有多大差别。图2-1展示了表2-1中的各个函数。注意，当n较小时，这些函数之间的界限不是很明确，很难看出哪个起主导作用。随着n的增长，它们之间的差别就很明显了。 表2-1 常见的大$\boldsymbol{O}$函数 $\boldsymbol{f(n)}$ 名称 $1$ 常数 $\log n$ 对数 $n$ 线性 $n\log n$ 对数线性 $n^2$ 平方 $n^3$ 立方 $2^n$ 指数 图2-1 常见的大O函数 最后来看一个例子，假设有如代码清单2-5所示的一段Python代码。尽管这个程序没有做什么实际工作，但它对分析性能有一定的指导意义。 代码清单2-5 Python代码示例 123456789101112a = 5b = 6c = 10for i in range(n): for j in range(n): x = i * i y = j * j z = i * jfor k in range(n): w = a * k + 45 v = b * bd = 33 赋值操作的数量是4项之和：$T(n)=3+3n^2+2n+1$。第1项是常数3，对应起始部分的3条赋值语句。第2项是$3n^2$，因为有3条语句要在嵌套循环中重复$n^2$次。第3项是$2n$，因为两条语句要循环n遍。第4项是常数1，代表最后那条赋值语句。 T(n)=3+3n^2+2n+1=3n^2+2n+4很容易看出来，$n^2$起主导作用，所以这段代码的时间复杂度是$O(n^2)$。当n变大时，其他项以及主导项的系数都可以忽略。 图2-2展示了一部分常见的大O函数与前面讨论的$T(n)$函数的对比情况。注意，$T(n)$一开始比立方函数大。然而，随着n的增长，立方函数很快就超越了$T(n)$。 图2-2 对比$T(n)$函数与常见的大O函数 异序词检测示例要展示不同数量级的算法，一个好例子就是经典的异序词检测问题。如果一个字符串只是重排了另一个字符串的字符，那么这个字符串就是另一个的异序词，比如heart与earth，以及python与typhon。为了简化问题，假设要检查的两个字符串长度相同，并且都是由26个英文字母的小写形式组成的。我们的目标是编写一个布尔函数，它接受两个字符串，并能判断它们是否为异序词。 方案1：清点法 清点第1个字符串的每个字符，看看它们是否都出现在第2个字符串中。如果是，那么两个字符串必然是异序词。清点是通过用Python中的特殊值None取代字符来实现的。但是，因为Python中的字符串是不可修改的，所以先要将第2个字符串转换成列表。在字符列表中检查第1个字符串中的每个字符，如果找到了，就替换掉。代码清单2-6给出了这个函数。 代码清单2-6 实现清点方案 1234567891011121314151617181920212223def anagramSolution1(s1, s2): alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(alist) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOK 来分析这个算法。注意，对于s1中的n个字符，检查每一个时都要遍历s2中的n个字符。要匹配s1中的一个字符，列表中的n个位置都要被访问一次。因此，访问次数就成了从1到n的整数之和。这可以用以下公式来表示。 \sum^n_{i=1}i=\frac{n(n+1)}{2}=\frac{1}{2}n^2+\frac{1}{2}n当n变大时，起决定性作用的是$n^2$，而$\frac{1}{2}$可以忽略。所以，这个方案的时间复杂度是$O(n^2)$。 方案2：排序法 尽管s1与s2是不同的字符串，但只要由相同的字符构成，它们就是异序词。基于这一点，可以采用另一个方案。如果按照字母表顺序给字符排序，异序词得到的结果将是同一个字符串。代码清单2-7给出了这个方案的实现代码。在Python中，可以先将字符串转换为列表，然后使用内建的sort方法对列表排序。 代码清单2-7 实现排序方案 1234567891011121314151617def anagramSolution2(s1, s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 matches = True while pos &lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos = pos + 1 else: matches = False return matches 乍看之下，你可能会认为这个算法的时间复杂度是$O(n)$，因为在排序之后只需要遍历一次就可以比较$n$个字符。但是，调用两次sort方法不是没有代价。我们在后面会看到，排序的时间复杂度基本上是$O(n^2)$或$O(n\log n)$，所以排序操作起主导作用。也就是说，该算法和排序过程的数量级相同。 方案3：蛮力法 用蛮力解决问题的方法基本上就是穷尽所有的可能。就异序词检测问题而言，可以用s1中的字符生成所有可能的字符串，看看s2是否在其中。但这个方法有个难处。用s1中的字符生成所有可能的字符串时，第1个字符有n种可能，第2个字符有$n-1$种可能，第3个字符有$n-2$种可能，依此类推。字符串的总数是$n*(n-1)*(n-2)*\cdots*3*2*1$，即$n!$。也许有些字符串会重复，但程序无法预见，所以肯定会生成$n!$个字符串 n当较大时，$n!$增长得比$2^n$还要快。实际上，如果s1有20个字符，那么字符串的个数就是$20!=2~432~902~008~176~640~000$。假设每秒处理一个，处理完整个列表要花77 146 816 596年。这可不是个好方案。 方案4：计数法 最后一个方案基于这样一个事实：两个异序词有同样数目的a、同样数目的b、同样数目的c，等等。要判断两个字符串是否为异序词，先数一下每个字符出现的次数。因为字符可能有26种，所以使用26个计数器，对应每个字符。每遇到一个字符，就将对应的计数器加1。最后，如果两个计数器列表相同，那么两个字符串肯定是异序词。代码清单2-8给出了这个方案的实现代码。 代码清单2-8 实现计数方案 123456789101112131415161718192021def anagramSolution4(s1, s2): c1 = [0] * 26 c2 = [0] * 26 for i in range(len(s1)): pos = ord(s1[i]) - ord('a') c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i]) - ord('a') c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j &lt; 26 and stillOK: if c1[j] == c2[j]: j = j + 1 else: stillOK = False return stillOK 这个方案也有循环。但不同于方案1，这个方案的循环没有嵌套。前两个计数循环都是n阶的。第3个循环比较两个列表，由于可能有26种字符，因此会循环26次。全部加起来，得到总步骤数$T(n)=2n+26$，即$O(n)$。我们找到了解决异序词检测问题的线性阶算法。 结束这个例子的讲解之前，需要聊聊空间需求。尽管方案4的执行时间是线性的，它还是要用额外的空间来存储计数器。也就是说，这个算法用空间换来了时间。 这种情形很常见。很多时候，都需要在时间和空间之间进行权衡。本例中，额外使用的空间并不大。不过，如果有数以百万计的字符，那就有问题了。面对多种算法和具体的问题，计算机科学家需要决定如何利用好计算资源。 Python数据结构的性能你对大O记法及其不同函数的差别已经有了大致的了解。本节的目标是针对Python的列表和字典介绍如何用大O记法描述操作的性能。我们会做一些实验，展示在每个数据结构上做某些操作时的损耗与收益。理解这些Python数据结构的效率很重要，因为它们是本书用来实现其他数据结构的基石。本节不会解释性能优劣的原因。在后续章节中，你会看到列表和字典的一些可能的实现，以及为何性能取决于实现。 列表在实现列表数据结构时，Python的设计师有许多选择，每一个选择都会影响操作的性能。为了做出正确的选择，他们考虑了列表最常见的用法，并据此优化列表的实现，以使最常用的操作非常快。当然，他们也尽力使不常用的操作也很快，但在需要权衡时，往往会牺牲低频操作的性能。 两个常见操作是索引和给某个位置赋值。无论列表多长，这两个操作所花的时间应该恒定。像这种与列表长度无关的操作就是常数阶的。 另一个常见的操作是加长列表。有两种方式：要么采用追加方法，要么执行连接操作。追加方法是常数阶的。如果待连接列表的长度为k，那么连接操作的时间复杂度就是$O(k)$。知道这一点很重要，因为它能帮你选择正确的工具，使程序更高效。 假设要从0开始生成含有n个数的列表，来看看4种生成方式。首先，用for循环通过连接操作创建列表；其次，采用追加方法；再次，使用列表解析式；最后，用列表构造器调用range函数（这可能是最容易想到的方式）。代码清单2-9给出了4种方式的代码。假设代码保存在文件listfuns.py中。 代码清单2-9 生成列表的4种方式 123456789101112131415def test1(): l = [] for i in range(1000): l = l + [i]def test2(): l = [] for i in range(1000): l.append(i)def test3(): l = [i for i in range(1000)]def test4(): l = list(range(1000)) 要得到每个函数的执行时间，需要用到Python的timeit模块。该模块使Python开发人员能够在一致的环境下运行函数，并且在多种操作系统下使用尽可能相似的机制，以实现跨平台计时。 要使用timeit模块，首先创建一个Timer对象，其参数是两条Python语句。第1个参数是要为之计时的Python语句；第2个参数是建立测试的语句。timeit模块会统计多次执行语句要用多久。默认情况下，timeit会执行100万次语句，并在完成后返回一个浮点数格式的秒数。不过，既然这是执行100万次所用的秒数，就可以把结果视作执行1次所用的微秒数。此外，可以给timeit传入参数number，以指定语句的执行次数。下面的例子展示了测试函数各运行1000次所花的时间。 12345678910111213141516t1 = Timer("test1()", "from __main__ import test1")print("concat ", t1.timeit(number=1000), "milliseconds")t2 = Timer("test2()", "from __main__ import test2")print("append ", t2.timeit(number=1000), "milliseconds")t3 = Timer("test3()", "from __main__ import test3")print("comprehension ", t3.timeit(number=1000), "milliseconds")t4 = Timer("test4()", "from __main__ import test4")print("list range ", t4.timeit(number=1000), "milliseconds")# concat 6.54352807999 milliseconds# append 0.306292057037 milliseconds# comprehension 0.147661924362 milliseconds# list range 0.0655000209808 milliseconds 在本例中，计时的语句是对test1()、test2()等的函数调用。你也许会觉得建立测试的语句有些奇怪，所以我们仔细研究一下。你可能已经熟悉from和import，但它们通常在Python程序文件的开头使用。本例中，from __main__ import test1将test1函数从__main__命名空间导入到timeit设置计时的命名空间。timeit模块这么做，是为了在一个干净的环境中运行计时测试，以免某些变量以某种意外的方式干扰函数的性能。 实验结果清楚地表明，0.30毫秒的追加操作远快于6.54毫秒的连接操作。实验也测试了另两种列表创建操作：使用列表解析式，以及使用列表构造器调用range。有趣的是，与用for循环进行追加操作相比，使用列表解析式几乎快一倍。 关于这个小实验要说明的最后一点是，执行时间其实包含了调用测试函数的额外开销，但可以假设4种情形的函数调用开销相同，所以对比操作还是有意义的。鉴于此，说连接操作花了6.54毫秒不太准确，应该说用于连接操作的测试函数花了6.54毫秒。可以做个练习，测一下调用空函数的时间，然后从之前得到的数字中减去。 知道如何衡量性能之后，可以对照表2-2，看看基本列表操作的大O效率。仔细考虑之后，你可能会对pop的两种效率有疑问。在列表末尾调用pop时，操作是常数阶的，在列表头一个元素或中间某处调用pop时，则是阶的。原因在于Python对列表的实现方式。在Python中，从列表头拿走一个元素，其他元素都要向列表头挪一位。你可能觉得这个做法有点傻，但再看看表2-2，你会明白这种实现保证了索引操作为常数阶。Python的实现者认为这是不错的取舍决策。 表2-2 Python列表操作的大$\boldsymbol{O}$效率 操作 大$\boldsymbol{O}$效率 索引 $O(1)$ 索引赋值 $O(1)$ 追加 $O(1)$ pop() $O(1)$ pop(i) $O(n)$ insert(i, item) $O(n)$ 删除 $O(n)$ 遍历 $O(n)$ 包含 $O(n)$ 切片 $O(k)$ 删除切片 $O(n)$ 设置切片 $O(n+k)$ 反转 $O(n)$ 连接 $O(k)$ 排序 $O(n\log n)$ 乘法 $O(nk)$ 为了展示pop()和pop(i)的性能差异，我们使用timeit模块做另一个实验。实验目标是针对一个长度已知的列表，分别从列表头和列表尾弹出一个元素。我们也想衡量不同长度下的执行时间。预期结果是，从列表尾弹出元素的时间是恒定的，而从列表头弹出元素的时间会随着列表变长而增加。 代码清单2-10是实验代码。可以看到，从列表尾弹出元素花了0.0003毫秒，从列表头弹出花了4.8214毫秒。对于含有200万个元素的列表来说，后者是前者的16 000倍。 有两点需要说明。首先是from __main__ import x语句。尽管没有定义一个函数，但是我们仍然希望能在测试中使用列表对象x。这个办法允许我们只对pop语句计时，从而准确地获得这一个操作的耗时。其次，因为计时重复了1000次，所以列表每次循环都少一个元素。不过，由于列表的初始长度是200万，因此对于整体长度来说，只减少了0.05%。 代码清单2-10 pop的性能分析 12345678910popzero = timeit.Timer("x.pop(0)", "from __main__ import x")popend = timeit.Timer("x.pop()", "from __main__ import x")x = list(range(2000000))popzero.timeit(number=1000)# 4.8213560581207275x = list(range(2000000))popend.timeit(number=1000)# 0.0003161430358886719 虽然测试结果说明pop(0)确实比pop()慢，但是并没有证明pop(0)的时间复杂度是$O(n)$，也没有证明pop()的是$O(1)$。要证明这一点，需要看看两个操作在各个列表长度下的性能。代码清单2-11实现了这个测试。 代码清单2-11 比较pop(0)和pop()在不同列表长度下的性能 123456789popzero = Timer("x.pop(0)", "from __main__ import x")popend = Timer("x.pop()", "from __main__ import x")print("pop(0) pop()")for i in range(1000000, 100000001, 1000000): x = list(range(i)) pt = popend.timeit(number=1000) x = list(range(i)) pz = popzero.timeit(number=1000) print("%15.5f, %15.5f" % (pz, pt)) 图2-3展示了实验结果。可以看出，列表越长，pop(0)的耗时也随之变长，而pop()的耗时很稳定。这刚好符合$O(n)$和$O(1)$的特征。 图2-3 对比pop(0)和pop()的性能 实验会有一些误差。因为用来测量的计算机运行着其他进程，所以可能拖慢代码的速度。因此，尽管我们尽力减少计算机所做的其他工作，测出的时间仍然会有些许变化。这也是测试1000遍的原因，从统计角度来说，收集足够多的信息有助于得到可靠的结果。 字典Python的第二大数据结构就是字典。你可能还记得，字典不同于列表的地方在于，可以通过键——而不是位置——访问元素。你会在后文中发现，实现字典有许多方法。现在最重要的是，知道字典的取值操作和赋值操作都是常数阶。另一个重要的字典操作就是包含（检查某个键是否在字典中），它也是常数阶。表2-3总结了所有字典操作的大O效率。要注意，表中给出的效率针对的是普通情况。在某些特殊情况下，包含、取值、赋值等操作的时间复杂度可能变成$O(n)$。后文在讨论不同的字典实现方式时会详细说明。 表2-3 Python字典操作的大$\boldsymbol{O}$效率 操作 大$\boldsymbol{O}$效率 复制 $O(n)$ 取值 $O(1)$ 赋值 $O(1)$ 删除 $O(1)$ 包含 $O(1)$ 遍历 $O(n)$ 最后一个性能实验会比较列表和字典的包含操作，并验证列表的包含操作是$O(n)$，而字典的是$O(1)$。实验很简单，首先创建一个包含一些数的列表，然后随机取一些数，看看它们是否在列表中。如果表2-2给出的效率是正确的，那么随着列表变长，判断一个数是否在列表中所花的时间也就越长。 对于以数字为键的字典，重复上述实验。我们会看到，判断数字是否在字典中的操作，不仅快得多，而且当字典变大时，耗时基本不变。 代码清单2-12实现了这个对比实验。注意，我们进行的是完全相同的操作。不同点在于，第7行的x是列表，第9行的x则是字典。 代码清单2-12 比较列表和字典的包含操作 12345678910import timeitimport randomfor i in range(10000, 1000001, 20000): t = timeit.Timer("random.randrange(%d) in x" % i, "from __main__ import random, x") x = list(range(i)) lst_time = t.timeit(number=1000) x = &#123;j:None for j in range(i)&#125; d_time = t.timeit(number=1000) print("%d, %10.3f, %10.3f" % (i, lst_time, d_time)) 图2-4展示了运行结果。可以看出，字典一直更快。对于元素最少的情况（10 000），字典的速度是列表的89.4倍。对于元素最多的情况（990 000），字典的速度是列表的11 603倍！还可以看出，随着规模增加，列表的包含操作在耗时上的增长是线性的，这符合$O(n)$。对于字典来说，即使规模增加，包含操作的耗时也是恒定的。实际上，当字典有10 000个元素时，包含操作的耗时是0.004毫秒，当有990 000个元素时，耗时还是0.004毫秒。 图2-4 比较列表和字典的包含操作 小结 算法分析是一种独立于实现的算法度量方法。 大O记法使得算法可以根据随问题规模增长而起主导作用的部分进行归类。 关键术语大记法 对数 对数线性蛮力法 平方 普通情况清点法 时间复杂度 数量级线性 指数 最坏情况 讨论题给出以下代码的大O性能。123for i in range(n): for j in range(n): k = 2 + 2 给出以下代码的大O性能。12for i in range(n): k = 2 + 2 给出以下代码的大O性能。1234i = nwhile i &gt; 0: k = 2 + 2 i = i // 2 给出以下代码的大O性能。1234for i in range(n): for j in range(n): for k in range(n): k = 2 + 2 给出以下代码的大O性能。1234i = nwhile i &gt; 0: k = 2 + 2 i = i // 2 给出以下代码的大O性能。123456for i in range(n): k = 2 + 2for j in range(n): k = 2 + 2for k in range(n): k = 2 + 2 编程练习 1.设计一个实验，证明列表的索引操作为常数阶。 2.设计一个实验，证明字典的取值操作和赋值操作为常数阶。 3.设计一个实验，针对列表和字典比较del操作的性能。 4.给定一个数字列表，其中的数字随机排列，编写一个线性阶算法，找出第k小的元素，并解释为何该算法的阶是线性的。 5.针对前一个练习，能将算法的时间复杂度优化到$O(n\log n)$吗？]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Python数据结构与算法分析（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合Laravel Facade看外观模式怎么用？]]></title>
    <url>%2F2020%2F01%2F14%2F%E7%BB%93%E5%90%88Laravel-Facade%E7%9C%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是外观模式？ 当独立子系统的开发完成后，如果两个系统是客户—供应商关系，也就是说其中一个子系统（客户）需要使用另一个子系统（供应商）提供的服务时，我们可以通过外观模式来对客户子系统隐藏调用供应商系统的复杂性，客户端只需通过facade调用相应的服务而无需涉及供应商具体的服务调用方法。下面通过laravel中的facade来说明: 在laravel中，我们经常通过facade来实现全局调用某个方法而不需要实例化一个对象。通过查看源码可以知道，所有的Facade都是继承自同一个抽象父类Illuminate\Support\Facades\Facade。 当我们调用Auth::guard(‘customer’)来返回一个guard实例的时候，只需要在调用这个方法的所在脚本写上use Illuminate\Support\Facades\Auth;就可以了，而当我们去查看Illuminate\Support\Facades\Auth的具体定义的时候，我们就会发现，这种调用都是基于php的魔术方法——__callstatic()。 \vendor\laravel\framework\src\Illuminate\Support\Facades.php 12345678910public static function __callStatic($method, $args)&#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException('A facade root has not been set.'); &#125; return $instance-&gt;$method(...$args);&#125; 从代码中可以看出，最关键的一句就是$instance=static::getFacadeRoot();因为调用的方法和参数我们都能通过__callstatic获取，关键是我们如何获取到一个能执行这个方法的正确的对象，让我们继续往下扒。 1234public static function getFacadeRoot()&#123; return static::resolveFacadeInstance(static::getFacadeAccessor());&#125; 原来底层是你，resolveFacadeInstance(static::getFacadeAccessor())不管，继续扒。1234protected static function getFacadeAccessor()&#123; throw new RuntimeException('Facade does not implement getFacadeAccessor method.');&#125; static::getFacadeAccessor()为什么直接抛出错误，搞错了？不对，刚才好像在哪见过？？没错，每个Facade都会对这个方法进行重写，如果没有重写就会抛出错误，例如在Illuminate\Support\Facades\Auth中的实现是：1234protected static function getFacadeAccessor()&#123; return 'auth';&#125; 好了，看来接下来这个才是最核心的resolveFacadeInstance($name)123456789101112131415 protected static function resolveFacadeInstance($name)&#123; // 判断传入参数是否是对象，是则直接返回，我猜laravel框架告诉我们在定义自己的facade的时候可以直接在getFacadeAccessor返回一个对象 if (is_object($name)) &#123; return $name; &#125; // 不是对象的话,判断是否已经实例化过这个对象，是的话就把之前实例化后保存的对象拿去使 if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; // 没有?!那只能返回新的对象并保存到$resolvedInstance中方便下次用了 return static::$resolvedInstance[$name] = static::$app[$name];&#125; 这里是$app是laravel的ioc容器。 通过上面的例子可以看出，laravel通过外观模式对外提供auth服务，向客户端隐藏了具体的操作，实际底层是调用了某个具体的执行者来提供该项服务，这样客户端就无需知道相关细节，就可以使用开箱即用的服务。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP性能优化利器：生成器yield理解]]></title>
    <url>%2F2020%2F01%2F14%2FPHP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8%EF%BC%9A%E7%94%9F%E6%88%90%E5%99%A8yield%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 使用yield还需要再循环一次，怎么理解？ yield和两个foreach在一起。怎么理解？ 如果是做Python或者C#的小伙伴，对于生成器应该不陌生。但很多PHP开发者或许都不知道生成器这个功能，可能是因为生成器是PHP5.5.0才引入的功能，也可以是生成器作用不是很明显。但是，生成器功能的确非常有用。 优点 生成器会对PHP应用的性能有非常大的影响。 PHP代码运行时节省大量的内存。 比较适合计算大量的数据。 那么，这些神奇的功能究竟是如何做到的？我们先来举个例子。 概念引入首先，放下生成器概念的包袱，来看一个简单的PHP函数： 1234567891011function createRange($number)&#123; $data = []; for($i = 0; $i &lt; $number; $i++) &#123; $data[] = time(); &#125; return $data;&#125; 这是一个非常常见的PHP函数，我们在处理一些数组的时候经常会使用。这里的代码也非常简单： 1.我们创建一个函数。 2.函数内包含一个for循环，我们循环的把当前时间放到$data里面。 3.for循环执行完毕，把$data返回出去。 再写一个函数，把这个函数的返回值循环打印出来： 1234567$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1); // 这里停顿1秒，我们后续有用 echo $value.'&lt;br/&gt;';&#125; 我们在浏览器里面看一下运行结果： 这里非常完美，没有任何问题。（当然sleep(1)效果你们看不出来） 生成器我们注意到，在调用函数createRange的时候给$number的传值是10，一个很小的数字。假设，现在传递一个值10000000（1000万）。 那么，在函数createRange里面，for循环就需要执行1000万次。且有1000万个值被放到$data里面，而$data数组在是被放在内存内。所以，在调用函数时候会占用大量内存。 这里，生成器就可以大显身手了。 创建生成器我们直接修改代码，你们注意观察： 1234567function createRange($number)&#123; for($i = 0; $i &lt; $number; $i++) &#123; yield time(); &#125;&#125; 看下这段和刚刚很像的代码，我们删除了数组$data，而且也没有返回任何内容，而是在time()之前使用了一个关键字yield。 使用生成器我们再运行一下第二段代码： 1234567$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1); echo $value.'&lt;br /&gt;';&#125; 我们奇迹般的发现了，输出的值和第一次没有使用生成器的不一样。这里的值（时间戳）中间间隔了1秒。 这里的间隔一秒其实就是sleep(1)造成的后果。但是为什么第一次没有间隔？那是因为： 未使用生成器时：createRange函数内的for循环结果被很快放到$data中，并且立即返回。所以，foreach循环的是一个固定的数组。 使用生成器时：createRange的值不是一次性快速生成，而是依赖于foreach循环。foreach循环一次，for执行一次。 到这里，你应该对生成器有点儿头绪。 深入理解生成器代码剖析 下面我们来对于刚刚的代码进行剖析。 123456789101112131415function createRange($number)&#123; for($i = 0; $i &lt; $number; $i++) &#123; yield time(); &#125;&#125;$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1); echo $value.'&lt;br /&gt;';&#125; 我们来还原一下代码执行过程。 1.首先调用createRange函数，传入参数10，但是for值执行了一次然后停止了，并且告诉foreach第一次循环可以用的值。 2.foreach开始对$result循环，进来首先sleep(1)，然后开始使用for给的一个值执行输出。 3.foreach准备第二次循环，开始第二次循环之前，它向for循环又请求了一次。 4.for循环于是又执行了一次，将生成的时间戳告诉foreach. 5.foreach拿到第二个值，并且输出。由于foreach中sleep(1)，所以，for循环延迟了1秒生成当前时间。 所以，整个代码执行中，始终只有一个记录值参与循环，内存中也只有一条信息。 无论开始传入的$number有多大，由于并不会立即生成所有结果集，所以内存始终是一条循环的值。 概念理解 到这里，你应该已经大概理解什么是生成器了。下面我们来说下生成器原理。 首先明确一个概念：生成器yield关键字不是返回值，他的专业术语叫产出值，只是生成一个值 那么代码中foreach循环的是什么？其实是PHP在使用生成器的时候，会返回一个Generator类的对象。foreach可以对该对象进行迭代，每一次迭代，PHP会通过Generator 实例计算出下一次需要迭代的值。这样foreach就知道下一次需要迭代的值了。 而且，在运行中for循环执行后，会立即停止。等待foreach下次循环时候再次和for索要下次的值的时候，循环才会再执行一次，然后立即再次停止。直到不满足条件不执行结束。 实际开发应用很多PHP开发者不了解生成器，其实主要是不了解应用领域。那么，生成器在实际开发中有哪些应用？ 读取超大文件PHP开发很多时候都要读取大文件，比如csv文件、text文件，或者一些日志文件。这些文件如果很大，比如5个G。这时，直接一次性把所有的内容读取到内存中计算不太现实。 这里生成器就可以派上用场啦。简单看个例子：读取text文件。 我们创建一个text文本文档，并在其中输入几行文字，示范读取。 12345678910111213141516171819&lt;?phpheader("content-type:text/html;charset=utf-8");function readTxt()&#123; # code... $handle = fopen("./test.txt", 'rb'); while (feof($handle)===false) &#123; # code... yield fgets($handle); &#125; fclose($handle);&#125;foreach (readTxt() as $key =&gt; $value) &#123; # code... echo $value.'&lt;br /&gt;';&#125; 通过上图的输出结果我们可以看出代码完全正常。 但是，背后的代码执行规则却一点儿也不一样。使用生成器读取文件，第一次读取了第一行，第二次读取了第二行，以此类推，每次被加载到内存中的文字只有一行，大大的减小了内存的使用。 这样，即使读取上G的文本也不用担心，完全可以像读取很小文件一样编写代码。 百万级别的访问量yield生成器是php5.5之后出现的，yield提供了一种更容易的方法来实现简单的迭代对象，相比较定义类实现Iterator接口的方式，性能开销和复杂性大大降低。 yield生成器允许你在foreach代码块中写代码来迭代一组数据而不需要在内存中创建一个数组。 使用示例：123456789101112131415161718192021222324252627/** * 计算平方数列 * @param $start * @param $stop * @return Generator */ function squares($start, $stop) &#123; if ($start &lt; $stop) &#123; for ($i = $start; $i &lt;= $stop; $i++) &#123; yield $i =&gt; $i * $i; &#125; &#125; else &#123; for ($i = $start; $i &gt;= $stop; $i--) &#123; yield $i =&gt; $i * $i; //迭代生成数组： 键=》值 &#125; &#125; &#125; foreach (squares(3, 15) as $n =&gt; $square) &#123; echo $n . ‘squared is‘ . $square . ‘&lt;br&gt;‘; &#125; 输出：12343 squared is 9 4 squared is 16 5 squared is 25 ... 示例2： 1234567891011121314151617181920212223242526272829303132333435363738394041//对某一数组进行加权处理 $numbers = array(‘nike‘ =&gt; 200, ‘jordan‘ =&gt; 500, ‘adiads‘ =&gt; 800); //通常方法，如果是百万级别的访问量，这种方法会占用极大内存 function rand_weight($numbers) &#123; $total = 0; foreach ($numbers as $number =&gt; $weight) &#123; $total += $weight; $distribution[$number] = $total; &#125; $rand = mt_rand(0, $total-1); foreach ($distribution as $num =&gt; $weight) &#123; if ($rand &lt; $weight) return $num; &#125; &#125; //改用yield生成器 function mt_rand_weight($numbers) &#123; $total = 0; foreach ($numbers as $number =&gt; $weight) &#123; $total += $weight; yield $number =&gt; $total; &#125; &#125; function mt_rand_generator($numbers) &#123; $total = array_sum($numbers); $rand = mt_rand(0, $total -1); foreach (mt_rand_weight($numbers) as $num =&gt; $weight) &#123; if ($rand &lt; $weight) return $num; &#125; &#125; Laravel + ElasticSearch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 迁移用户数据到es * @param $container * @param $logger * @param $type */public static function syncUsersToEs($container, $logger, $type)&#123; list($builder, $currentTime) = [ $container-&gt;get(ClientBuilderFactory::class)-&gt;create(), time(), ]; $client = $builder-&gt;setHosts([env('ES_HOSTS', '')])-&gt;build(); $esFun = function ($data, $client) use ($type) &#123; $list = []; foreach ($data as $k =&gt; $va) &#123; if (count($list) &gt;= 500) &#123; $client-&gt;bulk([ 'index' =&gt; Users::ES_INDEX_NAME, 'type' =&gt; 'users', 'body' =&gt; $list ]); $list = []; &#125; else &#123; switch ($type) &#123; // 更新基础数据字段的值 case 'update': array_push( $list, [ 'update' =&gt; [ '_id' =&gt; (int)$va['id'], '_index' =&gt; Users::ES_INDEX_NAME, '_type' =&gt; '_doc', ] ], ['doc' =&gt; $va] ); break; // 把对应的新增用户注入es case 'create': array_push( $list, [ 'create' =&gt; [ '_id' =&gt; (int)$va['id'], '_index' =&gt; Users::ES_INDEX_NAME, '_type' =&gt; '_doc', ] ], $va ); break; &#125; &#125; &#125; if (!empty($list)) &#123; $res = $client-&gt;bulk(['index' =&gt; Videos::ES_INDEX_NAME, 'type' =&gt; 'sv_videos', 'body' =&gt; $list]); &#125; unset($list); &#125;; switch ($type) &#123; // 添加新用户到es中 case 'create': Users::query() -&gt;select(['id', 'name', 'avatar', 'gender', 'mobile']) -&gt;where([ ['created_at', '&gt;=', date('Y-m-d H:i:s', $currentTime - 3600)] ]) -&gt;chunkById(1000, function ($results) use ($client, $esFun) &#123; // 迭代器数据 $data = function () use ($results) &#123; foreach ($results-&gt;toArray() as $v) &#123; yield [ 'id' =&gt; (int)$v['id'], 'name' =&gt; (string)$v['name'], 'avatar' =&gt; (string)$v['avatar'], 'gender' =&gt; (int)$v['gender'], 'mobile' =&gt; (string)$v['mobile'], ]; &#125; &#125;; $esFun($data(), $client); &#125;); break; // 去更新用户搜索的基础数据 case 'update': Users::query() -&gt;select(['id', 'name', 'avatar', 'gender', 'mobile']) -&gt;where([ ['updated_at', '&gt;=', date('Y-m-d H:i:s', $currentTime - 3600)] ]) -&gt;chunkById(1000, function ($results) use ($client, $esFun) &#123; // 迭代器数据 $data = function () use ($results) &#123; foreach ($results-&gt;toArray() as $v) &#123; yield [ 'id' =&gt; (int)$v['id'], 'name' =&gt; (string)$v['name'], 'avatar' =&gt; (string)$v['avatar'], 'gender' =&gt; (int)$v['gender'], 'mobile' =&gt; (string)$v['mobile'], ]; &#125; &#125;; $esFun($data(), $client); &#125;); break; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 树]]></title>
    <url>%2F2020%2F01%2F08%2F%E7%AC%AC6%E7%AB%A0-%E6%A0%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库分片（Database Sharding）详解]]></title>
    <url>%2F2020%2F01%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87%EF%BC%88Database-Sharding%EF%BC%89%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 导言任何看到显著增长的应用程序或网站，最终都需要进行扩展，以适应流量的增加。以确保数据安全性和完整性的方式进行扩展，对于数据驱动的应用程序和网站来说十分重要。人们可能很难预测某个网站或应用程序的流行程度，也很难预测这种流行程度会持续多久，这就是为什么有些机构选择“可动态扩展的”数据库架构的原因。 在这篇概念性文章中，我们将讨论一种“可动态扩展的”数据库架构：分片数据库。近年来，分片（Sharding）一直受到很多关注，但许多人并没有清楚地了解它是什么，或者对数据库进行分片可能有意义的场景。我们将讨论分片是什么，它的一些主要优点和缺点，以及一些常见的分片方法。 什么是分片？分片（Sharding）是一种与水平切分（horizontal partitioning）相关的数据库架构模式——将一个表里面的行，分成多个不同的表的做法（称为分区）。每个区都具有相同的模式和列，但每个表有完全不同的行。同样，每个分区中保存的数据都是唯一的，并且与其他分区中保存的数据无关。 从水平切分（horizontal partitioning）与垂直切分（vertical partitioning）的关系，可能会有所帮助。在垂直切分表中，所有的列被分离出来，并放入新的不同的表中。每个垂直切分内的数据，独立于所有其他分区中的数据，并且每个分区都包含不同的行和列。下图说明了如何在水平和垂直方向上对表进行分区： 分片（Sharding）将一个数据分成两个或多个较小的块，称为逻辑分片（logical shards）。然后，逻辑分片（logical shards）分布在单独的数据库节点上，称为物理分片（physical shards）。物理分片（physical shards）可以容纳多个逻辑分片（logical shards）。尽管如此，所有分片中保存的数据，共同代表整个逻辑数据集。 数据库分片（Database shards）是无共享架构的一个例子。这意味着分片是自治的：分片间不共享任何相同的数据或服务器资源。但是在某些情况下，将某些表复制到每个分片中作为参考表是有意义的。例如，假设某个应用程序的数据库依赖于重量测量的固定转换率。通过将包含必要转换率数据的表复制到每个分片中，有助于确保查询所需的所有数据都保存在每个分片中。 通常，分片（Sharding）在应用程序级别进行实现。这意味着应用程序包含“要向哪个分片发送读和写”的代码。但是，某些数据库管理系统内置了分片功能，允许您直接在数据库级别实现分片。 以上是分片（Sharding）的概述，接下来让我们来看一下，这种数据库架构的优点和缺点。 分片的好处数据库分片的主要吸引力在于，它可以帮助促进水平扩展（horizontal scaling），也称为向外扩展（scaling out）。水平扩展是将更多的机器添加到现有堆栈中，以分散负载，允许更多的流量和更快的处理。这通常与垂直扩展（vertical scaling）形成对比，垂直扩展也称为向上扩展（scaling up），是指升级现有服务器的硬件，通常是添加更多内存或CPU。 让一个关系数据库在单个机器上运行，并按需升级其服务器资源进行向上扩展是相对简单的。但最终，任何非分布式数据库在存储和计算能力方面都会受到限制，因此可以自由地水平扩展数据库，会使您的架构更加灵活且适应性强。 选择分片数据库架构的另一个原因，是为了加速查询响应的时间。当您对尚未分片的数据库提交查询时，必须先搜索您查询的表中的每一行，然后才能找到您要查找的结果集。对于具有大型单片数据库的应用程序，查询可能变得极其缓慢。但是，通过将一个表分成多个，查询过程会遍历更少的行，并且返回结果集的速度要快得多。 分片还可以通过减少宕机（outage）的影响，使应用程序更稳定可靠。如果您的应用程序或网站依赖于未分片的数据库，则宕机可能会导致整个应用程序不可用。但是，对于分片数据库，宕机可能只会影响单个分片。即使这可能使某些用户无法使用应用程序或网站部分功能，但仍会低于整个数据库崩溃带来的影响。 分片的缺点虽然对数据库进行分片可以使扩展更容易并提高性能，但它也可能会带来某些限制。在这里，我们将讨论其中的一些限制，以及为什么这些限制会让我们避免对数据库全部分片。 正确实现分片数据库架构，是十分复杂的，所以这是分片遇到的第一个困难。如果操作不正确，则分片过程可能会导致数据丢失或表损坏，这是一个很大的风险。但是，即使正确地进行了分片，也可能对团队的工作流程产生重大影响。与从单个入口点访问和管理数据不同，用户必须跨多个分片位置管理数据，这可能会让某些团队存在工作混乱。 在对数据库进行分片后，用户有时会遇到的一个问题是分片最终会变得不平衡。举例来说，假设您有一个数据库，其中有两个单独的分片，一个用于姓氏以字母A到M开头的客户，另一个用于名字以字母N到Z开头的客户。但是，您的应用程序为姓氏以字母G开头的人提供了过多的服务。因此，A-M分片逐渐累积的数据比N-Z分片要多，这会导致应用程序速度变慢，并对很大一部分用户造成影响。A-M分片已成为所谓的数据热点。在这种情况下，数据库分片的任何好处都被慢速和崩溃抵消了。数据库可能需要修复和重新分片，才能实现更均匀的数据分布。 另一个主要缺点是，一旦对数据库进行了分片，就很难将其恢复到未分片的架构。分片前数据库的备份数据，都无法与分片后写入的数据合并。因此，重建原始的非分片架构，需要将新的分区数据与旧备份合并，或者将分区的数据库转换回单个数据库，这两种方法都是昂贵且耗时的。 要考虑的最后一个缺点是，并不是每个数据库引擎本身都支持分片。例如，尽管可以手动分片PostgreSQL数据库，但PostgreSQL本身并不包括自动分片功能。有许多Postgres分支包括自动分片功能，但这些分支通常落后于最新的PostgreSQL版本，并且缺乏某些其他的功能特性。一些专业的数据库技术——如MySQL Cluster或某些数据库即服务产品（如MongoDB Atlas）确实包含自动分片功能，但这些数据库管理系统的普通版本却并不包含。因此，分片通常需要“自己动手”的方法。这意味着通常很难找到有关分片或故障排除技巧的文档。 现在我们已经介绍了一些分片的缺点和好处，我们将讨论一些分片数据库的不同架构。 一旦你决定对数据库进行分片，接下来你需要弄清楚的是如何进行分片。在运行查询或将传入的数据分发到分片表或数据库时，关键是要将其分配到正确的分片。否则，它可能导致数据丢失或查询速度缓慢。在本节中，我们将介绍一些常见的分片架构，每个架构使用稍微不同的流程来跨分片分发数据。 基于键的分片 为了确保数据记录以正确的方式被放置在正确的分片中，哈希函数中输入的值都应该来自同一列。此列称为分片键。简单来说，分片键与主键类似，因为它们都是列，用于为各个行建立唯一标识符。一般来说，分片键应该是静态的，这意味着它不应包含可能随时间变化的值。否则，它会增加更新操作的工作量，并可能降低性能。 虽然基于键的分片是一种相当常见的分片架构，但在尝试动态添加或删除数据库中的其他服务器时，它会使事情变得棘手。在添加服务器时，每个服务器都需要一个相应的哈希值，并且许多现有条目（如果不是全部）都需要重新映射到新的正确哈希值，然后迁移到相应的服务器。当您开始重新平衡数据时，新旧哈希函数都不会有效。因此，在迁移期间，您的服务器将无法编写任何新数据，您的应用程序可能会停机。 这种策略的主要吸引力在于，它可以用于均匀分布数据，从而防止热点。此外，由于它以算法方式分配数据，因此无需维护所有数据所在位置的映射，而其他策略（如范围或基于目录的分片）必须维护数据位置的映射。 基于范围的分片基于范围的分片（Range based sharding），基于给定值的范围进行数据分片。为了说明，假设您有一个数据库，用于存储零售商目录中所有产品的信息。您可以创建一些不同的分片，并根据每个产品的价格范围分配每个产品的信息，如下所示： 基于范围的分片的主要好处是，它实现起来相对简单。每个分片都包含一组不同的数据，但它们都具有相同的模式，以及原始数据库。应用程序代码只读取数据所属的范围，并将其写入相应的分片。 另一方面，基于范围的分片并不能预防数据不均匀分布的现象，而有可能会出现前面提到的数据热点现象。查看示例图，即使每个分片拥有相同数量的数据，特定产品比其他产品获得更多关注的可能性也会很大。相应的，各个的分片将接收不成比例的读取操作。 基于目录的分片要实现基于目录的分片，必须创建并维护一个查找表，该查找表使用分片键来跟踪哪个分片包含哪些数据。简而言之，查找表是一个表，其中包含有关可以找到特定数据的静态信息集。下图显示了基于目录的分片的简单示例： 此处，Delivery Zone列被定义为分片键。将来自分片键的数据，连同每一行应该写入的分片写入查找表。这与基于范围的分片类似，但不是确定分片键的数据落入哪个范围，而是将每个键绑定到其自己的特定分片。如果分片键的基数很低，并且分片键存储键的范围没有意义，那么基于目录的分片比基于范围的分片要更好。请注意，它也不同于基于密钥的分片，因为它不通过散列函数处理分片键; 它只是根据查找表检查键值，以查看数据需要写入的位置。 基于目录的分片的主要吸引力在于其灵活性。基于范围的分片架构只能指定键值范围，而基于键的分片架构只能使用固定的哈希函数，如前所述，在以后更改该函数非常困难。另一方面，基于目录的分片允许您使用任何系统或算法将数据项分配给分片，使用这种方法动态添加分片也相对容易。 虽然基于目录的分片是这里讨论的最灵活的分片方法，但是在每次查询或写入之前连接到查找表，可能会对应用程序的性能产生不利影响。此外，查找表可能出现单点故障：如果查询表损坏或出现其他故障，它可能会影响数据库写入新数据或访问现有数据的能力。 我应该分片吗？是否应该实现分片数据库架构，几乎总是一个争论的问题。有些人认为分片对于达到一定规模的数据库来说，是不可避免的结果。而另一些人则认为这是一个令人头疼的问题，除非绝对必要，否则应该避免，因为分片增加了操作的复杂性。 由于这种增加的复杂性，通常仅在处理非常大量的数据时才执行分片。以下是一些常见方案，可能对数据库分片的操作有所帮助： 应用程序数据量增长到超过单个数据库节点的存储容量。 对数据库的读写量，超过单个节点或其只读副本可以处理的量，从而导致响应时间增加或超时。 应用程序所需的网络带宽，超过单个数据库节点和任何只读副本可用的带宽，从而导致响应时间增加或超时。 在分片之前，您应该用尽所有其他选项来优化数据库。您可能需要考虑的一些优化包括： 设置远程数据库。如果您使用的是一个整体应用程序，其中所有组件都位于同一个服务器上，那么可以通过将数据库移到它自己的机器上来提高数据库的性能。由于数据库的表保持不变，因此这不会增加分片的复杂性。但是，它仍然允许您垂直伸缩数据库，使其与基础结构的其他部分分离。 实现缓存。如果您的应用程序的读取性能导致您遇到麻烦，那么缓存是一种可以帮助改进它的策略。缓存涉及临时存储已在内存中请求的数据，以便您以后更快地访问它。 创建一个或多个只读副本。另一种有助于提高读取性能的策略，包括将数据从一个数据库服务器（主服务器）复制到一个或多个从服务器。在此之后，每次新的写操作在复制到从服务器之前都要先到主服务器，而读操作只对从服务器进行。像这样分发读写可以防止任何一台机器承担过多的负载，从而有助于防止速度下降和崩溃。请注意，创建读副本需要更多的服务器资源，因此花费更多的钱，这对一些人来说可能是一个很大的限制。 升级到更大的服务器。在大多数情况下，将一个数据库服务器扩展到具有更多资源的计算机比分片需要更少的工作量。与创建只读副本一样，具有更多资源的服务器升级可能会花费更多的钱。因此，只有当它确实是您的最佳选择时，您才应该进行服务器扩容。 请记住，如果您的应用程序或网站增长超过某个点，这些策略本身都不足以提高性能。在这种情况下，分片可能确实是您的最佳选择。 结语对于那些希望横向扩展数据库的人来说，分片是一个很好的解决方案。但是，它还会增加很多复杂性，并为您的应用程序创建更多潜在的故障点。分片对于某些人来说可能是必要的，但是创建和维护分片架构所需的时间和资源可能会超过对其他人的好处。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2019%2F09%2F26%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么代理人和被代理人要有一个公共的接口？是为了减少客户端的修改，只是更换成代理类而不需要改方法的名字。怎么理解？ schoolGirl类和代理模式一点关系都没有。为什么？ 抽象类比接口的强制性高。怎么理解？ 它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。怎么理解？ 没有代理的代码 结构图 追求者类 1234567891011121314151617181920212223// 追求者class Pursuit&#123; SchoolGirl mm; public Pursuit(SchoolGirl mm) &#123; this.mm = mm; &#125; public void GiveDolls() &#123; Console.WriteLine(mm.Name + " 送你洋娃娃"); &#125; public void GiveFlowers() &#123; Console.WriteLine(mm.Name + " 送你鲜花"); &#125; public void GiveChocolate() &#123; Console.WriteLine(mm.Name + " 送你巧克力"); &#125;&#125; 被追求者类 12345678910//被追求者class SchoolGirl&#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125;&#125; 客户端调用代码如下 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; SchoolGirl jiaojiao = new SchoolGirl(); jiaojiao.Name = "李娇娇"; Pursuit zhuojiayi = new Pursuit(jiaojiao); zhuojiayi.GiveDolls(); zhuojiayi.GiveFlowers(); zhuojiayi.GiveChocolate(); Console.Read(); &#125;&#125; 娇娇并不认识卓贾易，这样写等于他们之间互相认识，并且是卓贾易亲自送东西给娇娇了，戴励就是代理。 只有代理的代码 结构图 客户端代码 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; SchoolGirl jiaojiao = new SchoolGirl(); jiaojiao.Name = "李娇娇"; Proxy daili = new Proxy(jiaojiao); daili.GiveDolls(); daili.GiveFlowers(); daili.GiveChocolate(); Console.Read(); &#125;&#125; 把‘Pursuit（追求者）’换成了‘Proxy（代理）’，这样写把‘Pursuit（追求者）’给忽略了，事实上应该是‘Pursuit（追求者）’通过‘Proxy（代理）’送给‘SchoolGirl（被追求者）’礼物，这才是合理的。‘Pursuit（追求者）’和‘Proxy（代理）’都有送礼物的三个方法，只不过‘Proxy（代理）’送的礼物是‘Pursuit（追求者）’买的，实质是‘Pursuit（追求者）’送的。他们都实现了同样的接口。 符合实际的代码 结构图 代理接口如下 1234567//送礼物interface GiveGift&#123; void GiveDolls(); void GiveFlowers(); void GiveChocolate();&#125; 追求者类如下 12345678910111213141516171819202122class Pursuit : GiveGift&#123; SchoolGirl mm; public Pursuit(SchoolGirl mm) &#123; this.mm = mm; &#125; public void GiveDolls() &#123; Console.WriteLine(mm.Name + " 送你洋娃娃"); &#125; public void GiveFlowers() &#123; Console.WriteLine(mm.Name + " 送你鲜花"); &#125; public void GiveChocolate() &#123; Console.WriteLine(mm.Name + " 送你巧克力"); &#125;&#125; 代理类如下 123456789101112131415161718192021222324class Proxy : GiveGift&#123; Pursuit gg; public Proxy(SchoolGirl mm) &#123; gg = new Pursuit(mm); &#125; public void GiveDolls() &#123; gg.GiveDolls(); &#125; public void GiveFlowers() &#123; gg.GiveFlowers(); &#125; public void GiveChocolate() &#123; gg.GiveChocolate(); &#125;&#125; 客户端如下 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; SchoolGirl jiaojiao = new SchoolGirl(); jiaojiao.Name = "李娇娇"; Proxy daili = new Proxy(jiaojiao); daili.GiveDolls(); daili.GiveFlowers(); daili.GiveChocolate(); Console.Read(); &#125;&#125; 代理模式12 代理模式（Proxy）结构图 Subject类，定义了RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。 1234abstract class Subject&#123; public abstract void Request();&#125; RealSubject类，定义Proxy所代表的真实实体。 1234567class RealSubject : Subject&#123; public override void Request() &#123; Console.WriteLine("真实的请求"); &#125;&#125; Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。 12345678910111213class Proxy : Subject&#123; RealSubject realSubject; public override void Request() &#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; realSubject.Request(); &#125;&#125; 客户端代码 12345678910class Program&#123; static void Main(string[] args) &#123; Proxy proxy = new Proxy(); proxy.Request(); Console.Read(); &#125;&#125; 代理模式应用代理模式有以下几种使用场合： 第一，远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 第二种应用是虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。这样就可以达到性能的最优化，比如说你打开一个很大的HTML网页时，里面可能有很多的文字和图片，但你还是可以很快打开它，此时你所看到的是所有的文字，但图片却是一张一张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。浏览器是用代理模式来优化下载的。 第三种应用是安全代理，用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。第四种是智能指引，是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。说白了，代理就是真实对象的代表。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 迭代器模式是一种使用频率非常高的设计模式，迭代器用于对一个聚合对象进行遍历。通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成，简化了聚合对象的设计，更符合单一职责原则的要求。 本章将学习迭代器模式的定义与结构，结合实例学习迭代器模式的实现和应用，并学习如何使用.NET Framework内置的迭代器。 本章知识点 迭代器模式的定义 迭代器模式的结构 迭代器模式的实现 迭代器模式的应用 迭代器模式的优缺点 迭代器模式的适用环境 使用内部类实现迭代器 .NET内置迭代器 迭代器模式概述在现实生活中，人们有两种方式来操作一台电视机实现开机、关机、换台、改变音量等功能，一种方式是直接通过电视机控制面板上的按键来实现，另一种方式是通过电视机遥控器来间接实现。遥控器为操作电视机带来很大的方便，用户并不需要知道电视频道到底怎样存储在电视机中。在此，可以将电视机看成一个存储电视频道的集合对象，通过遥控器可以对电视机中的电视频道集合进行操作，例如返回上一个频道、跳转到下一个频道或者跳转到指定的频道。电视机遥控器和电视机示意图如图1所示。 图1 电视机遥控器与电视机示意图 在软件开发中，也存在着大量类似电视机一样的类，它们可以存储多个成员对象（元素），这些类通常称为聚合类（Aggregate Classes），对应的对象称为聚合对象。为了更加方便地操作这些聚合对象，同时可以很灵活地为聚合对象增加不同的遍历方法，也需要类似电视机遥控器一样的角色，可以访问一个聚合对象中的元素但又不需要暴露它的内部结构。本章所要学习的迭代器模式将为聚合对象提供一个“遥控器”，通过引入迭代器，客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式。 在软件系统中，聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合单一职责原则的要求。 迭代器模式的定义如下：1提供一种方法顺序访问一个聚合对象中的各个元素，且不用暴露该对象的内部表示。 迭代器模式又称为游标（Cursor）模式，它是一种对象行为型模式。 迭代器模式的结构与实现迭代器模式的结构在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式，其模式结构如图2所示。 图2 迭代器模式结构图 由图2可知，迭代器模式包含以下4个角色。 (1)Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。例如，用于获取第一个元素的First()方法，用于访问下一个元素的Next()方法，用于判断是否还有下一个元素的HasNext()方法，用于获取当前元素的CurrentItem()方法等，在具体迭代器中将实现这些方法。 (2)ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。 (3)Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个CreateIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。 (4)ConcreteAggregate（具体聚合类）：它是抽象聚合类的子类，实现了在抽象聚合类中声明的CreateIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器Concretelterator实例。 迭代器模式的实现在迭代器模式中，提供了一个外部的迭代器对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。迭代器的引入，将使对一个复杂聚合对象的操作变得简单。 下面结合代码对迭代器模式的实现作进一步分析。在迭代器模式中应用了工厂方法模式，抽象迭代器对应于抽象产品角色，具体迭代器对应于具体产品角色，抽象聚合类对应于抽象工厂角色，具体聚合类对应于具体工厂角色。 在抽象迭代器中声明了用于遍历聚合对象中所存储元素的方法，其典型代码如下：1234567interface Iterator&#123; void First(); // 将游标指向第一个元素 void Next(); // 将游标指向下一个元素 bool HasNext(); // 判断是否存在下一个元素 object CurrentItem(); // 获取游标指向的当前元素&#125; 在具体迭代器中将实现抽象迭代器声明的遍历数据的方法，其典型代码如下：1234567891011121314151617181920212223242526272829303132class ConcreteIterator : Iterator &#123; private ConcreteAggregate objects; // 维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据 private int cursor; // 定义一个游标，用于记录当前访问位置 public ConcreteIterator(ConcreteAggregate objects) &#123; this.objects = objects; &#125; public void First() &#123; // 实现代码 &#125; public void Next() &#123; // 实现代码 &#125; public bool HasNext() &#123; // 实现代码 return false; &#125; public object CurrentItem() &#123; // 实现代码 return null; &#125;&#125; 需要注意的是，抽象迭代器接口的设计非常重要，一方面需要充分满足各种遍历操作的要求，尽量为各种遍历方法提供声明；另一方面又不能包含太多方法，如果接口中的方法太多将给子类的实现带来麻烦。因此，可以考虑使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现。如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反开闭原则，因此在设计时要考虑全面，避免之后修改接口。 聚合类用于存储数据并负责创建迭代器对象，最简单的抽象聚合类代码如下：1234interface Aggregate&#123; Iterator CreateIterator();&#125; 具体聚合类作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法CreateIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象。其典型代码如下：123456789class ConcreteAggregate : Aggregate &#123; //...... public Iterator CreateIterator() &#123; return new ConcreteIterator(this); &#125; //......&#125; 迭代器模式的应用实例下面通过一个应用实例来进一步学习和理解迭代器模式。 1.实例说明 某软件公司为某商场开发了一套销售管理系统，在对该系统进行分析和设计时，开发人员发现经常需要对系统中的商品数据、客户数据等进行遍历，为了复用这些遍历代码，开发人员设计了一个抽象的数据集合类AbstractObjectList，将存储商品和客户等数据的类作为其子类，AbstractObjectList类结构如图3所示。 图3 AbstractObjectList类结构图 在图3中，List类型的对象objects用于存储数据，其方法与说明如表1所示。 表1 AbstractObjectList类的方法与说明 方法名 方法说明 AbstractObjectList() 构造方法，用于给objects对象赋值 AddObject() 增加元素 RemoveObject() 删除元素 GetObjects() 获取所有元素 Next() 移至下一个元素 IsLast() 判断当前元素是否是最后一个元素 Previous() 移至上一个元素 IsFirst() 判断当前元素是否是第一个元素 GetNextItem() 获取下一个元素 GetPreviousItem() 获取上一个元素 AbstractObjectList类的子类ProductList和CustomerList分别用于存储商品数据和客户数据。通过分析，发现AbstractObjectList类的职责非常重，它既负责存储和管理数据，又负责遍历数据，违背了单一职责原则，实现代码将非常复杂。因此，开发人员决定使用迭代器模式对AbstractObjectList类进行重构，将负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，还可以给不同的具体数据集合类提供不同的遍历方式。现给出使用迭代器模式重构后的解决方案。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 销售管理系统数据遍历结构图 为了简化类图和代码，图4只提供了一个具体聚合类和一个具体迭代器类，AbstractObjectList充当抽象聚合类，ProductList充当具体聚合类，Abstractlterator充当抽象迭代器，Productlterator充当具体迭代器。 3.实例代码 (1)AbstractObjectList：抽象聚合类。 1234567891011121314151617181920212223242526272829303132using System.Collections.Generic;namespace IteratorSample&#123; abstract class AbstractObjectList &#123; protected List&lt;object&gt; objects = new List&lt;object&gt;(); public AbstractObjectList(List&lt;object&gt; objects) &#123; this.objects = objects; &#125; public void AddObject(object obj) &#123; this.objects.Add(obj); &#125; public void RemoveObject(object obj) &#123; this.objects.Remove(obj); &#125; public List&lt;object&gt; GetObjects() &#123; return this.objects; &#125; // 声明创建迭代器对象的抽象工厂方法 public abstract AbstractIterator CreateIterator(); &#125;&#125; (2)ProductList：商品数据类，充当具体聚合类。 1234567891011121314151617using System.Collections.Generic;namespace IteratorSample&#123; class ProductList : AbstractObjectList &#123; public ProductList(List&lt;object&gt; products) : base(products) &#123; &#125; // 实现创建迭代器对象的具体工厂方法 public override AbstractIterator CreateIterator() &#123; return new ProductIterator(this); &#125; &#125;&#125; (3)AbstractIterator：抽象迭代器。 123456789101112namespace IteratorSample&#123; interface AbstractIterator &#123; void Next(); // 移至下一个元素 bool IsLast(); // 判断是否为最后一个元素 void Previous(); // 移至上一个元素 bool IsFirst(); // 判断是否为第一个元素 object GetNextItem(); // 获取下一个元素 object GetPreviousItem(); // 获取上一个元素 &#125;&#125; (4)ProductIterator：商品迭代器，充当具体迭代器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System.Collections.Generic;namespace IteratorSample&#123; class ProductIterator : AbstractIterator &#123; private ProductList productList; private List&lt;object&gt; products; private int cursor1; // 定义一个游标，用于记录正向遍历的位置 private int cursor2; // 定义一个游标，用于记录逆向遍历的位置 public ProductIterator(ProductList list) &#123; this.productList = list; this.products = list.GetObjects(); // 获取集合对象 cursor1 = 0; // 设置正向遍历游标的初始值 cursor2 = products.Count - 1; // 设置逆向遍历游标的初始值 &#125; public void Next() &#123; if (cursor1 &lt; products.Count) &#123; cursor1++; &#125; &#125; public bool IsLast() &#123; return (cursor1 == products.Count); &#125; public void Previous() &#123; if (cursor2 &gt; -1) &#123; cursor2--; &#125; &#125; public bool IsFirst() &#123; return (cursor2 == -1); &#125; public object GetNextItem() &#123; return products[cursor1]; &#125; public object GetPreviousItem() &#123; return products[cursor2]; &#125; &#125;&#125; (5)Program：客户端测试类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections;using System.Collections.Generic;namespace IteratorSample&#123; class Program &#123; static void Main(string[] args) &#123; List&lt;object&gt; products = new List&lt;object&gt;(); products.Add("倚天剑"); products.Add("屠龙刀"); products.Add("断肠草"); products.Add("葵花宝典"); products.Add("四十二章经"); AbstractObjectList list; AbstractIterator iterator; list = new ProductList(products); // 创建聚合对象 iterator = list.CreateIterator(); // 创建迭代器对象 Console.WriteLine("正向遍历："); while(!iterator.IsLast()) &#123; Console.Write(iterator.GetNextItem() + "，"); iterator.Next(); &#125; Console.WriteLine(); Console.WriteLine("-----------------------------"); Console.WriteLine("逆向遍历："); while(!iterator.IsFirst()) &#123; Console.Write(iterator.GetPreviousItem() + "，"); iterator.Previous(); &#125; Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345正向遍历： 倚天剑，屠龙刀，断肠草，葵花宝典，四十二章经，-----------------------------逆向遍历： 四十二章经，葵花宝典，断肠草，屠龙刀，倚天剑， 如果需要增加一个新的具体聚合类，例如客户数据集合类，并且需要为客户数据集合类提供不同于商品数据集合类的正向遍历和逆向遍历操作，只需增加一个新的聚合子类和一个新的具体迭代器类即可，原有类库代码无须修改，符合开闭原则；如果需要为ProductList类更换一个迭代器，只需增加一个新的具体迭代器类作为抽象迭代器类的子类，重新实现遍历方法即可，原有迭代器代码无须修改，也符合开闭原则；如果要在迭代器中增加新的方法，则需要修改抽象迭代器的源代码，这将违背开闭原则。 使用内部类实现迭代器在图2所示的迭代器模式结构图中，可以看到具体迭代器类和具体聚合类之间存在着双重关系，其中一个关系为关联关系，在具体迭代器中需要维持一个对具体聚合对象的引用，该关联关系的目的是访问存储在聚合对象中的数据，以便迭代器能够对这些数据进行遍历操作。 除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类。例如可以对19.3节中的ProductList类进行修改，将Productlterator类作为ProductList类的内部类，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System.Collections.Generic;namespace IteratorSample&#123; class ProductListNew : AbstractObjectList &#123; public ProductListNew(List&lt;object&gt; products) : base(products) &#123; &#125; public override AbstractIterator CreateIterator() &#123; return new ProductIterator(); &#125; // 商品迭代器：具体迭代器，内部类实现 private class ProductIterator : AbstractIterator &#123; private int cursor1; private int cursor2; public ProductIterator() &#123; cursor1 = 0; cursor2 = objects.Count - 1; &#125; public void Next() &#123; if(cursor1 &lt; objects.Count) &#123; cursor1++; &#125; &#125; public bool IsLast() &#123; return (cursor1 == objects.Count); &#125; public void Previous() &#123; if(cursor2 &gt; -1) &#123; cursor2--; &#125; &#125; public bool IsFirst() &#123; return (cursor2 == -1); &#125; public object GetNextItem() &#123; return objects[cursor1]; &#125; public object GetPreviousItem() &#123; return objects[cursor2]; &#125; &#125; &#125;&#125; 需要注意的是，根据C#语言的语法规定，内部类只能访问到外部类中定义的静态（static）成员变量，因此需要将AbstractObjectList中的objects声明为静态变量，代码如下：123...protected static List&lt;object&gt; objects = new List&lt;object&gt;();... 同时还需要将引用该变量的方法中的this关键字去掉。 无论使用哪种实现机制，客户端代码都是一样的，也就是说客户端无须关心具体迭代器对象的创建细节，只需通过调用工厂方法Createlterator()即可得到一个可用的迭代器对象，这也是使用工厂方法模式的好处，通过工厂来封装对象的创建过程，简化了客户端的调用。 .NET内置迭代器在.NET Framework中内置了对迭代器模式的支持，提供了抽象的迭代器接口System.Collections.IEnumerator和枚举接口System.Collections.IEnumerable，C#语言中的foreach循环就是利用IEnumerable提供的IEnumerator来实现的。 在.Net中，IEnumerable接口的定义如下：1234public interface IEnumerable&#123; IEnumerator GetEnumerator(); // 工厂方法，获取迭代器对象&#125; IEnumerator接口的定义如下：123456789public interface IEnumerator&#123; object Current&#123; // 返回当前集合中的元素 get; &#125; bool MoveNext(); // 遍历集合，移至下一个元素 void Reset(); // 恢复初始位置&#125; 通过扩展IEnumerable接口和IEnumerator接口可以定义自己的聚合类和迭代器类，实现了IEnumerable的子类都可以对应定义一个迭代器，用于对其中的元素进行遍历。在NET中，ICollection继承自IEnumerable，IList继承自ICollection，而ArrayList是IList的子类，实现了GetEnumerator()方法，并返回一个ArrayListEnumeratorSimple类型的对象。 ArrayList类的代码片段如下：123456789public class ArrayList : IList, ICloneable&#123; ... public virtual IEnumerator GetEnumerator() &#123; return new ArrayListEnumeratorSimple(this); &#125; ...&#125; ArrayList中，GetEnumerator()方法是一个虚方法，表示可以自定义一个集合类型继承ArrayList，然后重写这个方法，创建不同的IEnumerator对象，从而实现不同的遍历方式。 在.NET中，ArrayListEnumeratorSimple类的代码片段如下：1234567891011121314151617181920212223[Serializable]private class ArrayListEnumeratorSimple : IEnumerator, ICloneable&#123; // Methods internal ArrayListEnumeratorSimple(ArrayList list) &#123; this.list = list; this.index = -1; this.version = list._version; this.currentElement = list; &#125; public object Clone()&#123;&#125;; public virtual bool MoveNext()&#123;&#125;; public virtual void Reset()&#123;&#125;; public virtual bool Current()&#123;&#125;; // Fields private object currentElement; private int index; private ArrayList list; private int version;&#125; ArrayListEnumeratorSimple实现了IEnumerator接口，且实现了MoveNext()、Reset()、Current等方法和属性，该类是一个私有类，其构造函数被internal修饰符限制，在构造函数中，传入的参数类型是ArrayList，MoveNext()、Current、Reset()等操作通过构造函数所传递的ArrayList对象实现。 在此，IEnumerable是抽象聚合类，IEnumerator是抽象迭代器，ArrayList是具体聚合类，ArrayListEnumeratorSimple是具体迭代器。 在实际的C#应用开发中通常很少自定义迭代器，一般使用.NET Framework内置的迭代器即可，下面的代码演示了如何使用.NET Framework内置迭代器。12345678910111213141516171819202122232425262728293031323334using System;using System.Collections;using System.Collections.Generic;namespace IteratorSample&#123; class Program &#123; static void Process(IEnumerable e) &#123; IEnumerator i = e.GetEnumerator(); // 创建迭代器对象 while (i.MoveNext()) &#123; Console.WriteLine(i.Current.ToString()); &#125; &#125; static void Main(string[] args) &#123; IList persons; persons = new ArrayList(); // 创建一个ArrayList类型的聚合对象 persons.Add("张无忌"); persons.Add("小龙女"); persons.Add("令狐冲"); persons.Add("韦小宝"); persons.Add("袁紫衣"); persons.Add("小龙女"); Process(persons); Console.Read(); &#125; &#125;&#125; 如上加粗代码所示，在静态方法Process()中使用迭代器1Enumerator对IEnumerable对象进行处理。该代码的运行结果如下：123456张无忌 小龙女 令狐冲 韦小宝 袁紫衣 小龙女 迭代器模式的优缺点与适用环境迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，直接使用C#、Java等语言已经定义好的迭代器即可，迭代器已经成为操作聚合对象的基本工具之一。 迭代器模式的优点迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，直接使用C#，Java等语言已经定义好的迭代器即可，迭代器已经成为操作聚合对象的基本工具之一。 迭代器模式的优点迭代器模式的主要优点如下： (1)迭代器模式支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中，只需用一个不同的迭代器来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式。 (2)迭代器模式简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。 (3)在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则。 迭代器模式的缺点迭代器模式的主要缺点如下： (1)由于迭代器模式将存储数据和遍历数据的职责分离，在增加新的聚合类时需要对应地增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 (2)抽象迭代器的设计难度较大，需要充分考虑系统将来的扩展。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情。 迭代器模式的适用环境在以下情况下可以考虑使用迭代器模式： (1)访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。 (2)需要为一个聚合对象提供多种遍历方式。 (3)为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。 本章小结(1)迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，且不用暴露该对象的内部表示。迭代器模式是一种对象行为型模式。 (2)迭代器模式包含抽象迭代器、具体迭代器、抽象聚合类和具体聚合类4个角色。其中，抽象迭代器定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法；具体迭代器实现了抽象迭代器接口，完成对聚合对象的遍历；抽象聚合类用于存储和管理元素对象；具体聚合类是抽象聚合类的子类，实现了在抽象聚合类中声明的方法。 (3)迭代器模式的主要优点包括支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式；简化了聚合类；增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则。其主要缺点是在增加新的聚合类时需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性；抽象迭代器的设计难度较大，需要充分考虑系统将来的扩展。 (4)迭代器模式适用的环境:访问一个聚合对象的内容而无须暴露它的内部表示；需要为一个聚合对象提供多种遍历方式；为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。 (5)除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类。 (6)在.NET Framework中内置了对迭代器模式的支持，提供了抽象的迭代器接口IEnumerator和枚举接口IEnumerable，通过使用.NET Framework内置的迭代器可以很方便地实现对常用集合对象的遍历操作。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 解释器模式用于描述如何构成一个简单的语言解释器，主要应用于使用面向对象语言开发的解释器的设计。当需要开发一个新的语言时，开发人员可以考虑使用解释器模式。在实际应用中，用户也许很少碰到去构造一个语言的情况，虽然很少使用，但是对它进行学习能够加深对面向对象思想的理解，并且掌握编程语言中语法规则解释的原理和过程。 本章将学习解释器模式的定义和结构，并结合实例学习如何使用解释器模式构造一个新的语言，以及如何通过终结符表达式和非终结符表达式在类中封装语言的文法规则。 本章知识点 解释器模式的定义 解释器模式的结构 解释器模式的实现 解释器模式的应用 文法规则和抽象语法树 解释器模式的优缺点 解释器模式的适用环境 解释器模式概述虽然目前计算机编程语言有几百种，但有时人们还是希望能用一些简单的语言来实现一些特定的操作，用户只要向计算机输入一个句子或文件，它就能够按照预先定义的文法规则对句子或文件进行解释，从而实现相应的功能。例如提供一个简单的加法/减法解释器，只要输入一个加法/减法表达式，它就能够计算出表达式结果，如图1所示，当输入字符串表达式为“1+2+3-4+1”时，将输出计算结果“3”。 图1 加法/减法解释器示意图 众所周知，像C#、C+和Java等语言无法直接解释类似“1+2+3-4+1”这样的字符串（如果直接作为数学表达式则可以解释），必须定义一套文法规则来实现对这些语句的解释，即设计一个自定义语言。在实际开发中，这些简单的自定义语言可以基于现有的编程语言来设计，如果所基于的编程语言是面向对象语言，则可以使用解释器模式来实现自定义语言。 解释器模式是一种使用频率相对较低但学习难度相对较大的设计模式，用于描述如何使用面向对象语言构成一个简单的语言解释器。在某些情况下，为了更好地描述某一些特定类型的问题，可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应该语言中的句子。此时，用户可以使用解释器模式来设计这种新的语言。另外，对解释器模式进行学习能够加深用户对面向对象思想的理解，并且理解编程语言中文法规则的解释过程。 解释器模式的定义如下:1给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 在解释器模式的定义中所指的“语言”是使用规定格式和语法的代码，解释器模式是一种类行为型模式。 文法规则和抽象语法树解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。在正式分析解释器模式结构之前，先来学习如何表示一个语言的文法规则以及如何构造一棵抽象语法树。 在前面所提到的加法/减法解释器中，每一个输入表达式，例如“1+2+3-4+1”，都包含了3个语言单位，可以使用以下文法规则来定义：123expression ::= value | operationoperation ::= expression &apos;+&apos; expression | expression &apos;-&apos; expressionvalue ::= an integer //一个整数值 该文法规则包含3条语句，第一条表示表达式的组成方式，其中，value和operation是后面两个语言单位的定义，每一条语句所定义的字符串（如operation和value）称为语言构造成分或语言单位，符号“::=”是“定义为”的意思，其左边的语言单位通过右边进行说明和定义，语言单位对应终结符表达式和非终结符表达式。例如本规则中的operation是非终结符表达式，它的组成元素仍然可以是表达式，还可以进一步分解，而value是终结符表达式，它的组成元素是最基本的语言单位，不能再进行分解。 在文法规则定义中可以使用一些符号表示不同的含义，例如使用“|”表示“或”，使用“{”和“}”表示“组合”，使用“*”表示出现“0次或多次”等。其中，使用频率最高的符号是表示“或”关系的“|”，例如文法规则“boolValue::=0|1”表示终结符表达式boolValue的取值可以为0或者1。 除了使用文法规则来定义一个语言外，在解释器模式中还可以通过一种被称为抽象语法树（Abstract Syntax Tree，AST）的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例，例如加法/减法解释器中的表达式“1+2+3-4+1”可以通过如图2所示的抽象语法树来表示。 图2 抽象语法树示意图 在该抽象语法树中，可以通过终结符表达式value和非终结符表达式operation组成复杂的语句，每个文法规则的语言实例都可以表示为一棵抽象语法树，即每一条具体的语句都可以用类似图2所示的抽象语法树来表示。在该图中，终结符表达式类的实例作为树的叶子结点，而非终结符表达式类的实例作为非叶子结点，它们可以将终结符表达式类的实例以及包含终结符和非终结符实例的子表达式作为其子结点。抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。 解释器模式的结构与实现解释器模式的结构由于表达式可以分为终结符表达式和非终结符表达式，所以解释器模式的结构与组合模式的结构有些类似，但在解释器模式中包含更多的组成元素，它的结构如图3所示。 图3 解释器模式结构图 由图3可知，解释器模式包含以下4个角色。 (1)AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。 (2)TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常，在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。 (3)NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。 (4)Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常临时存储了需要解释的语句。 解释器模式的实现在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一条文法规则，所以系统具有较好的灵活性和可扩展性。 对于所有的终结符和非终结符，首先需要抽象出一个公共父类，即抽象表达式类。其典型代码如下：1234abstract class AbstractExpression&#123; public abstract void Interpret(Context ctx);&#125; 终结符表达式类和非终结符表达式类都是抽象表达式类的子类，对于终结符表达式类，其代码很简单，主要是对终结符元素进行处理。其典型代码如下：1234567class TerminalExpression : AbstractExpression &#123; public override void Interpret(Context ctx) &#123; //终结符表达式的解释操作 &#125;&#125; 对于非终结符表达式，其代码相对比较复杂，因为可以通过非终结符将表达式组合成更加复杂的结构，对于包含两个操作元素的非终结符表达式类，其典型代码如下：1234567891011121314151617class NonterminalExpression : AbstractExpression &#123; private AbstractExpression left; private AbstractExpression right; public NonterminalExpression(AbstractExpression left,AbstractExpression right) &#123; this.left=left; this.right=right; &#125; public override void Interpret(Context ctx) &#123; //递归调用每一个组成部分的interpret()方法 //在递归调用时指定组成部分的连接方式，即非终结符的功能 &#125; &#125; 除了用于表示表达式的类以外，通常在解释器模式中还提供了一个环境类Context，用于存储一些全局信息，在环境类中一般包含了一个Hashtable或List等类型的集合对象（也可以直接由Hashtable等集合类充当环境类），存储一系列公共信息，例如变量名与值的映射关系（key/value等），用于在执行具体的解释操作时从中获取相关信息。其典型代码片段如下：12345678910111213141516class Context&#123; private Hashtable ht = new Hashtable(); //往环境类中设值 public void Assign(string key, string value) &#123; ht.Add(key,value); &#125; //获取存储在环境类中的值 public string Lookup(string key) &#123; return (string)ht[key]; &#125;&#125; 环境类Context的对象通常作为参数被传递到所有表达式的解释方法Interpret()中，可以在环境类对象中存储和访问表达式解释器的状态，向表达式解释器提供一些全局的、公共的数据，此外，还可以在环境类中增加一些所有表达式解释器都共有的功能，以减轻解释器的职责。当系统无须提供全局公共信息时可以省略环境类，根据实际情况决定是否需要环境类。 解释器模式的应用实例下面通过一个应用实例来进一步学习和理解解释器模式。 1.实例说明 某软件公司要开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式（expression），该表达式可以是简单表达式也可以是复合表达式。每一个简单表达式由移动方向（direction）、移动方式（action）和移动距离（distance）三部分组成，其中，移动方向包括向上（up）、向下（down）、向左（left）、向右（right）；移动方式包括移动（move）和快速移动（run）；移动距离为一个正整数。两个表达式之间可以通过与（and）连接，形成复合（composite）表达式。用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令“up move 5”将“向上移动5个单位”；输入控制指令“down run 10 and left move 20”将“向下快速移动10个单位再向左移动20个单位”。现使用解释器模式来设计该程序并模拟实现。 2.实例类图 根据上述需求描述，用形式化语言来表示该简单语言的文法规则如下：12345expression ::= direction action distance | composite //表达式composite ::= expression &apos;and&apos; expression //复合表达式direction ::= &apos;up&apos; | &apos;down&apos; | &apos;left&apos; | &apos;right&apos; //移动方向action ::= &apos;move&apos; | &apos;run&apos; //移动方式distance ::= an integer //移动距离 该语言一共定义了5条文法规则，对应5个语言单位，这些语言单位可以分为两类，一类为终结符（也称为终结符表达式），例如direction，action和distance，它们是语言的最小组成单位，不能再进行拆分；另一类为非终结符（也称为非终结符表达式），例如expression和composite，它们都是一个完整的句子，包含一系列终结符或非终结符。 针对5条文法规则，分别提供5个类来实现，其中，终结符表达式direction，action和diatance对应DirectionNode类、ActionNode类和DistanceNode类，非终结符表达式expression和composite对应SentenceNode类和AndNode类。 可以通过抽象语法树来表示具有解释过程，例如机器人控制指令“down run 10 and left move 20”对应的抽象语法树如图4所示。 图4 机器人控制程序抽象语法树实例 机器人控制程序实例的基本结构如图5所示。 图5 机器人控制程序结构图 在图5中，AbstractNode充当抽象表达式角色，DirectionNode、ActionNode和DistanceNode充当终结符表达式角色，AndNode和SentenceNode充当非终结符表达式角色。 3.实例代码 (1)AbstractNode：抽象节点类，充当抽象表达式角色。 1234567namespace InterpreterSample&#123; abstract class AbstractNode &#123; public abstract string Interpret(); &#125;&#125; (2)AndNode：And节点类，充当非终结符表达式角色。 1234567891011121314151617181920namespace InterpreterSample&#123; class AndNode : AbstractNode &#123; private AbstractNode left; //And的左表达式 private AbstractNode right; //And的右表达式 public AndNode(AbstractNode left, AbstractNode right) &#123; this.left = left; this.right = right; &#125; //And表达式解释操作 public override string Interpret() &#123; return left.Interpret() + "再" + right.Interpret(); &#125; &#125;&#125; (3)SentenceNode：简单句子节点类，充当非终结符表达式角色。 12345678910111213141516171819202122namespace InterpreterSample&#123; class SentenceNode : AbstractNode &#123; private AbstractNode direction; private AbstractNode action; private AbstractNode distance; public SentenceNode(AbstractNode direction,AbstractNode action,AbstractNode distance) &#123; this.direction = direction; this.action = action; this.distance = distance; &#125; //简单句子的解释操作 public override string Interpret() &#123; return direction.Interpret() + action.Interpret() + distance.Interpret(); &#125; &#125;&#125; (4)DirectionNode：方向节点类，充当终结符表达式角色。 12345678910111213141516171819202122232425262728293031323334353637namespace InterpreterSample&#123; class DirectionNode : AbstractNode &#123; private string direction; public DirectionNode(string direction) &#123; this.direction = direction; &#125; //方向表达式的解释操作 public override string Interpret() &#123; if (direction.Equals("up")) &#123; return "向上"; &#125; else if (direction.Equals("down")) &#123; return "向下"; &#125; else if (direction.Equals("left")) &#123; return "向左"; &#125; else if (direction.Equals("right")) &#123; return "向右"; &#125; else &#123; return "无效指令"; &#125; &#125; &#125;&#125; (5)ActionNode：动作节点类，充当终结符表达式角色。 1234567891011121314151617181920212223242526272829namespace InterpreterSample&#123; class ActionNode : AbstractNode &#123; private string action; public ActionNode(string action) &#123; this.action = action; &#125; //动作（移动方式）表达式的解释操作 public override string Interpret() &#123; if (action.Equals("move")) &#123; return "移动"; &#125; else if (action.Equals("run")) &#123; return "快速移动"; &#125; else &#123; return "无效指令"; &#125; &#125; &#125;&#125; (6)DistanceNode：距离节点类，充当终结符表达式角色。 123456789101112131415161718namespace InterpreterSample&#123; class DistanceNode : AbstractNode &#123; private string distance; public DistanceNode(string distance) &#123; this.distance = distance; &#125; //距离表达式的解释操作 public override string Interpret() &#123; return this.distance; &#125; &#125;&#125; (7)InstructionHandler：指令处理类，工具类，提供相应的方法对输入指令进行处理。它将输入指令分隔为字符串数组，将第1个、第2个和第3个单词组合成一个句子，并存入栈中；如果发现有单词“and”，则将“and”后的第1个、第2个和第3个单词组合成一个新的句子作为“and”的右表达式，并从栈中取出原先所存句子作为左表达式，然后组合成一个And结点存入栈中。依此类推，直到整个指令解析结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Collections;namespace InterpreterSample&#123; class InstructionHandler &#123; private AbstractNode node; public void Handle(string instruction) &#123; AbstractNode left = null, right = null; AbstractNode direction = null, action = null, distance = null; Stack stack = new Stack(); //声明一个栈对象用于存储抽象语法树 string[] words = instruction.Split(' '); //以空格分隔指令字符串 for (int i = 0; i &lt; words.Length; i++) &#123; //本实例采用栈的方式来处理指令，如果遇到“and”，则将其后的三个单词作为三个终结符表达式连成一个简单句子SentenceNode作为“and”的右表达式，而将从栈顶弹出的表达式作为“and”的左表达式，最后将新的“and”表达式压入栈中。 if (words[i].Equals("and")) &#123; left = (AbstractNode)stack.Pop(); //弹出栈顶表达式作为左表达式 string word1= words[++i]; direction = new DirectionNode(word1); string word2 = words[++i]; action = new ActionNode(word2); string word3 = words[++i]; distance = new DistanceNode(word3); right = new SentenceNode(direction,action,distance); //右表达式 stack.Push(new AndNode(left,right)); //将新表达式压入栈中 &#125; //如果是从头开始进行解释，则将前三个单词组成一个简单句子SentenceNode并将该句子压入栈中 else &#123; string word1 = words[i]; direction = new DirectionNode(word1); string word2 = words[++i]; action = new ActionNode(word2); string word3 = words[++i]; distance = new DistanceNode(word3); left = new SentenceNode(direction,action,distance); stack.Push(left); //将新表达式压入栈中 &#125; &#125; this.node = (AbstractNode)stack.Pop(); //将全部表达式从栈中弹出 &#125; public string Output() &#123; string result = node.Interpret(); //解释表达式 return result; &#125; &#125;&#125; (8)Program：客户端测试类。 1234567891011121314151617181920using System;namespace InterpreterSample&#123; class Program &#123; static void Main(string[] args) &#123; //string instruction = "down run 10 and left move 20"; string instruction = "up move 5 and down run 10 and left move 5"; InstructionHandler handler = new InstructionHandler(); handler.Handle(instruction); string outString; outString = handler.Output(); Console.WriteLine(outString); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下:1向下快速移动10再向左移动20 如果将输入指令改为“up move 5 and down run 10 and left move 5”，则输出结果如下：1向上移动5再向下快速移动10再向左移动5 本实例对机器人控制指令的输出结果进行模拟，将英文指令翻译为中文指令，在真实情况下，系统将调用不同的控制程序对机器人进行控制，包括对移动方向、方式和距离的控制等。 解释器模式的优缺点与适用环境解释器模式为自定义语言的设计和实现提供了一种解决方案，用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正则表达式、XML文档解释等领域还是得到了广泛使用。 解释器模式的优点解释器模式的主要优点如下： (1)解释器模式易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 (2)在解释器模式中，每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 (3)实现文法较为容易。在抽象语法树中每一个表达式结点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成结点类代码。 (4)增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合开闭原则。 解释器模式的缺点解释器模式的主要缺点如下： (1)解释器模式对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多的文法规则，类的个数将会急剧增加，从而导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 (2)其执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。 解释器模式的适用环境在以下情况下可以考虑使用解释器模式： (1)可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树。 (2)一些重复出现的问题可以用一种简单的语言进行表达。 (3)一个语言的文法较为简单。对于复杂的文法，解释器模式中的文法类层次结构将变得很庞大而无法管理，此时最好使用语法分析程序生成器。 (4)执行效率不是关键问题。高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。 本章小结(1)解释器模式的目的是：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。解释器模式是一种类行为型模式。 (2)解释器模式包含抽象表达式、终结符表达式、非终结符表达式和环境类4个角色。其中，抽象表达式声明了抽象的解释操作，是所有终结符表达式和非终结符表达式的公共父类；终结符表达式是抽象表达式的子类，实现了与文法中的终结符相关联的解释操作；非终结符表达式也是抽象表达式的子类，实现了文法中非终结符的解释操作；环境类用于存储解释器之外的一些全局信息。 (3)解释器模式的主要优点包括易于改变和扩展文法，可以方便地实现一个简单的语言，实现文法较为容易，且增加新的解释表达式较为方便。其主要缺点是对于复杂文法难以维护，并且其执行效率较低。 (4)解释器模式适用的环境：可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树；一些重复出现的问题可以用一种简单的语言进行表达；一个语言的文法较为简单；执行效率不是关键问题。 (5)用户可以使用文法规则来定义一个语言，还可以通过抽象语法树以图形方式直观地表示一个语言的构成，每一棵抽象语法树对应一个语言实例。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问元素具有不同的类型，且不同的访问者可以对其施加不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 本章将学习访问者模式的定义与结构，理解访问者模式中对象结构的作用以及学会如何编程实现访问者模式，并掌握元素类和访问者类的设计原理及实现过程。 本章知识点 访问者模式的定义 访问者模式的结构 访问者模式的实现 访问者模式的应用 访问者模式的优缺点 访问者模式的适用环境 访问者模式与组合模式联用 访问者模式概述在医生开具处方单（药单）后，很多医院都存在着这样的处理流程：划价人员拿到处方单之后根据药品名称和数量计算总价，药房工作人员根据药品名称和数量准备药品，如图1所示。 图1 医院处方单处理示意图 在图1中，可以将处方单看成一个药品信息的集合，其中包含了一种或多种不同类型的药品信息，不同类型的工作人员（例如划价人员和药房工作人员）在操作同一个药品信息集合时将提供不同的处理方式，而且可能会增加新类型的工作人员来操作处方单。 在软件开发中，有时也需要处理像处方单这样的集合对象结构，在该对象结构中存储了多种不同类型的对象信息，而且对同一对象结构中的元素的操作方式并不唯一，可能需要提供多种不同的处理方式，还有可能增加新的处理方式。在设计模式中，有一种模式可以满足上述要求，它以不同的方式操作复杂对象结构，该模式就是访问者模式。 访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。例如处方单中的各种药品信息就是被访问的元素，而划价人员和药房工作人员就是访问者。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。访问者模式的定义如下:1访问者模式：表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 访问者模式是一种对象行为型模式，它为操作存储不同类型元素的对象结构提供了一种解决方案，用户可以对不同类型的元素施加不同的操作。 访问者模式的结构与实现访问者模式的结构访问者模式的结构较为复杂，其结构如图2所示。 图2 访问者模式结构图 由图2可知，访问者模式包含以下5个角色。 (1)Visitor（抽象访问者）：抽象访问者为对象结构中的每一个具体元素类声明一个访问操作，从这个操作的名称或参数类型大家可以清楚地知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。 (2)ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。 (3)Element（抽象元素）：抽象元素一般是抽象类或者接口，它声明了一个Accept()方法，用于接受访问者的访问操作，该方法通常以一个抽象访问者作为参数。 (4)ConcreteElement（具体元素）：具体元素实现了Accept()方法，在Accept()方法中调用访问者的访问方法以便完成对一个元素的操作。 (5)Objectistructure（对象结构）：对象结构是一个元素的集合，用于存放元素对象，并且提供了遍历其内部元素的方法。对象结构可以结合组合模式来实现,也可以是一个简单的集合对象。 访问者模式的实现在访问者模式中，对象结构存储了不同类型的元素对象，以供不同的访问者访问。访问者模式包括两个层次结构：一个是访问者层次结构，提供了抽象访问者和具体访问者；另一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同的方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。 在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，例如VisitElementA(ElementA elementA)；另一种是统一命名为Visit()，通过参数类型的不同来定义一系列重载的Visit()方法。当然，如果所有的访问者对某一类型的元素的访问操作都相同，可以将操作代码移到抽象访问者类中，其典型代码如下： 12345678910abstract class Visitor&#123; public abstract void Visit(ConcreteElementA elementA); public abstract void Visit(ConcreteElementB elementB); public void Visit(ConcreteElementC elementC) &#123; //元素ConcreteElementC操作代码 &#125;&#125; 在这里使用了重载Visit()方法的方式来定义多个方法，用于操作不同类型的元素对象。在抽象访问者Visitor类的子类ConcreteVisitor中实现了抽象的访问方法，用于定义对不同类型元素对象的操作。具体访问者类的典型代码如下：123456789101112class ConcreteVisitor : Visitor &#123; public override void Visit(ConcreteElementA elementA) &#123; //元素ConcreteElementA操作代码 &#125; public override void Visit(ConcreteElementB elementB) &#123; //元素ConcreteElementB操作代码 &#125;&#125; 对于元素类而言，在其中一般都定义了一个Accept()方法，用于接收访问者的访问。典型的抽象元素类代码如下：1234interface Element&#123; void Accept(Visitor visitor);&#125; 需要注意的是，该方法传入了一个抽象访问者Visitor类型的参数，即针对抽象访问者进行编程，而不是具体访问者，在程序运行时再确定具体访问者的类型，并调用具体访问者对象的Visit()方法实现对元素对象的操作。在抽象元素类Element的子类中实现了Accept()方法，用于接受访问者的访问，在具体元素类中还可以定义不同类型的元素所特有的业务方法。其典型代码如下：123456789101112class ConcreteElementA : Element &#123; public void Accept(Visitor visitor) &#123; visitor.Visit(this); &#125; public void OperationA() &#123; //业务方法 &#125;&#125; 在具体元素类ConcreteElementA的Accept()方法中，通过调用Visitor类的Visit()方法实现对元素的访问，并以当前对象作为Visit()方法的参数。其具体执行过程如下： (1)调用具体元素类的Accept(Visitor visitor)方法，并将Visitor子类对象作为其参数。 (2)在具体元素类Accept(Visitor visitor)方法内部调用传入的Visitor对象的Visit()方法，例如Visit(ConcreteElementA elementA)，将当前具体元素类对象(this)作为参数，例如visitor.Visit(this)。 (3)执行Visitor对象的Visit()方法，在其中还可以调用具体元素对象的业务方法。 这种调用机制也称为“双重分派”，正因为使用了双重分派机制,使得增加新的访问者无须修改现有类库代码，只需将新的访问者对象作为参数传入具体元素对象的Accept()方法，程序运行时将回调在新增Visitor类中定义的Visit()方法，从而增加新的元素访问方式。 在访问者模式中，对象结构是一个集合，用于存储元素对象并接受访问者的访问。其典型代码如下：1234567891011121314151617181920212223242526using System;using System.Collections.Generic;class ObjectStructure&#123; private List&lt;Element&gt; list = new List&lt;Element&gt;(); //定义一个集合用于存储元素对象 //接受访问者的访问操作 public void Accept(Visitor visitor) &#123; foreach (Object obj in list) &#123; ((Element)obj).Accept(visitor); //遍历访问集合中的每一个元素 &#125; &#125; public void AddElement(Element element) &#123; list.Add(element); &#125; public void RemoveElement(Element element) &#123; list.Remove(element); &#125;&#125; 在对象结构中可以使用迭代器对存储在集合中的元素对象进行遍历，并逐个调用元素对象的Accept()方法，实现对元素对象的访问操作。 访问者模式的应用实例下面通过一个应用实例来进一步学习和理解访问者模式。 1.实例说明 某公司OA系统中包含一个员工信息管理子系统，该公司员工包括正式员工和临时工，每周人力资源部和财务部等部门需要对员工数据进行汇总，汇总数据包括员工工作时间、员工工资等。该公司的基本制度如下：(1)正式员工每周工作时间为40小时不同级别、不同部门的员工每周基本工资不同；如果超过40小时，超出部分按照100元/小时作为加班费；如果少于40小时所缺时间按照请假处理，请假所扣工资以80元/小时计算，直到基本工资扣除到零为止。除了记录实际工作时间外，人力资源部需记录加班时长或请假时长，作为员工平时表现的一项依据。(2)临时工每周工作时间不固定，基本工资按小时计算，不同岗位的临时工小时工资不同。人力资源部只需记录实际工作时间。人力资源部和财务部工作人员可以根据各自的需要对员工数据进行汇总处理，人力资源部负责汇总每周员工工作时间，而财务部负责计算每周员工工资。现使用访问者模式设计该系统，绘制类图并使用C#语言编程实现。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 员工数据汇总模块结构图 在图3中，FADepartment表示财务部，HRDepartment表示人力资源部，它们充当具体访问者类，其抽象父类Department充当抽象访问者类；EmployeeList充当对象结构，用于存储员工列表；FulltimeEmployee表示正式员工，ParttimeEmployee表示临时工，它们充当具体元素类，其父接口Employee充当抽象元素类。 3.实例代码 (1)Employee：员工类，充当抽象元素类。 1234567namespace VisitorSample&#123; interface Employee &#123; void Accept(Department handler); //接受一个抽象访问者访问 &#125;&#125; (2)FulltimeEmployee：全职员工类，充当具体元素类。 123456789101112131415161718192021222324252627282930313233343536373839namespace VisitorSample&#123; class FulltimeEmployee : Employee &#123; private string name; //员工姓名 private double weeklyWage; //员工周薪 private int workTime; //工作时间 public FulltimeEmployee(string name, double weeklyWage, int workTime) &#123; this.name = name; this.weeklyWage = weeklyWage; this.workTime = workTime; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public double WeeklyWage &#123; get &#123; return weeklyWage; &#125; set &#123; weeklyWage = value; &#125; &#125; public int WorkTime &#123; get &#123; return workTime; &#125; set &#123; workTime = value; &#125; &#125; public void Accept(Department handler) &#123; handler.Visit(this); //调用访问者的访问方法 &#125; &#125;&#125; (3)ParttimeEmployee：兼职员工类，充当具体元素类。 123456789101112131415161718192021222324252627282930313233343536373839namespace VisitorSample&#123; class ParttimeEmployee : Employee &#123; private string name; //员工姓名 private double hourWage; //员工时薪 private int workTime; //工作时间 public ParttimeEmployee(string name, double hourWage, int workTime) &#123; this.name = name; this.hourWage = hourWage; this.workTime = workTime; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public double HourWage &#123; get &#123; return hourWage; &#125; set &#123; hourWage = value; &#125; &#125; public int WorkTime &#123; get &#123; return workTime; &#125; set &#123; workTime = value; &#125; &#125; public void Accept(Department handler) &#123; handler.Visit(this); //调用访问者的访问方法 &#125; &#125;&#125; (4)Department：部门类，充当抽象访问者类。 123456789namespace VisitorSample&#123; abstract class Department &#123; //声明一组重载的访问方法，用于访问不同类型的具体元素 public abstract void Visit(FulltimeEmployee employee); public abstract void Visit(ParttimeEmployee employee); &#125;&#125; (5)FADepartment：财务部类，充当具体访问者类。 1234567891011121314151617181920212223242526272829303132333435using System;namespace VisitorSample&#123; class FADepartment : Department &#123; //实现财务部对全职员工的访问 public override void Visit(FulltimeEmployee employee) &#123; int workTime = employee.WorkTime; double weekWage = employee.WeeklyWage; if(workTime &gt; 40) &#123; weekWage = weekWage + (workTime - 40) * 100; &#125; else if(workTime &lt; 40) &#123; weekWage = weekWage - (40 - workTime) * 80; if(weekWage &lt; 0) &#123; weekWage = 0; &#125; &#125; Console.WriteLine("正式员工&#123;0&#125;实际工资为：&#123;1&#125;元。", employee.Name,weekWage); &#125; //实现财务部对兼职员工的访问 public override void Visit(ParttimeEmployee employee) &#123; int workTime = employee.WorkTime; double hourWage = employee.HourWage; Console.WriteLine("临时工&#123;0&#125;实际工资为：&#123;1&#125;元。", employee.Name, workTime * hourWage); &#125; &#125;&#125; (6)HRDepartment：人力资源部类，充当具体访问者类。 1234567891011121314151617181920212223242526272829using System;namespace VisitorSample&#123; class HRDepartment : Department &#123; //实现人力资源部对全职员工的访问 public override void Visit(FulltimeEmployee employee) &#123; int workTime = employee.WorkTime; Console.WriteLine("正式员工&#123;0&#125;实际工作时间为：&#123;1&#125;小时。", employee.Name, workTime); if(workTime &gt; 40) &#123; Console.WriteLine("正式员工&#123;0&#125;加班时间为：&#123;1&#125;小时。", employee.Name,workTime - 40); &#125; else if(workTime &lt; 40) &#123; Console.WriteLine("正式员工&#123;0&#125;请假时间为：&#123;1&#125;小时。", employee.Name,40 - workTime); &#125; &#125; //实现人力资源部对兼职员工的访问 public override void Visit(ParttimeEmployee employee) &#123; int workTime = employee.WorkTime; Console.WriteLine("临时工&#123;0&#125;实际工作时间为：&#123;1&#125;小时。", employee.Name, workTime); &#125; &#125;&#125; (7)EmployeeList：员工列表类，充当对象结构。 12345678910111213141516171819202122232425using System;using System.Collections;namespace VisitorSample&#123; class EmployeeList &#123; //定义一个集合用于存储员工对象 private ArrayList list = new ArrayList(); public void AddEmployee(Employee employee) &#123; list.Add(employee); &#125; //遍历访问员工集合中的每一个员工对象 public void Accept(Department handler) &#123; foreach(Object obj in list) &#123; ((Employee)obj).Accept(handler); &#125; &#125; &#125;&#125; (8)配置文件App.config：在配置文件中存储了具体访问者类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="visitor" value="VisitorSample.FADepartment"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (9)Program：客户端测试类。 123456789101112131415161718192021222324252627282930313233343536using System;using System.Configuration;using System.Reflection;namespace VisitorSample&#123; class Program &#123; static void Main(string[] args) &#123; EmployeeList list = new EmployeeList(); Employee fte1, fte2, fte3, pte1, pte2; fte1 = new FulltimeEmployee("张无忌", 3200.00, 45); fte2 = new FulltimeEmployee("杨过", 2000.00, 40); fte3 = new FulltimeEmployee("段誉", 2400.00, 38); pte1 = new ParttimeEmployee("洪七公", 80.00, 20); pte2 = new ParttimeEmployee("郭靖", 60.00, 18); list.AddEmployee(fte1); list.AddEmployee(fte2); list.AddEmployee(fte3); list.AddEmployee(pte1); list.AddEmployee(pte2); Department dep; //读取配置文件 string visitorStr = ConfigurationManager.AppSettings["visitor"]; //反射生成对象 dep = (Department)Assembly.Load("VisitorSample").CreateInstance(visitorStr); list.Accept(dep); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345正式员工张无忌的实际工资为：3700元。正式员工杨过的实际工资为：2000元。正式员工段誉的实际工资为：2240元。临时工洪七公的实际工资为：1600元。临时工郭靖的实际工资为：1080元。 如果需要更换具体访问者类，无须修改源代码，只需修改配置文件即可。例如将访问者类由财务部改为人力资源部，只需将存储在配置文件App.config中的具体访问者类FADepartment改为HRDepartment，代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="visitor" value="VisitorSample.HRDepartment"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 重新运行客户端程序，输出结果如下：1234567正式员工张无忌的实际工作时间为：45小时。 正式员工张无忌的加班时间为：5小时。 正式员工杨过的实际工作时间为：40小时。 正式员工段誉的实际工作时间为：38小时。 正式员工段誉的请假时间为：2小时。 临时工洪七公的实际工作时间为：20小时。 临时工郭靖的实际工作时间为：18小时。 如果要在系统中增加一种新的访问者，无须修改源代码，只需增加一个新的具体访问者类即可，在该具体访问者中封装了新的操作元素对象的方法。从增加新的访问者的角度来看，访问者模式符合开闭原则。 如果要在系统中增加一种新的具体元素，例如增加一种新的员工类型为“退休人员”，由于原有系统并未提供相应的访问接口（在抽象访问者中没有声明任何访问“退休人员”的方法），所以必须对原有系统进行修改，在原有的抽象访问者类和具体访问者类中增加相应的访问方法。从增加新的元素的角度来看，访问者模式违背了开闭原则。 综上所述，访问者模式与抽象工厂模式类似，对开闭原则的支持具有倾斜性，可以很方便地添加新的访问者，但是添加新的元素较为麻烦。 访问者模式与组合模式联用在访问者模式中，包含一个用于存储元素对象集合的对象结构，通常可以使用迭代器来遍历对象结构，同时具体元素之间可以存在整体与部分关系，有些元素作为容器对象，有些元素作为成员对象，因此可以使用组合模式来组织元素。引入组合模式后的访问者模式结构如图4所示。 图4 访问者模式与组合模式联用示意图 需要注意的是，在图4所示的结构中，由于叶子元素的遍历操作已经在容器元素中完成，因此要防止单独将已增加到容器元素中的叶子元素再次加入到对象结构中，对象结构中只保存容器元素和孤立的叶子元素。 访问者模式的优缺点与适用环境由于访问者模式的使用条件较为苛刻，本身结构也较为复杂，所以在实际应用中的使用频率不是特别高。当系统中存在一个较为复杂的对象结构，且不同访问者对其所采取的操作也不相同时，可以考虑使用访问者模式进行设计。在XML文档解析、编译器的设计、复杂集合对象的处理等领域访问者模式得到了一定的应用。 访问者模式的优点访问者模式的主要优点如下： (1)访问者模式增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合开闭原则。 (2)访问者模式将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。 (3)访问者模式让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。 访问者模式的缺点访问者模式的主要缺点如下: (1)增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了开闭原则的要求。 (2)破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。 访问者模式的适用环境在以下情况下可以考虑使用访问者模式： (1)一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者模式中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作 (2)需要对一个对象结构中的对象进行很多不同的且不相关的操作，并需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得用户可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。 (3)对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 本章小结(1)访问者模式用于表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。 (2)访问者模式包含抽象访问者、具体访问者、抽象元素、具体元素和对象结构5个角色。其中，抽象访问者为对象结构中的每一个具体元素类声明一个访问操作；具体访问者实现了每个由抽象访问者声明的操作；抽象元素声明了一个Accept()方法，用于接受访问者的访问操作；具体元素实现了Accept()方法，在Accept()方法中调用访问者的访问方法以便完成对一个元素的操作；对象结构是一个元素的集合，用于存放元素对象，并且提供了遍历其内部元素的方法。 (3)访问者模式的主要优点是增加新的访问操作很方便；将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中，类的职责更加清晰；让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。其主要缺点是增加新的元素类很困难，而且可能破坏系统的封装性。 (4)访问者模式适用的环境：一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作；需要对一个对象结构中的对象进行很多不同的且不相关的操作，并需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类；对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 (5)在访问者模式中，包含一个用于存储元素对象集合的对象结构，通常可以使用迭代器来遍历对象结构，同时具体元素之间可以存在整体与部分关系，有些元素作为容器对象，有些元素作为成员对象，因此可以使用组合模式来组织元素。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 桥接模式为什么是结构型模式？ 某个类存在两个独立变化的维度，用毛笔和蜡笔怎么举例？ 型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分。怎么理解？ 任意组合子类，从而获得多维度组合对象。怎么理解？ 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时在设计初期也需要考虑适配器模式，特别是那些涉及大量第三方应用接口的情况。怎么理解？ 用抽象关联来取代传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系。原来的多层继承是怎么写的？存在什么问题？怎么用桥接模式取代？ 将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。怎么做到？ 可以针对两个维度的抽象层编程，在程序运行时再动态地确定两个维度的子类，动态地组合对象。怎么理解？ 本章导学 桥接模式是一种很实用的结构型设计模式，如果系统中某个类存在两个独立变化的维度，通过桥接模式可以将这两个维度分离出来，使两者可以独立扩展。桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联来取代传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。 本章将学习桥接模式的定义与结构，通过实例来加深对桥接模式的理解，并学习如何将其应用于实际项目的开发，还将学习如何实现桥接模式和适配器模式的联用。 本章知识点 桥接模式的定义 桥接模式的结构 桥接模式的实现 桥接模式的应用 桥接模式与适配器模式联用 桥接模式的优缺点 桥接模式的适用环境 桥接模式概述毛笔和蜡笔是两种很常见的文具，它们都归属于画笔。假如需要大、中、小3种型号的画笔，能够分别绘制12种不同的颜色，如果使用蜡笔，需要准备3 ×12 = 36支，如果使用毛笔，只需要提供3种型号的毛笔，外加一个包含12种颜色的调色板即可，涉及的对象个数仅为3 + 12 = 15，远远小于36，却能实现与36支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有12种颜色，对应的蜡笔需增加12支，而毛笔只需增加一支。图1所示为毛笔与蜡笔示意图。 图1 毛笔与蜡笔示意图 通过分析不难得知：在蜡笔中，颜色和型号两个不同的变化维度（即两个不同的变化原因，如图2所示）耦合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度；但在毛笔中，颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响。如果使用软件工程中的术语，可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也更为方便。在软件开发中，也有一种设计模式可以用来处理与画笔类似的具有多变化维度的情况，它就是桥接模式。 图2 画笔中存在的两个独立变化维度示意图 在桥接模式中，将两个独立变化的维度（例如画笔的型号与颜色）设计为两个独立的继承等级结构，而不是将二者耦合在一起形成多层继承结构。桥接模式在抽象层建立起一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。 桥接模式的定义如下：1将抽象部分与它的实现部分解耦，使得两者都能够独立变化。 桥接模式是一种对象结构型模式，它又被称为柄体（Handle and Body）模式或接口（Interface）模式。桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵话，并易于扩展，同时有效控制了系统中类的个数。 桥接模式的结构与实现桥接模式的结构桥接模式的结构如图3所示。 图3 桥接模式结构图 由图3可知，桥接模式包含以下4个角色： (1)Abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，既可以包含抽象业务方法，也可以包含具体业务方法。 (2)RefinedAbstraction（扩充抽象类）：它扩充由Abstraction定义的接口，通常情况下不再是抽象类而是具体类，实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。 (3)Implementor（实现类接口）：它是定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同。一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而将具体实现交给其子类。通过关联关系，在Abstraction中不仅可以拥有自己的方法，还可以调用Implementor中定义的方法，使用关联关系来替代继承关系。 (4)ConcreteImplementor（具体实现类）：它具体实现了Implementor接口，在不同的Concretelmplementor中提供基本操作的不同实现，在程序运行时，Concretelmplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。 桥接模式的实现桥接模式是一个非常实用的设计模式，在桥接模式中体现了很多面向对象设计原则的思想，包括单一职责原则、开闭原则、合成复用原则、里氏代换原则、依赖倒转原则等。熟悉桥接模式将有助于用户深入理解这些设计原则，也有助于形成正确的设计思想和培养良好的设计风格。 在使用桥接模式时，用户首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。通常情况下，将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。例如：对于毛笔而言，由于型号是其固有的维度，因此可以设计一个抽象的毛笔类，在该类中声明并部分实现毛笔的业务方法，而将各种型号的毛笔作为其子类；颜色是毛笔的另一个维度，由于它与毛笔之间存在一种“设置”的关系，因此可以提供一个抽象的颜色接口，而将具体的颜色作为实现该接口的子类。在此，型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分，结构示意图如图4所示。 图4 毛笔结构示意图 在图4中，如果需要增加一种新型号的毛笔，只需扩展左侧的“抽象部分”，增加一个新的扩充抽象类；如果需要增加一种新的颜色，只需扩展右侧的“实现部分”，增加一个新的具体实现类。扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。 在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了降低两者之间的耦合度，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分”维度，典型的实现类接口代码如下：1234interface Implementor&#123; void OperationImpl();&#125; 在实现Implementor接口的子类ConcreteImplementor中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法，代码如下：1234567class ConcreteImplementor&#123; public void OperationImpl() &#123; // 具体业务方法的实现 &#125;&#125; 对于另一“抽象部分”维度而言，其典型的抽象类代码如下：1234567891011abstract class Abstraction&#123; protected Implementor impl; // 定义实现类接口对象 public void SetImpl(Implementor impl) &#123; this.impl = impl; &#125; public abstract void Operation(); // 声明抽象业务方法&#125; 在抽象类Abstraction中定义了一个实现类接口类型的成员对象impl，再通过Setter方法或者构造方法以注入的方式给该对象赋值，一般将该对象的可见性定义为protected，以便在其子类中访问Implementor的方法，其子类一般称为扩充抽象类或细化抽象类（RefinedAbstraction），典型的RefinedAbstraction类代码如下：123456789class RefinedAbstraction : Abstraction&#123; public override void Operation() &#123; // 业务代码 impl.OperationImpl(); // 调用实现类的方法 // 业务代码 &#125;&#125; 对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态地确定两个维度的子类，动态地组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。 桥接模式的应用实例下面通过一个应用实例来进一步学习和理解桥接模式。 1.实例说明 某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示BMP、JPG、GIF、PNG等多种格式的文件，并且能够在Windows、Linux、UNIX等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵（Matrix），然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。另外，系统需具有较好的扩展性，以便在将来支持新的文件格式和操作系统。试使用桥接模式设计该跨平台图像浏览系统。 2.实例类图 通过分析，本实例的结构如图5所示。 图5 跨平台图像浏览系统结构图 在图5中，Image充当抽象类，其子类JPGImage、PNGImage、BMPImage和GIFImage充当扩充抽象类；Imagelmp充当实现类接口，其子类WindowsImp、LinuxImp和UnixImp充当具体实现类。 3.实例代码 (1)Matrix：像素矩阵类，它是一个辅助类，各种格式的图像文件最终都会被转化为像素矩阵，不同的操作系统提供不同的方式显示像素矩阵。1234567namespace BridgeSample&#123; class Matrix &#123; // 代码省略 &#125;&#125; (2)ImageImp：抽象操作系统实现类，充当实现类接口。 1234567namespace BridgeSample&#123; interface ImageImp &#123; void DoPaint(Matrix m); // 显示像素矩阵m &#125;&#125; (3)WindowsImp：Windows操作系统实现类，充当具体实现类。 12345678910111213using System;namespace BridgeSample&#123; class WindowsImp : ImageImp &#123; public void DoPaint(Matrix m) &#123; // 调用Windows系统的绘制函数绘制像素矩阵 Console.Write("在Windows操作系统中显示图像："); &#125; &#125;&#125; (4)LinuxImp：Linux操作系统实现类，充当具体实现类。 12345678910111213using System;namespace BridgeSample&#123; class LinuxImp : ImageImp &#123; public void DoPaint(Matrix m) &#123; // 调用Linux系统的绘制函数绘制像素矩阵 Console.Write("在Linux操作系统中显示图像："); &#125; &#125;&#125; (5)UnixImp：UNIX操作系统实现类，充当具体实现类。 12345678910111213using System;namespace BridgeSample&#123; class UnixImp : ImageImp &#123; public void DoPaint(Matrix m) &#123; // 调用Unix系统的绘制函数绘制像素矩阵 Console.Write("在Unix操作系统中显示图像："); &#125; &#125;&#125; (6)Image：抽象图像类，充当抽象类。 123456789101112131415namespace BridgeSample&#123; abstract class Image &#123; protected ImageImp imp; // 注入实现类接口对象 public void SetImageImp(ImageImp imp) &#123; this.imp = imp; &#125; public abstract void ParseFile(string fileName); &#125;&#125; (7)JPGImage：JPG格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class JPGImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析JPG文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为JPG。",fileName); &#125; &#125;&#125; (8)PNGImage：PNG格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class PNGImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析PNG文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为PNG。", fileName); &#125; &#125;&#125; (9)BMPImage：BMP格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class BMPImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析BMP文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为BMP。", fileName); &#125; &#125;&#125; (10)GIFImage：GIF格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class GIFImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析GIF文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为GIF。", fileName); &#125; &#125;&#125; (11)配置文件App.config：在配置文件中存储了具体扩充抽象类和具体实现类类名。 123456789&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;!--RefinedAbstraction--&gt; &lt;add key="image" value="BridgeSample.JPGImage"/&gt; &lt;!--ConcreteImplementor--&gt; &lt;add key="os" value="BridgeSample.WindowsImp"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (12)Program：客户端测试类。 123456789101112131415161718192021222324252627using System;using System.Configuration;using System.Reflection;namespace BridgeSample&#123; class Program &#123; static void Main(string[] args) &#123; Image image; ImageImp imp; // 读取配置文件 string imageType = ConfigurationManager.AppSettings["image"]; string osType = ConfigurationManager.AppSettings["os"]; // 反射生成对象 image = (Image)Assembly.Load("BridgeSample").CreateInstance(imageType); imp = (ImageImp)Assembly.Load("BridgeSample").CreateInstance(osType); image.SetImageImp(imp); image.ParseFile("中国地图"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1在Windows操作系统中显示图像：中国地图，格式为JPG。 如果需要更换图像文件格式或者更换操作系统，只需修改配置文件即可。例如将配置文件App.config改为：123456789&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;!--RefinedAbstraction--&gt; &lt;add key="image" value="BridgeSample.BMPImage"/&gt; &lt;!--ConcreteImplementor--&gt; &lt;add key="os" value="BridgeSample.LinuxImp"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 再次运行程序，输出结果为:1在Linux操作系统中显示图像：中国地图，格式为BMP。 在实际使用时，可以通过分析图像文件格式扩展名来确定具体的文件格式，在程序运行时获取操作系统信息来确定操作系统类型，无须使用配置文件。当增加新的图像文件格式或者操作系统时，对于原有系统源代码无须做任何修改，只需增加一个对应的扩充抽象类或具体实现类即可，系统具有较好的可扩展性，完全符合开闭原则。 桥接模式与适配器模式联用在软件开发中，适配器模式通常可以与桥接模式联合使用。适配器模式可以解决两个已有接口间不兼容的问题，在这种情况下被适配的类往往是一个黑盒子，有时不想也不能改变这个被适配的类，也不能控制其扩展。适配器模式通常用于现有系统与第三方产品功能的集成，采用增加适配器的方式将第三方类集成到系统中。桥接模式则不同，用户可以通过接口继承或类继承的方式对系统进行扩展。 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时在设计初期也需要考虑适配器模式，特别是那些涉及大量第三方应用接口的情况。 下面通过一个实例来说明适配器模式和桥接模式的联合使用： 在某系统的报表处理模块中，需要将报表显示和数据输出分开，系统可以有多种报表显示方式也可以有多种数据输出方式，例如可以将数据输出为文本文件，也可以输出为Excel文件，如果需要输出为Excel文件，则需要调用与Excel相关的API，而这个API是现有系统所不具备的，该API由厂商提供。因此，可以同时使用适配器模式和桥接模式来设计该模块，如图6所示。 图6 桥接模式与适配器模式联用示意图 桥接模式的优缺点与适用环境桥接模式的应用很广泛，在软件开发中如果一个类或一个系统有多个变化维度，都可以尝试使用桥接模式对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。 桥接模式的优点桥接模式的主要优点如下： (1)分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自具有自己的子类，以便任意组合子类，从而获得多维度组合对象。 (2)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了单一职责原则，复用性较差，且类的个数非常多。桥接模式是比多层继承方案更好的解决方法，它极大地减少了子类的个数。 (3)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则。 桥接模式的缺点桥接模式的主要缺点如下： (1)桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。 (2)桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。 桥接模式的适用环境在以下情况下可以考虑使用桥接模式： (1)如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。 (2)抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态地将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 (3)一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展。 (4)对于不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 本章小结(1)桥接模式将抽象部分与它的实现部分解耦，使得两者都能够独立变化。桥接模式是一种对象结构型模式。 (2)桥接模式包含抽象类、扩充抽象类、实现类接口和具体实现类4个角色。其中，抽象类定义了一个实现类接口类型的对象并维护该对象；扩充抽象类扩充由抽象类定义的接口，实现了在抽象类中声明的抽象业务方法；实现类接口声明了一些基本操作，而将具体实现交给其子类完成；具体实现类具体实现了实现类接口，在不同的具体实现类中提供基本操作的不同实现。 (3)桥接模式的主要优点在于可以分离抽象接口及其实现部分，它是比多层继承方案更好的解决方法，极大地减少了子类的个数。此外，桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则。其主要缺点在于会增加系统的理解与设计难度，且正确识别出系统中两个独立变化的维度并不是一件容易的事情。 (4)桥接模式适用的环境：需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系；抽象部分和实现部分可以以继承的方式独立扩展而互不影响；一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展；不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统。 (5)在使用桥接模式进行系统设计时，如果需要重用第三方应用接口，可与适配器模式一起联用，既可以保证系统的扩展性，又可以将第三方类集成到系统中。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2019%2F09%2F24%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 抽象装饰类继承抽象构件类并引用它。怎么理解？ 对于扩展一个对象的功能，装饰模式比继承更加灵活。为什么？ 装饰模式为什么是一种结构型模式？ 装饰模式包含抽象构件、具体构件、抽象装饰类和具体装饰类4个角色。这四种如何组合？ 半透明模式和透明模式有什么区别？ 本章导学 装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和用于装饰的具体装饰类都可以独立变化，增加新的具体构件类和具体装饰类都非常方便，符合开闭原则。 本章将学习装饰模式的定义与结构，通过实例学习装饰模式的使用，并学习透明装饰模式和半透明装饰模式的区别与实现。 本章知识点 装饰模式的定义 装饰模式的结构 装饰模式的实现 装饰模式的应用 装饰模式的优缺点 装饰模式的适用环境 透明装饰模式与半透明装饰模式 装饰模式概述对新房进行装修并没有改变房屋用于居住的本质，但它可以让房子变得更漂亮、更温馨、更实用、更能满足居家的需求。在软件设计中，也有一种类似新房装修的技术可以对已有对象（新房）的功能进行扩展（装修），以获得更加符合用户需求的对象，使得对象具有更加强大的功能，这种技术在设计模式中被称为装饰模式。 装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为，在现实生活中，这种情况也到处存在。例如一张照片，用户可以不改变照片本身，给它增加一个相框，使它具有防潮的功能，还可以根据需要给它增加不同类型的相框，甚至可以在一个小相框的外面再套一个大相框，如图1所示。 图1 装饰模式示意图 在软件设计中，装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能。 装饰模式的定义如下：1动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。 装饰模式是一种对象结构型模式，它以对客户透明的方式动态地给一个对象附加上更多的责任，可以在不需要创建更多子类的情况下，让对象的功能得以扩展。 装饰模式的结构与实现装饰模式的结构装饰模式的结构如图2所示。 图2 装饰模式结构图 由图2可知，装饰模式包含以下4个角色。 (1)Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 (2)ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）。 (3)Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责通常在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 (4)ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法，以扩展对象的行为。 装饰模式的实现在装饰模式中，抽象构件类一般设计为抽象类或者接口，在其中声明了抽象业务方法，当然，也可以在抽象构件类中实现一些所有具体构件类都共有的业务方法。抽象构件类的典型代码如下：1234abstract class Component&#123; public abstract void Operation(); &#125; 具体构件类作为抽象构件类的子类实现了在抽象构件类中声明的业务方法，通常在具体构件类中只提供基本功能的实现，一些复杂的功能需通过装饰类来进行扩展。其典型代码如下：1234567class ConcreteComponent : Component&#123; public override void Operation() &#123; // 基本功能的实现 &#125;&#125; 装饰模式的核心在于抽象装饰类的设计，其典型代码如下：1234567891011121314151617class Decorator : Component&#123; // 维持一个对抽象构建对象的引用 private Component component; // 注入一个抽象构件类型的对象 public Decorator(Component component) &#123; this.component = component; &#125; public override void Operation() &#123; // 调用原有业务方法 component.Operation(); &#125;&#125; 在抽象装饰类Decorator中定义了一个Component类型的对象component，维持一个对抽象构件对象的引用，并可以通过构造方法或Setter方法将一个Component类型的对象注入进来，同时由于Decorator类实现了抽象构件Component接口，因此需要实现在其中声明的业务方法Operation()。值得注意的是，在Decorator中并未真正实现Operation()方法，而是调用原有component对象的Operation()方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。 在Decorator的子类（即具体装饰类）中将继承Operation()方法并根据需要进行扩展，典型的具体装饰类代码如下：12345678910111213141516171819class ConcreteDecorator : Decorator&#123; public ConcreteDecorator (Component component) : base(component) &#123; &#125; public override void Operation() &#123; base.Operation(); // 调用原有业务方法 AddedBehavior(); // 调用新增业务方法 &#125; // 新增业务方法 public void AddedBehavior() &#123; // 功能的扩展 &#125;&#125; 在具体装饰类中可以调用抽象装饰类的Operation()方法，同时可以定义新的业务方法，例如AddedBehavior()，如果该方法不希望客户端单独调用，可以将其可见性设为私有（private）。 由于在抽象装饰类Decorator中注入的是Component类型的对象，因此可以将一个具体构件对象注入其中，再通过具体装饰类来进行装饰。此外，还可以将一个已经装饰过的Decorator子类的对象再注入其中进行多次装饰，从而实现对原有功能的多次扩展。 装饰模式的应用实例下面通过一个应用实例来进一步学习和理解装饰模式。 1.实例说明 某软件公司基于面向对象技术开发了一套图形界面构件库——VisualComponent，该构件库提供了大量的基本构件，如窗体、文本框、列表框等，由于在使用该构件库时，用户经常要求定制一些特殊的显示效果，如带滚动条的窗体、带黑色边框的文本框、既带滚动条又带黑色边框的列表框等，因此经常需要对该构件库进行扩展以增强其功能。现使用装饰模式来设计该图形界面构件库。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 图形界面构件库结构图 在图3中，VisualComponent充当抽象构件类，其子类Window、TextBox、ListBox充当具体构件类，VisualComponent类的另一个子类ComponentDecorator充当抽象装饰类，ComponentDecorator的子类ScrollBarDecorator和BlackBorderDecorator充当具体装饰类。 3.实例代码 (1)VisualComponent：抽象界面构件类，充当抽象构件类。为了突出与模式相关的核心代码，在本实例中对控件代码进行了大量的简化。1234567namespace DecoratorSample&#123; abstract class VisualComponent &#123; public abstract void Display(); &#125;&#125; (2)Window：窗体类，充当具体构件类。 123456789101112using System;namespace DecoratorSample&#123; class Window : VisualComponent &#123; public override void Display() &#123; Console.WriteLine("显示窗体！"); &#125; &#125;&#125; (3)TextBox：文本框类，充当具体构件类。 123456789101112using System;namespace DecoratorSample&#123; class TextBox : VisualComponent &#123; public override void Display() &#123; Console.WriteLine("显示文本框！"); &#125; &#125;&#125; (4)ListBox：列表框类，充当具体构件类。 123456789101112using System;namespace DecoratorSample&#123; class ListBox : VisualComponent &#123; public override void Display() &#123; Console.WriteLine("显示列表框！"); &#125; &#125;&#125; (5)ComponentDecorator：构件装饰类，充当抽象装饰类。 123456789101112131415161718namespace DecoratorSample&#123; class ComponentDecorator : VisualComponent &#123; private VisualComponent component; // 维持对抽象构件类型对象的引用 // 注入抽象构件类型的对象 public ComponentDecorator(VisualComponent component) &#123; this.component = component; &#125; public override void Display() &#123; component.Display(); &#125; &#125;&#125; (6)ScrollBarDecorator：滚动条装饰类，充当具体装饰类。 1234567891011121314151617181920212223using System;namespace DecoratorSample&#123; class ScrollBarDecorator : ComponentDecorator &#123; public ScrollBarDecorator(VisualComponent component) : base(component) &#123; &#125; public override void Display() &#123; this.SetScrollBar(); base.Display(); &#125; public void SetScrollBar() &#123; Console.WriteLine("为构件增加滚动条！"); &#125; &#125;&#125; (7)BlackBorderDecorator：黑色边框装饰类，充当具体装饰类。 1234567891011121314151617181920212223using System;namespace DecoratorSample&#123; class BlackBorderDecorator : ComponentDecorator &#123; public BlackBorderDecorator(VisualComponent component) : base(component) &#123; &#125; public override void Display() &#123; this.SetBlackBorder(); base.Display(); &#125; public void SetBlackBorder() &#123; Console.WriteLine("为构件增加黑色边框！"); &#125; &#125;&#125; (8)Program：客户端测试类。 1234567891011121314151617using System;namespace DecoratorSample&#123; class Program &#123; static void Main(string[] args) &#123; VisualComponent component, componentSB; // 使用抽象构件定义 component = new Window(); // 定义具体构件 componentSB = new ScrollBarDecorator(component); // 定义装饰后的构件 componentSB.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12为构件增加滚动条！ 显示窗体！ 在客户端代码中，先创建一个Window类型的具体构件对象component，然后将component作为构造函数的参数注入具体装饰类ScrollBarDecorator中，得到一个装饰之后的对象componentSB，在调用componentSB的Display()方法后将得到一个有滚动条的窗体。如果希望得到一个既有滚动条又有黑色边框的窗体，不需要对原有类库进行任何修改，只需将客户端代码修改如下：1234567891011121314151617using System;namespace DecoratorSample&#123; class Program &#123; static void Main(string[] args) &#123; VisualComponent component, componentSB, componentBB; // 使用抽象构件定义 component = new Window(); // 定义具体构件 componentSB = new ScrollBarDecorator(component); // 定义装饰后的构件 componentBB = new BlackBorderDecorator(componentSB); // 将装饰了一次之后的对象继续注入到另一个装饰类中，进行第二次装饰 componentBB.Display(); Console.Read(); &#125; &#125;&#125; 再次编译并运行程序，输出结果如下：123为构件增加黑色边框！为构件增加滚动条！显示窗体！ 在上述客户端代码中，将装饰了一次之后的componentSB对象注入另一个装饰类BlackBorderDecorator中实现第二次装饰，得到一个经过两次装饰的对象componentBB，再调用componentBB的Display()方法即可得到一个既有滚动条又有黑色边框的窗体。 如果需要在原有系统中增加一个新的具体构件类或者新的具体装饰类，无须修改现有类库代码，只需将它们分别作为抽象构件类或者抽象装饰类的子类即可。 透明装饰模式与半透明装饰模式在装饰模式中，具体装饰类通过新增成员变量或者成员方法来扩展具体构件类的功能。在标准的装饰模式中，新增行为需在原有业务方法中调用，无论是具体构件对象还是装饰过的构件对象，对于客户端而言都是透明的，这种装饰模式被称为透明（Transparent）装饰模式。但是在某些情况下，有些新增行为可能需要单独被调用，此时，客户端不能再一致性地处理装饰之前的对象和装饰之后的对象，这种装饰模式被称为半透明（Semi-transparent）装饰模式。下面将对这两种装饰模式进行较为详细的介绍。 1.透明装饰模式 在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。即应该使用以下代码：1234Component component_o, component_d; // 使用抽象构件类型定义对象component_o = new ConcreteComponent();component_d = new ConcreteDecorator(component_o);component_d.Operation(); 而不应该使用以下代码：12ConcreteComponent component_o; // 使用具体构件类型定义对象component_o = new ConcreteComponent(); 或12ConcreteComponent component_d; // 使用具体构件类型定义对象component_d = new ConcreteComponent(); 对于多次装饰而言，在客户端中存在以下代码片段：12345678...Component component_o, component_d1,component_d2; // 全部使用抽象构件定义component_o = new ConcreteComponent();component_d1 = new ConcreteDecorator(component_o);component_d2 = new ConcreteDecorator(component_d1);component_d2.Operation();// 无法单独调用component_d2的AddedBehavior()方法... 使用抽象构件类型Component定义全部具体构件对象和具体装饰对象，客户端可以一致地使用这些对象，因此符合透明装饰模式的要求。 透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象。在实现透明装饰模式时，要求具体装饰类的Operation()方法覆盖抽象装饰类的Operation()方法，除了调用原有对象的Operation()外还需要调用新增的AddedBehavior()方法来增加新行为。但是由于在抽象构件中并没有声明AddedBehavior()方法，因此，无法在客户端单独调用该方法，在本章上一节图形界面构件库的设计方案中使用的就是透明装饰模式。 2.半透明装饰模式 透明装饰模式的设计难度较大，而且有时需要单独调用新增的业务方法。为了能够调用到新增方法，不得不用具体装饰类型来定义装饰之后的对象，而具体构件可以继续使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。也就是说，对于客户端而言，对具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。客户端代码片段如下：123456789...Component component_o; // 使用抽象构件类型定义component_o = new ConcreteComponent();component_o.Operation();ConcreteDecorator component_d; // 使用具体装饰类型定义component_d = new ConcreteDecorator(component_o);component_d.Operation();component_d.AddedBehavior(); // 单独调用新增业务方法... 半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。在实现半透明的装饰模式时，只需在具体装饰类中增加一个独立的AddedBehavior()方法来封装相应的业务处理即可，由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用AddedBehavior()方法。 装饰模式的优缺点与适用环境装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和用于装饰的具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。使用装饰模式将大大减少子类的个数，让系统扩展起来更加方便，而且更容易维护，是取代继承复用的有效方式之一。在软件开发中，装饰模式得到了较为广泛的应用。 装饰模式的优点装饰模式的主要优点如下： (1)对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。 (2)装饰模式可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。 (3)装饰模式可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。 (4)在装饰模式中，具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，且原有类库代码无须改变，符合开闭原则。 装饰模式的缺点装饰模式的主要缺点如下: (1)使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能。 (2)装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也更困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 装饰模式的适用环境在以下情况下可以考虑使用装饰模式： (1)在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 (2)当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两种：第一种是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二种是因为类已定义为不能被继承（例如C#语言中的密封类，即使用sealed关键字修饰的类）。 本章小结(1)装饰模式用于动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案，它是一种对象结构型模式。 (2)装饰模式包含抽象构件、具体构件、抽象装饰类和具体装饰类4个角色。其中，抽象构件是具体构件类和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法；具体构件实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）；抽象装饰类用于给具体构件增加职责，但是具体职责在其子类中实现；具体装饰类负责向构件添加新的职责。 (3)装饰模式的主要优点是在扩展功能时比继承更加灵活，不会导致类的个数急剧增加；它通过一种动态的方式来扩展一个对象的功能，可以对一个对象进行多次装饰，还通过使用不同的具体装饰类以及这些装饰类的排列组合，创造出很多不同行为的组合，得到功能更为强大的对象；具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，且原有类库代码无须改变，符合开闭原则。其主要缺点是使用装饰模式进行系统设计时将产生很多小对象；此外，装饰模式比继承更加易于出错，排错也更困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 (4)装饰模式适用的环境：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时也可以使用装饰模式。 (5)装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰类型的对象，从而可以单独调用在具体装饰类中新增的方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 组合模式使用面向对象的方式来处理树形结构。经常会遇到什么树形结构？ 组合模式的设计动机是用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象。怎么理解？ 组合模式为什么是结构型模式？ 组合模式的关键在于定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。怎么理解？ 组合模式是怎么使用递归的？ 容器构件维护一个列表。怎么理解？ 本章导学 组合模式关注那些包含叶子构件和容器构件的结构以及它们的组织形式，在叶子构件中不包含成员对象，而容器构件中可以包含成员对象，这些对象通过递归组合可构成一个树形结构。组合模式使用面向对象的方式来处理树形结构，它为叶子构件和容器构件提供了一个公共的抽象构件类，客户端可以针对抽象构件进行处理，而无须关心所操作的是叶子构件还是容器构件。 本章将学习组合模式的定义与结构，通过如何处理树形结构来学习组合模式的实现，结合实例学习如何在软件开发中应用组合模式，还将学习透明组合模式和安全组合模式的结构与区别。 本章知识点 组合模式的定义 组合模式的结构 组合模式的实现 组合模式的应用 组合模式的优缺点 组合模式的适用环境 透明组合模式与安全组合模式 组合模式概述树形结构在软件中随处可见，例如操作系统中的目录结构、应用软件中的菜单结构、办公系统中的公司组织结构等。在Windows操作系统中，就存在着图1所示的目录结构。 图1 Windows目录结构 与图1相对应的树形目录结构如图2所示。 图2 树形目录结构示意图 在图2中包含文件（黄色结点，例如“小龙女.jpg”和“九阴真经.txt”）和文件夹（白色结点，例如“我的资料”和“图像文件”）两类不同的元素，其中，在文件夹中可以包含文件，还可以继续包含子文件夹，但是在文件中不能再包含子文件或者子文件夹。在此，可以称文件夹为容器（Container），而不同类型的文件是其成员，又称为叶子（Leaf）。 对于所有与目录结构相类似的树形结构，当容器对象（例如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，例如子文件夹和文件）并调用执行，牵一而动百，其中使用了递归调用的机制来对整个结构进行处理。由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使程序非常复杂。 组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。 组合模式的定义如下：1组合多个对象形成树形结构以表示具有部分——整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。 组合模式又称为“部分-整体”（Part-Whole）模式，属于对象结构型模式，它将对象组织到树形结构中，可以用来描述整体与部分的关系。 组合模式的结构与实现组合模式的结构组合模式的结构如图3所示。 图3 组合模式结构图 由图3可知，组合模式包含以下3个角色。 (1)Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。 (2)Leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。 (3)Composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。 组合模式的实现组合模式的关键在于定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立了一种聚合关联关系，在容器对象中既可以包含叶子，又可以包含容器，以此实现递归组合，形成一个树形结构。 如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，造成代码维护困难、可扩展性差等问题，组合模式的使用将在一定程度上解决这些问题。 下面通过简单的示例代码来分析组合模式的各个角色的用途和实现。 对于组合模式中的抽象构件角色，其典型代码如下：1234567abstract class Component&#123; public abstract void Add(Component c); // 增加成员 public abstract void Remove(Component c); // 删除成员 public abstract Component GetChild(int i); // 获取成员 public abstract void Operation(); // 业务方法&#125; 通常将抽象构件类设计为接口或抽象类，将所有子类共有方法的声明和实现放在抽象构件类中。对于客户端而言，将针对抽象构件编程，而无须关心其具体子类是容器构件还是叶子构件。 如果继承抽象构件的是叶子构件，其典型代码如下：1234567891011121314151617181920212223class Leaf : Component&#123; public override void Add(Component c) &#123; // 异常处理或错误提示 &#125; public override void Remove(Component c) &#123; // 异常处理或错误提示 &#125; public override Component GetChild(int i) &#123; // 异常处理或错误提示 return null; &#125; public override void Operation() &#123; // 叶子构件具体业务方法的实现 &#125;&#125; 作为抽象构件类的子类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示。显然，这会给叶子构件的实现带来麻烦。 如果继承抽象构件的是容器构件，其典型代码如下：12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;class Composite : Component&#123; private List&lt;Component&gt; list = new List&lt;Component&gt;(); public override void Add(Component c) &#123; list.Add(c); &#125; public override void Remove(Component c) &#123; list.Remove(c); &#125; public override Component GetChild(int i) &#123; return (Component)list[i]; &#125; public override void Operation() &#123; foreach(Object obj in list) &#123; // 容器构件具体业务方法的实现，将递归调用成员构件的业务方法 ((Component)obj).Operation(); &#125; &#125;&#125; 在容器构件中实现了在抽象构件中声明的所有方法，既包括业务方法，也包括用于访问和管理成员子构件的方法，如Add()、Remove()和GetChild()等方法。需要注意的是，在实现具体业务方法时，由于容器构件充当的是容器角色，包含成员构件，因此它将调用其成员构件的业务方法。在组合模式结构中，由于容器构件中仍然可以包含容器构件，因此在对容器构件进行处理时需要使用递归算法，即在容器构件的Operation()方法中递归调用其成员构件的Operation()方法。 组合模式的应用实例下面通过一个应用实例来进一步学习和理解组合模式。 1.实例说明 某软件公司要开发一个杀毒（AntiVirus）软件，该软件既可以对某个文件夹（Folder）杀毒，也可以对某个指定的文件（File）进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件（ImageFile）和文本文件（TextFile）的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 杀毒软件框架设计结构图 在图4中，AbstractFile充当抽象构件类，Folder充当容器构件类，ImageFile、TextFile和VideoFile充当叶子构件类。 3.实例代码 (1)AbstractFile：抽象文件类，充当抽象构件类。 12345678910namespace CompositeSample&#123; abstract class AbstractFile &#123; public abstract void Add(AbstractFile file); public abstract void Remove(AbstractFile file); public abstract AbstractFile GetChild(int i); public abstract void KillVirus(); &#125;&#125; (2)ImageFile：图像文件类，充当叶子构件类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace CompositeSample&#123; class ImageFile : AbstractFile &#123; private string name; public ImageFile(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override void Remove(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override AbstractFile GetChild(int i) &#123; Console.WriteLine("对不起，不支持该方法！"); return null; &#125; public override void KillVirus() &#123; // 模拟杀毒 Console.WriteLine("----对图像文件'&#123;0&#125;'进行杀毒",name); &#125; &#125;&#125; (3)TextFile：文本文件类，充当叶子构件类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace CompositeSample&#123; class TextFile : AbstractFile &#123; private string name; public TextFile(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override void Remove(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override AbstractFile GetChild(int i) &#123; Console.WriteLine("对不起，不支持该方法！"); return null; &#125; public override void KillVirus() &#123; // 模拟杀毒 Console.WriteLine("----对文本文件'&#123;0&#125;'进行杀毒",name); &#125; &#125;&#125; (4)VideoFile：视频文件类，充当叶子构件类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace CompositeSample&#123; class VideoFile : AbstractFile &#123; private string name; public VideoFile(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override void Remove(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override AbstractFile GetChild(int i) &#123; Console.WriteLine("对不起，不支持该方法！"); return null; &#125; public override void KillVirus() &#123; // 模拟杀毒 Console.WriteLine("----对视频文件'&#123;0&#125;'进行杀毒",name); &#125; &#125;&#125; (5)Folder：文件夹类，充当容器构件类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;namespace CompositeSample&#123; class Folder : AbstractFile &#123; // 定义集合fileList，用于存储AbstractFile类型的成员 private List&lt;AbstractFile&gt; fileList = new List&lt;AbstractFile&gt;(); private string name; public Folder(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; fileList.Add(file); &#125; public override void Remove(AbstractFile file) &#123; fileList.Remove(file); &#125; public override AbstractFile GetChild(int i) &#123; return (AbstractFile)fileList[i]; &#125; public override void KillVirus() &#123; Console.WriteLine("****对文件夹'&#123;0&#125;'进行杀毒",name); // 模拟杀毒 // 递归调用成员构件的killVirus()方法 foreach(Object obj in fileList) &#123; ((AbstractFile)obj).KillVirus(); &#125; &#125; &#125;&#125; (6)Program：客户端测试类。 1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;namespace CompositeSample&#123; class Program &#123; static void Main(string[] args) &#123; // 针对抽象构件编程 AbstractFile file1, file2, file3, file4, file5, folder1, folder2, folder3, folder4; folder1 = new Folder("我的资料"); folder2 = new Folder("图像文件"); folder3 = new Folder("文本文件"); folder4 = new Folder("视频文件"); file1 = new ImageFile("小龙女.jpg"); file2 = new ImageFile("张无忌.gif"); file3 = new TextFile("九阴真经.txt"); file4 = new TextFile("葵花宝典.doc"); file5 = new VideoFile("神雕侠侣.rmvb"); folder2.Add(file1); folder2.Add(file2); folder3.Add(file3); folder3.Add(file4); folder4.Add(file5); folder1.Add(folder2); folder1.Add(folder3); folder1.Add(folder4); // 从“我的资料”节点开始进行杀毒操作 folder1.KillVirus(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结构如下：123456789****对文件夹&apos;我的资料&apos;进行杀毒****对文件夹&apos;图像文件&apos;进行杀毒----对图像文件&apos;小龙女.jpg&apos;进行杀毒----对图像文件&apos;张无忌.gif&apos;进行杀毒****对文件夹&apos;文本文件&apos;进行杀毒----对文本文件&apos;九阴真经.txt&apos;进行杀毒----对文本文件&apos;葵花宝典.doc&apos;进行杀毒****对文件夹&apos;视频文件&apos;进行杀毒----对视频文件&apos;神雕侠侣.rmvb&apos;进行杀毒 在本实例中，抽象构件类声明了所有方法，包括用于管理和访问子构件的方法，如Add()方法和Remove()方法等，因此，在ImageFile等叶子构件类中实现这些方法时必须进行相应的异常处理或错误提示。在容器构件类Folder的KillVirus()方法中将递归调用其成员对象的KillVirus()方法，从而实现对整个树形结构的遍历。 如果需要更换操作结点，例如只对文件夹“文本文件”进行杀毒，客户端代码只需修改一行即可，将代码：1folder1.KillVirus(); 改为：1folder3.KillVirus(); 输出结果如下：123****对文件夹&apos;文本文件&apos;进行杀毒 ----对文本文件&apos;九阴真经.txt&apos;进行杀毒 ----对文本文件&apos;葵花宝典.doc&apos;进行杀毒 在具体实现时，可以创建图形化界面让用户来选择所需操作的根结点，无须修改源代码，符合开闭原则，客户端无须关心结点的层次结构，可以对所选结点进行统一处理，从而提高系统的灵活性。 透明组合模式与安全组合模式组合模式根据抽象构件类的定义形式不同，可以分为透明组合模式和安全组合模式。 1.透明组合模式 在透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法，包括Add()、Remove()、以及GetChild()等方法，如图5所示，这样做的好处是确保了所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象。 图5 透明组合模式结构图 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供Add()、Remove()及GetChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。 2.安全组合模式 在安全组合模式中，抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法，如图6所示。这样做是安全的，因为根本向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。 图6 安全组合模式结构图 安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，容器构件中用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高。 组合模式的优缺点与适用环境组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。 组合模式的优点组合模式的主要优点如下： (1)组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制。 (2)客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 (3)在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则。 (4)为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 组合模式的缺点组合模式的主要缺点如下： 在增加新构件时很难对容器中的构件类型进行限制。有时希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。 组合模式的适用环境在以下情况下可以考虑使用组合模式： (1)在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 (2)在一个使用面向对象语言开发的系统中需要处理一个树形结构。 (3)在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。 本章小结(1)组合模式用于组合多个对象形成树形结构以表示具有部分整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。组合模式又可以称为“部分整体”模式，是一种对象结构型模式。 (2)组合模式包含抽象构件、叶子构件和容器构件3个角色。其中，抽象构件为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现；叶子构件在组合结构中表示叶子结点对象，叶子结点没有子结点；容器构件在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现了在抽象构件中定义的行为。 (3)组合模式的主要优点在于可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制；客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码;增加新的容器构件和叶子构件都很方便。其主要缺点是在增加新构件时很难对容器中的构件类型进行限制。 (4)组合模式适用的环境：在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们；在一个使用面向对象语言开发的系统中需要处理一个树形结构；在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。 (5)根据抽象构件类的定义形式不同，组合模式可以分为透明组合模式和安全组合模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2019%2F09%2F23%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 适配器模式和代理模式有什么区别？ 本章导学 结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构，在GOF设计模式中包含7种结构型设计模式，它们适用于不同的环境，使用不同的方式组合类与对象，使之可以协同工作。 适配器模式是一种使用频率非常高的结构型设计模式，如果在系统中存在不兼容的接口，可以通过引入一个适配器来使得原本因为接口不兼容而不能一起工作的两个类可以协同工作。 本章将对7种结构型模式进行简要的介绍，学习适配器模式的定义，掌握类适配器模式和对象适配器模式的结构与实现方式，并结合实例学习如何在实际软件项目开发中应用适配器模式，还将学习缺省适配器模式和双向适配器模式等适配器模式的扩展形式。 本章知识点 适配器模式的定义 适配器模式的结构 适配器模式的实现 适配器模式的应用 适配器模式的优缺点 适配器模式的适用环境 缺省适配器模式 双向适配器 结构型模式在面向对象软件系统中，每个类/对象都承担了一定的职责，它们可以相互协作，实现一些复杂的功能。结构型模式（Structural Pattern）关注如何将现有类或对象组织在一起形成更加强大的结构。不同的结构型模式从不同的角度组合类或对象，它们在尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。 结构型模式可以描述两种不同的东西：类与类的实例（即对象）。根据这一点，结构型模式可以分为类结构型模式和对象结构型模式。类结构型模式关心类的组合，由多个类组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；而对象结构型模式关心类与对象的组合，通过关联关系，在一个类中定义另一个类的实例对象，然后通过该对象调用相应的方法。根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此，大部分结构型模式都是对象结构型模式。 在GoF设计模式中包含7种结构型模式，它们的名称、定义、学习难度和使用频率如表1所示。 表1 结构型模式一览表 名 称 定 义 学习难度 使用频率 适配器模式(Adapter Pattern) 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。 ★★☆☆☆ ★★★★☆ 桥接模式(Bridge Pattern) 将抽象部分与它的实现部分解耦，使得两者都能够独立变化。 ★★★☆☆ ★★★☆☆ 组合模式(Composite Pattern) 组合多个对象形成树形结构，以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。 ★★★☆☆ ★★★★☆ 装饰模式(Decorator Pattern) 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。 ★★★☆☆ ★★★☆☆ 外观模式(Facade Pattern) 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 ★☆☆☆☆ ★★★★★ 享元模式(Flyweight Pattern) 运用共享技术有效地支持大量细粒度对象的复用。 ★★★★☆ ★☆☆☆☆ 代理模式(Proxy Pattern) 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 ★★★☆☆ ★★★★☆ 适配器模式概述众所周知，我们国家的生活用电的电压是220V，而笔记本电脑、手机等电子设备的工作电压没有这么高，为了使笔记本电脑、手机等设备可以使用220V的生活用电，需要电源适配器（AC Adapter)，也就是充电器或变压器，有了这个电源适配器，生活用电和笔记本电脑就可以兼容了。在这里，电源适配器充当了一个适配器的角色，如图1所示。 图1 电源适配器示意图 在软件开发中，有时也存在类似这种不兼容的情况，也可以像引入一个电源适配器那样引入一个称之为适配器的角色来协调这些存在不兼容的结构，这种设计方案即为适配器。 与电源适配器相似，在适配器模式中引入了一个被称为适配器（Adapter）的包装类，而它所包装的对象称为适配者（Adaptee），即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。 适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。 适配器模式的定义如下：1将一个类的接口转换成客户希望的另一个接口适配器模式让那些接口不兼容的类可以一起工作。 适配器模式的别名为包装器（Wrapper）模式，它既可以作为类结构型模式，也可以作为对象结构型模式，在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。 适配器模式的结构与实现适配器模式包括类适配器和对象适配器。在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。下面分别对两种适配器进行结构分析。 适配器模式的结构类适配器模式的结构如图2所示。 图2 类适配器模式结构图 对象适配器模式的结构如图3所示。 图3 对象适配器模式结构图 由图2和图3可知，适配器模式包含以下3个角色。 (1)Target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。在类适配器中，由于C#语言不支持多重继承，它只能是接口。 (2)Adapter（适配器类）：它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 (3)Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码。 适配器模式的实现由于适配器模式包括类适配器模式和对象适配器模式两种形式，下面分别介绍这两种适配器模式的实现机制。 1.类适配器 根据图2所示的类适配器模式结构图，在类适配器中，适配者类Adaptee没有Request()方法，而客户期待这个方法，但在适配者类中实现了SpecificRequest()方法，该方法所提供的实现正是客户所需要的。为了使客户能够使用适配者类，提供了一个中间类，即适配器类Adapter，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的Request()方法中调用所继承的适配者类的SpecificRequest()方法，达到了适配的目的。因为适配器类与适配者类是继承关系，所以这种适配器模式称为类适配器模式。典型的类适配器代码如下：1234567class Adapter : Adaptee, Target&#123; public void Request() &#123; base.SpecificRequest(); &#125;&#125; 2.对象适配器 根据图3所示的对象适配器模式结构图，在对象适配器中，客户端需要调用Request()方法，而适配者类Adaptee没有该方法，但是它所提供的SpecificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的Request()方法中调用适配者的SpecificRequest()方法。因为适配器类与适配者类是关联关系（也可称为委派关系），所以这种适配器模式称为对象适配器模式。典型的对象适配器代码如下：1234567891011121314class Adapter : Target&#123; private Adaptee adaptee; // 维持一个对适配器对象的引用 public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void Request() &#123; adaptee.SpecificRequest(); // 转发调用 &#125;&#125; 适配器模式可以将一个类的接口和另一个类的接口匹配起来，使用的前提是不能或不想修改原来的适配者接口和抽象目标类接口。例如，购买了一些第三方类库或控件，但是没有源代码，此时使用适配器模式可以统一对象访问接口。 适配器模式更多的是强调对代码的组织，而不是功能的实现。在实际开发中，对象适配器的使用频率更高。 适配器模式的应用实例下面通过一个应用实例进一步学习和理解适配器模式。 1.实例说明 在为某学校开发教务管理系统时，开发人员发现需要对学生成绩进行排序和查找，该系统的设计人员已经开发了一个成绩操作接口ScoreOperation，在该接口中声明了排序方法Sort(int[])和查找方法Search(int[], int)，为了提高排序和查找的效率，开发人员决定重用现有算法库中的快速排序算法类QuickSortClass和二分查找算法类BinarySearchClass，其中，QuickSortClass的QuickSort(int[])方法实现了快速排序，BinarySearchClass的BinarySearch(int[], int)方法实现了二分查找。由于某些原因，开发人员已经找不到该算法库的源代码，无法直接通过复制和粘贴操作来重用其中的代码；而且部分开发人员已经针对ScoreOperation接口编程，如果再要求对该接口进行修改或要求大家直接使用QuickSortClass类和BinarySearchClass类将导致大量代码需要修改。现使用适配器模式设计一个系统，在不修改已有代码的前提下将类QuickSortClass和类BinarySearchClass的相关方法适配到ScoreOperation接口中。 2.实例类图 通过分析，本实例采用对象适配器模式来实现，如图4所示。 图4 算法库重用结构图 在图4中，ScoreOperation接口充当抽象目标，QuickSortClass和BinarySearchClass类充当适配者，OperationAdapter充当适配器。 3.实例代码 (1)ScoreOperation：抽象成绩操作类，充当目标接口。12345678namespace AdapterSample&#123; interface ScoreOperation &#123; int[] Sort(int[] array); // 成绩排序 int Search(int[] array, int key); // 成绩查找 &#125;&#125; (2)QuickSortClass：快速排序类，充当适配者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace AdapterSample&#123; class QuickSortClass &#123; public int[] QuickSort(int[] array) &#123; Sort(array,0,array.Length - 1); return array; &#125; public void Sort(int[] array, int p, int r) &#123; int q = 0; if (p &lt; r) &#123; q = Partition(array,p,r); Sort(array,p,q - 1); Sort(array,q + 1,r); &#125; &#125; public int Partition(int[] a, int p, int r) &#123; int x = a[r]; int j = p - 1; for (int i = p;i &lt;= r - 1;i++) &#123; if (a[i] &lt;= x) &#123; j++; Swap(a,j,i); &#125; &#125; Swap(a,j + 1,r); return j + 1; &#125; public void Swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125;&#125; (3)BinarySearchClass：二分查找类，充当适配者。 1234567891011121314151617181920212223242526272829namespace AdapterSample&#123; class BinarySearchClass &#123; public int BinarySearch(int[] array, int key) &#123; int low = 0; int high = array.Length -1; while (low &lt;= high) &#123; int mid = (low + high) / 2; int midVal = array[mid]; if (midVal &lt; key) &#123; low = mid +1; &#125; else if (midVal &gt; key) &#123; high = mid -1; &#125; else &#123; return 1; // 找到元素返回1 &#125; &#125; return -1; // 未找到元素返回-1 &#125; &#125;&#125; (4)OperationAdapter：操作适配器，充当适配器。 123456789101112131415161718192021222324namespace AdapterSample&#123; class OperationAdapter : ScoreOperation &#123; private QuickSortClass sortObj; // 定义适配者QuickSortClass对象 private BinarySearchClass searchObj; // 定义适配者BinarySearchClass对象 public OperationAdapter() &#123; sortObj = new QuickSortClass(); searchObj = new BinarySearchClass(); &#125; public int[] Sort(int[] array) &#123; return sortObj.QuickSort(array); // 调用适配者类QuickSortClass的排序方法 &#125; public int Search(int[] array, int key) &#123; return searchObj.BinarySearch(array, key); // 调用适配者类BinarySearchClass的查找方法 &#125; &#125;&#125; (5)配置文件App.config：在配置文件中存储了适配器类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="adapter" value="AdapterSample.OperationAdapter"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (6)Program：客户端测试类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Configuration;using System.Reflection;namespace AdapterSample&#123; class Program &#123; static void Main(string[] args) &#123; ScoreOperation operation; // 针对抽象目标接口编程 // 读取配置文件 string adapterType = ConfigurationManager.AppSettings["adapter"]; // 反射生成对象 operation = (ScoreOperation)Assembly.Load("AdapterSample").CreateInstance(adapterType); int[] scores = &#123;84,76,50,69,90,91,88,96&#125;; // 定义成绩数组 int[] result; int score; Console.WriteLine("成绩排序结果："); result = operation.Sort(scores); // 遍历输出成绩 foreach (int i in result) &#123; Console.Write(i + ","); &#125; Console.WriteLine(); Console.WriteLine("查找成绩90："); score = operation.Search(result,90); if (score != -1) &#123; Console.WriteLine("找到成绩90。"); &#125; else &#123; Console.WriteLine("没有找到成绩90。"); &#125; Console.WriteLine("查找成绩92："); score = operation.Search(result,92); if (score != -1) &#123; Console.WriteLine("找到成绩92。"); &#125; else &#123; Console.WriteLine("没有找到成绩92。"); &#125; Console.Read(); &#125; &#125;&#125; 4．结果及分析 编译并运行程序，输出结果如下：123456成绩排序结果：50,69,76,84,88,90,91,96, 查找成绩 90：找到成绩 90。 查找成绩 92：没有找到成绩92。 在本实例中使用了对象适配器模式，同时引入了配置文件，将适配器类的类名存储在配置文件App.config中。如果需要使用其他排序算法类和查找算法类，可以增加一个新的适配器类，使用新的适配器来适配新的算法，原有代码无须修改。通过引入配置文件和反射机制，可以在不修改客户端代码的情况下使用新的适配器，无须修改源代码，符合开闭原则。 缺省适配器模式缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。 缺省适配器模式（Default Adapter Pattern）的定义如下：1当不需要实现一个妾口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。 缺省适配器模式的结构如图5所示。 图5 缺省适配器模式结构图 由图5可知，在缺省适配器模式中，包含以下3个角色。 (1)ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。 (2)AbstractServiceClass（缺省适配器)：缺省适配器模式的核心类，使用空方法的形式实现了在Servicelnterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。 (3)ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中声明的所有方法，而对于一些无须使用的方法不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适已器类中定义的方法。 其中，缺省适配器类的典型代码片段如下：123456abstract class AbstractServiceClass : ServiceInterface&#123; public void ServiceMethod1()&#123;&#125; // 空方法 public void ServiceMethod2()&#123;&#125; // 空方法 public void ServiceMethod3()&#123;&#125; // 空方法&#125; 双向适配器在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器，其结构示意图如图6所示。 图6 双向适配器模式示意图 双向适配器的实现较为复杂，其典型代码如下：1234567891011121314151617181920212223242526public class Adapter : Target, Adaptee&#123; // 同时维持对抽象目标类和适配者的引用 private Target target; private Adaptee adaptee; public Adapter(Target target) &#123; this.target = target; &#125; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void Request() &#123; adaptee.SpecificRequest(); &#125; public void SpecificRequest() &#123; target.Request(); &#125;&#125; 适配器模式的优点无论是对象适配器模式还是类适配器模式都具有以下优点： (1)将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 (2)增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 (3)灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则。 具体来说，类适配器模式还具有以下优点： 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对象适配器模式还具有以下优点： (1)一个对象适配器可以把多个不同的适配者适配到同一个目标。 (2)对象适配器模式可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据里氏代换原则，适配者的子类也可通过该适配器进行适配。 适配器模式的缺点类适配器模式的主要缺点如下： (1)对于C#Java等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。 (2)适配者类不能为最终类，例如在C#中不能为sealed类。 (3)在C#Java等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。 对象适配器模式的主要缺点如下： 与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把该适配者类的子类当作真正的适配者进行适配，其实现过程较为复杂。 适配器模式的适用环境在以下情况下可以考虑使用适配器模式： (1)系统需要使用一些现有的类，而这些类的接口（例如方法名）不符合系统的需要，甚至没有这些类的源代码。 (2)创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。 本章小结(1)结构型模式关注如何将现有类或对象组设计模式中一共包含7种结构型模式。 (2)适配器模式将一个类的接口转换成客户希望的另一个接口，适配器模式让那些接口不兼容的类可以一起工作。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 (3)适配器模式包含目标抽象类、适配器类和适配者类3个角色。其中，目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类；适配器类可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配；适配者类即被适配的角色 (4)适配器模式的主要优点是将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构；增加了类的透明性和复用性且让系统的灵活性和展性都非常好，此外，在类适配器模式中置换一些适配者的方法很方便;通过对象适配器模式可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类。类适配器模式的主要缺点是一次最多只能适配一个适配者类，不能同时适配多个适配者；适配者类不能为最终类，且类适配器模式中的目标抽象类只能为接口，不能为类。对象适配器模式的主要缺点是在适配器中置换适配者类的某些方法比较麻烦。 (5)适配器模式适用的环境：系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码;想创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。 (6)缺省适配器模式是指当不需要实现一个接口所提供的所有方法时，可先设计一个日象类实现该接口，并为接口中的每个方法提供一个默认实现(空方法)，那么该抽象类的子 类可以有选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况。 (7)在使用对象适配器的过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，该适配器就是一个双向适配器。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是基本方法？什么是模板方法？ 模板方法模式为什么是类行为型模式？ 钩子方法的引入使得子类可以控制父类的行为。怎么实现的？ 本章导学 模板方法模式是结构最简单的行为型设计模式，它是一种类行为模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供了一个称为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法模式提供了具体的模板方法来定义算法结构，而具体步骤的实现可以在其子类中完成。 本章将学习模板方法模式的定义与结构，学习模板方法模式中所包含的几种不同的方法，并通过实例来学习模板方法模式的应用，学会如何在实际软件项目开发中合理地使用模板方法模式。 本章知识点 模板方法模式的定义 模板方法模式的结构 模板方法模式的实现 模板方法模式的应用。 模板方法模式的优缺点 模板方法模式的适用环境 钩子方法的使用 模板方法模式概述在现实生活中，很多事情都包含几个实现步骤，例如请客吃饭，无论吃什么，一般都包含点单、吃东西、买单等几个步骤，通常情况下这几个步骤的次序是：点单-&gt;吃东西-&gt;买单。在这3个步骤中，点单和买单大同小异，最大的区别在于第二步——吃什么，吃面条和吃满汉全席可大不相同。请客吃饭示意图如图1所示。 图1 请客吃饭示意图 在软件开发中，开发人员有时也会遇到类似的情况，某个方法的实现需要多个步骤（类似“请客”），其中有些步骤是固定的（类似“点单”和“买单”)，而有些步骤并不固定，存在可变性（类似“吃东西”）。为了提高代码的复用性和系统的灵活性，可以使用一种称为模板方法模式的设计模式来对这类情况进行设计。在模板方法模式中，将实现功能的每一个步骤所对应的方法称为基本方法（例如“点单”、“吃东西”和“买单”），而调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法（例如“请客”）。在模板方法模式中，可以将相同的代码放在父类中，例如将模板方法“请客”以及基本方法“点单”和“买单”的实现放在父类中，而对于基本方法“吃东西”，在父类中只做一个声明，将其具体实现放在不同的子类中，在一个子类中提供“吃面条”的实现，而另一个子类提供“吃满汉全席”的实现。通过使用模板方法模式，一方面提高了代码的复用性；另一方面还可以利用面向对象的多态性，在运行时选择一种具体子类，实现完整的“请客”方法，提高系统的灵活性和可扩展性。 模板方法模式的定义如下：1定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。 模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。 模板方法模式的结构与实现模板方法模式的结构模板方法模式的结构比较简单，其核心是抽象类和其中的模板方法的设计，其结构如由图2可知，模板方法模式包含以下两个角色。 图2 模板方法模式结构图 (1)AbstracClass（抽象类）：在抽象类中定义了一系列基本操作（Primitive Operations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。 (2)ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作，以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。 模板方法模式的实现在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。一个设计师负责给出一个算法的轮廓和框架，另一些设计师则负责给出这个算法的各个逻辑步骤。实现这些具体逻辑步骤的方法即为基本方法，而将这些基本方法汇总起来的方法即为模板方法，模板方法模式的名字也因此而来。下面详细介绍模板方法和基本方法。 1.模板方法 一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此，模板方法模式中的抽象层只能是抽象类，而不是接口。 2.基本方法 基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为3种，即抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。 (1)抽象方法：一个抽象方法由抽象类声明、其具体子类实现。在C#语言中，一个抽象方法以abstract关键字标识。 (2)具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。 (3)钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常，在父类中给出的实现是一个空实现（可使用virtual关键字将其定义为虚函数），并以该空实现作为方法的默认实现，当然，钩子方法也可以提供一个非空的默认实现。 在模板方法模式中，钩子方法有两类：第一类钩子方法可以与一些具体步骤“挂钩”，以实现在不同条件下执行模板方法中的不同步骤，这类钩子方法的返回类型通常是bool类型，方法名一般为IsXXX()，用于对某个条件进行判断，如果条件满足，则执行某一步骤，否则不执行，代码片段如下：12345678910111213141516171819...// 模板方法public void TemplateMethod()&#123; Open(); Display(); // 通过钩子方法来确定某步骤是否执行 if (IsPrint) &#123; Print(); &#125;&#125;// 钩子方法public bool IsPrint()&#123; return true;&#125;... 在该段代码中，IsPrint()方法即钩子方法，它可以决定Print()方法是否执行，一般情况下，钩子方法的返回值为true，如果不希望某方法执行，可以在其子类中覆盖钩子方法，将其返回值改为false即可，这种类型的钩子方法可以控制方法的执行，对一个算法进行约束。 还有一类钩子方法就是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法，与抽象方法相比，这类钩子方法的好处在于子类如果没有覆盖父类中定义的钩子方法，编译可以正常通过，但是如果没有覆盖父类中声明的抽象方法，编译将报错。 在模板方法模式中，抽象类的典型代码如下：12345678910111213141516171819202122232425abstract class AbstracClass&#123; // 模板方法 public void TemplateMethod() &#123; PrimitiveOperation1(); PrimitiveOperation2(); PrimitiveOperation3(); &#125; // 基本方法——具体方法 public void PrimitiveOperation1() &#123; // 实现代码 &#125; // 基本方法——抽象方法 public abstract void PrimitiveOperation2(); // 基本方法——钩子方法 public virtual void PrimitiveOperation3() &#123; &#125;&#125; 在抽象类中，模板方法TemplateMethod()定义了算法的框架，在模板方法中调用基本方法以实现完整的算法，每一个基本方法（如PrimitiveOperation1()、PrimitiveOperation2()等）均实现了算法的一部分，对于所有子类都相同的基本方法可以在父类提供具体实现，例如PrimitiveOperation1()，否则在父类声明为抽象方法或钩子方法，由不同的子类提供不同的实现，例如PrimitiveOperation2()和PrimitiveOperation3()。 用户可在抽象类的子类中提供抽象步骤的实现，也可覆盖父类中已经实现的具体方法，具体子类的典型代码如下：123456789101112class ConcreteClass : AbstracClass&#123; public override void PrimitiveOperation2() &#123; // 实现代码 &#125; public override void PrimitiveOperation3() &#123; // 实现代码 &#125;&#125; 在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，具体子类的基本方法将覆父类中定义的基本方法，子类的钩子方法将覆盖父类的钩子方法，从而可以通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。 模板方法模式的应用实例下面通过一个应用实例来进一步学习和理解模板方法模式。 1.实例说明 某软件公司要为某银行的业务支撑系统开发一个利息计算模块，利息的计算流程如下：(1)系统根据账号和密码验证用户信息，如果用户信息错误，则系统显示出错提示。(2)如果用户信息正确，则根据用户类型的不同使用不同的利息计算公式计算利息（如活期账户和定期账户具有不同的利息计算公式）。(3)系统显示利息。现使用模板方法模式设计该利息计算模块。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 银行利息计算模块结构图 在图3中，Account充当抽象类角色，CurrentAccount和SavingAccount充当具体子类角色。 3.实例代码 (1)Account：账户类、充当抽象类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;namespace TemplateMethodSample&#123; abstract class Account &#123; // 基本方法——具体方法 public bool Validate(string account, string password) &#123; Console.WriteLine("账号：&#123;0&#125;", account); Console.WriteLine("密码：&#123;0&#125;", password); // 模拟登录 if (account.Equals("张无忌") &amp;&amp; password.Equals("123456")) &#123; return true; &#125; else &#123; return false; &#125; &#125; // 基本方法——抽象方法 public abstract void CalculateInterest(); // 基本方法——具体方法 public void Display() &#123; Console.WriteLine("显示利息！"); &#125; // 模板方法 public void Handle(string account, string password) &#123; if (!Validate(account,password)) &#123; Console.WriteLine("账户或密码错误！"); return; &#125; CalculateInterest(); Display(); &#125; &#125;&#125; (2)CurrentAccount：活期账户类，充当具体子类。 12345678910111213using System;namespace TemplateMethodSample&#123; class CurrentAccount : Account &#123; // 覆盖父类的抽象基本方法 public override void CalculateInterest() &#123; Console.WriteLine("按活期利率计算利息！"); &#125; &#125;&#125; (3)SavingAccount：定期账户类，充当具体子类。 12345678910111213using System;namespace TemplateMethodSample&#123; class SavingAccount : Account &#123; // 覆盖父类的抽象基本方法 public override void CalculateInterest() &#123; Console.WriteLine("按定期利率计算利息！"); &#125; &#125;&#125; (4)配置文件App.config：在配置文件中存储了具体子类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="subClass" value="TemplateMethodSample.CurrentAccount"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (5)Program：客户端测试类。 123456789101112131415161718192021using System;using System.Configuration;using System.Reflection;namespace TemplateMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; Account account; // 读取配置文件 string subClassStr = ConfigurationManager.AppSettings["subClass"]; // 反射生成对象 account = (Account)Assembly.Load("TemplateMethodSample").CreateInstance(subClassStr); account.Handle("张无忌", "123456"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下:1234账号：张无忌 密码：123456 按活期利率计算利息！ 显示利息！ 如果需要更换具体子类，无须修改源代码，只需修改配置文件App.config即可。例如将活期账户（Current Account）改为定期账户（Saving Account），只需将存储在配置文件中的具体子类CurrentAccount改为SavingAccount，代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="subClass" value="TemplateMethodSample.SavingAccount"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 重新运行客户端程序，输出结果如下:1234账号：张无忌 密码：123456 按定期利率计算利息！显示利息！ 如果需要增加新的具体子类（新的账户类型），原有代码无须修改，完全符合开闭原则。 钩子方法的使用在模板方法模式中，父类提供了一个定义算法框架的模板方法，还提供了一系列抽象方法、具体方法和钩子方法，其中，钩子方法的引入使得子类可以控制父类的行为。最简单的钩子方法就是空方法，其代码如下：1public virtual void Display()&#123;&#125; 当然，用户也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。 另一种钩子方法可以实现对其他方法进行约束，这种钩子方法通常返回一个bool类型，即返回true或false，用来判断是否执行某一个基本方法。下面通过一个实例来说明这种钩子方法的使用。 某软件公司要为销售管理系统提供一个数据图表显示功能，该功能的实现包括以下几个步骤：(1)从数据源获取数据。(2)将数据转换为XML格式。(3)以某种图表方式显示XML格式的数据。该功能支持多种数据源和多种图表显示方式，但所有的图表显示操作都基于XML格式的数据，因此可能需要对数据进行转换，如果从数据源获取的数据已经是XML数据，则无须转换。 由于该数据图表显示功能的3个步骤次序是固定的，且存在公共代码（例如数据格式转换代码），满足模板方法模式的适用条件，可以使用模板方法模式对其进行设计。因为数据格式不同，XML数据可以直接显示，而其他格式的数据需要进行转换，因此第(2)步“将数据转换为XML格式”的执行存在不确定性，为了解决这个问题，可以定义一个钩子方法IsNotXMLData()对数据转换方法进行控制。通过分析，该图表显示功能的基本结构如图4所示。 图4 数据图表显示功能结构图 用户可以将公共方法和框架代码放在抽象父类中，其代码如下：12345678910111213141516171819202122232425262728293031323334353637using System;namespace TemplateMethodSample&#123; abstract class DataViewer &#123; // 抽象方法：获取数据 public abstract void GetData(); // 具体方法：转换数据 public void ConvertData() &#123; Console.WriteLine("将数据转换为XML格式。"); &#125; // 抽象方法：显示数据 public abstract void DisplayData(); // 钩子方法：判断是否为XML格式的数据 public virtual bool IsNotXMLData() &#123; return true; &#125; // 模板方法 public void Process() &#123; GetData(); // 如果不是XML格式的数据则进行数据转换 if (IsNotXMLData()) &#123; ConvertData(); &#125; DisplayData(); &#125; &#125;&#125; 在上面的代码中，引入了一个钩子方法IsNotXMLData()，其返回类型为bool类型，在模板方法中通过它来对数据转换方法ConvertData()进行约束，该钩子方法的默认返回值为true，在子类中可以根据实际情况覆盖该方法，其中，用于显示XML格式数据的具体子类XMLDataViewer的代码如下：12345678910111213141516171819202122232425using System;namespace TemplateMethodSample&#123; class XMLDataViewer : DataViewer &#123; // 实现父类方法：获取数据 public override void GetData() &#123; Console.WriteLine("从XML文件中获取数据。"); &#125; // 实现父类方法：显示数据 public override void DisplayData() &#123; Console.WriteLine("以柱状图显示数据。"); &#125; // 覆盖父类的钩子方法 public override bool IsNotXMLData() &#123; return false; &#125; &#125;&#125; 在具体子类XMLDataViewer中覆盖了钩子方法IsNotXMLData()，返回false，表示该数据已为XML格式，无须执行数据转换方法ConvertData()。客户端代码如下：12345678910111213141516using System;namespace TemplateMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; DataViewer dv; dv = new XMLDataViewer(); dv.Process(); Console.Read(); &#125; &#125;&#125; 该程序的运行结果如下：12从XML文件中获取数据。 以柱状图显示数据。 模板方法模式的优缺点与适用环境模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式被广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化、测试流程的设置等）。 模板方法模式的优点模板方法模式的主要优点如下： (1)在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 (2)模板方法模式是一种代码复用技术，在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励用户恰当地使用继承来实现代码复用。 (3)模板方法模式可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 (4)在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 模板方法模式的缺点模板方法模式的主要缺点如下: 模板方法模式需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统会更加庞大，设计也会更加抽象，此时，可结合桥接模式来进行设计。 模板方法模式的适用环境在以下情况下可以考虑使用模板方法模式： (1)对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而将一些可以改变的细节由其子类来实现，即一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 (2)各子类中公共的行为应被提取出来，并集中到一个公共父类中，以避免代码重复。 (3)需要通过子类来决定父类算法中的某个步骤是否执行，实现子类对父类的反向控制。 本章小结(1)在模板方法模式中，定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。 (2)模板方法模式包含抽象类和具体子类两个角色。其中，在抽象类中定义了一系列基本操作并实现了一个模板方法，模板方法用于定义一个算法的框架；具体子类是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。 (3)模板方法模式的主要优点是在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序；提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为；可实现一种反向控制结构，且具有良好的可扩展性，符合单一职责原则和开闭原则。其主要缺点在于需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统会更加庞大，设计也更加抽象。 (4)模板方法模式适用的环境：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现；各子类中公共的行为应被提取出来，并集中到一个公共父类中，以避免代码重复；需要通过子类来决定父类算法中的某个步骤是否执行，实现子类对父类的反向控制。 (5)在模板方法模式中，模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。基本方法是实现算法各个步骤的方法，是模板方法的组成部分，基本方法又可以分为抽象方法、具体方法和钩子方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职责链模式]]></title>
    <url>%2F2019%2F09%2F22%2F%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 行为型模式分为类行为型模式和对象行为型模式两种。两者有什么区别？ 在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。怎么理解？ C#语言中的异常处理（Exceptior Handlers）机制也是职责链模式的典型应用之一，不同的catch子句可以处理不同类型的异常，这些catch子句构成了一条处理异常对象的职责链。怎么理解？ 本章导学 行为型模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。在GoF设计模式中包含11种行为型设计模式，它们适用于不同的环境，用于解决用户在软件设计中面临的不同问题。 在系统中如果存在多个对象可以处理同—请求，可以通过职责链模式将这些处理请求的对象连成一条链，让请求沿着该链进行传递。如果链上的对象可以处理该请求则进行处理，否则将请求转发给下家来处理。职责链模式可以将请求的发送者和接收者解耦，客户端无须关心请求的处理细节和传递过程，只需要将请求提交给职责链即可。 本章将对11种行为型模式进行简要的介绍，并学习职责链模式的定义和结构，通过实例来学习职责链模式的实现以及如何在软件开发中应用职责链模式。 本章知识点 行为型模式 职责链模式的定义 职责链模式的结构 职责链模式的实现 职责链模式的应用 职责链模式的优缺点 职责链模式的适用环境 纯与不纯的职责链模式 行为型模式在软件系统运行时，对象并不是孤立存在的，它们可以通过相互通信协作完成某些功能，一个对象在运行时也将影响其他对象的运行。行为型模式（Behavioral Pattern）关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。行为型模式不仅仅关注类和对象本身，还重点关注它们之间的相互作用和职责划分。 行为型模式分为类行为型模式和对象行为型模式两种，其中，类行为型模式使用继承关系在几个类之间分配行为，主要通过多态等方式来分配父类与子类的职责；对象行为型模式则使用对象的关联关系来分配行为，主要通过对象关联等方式来分配两个或多个类的职责。根据合成复用原则，在系统中复用功能时要尽量使用关联关系来取代继承关系，因此，大部分行为型设计模式都属于对象行为型模式。 在GoF设计模式中包含11种行为型模式，它们的名称、定义、学习难度和使用频率如表1所示。 表1 行为型模式一览表 名 称 定 义 学习难度 使用频率 职责链模式（Chain of Responsibility Pattern） 避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。 ★★★☆☆ ★★☆☆☆ 命令模式（Command Pattern） 将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。 ★★★☆☆ ★★★★☆ 解释器模式（Interpreter Pattern） 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 ★★★★★ ★☆☆☆☆ 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中的各个元素，且不用暴露该对象的内部表示。 ★★★☆☆ ★★★★★ 中介者模式（Mediator Pattern） 定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。 ★★★☆☆ ★★☆☆☆ 备忘录模式（Memento Pattern） 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 ★★☆☆☆ ★★☆☆☆ 观察者模式（Observer Pattern） 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。 ★★★☆☆ ★★★★★ 状态模式（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 ★★★☆☆ ★★★☆☆ 策略模式（Strategy Pattern） 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法可以独立于使用它的客户变化。 ★☆☆☆☆ ★★★★☆ 模板方法模式（Template Method Pattern） 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。 ★★☆☆☆ ★★★☆☆ 访问者模式（Visitor Pattern） 表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 ★★★★☆ ★☆☆☆☆ 职责链模式概述在很多情况下，可以处理某个请求的对象不止一个，例如大学里的奖学金审批，学生在向辅导员提交审批表之后，首先是辅导员签字审批，然后交给系主任签字审批，接着是院长审批，最后可能是校长审批。在这个过程中，奖学金申请表可以看成是一个请求对象，而不同级别的审批者都可以处理该请求对象，除了辅导员之外，学生不需要一一与其他审批者交互，只需要等待结果即可。在审批过程中如果某一个审批者认为不符合条件，则请求中止；否则将请求递交给下一个审批者，最后由校长来确定能否授予奖学金。该过程如图1所示 图1 奖学金审批示意图 在图1中，辅导员、系主任、院长、校长都可以处理奖学金申请表，他们构成了一个处理申请表的链式结构，申请表沿着这条链进行传递，这条链就称为职责链。职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上，将请求的发送者和请求的处理者解耦，这就是职责链模式的模式动机。 图2 职责链模式结构图 由图2可知，职责链模式包含以下两个角色。 (1)Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。每一个处理者的下家还是一个处理者，故在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor）作为其对下家的引用，通过该引用，处理者可以连成一条链。 (2)ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。 职责链模式的实现在职责链模式中，很多对象由每一个对象对其下家的引用连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 职责链模式的核心在于抽象处理者类的设计，抽象处理者的典型代码如下:123456789101112abstract class Handler&#123; // 维持对下家的引用 protected Handler successor; public void SetSuccessor(Handler successor) &#123; this.successor = successor; &#125; public abstract void HandleRequest(string request);&#125; 在上述代码中，抽象处理者类定义了对下家的引用对象，以便将请求转发给下家，该对象的访问符可设为protected，在其子类中可以使用。在抽象处理者类中声明了抽象的请求处理方法，具体实现交由子类完成。 具体处理者是抽象处理者的子类，它有两个作用：一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法HandleRequest()；二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。具体处理者类的典型代码如下：123456789101112131415public ConcreteHandler : Handler&#123; public override void HandleRequest(string request) &#123; if (请求满足条件) &#123; // 处理请求 &#125; else &#123; // 转发请求 this.successor.HandleRequest(request); &#125; &#125;&#125; 在具体处理类中通过对请求进行判断可以做出相应的处理。 需要注意的是，职责链模式并不负责创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。典型的客户端代码片段如下：1234567891011...Handler handler1, handler2, handler3;handler1 = new ConcreteHandlerA();handler2 = new ConcreteHandlerB();handler3 = new ConcreteHandlerC();// 创建职责链handler1.SetSuccessor(handler2);handler2.SetSuccessor(handler3);// 发送请求，请求对象通常为自定义类型handler1.HandleRequest("请求对象");... 职责链模式的应用实例下面通过一个应用实例来进一步学习和理解职责链模式。 1.实例说明 某企业的SCM（Supply Chain Management，供应链管理）系统中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单则需要开董事会讨论决定，如图3所示。图3 采购单分级审批示意图现使用职责链模式设计并实现该系统。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 采购单分级审批结构图 在图4中，抽象类Approver充当抽象处理者（抽象传递者），Director、VicePresident、President和Congress充当具体处理者（具体传递者），PurchaseRequest充当请求者。 3.实例代码 (1)PurchaseRequest：采购单类，充当请求者。 12345678910111213141516171819202122232425262728293031323334namespace CoRSample&#123; class PurchaseRequest &#123; private double amount; // 采购金额 private int number; // 采购单编号 private string purpose; // 采购目的 public PurchaseRequest(double amount, int number, string purpose) &#123; this.amount = amount; this.number = number; this.purpose = purpose; &#125; public double Amount &#123; get &#123; return amount; &#125; set &#123; amount = value; &#125; &#125; public int Number &#123; get &#123; return number; &#125; set &#123; number = value; &#125; &#125; public string Purpose &#123; get &#123; return purpose; &#125; set &#123; purpose = value; &#125; &#125; &#125;&#125; (2)Approver：审判者类，充当抽象处理者。12345678910111213141516171819202122namespace CoRSample&#123; abstract class Approver &#123; protected Approver successor; // 定义后继对象 protected string name; // 审批者姓名 public Approver(string name) &#123; this.name = name; &#125; // 设置后继者 public void SetSuccessor(Approver successor) &#123; this.successor = successor; &#125; // 抽象请求处理方法 public abstract void ProcessRequest(PurchaseRequest request); &#125;&#125; (3)Director：主任类，充当具体处理者。 1234567891011121314151617181920212223using System;namespace CoRSample&#123; class Director : Approver &#123; public Director(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 50000) &#123; Console.WriteLine("主任&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); //处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; (4)VicePresident：副董事长类，充当具体处理类。 123456789101112131415161718192021222324using System;namespace CoRSample&#123; class VicePresident : Approver &#123; public VicePresident(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 100000) &#123; Console.WriteLine("副董事长&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); //处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; (5)President：董事长类，充当具体处理者。 123456789101112131415161718192021222324using System;namespace CoRSample&#123; class President : Approver &#123; public President(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 500000) &#123; Console.WriteLine("董事长&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); //处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; (6)Congress：董事会类，充当具体处理者。1234567891011121314151617using System;namespace CoRSample&#123; class Congress : Approver &#123; public Congress(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; Console.WriteLine("召开董事会审批采购单：&#123;0&#125;，金额：&#123;1&#125;元，采购目的：&#123;2&#125;。",request.Number, request.Amount, request.Purpose); // 处理请求 &#125; &#125;&#125; (7)Program：客户端测试类。 12345678910111213141516171819202122232425262728293031323334353637using System;namespace CoRSample&#123; class Program &#123; static void Main(string[] args) &#123; Approver wjzhang, gyang, jguo, meeting; wjzhang = new Director("张无忌"); gyang = new VicePresident("杨过"); jguo = new President("郭靖"); meeting = new Congress("董事会"); // 创建职责链 wjzhang.SetSuccessor(gyang); gyang.SetSuccessor(jguo); jguo.SetSuccessor(meeting); // 创建采购单 PurchaseRequest pr1 = new PurchaseRequest(45000, 10001, "购买倚天剑"); wjzhang.ProcessRequest(pr1); PurchaseRequest pr2 = new PurchaseRequest(60000, 10002, "购买《葵花宝典》"); wjzhang.ProcessRequest(pr2); PurchaseRequest pr3 = new PurchaseRequest(160000, 10003, "购买《金刚经》"); wjzhang.ProcessRequest(pr3); PurchaseRequest pr4 = new PurchaseRequest(800000, 10004, "购买桃花岛"); wjzhang.ProcessRequest(pr4); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234主任张无忌审批采购单：10001，金额：45000元，采购目的：购买倚天剑。 副董事长杨过审批采购单：10002，金额：60000元，采购目的：购买《葵花宝典》。 董事长郭靖审批采购单：10003，金额：160000元，采购目的：购买《金刚经》。 召开董事会审批采购单：10004，金额：800000元，采购目的：购买桃花岛。 如果需要在系统中增加一个新的具体处理者，如增加一个经理（Manager）角色，可以审批5万元至8万元（不包括8万元）的采购单，需要编写一个新的具体处理者类Manager，作为抽象处理者类Approver的子类，实现在Approver类中声明的抽象处理方法，如果采购金额大于等于8万元，则将请求转发给下家。其代码如下： Manager：经理类，充当具体处理者。 123456789101112131415161718192021222324using System;namespace CoRSample&#123; class Manager : Approver &#123; public Manager(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 80000) &#123; Console.WriteLine("经理&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); // 处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; 由于链的创建过程由客户端负责，因此增加新的具体处理者类对原有类库无任何影响，无须修改已有类的源代码，符合开闭原则。 在客户端代码中，如果要将新的具体请求处理者应用在系统中，需要创建新的具体处理者对象，然后将该对象加入职责链中。在客户端测试代码中增加以下代码：12Approver rhuang;rhuang = new Manager("黄蓉"); 将建链代码改为：12345// 创建职责链wjzhang.SetSuccessor(rhuang); // 将“黄蓉”作为“张无忌”的下家rhuang.SetSuccessor(gyang); //将“杨过”作为“黄蓉”的下家gyang.SetSuccessor(jguo);jguo.SetSuccessor(meeting); 重新编译并运行程序，输出结果如下：1234主任张无忌审批采购单：10001，金额：45000元，采购目的：购买倚天剑 经理黄蓉审批采购单：10002，金额：60000元，采购目的：购买《葵花宝典》。 董事长郭靖审批采购单：10003，金额：160000元，采购目的：购买《金刚经》。 召开董事会审批采购单：10004，金额：800000元，采购目的：购买桃花岛。 纯与不纯的职责链模式职责链模式可分为纯的职责链模式和不纯的职责链模式两种类型。 1.纯的职责链模式 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在上一节的采购单审批实例中应用的是纯的职责链模式。 2.不纯的职责链模式 在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。 在JavaScript的事件浮升（Event Bubbling）处理机制中使用了这种不纯的职责链模式，其基本原理是：当一个事件（例如鼠标单击事件）被触发后，界面组件（例如按钮、文本框等HTML，控件）将检测并调用相应的事件处理方法来处理事件，如果存在对应的事件处理方法则处理该事件，然后将该事件向上一级容器组件（例如DIV、TABLE等）传播，上级容器组件在接收到事件之后可以继续处理此事件并继续向上级容器组件传播，如此反复，直到事件到达顶层容器（例如BODY）组件为止；如果一直传到最顶层容器仍没有事件处理方法，则该事件不予处理。每一级组件在接收到事件时都可以处理此事件，而不论此事件是否在前一级已得到处理，且存在事件未被处理的情况。显然，这是不纯的职责链模式。 职责链模式的优缺点与适用环境职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，用户如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建多个过滤器（Filter）链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等，使用职责链模式可以较好地解决此类问题。C#语言中的异常处理（Exceptior Handlers）机制也是职责链模式的典型应用之一，不同的catch子句可以处理不同类型的异常，这些catch子句构成了一条处理异常对象的职责链。 职责链模式的优点职责链模式的主要优点如下： (1)职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。 (2)请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象之间的相互连接。 (3)在给对象分配职责时，职责链可以带来更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 (4)在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合开闭原则的。 职责链模式的缺点职责链模式的主要缺点如下： (1)由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。 (2)对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定的影响，而且在进行代码调试时不太方便。 (3)如果建链不当，可能会造成循环调用，导致系统陷入死循环。 职责链模式的适用环境在以下情况下可以考虑使用职责链模式： (1)有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。 (2)在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 (3)可动态指定一组对象处理请求，客户端可以动态地创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 本章小结(1)行为型模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。在GoF设计模式中一共包含11种行为型模式。 (2)在职责链模式中，为了避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求，将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。职责链模式是一种对象行为型模式。 (3)职责链模式包含抽象处理者和具体处理者两个角色。其中，抽象处理者定义了一个处理请求的接口，它定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链；具体处理者是抽象处理者的子类，可以处理用户请求，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者进行处理。 (4)职责链模式的主要优点是使得一个对象无须知道是其他哪一个对象处理其请求，降低了系统的耦合度，简化了对象之间的相互连接，给对象职责的分配带来更多的灵活性。同时，增加一个新的具体请求处理者较为方便。职责链模式的主要缺点在于不能保证请求一定会被处理；对于比较长的职责链，系统性能将受到一定影响；如果建链不当，可能会造成循环调用，导致系统陷入死循环。 (5)职责链模式适用的环境：有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求，客户端可以动态地创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 (6)职责链模式可分为纯的职责链模式和不纯的职责链模式两种类型，其中，一个纯的职责链模式要求一个具体处理者对象要么承担全部责任，要么将责任推给下家，一个请求必须被某一个处理者对象所接收；在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 代理模式是常用的结构型设计模式之一，当用户无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。 本章将学习代理模式的定义与结构，学习几种常见的代理模式的类型及其适用环境，学会如何实现简单的代理模式并理解远程代理、虚拟代理、缓冲代理、保护代理和智能引用代理的作用和实现原理。 本章知识点 代理模式的定义 代理模式的结构 代理模式的实现 代理模式的应用 代理模式的优缺点 代理模式的适用环境 远程代理 代理模式概述近年来，代购已逐步成为电子商务的一个重要分支。何谓代购，简单来说就是找人帮忙购买所需要的商品，当然代购者可能需要向实施代购的人支付一定的费用。代购通常分为两种类型：一种是因为在当地买不到某件商品，或者又因为当地这件商品的价格比其他地区的贵，因此托人在其他地区甚至国外购买该商品，然后通过快递发货或者直接携带回来；还有一种代购，由于消费者对想要购买的商品的相关信息缺乏，自己无法确定其实际价值而又不想被商家“宰”，只好委托中介机构帮忙讲价或代买。代购网站为此应运而生，它为消费者提供在线的代购服务，如果看中某国外购物网站上的商品，可以登录代购网站填写代购单并付款，代购网站会帮助购买，然后通过快递公司将商品发送给消费者。商品代购过程如图1所示。 图1 商品代购示意图 在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个被称为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。 代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、虚拟代理、缓冲代理、保护代理和智能引用代理等，后面将学习这些不同的代理形式。 代理模式（Proxy）的定义如下：1给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。 代理模式的结构与实现代理模式的结构代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层。代理模式结构如图2所示。 图2 代理模式结构图 由图2可知，代理模式包含以下3个角色。 (1)Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。 (2)Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以代替真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯地调用真实主题对象中的操作。 (3)RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。 代理模式的实现代理模式的结构图比较简单，但在实际使用和实现过程中要复杂得多，特别是代理类的设计和实现。 抽象主题类声明了真实主题类和代理类的公共方法，它可以是接口、抽象类或具体类，客户端针对抽象主题类编程，一致性地对待真实主题和代理主题。典型的抽象主题类代码如下：1234abstract class Subject&#123; public abstract void Request();&#125; 真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：1234567class RealSubject : Subject&#123; public override void Request() &#123; // 业务方法具体实现代码 &#125;&#125; 代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩展或约束。最简单的代理类实现代码如下：1234567891011121314151617181920212223class Proxy : Subject&#123; // 维持一个对真实主题对象的引用 private RealSubject realSubject = new RealSubject(); public void PreRequest() &#123; ... &#125; public override void Request() &#123; PreRequest(); // 调用真实主题对象的方法 realSubject.Request(); PostRequest(); &#125; public void PostRequest() &#123; ... &#125;&#125; 在实际开发过程中，代理类的实现要比上述代码复杂得多，代理模式根据其目的和实现方式的不同可分为很多种类，对其中常用的几种代理模式的简要说明如下。 (1)远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使（Ambassador）。 (2)虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 (3)保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 (4)缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 (5)智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。 在这些常用的代理模式中，有些代理类的设计非常复杂，例如远程代理类，它封装了底层网络通信和对远程对象的调用，其实现较为复杂。 代理模式的应用实例下面通过一个应用实例来进一步学习和理解代理模式。 1.实例说明 某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：(1)在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统。(2)在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。现使用代理模式设计并实现该收费商务信息查询系统。 2.实例类图 通过分析，可以采用一种间接访问的方式实现该商务信息查询系统的设计，在客户端对象和信息查询对象之间增加一个代理对象，让代理对象来实现身份验证和日志记录等功能，而无须直接对原有的商务信息查询对象进行修改，如图3所示。 图3 商务信息查询系统设计方案示意图 在图3中，客户端对象通过代理对象间接访问具有商务信息查询功能的真实对象，在代理对象中除了调用真实对象的商务信息查询功能外，还增加了身份验证和日志记录等功能。使用代理模式设计该商务信息查询系统，结构如图4所示。 图4 商务信息查询系统结构图 在图4中，业务类AccessValidator用于验证用户身份，业务类Logger用于记录用户查询日志，Searcher充当抽象主题角色，RealSearcher充当真实主题角色，ProxySearcher充当代理主题角色。 3.实例代码 (1)AccessValidator：身份验证类，业务类，它提供方法Validate()来实现身份验证。 123456789101112131415161718192021using System;namespace ProxySample&#123; class AccessValidator &#123; // 模拟实现登录验证 public bool Validate(string userId) &#123; Console.WriteLine("在数据库中验证用户'" + userId + "'是否是合法用户？"); if (userId.Equals("杨过")) &#123; Console.WriteLine("'&#123;0&#125;'登录成功！",userId); return true; &#125; else &#123; Console.WriteLine("'&#123;0&#125;'登录失败！", userId); return false; &#125; &#125; &#125;&#125; (2)Logger：日志记录类，业务类，它提供方法Log()来保存日志。 123456789101112using System;namespace ProxySample&#123; class Logger &#123; // 模拟实现日志记录 public void Log(string userId) &#123; Console.WriteLine("更新数据库，用户'&#123;0&#125;'查询次数加1！",userId); &#125; &#125;&#125; (3)Searcher：抽象查询类，充当抽象主题角色，它声明了DoSearch()方法。1234567namespace ProxySample&#123; interface Searcher &#123; string DoSearch(string userId, string keyword); &#125;&#125; (4)RealSearcher：具体查询类，充当真实主题角色，它实现查询功能，提供方法DoSearch()来查询信息。12345678910111213using System;namespace ProxySample&#123; class RealSearcher : Searcher &#123; // 模拟查询商务信息 public string DoSearch(string userId, string keyword) &#123; Console.WriteLine("用户'&#123;0&#125;'使用关键词'&#123;1&#125;'查询商务信息！",userId,keyword); return "返回具体内容"; &#125; &#125;&#125; (5)ProxySearcher：代理查询类，充当代理主题角色。它是查询代理，维持了对RealSearcher对象、AccessValidator对象和Logger对象的引用。1234567891011121314151617181920212223242526272829303132333435363738namespace ProxySample&#123; class ProxySearcher : Searcher &#123; private RealSearcher searcher = new RealSearcher(); // 维持一个对真实主题的引用 private AccessValidator validator; private Logger logger; public string DoSearch(string userId, string keyword) &#123; // 如果身份验证成功，则执行查询 if (this.Validate(userId)) &#123; string result = searcher.DoSearch(userId, keyword); // 调用真实主题对象的查询方法 this.Log(userId); // 记录查询日志 return result; // 返回查询结果 &#125; else &#123; return null; &#125; &#125; // 创建访问验证对象并调用其Validate()方法实现身份验证 public bool Validate(string userId) &#123; validator = new AccessValidator(); return validator.Validate(userId); &#125; // 创建日志记录对象并调用其Log()方法实现日志记录 public void Log(string userId) &#123; logger = new Logger(); logger.Log(userId); &#125; &#125;&#125; (6)配置文件App.config：在配置文件中存储了代理主题类类名。123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="proxy" value="ProxySample.ProxySearcher"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (7)Program：客户端测试类。12345678910111213141516171819202122using System;using System.Configuration;using System.Reflection;namespace ProxySample&#123; class Program &#123; static void Main(string[] args) &#123; // 读取配置文件 string proxy = ConfigurationManager.AppSettings["proxy"]; // 反射生成对象，针对抽象编程，客户端无须分辨真实主题类和代理类 Searcher searcher; searcher = (Searcher)Assembly.Load("ProxySample").CreateInstance(proxy); String result = searcher.DoSearch("杨过", "玉女心经"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234在数据库中验证用户&apos;杨过&apos;是否是合法用户？&apos;杨过&apos;登录成功！用户&apos;杨过&apos;使用关键词&apos;玉女心经&apos;查询商务信息！更新数据库，用户&apos;杨过&apos;查询次数加1！ 本实例是保护代理和智能引用代理的应用实例，在代理类ProxySearcher中实现对真实主题类的权限控制和引用计数，如果需要在访问真实主题时增加新的访问控制机制和新功能，只需增加一个新的代理类，再修改配置文件，在客户端代码中使用新增代理类即可，源代码无须修改，符合开闭原则。 远程代理远程代理（Remote Proxy）是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速地响应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。 远程代理示意图如图5所示，客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。 在基于.NET平台的分布式技术，例如DCOM（Distribute Component Object Model，分布式组件对象模型）、Web Service中，都应用了远程代理模式。 图5 远程代理示意图 虚拟代理虚拟代理（Virtual Proxy）也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。 通常，在以下两种情况下可以考虑使用虚拟代理： (1)由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。通常，在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。 (2)当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可以被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行 存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。 无论是以上哪种情况，虚拟代理都是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。 缓冲代理缓冲代理（Cache Proxy）也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而避免某些方法的重复执行，优化系统性能。 在微软示例项目PetShop 4.0的业务逻辑层（Business Logic Layer，BLL）中定义了Product、Category、Item等类，它们封装了相关的业务方法，用于调用数据访问层（Data Access Layer，DAL）对象访问数据库，以获取相关数据。为了改进系统性能，PetShop 4.0为这些实现方法增加了缓存机制，引入一个新的对象去控制原来的BLL业务逻辑对象，这些新的对象对应于代理模式中的代理对象。在引入代理模式后，实现了在缓存级别上对业务对象的封装，增强了对业务对象的控制，如果需要访问的数据在缓存中已经存在，则无须再重复执行获取数据的方法，直接返回存储在缓存中的数据即可。由于原有业务对象（真实对象）和新增代理对象暴露在外的方法是一致的，所以对于调用方（即客户端）而言，调用代理对象与真实对象并没有实质的区别。 这些新引入的代理类包括ProductDataProxy、CategoryDataProxy和ItemDataProxy等。下面以PetShop.BLL.Product业务对象为例进行说明，PetShop 4.0为其建立了代理对象ProductDataProxy，并在ProductDataProxy的GetProductsByCategory()方法中调用了业务逻辑层Product类的GetProductsByCategory()方法，同时增加了缓存机制，如图6所示。 图6 PetShop 4.0缓存代理示意图 在ProductDataProxy类中存在以下代码片段：12345678910111213141516171819202122232425262728293031public static class ProductDataProxy&#123; private static readonly int productTimeout = int.Parse(ConfigurationManager.AppSettings ["ProductCacheDuration"]); private static readonly bool enableCaching = bool.Parse(ConfigurationManager. AppSettings["EnableCaching"]); public static IList GetProductsByCategory(string category) &#123; Product product = new Product(); // 如果缓存被禁用，则直接通过product对象来获取数据 if (!enableCaching) &#123; return product.GetProductsByCategory(category); &#125; string key = "product_by_category_" + category; // 从缓存中获取数据 IList data = (IList )HttpRuntime.Cache[key]; // 如果缓存中没有数据则执行如下代码 if (data == null) &#123; data = product.GetProductsByCategory(category); // 通过工厂创建AggregateCacheDependency对象 AggregateCacheDependency cd = DependencyFacade.GetProductDependency (); // 将数据存储在缓存中，并添加必要的AggregateCacheDependency对象 HttpRuntime.Cache.Add(key, data, cd, DateTime.Now.AddHours(product Timeout), Cache.NoSlidingExpiration, CacheItemPriority.High, null); &#125; return data; &#125; ……&#125; 在上述代码中，AggregateCacheDependency是从.NET Framework 2.0开始新增的一个类，它负责监视依赖项对象的集合。当这个集合中的任意一个依赖项对象发生改变时，该依赖项对象对应的缓存对象将被自动移除。在此不对AggregateCacheDependency进行详细说明。 与业务逻辑层Product对象的GetProductsByCategory()方法相比，上述代码增加了缓存机制。当缓存内不存在相关数据项时，直接调用业务逻辑层Product的GetProductsByCategory()方法来获取数据，并将其与对应的AggregateCacheDependency对象一起存储在缓存中。在ProductDataProxy类的每一个业务方法中都实例化了Product类，再调用Product类的相应方法，因此ProductDataProxy与Product之间属于依赖关系，这是标准代理模式的一种变形，可以按照标准代理模式对其进行改进，包括引入高层的抽象接口。 代理模式的优缺点与适用环境代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。代理模式的类型较多，其中远程代理、虚拟代理、保护代理等在软件开发中的应用非常广泛。 代理模式的优点代理模式的共同优点如下： (1)代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 (2)客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。 此外，不同类型的代理模式具有独特的优点，例如： (1)远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率。 (2)虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。 (3)缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 (4)保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。 代理模式的缺点代理模式的主要缺点如下： (1)由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。 (2)实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。 代理模式的适用环境代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的环境： (1)当客户端对象需要访问远程主机中的对象时可以使用远程代理。 (2)当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。 (3)当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。 (4)当需要控制对一个对象的访问，为不同用户提供不同级别的访n权限时可以使用保护代理。 (5)当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。 本章小结(1)代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。代理模式是一种对象结构型模式。 (2)代理模式包含抽象主题角色、代理主题角色和真实主题角色3个角色。其中，抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色包含了对真实主题的引用，可以在任何时候操作真实主题对象；真实主题角色实现了真实的业务操作。 (3)代理模式的主要优点是能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；系统具有较好的灵活性和可扩展性，客户端可以针对抽象主题角色进行编程，增加更换代理类无须修改源代码，符合开闭原则。其主要缺点是有些类型的代理模式可能会造成请求的处理速度变慢；实现代理模式需要一些额外的工作，而且有些代理模式的实现过程较为复杂。 (4)当客户端对象需要访问远程主机中的对象时可以使用远程代理。远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，从而提高系统的整体运行效率。 (5)当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理。虚拟代理可以在一定程度上节省系统的运行开销。 (6)当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 (7)当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。 (8)当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 提供了一个享元池用于存储已经创建好的享元对象。怎么理解？ 本章导学 当系统中存在大量相同或者相似的对象时，享元模式是一种值得考虑的解决方案，它通过共享技术实现相同或相似的细粒度对象的复用，从而节约内存空间，提高系统性能。在享元模式中提供了一个享元池用于存储已经创建好的享元对象，并通过享元工厂类将享元对象提供给客户端使用。 本章将学习享元模式的定义与结构，学习如何设计享元池和享元工厂，并结合实例学习如何实现无外部状态的享元模式以及有外部状态的享元模式。 本章知识点 享元模式的定义 享元模式的结构 享元模式的实现 享元模式的应用 享元模式的优缺点 享元模式的适用环境 有外部状态的享元模式 单纯享元模式与复合享元模式 享元模式概述如果一个软件系统在运行时所创建的相同或相似的对象数量太多，将导致运行代价过高，带来系统资源浪费、性能下降等问题。例如在一个文本字符串中存在很多重复的字符，如果每一个字符都用一个单独的对象来表示，将会占用较多的内存空间，那么如何避免系统中出现大量相同或相似的对象，同时又不影响客户端程序通过面向对象的方式对这些对象进行操作呢？享元模式正是为解决这一类问题而“诞生”。享元模式通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例。在享元模式中，存储这些共享实例对象的地方称为享元池（Flyweight Pool），用户可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，待需要时再从享元池中取出。字符享元对象示意图如图1所示。 图1 字符享元对象示意图 享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态（Intrinsic State）和外部状态（Extrinsic State）。下面对享元的内部状态和外部状态进行简单的介绍。 (1)内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。例如字符的内容，不会随外部环境的变化而变化，无论在任何环境下字符“a”始终是“a”，都不会变成“b”。 (2)外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。例如字符的颜色，可以在不同的地方有不同的颜色，例如有的“a”是红色的，有的“a”是绿色的，字符的大小也是如此，有的“a”是五号字，有的“a”是四号字。而且字符的颜色和大小是两个独立的外部状态，它们可以独立变化，相互之间没有影响，客户端可以在使用时将外部状态注入享元对象中。 正因为区分了内部状态和外部状态，可以将具有相同内部状态的对象存储到享元池中，享元池中的对象是可以实现共享的，需要的时候将对象从享元池中取出，即可实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份。 享元模式的定义如下：1运用共享技术有效地支持大量细粒度对象的复用。 享元模式要求能够被共享的对象必须是细粒度对象，它又称为轻量级模式，享元模式是一种对象结构型模式。 享元模式的结构与实现享元模式的结构享元模式结构较为复杂，通常结合工厂模式一起使用，在它的结构图中包含了一个享元工厂类，其结构如图2所示。 图2 享元模式结构图 由图2可知，享元模式包含以下4个角色。 (1)Flyweight（抽象享元类）：它通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法设置外部数据（外部状态）。 (2)ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象，并在具体享元类中为内部状态提供了存储空间。通常可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 (3)UnsharedConcretelyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，用户可以将不能被共享的子类设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 (4)FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计。当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在），返回新创建的实例并将其存储在享元池中。 享元模式的实现享元类Flyweight的设计是享元模式的要点之一，为了提高系统的可扩展性，通常要定义一个抽象享元类作为所有具体享元类的公共父类。典型的抽象享元类代码如下：1234abstract class Flyweight&#123; public abstract void Operation(string extrinsicState);&#125; 在具体享元类ConcreteFlyweight中要将内部状态和外部状态分开处理，通常将内部状态作为具体享元类的成员变量，而将外部状态通过注入的方式添加到具体享元类中。典型的具体享元类代码如下：12345678910111213141516class ConcreteFlyweight : Flyweight&#123; // 内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的 private string intrinsicState; public ConcreteFlyweight(string intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; // 外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象，在每一次调用时可以传入不同的外部状态 public override void Operation(string extrinsicState) &#123; //实现业务方法 &#125; &#125; 除了可以共享的具体享元类以外，用户在使用享元模式时，有时还需要处理不需要共享的抽象享元类Flyweight的子类，这些子类被定义为非共享具体享元类UnsharedConcreteFlyweight。其典型代码如下：1234567class UnsharedConcreteFlyweight : Flyweight&#123; public override void Operation(string extrinsicState) &#123; // 实现业务方法 &#125;&#125; 在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。典型的享元工厂类的代码如下：1234567891011121314151617181920class FlyweightFactory&#123; // 定义一个Hashtable用于存储享元对象，实现享元池 private Hashtable flyweights = new Hashtable(); public Flyweight GetFlyweight(string key) &#123; // 如果对象存在，则直接从享元池获取 if (flyweights.ContainsKey(key)) &#123; return (Flyweight)flyweights[key]; &#125; else // 如果对象不存在，先创建一个新的对象添加到享元池中，然后返回 &#123; Flyweight fw = new ConcreteFlyweight("state"); flyweights.Add(key,fw); return fw; &#125; &#125;&#125; 享元模式的应用实例下面通过一个应用实例来进一步学习和理解享元模式。 1.实例说明 某软件公司要开发一个围棋软件，其界面效果如图3所示。图3 围棋软件界面效果图该软件公司开发人员通过对围棋软件进行分析发现，在图3中，围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需的内存空间较大，如何降低运行代价、提高系统性能是需要解决的一个问题。为了解决该问题，现使用享元模式来设计该围棋软件的棋子对象。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 围棋棋子结构图 在图4中，IgoChessman充当抽象享元类，BlackIgoChessman和WhiteIgoChessman充当具体享元类，IgoChessmanFactory充当享元工厂类。 3.实例代码 (1)IgoChessman：围棋棋子类，充当抽象享元类。 1234567891011121314using System;namespace FlyweightSample&#123; abstract class IgoChessman &#123; public abstract string GetColor(); public void Display() &#123; Console.WriteLine("棋子颜色：" + this.GetColor()); &#125; &#125;&#125; (2)BlackIgoChessman：黑色棋子类，充当具体享元类。 12345678910namespace FlyweightSample&#123; class BlackIgoChessman : IgoChessman &#123; public override string GetColor() &#123; return "黑色"; &#125; &#125;&#125; (3)WhiteIgoChessman：白色棋子类，充当具体享元类。 12345678910namespace FlyweightSample&#123; class WhiteIgoChessman : IgoChessman &#123; public override string GetColor() &#123; return "白色"; &#125; &#125;&#125; (4)IgoChessmanFactory：围棋棋子工厂类，充当享元工厂类，使用单例模式对其进行设计。 1234567891011121314151617181920212223242526272829303132using System.Collections;namespace FlyweightSample&#123; class IgoChessmanFactory &#123; private static IgoChessmanFactory instance = new IgoChessmanFactory(); private Hashtable ht; // 使用Hashtable来存储享元对象，充当享元池 private IgoChessmanFactory() &#123; ht = new Hashtable(); IgoChessman black, white; black = new BlackIgoChessman(); ht.Add("b", black); white = new WhiteIgoChessman(); ht.Add("w", white); &#125; // 返回享元工厂类的唯一实例 public static IgoChessmanFactory GetInstance() &#123; return instance; &#125; // 通过key来获取存储在Hashtable中的享元对象 public IgoChessman GetIgoChessman(string color) &#123; return (IgoChessman)ht[color]; &#125; &#125;&#125; (5)Program：客户端测试类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace FlyweightSample&#123; class Program &#123; static void Main(string[] args) &#123; IgoChessman black1,black2,black3,white1,white2; IgoChessmanFactory factory; // 获取享元工厂对象 factory = IgoChessmanFactory.GetInstance(); // 通过享元工厂获取三颗黑子 black1 = factory.GetIgoChessman("b"); black2 = factory.GetIgoChessman("b"); black3 = factory.GetIgoChessman("b"); Console.WriteLine("判断两颗黑子是否相同：" + (black1 == black2)); // 通过享元工厂获取两颗白子 white1 = factory.GetIgoChessman("w"); white2 = factory.GetIgoChessman("w"); Console.WriteLine("判断两颗白子是否相同：" + (white1 == white2)); // 显示棋子 black1.Display(); black2.Display(); black3.Display(); white1.Display(); white2.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234567判断两颗黑子是否相同：True判断两颗白子是否相同：True棋子颜色：黑色 棋子颜色：黑色 棋子颜色：黑色 棋子颜色：白色 棋子颜色：白色 从输出结果可以看出，虽然在客户端代码中获取了3个黑子对象和两个白子对象，但是3个黑子的内存地址相同，两个白子的内存地址也相同，也就是说，实际上只有两个对象。在实现享元工厂类时使用了单例模式和简单工厂模式，确保了享元工厂对象的唯一性，并提供了工厂方法向客户端返回享元对象。 有外部状态的享元模式在上一节的应用实例中，对围棋棋子进行进一步分析，不难发现，虽然黑色棋子和白色棋子可以共享，但是它们将显示在棋盘的不同位置，如何让相同的黑子或者白子能够多次重复显示但位于一个棋盘的不同地方？解决方法之一就是将棋子的位置定义为棋子的一个外部状态，在需要时再进行设置。因此，在图4的基础上增加了一个新的类Coordinates（坐标类），用于存储每一个棋子的位置，修改之后的结构如图5所示。 图5 引入外部状态之后的围棋棋子结构图 在图5中，除了增加一个坐标类Coordinates以外，抽象享元类IgoChessman中的Display()方法也将对应增加一个Coordinates类型的参数，用于在显示棋子时指定其坐标。Coordinates类的代码如下：1234567891011121314151617181920212223242526namespace FlyweightSample&#123; class Coordinates &#123; private int x; private int y; public Coordinates(int x, int y) &#123; this.x = x; this.y = y; &#125; public int X &#123; get &#123; return x; &#125; set &#123; x = value; &#125; &#125; public int Y &#123; get &#123; return y; &#125; set &#123; y = value; &#125; &#125; &#125;&#125; 修改之后的IgoChessman类代码如下：1234567891011121314using System;namespace FlyweightSample&#123; abstract class IgoChessman &#123; public abstract string GetColor(); public void Display(Coordinates coord) &#123; Console.WriteLine("棋子颜色：&#123;0&#125;，棋子位置：&#123;1&#125;，&#123;2&#125;", this.GetColor(),coord.X,coord.Y); &#125; &#125;&#125; 将客户端测试代码修改如下：123456789101112131415161718192021222324252627282930313233343536using System;namespace FlyweightSample&#123; class Program &#123; static void Main(string[] args) &#123; IgoChessman black1,black2,black3,white1,white2; IgoChessmanFactory factory; // 获取享元工厂对象 factory = IgoChessmanFactory.GetInstance(); // 通过享元工厂获取三颗黑子 black1 = factory.GetIgoChessman("b"); black2 = factory.GetIgoChessman("b"); black3 = factory.GetIgoChessman("b"); Console.WriteLine("判断两颗黑子是否相同：" + (black1 == black2)); // 通过享元工厂获取两颗白子 white1 = factory.GetIgoChessman("w"); white2 = factory.GetIgoChessman("w"); Console.WriteLine("判断两颗白子是否相同：" + (white1 == white2)); // 显示棋子，同时设置棋子的坐标位置 black1.Display(new Coordinates(1, 2)); black2.Display(new Coordinates(3, 4)); black3.Display(new Coordinates(1, 3)); white1.Display(new Coordinates(2, 5)); white2.Display(new Coordinates(2, 4)); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：1234567判断两颗黑子是否相同：True判断两颗白子是否相同：True棋子颜色：黑色，棋子位置：1，2 棋子颜色：黑色，棋子位置：3，4 棋子颜色：黑色，棋子位置：1，3棋子颜色：白色，棋子位置：2，5棋子颜色：白色，棋子位置：2，4 从输出结果可以看到，在每次调用Display()方法时，都设置了不同的外部状态——坐标值，因此相同的棋子对象虽然具有相同的颜色，但是它们的坐标值不同，将显示在棋盘的不同位置。 单纯享元模式和复合享元模式标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用的过程中，有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式，下面对这两种特殊的享元模式进行简单的介绍。 1.单纯享元模式 在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。单纯享元模式的结构如图6所示。 图6 单纯享元模式结构图 2.复合享元模式 将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。复合享元模式的结构如图7所示。 图7 复合享元模式结构图 通过使用复合享元模式，可以让复合享元类CompositeConcreteFlyweight中所包含的每个单纯享元ConcreteFlyweight都具有相同的外部状态，而这些单纯享元的内部状态往往不同。如果希望为多个内部状态不同的享元对象设置相同的外部状态，可以考虑使用复合享元模式。 享元模式的优缺点与适用环境当系统中存在大量相同或者相似的对象时，享元模式是一种较好的解决方案，它通过共享技术实现相同或相似的细粒度对象的复用，从而节约了内存空间，提高了系统性能。相比其他结构型设计模式，享元模式的使用频率并不算太高，但是作为一种以“节约内存，提高性能”为出发点的设计模式，它在软件开发中还是得到了一定程度的应用。 享元模式的优点享元模式的主要优点如下： (1)享元模式可以减少内存中对象的数量，使得相同或者相似的对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。 (2)在享元模式中，外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。 享元模式的缺点享元模式的主要缺点如下： (1)享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 (2)为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。 享元模式的适用环境在以下情况下可以考虑使用享元模式： (1)一个系统有大量相同或者相似的对象，造成了内存的大量耗费。 (2)对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 (3)在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，在需要多次重复使用享元对象时才值得使用享元模式。 本章小结(1)享元模式运用共享技术有效地支持大量细粒度对象的复用。通过使用享元模式，系统只需使用少量的对象，而这些对象都很相似，状态变化很小，因此可以实现对象的多次复用，享元模式是一种对象结构型模式。 (2)享元模式包含抽象享元类、具体享元类、非共享具体享元类和享元工厂类4个角色。其中，在抽象享元类中声明了具体享元类公共的方法；具体享元类实现了抽象享元接口，为内部状态提供了存储空间；非共享具体享元是不能被共享的抽象享元类的子类；享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。 (3)享元模式的主要优点是可以极大地减少内存中对象的数量，使得相同或相似的对象在内存中只保存一份，从而节约系统资源，提高系统性能。其主要缺点是使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化；此外，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。 (4)享元模式适用的环境：一个系统有大量相同或者相似的对象，造成内存的大量耗费；对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；需要多次重复使用享元对象。 (5)享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态和外部状态。内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。 (6)在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 中介者模式为什么是行为型模式？为什么是迪米特法则的一个典型应用？ 中介者模式的核心在于中介者类的引入，中介者类维护一个同事类的列表。怎么理解？ 像QQ群一样，QQ群维护了其他用户的QQ。怎么理解？ 本章导学 对于对象之间存在复杂交互关系的系统，中介者模式提供了一种简化复杂交互的解决方案，它通过引入中介者，将原本对象之间的两两交互转化为每个对象与中介者之间的交互，中介者可以对对象之间的通信进行控制与协调，降低了原有系统的耦合度，使得系统更加灵活，也更易于扩展。 本章将学习中介者模式的定义与结构，理解为何以及如何引入中介者角色，学会编程实现中介者模式以及理解如何通过中介者模式来简化对象之间的复杂交互关系。 本章知识点 中介者模式的定义 中介者模式的结构 中介者模式的实现 中介者模式的应用 中介者模式的优缺点 中介者模式的适用环境 中介者模式概述在QQ聊天中存在两种聊天方式：第一种是用户与用户直接聊天，第二种是通过QQ群聊天，如图1所示。如果使用图1（a）所示方式，一个用户要与其他用户聊天或发送文件，通常需要加其他用户为好友，用户与用户之间存在多对多的联系，这将导致系统中用户之间的关系非常复杂，一个用户如果将相同的信息或文件发送给其他所有用户，必须一个一个地发送，于是QQ群产生了，如图1（b）所示。如果使用QQ群，一个用户可以向多个用户发送相同的信息和文件而无须一一发送，只需将信息或文件发送到群中或上传为群共享文件即可，群的作用就是将发送者所发送的信息和文件转发给每一个接收者。通过引入群的机制，将极大地减少系统中用户之间的两两通信，用户与用户之间的联系可以通过群来实现。 图1 QQ聊天示意图 在软件系统中，某些类/对象之间的相互调用关系错综复杂，类似QQ用户之间的关系，此时，特别需要一个类似“QQ群”一样的中间类来协调这些类/对象之间的复杂关系，以降低系统的耦合度。中介者模式为此而“诞生”，它通过在系统中增加中介者对象来降低原有类/对象之间的复杂引用关系。 下面对中介者模式的模式动机做进一步说明： 如果在一个系统中对象之间的联系呈现为网状结构，如图2所示，对象之间存在着大量的多对多联系，将导致系统非常复杂，这些对象既会影响其他对象，也会被其他对象所影响，这些对象被称为同事对象，它们之间通过彼此的相互作用实现系统的行为。在网状结构中，几乎每个对象都需要与其他对象发生相互作用，而这种相互作用表现为一个对象与另外一个对象的直接耦合，这将导致一个过度耦合的系统。 图2 对象之间存在复杂关系的网状结构 中介者模式可以使对象之间的关系数量急剧减少，通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，如图3所示。在这个星形结构中，同事对象不再直接与另一个对象联系，它通过中介者对象与另一个对象发生相互作用。中介者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入带来大量的修改工作。 图3 引入中介者对象的星形结构 如果在一个系统中对象之间存在着多对多的相互关系，可以将对象之间的一些交互行为从各个对象中分离出来，集中封装在一个中介者对象中，并由该中介者进行统一协调，这样对象之间多对多的复杂关系就转化为相对简单的一对多关系。 中介者模式的定义如下：1定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。 中介者模式又称为调停者模式，它是一种对象行为型模式。在中介者模式中，通过引入中介者来简化对象之间的复杂交互，中介者模式是迪米特法则的一个典型应用。 中介者模式的结构与实现中介者模式的结构在中介者模式中，引入了用于协调其他对象/类之间相互调用的中介者类，为了让系统具有更好的灵活性和可扩展性，通常还提供了抽象中介者，其结构如图4所示。 图4 中介者模式结构图 由图4可知，中介者模式包含以下4个角色。 (1)Mediator（抽象中介者）：它定义一个接口，该接口用于与各同事对象之间进行通信。 (2)ConcreteMediator（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，维持了对各个同事对象的引用。 (3)Colleague（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用与中介者通信。 (4)ConcreteColleague（具体同事类）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。 中介者模式的实现中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两个方面的职责。 (1)中转作用（结构性）：通过中介者提供的中转作用，各个同事对象不再需要显式地引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。 (2)协调作用（行为性）：中介者可以更进一步对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。 在中介者模式中，典型的抽象中介者类代码如下： 12345678910111213141516using System.Collections.Generic;abstract class Mediator&#123; // 用于存储同事对象 protected List&lt;Colleague&gt; colleague = new List&lt;Colleague&gt;(); // 注册方法，用于增加同事对象 public void Register(Colleague colleague) &#123; colleague.Add(colleague); &#125; // 声明抽象的业务方法 public abstract void Operation();&#125; 在抽象中介者中可以定义一个同事类的集合，用于存储同事对象并提供注册方法，同时声明了具体中介者类所具有的方法。在具体中介者类中将实现这些抽象方法，典型的具体中介者类代码如下：12345678910class ConcreteMediator : Mediator&#123; // 实现业务方法，封装同事之间的调用 public override void Operation() &#123; ... ((Colleague)(colleagues[0])).Method1(); // 通过中介者调用同事类的方法 .. &#125;&#125; 在具体中介者类中将调用同事类的方法，调用时可以增加一些自己的业务代码对调用进行控制。 在抽象同事类中维持了一个抽象中介者的引用，用于调用中介者的方法。典型的抽象同事类代码如下：123456789101112131415161718abstract class Colleague&#123; // 维持一个抽象中介者的引用 protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void Method1(); // 声明自身方法，处理自己的行为 // 定义依赖方法，与中介者进行通信 public void Method2() &#123; mediator.Operation(); &#125;&#125; 在抽象同事类中声明了同事类的抽象方法，在具体同事类中将实现这些方法。典型的具体同事类代码如下：12345678910111213class ConcreteColleague : Colleague&#123; public ConcreteColleague(Mediator mediator) : base(mediator) &#123; &#125; // 实现自身方法 public override void Method1() &#123; ... &#125;&#125; 在具体同事类ConcreteColleague中实现了在抽象同事类中声明的方法，其中，方法Method1()是同事类的自身方法（Self-Method），用于处理自己的行为，而方法Method2()是依赖方法（Depend-Method），用于调用在中介者中定义的方法，依赖中介者完成相应的行为，例如调用另一个同事类的相关方法。 中介者模式的应用实例下面通过一个应用实例来进一步学习和理解中介者模式。 1.实例说明 某软件公司要开发一套CRM系统，其中包含一个客户信息管理模块，所设计的“客户信息管理窗口”界面效果图如图5所示。图5 “客户信息管理窗口”界面效果图 通过分析发现，在图5中，界面组件之间存在着较为复杂的交互关系：如果删除一个客户，将从客户列表（List）中删掉对应的项，客户选择组合框（ComboBox）中的客户名称也将减少一个；如果增加一个客户信息，则客户列表中将增加一个客户，且组合框中也将增加一项。 为了更好地处理界面组件之间的交互，现使用中介者模式设计该系统。 2.实例类图 为了协调界面组件对象之间的复杂交互关系，可引入一个中介者类，其结构如图6所示。 图6 引入中介者类的“客户信息管理窗口”结构示意图 图6只是一个结构示意图，在具体实现时，为了确保系统具有更好的灵活性和可扩展性，需要定义抽象中介者和抽象组件类，其中，抽象组件类是所有具体组件类的公共父类，完整类图如图7所示。 图7 “客户信息管理窗口”结构图 在图7中，Component充当抽象同事类，Button、List、ComboBox和TextBox充当具体同事类，Mediator充当抽象中介者类，ConcreteMediator充当具体中介者类，ConcreteMediator维持了对具体同事类的引用，为了简化ConcreteMediator类的代码，在其中只定义了一个Button对象和一个TextBox对象。 3.实例代码 (1)Mediator：抽象中介者类。 1234567namespace MediatorSample&#123; abstract class Mediator &#123; public abstract void ComponentChanged(Component c); &#125;&#125; (2)ConcreteMediator：具体中介者类。 12345678910111213141516171819202122232425262728293031323334353637383940using System;namespace MediatorSample&#123; class ConcreteMediator : Mediator &#123; // 维持对各个同事对象的引用 public Button addButton; public List list; public TextBox userNameTextBox; public ComboBox cb; // 封装同事对象之间的交互 public override void ComponentChanged(Component c) &#123; // 单击按钮 if (c == addButton) &#123; Console.WriteLine("--单击增加按钮--"); list.Update(); cb.Update(); userNameTextBox.Update(); &#125; // 从列表框选择客户 else if (c == list) &#123; Console.WriteLine("--从列表框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; // 从组合框选择客户 else if (c == cb) &#123; Console.WriteLine("--从组合框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; &#125; &#125;&#125; (3)Component：抽象组件类，充当抽象同事类。 1234567891011121314151617181920namespace MediatorSample&#123; abstract class Component &#123; protected Mediator mediator; public void SetMediator(Mediator mediator) &#123; this.mediator = mediator; &#125; // 转发调用 public void Changed() &#123; mediator.ComponentChanged(this); &#125; public abstract void Update(); &#125;&#125; (4)Button：按钮类，充当具体同事类。 12345678910namespace MediatorSample&#123; class Button : Component &#123; public override void Update() &#123; // 按钮不产生响应 &#125; &#125;&#125; (5)List：列表框类，充当具体同事类。 1234567891011121314151617using System;namespace MediatorSample&#123; class List : Component &#123; public override void Update() &#123; Console.WriteLine("列表框增加一项：张无忌。"); &#125; public void Select() &#123; Console.WriteLine("列表框选中项：小龙女。"); &#125; &#125;&#125; (6)ComboBox：组合框类，充当具体同事类。 1234567891011121314151617using System;namespace MediatorSample&#123; class ComboBox : Component &#123; public override void Update() &#123; Console.WriteLine("组合框增加一项：张无忌。"); &#125; public void Select() &#123; Console.WriteLine("组合框选中项：小龙女。"); &#125; &#125;&#125; (7)TextBox：文本框类，充当具体同事类。 1234567891011121314151617using System;namespace MediatorSample&#123; class TextBox : Component &#123; public override void Update() &#123; Console.WriteLine("客户信息增加成功后文本框清空。"); &#125; public void SetText() &#123; Console.WriteLine("文本框显示：小龙女。"); &#125; &#125;&#125; (8)Program：客户端测试类。 12345678910111213141516171819202122232425262728293031323334353637using System;namespace MediatorSample&#123; class Program &#123; static void Main(string[] args) &#123; // 定义中介者对象 ConcreteMediator mediator; mediator = new ConcreteMediator(); // 定义同事对象 Button addBT = new Button(); List list = new List(); ComboBox cb = new ComboBox(); TextBox userNameTB = new TextBox(); addBT.SetMediator(mediator); list.SetMediator(mediator); cb.SetMediator(mediator); userNameTB.SetMediator(mediator); mediator.addButton = addBT; mediator.list = list; mediator.cb = cb; mediator.userNameTextBox = userNameTB; addBT.Changed(); Console.WriteLine("-----------------------------"); list.Changed(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345678--单击增加按钮-- 列表框增加一项：张无忌。 组合框增加一项：张无忌。 客户信息增加成功后文本框清空。-------------------------------从列表框选择客户-- 组合框选中项：小龙女。 文本框显示：小龙女。 在引入中介者后，同事之间的复杂交互由中介者间接实现，当某个组件类的Changed()方法被调用时，中介者的ComponentChanged()方法将被调用，在中介者的ComponentChanged()方法中再逐个调用与该组件有交互的其他组件的相关方法。如果某个组件类需要与新的组件进行交互，无须修改已有组件类的源代码，只需修改中介者或者对现有中介者进行扩展即可，系统具有更好的灵活性和可扩展性。 扩展中介者与同事类本节将对上一节中的“客户信息管理窗口”进行改进，在窗口的下端能够及时显示当前系统中客户信息的总数，如图8所示。 图8 修改之后的“客户信息管理窗口”界面图 从图8中不难发现，可以通过增加一个文本标签(Label)来显示客户信息总数，而且当用户单击“增加”按钮或者“删除”按钮时，将改变文本标签的内容。 由于使用了中介者模式，在原有系统中增加新的组件（即新的同事类）将变得很容易，至少有以下两种解决方案。 方案(1)：增加一个界面组件类Label，修改原有具体中介者类ConcreteMediator，增加一个对Label对象的引用，然后修改ComponentChanged()方法中其他相关组件对象的业务处理代码，原有组件类无须任何修改，客户端代码需针对新增组件Label进行适当修改。 方案(2)：与方案(1)类似，首先增加一个Label类，但不修改原有具体中介者类ConcreteMediator的代码，而是增加一个ConcreteMediator的子类SubConcreteMediator来实现对Label对象的引用，然后在新增的中介者类SubConcreteMediator中通过覆盖ComponentChanged()方法实现所有组件(包括新增组件Label)之间的交互，同样，原有组件类无须做任何修改，客户端代码需少许修改。 引入Label之后的“客户信息管理窗口”类结构示意图如图9所示。 图9 增加Label组件类后的“客户信息管理窗口”结构示意图 由于方案(2)无须修改ConcreteMediator类，更符合开闭原则，因此选择方案(2)对新增Label类进行处理，对应的完整类图如图10所示。 图10 修改之后的“客户信息管理窗口”结构图 在图10中新增了具体同事类Label和具体中介者类SubConcreteMediator，代码如下： Label.cs 文本标签类，充当具体同事类 123456789101112using System;namespace MediatorSample&#123; class Label : Component &#123; public override void Update() &#123; Console.WriteLine("文本标签内容改变，客户信息总数加1。"); &#125; &#125;&#125; SubConcreteMediator.cs 新增具体中介者类 12345678910111213141516171819202122232425262728293031323334353637using System;namespace MediatorSample&#123; class SubConcreteMediator : ConcreteMediator &#123; // 增加对Label对象的引用 public Label label; public override void ComponentChanged(Component c) &#123; // 单击按钮 if (c == addButton) &#123; Console.WriteLine("--单击增加按钮--"); list.Update(); cb.Update(); userNameTextBox.Update(); label.Update(); // 文本标签更新 &#125; // 从列表框选择客户 else if (c == list) &#123; Console.WriteLine("--从列表框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; // 从组合框选择客户 else if (c == cb) &#123; Console.WriteLine("--从组合框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; &#125; &#125;&#125; 修改客户端测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738using System;namespace MediatorSample&#123; class Program &#123; static void Main(string[] args) &#123; // 用新增具体中介者定义中介者对象 SubConcreteMediator mediator; mediator = new SubConcreteMediator(); Button addBT = new Button(); List list = new List(); ComboBox cb = new ComboBox(); TextBox userNameTB = new TextBox(); Label label = new Label(); addBT.SetMediator(mediator); list.SetMediator(mediator); cb.SetMediator(mediator); userNameTB.SetMediator(mediator); label.SetMediator(mediator); mediator.addButton = addBT; mediator.list = list; mediator.cb = cb; mediator.userNameTextBox = userNameTB; mediator.label = label; addBT.Changed(); Console.WriteLine("-----------------------------"); list.Changed(); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：123456789--单击增加按钮-- 列表框增加一项：张无忌。 组合框增加一项：张无忌。 客户信息增加成功后文本框清空。文本标签内容改变，客户信息总数加1。-------------------------------从列表框选择客户-- 组合框选中项：小龙女。 文本框显示：小龙女。 由于在本实例中不同的组件类(即不同的同事类)拥有的方法并不完全相同，因此，中介者类没有针对抽象同事类编程，导致在具体中介者类中需要维持对具体同事类的引用，客户端代码无法完全透明地对待所有同事类和中介者类。在某些情况下，如果设计得当，可以在客户端透明地对同事类和中介者类编程，这样系统将具有更好的灵活性和可扩展性。 在中介者模式的实际使用过程中，如果需要引入新的具体同事类，只需继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现；如果需要在原有系统中增加新的具体中介者类，只需继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用。在客户端中只需修改少许代码（如果引入配置文件可以不用修改任何代码）就可以实现中介者类的更换。 中介者模式的优缺点与适用环境中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星形结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。中介者模式在事件驱动类软件中的应用较为广泛，特别是基于GUI(Graphical User Interface，图形用户界面）的应用软件，此外，在类与类之间存在错综复杂的关联关系的系统中，中介者模式也得到了较好的应用。 中介者模式的优点中介者模式的主要优点如下： (1)中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星形结构。 (2)可将各同事对象解耦，中介者模式有利于各同事之间的松耦合，可以独立地改变和复用每一个同事和中介者，增加新的中介者类和新的同事类都比较方便，更好地符合开闭原则。 (3)可以减少子类的生成，中介者模式将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使得各个同事类可被重用，无须直接对同事类进行扩展。 中介者模式的缺点中介者模式的主要缺点如下： 在具体中介者类中包含了大量的同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 中介者模式的适用环境在以下情况下可以考虑使用中介者模式： (1)系统中对象之间存在着复杂的引用关系，系统结构混乱且难以理解。 (2)一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。 (3)用户想通过一个中间类来封装多个类中的行为，又不想生成太多的子类，此时可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。 本章小结(1)中介者模式通过定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。 (2)中介者模式包含抽象中介者、具体中介者、抽象同事类和具体同事类4个角色。其中，抽象中介者定义一个接口，该接口用于和各同事对象之间进行通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用；抽象同事类定义各个同事类公有的方法，并声明了一些抽象方法供子类实现；具体同事类是抽象同事类的子类，每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者间接完成与其他同事类的通信。 (3)中介者模式的主要优点包括它简化了对象之间的交互，可将各同事对象解耦，还可以减少子类的生成。其主要缺点是在具体中介者类中包含了大量的同事之间的交互细节可能会导致具体中介者类非常复杂，使得系统难以维护。 (4)中介者模式适用的环境：系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；用户想通过一个中间类来封装多个类中的行为，又不想生成太多的子类。 (5)在中介者模式中，中介者类承担了中转和协调双重职责。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 有些对象也像水一样具有多种状态，这些状态在某些情况下能够相互转换。游戏中是什么对象？ 统一由环境类来负责状态之间的转换和由具体状态类来负责状态之间的转换有什么不同？ 本章导学 状态模式是一种较为复杂的设计模式，用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。 本章将学习状态模式的定义与结构，分析状态模式的特点，并结合实例学习状态模式的实现过程，学会如何在实际软件项目开发中应用状态模式。 本章知识点 状态模式的定义 状态模式的结构 状态模式的实现 状态模式的应用 状态模式的优缺点 状态模式的适用环境 共享状态 使用环境类实现状态的转换 状态模式概述“人有悲欢离合，月有阴晴圆缺”，包括人在内，很多事物都具有多种状态，而且在不同状态下会具有不同的行为，这些状态在特定条件下还将发生相互转换。就像水，它可以凝固成冰，也可以受热蒸发后变成水蒸气，水可以流动，冰可以雕刻，水蒸气可以扩散。可以用UML状态图来描述H2O的3种状态，如图1所示。 图1 H2O的3种状态（未考虑临界点） 在软件系统中，有些对象也像水一样具有多种状态，这些状态在某些情况下能够相互转换，而且对象在不同的状态下也将具有不同的行为。通常可以使用复杂的条件判断语句（例如if…else…语句）来进行状态的判断和转换操作，这会导致代码的可维护性和灵活性下降，特别是出现新的状态时，代码的扩展性很差，客户端代码也需要进行相应的修改，违背了开闭原则。为了解决状态的转换问题，并降低客户端代码与对象状态之间的耦合度，可以使用一种被称为状态模式的设计模式。 状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。 状态模式的定义如下：1允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 状态模式又称为状态对象（Objects for States），它是一种对象行为型模式。 状态模式的结构与实现状态模式的结构在状态模式中引入了抽象状态类和具体状态类，它们是状态模式的核心，其结构如图2所示。 由图2可知，状态模式包含以下3个角色。 图2 状态模式结构图 (1)Context（环境类）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性，且在不同状态下对象的行为有所不同，所以将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。 (2)State（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现了这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。 (3)Concretestate（具体状态类）：它是抽象状态类的子类，每一个具体状态类实现一个与环境类的一个状态相关的行为，对应环境类的一个具体状态，不同的具体状态类其行为有所不同。 状态模式的实现在状态模式中，将对象在不同状态下的行为封装到不同的状态类中，为了让系统具有更好的灵活性和可扩展性，同时对各状态下的共有行为进行封装，需要对状态进行抽象化，引入了抽象状态类角色。其典型代码如下：12345abstract class State&#123; // 声明抽象业务方法，不同的具体状态类可以有不同的实现 public abstract void Handle();&#125; 在抽象状态类的子类（即具体状态类）中实现了在抽象状态类中声明的业务方法，不同的具体状态类可以提供完全不同的方法实现。实际使用时，在一个状态类中可能包含多个业务方法，如果在具体状态类中某些业务方法的实现完全相同，则可以将这些方法移至抽象状态类，实现代码的复用。典型的具体状态类代码如下：1234567class ConcreteState : State&#123; public override void Handle() &#123; // 方法具体实现代码 &#125;&#125; 环境类维持一个对抽象状态类的引用，通过SetState()方法可以向环境类注入不同的状态对象，再在环境类的业务方法中调用状态对象的方法。其典型代码如下：123456789101112131415161718class Context&#123; private State state; // 维持一个对抽象状态对象的引用 private int value; // 其他属性值，该属性值的变化可能会导致对象的状态发生变化 // 设置状态对象 public void SetState(State state) &#123; this.state = state; &#125; public void Request() &#123; // 其他代码 state.Handle(); // 调用状态对象的业务方法 // 其他代码 &#125;&#125; 环境类实际上是真正拥有状态的对象，只是将环境类中与状态有关的代码提取出来封装到专门的状态类中。在状态模式结构图中，环境类Context与抽象状态类State间存在着单向关联关系，在Context中定义了一个State对象。在实际使用时，它们之间可能存在更为复杂的关系，State与Context之间可能也存在依赖或者双向关联关系。 在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换，通常有两种实现状态转换的方式。 (1)统一由环境类来负责状态之间的转换，此时，环境类还充当了状态管理器（StateManager）角色，在环境类的业务方法中通过对某些属性值的判断实现状态转换，也可以提供一个专门的方法用于实现属性判断和状态转换，代码片段如下：123456789101112131415...public void ChangeState()&#123; // 判断属性值，根据属性值进行状态转换 if (value == 0) &#123; this.SetState(new ConcreteStateA()); &#125; else if (value == 1) &#123; this.SetState(new ConcreteStateB()); &#125; ...&#125;... (2)由具体状态类来负责状态之间的转换，可以在具体状态类的业务方法中判断环境类的某些属性值，再根据情况为环境类设置新的状态对象，实现状态变换。同样，也可以提供一个专门的方法来负责属性值的判断和状态转换。此时，状态类与环境类之间将存在依赖或关联关系，因为状态类需要访问环境类中的属性值，具体状态类ConcreteStateA的代码片段如下：123456789101112131415...public void ChangeState(Context ctx)&#123; // 根据环境对象中的属性值进行状态转换 if (ctx.value == 1) &#123; ctx.SetState(new ConcreteStateB()); &#125; else if (ctx.value == 2) &#123; ctx.SetState(new ConcreteStateC()); &#125; ...&#125;... 状态模式的应用实例下面通过一个应用实例来进一步学习和理解状态模式。 1.实例说明 某软件公司要为一银行开发一套信用卡业务系统，银行账户（Account）是该系统的核心类之一，通过分析，该软件公司开发人员发现在系统中账户存在3种状态，且在不同状态下账户存在不同的行为，具体说明如下：(1)如果账户中余额大于等于0，则账户的状态为正常状态（NormalState），此时用户既可以向该账户存款也可以从该账户取款。(2)如果账户中余额小于0，并且大于-2000，则账户的状态为透支状态（OverdraftState），此时用户既可以向该账户存款也可以从该账户取款，但需要按天计算利息。(3)如果账户中余额等于-2000，那么账户的状态为受限状态（RestrictedState），此时用户只能向该账户存款，不能再从中取款，同时也将按天计算利息。(4)根据余额的不同，以上3种状态可发生相互转换。现使用状态模式设计并实现银行账户状态的转换。 2.实例类图 通过对银行账户类进行分析，可以绘制出图3所示的UML状态图。 图3 银行账户状态图 在图3中，NormalState表示正常状态，OverdraftState表示透支状态，RestrictedState表示受限状态。在这3种状态下账户对象拥有不同的行为，方法Deposit()用于存款，Withdraw()用于取款，ComputeInterest()用于计算利息，StateCheck()用于在每一次执行存款和取款操作后根据余额来判断是否要进行状态转换并实现状态转换，相同的方法在不同的状态下可能会有不同的实现。 使用状态模式对银行账户状态进行设计，所得的结构如图4所示。 图4 银行账户结构图 在图4中，Account充当环境类角色，AccountState充当抽象状态类角色，NormalState、OverdraftState和RestrictedState充当具体状态类角色。 3.实例代码 (1)Account：银行账户，充当环境类。 Account.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;namespace StateSample&#123; class Account &#123; private AccountState state; // 维持一个对抽象状态对象的引用 private string owner; // 开户名 private double balance = 0; // 账户余额 public Account(string owner, double init) &#123; this.owner = owner; this.balance = init; this.state = new NormalState(this); // 设置初始状态 Console.WriteLine("&#123;0&#125;开户，初始金额为&#123;1&#125;", this.owner ,init); Console.WriteLine("---------------------------------------------"); &#125; public double Balance &#123; get &#123; return balance; &#125; set &#123; balance = value; &#125; &#125; public void SetState(AccountState state) &#123; this.state = state; &#125; public void Deposit(double amount) &#123; Console.WriteLine("&#123;0&#125;存款&#123;1&#125;", this.owner,amount); state.Deposit(amount); // 调用状态对象的Deposit()方法 Console.WriteLine("现在余额为&#123;0&#125;", this.Balance); Console.WriteLine("现在帐户状态为&#123;0&#125;",this.state.GetType().ToString()); Console.WriteLine("---------------------------------------------"); &#125; public void Withdraw(double amount) &#123; Console.WriteLine("&#123;0&#125;取款&#123;1&#125;",this.owner, amount); state.Withdraw(amount); // 调用状态对象的Withdraw()方法 Console.WriteLine("现在余额为&#123;0&#125;", this.Balance); Console.WriteLine("现在帐户状态为&#123;0&#125;", this.state.GetType().ToString()); Console.WriteLine("---------------------------------------------"); &#125; public void ComputeInterest() &#123; state.ComputeInterest(); // 调用状态对象的ComputeInterest()方法 &#125; &#125;&#125; (2)AccountState：账户状态类，充当抽象状态类。 AccountState.cs 1234567891011121314151617namespace StateSample&#123; abstract class AccountState &#123; private Account acc; public Account Acc &#123; get &#123; return acc; &#125; set &#123; acc = value; &#125; &#125; public abstract void Deposit(double amount); public abstract void Withdraw(double amount); public abstract void ComputeInterest(); public abstract void StateCheck(); &#125;&#125; (3)NormalState：正常状态类，充当具体状态类。 NormalState.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;namespace StateSample&#123; class NormalState : AccountState &#123; public NormalState(Account acc) &#123; this.Acc = acc; &#125; public NormalState(AccountState state) &#123; this.Acc = state.Acc; &#125; public override void Deposit(double amount) &#123; Acc.Balance = Acc.Balance + amount; StateCheck(); &#125; public override void Withdraw(double amount) &#123; Acc.Balance = Acc.Balance - amount; StateCheck(); &#125; public override void ComputeInterest() &#123; Console.WriteLine("正常状态，无须支付利息！"); &#125; // 状态转换 public override void StateCheck() &#123; if (Acc.Balance &gt; -2000 &amp;&amp; Acc.Balance &lt;= 0) &#123; Acc.SetState(new OverdraftState(this)); &#125; else if (Acc.Balance == -2000) &#123; Acc.SetState(new RestrictedState(this)); &#125; else if (Acc.Balance &lt; -2000) &#123; Console.WriteLine("操作受限！"); &#125; &#125; &#125;&#125; (4)OverdraftState：透支状态类，充当具体状态类。 OverdraftState.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;namespace StateSample&#123; class OverdraftState : AccountState &#123; public OverdraftState(AccountState state) &#123; this.Acc = state.Acc; &#125; public override void Deposit(double amount) &#123; Acc.Balance = Acc.Balance + amount; StateCheck(); &#125; public override void Withdraw(double amount) &#123; Acc.Balance = Acc.Balance - amount; StateCheck(); &#125; public override void ComputeInterest() &#123; Console.WriteLine("计算利息！"); &#125; // 状态转换 public override void StateCheck() &#123; if (Acc.Balance &gt; 0) &#123; Acc.SetState(new NormalState(this)); &#125; else if (Acc.Balance == -2000) &#123; Acc.SetState(new RestrictedState(this)); &#125; else if (Acc.Balance &lt; -2000) &#123; Console.WriteLine("操作受限！"); &#125; &#125; &#125;&#125; (5)RestrictedState：受限状态类，充当具体状态类。 RestrictedState.cs 1234567891011121314151617181920212223242526272829303132333435363738394041using System;namespace StateSample&#123; class RestrictedState : AccountState &#123; public RestrictedState(AccountState state) &#123; this.Acc = state.Acc; &#125; public override void Deposit(double amount) &#123; Acc.Balance = Acc.Balance + amount; StateCheck(); &#125; public override void Withdraw(double amount) &#123; Console.WriteLine("帐号受限，取款失败"); &#125; public override void ComputeInterest() &#123; Console.WriteLine("计算利息！"); &#125; // 状态转换 public override void StateCheck() &#123; if (Acc.Balance &gt; 0) &#123; Acc.SetState(new NormalState(this)); &#125; else if (Acc.Balance &gt; -2000) &#123; Acc.SetState(new OverdraftState(this)); &#125; &#125; &#125;&#125; (6)Program：客户端测试类。 Program.cs 1234567891011121314151617181920using System;namespace StateSample&#123; class Program &#123; static void Main(string[] args) &#123; Account acc = new Account("段誉", 0.0); acc.Deposit(1000); acc.Withdraw(2000); // ① acc.Deposit(3000); acc.Withdraw(4000); // ② acc.Withdraw(1000); // ③ acc.ComputeInterest(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：123456789101112131415161718192021222324段誉开户，初始金额为0---------------------------------------------段誉存款1000现在余额为1000现在账户状态为StateSample.NormalState---------------------------------------------①段誉取款2000现在余额为-1000现在账户状态为StateSample.OverdraftState---------------------------------------------段誉存款3000现在余额为2000现在账户状态为StateSample.NormalState---------------------------------------------②段誉取款4000现在余额为-2000现在账户状态为StateSample.RestrictedState---------------------------------------------③段誉取款1000账号受限，取款失败现在余额为-2000现在账户状态为StateSample.RestrictedState---------------------------------------------计算利息！ ①②③部分对应客户端代码中3次调用取款方法Withdraw()的输出结果，由于对象状态不一样，因此这3次输出结果有所差异。第一次取款后账户状态由正常状态（NormalState）变为透支状态（OverdraftState）；第二次取款后账户状态由正常状态（NormalState）变为受限状态（RestrictedState）；在第三次取款时，由于账户状态已经为受限状态，因此取款失败。这3次取款操作体现了对象在不同状态下具有不同的行为，而且对象的转换是自动的，客户端无须关心其转换细节。 共享状态在有些情况下，多个环境对象可能需要共享同一个状态，如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象定义为环境类的静态成员对象。下面通过一个简单实例来说明如何实现共享状态。 某系统要求两个开关对象要么都处于开的状态，要么都处于关的状态，在使用时它们的状态必须保持一致，开关可以由开转换到关，也可以由关转换到开。试使用状态模式来实现开关的设计。 通过分析，其结构如图5所示。 图5 开关及其状态设计结构图 开关类的代码如下： Switch.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;namespace SwitchStateSample&#123; class Switch &#123; private static SwitchState currentState, onState, offState; // 定义三个静态的状态对象 private string name; public Switch(string name) &#123; this.name = name; onState = new OnState(); offState = new OffState(); currentState = onState; &#125; public void SetState(SwitchState state) &#123; currentState = state; &#125; public static SwitchState GetState(string type) &#123; if (type.Equals("on")) &#123; return onState; &#125; else &#123; return offState; &#125; &#125; // 打开开关 public void On() &#123; Console.Write(name); currentState.On(this); &#125; // 关闭开关 public void Off() &#123; Console.Write(name); currentState.Off(this); &#125; &#125;&#125; 抽象状态类的代码如下： SwitchState.cs 12345678namespace SwitchStateSample&#123; abstract class SwitchState &#123; public abstract void On(Switch s); public abstract void Off(Switch s); &#125;&#125; 两个具体状态类的代码如下： OnState.cs 123456789101112131415161718using System;namespace SwitchStateSample&#123; class OnState : SwitchState &#123; public override void On(Switch s) &#123; Console.WriteLine("已经打开！"); &#125; public override void Off(Switch s) &#123; Console.WriteLine("关闭！"); s.SetState(Switch.GetState("off")); &#125; &#125;&#125; OffState.cs 123456789101112131415161718using System;namespace SwitchStateSample&#123; class OffState : SwitchState &#123; public override void On(Switch s) &#123; Console.WriteLine("打开！"); s.SetState(Switch.GetState("on")); &#125; public override void Off(Switch s) &#123; Console.WriteLine("已经关闭！"); &#125; &#125;&#125; 编写以下客户端代码进行测试： Program.cs 1234567891011121314151617181920212223using System;namespace SwitchStateSample&#123; class Program &#123; static void Main(string[] args) &#123; Switch s1, s2; s1 = new Switch("开关1"); s2 = new Switch("开关2"); s1.On(); s2.On(); s1.Off(); s2.Off(); s2.On(); s1.On(); Console.Read(); &#125; &#125;&#125; 输出结果如下：123456开关1已经打开！开关2已经打开！开关1关闭！开关2已经关闭！开关2打开！开关1已经打开！ 从输出结果可以得知：两个开关共享相同的状态，如果第一个开关关闭，则第二个开关也将关闭，再次关闭时将输出“已经关闭”，打开时也将得到类似结果。 使用环境类实现状态的转换在状态模式中实现状态转换时，具体状态类可通过调用环境类Context的SetState()方法进行状态的转换操作，也可以统一由环境类Context实现状态的转换。此时，增加新的具体状态类可能需要修改其他具体状态类或者环境类的源代码，否则系统无法转换到新增状态。但是对于客户端而言，无须关心状态类，可以为环境类设置默认的状态类，而将状态的转换工作交给具体状态类或环境类来完成，具体的转换细节对于客户端而言是透明的。 在之前的“银行账户状态转换”实例中，通过具体状态类来实现状态的转换，在每一个具体状态类中都包含一个StateCheck()方法，在该方法内部实现状态的转换。除此之外，还可以通过环境类来实现状态转换，环境类作为一个状态管理器，统一实现各种状态之间的转换操作。 下面通过一个包含循环状态的简单实例来说明如何使用环境类实现状态转换。 现要开发一个屏幕放大镜工具，其具体功能描述如下：用户单击“放大镜”按钮之后屏幕将放大一倍，再单击一次“放大镜”按钮屏幕再放大一倍，第三次单击该按钮后屏幕将还原到默认大小。试使用状态模式来设计该屏幕放大镜工具。 通过分析，可以定义3个屏幕状态类NormalState、LargerState和LargestState来对应屏幕的3种状态，分别是正常状态、二倍放大状态和四倍放大状态，屏幕类Screen充当环境类，其结构如图6所示。 图6 屏幕放大镜工具结构图 本实例的核心代码如下： Screen.cs：屏幕类 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;namespace ScreenStateSample&#123; class Screen &#123; // 枚举所有的状态，currentState表示当前状态 private ScreenState currentState, normalState, largerState, largestState; public Screen() &#123; this.normalState = new NormalState(); // 创建正常状态对象 this.largerState = new LargerState(); // 创建二倍放大状态对象 this.largestState = new LargestState(); // 创建四倍放大状态对象 this.currentState = normalState; // 设置初始状态 this.currentState.Display(); &#125; public void SetState(ScreenState state) &#123; this.currentState = state; &#125; // 单击事件处理方法，封转了对状态类中业务方法的调用和状态的转换 public void OnClick() &#123; if (this.currentState == normalState) &#123; this.SetState(largerState); this.currentState.Display(); &#125; else if (this.currentState == largerState) &#123; this.SetState(largestState); this.currentState.Display(); &#125; else if (this.currentState == largestState) &#123; this.SetState(normalState); this.currentState.Display(); &#125; &#125; &#125;&#125; ScreenState.cs：抽象状态类 123456789using System;namespace ScreenStateSample&#123; abstract class ScreenState &#123; public abstract void Display(); &#125;&#125; NormalState.cs：正常状态类 123456789101112using System;namespace ScreenStateSample&#123; class NormalState : ScreenState &#123; public override void Display() &#123; Console.WriteLine("正常大小！"); &#125; &#125;&#125; LargerState.cs：二倍状态类 123456789101112using System;namespace ScreenStateSample&#123; class LargerState : ScreenState &#123; public override void Display() &#123; Console.WriteLine("二倍大小！"); &#125; &#125;&#125; LargerState.cs：四倍状态类 123456789101112using System;namespace ScreenStateSample&#123; class LargestState : ScreenState &#123; public override void Display() &#123; Console.WriteLine("四倍大小！"); &#125; &#125;&#125; 在上述代码中，所有的状态转换操作都由环境类Screen来实现，此时，环境类充当了状态管理器角色。如果需要增加新的状态，例如“八倍状态类”，需要修改环境类，这在一定程度上违背了开闭原则，但对其他状态类没有任何影响。 编写以下客户端代码进行测试： Program.cs：客户端测试类 1234567891011121314151617using System;namespace ScreenStateSample&#123; class Program &#123; static void Main(string[] args) &#123; Screen screen = new Screen(); screen.OnClick(); screen.OnClick(); screen.OnClick(); Console.Read(); &#125; &#125;&#125; 输出结果如下：1234正常大小！二倍大小！四倍大小！正常大小！ 状态模式的优缺点与适用环境状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用。在实际开发中，状态模式具有较高的使用频率，在工作流、游戏等软件中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。 状态模式的优点状态模式的主要优点如下： (1)状态模式封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。 (2)状态模式将所有与某个状态有关的行为放到一个类中，只需注入一个不同的状态对象即可使环境对象拥有不同的行为。 (3)状态模式允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句将业务方法和状态转换代码交织在一起。 (4)状态模式可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 状态模式的缺点状态模式的主要缺点如下： (1)状态模式会增加系统中类和对象的个数，导致系统运行开销增大。 (2)其结构与实现都较为复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计的难度。 (3)状态模式对开闭原则的支持并不太好，增加新的状态类需要修改负责状态转换的源代码，否则无法转换到新增状态，而且修改某个状态类的行为也需要修改对应类的源代码。 状态模式的适用环境在以下情况下可以考虑使用状态模式： (1)对象的行为依赖于它的状态（例如某些属性值），状态的改变将导致行为的变化。 (2)在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。 本章小结(1)在状态模式中，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式是一种对象行为型模式。 (2)状态模式包含环境类、抽象状态类和具体状态类3个角色。其中，环境类是拥有多种状态的对象；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现了这些方法；具体状态类是抽象状态类的子类，每一个具体状态类实现一个与环境类的一个状态相关的行为，对应环境类的一个具体状态，不同的具体状态类其行为有所不同。 (3)状态模式的主要优点包括它封装了状态的转换规则，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中；允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块；可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。其主要缺点包括状态模式会增加系统中类和对象的个数，导致系统运行开销增大；如果使用不当将导致程序结构和代码混乱，增加系统设计的难度；此外，状态模式对开闭原则的支持并不太好。 (4)状态模式适用的环境：对象的行为依赖于它的状态，状态的改变将导致行为的变化；在代码中包含大量与对象状态有关的条件语句。 (5)如果需要在系统中实现多个环境对象共享一个或多个状态对象，可以将这些状态对象定义为环境类的静态成员对象。 (6)在状态模式中，可以在具体状态类中实现状态之间的转换，也可以统一由环境类来负责状态之间的转换。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 在软件系统中，对象并不是孤立存在的，一个对象行为的改变可能会导致一个或多个其他与之存在依赖关系的对象行为发生改变。观察者模式用于描述对象之间的依赖关系，为实现多个对象之间的联动提供了一种解决方案，它是一种使用频率非常高的设计模式。 本章将学习观察者模式的定义与结构，分析观察者模式的实现原理，通过实例学习如何编程实现观察者模式并理解观察者模式在.NET事件处理中的应用。 本章知识点 观察者模式的定义 观察者模式的结构 观察者模式的实现 观察者模式的应用 观察者模式的优缺点 观察者模式的适用环境 观察者模式与.NET中的委托事件模型 观察者模式概述“红灯停，绿灯行”，在日常生活中，交通信号灯装点着城市，指挥着日益拥挤的城市交通。当红灯亮起，来往的汽车将停止；而绿灯亮起，汽车可以继续前行。在这个过程中，交通信号灯是汽车（更准确地说应该是汽车驾驶员）的观察目标，而汽车是观察者。随着交通信号灯的变化，汽车的行为也将随之变化，一盏交通信号灯可以指挥多辆汽车。交通信号与汽车示意图如图1所示。 图1 交通信号与汽车示意图 在软件系统中，有些对象之间也存在着类似交通信号灯和汽车之间的关系，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动，正所谓“牵一发而动全身”。为了更好地描述对象之间存在的这种一对多（包括一对一）的联动，观察者模式应运而生，它定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象。 观察者模式是使用频率较高的设计模式之一，用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在观察者模式中，发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，用户可以根据需要增加和删除观察者，使得系统更易于扩展。 观察者模式的定义如下：1定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。 观察者模式又称为发布-订阅（Publish-Subscribe）模式、模型-视图（Model-View）模式、源-监听器（Source-Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。 观察者模式的结构与实现观察者模式的结构观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如图2所示。 图2 观察者模式结构图 由图2可知，观察者模式包含以下4个角色。 (1)Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以被任意数量的观察者观察，它提供一系列方法来增加和删除观察者对象，同时定义了通知方法Notify()。目标类可以是接口，也可以是抽象类或具体类。 (2)ConcreteSubject（具体目标）：具体目标是目标类的子类，通常包含经常发生改变的数据，当它的状态发生改变时，将向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务方法（如果有）。如果无须扩展目标类，具体目标类则可以省略。 (3)Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法Update()，因此又称为抽象观察者。 (4)ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的Update()方法。通常在实现时，可以调用具体目标类的Attach()方法将自己添加到目标类的集合中或通过Detach()方法将自己从目标类的集合中删除。 观察者模式的实现观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态，以使其状态与目标状态同步，这种交互也称为发布-订阅（Publish-Subscribe），观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。下面通过演示代码来对观察者模式进行进一步分析。首先定义一个抽象目标类Subject，其典型代码如下： Subject.cs 12345678910111213using System.Collections;abstract class Subject&#123; // 定义一个观察者集合用于存储所有观察者对象 protected ArrayList observers = new ArrayList(); // 声明抽象注册方法，用于向观察者集合中增加一个观察者 public abstract void Attach(Observer observer); // 声明抽象注销方法，用于在观察者集合中删除一个观察者 public abstract void Detach(Observer observer); // 声明抽象通知方法 public abstract void Notify();&#125; 具体目标类ConcreteSubject是实现了抽象目标类Subject的一个具体子类，它实现了上述3个方法，其典型代码如下： ConcreteSubject.cs 12345678910111213141516171819202122class ConcreteSubject : Subject&#123; public override void Attach(Observer observer) &#123; observers.Add(observer); &#125; public override void Detach(Observer observer) &#123; observers.Remove(observer); &#125; // 实现通知方法 public override void Notify() &#123; // 遍历观察者集合，调用每一个观察者的响应方法 foreach(object obs in observers) &#123; ((Observer)obs).Update(); &#125; &#125;&#125; 抽象观察者角色一般定义为一个接口，通常只声明一个Update()方法，为不同观察者的更新（响应）行为定义相同的接口，这个方法在其子类中实现，不同的观察者具有不同的响应方法。抽象观察者Observer的典型代码如下： Observer.cs 1234interface Observer&#123; void Update();&#125; 在具体观察者ConcreteObserver中实现了Update()方法，其典型代码如下： ConcreteObserver.cs 12345678class ConcreteObserver : Observer&#123; // 实现响应方法 public void Update() &#123; // 具体更新代码 &#125;&#125; 在有些更加复杂的情况下，具体观察者类ConcreteObserver的Update()方法在执行时需要使用到具体目标类ConcreteSubject中的状态（属性），因此在ConcreteObserver与ConcreteSubject之间有时候还存在关联或依赖关系，在ConcreteObserver中定义一个ConcreteSubject实例，通过该实例获取存储在ConcreteSubject中的状态。如果ConcreteObserver的Update()方法不需要使用ConcreteSubject中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者ConcreteObserver和具体目标ConcreteSubject之间无须维持对象引用。 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。 在客户端代码中，首先创建具体目标对象以及具体观察者对象，然后调用目标对象的Attach()方法，将这个观察者对象在目标对象中登记，也就是将它加入到目标对象的观察者集合中，代码片段如下：123456...Subject subject = new ConcreteSubject();Observer observer = new ConcreteObserver();subject.Attach(observer);subject.Notify();... 客户端在调用目标对象的Notify()方法时，将调用在其观察者集合中注册的观察者对象的Update()方法。 观察者模式的应用实例下面通过一个应用实例来进一步学习和理解观察者模式。 1.实例说明 在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。 2.实例类图 通过分析，不难发现在该系统中战队成员之间的联动过程可以简单描述如下： 联盟成员受到攻击-&gt;发送通知给盟友-&gt;盟友做出响应。 如果按照上述思路来设计系统，一个战队联盟成员在受到攻击时需要通知他的每一位盟友，每个联盟成员都需要持有其他所有盟友的信息，这将导致系统开销较大，因此可以引入一个新的角色——指挥部（战队控制中心）来负责维护和管理每个战队所有成员的信息。当一个联盟成员受到攻击时，将向对应的指挥部发送请求信息，指挥部逐一通知每个盟友，盟友再做出响应，如图3所示。 图3 多人联机对战游戏中对象的联动 在图3中，受攻击的联盟成员将与指挥部产生联动，指挥部还将与其他盟友产生联动。 通过分析，本实例的结构如图4所示。 图4 多人联机对战游戏结构图 在图4中，AllyControlCenter充当抽象目标类，ConcreteAllyControlCenter充当具体目标类，IObserver充当抽象观察者，Player充当具体观察者。 3.实例代码 (1)AllyControlCenter：指挥部（战队控制中心类），充当抽象目标类。 AllyControlCenter.cs 1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;namespace ObserverSample&#123; abstract class AllyControlCenter &#123; protected string allyName; // 战队名称 protected List&lt;IObserver&gt; players = new List&lt;IObserver&gt;(); // 定义一个集合用于存储战队成员 public void SetAllyName(string allyName) &#123; this.allyName = allyName; &#125; public string GetAllyName() &#123; return this.allyName; &#125; // 注册方法 public void Join(IObserver obs) &#123; Console.WriteLine("&#123;0&#125;加入&#123;1&#125;战队！", obs.Name, this.allyName); players.Add(obs); &#125; // 注销方法 public void Quit(IObserver obs) &#123; Console.WriteLine("&#123;0&#125;退出&#123;1&#125;战队！", obs.Name, this.allyName); players.Remove(obs); &#125; // 声明抽象通知方法 public abstract void NotifyObserver(string name); &#125;&#125; (2)ConcreteAllyControlCenter：具体指挥部类，充当具体目标类。 ConcreteAllyControlCenter.cs 12345678910111213141516171819202122232425262728using System;namespace ObserverSample&#123; class ConcreteAllyControlCenter : AllyControlCenter &#123; public ConcreteAllyControlCenter(string allyName) &#123; Console.WriteLine("&#123;0&#125;战队组建成功！", allyName); Console.WriteLine("----------------------------"); this.allyName = allyName; &#125; // 实现通知方法 public override void NotifyObserver(string name) &#123; Console.WriteLine("&#123;0&#125;战队紧急通知，盟友&#123;1&#125;遭受敌人攻击！", this.allyName, name); // 遍历观察者集合，调用每一个盟友（自己除外）的支援方法 foreach(object obs in players) &#123; if (!((IObserver)obs).Name.Equals(name)) &#123; ((IObserver)obs).Help(); &#125; &#125; &#125; &#125;&#125; (3)IObserver：抽象观察者类。 IObserver.cs 1234567891011121314namespace ObserverSample&#123; interface IObserver &#123; string Name &#123; get; set; &#125; void Help(); // 声明支援盟友方法 void BeAttacked(AllyControlCenter acc); // 声明遭受攻击方法 &#125;&#125; (4)Player：战队成员类，充当具体观察者类。 Player.cs 123456789101112131415161718192021222324252627282930313233using System;namespace ObserverSample&#123; class Player : IObserver &#123; private string name; public Player(string name) &#123; this.name = name; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; // 支援盟友方法的实现 public void Help() &#123; Console.WriteLine("坚持住，&#123;0&#125;来救你！", this.name); &#125; // 遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法NotifyObserver()来通知盟友 public void BeAttacked(AllyControlCenter acc) &#123; Console.WriteLine("&#123;0&#125;被攻击！", this.name); acc.NotifyObserver(name); &#125; &#125;&#125; (5)Program：客户端测试类。 Program.cs 12345678910111213141516171819202122232425262728293031323334using System;namespace ObserverSample&#123; class Program &#123; static void Main(string[] args) &#123; // 定义观察目标对象 AllyControlCenter acc; acc = new ConcreteAllyControlCenter("金庸群侠"); // 定义四个观察者对象 IObserver player1, player2, player3, player4; player1 = new Player("杨过"); acc.Join(player1); player2 = new Player("令狐冲"); acc.Join(player2); player3 = new Player("张无忌"); acc.Join(player3); player4 = new Player("段誉"); acc.Join(player4); // 某成员遭受攻击 player1.BeAttacked(acc); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234567891011金庸群侠战队组建成功！----------------------------杨过加入金庸群侠战队！令狐冲加入金庸群侠战队！张无忌加入金庸群侠战队！段誉加入金庸群侠战队！杨过被攻击！金庸群侠战队紧急通知，盟友杨过遭受敌人攻击！坚持住，令狐冲来救你！坚持住，张无忌来救你！坚持住，段誉来救你！ 在本实例中，实现了两次对象之间的联动，当一个游戏玩家Player对象的BeAttacked()方法被调用时，将调用指挥部AllyControlCenter的NotifyObserver()方法来进行处理，而在NotifyObserver()方法中又将调用其他Player对象的Help()方法。Player的BeAttacked()方法、AllyControlCenter的NotifyObserver()方法以及Player的Help()方法构成了一个联动触发链，执行顺序如下： Player.BeAttacked()->AllyControlCenter.NotifyObserver()->Player.Help()。 观察者模式与.NET中的委托事件模型.NET中的委托事件模型是观察者模式在.NET中的经典应用。在WinForm编程中需要编写事件处理程序对所发生的事件（例如鼠标单击、菜单项选取等）做出反应，并执行相应的操作。事件被触发后，将执行响应该事件的一个或多个事件处理程序，可以将一个事件分配给多个事件处理程序（注册），还可以根据需要动态更改处理事件的方法。产生事件的对象（例如按钮、文本框、菜单等）称为事件的发送者（事件源对象），接收并响应事件的对象称为事件的接收者（事件处理对象）。与观察者模式相对应，事件源对象充当观察目标角色，事件处理对象充当具体观察者角色，如果事件源对象的某个事件触发，则调用事件处理对象中的事件处理程序对事件进行处理。 在.NET中，如果需要从WinForm控件获取事件，先提供一个委托（Delegate）类型的Event Handler，然后将它注册到事件源。在这里委托对象充当了抽象观察者的角色，所有事件处理方法都必须和委托方法具有相同的函数签名。 C#事件注册方法的语法如下：1eventSource.someEvent += new SomeEventHandler(someMethod); 在该语法中，eventSource表示事件源，someEvent表示定义在事件源中的事件，SomeEventHandler表示用于处理事件的委托，someMethod表示与委托SomeEventHandler具有相同函数签名的事件处理方法。用户只需修改someMethod，即可实现相同的事件对应不同的事件处理程序。 在.NET事件中，事件源并不需要知道哪些对象或方法会收到将要发生的通知，它只持有与签名相符合的方法的引用，即委托；还可以通过多重传送事件来实现一个事件有多个订阅者，即通过委托将多个方法添加到该事件中，当该事件被触发时，同时执行对应的多个事件处理方法。 下面通过一个简单的自定义事件来进一步说明.NET事件中的观察者模式。首先定义一个包含委托和事件的类EventTest，代码如下： EventTest.cs 12345678910111213141516171819202122232425262728using System;namespace ObserverExtend&#123; class EventTest &#123; // 定义一个委托 public delegate void UserInput(object sender, EventArgs e); // 定义一个此委托类型的事件 public event UserInput OnUserInput; // 模拟事件触发，当输入“0”时引发事件 public void Method() &#123; bool flag = false; Console.WriteLine("请输入数字："); while (!flag) &#123; if (Console.ReadLine() == "0") &#123; OnUserInput(this, new EventArgs()); &#125; &#125; &#125; &#125;&#125; 在类EventTest中定义了一个委托UserInput和一个事件OnUserInput，EventTest充当观察目标类的角色，而委托充当抽象观察者角色，在方法Method()中引发了事件，即调用与委托具有相同函数签名的方法，方法Method()即为目标类的通知方法。 在客户端测试类Program中提供了具体的事件处理方法，并将该方法和事件绑定在一起，这个过程称为订阅事件。Program类的代码如下： Program.cs 123456789101112131415161718192021222324252627282930313233using System;namespace ObserverExtend&#123; class Program &#123; public Program(EventTest test) &#123; // 注册事件或订阅事件 test.OnUserInput += new EventTest.UserInput(Handler); test.OnUserInput += new EventTest.UserInput(HandlerMore); // 注销事件或取消订阅 // test.OnUserInput -= new EventTest.UserInput(Handler); &#125; public void Handler(object sender, EventArgs e) &#123; Console.WriteLine("数据输入结束！"); &#125; public void HandlerMore(object sender, EventArgs e) &#123; Console.WriteLine("真的结束了！"); &#125; static void Main(string[] args) &#123; EventTest test = new EventTest(); Program program = new Program(test); test.Method(); &#125; &#125;&#125; 在Program的构造函数中订阅了事件，在此处，通过委托将两个方法添加到事件中，即该事件有两个订阅者，当事件触发时同时触发这些方法的执行。Program类充当了具体观察者角色，可以对目标类的事件做出响应，在此，方法Handler()和HandlerMore()即为响应方法。编译并运行程序，输出结果如下：123456请输入数字： 321数据输入结束！真的结束了！ 如果在另一个类中也需要处理该事件，无须修改EventTest类的源代码，只需要按照委托的规范编写事件处理程序并订阅事件即可，系统具有很好的扩展性，相同的目标可以对应于不同的观察者，相同的事件可以对应于不同的事件处理程序。.NET中的事件处理模型是观察者模式的一种变形，它与观察者模式的实现原理本质上是一致的。 观察者模式与MVC在当前流行的MVC（Model-View-Controller）架构中也应用了观察者模式，MVC是一种架构模式，它包含3个角色：模型（Model）、视图（View）和控制器（Controller）。其中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容。MVC结构示意图如图5所示。 图5 MVC结构示意图 在图5中，模型层提供的数据是视图层所观察的对象，在视图层中包含两个用于显示数据的图表对象，一个是柱状图，一个是饼状图，相同的数据拥有不同的图表显示方式，如果模型层的数据发生改变，两个图表对象将随之发生变化，这意味着图表对象依赖模型层提供的数据对象，因此数据对象的任何状态改变都应立即通知它们。同时，这两个图表之间相互独立，不存在任何联系，而且图表对象的个数没有任何限制，用户可以根据需要再增加新的图表对象，例如折线图。在增加新的图表对象时，无须修改原有类库，符合开闭原则。 观察者模式的优缺点与适用环境观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用还是桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及一对一或者一对多的对象交互场景都可以使用观察者模式。观察者模式广泛应用于各种编程语言的GUI事件处理的实现，在基于事件的XML解析技术以及Web事件处理中也都使用了观察者模式。 观察者模式的优点观察者模式的主要优点如下： (1)观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 (2)在观察目标和观察者之间建立一个抽象的耦合，观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 (3)观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 (4)观察者模式符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。 观察者模式的缺点观察者模式的主要缺点如下： (1)如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。 (2)如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们进行循环调用，可能导致系统崩溃。 (3)观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化。 观察者模式的适用环境在以下情况下可以考虑使用观察者模式： (1)一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。 (2)一个对象的改变将导致一个或多个其他对象发生改变，且不知道具体有多少对象将发生改变，也不知道这些对象是谁。 (3)需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……可以使用观察者模式创建一种链式触发机制。 本章小结(1)在观察者模式中，定义了对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。观察者模式是一种对象行为型模式。 (2)观察者模式包含目标、具体目标、观察者和具体观察者4个角色。其中，目标是指被观察的对象；具体目标是目标类的子类，通常包含经常发生改变的数据，当它的状态发生改变时，将向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；具体观察者是观察者的子类，实现在观察者中声明的更新数据的方法。 (3)观察者模式的主要优点是可以实现表示层和数据逻辑层的分离；在观察目标和观察者之间建立一个抽象的耦合；支持广播通信且符合开闭原则。其主要缺点是将所有的观察者都通知到会花费很多时间；如果存在循环调用可能导致系统崩溃；没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化。 (4)观察者模式适用的环境：一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用；一个对象的改变将导致一个或多个其他对象也发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁；需要在系统中创建一个触发链。 (5).NET中的委托事件模型是观察者模式在.NET中的经典应用。事件源对象充当观察目标角色，事件处理对象充当具体观察者角色，如果事件源对象的某个事件触发，则调用事件处理对象中的事件处理程序对事件进行处理。 (6)MVC架构中应用了观察者模式，其中模型对应于观察者模式中的观察目标，视图对应于观察者，控制器可充当两者之间的中介者。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 外观模式是迪米特法则的一种具体实现。什么是迪米特法则？怎么实现的？ 使用外观模式要引入一个新的外观角色，怎么理解？ 抽象外观类可以解决传统的外观模式违反开闭原则的缺点。怎么理解？ 外观模式为什么是结构型设计模式？ 客户端通过外观角色来间接访问子系统。怎么理解？ 本章导学 外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。 本章将学习外观模式的定义与结构，结合实例学习如何使用外观模式并分析外观模式的优缺点。 本章知识点 外观模式的定义 外观模式的结构 外观模式的实现 外观模式的应用 外观模式的优缺点 外观模式的适用环境 抽象外观类 外观模式概述不知道大家有没有比较过自己泡茶和去茶馆喝茶的区别，如果是自己泡茶，需要自行准备茶叶、茶具和开水，如图1（a）所示，而去茶馆喝茶，最简单的方式就是跟茶馆服务员说想要一杯什么样的茶，是铁观音、碧螺春还是西湖龙井。正因为茶馆有服务员，顾客无须直接和茶叶、茶具、开水等交互，整个泡茶过程由服务员来完成，顾客只需与服务员交互即可，整个过程非常简单、省事，如图1（b）所示。 图1 两种喝茶方式示意图 在软件开发中，有时为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互。外观模式通过引入一个新的外观类（Facade）来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。在外观模式中，需要交互的业务类被称为子系统（SubSystem）。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大，如图2（a）所示；而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度，如图2（b）所示。 图2 外观模式示意图 在外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。 外观模式（Facade）的定义如下：1为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式又称为门面模式，它是一种对象结构型模式。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统的耦合度。 外观模式的结构与实现外观模式的结构外观模式没有一个一般化的类图描述，通常使用如图2（b）所示的示意图来表示外观模式。图3所示的类图也可以作为描述外观模式的结构图。 图3 外观模式结构图 由图3可知，外观模式包含以下两个角色。 (1)Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。 (2)SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。 外观模式的实现外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。 外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下： 1234567891011121314151617181920212223class SubSystemA&#123; public void MethodA() &#123; // 业务实例代码 &#125;&#125;class SubSystemB&#123; public void MethodB() &#123; // 业务实例代码 &#125;&#125;class SubSystemC&#123; public void MethodC() &#123; // 业务实例代码 &#125;&#125; 在引入外观类之后，与子系统业务类之间的交互统一由外观类来完成，在外观类中通常存在以下代码：12345678910111213class Facade&#123; private SubSystemA obj1 = new SubSystemA(); private SubSystemB obj2 = new SubSystemB(); private SubSystemC obj3 = new SubSystemC(); public void Method() &#123; obj1.MethodA(); obj2.MethodB(); obj3.MethodC(); &#125;&#125; 由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。引入外观类后，客户端代码变得非常简单，其典型代码如下：12345678class Program&#123; static void Main(string[] args) &#123; Facade facade = new Facade(); facade.Method(); &#125;&#125; 外观模式的应用实例下面通过一个应用实例来进一步学习和理解外观模式。 1.实例说明 某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。现使用外观模式设计该文件加密模块。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 文件加密模块结构图 在图4中，EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。 3.实例代码 (1)FileReader：文件读取类、充当子系统类。 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Text;using System.IO;namespace FacadeSample&#123; class FileReader &#123; public string Read(string fileNameSrc) &#123; Console.Write("读取文件，获取明文："); FileStream fs = null; StringBuilder sb = new StringBuilder(); try &#123; fs = new FileStream(fileNameSrc, FileMode.Open); int data; while((data = fs.ReadByte())!= -1) &#123; sb = sb.Append((char)data); &#125; fs.Close(); Console.WriteLine(sb.ToString()); &#125; catch(FileNotFoundException e) &#123; Console.WriteLine("文件不存在！"); &#125; catch(IOException e) &#123; Console.WriteLine("文件操作错误！"); &#125; return sb.ToString(); &#125; &#125;&#125; (2)CipherMachine：数据加密类，充当子系统类。 1234567891011121314151617181920212223242526using System;using System.Text;namespace FacadeSample&#123; class CipherMachine &#123; public string Encrypt(string plainText) &#123; Console.Write("数据加密，将明文转换为密文："); string es = ""; char[] chars = plainText.ToCharArray(); foreach(char ch in chars) &#123; string c = (ch % 7).ToString(); es += c; &#125; Console.WriteLine(es); return es; &#125; &#125;&#125; (3)FileWriter：文件保存类，充当子系统类。 12345678910111213141516171819202122232425262728293031323334using System;using System.IO;using System.Text;namespace FacadeSample&#123; class FileWriter &#123; public void Write(string encryptStr,string fileNameDes) &#123; Console.WriteLine("保存密文，写入文件。"); FileStream fs = null; try &#123; fs = new FileStream(fileNameDes, FileMode.Create); byte[] str = Encoding.Default.GetBytes(encryptStr); fs.Write(str,0,str.Length); fs.Flush(); fs.Close(); &#125; catch(FileNotFoundException e) &#123; Console.WriteLine("文件不存在！"); &#125; catch(IOException e) &#123; Console.WriteLine(e.Message); Console.WriteLine("文件操作错误！"); &#125; &#125; &#125;&#125; (4)EncryptFacade：加密外观类，充当外观类。 12345678910111213141516171819202122232425namespace FacadeSample&#123; class EncryptFacade &#123; // 维持对其他对象的引用 private FileReader reader; private CipherMachine cipher; private FileWriter writer; public EncryptFacade() &#123; reader = new FileReader(); cipher = new CipherMachine(); writer = new FileWriter(); &#125; // 调用其他对象的业务方法 public void FileEncrypt(string fileNameSrc, string fileNameDes) &#123; string plainStr = reader.Read(fileNameSrc); string encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); &#125; &#125;&#125; (5)Program：客户端测试类 1234567891011121314151617using System;using System.Configuration;using System.Reflection;namespace FacadeSample&#123; class Program &#123; static void Main(string[] args) &#123; EncryptFacade ef = new EncryptFacade(); ef.FileEncrypt("src.txt", "des.txt"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：123读取文件，获取明文：Hello World!数据加密，将明文转换为密文：233364062325保存密文，写入文件。 在本实例中，对文件src.txt中的数据进行加密，该文件内容为“Hello World!”，加密之后将密文保存到另一个文件des.txt中，程序运行后保存在文件中的密文为“233364062325”。在加密类CipherMachine中，采用求模运算对明文进行加密，将明文中的每一个字符除以一个整数（本例中为7，可以由用户来进行设置）后取余数作为密文。 抽象外观类在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，在一定程度上解决该问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。 下面通过一个具体实例来学习如何使用抽象外观类。 如果在上一节应用实例“文件加密模块”中需要更换一个加密类，不再使用原有的基于求模运算的加密类CipherMachine，而改为基于移位运算的新加密类NewCipherMachine，其代码如下：12345678910111213141516171819202122232425262728293031323334353637383940using System;namespace FacadeSample&#123; class NewCipherMachine &#123; public string Encrypt(string plainText) &#123; Console.Write("数据加密，将明文转换为密文："); string es = ""; int key = 10;// 设置密钥，移位数为10 char[] chars = plainText.ToCharArray(); foreach(char ch in chars) &#123; int temp = Convert.ToInt32(ch); // 小写字母移位 if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; temp += key % 26; if (temp &gt; 122) temp -= 26; if (temp &lt; 97) temp += 26; &#125; // 大写字母移位 if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; temp += key % 26; if (temp &gt; 90) temp -= 26; if (temp &lt; 65) temp += 26; &#125; es += ((char)temp).ToString(); &#125; Console.WriteLine(es); return es; &#125; &#125;&#125; 如果不增加新的外观类，只能通过修改原有外观类EncryptFacade的源代码来实现加密类的更换，将原有的对CipherMachine类型对象的引用改为对NewCipherMachine类型对象的引用，这违背了开闭原则，因此需要通过增加新的外观类来实现对子系统对象引用的改变。 如果增加一个新的外观类NewEncryptFacade与FileReader类、FileWriter类及新增加的NewCipherMachine类进行交互，虽然原有系统类库无须做任何修改，但是因为在客户端代码中原来针对EncryptFacade类进行编程，现在需要改为NewEncryptFacade类，因此需要修改客户端源代码。 如何在不修改客户端代码的前提下使用新的外观类呢？解决方法之一是引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类。引入抽象外观类之后的文件加密模块结构如图5所示。 图5 引入抽象外观类之后的文件加密模块结构图 在图5中，客户类Client针对抽象外观类AbstractEncryptFacade进行编程，AbstractEncryptFacade代码如下：1234567namespace FacadeSample&#123; abstract class AbstractEncryptFacade &#123; public abstract void FileEncrypt(string fileNameSrc, string fileNameDes); &#125;&#125; 新增具体加密外观类NewEncryptFacade的代码如下：1234567891011121314151617181920212223namespace FacadeSample&#123; class NewEncryptFacade : AbstractEncryptFacade &#123; private FileReader reader; private NewCipherMachine cipher; private FileWriter writer; public NewEncryptFacade() &#123; reader = new FileReader(); cipher = new NewCipherMachine(); writer = new FileWriter(); &#125; public override void FileEncrypt(string fileNameSrc, string fileNameDes) &#123; string plainStr = reader.Read(fileNameSrc); string encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); &#125; &#125;&#125; 配置文件App.config中存储了具体外观类的类名，其代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="facade" value="FacadeSample.NewEncryptFacade"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 将客户端测试代码修改如下：123456789101112131415161718192021using System;using System.Configuration;using System.Reflection;namespace FacadeSample&#123; class Program &#123; static void Main(string[] args) &#123; AbstractEncryptFacade ef; // 针对抽象外观类编程 // 读取配置文件 string facadeString = ConfigurationManager.AppSettings["facade"]; // 反射生成对象 ef = (AbstractEncryptFacade)Assembly.Load("FacadeSample").CreateInstance(facadeString); ef.FileEncrypt("src.txt", "des.txt"); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：123读取文件，获取明文：Hello World!数据加密，将明文转换为密文：Rovvy gybvn!保存密文，写入文件。 原有外观类EncryptFacade也需作为抽象外观类AbstractEncryptFacade的子类，更换具体外观类时只需修改配置文件，无须修改源代码，符合开闭原则。 外观模式的优缺点与适用环境外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。在几乎所有的软件中都能够找到外观模式的应用，如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度，所有涉及与多个业务对象交互的环境都可以考虑使用外观模式进行重构。 外观模式的优点外观模式的主要优点如下： (1)它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。 (2)它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。 (3)一个子系统的修改对其他子系统没有任何影响，而且子系统的内部变化也不会影响到外观对象。 外观模式的缺点外观模式的主要缺点如下： (1)外观模式不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。 (2)如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 外观模式的适用环境在以下情况下可以考虑使用外观模式： (1)当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。 (2)客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。 (3)在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度。 本章小结(1)外观模式为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 (2)外观模式包含外观和子系统两个角色。其中，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任，客户端通过外观角色来间接访问子系统；在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能，每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求。 (3)外观模式主要优点是对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。其主要缺点是不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性；如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 (4)外观模式适用的环境：要为访问一系列复杂的子系统提供一个简单入口；客户端程序与多个子系统之间存在很大的依赖性；在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度。 (5)用户可以通过抽象外观类对系统进行改进，引入抽象外观类之后，客户端针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而只需对应地增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，并且通过修改配置文件达到不修改任何源代码更换外观类的目的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2019%2F09%2F19%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 中介者模式可以从更宏观的角度来看待问题。怎么理解？ 抽象中介者的public abstract void Send(string message, Colleague colleague);这行代码怎么理解？ 最关键的问题在于ConcreteMediator这个类必须要知道所有的ConcreteColleague。这句话怎么理解？这样会有什么问题？ 联合国中介者模式又叫做调停者模式。其实就是中间人或者调停者的意思。 联合国就是一个调停者、中介者的角色。国与国之间的关系，就类似于不同的对象与对象之间的关系，这就要求对象之间需要知道其他所有对象，尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性。 这是因为大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。 ‘迪米特法则’认为，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以，国与国之间完全可以通过‘联合国’这个中介者来发生关系，而不用直接通信。 通过中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过‘中介者’对象与另一个对象发生相互作用。中介者对象的设计，使得系统的结构通过中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构不会因为新对象的引入造成大量的修改工作。 之前解释‘迪米特法则’的时候，是以公司的IT部门的管理为例子，让一个刚进公司的人去求任何一个不认识的IT部同事帮忙是有困难的，但如果是有IT主管来协调工作，就不至于发生第一天上班却没有电脑进行工作的局面。IT主管就是一个‘中介者’对象。 中介者模式中介者模式的定义如下：1用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式（Mediator）结构图 Colleague叫做抽象同事类，而ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们却都认识中介者对象。Mediator是抽象中介者，定义了同事对象到中介者对象的接口，ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。 Mediator类 抽象中介者类 12345abstract class Mediator&#123; // 定义一个抽象的发送消息方法，得到同事对象和发送信息 public abstract void Send(string message, Colleague colleague);&#125; Colleague类 抽象同事类 12345678910abstract class Colleague&#123; protected Mediator mediator; // 构造方法，得到中介者对象 public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; ConcreteMediator类 具体中介者类 1234567891011121314151617181920212223242526272829class ConcreteMediator : Mediator&#123; // 需要了解所有的具体同事对象 private ConcreteColleague1 colleague1; private ConcreteColleague2 colleague2; public ConcreteColleague1 Colleague1 &#123; set &#123; colleague1 = value; &#125; &#125; public ConcreteColleague2 Colleague2 &#123; set &#123; colleague2 = value; &#125; &#125; // 重写发送信息的方法，根据对象做出选择判断，通知对象 public override void Send(string message, Colleague colleague) &#123; if (colleague == colleague1) &#123; colleague2.Notify(message); &#125; else &#123; colleague1.Notify(message); &#125; &#125;&#125; ConcreteColleague1和ConcreteColleague2等各种同事对象12345678910111213141516171819202122232425262728293031323334353637class ConcreteColleague1 : Colleague&#123; public ConcreteColleague1(Mediator mediator) : base(mediator) &#123; &#125; public void Send(string message) &#123; // 发送信息时通常是中介者发送出去的 mediator.Send(message, this); &#125; public void Notify(string message) &#123; Console.WriteLine("同事1得到信息:" + message); &#125;&#125;class ConcreteColleague2 : Colleague&#123; public ConcreteColleague2(Mediator mediator) : base(mediator) &#123; &#125; public void Send(string message) &#123; mediator.Send(message, this); &#125; public void Notify(string message) &#123; Console.WriteLine("同事2得到信息:" + message); &#125;&#125; 客户端 123456789101112131415161718192021class Program&#123; static void Main(string[] args) &#123; ConcreteMediator m = new ConcreteMediator(); // 让两个具体同事类认识中介者对象 ConcreteColleague1 c1 = new ConcreteColleague1(m); ConcreteColleague2 c2 = new ConcreteColleague2(m); // 让中介者认识各个具体同事类对象 m.Colleague1 = c1; m.Colleague2 = c2; // 具体同事类对象的发送信息都是通过中介者转发 c1.Send("吃过饭了吗?"); c2.Send("没有呢，你打算请客？"); Console.Read(); &#125;&#125; 由于有了Mediator，使得ConcreteColleague1和ConcreteColleague2在发送消息和接收信息时其实是通过中介者来完成的，这就减少了它们之间的耦合度了。 安理会做中介下面让美国和伊拉克之间的对话都通过联合国安理会作为中介来完成。 美国和伊拉克都是国家，所以有一个国家抽象类和两个具体国家类。‘联合国’是Mediator还是ConcreteMediator取决于未来是否有可能扩展中介者对象，联合国除了安理会，还有如国际劳工组织、教科文组织、世界卫生组织、世界贸易组织等等很多机构，所以Mediator应该是‘联合国机构’，而‘安理会’是一个具体的中介者。 如果不存在扩展情况，那么Mediator可以与ConcreteMediator合二为一。 代码结构图 联合国机构类 相当于Mediator类 12345678910// 联合国机构abstract class UnitedNations&#123; /// &lt;summary&gt; /// 声明 /// &lt;/summary&gt; /// &lt;param name="message"&gt;声明信息&lt;/param&gt; /// &lt;param name="colleague"&gt;声明国家&lt;/param&gt; public abstract void Declare(string message, Country colleague);&#125; 国家类 相当于Colleague类 12345678910// 国家abstract class Country&#123; protected UnitedNations mediator; public Country(UnitedNations mediator) &#123; this.mediator = mediator; &#125;&#125; 美国类 相当于ConcreteColleague1类 1234567891011121314151617181920 // 美国class USA : Country&#123; public USA(UnitedNations mediator) : base(mediator) &#123; &#125; // 声明 public void Declare(string message) &#123; mediator.Declare(message, this); &#125; // 获得消息 public void GetMessage(string message) &#123; Console.WriteLine("美国获得对方信息：" + message); &#125;&#125; 伊拉克类 相当于ConcreteColleague2类 1234567891011121314151617181920// 伊拉克class Iraq : Country&#123; public Iraq(UnitedNations mediator) : base(mediator) &#123; &#125; // 声明 public void Declare(string message) &#123; mediator.Declare(message, this); &#125; // 获得消息 public void GetMessage(string message) &#123; Console.WriteLine("伊拉克获得对方信息：" + message); &#125;&#125; 联合国安理会 相当于ConcreteMediator类 123456789101112131415161718192021222324252627282930// 联合国安全理事会class UnitedNationsSecurityCouncil : UnitedNations&#123; private USA colleague1; private Iraq colleague2; // 联合国安理会了解所有的国家，所以拥有美国和伊拉克的对象属性 public USA Colleague1 &#123; set &#123; colleague1 = value; &#125; &#125; public Iraq Colleague2 &#123; set &#123; colleague2 = value; &#125; &#125; // 重写了“声明”方法，实现了两个对象间的通信 public override void Declare(string message, Country colleague) &#123; if (colleague == colleague1) &#123; colleague2.GetMessage(message); &#125; else &#123; colleague1.GetMessage(message); &#125; &#125;&#125; 客户端 123456789101112131415161718class Program&#123; static void Main(string[] args) &#123; UnitedNationsSecurityCouncil UNSC = new UnitedNationsSecurityCouncil(); USA c1 = new USA(UNSC); Iraq c2 = new Iraq(UNSC); UNSC.Colleague1 = c1; UNSC.Colleague2 = c2; c1.Declare("不准研制核武器，否则要发动战争！"); c2.Declare("我们没有核武器，也不怕侵略。"); Console.Read(); &#125;&#125; 结果显示 12伊拉克获得对方信息：不准研制核武器，否则要发动战争。美国获得对方信息：我们没有核武器，也不怕侵略。 最关键的问题在于ConcreteMediator这个类必须要知道所有的ConcreteColleague，这样的设计可以减少了ConcreteColleague类之间的耦合，但这又使得ConcreteMediator责任太多了，如果它出了问题，则整个系统都会有问题。 中介者模式优缺点如果联合国安理会出了问题，会对世界都造成影响。所以说，中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了‘多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思系统在设计上是不是合理。 中介者模式的优点： 1.Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator，比如任何国家的改变不会影响到其他国家，而只是与安理会发生变化。 2.简化了对象协议，用Mediator和各Colleague间的一对多的交互来替代多对多的交互。一对多的关系更易于理解，维护和扩展。 3.由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。比如巴以冲突，本来只能算是国与国之间的矛盾，因此各自的看法可能都比较狭隘，但站在联合国安理会的角度，就可以从全球化、也更客观角度来看待这个问题，在调停和维和上做出贡献。 4.可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。 中介者模式的缺点： 具体中介者类ConcreteMediator可能会因为ConcreteColleague的越来越多，而变得非常复杂，反而不容易维护。 由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。事实上，联合国安理会秘书长的工作是非常繁忙的。也正因为此，中介者模式的优点来自集中控制，其缺点也是它，使用时要考虑清楚。 中介者模式的应用**计算器程序** 它上面有菜单控件、文本控件、多个按钮控件和一个Form窗体，每个控件的类代码都被封装，所以它们的实例是不会知道其他控件对象的存在的，比如点击数字按钮要在文本框中显示数字。如果是在Button类中编写给TextBox类实例的Text属性赋值的代码，会造成两个类有耦合，这显然是非常不合理的。 实际情况是它们都有事件机制，而事件的执行都是在Form窗体的代码中完成，也就是说所有的控件的交互都是由Form窗体来作中介，操作各个对象，这是典型的中介者模式应用。 **数据库** 世界上存在着各种各样的数据库，不同数据库有各自的应用场景，对于同一份数据，最开始可能使用关系型数据库（如MySQL）进行存储查询，使用Redis作为缓存数据库，当数据量较大时使用MySQL进行查询可能较慢，所以需要将数据同步到Elasticsearch或者列式数据库如Hbase中进行大数据查询。 如何设计数据同步方案是一个重要的问题。数据源众多，目标端也众多，设计得不好可能 “牵一发而动全身”。 如果我们这样设计：每个数据源直接同步数据到目标端数据库的，如果数据库有N个，那么最多可能的同步作业将达到N * N个，当修改了其中一个数据库的某些配置，可能需要修改另外的N - 1个数据库的同步作业。 现在介绍另一种方案，DataX是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS等各种异构数据源之间高效的数据同步功能。 DataX 其实相当于一个中介，从数据源读取数据，写入到目标端，数据源不再需要维护到目标端的同步作业，只需要与DataX通信即可。DataX体现了中介者模式的思想。 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，比如刚才得到的窗体Form对象，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 最简单的抽象命令类万年不变是什么意思？ 命令模式为什么是行为型模式？是如何将请求发送者与请求接收者解耦的？ 什么是命令对象？为什么实现了间接引用？ 是怎么做到可以在不修改现有系统源代码的情况下让相同的发送者对应不同的接收者的？ 命令模式的核心在于引入了抽象命令类和具体命令类。怎么理解？ 可以在具体命令类里直接new请求接收者，也可以在客户端注入。怎么理解？ “用不同的请求对客户进行参数化”，客户端只需要将具体命令对象作为参数注入请求发送者。怎么理解？ 将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。怎么理解？ 一个调用者并不需要在设计时确定其接收者，因此只与抽象命令类之间存在关联关系。怎么理解？ 在具体命令类里写代码时直接new Receiver了。怎么理解？ 本章导学 命令模式是常用的行为型模式之一，它将请求发送者与请求接收者解耦，请求发送者通过命令对象来间接引用接收者，使得系统具有更好的灵活性，可以在不修改现有系统源代码的情况下让相同的发送者对应不同的接收者。 本章将学习命令模式的定义与结构，结合实例学习如何实现命令模式，并理解命令队列、请求日志、撤销操作和宏命令的实现原理。 本章知识点 命令模式的定义 命令模式的结构 命令模式的实现 命令模式的应用 实现命令队列 记录请求日志 实现撤销操作 宏命令 命令模式的优缺点 命令模式的适用环境 命令模式概述在现实生活中，人们通过使用开关来控制一些电器的打开和关闭，例如电灯或者排气扇。在购买开关时，购买者可能并不知道它将来到底用于控制什么电器，也就是说，开关与电灯、排气扇并无直接关系，一个开关在安装之后可能用来控制电灯，也可能用来控制排气扇或者其他电器设备。开关与电器之间通过电线建立连接，如果开关打开，则电线通电，电器工作；反之，开关关闭，电线断电，电器停止工作。相同的开关可以通过不同的电线来控制不同的电器，如图1所示。 图1 开关与电灯、排气扇示意图 在图1中，可以将开关理解成一个请求的发送者，用户通过它来发送一个“开灯”请求，而电灯是“开灯”请求的最终接收者和处理者，开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。 在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如一个按钮，它可能是一个“关闭窗口”请求的发送者，而按钮单击事件处理类则是该请求的接收者。为了降低系统的耦合度，将请求的发送者和接收者解耦，可以使用一种被称为命令模式的设计模式来设计系统。在命令模式中，发送者与接收者之间引入了新的命令对象（类似图1中的电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 命令模式的定义如下:1将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。 命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。命令模式的定义比较复杂，提到了很多术语，例如“用不同的请求对客户进行参数化”、“对请求排队”、“记录请求日志”、“支持可撤销操作”等。 命令模式的结构与实现命令模式的结构命令模式的核心在于引入了抽象命令类和具体命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法即可，其结构如图2所示。 图2 命令模式结构图 由图2可知，命令模式包含以下4个角色。 (1)Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的Execute()等方法，通过这些方法可以调用请求接收者的相关操作。 (2)ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现Execute()方法时，将调用接收者对象的相关操作。 (3)Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的Execute()方法，从而实现间接调用请求接收者的相关操作。 (4)Receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理。 命令模式的实现命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。 命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的Execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了Execute()方法的不同实现，并调用不同接收者的请求处理方法。 典型的抽象命令类代码如下：1234abstract class Command&#123; public abstract void Execute();&#125; 对于请求发送者（即调用者）而言，将针对抽象命令类进行编程，可以通过构造函数或者Setter方法在运行时注入具体命令类对象，并在业务方法中调用命令对象的Execute()方法。其典型代码如下：1234567891011121314151617181920212223class Invoker&#123; private Command command; // 构造注入 public Invoker(Command command) &#123; this.command = command; &#125; public Command command &#123; get&#123; return command; &#125; // 设值注入 set&#123; command = value; &#125; &#125; // 业务方法，用于调用命令类的方法 public void Call() &#123; command.Execute(); &#125;&#125; 具体命令类继承了抽象命令类，它与请求接收者相关联，实现了在抽象命令类中声明的Execute()方法，并在实现时调用接收者的请求响应方法Action()。其典型代码如下：1234567891011class ConcreteCommand : Command&#123; // 维持一个对请求接收者对象的引用 private Receiver receiver; public override void Execute() &#123; // 调用请求接收者的业务处理方法Action() receiver.Action(); &#125;&#125; 请求接收者Receiver具体实现对请求的业务处理，它拥有Action()方法，用于执行与请求相关的操作。其典型代码如下：1234567class Receiver&#123; public void Action() &#123; // 具体操作 &#125;&#125; 命令模式的应用实例下面通过一个应用实例来进一步学习和理解命令模式。 1.实例说明 为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）。用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 功能键设置结构图 在图3中，FunctionButton充当请求调用者，SystemExitClass和DisplayHelpClass充当请求接收者，Command是抽象命令类，ExitCommand和HelpCommand充当具体命令类。 3.实例代码 (1)FunctionButton：功能键，充当请求调用者（请求发送者）。 FunctionButton.cs 1234567891011121314151617181920212223using System;namespace CommandSample&#123; class FunctionButton &#123; private Command command; // 维持一个抽象命令对象的引用 // 为功能键注入命令 public Command Command &#123; get&#123; return command; &#125; set&#123; command = value; &#125; &#125; // 发送请求的方法 public void Click() &#123; Console.WriteLine("单击功能键！"); command.Execute(); &#125; &#125;&#125; (2)Command：抽象命令类 Command.cs 1234567namespace CommandSample&#123; abstract class Command &#123; public abstract void Execute(); &#125;&#125; (3)ExitCommand：退出命令类，充当具体命令类 ExitCommand.cs 123456789101112131415161718namespace CommandSample&#123; class ExitCommand : Command &#123; private SystemExitClass seObj; // 维持对请求接收者的引用 public ExitCommand() &#123; seObj = new SystemExitClass(); &#125; // 命令执行方法，将调用请求接收者的业务方法 public override void Execute() &#123; seObj.Exit(); &#125; &#125;&#125; (4)HelpCommand：帮助命令类，充当具体命令类。 HelpCommand.cs 123456789101112131415161718namespace CommandSample&#123; class HelpCommand : Command &#123; private DisplayHelpClass hcObj; // 维持对请求接收者的引用 public HelpCommand() &#123; hcObj = new DisplayHelpClass(); &#125; // 命令执行方法，将调用请求接收者的业务方法 public override void Execute() &#123; hcObj.Display(); &#125; &#125;&#125; (5)SystemExitClass：退出系统模拟实现类，充当请求接收者。 SystemExitClass.cs 123456789101112using System;namespace CommandSample&#123; class SystemExitClass &#123; public void Exit() &#123; Console.WriteLine("退出系统"); &#125; &#125;&#125; (6)DisplayHelpClass：显示帮助文档模拟实现类，充当请求接收者。 DisplayHelpClass.cs 123456789101112using System;namespace CommandSample&#123; class DisplayHelpClass &#123; public void Display() &#123; Console.WriteLine("显示帮助文档！"); &#125; &#125;&#125; (7)配置文件App.config：在配置文件中存储了具体命令类的类名。 App.config 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="command" value="CommandSample.ExitCommand" /&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (8)Program：客户端测试类。 Program.cs 123456789101112131415161718192021222324252627using System;using System.Configuration;using System.Reflection;namespace CommandSample&#123; class Program &#123; static void Main(string[] args) &#123; FunctionButton fb = new FunctionButton(); Command command; // 定义命令对象 // 读取配置文件 string commandStr = ConfigurationManager.AppSettings["command"]; // 反射生成对象 command = (Command)Assembly.Load("CommandSample").CreateInstance(commandStr); // 将命令对象注入功能键 fb.Command = command; // 调用功能键的业务方法 fb.Click(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12单击功能键！退出系统！ 如果需要更换具体命令类，无需修改源代码，只需修改配置文件，例如将退出命令改为帮助命令，只需将存储在配置文件中的具体命令类类名ExitCommand改为HelpCommand。其代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="command" value="CommandSample.HelpCommand" /&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 重新运行客户端程序，输出结果如下：12单击功能键！显示帮助文档！ 如果在系统中增加了新的功能，功能键需要与新功能对应，只需要对应增加一个新的具体命令类，在新的具体命令类中调用新功能类的业务方法，然后将该具体命令类的对象通过配置文件注入功能键即可，原有代码无须修改，符合开闭原则。 在命令模式中，每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使相同的发送者对应不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”，客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者。 实现命令队列当一个请求发送者发送一个请求时，有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理。此时，可以通过命令队列来实现。 命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式是增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。CommandQueue类的典型代码如下: CommandQueue.cs 1234567891011121314151617181920212223242526272829using System.Collections.Generic;namespace CommandSample&#123; class CommandQueue &#123; // 定义一个List来存储命令队列 private List&lt;Command&gt; commands = new List&lt;Command&gt;(); public void AddCommand(Command command) &#123; commands.Add(command); &#125; public void RemoveCommand(Command command) &#123; commands.Remove(command); &#125; // 循环调用每一个命令对象的Execute()方法 public void Execute() &#123; foreach(object command in commands) &#123; ((Command)command).Execute(); &#125; &#125; &#125;&#125; 在增加了命令队列类CommandQueue以后，请求发送者Invoker将针对CommandQueue编程。其代码修改如下： Invoker.cs 1234567891011121314151617181920212223242526namespace CommandSample&#123; class Invoker &#123; // 维持一个CommandQueue对象的引用 private CommandQueue commandQueue; // 构造注入 public Invoker(CommandQueue commandQueue) &#123; this.commandQueue = commandQueue; &#125; // 设值注入 public void SetCommandQueue(CommandQueue commandQueue) &#123; this.commandQueue = commandQueue; &#125; // 调用CommandQueue类的Execute()方法 public void Call() &#123; commandQueue.Execute(); &#125; &#125;&#125; 命令队列与人们常说的“批处理”有点类似。批处理，顾名思义，可以对一组命令对象进行批量处理，当一个发送者发送请求后，将有一系列接收者对请求作出响应。命令队列可以用于设计批处理应用程序，如果请求接收者的接收次序没有严格的先后次序，还可以使用多线程技术并发调用命令对象的Execute()方法，从而提高程序的执行效率。 记录请求日志请求日志就是将请求的历史记录保存下来，通常以日志文件（Log File）的形式永久存储在计算机中。很多系统都提供了日志文件，例如Windows日志文件，Oracle日志文件等，日志文件可以记录用户对系统的一些操作（例如对数据的更改）。请求日志文件可以实现很多功能，其常用功能如下： (1)一旦系统发生故障，日志文件可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利地恢复到某一个特定的状态。 (2)请求日志也可以用于实现批处理，在一个请求日志文件中可以存储一系列命令对象，例如一个命令队列。 (3)用户可以将命令队列中的所有命令对象都存储在一个日志文件中，每执行一个命令则从日志文件中删除一个对应的命令对象，防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行，只需读取日志文件，再继续执行文件中剩余的命令即可。 在实现请求日志时，可以将发送请求的命令对象通过序列化写到日志文件中，此时命令类必须使用属性[Serializable]标记为可序列化。 实现撤销操作在命令模式中，用户可以通过对命令类进行修改使得系统支持撤销（Undo）操作和恢复（Redo）操作，下面通过一个简单实例来学习如何在命令模式中实现撤销操作。 设计一个简易计算器，该计算器可以实现简单的数学运算，还可以对运算实施撤销操作。 使用命令模式设计可得到图4所示的结构图，其中，计算器界面类CalculatorForm充当请求发送者，实现了数据求和功能的加法类Adder充当请求接收者，界面类可间接调用加法类中的Add()方法实现加法运算，并且提供了可撤销加法运算的Undo()方法。 图4 简易计算器结构图 在实例中，加法类Adder充当请求接收者，其代码如下： Adder.cs 123456789101112131415namespace CommandUndoSample&#123; class Adder &#123; // 定义初始值为0 private int num = 0; // 加法操作，每次将传入的值与num做加法运算，再将结果返回 public int Add(int value) &#123; num += value; return num; &#125; &#125;&#125; AbstractCommand充当抽象命令类，声明了Execute()方法和撤销方法Undo()。其代码如下： AbstractCommand.cs 12345678namespace CommandUndoSample&#123; abstract class AbstractCommand &#123; public abstract int Execute(int value); public abstract int Undo(); &#125;&#125; AddCommand充当具体命令类，实现了在抽象命令类AbstractCommand中声明的Execute()方法和撤销方法Undo()。其代码如下： AddCommand.cs 123456789101112131415161718192021namespace CommandUndoSample&#123; class AddCommand : AbstractCommand &#123; private Adder adder = new Adder(); private int value; // 实现抽象命令类中声明的Execute()方法，调用加法类的加法操作 public override int Execute(int value) &#123; this.value = value; return adder.Add(value); &#125; // 实现抽象命令类中声明的Undo()方法，通过加一个相反数来实现加法的逆向操作 public override int Undo() &#123; return adder.Add(-value); &#125; &#125;&#125; CalculatorForm充当请求发送者，它引用一个抽象命令AbstractCommand类型的对象command，通过该command对象间接调用请求接收者Adder类的业务处理方法。其代码如下： CalculatorForm.cs 1234567891011121314151617181920212223242526272829using System;namespace CommandUndoSample&#123; class CalculatorForm &#123; private AbstractCommand command; public AbstractCommand Command &#123; get&#123; return command; &#125; set&#123; command = value; &#125; &#125; // 调用命令对象的Execute()方法执行运算 public void Compute(int value) &#123; int i = Command.Execute(value); Console.WriteLine("执行运算，运算结果为：" + i); &#125; // 调用命令对象的Undo()方法执行撤销 public void Undo() &#123; int i = Command.Undo(); Console.WriteLine("执行撤销，运算结果为：" + i); &#125; &#125;&#125; 在客户端测试类Program中定义了抽象命令类型的命令对象command，还创建了请求发送者对象form，通过调用form对象的Compute()方法实现加法运算，还可以调用Undo()方法撤销最后一次加法运算。其代码如下。 Program.cs 12345678910111213141516171819202122using System;namespace CommandUndoSample&#123; public class Program &#123; static void Main(string[] args) &#123; CalculatorForm form = new CalculatorForm(); AbstractCommand command; command = new AddCommand(); form.Command = command; form.Compute(10); form.Compute(5); form.Compute(10); form.Undo(); // 撤销 Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：1234执行运算，运算结果为：10执行运算，运算结果为：15执行运算，运算结果为：25执行撤销，运算结果为：15 需要注意的是，在本实例中只能实现一步撤销操作，因为没有保存命令对象的历史状态，用户可以通过引入一个命令集合或其他方式来存储每一次操作时命令的状态，从而实现多次撤销操作。除了撤销操作外，还可以采用类似的方式实现恢复（Redo）操作，即恢复所撤销的操作（或称为二次撤销）。 宏命令宏命令（Macro Command）又称为组合命令（Composite Command），它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用。通常，宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。当调用宏命令的Execute()方法时，将递归调用它所包含的每个成员命令的Execute()方法。一个宏命令的成员可以是简单命令，还可以继续是宏命令。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。宏命令结构如图5所示。 图5 宏命令结构图 命令模式的优缺点与适用环境命令模式是一种使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更好的灵活性与可扩展性。在基于GUI的软件开发，无论是计算机桌面应用还是手机移动应用中，命令模式都得到了广泛的应用。 命令模式的优点命令模式的主要优点如下： (1)命令模式降低了系统的藕合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现了完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 (2)通过使用命令模式，新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响其他类，所以增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足开闭原则的要求。 (3)使用命令模式可以比较容易地设计一个命令队列或宏命令（组合命令）。 (4)命令模式为请求的撤销（Undo）和恢复（Redo）操作提供了一种设计和实现方案。 命令模式的缺点命令模式的主要缺点如下： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，所以在某些系统中可能需要提供大量的具体命令类,，这将影响命令模式的使用。 命令模式的适用环境在以下情况下可以考虑使用命令模式： (1)系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 (2)系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期。换而言之，最初的请求发出者可能已经不在了，但命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 (3)系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作。 (4)系统需要将一组操作组合在一起形成宏命令。 本章小结(1)在命令模式中，将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，将请求排队或者记录请求日志以及支持可撤销的操作。命令模式是一种对象行为型模式。 (2)命令模式包含抽象命令类、具体命令类、调用者和接收者4个角色。其中，抽象命令类声明了用于执型请求的Execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，在实现Execute()方法时，将调用接收者对象的相关操作；调用者即请求发送者，它通过命令对象来执行请求；接收者执行与请求相关的操作，具体实现对请求的业务处理。 (3)命令模式的主要优点包括降低了系统的耦合度，增加新的命令很容易，可以比较容易地设计一个命令队列或宏命令，还为请求的撤销和恢复操作提供了一种设计和实现方案。其主要缺点是使用命令模式可能会导致某些系统有过多的具体命令类。 (4)命令模式适用的环境：系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；系统需要在不同的时间指定请求、将请求排队和执行请求；系统需要支持命令的撤销操作和恢复操作；系统需要将一组操作组合在一起形成宏命令。 (5)如果一个请求发送者发送一个请求后，有不止一个请求接收者产生响应，此时，可以使用命令队列来存储多个命令对象，每个命令对象对应一个请求接收者。 (6)用户可以将命令对象通过序列化写到日志文件中，实现对请求日志的存储。 (7)在命令模式中，用户可以通过对命令类进行修改使得系统支持撤销操作和恢复操作。 (8)宏命令又称为组合命令，它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 饿汉式单例与懒汉式单例有什么区别？ 本章导学 单例模式是结构最简单的设计模式，在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以确保系统中的一个类只有一个实例，而且该实例易被外界访问，从而方便对实例个数进行控制，节约系统资源。 本章将学习如何使用单例模式来确保系统中某个类的实例对象的唯一性，学习单例模式的实现方式以及如何在实际项目开发中合理地使用单例模式。 本章知识点 单例模式的定义 单例模式的结构 单例模式的实现 单例模式的应用 单例模式的优缺点 单例模式的适用环境 饿汉式单例和懒汉式单例 单例模式概述对于一个软件系统中的某些类而言，只有一个实例很重要。例如，一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器等。在Windows操作系统中只能打开一个任务管理器窗口，如图1所示。如果不使用机制对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此，有时确保系统中某个对象的唯一性（即一个类只能有一个实例）非常重要。 图1 Windows任务管理器 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个统一的全局变量可以确保对象随时都可以被访问，但不能防止创建多个对象。一个更好的解决办法是让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，它还提供了一个访问该实例的方法，这就是单例模式的动机。 单例模式的定义如下：1确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。 单例模式是一种对象创建型模式。单例模式有3个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 单例模式的结构与实现单例模式的结构单例模式是结构最简单的设计模式，它只包含一个类，即单例类。单例模式的结构如图2所示。 图2 单例模式结构图 由图2可知，单例模式只包含一个单例角色——Singleton（单例），在单例类的内部创建它的唯一实例，并通过静态方法GetInstance()让客户端可以使用它的唯一实例。为了防止在外部对单例类实例化，将其构造函数的可见性设为private，并在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 单例模式的实现单例模式的目的是保证一个类有且仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton，单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，单例类中还包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。 通常，单例模式的实现代码如下：12345678910111213141516171819class Singleton&#123; private static Singleton instance = null; // 静态私有成员变量 // 私有构造函数 private Singleton() &#123; &#125; // 静态公有工厂方法，返回唯一实例 public static Singleton GetInstance() &#123; if(instance == null) instance = new Singleton(); return instance; &#125;&#125; 为了测试单例类所创建对象的唯一性，可以编写以下客户端测试代码：123456789101112131415161718using System;class Program&#123; static void Main(string[] args) &#123; Singleton s1 = Singleton.GetInstance(); Singleton s2 = Singleton.GetInstance(); // 判断两个对象是否相同 if (s1 == s2) &#123; Console.WriteLine("两个对象是相同实例。"); &#125; Console.Read(); &#125;&#125; 编译代码并运行，输出结果为：1两个对象是相同实例。 说明两次调用Getinstance()所获取的对象是同一实例对象，且无法在外部对Singletor进行实例化，因此能够确保系统中只有唯一的一个Singleton对象。 在单例模式的实现过程中，用户需要注意以下3点： (1)单例类构造函数的可见性为private。 (2)提供一个类型为自身的静态私有成员变量。 (3)提供一个公有的静态工厂方法。 单例模式的应用实例下面通过一个应用实例来进一步学习和理解单例模式。 1.实例说明 某软件公司承接了一个服务器负载均衡（Load Balance）软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系元的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态刑减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 服务器负载均衡结构图 在图3中，将负载均衡器LoadBalancer设计为单例角色，其中包含一个存储服务器信息的集合serverList，每次在serverList中随机选择一台服务器来响应客户端的请求。 3.实例代码 (1)LoadBalancer：负载均衡器类，充当单例角色。在真实环境下该类非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，在此只列出部分与模式相关的核心代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections;namespace SingletonSample&#123; class LoadBalancer &#123; // 私有静态成员变量，存储唯一实例 private static LoadBalancer instance = null; // 服务器集合 private ArrayList serverList = null; // 私有构造函数 private LoadBalancer() &#123; serverList = new ArrayList(); &#125; // 公有静态成员方法，返回唯一实例 public static LoadBalancer GetLoadBalancer() &#123; if (instance == null) &#123; instance = new LoadBalancer(); &#125; return instance; &#125; // 增加服务器 public void AddServer(string server) &#123; serverList.Add(server); &#125; // 删除服务器 public void RemoveServer(string server) &#123; serverList.Remove(server); &#125; // 使用Random类随机获取服务器 public string GetServer() &#123; Random random = new Random(); int i = random.Next(serverList.Count); return serverList[i].ToString(); &#125; &#125;&#125; (2)Program：客户端测试类。12345678910111213141516171819202122232425262728293031323334353637using System;namespace SingletonSample&#123; class Program &#123; static void Main(string[] args) &#123; // 创建四个LoadBalancer对象 LoadBalancer balancer1,balancer2,balancer3,balancer4; balancer1 = LoadBalancer.GetLoadBalancer(); balancer2 = LoadBalancer.GetLoadBalancer(); balancer3 = LoadBalancer.GetLoadBalancer(); balancer4 = LoadBalancer.GetLoadBalancer(); // 判断服务器负载均衡器是否相同 if (balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) &#123; Console.WriteLine("服务器负载均衡器具有唯一性！"); &#125; // 增加服务器 balancer1.AddServer("Server 1"); balancer1.AddServer("Server 2"); balancer1.AddServer("Server 3"); balancer1.AddServer("Server 4"); // 模拟客户端请求的分发，如果输出结果全为同一个server，可以将i适当放大，例如改为"i &lt; 100" for (int i = 0; i &lt; 10; i++) &#123; string server = balancer1.GetServer(); Console.WriteLine("分发请求至服务器： " + server); &#125; Console.Read(); &#125; &#125;&#125; 4．结果及分析 编译并运行程序，输出结果如下：1234567891011服务器负载均衡器具有唯一性! 分发请求至服务器: Server 1 分发请求至服务器: Server 1 分发请求至服务器: Server 1 分发请求至服务器: Server 1 分发请求至服务器: Server 2 分发请求至服务器: Server 2 分发请求至服务器: Server 2 分发请求至服务器: Server 2 分发请求至服务器: Server 3 分发请求至服务器: Server 3 虽然创建了4个LoadBalancer对象，但是它们实际上是同一个对象，因此，通过使用单例模式可以确保LoadBalancer对象的唯一性。 饿汉式单例与懒汉式单例1.饿汉式单例类 饿汉式单例类（Eager Singleton）是实现起来最简单的单例类，饿汉式单例类结构如图4所示。 图4 饿汉式单例类图 从图4中可以看出，由于在定义静态变量的时候实例化了单例类，因此在类加载时单例对象就已创建，代码如下：1234567891011class EagerSingleton&#123; private static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123;&#125; public static EagerSingleton GetInstance() &#123; return instance; &#125;&#125; 当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。 2.懒汉式单例类与双重检查锁定 与饿汉式单例类相同的是，懒汉式单例类（Lazy Singleton）的构造函数也是私有的。与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。懒汉式单例类结构如图5所示。 图5 懒汉式单例类图 从图5中可以看出，在懒汉式单例类中，不是在定义静态变量时实例化单例类，而是在第一次调用静态工厂方法时实例化单例类。前面应用实例中的负载均衡器类LoadBalancer就是采用懒汉式单例来实现的。 但是懒汉式单例存在一个很严重的问题：如果在高并发、多线程环境下实现懒汉式单例类，在某一时刻可能会有多个线程需要使用单例对象，即会有多个线程同时调用GetInstance()方法，可能会造成创建多个实例对象，这将违背单例模式的设计意图。为了防止生成多个单例对象，需要使用C#语言中的lock关键字，lock关键字锁定的代码片段称为临界区，可以确保当一个线程位于代码的临界区时，另一个线程不能进入临界区。如果其他线程试图进入锁定的代码，则将一直等待，直到该对象被释放为止。修改之后的懒汉式单例类代码如下：123456789101112131415161718192021222324252627class LazySingleton&#123; private static LazySingleton instance = null; // 程序运行时创建一个静态只读的辅助对象 private static readonly object syncRoot = new object(); private LazySingleton()&#123;&#125; public static LazySingleton GetInstance() &#123; // 第一重判断，先判断实例是否存在，不存在再加锁处理 if (instance == null) &#123; // 加锁的程序在某一时刻只允许一个线程访问 lock(syncRoot) &#123; // 第二重判断 if (instance == null) &#123; instance = new LazySingleton(); // 创建单例实例 &#125; &#125; &#125; return instance; &#125;&#125; 在上面给出的懒汉式单例类实现代码中，对静态工厂方法GetInstance()中创建单例对象的代码进行了加锁、由于在调用时无法确定该单例对象是否已创建，因此需要使用辅助对象syncRoot来进行代码锁定。为了不影响程序的性能，此处只锁定创建单例对象的代码，并未锁定整个方法。如果实例存在则直接返回，如果实例未创建则加锁后再创建。 为了更好地对单例对象的创建进行控制，此处使用了一种被称为双重检查锁定（Double-Check Locking）的双重判断机制。在双重检查锁定中，当实例不存在且同时有两个线程调用GetInstance()方法时，它们都可以通过第一重“instance==null”判断，并且由于lock锁定机制，只有一个线程进入lock中执行创建代码，另一个线程处于排队等待状态，必须等待第一个线程执行完毕才可以进入lock锁定的代码，如果此时不进行第二重“instance-=null”判断，第二个线程并不知道实例已经创建，将继续创建新的实例，还是会产生多个单例对象，违背了单例模式的设计思想，因此需要进行双重检查。 3.饿汉式单例类与懒汉式单例类比较 饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多个线程同时访问的问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然会涉及大量时间，这意味着出现多线程同时首次引用此类的概率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。 单例模式的优缺点与适用环境单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。 单例模式的优点单例模式的主要优点如下： (1)单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以可以严格控制客户怎样访问它以及何时访问它。 (2)由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，使用单例模式无疑可以提高系统的性能。 (3)单例模式允许可变数目的实例。基于单例模式可以进行扩展，使用与控制单例对象相似的方法来获得指定个数的实例对象，既节省系统资源，又解决了由于单例对象共享过多有损性能的问题（自行提供指定数目实例对象的类可称为多例类）。 单例模式的缺点单例模式的主要缺点如下： (1)由于单例模式中没有抽象层，因此，单例类的扩展有很大的困难。 (2)单例类的职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起 (3)现在很多面向对象语言（如C#、Java）的运行环境都提供了自动垃圾回收技术，因此，实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，在下次利用时又将重新实例化，这将导致共享的单例对象状态丢失。 单例模式的适用环境在以下情况下可以考虑使用单例模式： (1)系统只需要一个实例对象，例如系统要求提供一个唯一的序列号生成器或资源管理器，或者因为资源消耗太大而只允许创建一个对象。 (2)客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 本章小结(1)单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供了全局访问的方法。单例模式是一种对象创建型模式。 (2)单例模式只包含一个单例角色。单例类的构造函数为私有，它提供一个自身类型的静态私有成员变量和一个公有的静态工厂方法。 (3)单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重，将太多的功能耦合在一起 (4)单例模式适用的环境：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。 (5)饿汉式单例在类加载的时候创建唯一实例，懒汉式单例在第一次调用静态工厂方法时创建唯一实例。 (6)在懒汉式单例类中，为了确保线程安全，避免创建多个单例对象，需要使用双重检查锁定机制来对单例对象的创建进行控制。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 原型模式是一种特殊的创建型模式，它通过复制一个已有对象来获取更多相同或者相似的对象。原型模式可以提高相同类型对象的创建效率，简化创建过程。 本章将学习原型模式的工作原理和结构，学习如何通过C#语言来实现原型模式，理解浅克隆和深克隆两种机制的异同，并通过实例学习如何实现浅克隆和深克隆。 本章知识点 原型模式的定义 原型模式的结构 浅克隆与深克隆 原型模式的实现 原型模式的应用 原型模式的优缺点 原型模式的适用环境 原型管理器 原型模式概述【西游记】中“孙悟空拔毛变小猴”的故事几乎人人皆知，孙悟空可以用毫毛根据自己的形象，复制出很多和自己长得一模一样的“身外身”来，如图1所示。 图1 孙悟空拔毛变小猴 孙悟空这种根据自己的形象复制（克隆）出多个身外身的技巧，在面向对象软件设计领域被称为原型模式，孙悟空则被称为原型对象。在面向对象系统中，也可以通过复制一个原型对象得到多个与原型对象一模一样的新对象，这就是原型模式的动机。 原型模式的定义如下：1使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。 原型模式是一种对象创建型模式，它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。由于在软件系统中经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在软件开发中具有较高的使用频率。原型模式是一种“另类”的创建型模式，创建新对象（也称为克隆对象）的工厂就是原型类自身，工厂方法由负责复制原型对象的克隆方法来实现。 需要注意的是，通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常，对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式对克隆对象进行修改以后，可以得到一系列相似但不完全相同的对象。 原型模式的结构与实现原型模式的结构原型模式的结构如图2所示。 图2 原型模式结构图 由图2可知，原型模式包含以下3个角色。 (1)Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至可以是具体实现类。 (2)ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 (3)Client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此，用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。 浅克隆与深克隆根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制分为两种：浅克隆（Shallow Clone）和深克隆（Deep Clone）。 1.浅克隆 在浅克隆中，如果原型对象的成员变量是值类型（如int、double、byte、bool、char等基本数据类型），将复制一份给克隆对象；如果原型对象的成员变量是引用类型（如类、接口、数组等复杂数据类型），则将引用对象的地址复制一份给克隆对象，也就是说，原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制，如图3所示。 图3 浅克隆示意图 2.深克隆 在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制，如图4所示。 图4 深克隆示意图 原型模式的实现实现原型模式的关键在于如何实现克隆方法，下面介绍两种在C#语言中常用的克隆实现方法。 1.通用的克隆实现方法 通用的克隆实现方法是在具体原型类的克隆方法中创建一个与自身类型相同的对象并将其返回，是创建的同时将相关参数传入新创建的对象中，保证它们的成员变量相同。示意代码如下：1234567891011121314151617181920212223abstract class Prototype&#123; public abstract Prototype Clone();&#125;class ConcretePrototype : Prototype&#123; private string attr; //成员变量 public string Attr &#123; get &#123; return attr; &#125; set &#123; attr = value; &#125; &#125; // 克隆方法 public override Prototype Clone() &#123; ConcretePrototype prototype = new ConcretePrototype(); prototype.Attr = this.Attr; return prototype; &#125;&#125; 在客户类中只需要创建一个ConcretePrototype对象作为原型对象，然后调用其Clone()方法即可得到对应的克隆对象，如下面的代码片段所示：1234...ConcretePrototype prototype = new ConcretePrototype();ConcretePrototype copy = (ConcretePrototype)prototype.Clone();... 此方法是原型模式的通用实现方法，与编程语言本身的特性无关，除C#外，其他面向对象编程语言也可以使用这种形式来实现对原型的克隆。 在原型模式的通用实现方法中，可通过手工编写Clone()方法来实现浅克隆和深克隆。对于引用类型的对象，可以在Clone()方法中通过赋值的方式来实现复制，这是一种浅克隆实现方案；如果在Clone()方法中通过创建一个全新的成员对象来实现复制，则是一种深克隆实现方案。C#语言中的字符串（string/String）对象存在特殊性，只要两个字符串的内容相同，无论是直接赋值还是创建新对象，它们在内存中始终只有一份。 2.C#中的MemberwiseClone()方法和ICloneable接口 在C#语言中，提供了一个MemberwiseClone()方法用于实现浅克隆，该方法使用起来很方便，直接调用一个已有对象的MemberwiseClone()方法即可实现克隆。如下面的代码所示：12345678910111213141516171819202122// 成员类class Member&#123;&#125;class ConcretePrototypeA&#123; private Member member; // 成员对象 public Member Member &#123; get &#123; return member; &#125; set &#123; member = value; &#125; &#125; // 克隆方法 public ConcretePrototypeA Clone() &#123; return (ConcretePrototypeA)this.MemberwiseClone(); // 浅克隆 &#125;&#125; 在客户类中可以直接调用原型对象的Clone()方法来创建新的对象，如下面的代码片段所示：1234567...ConcretePrototypeA prototype, copy;prototype = new ConcretePrototypeA();copy = prototype.Clone();Console.WriteLine(prototype == copy);Console.WriteLine(prototype.Member == copy.Member);... 在上述客户类代码片段中，输出语句“Console.WriteLine(prototype==copy);”的输出结果为“False”，输出语句“Console.WriteLine(prototype.Member==copy.Member);”的输出结果为“True”，表明此处的克隆方法为浅克隆。 除了MemberwiseClone()方法以外，在C#语言中还提供了一个ICloneable接口，它也可以用来创建当前对象的副本，其代码如下:1234public interface ICloneable&#123; object Clone();&#125; ICloneable接口充当了抽象原型类的角色，具体原型类通常作为实现该接口的子类，如下面的代码所示：12345678910111213141516171819class ConcretePrototypeB : ICloneable // 实现ICloneable接口&#123; private Member member; public Member Member &#123; get &#123; return member; &#125; set &#123; member = value; &#125; &#125; // 实现深克隆 public object Clone() &#123; ConcretePrototypeB copy = (ConcretePrototypeB)this.MemberwiseClone(); Member newMember = new Member(); copy.Member = newMember; return copy; &#125;&#125; 客户端代码片段如下：1234567...ConcretePrototypeB prototype, copy;prototype = new ConcretePrototypeB();copy = (ConcretePrototypeB)prototype.Clone();Console.WriteLine(prototype == copy);Console.WriteLine(prototype.Member == copy.Member);... 在此客户类代码片段中，输出语句“Console.WriteLine(prototype==copy);”的输出结果为“False”，输出语句“Console.WriteLine(prototype.Member==copy.Member);”的输出结果也为“False”，表明此处的克隆方法为深克隆。 在实现ICloneable接口时，通常提供的是除MemberwiseClone()以外的深克隆方法。除了通过直接创建新的成员对象来手工实现深克隆外，还可以通过反射、序列化等方式来实现深克隆，在使用序列化实现时要求所有被引用的对象都必须是可序列化的（Serializable）。在下一节的应用实例中将学习如何使用序列化来实现深克隆。 原型模式的应用实例下面通过一个应用实例来进一步学习和理解原型模式。 1.实例说明 在使用某OA系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切地希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。试使用原型模式对该OA系统中的工作周报创建模块进行改进。 2.实例类图 通过分析，本实例的结构如图5所示。 图5 工作周报创建模块结构图 在图5中，WeeklyLog充当原型角色，Clone()方法为克隆方法，用于实现原型对象的克隆，Attachment充当成员类。 3.实例代码 (1)WeeklyLog：周报类，充当原型角色。在真实环境下该类比较复杂，考虑到代码的可读性，在此只列出部分与模式相关的核心代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687using System;using System.IO;using System.Collections;using System.Runtime.Serialization.Formatters.Binary;using System.Runtime.Serialization;namespace PrototypeSample&#123; [Serializable] class WeeklyLog &#123; private Attachment attachment; private string name; private string date; private string content; public Attachment Attachment &#123; get &#123; return attachment; &#125; set &#123; attachment = value; &#125; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public string Date &#123; get &#123; return date; &#125; set &#123; date = value; &#125; &#125; public string Content &#123; get &#123; return content; &#125; set &#123; content = value; &#125; &#125; /* //使用MemberwiseClone()方法实现浅克隆 public WeeklyLog Clone() &#123; return this.MemberwiseClone() as WeeklyLog; &#125; */ //使用序列化方式实现深克隆 public WeeklyLog Clone() &#123; WeeklyLog clone = null; FileStream fs = new FileStream("Temp.dat", FileMode.Create); BinaryFormatter formatter = new BinaryFormatter(); try &#123; formatter.Serialize(fs, this); &#125; catch (SerializationException e) &#123; Console.WriteLine("Failed to serialize. Reason: " + e.Message); throw; &#125; finally &#123; fs.Close(); &#125; FileStream fs1 = new FileStream("Temp.dat", FileMode.Open); BinaryFormatter formatter1 = new BinaryFormatter(); try &#123; clone = (WeeklyLog)formatter1.Deserialize(fs1); &#125; catch (SerializationException e) &#123; Console.WriteLine("Failed to deserialize. Reason: " + e.Message); throw; &#125; finally &#123; fs.Close(); &#125; return clone; &#125; &#125;&#125; (2)Attachment：附件类。 123456789101112131415161718192021using System;namespace PrototypeSample&#123; [Serializable] class Attachment &#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public void Download() &#123; Console.WriteLine("下载附件，文件名为&#123;0&#125;。",name); &#125; &#125;&#125; (3)Program：客户端测试类。 12345678910111213141516171819using System;namespace PrototypeSample&#123; class Program &#123; static void Main(string[] args) &#123; WeeklyLog log_previous, log_new; log_previous = new WeeklyLog(); Attachment attachment = new Attachment(); log_previous.Attachment = attachment; log_new = log_previous.Clone(); Console.WriteLine("周报是否相同？&#123;0&#125;",(log_previous == log_new)?"是":"否"); Console.WriteLine("附件是否相同？&#123;0&#125;",(log_previous.Attachment == log_new.Attachment)?"是":"否"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12周报是否相同？否附件是否相同？是 从输出结果可以得知，在本实例中周报对象被成功复制，但是附件对象并没有被复制，实现了浅克隆。 5.深克隆解决方案 为了能够在复制周报的同时复制附件对象，需要采用深克隆机制。本节将介绍如何通过序列化的方式来实现深克隆，使用序列化实现深克隆包含两个步骤。 首先必须将周报类WeeklyLog和附件类Attachment标记为可序列化（Serializable），如下所示：123456789101112[Serializable]class WeeklyLog&#123; private Attachment attachment; ...&#125;[Serializable]class Attachment&#123; ...&#125; 然后将周报类WeeklyLog的Clone()方法修改如下：12345678910111213141516171819202122232425262728293031323334353637// 使用序列化方式实现深克隆public WeeklyLog Clone()&#123; WeeklyLog clone = null; FileStream fs = new FileStream("Temp.dat", FileMode.Create); BinaryFormatter formatter = new BinaryFormatter(); try &#123; formatter.Serialize(fs, this); // 序列化 &#125;catch(SerializationException e) &#123; Console.WriteLine("Failed to serialize. Reason: " + e.Message); throw; &#125;finally &#123; fs.Close(); &#125; FileStream fs1 = new FileStream("Temp.dat", FileMode.Open); BinaryFormatter formatter1 = new BinaryFormatter(); try &#123; clone = (WeeklyLog)formatter1.Deserialize(fs1); // 反序列化 &#125;catch(SerializationException e) &#123; Console.WriteLine("Failed to serialize. Reason: " + e.Message); throw; &#125;finally &#123; fs1.Close(); &#125; return clone;&#125; 重新执行客户端类Program，输出结果如下：12周报是否相同？否附件是否相同？否 从输出结果可以得知，本实例中，在成功复制周报对象的同时附件对象也被复制，实现了深克隆。 在上述深克隆实现代码中，通过使用FileStream类和BinaryFormatter类可实现对象的序列化和反序列化操作，首先使用序列化将当前对象写入流中，然后使用反序列化从流中获取对象。由于在序列化时一个对象的成员对象将伴随该对象一起被写入流中，在反序列化时将得到一个包含成员对象的新对象，因此可采用序列化和反序列化联用来实现深克隆。 原型管理器原型管理器（Prototype Manager）将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便于扩展，其结构如图6所示。 图6 带原型管理器的原型模式 图6中典型的原型管理器PrototypeManager类的实现代码片段如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;namespace PrototypeManagerSample&#123; abstract class Prototype &#123; public abstract Prototype Clone(); &#125; class ConcretePrototypeA : Prototype &#123; public override Prototype Clone() &#123; return (ConcretePrototypeA)this.MemberwiseClone(); &#125; &#125; class ConcretePrototypeB : Prototype &#123; public override Prototype Clone() &#123; return (ConcretePrototypeB)this.MemberwiseClone(); &#125; &#125; class PrototypeManager &#123; Hashtable ht = new Hashtable(); public PrototypeManager() &#123; ht.Add("A", new ConcretePrototypeA()); ht.Add("B", new ConcretePrototypeB()); &#125; public void Add(string key, Prototype prototype) &#123; ht.Add(key,prototype); &#125; public Prototype Get(string key) &#123; Prototype clone = null; clone = ((Prototype)ht[key]).Clone(); return clone; &#125; &#125;&#125; 在实际开发中，可以将PrototypeManager设计为单例类，确保系统中有且仅有一个PrototypeManager对象，既有利于节省系统资源，还可以更地对原型管理器对象进行控制. 原型模式的优缺点与适用环境原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中的应用较为广泛，很多软件提供的复制（Ctrl+C）和粘贴（Ctrl+V）操作就是原型模式的典型应用。 原型模式的优点原型模式的主要优点如下： (1)当要创建的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 (2)扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统没有任何影响。 (3)原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 (4)可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（例如恢复到某一历史状态），可辅助实现撤销操作。 原型模式的缺点原型模式的主要缺点如下： (1)需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则。 (2)在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 原型模式的适用环境在以下情况下可以考虑使用原型模式： (1)创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改。 (2)系统要保存对象的状态，而对象的状态变化很小。 (3)需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 本章小结(1)在原型模式中，使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。原型模式是一种对象创建型模式。 (2)原型模式包含抽象原型类、具体原型类和客户类3个角色。其中，抽象原型类是声明克隆方法的接口，是所有具体原型类的公共父类；具体原型类实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 (3)根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制可分为浅克隆和深克隆。在浅克隆中，当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有被复制；在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制。 (4)在C#语言中，提供了一个MemberwiseClone()方法用于实现克隆，此还提供了用于充当抽象原型角色的ICloneable接口。 (5)原型模式的主要优点是当要创建的对象实例较为复杂时，可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率，而且具有较好的扩展性；其主要缺点在于需要为每一个类配备一个克隆方法，因此在对已有类进行改造时比较麻烦，需要修改源代码，并且在实现深克隆时需要编写较为复杂的代码。 (6)原型模式适用的环境：创建新对象成本较大，新对象可以通过复制已有对象来获得；系统要保存对象的状态，而对象的状态变化很小；需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 (7)原型管理器将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象获得。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 建造者模式包含4个角色。是哪4个？ 在建造者模式的定义中提到了复杂对象，那么什么是复杂对象？ 如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。怎么理解？ 建造者模式中还引入了一个指挥者类Director，该类主要有两个作用：一方面隔离了客户端与创建过程；另一方面控制产品对象的创建过程。怎么理解？ 建造者客户端new一个指挥者，new一个具体建造者，然后调用指挥者的无参方法即可创建一个产品对象。怎么理解？ 抽象建造者是直接new了产品，然后对属性的不同赋值交给子类去完成。怎么理解？ Director可以省略吗？ 本章导学 建造者模式是一种较为复杂的创建型模式，它将客户端与包含多个组成部分的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需知道所需建造者的类型即可。建造者模式关注如何逐步创建一个复杂的对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，更换建造者或增加新的建造者非常方便，系统具有较好的扩展性。 本章将学习建造者模式的定义与结构，理解建造者模式中各个组成元素作用，并通过实例来学习如何实现建造者模式。 本章知识点 建造者模式的定义 建造者模式的结构 建造者模式的实现 建造者模式的应用 建造者模式的优缺点 建造者模式的适用环境 指挥者类的作用与变化 建造者模式概述无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分（部件），例如汽车，它包括车轮、方向盘、发动机等多种部件。对于大多数用户而言，并不知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，如图1所示。 图1 复杂对象（汽车）示意图 如何将这些部件组装成一辆完整的汽车并返回给用户，是建造者模式需要解决的问题。建造者模式可以将部件本身和它们的组装过程分开，关注如何一步步创建一个包含多个组成部分的复杂对象，用户只需要指定复杂对象的类型即可得到该对象，而无须知道其内部的具体构造细节。 建造者模式的定义如下：1将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一种对象创建型模式，它将客户端与包含多个部件的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需知道所需建造者的类型即可。建造者模式关注如何逐步创建一个复杂的对象，不同的建造者定义了不同的创建过程。 建造者模式的结构与实现建造者模式的结构建造者模式的结构如图2所示。 图2 建造者模式结构图 由图2可知，建造者模式包含以下4个角色。 (1)Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是BuildPartX()（例如图2中的BuildPartA()、BuildPartB()等），它们用于创建复杂对象的各个部件；另一类方法是GetResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 (2)ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可由抽象建造者实现）。 (3)Product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。 (4)Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其Construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 建造者模式的实现在建造者模式的定义中提到了复杂对象，那么什么是复杂对象，简单来说，复杂对象是指包含多个成员变量的对象，这些成员变量也称为部件或零件。如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件。一个典型的复杂对象类示例的代码如下：123456789101112131415161718192021222324class Product&#123; private string partA; private string partB; private string partC; public string PartA &#123; get &#123; return partA; &#125; set &#123; partA = value; &#125; &#125; public string PartB &#123; get &#123; return partB; &#125; set &#123; partB = value; &#125; &#125; public string PartC &#123; get &#123; return partC; &#125; set &#123; partC = value; &#125; &#125;&#125; 在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：12345678910111213abstract class Builder&#123; protected Product product = new Product(); public abstract void BuildPartA(); public abstract void BuildPartB(); public abstract void BuildPartC(); public Product GetResult() &#123; return product; &#125;&#125; 在抽象类Builder中声明了一系列抽象的BuildPartX()方法用于创建复杂产品的各个部件，具体建造过程在ConcreteBuilder中实现，此外，Builder还提供了一个GetResult()方法用于返回一个已创建好的完整产品对象。 在ConcreteBuilder中实现了这些BuildPartX()方法，通过调用Product的Setter方法可以给产品对象的成员变量设值，不同的具体建造者在实现BuildPartX()方法时将有所区别。典型的具体建造者类代码如下：1234567891011121314151617class ConcreteBuilder1 : Builder&#123; public override void BuildPartA() &#123; product.PartA = "A1"; &#125; public override void BuildPartB() &#123; product.PartB = "B1"; &#125; public override void BuildPartC() &#123; product.PartC = "C1"; &#125;&#125; 此外，在建造者模式中还引入了一个指挥者类Director，该类主要有两个作用：一方面隔离了客户端与创建过程；另一方面控制产品对象的创建过程，包括某个BuildPartX()方法是否被调用以及多个BuildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，便可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。在实际生活中也存在类似指挥者一样的角色，如一个客户去购买计算机，计算机销售人员相当于指挥者，只要客户确定计算机的类型，计算机销售人员就可以通知计算机组装人员给客户组装一台计算机。指挥者类的示例代码如下：1234567891011121314151617181920212223class Director&#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public void SetBuilder(Builder builder) &#123; this.builder = builder &#125; public Product Construct() &#123; builder.BuildPartA(); builder.BuildPartB(); builder.BuildPartC(); return builder.GetResult(); &#125;&#125; 在指挥者类中可以注入一个抽象建造者类型的对象，它提供了一个建造方法Construct()，在该方法中调用了builder对象的构造部件的方法，最后返回一个产品对象。 对于客户端而言，只需关心具体建造者的类型，无须关心产品对象的具体组装过程。通常，客户类代码片段如下：12345...Builder builder = new ConcreteBuilder1();Director director = new Director(builder);Product product = director.Construct();... 用户可以通过配置文件来存储具体建造者类ConcreteBuilder1的类名，使得在更换新的建造者时无须修改源代码，系统扩展更为方便。 建造者模式与抽象工厂模式都是较为复杂的创建型模式，建造者模式返回一个完整的复杂产品，抽象工厂模式返回一系列相关的产品；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型来指导Director类如何去生成对象，侧重逐步构造一个复杂对象，然后将结果返回。如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。 建造者模式的应用实例下面通过一个应用实例来进一步学习和理解建造者模式。 1.实例说明 某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着该游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、面容等多个组成部分，不同类型的游戏角色，其性别、面容、服装、发型等外部特性有所差异，例如“天使”拥有美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”极其丑陋，留着光头并穿一件刺眼的黑衣。无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。现使用建造者模式来实现游戏角色的创建。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 游戏角色创建结构图 在图3中，ActorController充当指挥者，ActorBuilder充当抽象建造者，HeroBuilder、AngelBuilder和DevilBuilder充当具体建造者，Actor充当复杂产品。 3.实例代码 (1)Actor：游戏角色类，充当复杂产品对象。考虑到代码的可读性，在此只列出了部分成员变量，且成员变量的类型均为string，真实情况下，有些成员变量的类型需用户自定义。1234567891011121314151617181920212223242526272829303132333435363738394041namespace BuilderSample&#123; class Actor &#123; private string type; //角色类型 private string sex; //性别 private string face; //面容 private string costume; //服装 private string hairstyle; //发型 public string Type &#123; get &#123; return type; &#125; set &#123; type = value; &#125; &#125; public string Sex &#123; get &#123; return sex; &#125; set &#123; sex = value; &#125; &#125; public string Face &#123; get &#123; return face; &#125; set &#123; face = value; &#125; &#125; public string Costume &#123; get &#123; return costume; &#125; set &#123; costume = value; &#125; &#125; public string Hairstyle &#123; get &#123; return hairstyle; &#125; set &#123; hairstyle = value; &#125; &#125; &#125;&#125; (2)ActorBuilder：游戏角色建造者，充当抽象建造者。 1234567891011121314151617181920namespace BuilderSample&#123; //角色建造者：抽象建造者 abstract class ActorBuilder &#123; protected Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); //工厂方法，返回一个完整的游戏角色对象 public Actor CreateActor() &#123; return actor; &#125; &#125;&#125; (3)HeroBuilder：英雄角色建造者，充当具体建造者。 123456789101112131415161718192021222324252627282930namespace BuilderSample&#123; class HeroBuilder : ActorBuilder &#123; public override void BuildType() &#123; actor.Type = "英雄"; &#125; public override void BuildSex() &#123; actor.Sex = "男"; &#125; public override void BuildFace() &#123; actor.Face = "英俊"; &#125; public override void BuildCostume() &#123; actor.Costume = "盔甲"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "飘逸"; &#125; &#125;&#125; (4)AngelBuilder：天使角色建造者，充当具体建造者。 123456789101112131415161718192021222324252627282930namespace BuilderSample&#123; class AngelBuilder : ActorBuilder &#123; public override void BuildType() &#123; actor.Type = "天使"; &#125; public override void BuildSex() &#123; actor.Sex = "女"; &#125; public override void BuildFace() &#123; actor.Face = "漂亮"; &#125; public override void BuildCostume() &#123; actor.Costume = "白裙"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "披肩长发"; &#125; &#125;&#125; (5)DevilBuilder：恶魔角色建造者，充当具体建造者。 123456789101112131415161718192021222324252627282930namespace BuilderSample&#123; class DevilBuilder : ActorBuilder &#123; public override void BuildType() &#123; actor.Type = "恶魔"; &#125; public override void BuildSex() &#123; actor.Sex = "妖"; &#125; public override void BuildFace() &#123; actor.Face = "丑陋"; &#125; public override void BuildCostume() &#123; actor.Costume = "黑衣"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "光头"; &#125; &#125;&#125; (6)ActorController：角色控制器，充当指挥者。 123456789101112131415161718namespace BuilderSample&#123; class ActorController &#123; //逐步构建复杂产品对象 public Actor Construct(ActorBuilder ab) &#123; Actor actor; ab.BuildType(); ab.BuildSex(); ab.BuildFace(); ab.BuildCostume(); ab.BuildHairstyle(); actor = ab.CreateActor(); return actor; &#125; &#125;&#125; (7)配置文件App.config：在配置文件中存储了具体建造者类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="builder" value="BuilderSample.AngelBuilder"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (8)Program：客户端测试类。 1234567891011121314151617181920212223242526272829using System;using System.Configuration;using System.Reflection;namespace BuilderSample&#123; class Program &#123; static void Main(string[] args) &#123; ActorBuilder ab; //针对抽象建造者编程 //读取配置文件 string builderType = ConfigurationManager.AppSettings["builder"]; //反射生成对象 ab = (ActorBuilder)Assembly.Load("BuilderSample").CreateInstance(builderType); ActorController ac = new ActorController(); Actor actor; actor = ac.Construct(ab); //通过指挥者创建完整的建造者对象 Console.WriteLine("&#123;0&#125;的外观：",actor.Type); Console.WriteLine("性别：&#123;0&#125;",actor.Sex); Console.WriteLine("面容：&#123;0&#125;",actor.Face); Console.WriteLine("服装：&#123;0&#125;",actor.Costume); Console.WriteLine("发型：&#123;0&#125;",actor.Hairstyle); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345天使的外观： 性别：女 面容：漂亮 服装：白裙 发型：披肩长发 如果需要更换具体角色建造者，只需修改配置文件即可，例如将配置文件中key为“builder”的键值对的value值改为“BuilderSample.HeroBuilder”，再次运行程序，输出结果如下：12345英雄的外观： 性别：男 面容：英俊 服装：盔甲 发型：飘逸 当需要增加新的具体角色建造者时，只需将新增具体角色建造者作为抽象角色建造者的子类，然后修改配置文件即可，原有代码无须修改，完全符合开闭原则。 指挥者类的深入讨论指挥者类Director是建造者模式的重要组成部分，简单的Director类用于指导具体建造者构建产品，它按一定次序调用Builder的BuildPartX()方法，控制调用的先后次序，并向客户端返回一个完整的产品对象。下面讨论几种Director的变化形式。 1.省略Director 在有些情况下，为了简化系统结构，可以将Director和抽象建造者Builder进行合并，在Builder中提供了逐步构建复杂产品对象的Construct()方法。由于Builder类通常为抽象类，因此可以将Construct()方法定义为静态（static）方法，以便客户端能够直接调用。如果将游戏角色实例中的指挥者类ActorController省略，ActorBuilder类的代码修改如下：12345678910111213141516171819202122232425namespace BuilderSample&#123; //角色建造者：抽象建造者 abstract class ActorBuilder &#123; protected static Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); public static Actor Construct(ActorBuilder ab) &#123; ab.BuildType(); ab.BuildSex(); ab.BuildFace(); ab.BuildCostume(); ab.BuildHairstyle(); return actor; &#125; &#125;&#125; 此时对应的客户端代码也将发生修改，代码片段如下：1234567...ActorBuilder ab;string builderType = ConfigurationManager.AppSettings["builder"];ab = (ActorBuilder)Assembly.Load("BuildExtend").CreateInstance(builderType);Actor actor;actor = ActorBuilder.Construct(ab);... 除此之外，还有一种更简单的处理方法，可以将Construct()方法中的参数去掉，直接在Construct()方法中调用BuildPartX()方法，代码如下：123456789101112131415161718192021abstract class ActorBuilder&#123; protected Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); public Actor Construct() &#123; this.BuildType(); this.BuildSex(); this.BuildFace(); this.BuildCostume(); this.BuildHairstyle(); return actor; &#125;&#125; 客户端代码片段如下：1234567...ActorBuilder ab;string builderType = ConfigurationManager.AppSettings["builder"];ab = (ActorBuilder)Assembly.Load("BuildExtend").CreateInstance(builderType);Actor actor;actor = ab.Construct();... 此时，Construct()方法定义了BuildPartX()方法的调用次序，为BuildPartX()方法的执行提供了一个流程模板，这与后面将要学习的模板方法模式非常类似。 以上两种对Director类的省略方式都不影响系统的灵活性和可扩展性，同时还简化了系统结构，但加重了抽象建造者类的职责。如果Construct()方法较为复杂，待构建产品的组成部分较多，建议将Construct()方法单独封装在Director中，这样更符合单一职责原则。 2.钩子方法的引入 建造者模式除了逐步构建一个复杂产品对象外，还可以通过Director类来更加精细地控制产品的创建过程，例如增加一类称为钩子方法（Hook Method）的特殊方法来控制是否调用某个BuildPartX()方法。 钩子方法的返回类型通常为bool类型，方法名一般为IsXXX()，钩子方法定义在抽象建造者类中。例如可以在游戏角色的抽象建造者类ActorBuilder中定义一个方法IsBareheaded()，用于判断某个角色是否为“光头（Bareheaded）”，在ActorBuilder中为之提供一个默认实现，其返回值为false，代码如下：123456789101112131415161718192021abstract class ActorBuilder&#123; protected Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); // 钩子方法，需要使用virtual关键字 public virtual bool IsBareheaded() &#123; return false; &#125; public Actor CreateActor() &#123; return actor; &#125;&#125; 如果某个角色无须构建头发部件，例如“恶魔（Devil）”，则对应的具体建造者DevilBuilder将覆盖IsBareheaded()方法，并将返回值改为true，代码如下：123456789101112131415161718192021222324252627282930313233class DevilBuilder : ActorBuilder&#123; public override void BuildType() &#123; actor.Type = "恶魔"; &#125; public override void BuildSex() &#123; actor.Sex = "妖"; &#125; public override void BuildFace() &#123; actor.Face = "丑陋"; &#125; public override void BuildCostume() &#123; actor.Costume = "黑衣"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "光头"; &#125; // 覆盖钩子方法 public override bool IsBareheaded() &#123; return true; &#125; &#125; 同时，指挥者类ActorController的代码修改如下：123456789101112131415161718192021class ActorController&#123; // 逐步构建复杂产品对象 public Actor Construct(ActorBuilder ab) &#123; Actor actor; ab.BuildType(); ab.BuildSex(); ab.BuildFace(); ab.BuildCostume(); // 通过钩子方法来控制产品的构建 if (!ab.IsBareheaded()) &#123; ab.BuildHairstyle(); &#125; actor = ab.CreateActor(); return actor; &#125;&#125; 当在客户端代码中指定具体建造者类型并通过指挥者来实现产品的逐步构建时，将调用钩子方法IsBareheaded()来判断游戏角色是否有头发，如果IsBareheaded()方法返回true，即没有头发，将跳过构建发型的方法BuildHairstyle()，否则执行BuildHairstyle()方法。通过引入钩子方法，可以在Director中对复杂产品的构建进行精细的控制，不仅指定BuildPartX()方法的执行顺序，还可以控制是否需要执行某个BuildPartX()方法。 建造者模式的优缺点与适用环境建造者模式的核心在于如何逐步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品。在软件开发中，如果需要创建复杂对象并希望系统具备很好的灵活性和可扩展性，可以考虑使用建造者模式。 建造者模式的优点建造者模式的主要优点如下： (1)在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 (2)每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合开闭原则。 (3)用户可以更加精细地控制产品的创建过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式的缺点建造者模式的主要缺点如下： (1)建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分不相同，则不适合使用建造者模式，因此其使用范围受到一定的限制。 (2)如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本。 建造者模式的适用环境在以下情况下可以考虑使用建造者模式： (1)需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。 (2)需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 (3)对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。 (4)隔离复杂对象的创建和使用，并使得相同的创建过程创建不同的产品。 本章小结(1)建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 (2)建造者模式包含抽象建造者、具体建造者、产品和指挥者4个角色。其中，抽象建造者为创建一个产品对象的各个部件声明抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，在其Construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 (3)在建造者模式中引入了一个指挥者角色，它主要有两个作用：一方面可以隔离客户端与创建过程；另一方面可以控制产品对象的创建过程。 (4)建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象；可以很方便地替换具体建造者或增加新的具体建造者；还可以更加精细地控制产品的创建过程。其主要缺在于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，并不适合使用建造者模式；此外，如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本。 (5)建造者模式适用的环境:需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使相同的创建过程可以创建不同的产品。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么系统中会存在大量的工厂类？可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。怎么理解？ 产品等级结构即产品的继承结构是什么意思？ 产品族又是什么？ 一个工厂产生多个类，这些类都有不同的抽象父类。怎么理解？ 抽象工厂模式与工厂方法模式最大的区别是什么？ 本章导学 抽象工厂模式是常用的创建型设计模式之一，它比工厂方法模式的抽象程度更高。在工厂方法模式中，每一个具体工厂只需要生产一种具体产品，但是在抽象工厂模式中，一个具体工厂可以生产一组相关的具体产品，这样的一组产品称为产品族，产品族中的每一个产品都分属于某一个产品继承等级结构。 本章将通过实例来学习抽象工厂模式，分析抽象工厂模式的结构及特点，并学习如何在实际软件项目开发中合理地使用抽象工厂模式。 本章知识点 产品等级结构与产品族 抽象工厂模式的定义 抽象工厂模式的结构 抽象工厂模式的实现 抽象工厂模式的应用 抽象工厂模式的优缺点 抽象工厂模式的适用环境 开闭原则的倾斜性 产品等级结构与产品族工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个具体工厂只有一个或者一组重载的工厂方法，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。有时可能需要一个工厂能够提供多种产品对象，而不是单一的产品对象，例如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。此时，可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是本章将要学习的抽象工厂模式的基本思想。 为了更好地理解抽象工厂模式，先引入以下两个概念。 (1)产品等级结构：产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类包括海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 (2)产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 产品等级结构与产品族示意图如图1所示。 图1 产品等级结构与产品族示意图 在图1中，不同颜色的多个正方形、圆形和椭圆形分别构成了3个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。在图1中共有5个产品族，分属于3个不同的产品等级结构，只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一地确定这个产品。 抽象工厂模式概述当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品类中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图2所示。 图2 抽象工厂模式示意图 在图2中，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，图2所示的结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大地减少了系统中类的个数。 抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，而是负责创建一族产品。 抽象工厂模式的定义如下：1提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 抽象工厂模式又称为工具（Kit）模式，它是一种对象创建型模式。 抽象工厂模式的结构与实现抽象工厂模式的结构在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族。抽象工厂模式的结构如图3所示。 图3 抽象工厂模式结构图 由图3可知，抽象工厂模式包含以下4个角色。 (1)AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 (2)ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 (3)AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 (4)ConereteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 抽象工厂模式的实现在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下：123456abstract class AbstractFactory&#123; public abstract AbstractProductA CreateProductA(); // 工厂方法一 public abstract AbstractProductB CreateProductB(); // エ厂方法二 ...&#125; 具体工厂实现了抽象工厂，每一个具体的工厂方法创建一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下：123456789101112131415class ConcreteFactory1 : AbstractFactory&#123; // 工厂方法1 public override AbstractProductA CreateProductA() &#123; return new ConcreteProductA1(); &#125; // 工厂方法2 public override AbstractProductB CreateProductB() &#123; return new ConcreteProductB1(); &#125; ...&#125; 与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式来创建产品对象。 抽象工厂模式的应用实例下面通过一个应用实例来进一步学习和理解抽象工厂模式。 1.实例说明 某软件公司要开发一套界面皮肤库，可以对基于.NET平台的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天（Spring）风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天（Summer）风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如图4所示。该皮肤库需要具备良好的灵活性与可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。现使用抽象工厂模式来设计该界面皮肤库。 图4 界面皮肤库结构示意图 2.实例类图 通过分析，本实例的结构如图5所示。 图5 界面皮肤库结构图 在图5中，SkinFactory接口充当抽象工厂，其子类SpringSkinFactory和SurmerSkinFactory充当具体工厂，接口Button、TextField和ComboBox充当抽象产品，其子类SpringButton、SpringTextField、SpringComboBox和SummerButton、SummerTextField、SummerComboBox充当具体产品。 3.实例代码 (1) Button：按钮接口，充当抽象产品。 Button.cs 1234567namespace AbstractFactorySample&#123; interface Button &#123; void Display(); &#125;&#125; (2)SpringButton：Spring按钮类，充当具体产品。 SpringButton.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SpringButton : Button &#123; public void Display() &#123; Console.WriteLine("显示浅绿色按钮。"); &#125; &#125;&#125; (3)SummerButton：Summer按钮类，充当具体产品。 SummerButton.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SummerButton : Button &#123; public void Display() &#123; Console.WriteLine("显示浅蓝色按钮。"); &#125; &#125;&#125; (4)TextField：文本框接口，充当抽象产品。 TextField.cs 1234567namespace AbstractFactorySample&#123; interface TextField &#123; void Display(); &#125;&#125; (5)SpringTextField：Spring文本框，充当具体产品。 SpringTextField.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SpringTextField : TextField &#123; public void Display() &#123; Console.WriteLine("显示绿色边框文本框。"); &#125; &#125;&#125; (6)SummerTextField：Summer文本框类，充当具体产品。 SummerTextField.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SummerTextField : TextField &#123; public void Display() &#123; Console.WriteLine("显示蓝色边框文本框。"); &#125; &#125;&#125; (7)ComboBox：组合框接口，充当抽象产品。 ComboBox.cs 1234567namespace AbstractFactorySample&#123; interface ComboBox &#123; void Display(); &#125;&#125; (8)SpringComboBox：Spring组合框类，充当具体产品。 SpringComboBox.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SpringComboBox : ComboBox &#123; public void Display() &#123; Console.WriteLine("显示绿色边框组合框。"); &#125; &#125;&#125; (9)SummerComboBox：Summer组合框类，充当具体产品。 SummerComboBox.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SummerComboBox : ComboBox &#123; public void Display() &#123; Console.WriteLine("显示蓝色边框组合框。"); &#125; &#125;&#125; (10)SkinFactory：界面皮肤工厂接口，充当抽象工厂。 SkinFactory.cs 123456789namespace AbstractFactorySample&#123; interface SkinFactory &#123; Button CreateButton(); TextField CreateTextField(); ComboBox CreateComboBox(); &#125;&#125; (11)SpringSkinFactory：Spring皮肤工厂，充当具体工厂。 SpringSkinFactory.cs 1234567891011121314151617181920namespace AbstractFactorySample&#123; class SpringSkinFactory : SkinFactory &#123; public Button CreateButton() &#123; return new SpringButton(); &#125; public TextField CreateTextField() &#123; return new SpringTextField(); &#125; public ComboBox CreateComboBox() &#123; return new SpringComboBox(); &#125; &#125;&#125; (12)SummerSkinFactory：Summer皮肤工厂，充当具体工厂。 SummerSkinFactory.cs 1234567891011121314151617181920namespace AbstractFactorySample&#123; class SummerSkinFactory : SkinFactory &#123; public Button CreateButton() &#123; return new SummerButton(); &#125; public TextField CreateTextField() &#123; return new SummerTextField(); &#125; public ComboBox CreateComboBox() &#123; return new SummerComboBox(); &#125; &#125;&#125; (13)配置文件App.config：在配置文件中存储了具体工厂类类名。 App.config 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="factory" value="AbstractFactorySample.SpringSkinFactory"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (14)Program：客户端测试类。 Program.cs 123456789101112131415161718192021222324252627282930313233using System;using System.Configuration;using System.Reflection;namespace AbstractFactorySample&#123; class Program &#123; static void Main(string[] args) &#123; // 使用抽象层定义 SkinFactory factory; Button bt; TextField tf; ComboBox cb; // 读取配置文件 string factoryType = ConfigurationManager.AppSettings["factory"]; // 反射生成对象 factory = (SkinFactory)Assembly.Load("AbstractFactorySample").CreateInstance(factoryType); bt = factory.CreateButton(); tf = factory.CreateTextField(); cb = factory.CreateComboBox(); bt.Display(); tf.Display(); cb.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下:123显示浅绿色的按钮。 显示绿色边框的文本框 显示绿色边框的组合框。 如果需要更换皮肤，只需修改配置文件即可，例如将春天风格的皮肤改为夏天风格的皮肤，只需将存储在配置文件中的具体工厂类SpringSkinFactory改为SummerSkinFactory即可，代码如下:123456&lt;?xml version = "1.0" encoding = "utf-8" ?&gt; &lt;configuration &gt; &lt;appSettings&gt; &lt;add key = "factory" value ="AbstractFactorySample. SummerSkinFactory"/ &gt; &lt;/appSettings &gt; &lt;/configuration &gt; 重新运行客户端程序，输出结果如下:123显示浅蓝色的按钮。 显示蓝色边框的文本框 显示蓝色边框的组合框。 在实际环境中，可以提供一个可视化界面，例如菜单或者窗口来修改配置文件，用户须直接修改配置文件。如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件中的具体工厂类的类名即可使用新的皮肤，原有代码无须修改，符合开闭原则。 开闭原则的倾斜性在上一节设计的界面皮肤库中可以较为方便地增加新类型的皮肤，但是该设计方案存在一个非常严重的问题：如果在设计之初因为考虑不全面，忘记为某种类型的界面组件（以单选按钮RadioButton为例）提供不同皮肤下的风格化显示，那么在向系统中增加单选按钮时将非常麻烦，无法在满足开闭原则的前提下增加单选按钮，原因是抽象工厂SkinFactory中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先要修改抽象工厂接口SkinFactory，在其中增加声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法，以便在不同的皮肤库中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。 抽象工厂模式无法很好地解决此类问题，这也是抽象工厂模式的最大缺点所在。在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种特性称为开闭原则的倾斜性。开闭原则要求系统对扩展开放，对修改关闭，通过扩展达到增强其功能的目的，对于涉及多个产品族与多个产品等级结构的系统，其功能增强包括以下两个方面。 (1)增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需增加具体产品并对应增加一个新的具体工厂即可，对已有代码无须做任何修改。 (2)增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色的方法违背了开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，它以一种倾斜的方式来满足开闭原则，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就要全面考虑，不要在设计完成之后再向系统中增加新的产品等级结构，也不要删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续的维护工作带来诸多麻烦。 抽象工厂模式的优缺点与适用环境抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中。抽象工厂模式是软件开发中最常用的设计模式之一。 抽象工厂模式的优点抽象工厂模式的主要优点如下: (1)抽象工厂模式隔离了具体类的生成，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 (2)当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 (3)抽象工厂模式增加新的产品族很方便，无须修改已有系统，符合开闭原则。 抽象工厂模式的缺点抽象工厂模式的主要缺点如下: 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。 抽象工厂模式的适用环境在以下情况下可以考虑使用抽象工厂模式: (1)一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。 (2)系统中有多于一个的产品族，但每次只使用其中某一产品族，可以通过配置文件等方式使用户能够动态地改变产品族，也可以很方便地增加新的产品族。 (3)属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。 (4)产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构. 本章小结(1)在抽象工厂模式中，产品等级结构即产品的继承结构，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。 (2)抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，开发人员无须指定具体的类。抽象工厂模式是一种对象创建型模式。 (3)抽象工厂模式包含抽象工厂、具体工厂、抽象产品和具体产品4个角色。其中，抽象工厂声明了一组用于创建一族产品的方法，每一个方法对应一种产品；具体工厂实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 (4)抽象工厂模式的主要优点是隔离了具体类的生成，使得客户端不需要知道什么被创建；当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象；增加新的产品族很方便，无须修改已有系统，符合开闭原则。其主要缺点是增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背了开闭原则。 (5)抽象工厂模式适用的环境：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，但每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来；产品等级结构稳定，在设计完成后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 (6)抽象工厂模式以一种倾斜的方式来满足开闭原则。对于增加新的产品族，抽象工厂模式很好地支持了开闭原则；对于增加新的产品等级结构，需要修改所有的工厂角色，违背了开闭原则。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 工厂方法模式比简单工厂优势在哪里？ 本章导学 工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的缺陷，能更好地符合开闭原则的要求，在增加新的具体产品对象时不需要对已有系统做任何修改。 本章将通过克服简单工厂模式的不足来引出工厂方法模式，并通过实例来学习工厂方法模式，理解工厂方法模式的结构及特点，学习如何在实际软件项目开发中合理地使用工厂方法模式。 本章知识点 工厂方法模式的定义 工厂方法模式的结构 工厂方法模式的实现 工厂方法模式的应用 工厂方法模式的优缺点 工厂方法模式的适用环境 配置文件与反射 工厂方法的重载 工厂方法的隐藏 工厂方法模式概述考虑这样一个系统，使用简单工厂模式设计的按钮工厂类可以返回一个具体类型的按钮实例，例如矩形按钮、圆形按钮、菱形按钮等。在这个系统中，如果需要增加一种新类型的按钮，例如椭圆形按钮，那么除了增加一个新的具体产品类之外，还需要修改工厂类的代码就使得整个设计在一定程度上违背了开闭原则，如图1所示。 图1 使用简单工厂模式设计的按钮工厂 下面对该系统进行修改，不再提供一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成。先定义一个抽象的按钮工厂类，再定义具体的工厂类来生产矩形按钮、圆形按钮、菱形按钮等，它们实现了在抽象按钮工厂类中声明的方法。这种抽象化的结果是使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮定义一个具体的工厂类就可以创建该新按钮的实例，这种改进的设计方案即为工厂方法模式。工厂方法模式通过引入抽象的工厂类，使得它具有超越简单工厂模式的优越性，让系统更加符合开闭原则，改进后的按钮工厂如图2所示。 图2 使用工厂方法模式改进后的按钮工厂 在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供了一个与产品等级结构对应的工厂等级结构。 工厂方法模式的定义如下：1定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。 工厂方法模式简称为工厂模式（Factory Pattern），又可称为虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern），工厂方法模式是一种类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 工厂方法模式的结构与实现工厂方法模式的结构工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式的结构如图3所示。 图3 工厂方法模式结构图 由图3可知，工厂方法模式包含以下4个角色。 (1)Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。(2)ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。(3)Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。(4)ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，由客户端调用，返回一个具体产品类的实例。 工厂方法模式的实现与简单工厂模式相比，工厂方法模式最重要的特点是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下:1234interface Factory&#123; Product FactoryMethod();&#125; 在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品。其典型代码如下：1234567class ConcreteFactory : Factory &#123; public Product FactoryMethod() &#123; return new ConcreteProduct(); &#125;&#125; 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 在客户端代码中，开发人员只需关心工厂类即可，不同的具体工厂可以创建不同的产品。典型的客户端代码片段如下：123456...Factory factory;factory = new ConcreteFactory(); // 可通过配置文件实现Product product;product = factory.FactoryMethod();... 开发人员可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 工厂方法模式的应用实例下面通过一个应用实例来进一步学习和理解工厂方法模式。 1.实例说明 某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统(在.NET平台下常用的日志记录工具有Log4net，NLog等，.NETFramework也提供了一些用于记日志的类，例如Debug.Trace、TraceSource等)。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 日志记录器结构图 在图4中，Logger接口充当抽象产品，其子类FileLogger和DatabaseLogger充当具体产品，LoggerFactory接口充当抽象工厂，其子类FileLoggerFactory和DatabaseLoggerFactory充当具体工厂。 3.实例代码 (1)Logger：日志记录器接口，充当抽象产品角色。 1234567namespace FactoryMethodSample&#123; interface Logger &#123; void WriteLog(); &#125;&#125; (2)DatabaseLogger：数据库日志记录器，充当具体产品角色。 123456789101112using System;namespace FactoryMethodSample&#123; class DatabaseLogger : Logger &#123; public void WriteLog() &#123; Console.WriteLine("数据库日志记录。"); &#125; &#125;&#125; (3)FileLogger：文件日志记录器，充当具体产品角色。 123456789101112using System;namespace FactoryMethodSample&#123; class FileLogger : Logger &#123; public void WriteLog() &#123; Console.WriteLine("文件日志记录。"); &#125; &#125;&#125; (4)LoggerFactory：日志记录器工厂接口，充当抽象工厂角色。 1234567namespace FactoryMethodSample&#123; interface LoggerFactory &#123; Logger CreateLogger(); &#125;&#125; (5)DatabaseLoggerFactory：数据库日志记录器工厂类，充当具体工厂角色。 1234567891011121314namespace FactoryMethodSample&#123; class DatabaseLoggerFactory : LoggerFactory &#123; public Logger CreateLogger() &#123; // 连接数据库，代码省略 // 创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; &#125; &#125;&#125; (6)FileLoggerFactory：文件日志记录器工厂类，充当具体工厂角色。 12345678910111213namespace FactoryMethodSample&#123; class FileLoggerFactory : LoggerFactory &#123; public Logger CreateLogger() &#123; // 创建文件日志记录器对象 Logger logger = new FileLogger(); // 创建文件，代码省略 return logger; &#125; &#125;&#125; (7)Program：客户端测试类。 12345678910111213141516171819using System;using System.Configuration;namespace FactoryMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); // 可引入配置文件实现 logger = factory.CreateLogger(); logger.WriteLog(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1文件日志记录。 如果需要更换日志记录器，只需修改客户端代码中的具体工厂类类名即可。例如将FileL.oggerFactory改为DatabaseLoggerFactory，则输出结果如下：1数据库日志记录。 如果需要增加并使用新的日志记录器，只需要对应增加一个新的具体工厂类，再在客户端代码中修改具体工厂类类名，原有类库的源代码无须做任何修改。 通过引入配置文件并使用反射机制，可以实现在不修改客户端代码的基础上更换具体工厂类，在下一节将详细说明其实现过程，让系统更加符合开闭原则，具备更好的灵活性和可扩展性。 配置文件与反射在上节中的日志记录器实例中，在更换日志记录器时需要修改客户端代码，对于客户端而言并不符合开闭原则，本节将介绍如何在不修改任何客户端代码的基础上更换或增加新的日志记录方式。 在实际应用开发中，可以对具体工厂类的实例化过程进行改进，在客户端代码中不直接使用new关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（例如XML文件）中，再通过程序集的反射机制，读取配置文件中存储的类名字符串生成对象。 例如将上一节的具体日志记录器工厂类类名FileLoggerFactory，存储在以下XML格式的文档中：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="factory" value="FactoryMethodSample.FileLoggerFactory"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 在该文件中，FactoryMethodSample为工厂类所在命名空间的名称，FilelLoggerFactory为具体工厂类类名。在.NET中，配置文件一般以config作为扩展名，例如App.config、Web.config等。 下面对.NET反射机制做一个简单的介绍： 反射（Reflection）是.NET的重要机制之一，通过反射，可以在运行时获得.NET中每一个类型（包括类、结构、委托、接口和枚举等）的成员，包括方法、属性、事件，以及构造函数等，还可以获得每个成员的名称、限定符和参数等。由于获取了构造函数的信息，因此可以通过类名来直接创建对象，即使这个对象的类型在编译时是未知的。 由于在.NET的程序集（Assembly）中封装了类型元数据信息，因此可以先通过Assembly的Load(“程序集名称”)方法加载一个程序集，再通过其CreateInstance(“命名空间.类”)方法根据类名创建一个object类型的对象，用户可以根据需要将其转换为所需类型。示意代码如下：1234// 导入命令空间using System.Reflection;object obj = Assembly.Load("程序集名称").CreateInstance("命名空间.类"); 在上述代码中，“命名空间.类”可以存储在配置文件中，使用ConfigurationManager类的AppSettings属性可以获取存储在配置文件中的类名字符串。 引入配置文件和反射机制后，在客户端测试代码中，无须直接使用new关键字来创建具体的工厂类，而是将具体工厂类的类名放在配置文件中，再通过读取配置文件和反射机制来动态创建对象。客户端代码修改如下:1234567891011121314151617181920212223using System;using System.Configuration;using System.Reflection;namespace FactoryMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; LoggerFactory factory; // 针对抽象工厂类编程 Logger logger; // 针对抽象产品类编程 // 读取配置文件 string factoryString = ConfigurationManager.AppSettings["factory"]; // 反射生成对象 factory = (LoggerFactory)Assembly.Load("FactoryMethodSample").CreateInstance(factoryString); logger = factory.CreateLogger(); logger.WriteLog(); Console.Read(); &#125; &#125;&#125; 需要注意的是，在使用配置文件和反射机制生成对象时，首先需要导入System.Configuration和System.Reflection两个命名空间，否则无法使用ConfigurationManager类来读取配置文件，也无法使用Assembly类来反射创建对象；其次，在客户端代码中要遵循依赖倒转原则、针对抽象工厂和抽象产品编程，否则无法保证系统的可扩展性。 在引入配置文件和反射机制后，如果需要增加一种新类型的日志记录方式，只需以下4个步骤： (1)新的日志记录器类需要继承抽象日志器类Logger。 (2)增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂类LoggerFactory，并实现其中的工厂方法CreateLogger()，返回具体的日志记录器对象。 (3)修改配置文件App.config，以新增的具体日志记录器工厂类的类名字符串替换原有工厂类的类名字符串。 (4)编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合开闭原则。 通过上述重构可以使系统更加灵活，由于很多设计模式都关注系统的可扩展性和灵活性，因此都定义了抽象层，在抽象层中声明业务方法，而将具体业务方法的实现放在实现层中。为了更好地体现这些设计模式的特点，本书在很多设计模式中都使用配置文件和反射机制来创建对象。 工厂方法的重载在某些情况下，可以通过多种方式来初始化同一个产品类。例如4.3节所提到的日志记录器类，可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将相关参数封装在一个object类型的对象中，通过object对象将配置参数传入工厂类。此时，可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。当然，对于同一个具体工厂而言，无论使用哪种工厂方法，所创建的产品类型均要相同。图5所示为重载的工厂方法结构图。 图5 重载的工厂方法结构图 引入重载方法后，抽象工厂类LoggerFactory的代码修改如下：123456interface LoggerFactory&#123; Logger CreateLogger(); Logger CreateLogger(string args); Logger CreateLogger(object obj);&#125; 具体工厂类DatabaseLoggerFactory的代码修改如下：1234567891011121314151617181920212223242526272829class DatabaseLoggerFactory : LoggerFactory &#123; public Logger CreateLogger() &#123; //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; &#125; public Logger CreateLogger(string args) &#123; //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; &#125; public Logger CreateLogger(object obj) &#123; //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; &#125; &#125; 在抽象工厂中声明了多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足产品对象的多样化创建需求。 工厂方法的隐藏有时为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中直接调用产品类的业务方法，在客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法。 如果对客户端隐藏工厂方法，那么图4所示的日志记录器的结构图可修改为图6所示。 图6 隐藏工厂方法的日志记录器结构图 在图6中，抽象工厂类LoggerFactory的代码修改如下：123456789101112// 将接口改为抽象类abstract class LoggerFactory&#123; // 在工厂类中直接调用日志记录器类的业务方法WriteLog() public void WriteLog() &#123; Logger logger = this.CreateLogger(); logger.WriteLog(); &#125; public abstract Logger CreateLogger();&#125; 客户端代码修改如下：12345678910111213141516171819202122using System;using System.Configuration;using System.Reflection;namespace FactoryMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; LoggerFactory factory; // 针对抽象工厂类编程 // 读取配置文件 string factoryString = ConfigurationManager.AppSettings["factory"]; // 反射生成对象 factory = (LoggerFactory)Assembly.Load("FactoryMethodSample").CreateInstance(factoryString); factory.WriteLog(); // 直接使用工厂对象来调用产品对象的业务方法 Console.Read(); &#125; &#125;&#125; 通过把业务方法的调用移至工厂类中，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须再直接使用工厂方法来创建产品对象。在某些情况下也可以使用这种设计方案。 工厂方法模式的优缺点与适用环境工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API的核心模式。 工厂方法模式的优点工厂方法模式的主要优点如下： (1)在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂即可，无须关心创建细节，甚至无须知道具体产品类的类名。 (2)基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以被称为多态工厂模式，就是因为所有的具体工厂类都具有同一抽象父类。 (3)使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样，系统的可扩展性也就变得非常好，完全符合开闭原则。 工厂方法模式的缺点工厂方法模式的主要缺点如下： (1)在添加新产品时，需要编写新的具体产品类，而且要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 (2)由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 工厂方法模式的适用环境以下情况下可以考虑使用工厂方法模式： (1)客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需知道所对应的工厂即可，具体产品对象由具体工厂类创建，可将具体工一类的类名存储在配置文件或数据库中。 (2)抽象工厂类通过其于类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使系统更容易扩展。 本章小结(1)在工厂方法模式中，定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类，它是一种类创建型模式。 (2)工厂方法模式包含抽象产品、具体产品、抽象工厂和具体工厂4个角色。其中，抽象产品是定义产品的接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建；抽象工厂声明了工厂方法，用于返回一个产品；具体工厂是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，返回一个具体产品类的实例。 (3)工厂方法模式的主要优点是提供了专门的工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节；能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部；在系统中加入新产品时，完全符合开闭原则。其主要缺点是系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销；增加了系统的抽象性和理解难度。 (4)工厂方法模式适用的环境：客户端不知道它所需要的对象的类；抽象工厂类通过其子类来指定创建哪个对象。 (5)通过引入配置文件和反射机制，将具体工厂类类名存储在配置文件中，然后使用反射机制生成工厂对象，使得系统可以在不修改任何已有代码的基础上增加新的产品类，完全符合开闭原则。 (6)在抽象工厂中可以声明多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足产品对象的多样化创建需求。 (7)在工厂类中可以直接调用产品类的业务方法，客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法，实现对工厂方法的隐藏。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是简单工厂模式？为什么简单？和工厂模式相比有什么缺点？ 两个类A和B之间的关系应该仅仅是A创建B或者是A使用B，而不能两种关系都有。怎么理解？ 防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中。怎么理解？ 从一组工厂方法中选择一个意义明确的工厂方法，比从一组名称相同参数不同的构造函数中选择一个构造函数要方便很多。怎么理解？ 本章导学 创建型模式关注对象的创建过程，是一类最常见的设计模式，在软件开发中的应用非常广泛。创建型模式描述如何将对象的创建和使用分离，让用户在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。 简单工厂模式是最简单的设计模式之一，它虽然不属于GoF的23种设计模式，但是应用也较为频繁，同时它也是学习其他创建型模式的基础。在简单工厂模式中，只需要记住一个简单的参数即可获得所需的对象实例，它提供专门的核心工厂类来负责对象的创建，实现对象的创建和使用分离。 本章将对6种创建型模式进行简要的介绍，并通过实例来学习简单工厂模式，理解简单工厂模式的结构及特点，学习如何在实际软件项目开发中合理地使用简单工厂模式。 本章知识点 创建型模式 简单工厂模式的定义 简单工厂模式的结构 简单工厂模式的实现 简单工厂模式的应用 简单工厂模式的优缺点 简单工厂模式的适用环境 创建型模式软件系统在运行时，类将实例化成对象，并由这些对象协作完成各项业务功能。创建型模式（Creational Pattern）关注对象的创建过程，是一类最常用的设计模式，在软件开发中的应用非常广泛。创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例创建细节。 创建型模式描述如何将对象的创建和使用分离，让用户在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。每一个创建型模式都通过采用不同的解决方案来回答3个问题：创建什么（What），由谁创建（Who）和何时创建（When）。 在GoF设计模式中，包含5种创建型模式，通常将一种非GoF设计模式——简单工厂模式作为学习其他工厂模式的基础，这5种设计模式的名称、定义、学习难度和使用频率如表1所示。 表1 创建型模式一览表 模式名称 定 义 学习难度 使用频率 简单工厂模式(Simple Factory Pattern) 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。 ★★☆☆☆ ★★★☆☆ 工厂方法模式(Factory Method Pattern) 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。 ★★☆☆☆ ★★★★★ 抽象工厂模式(Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 ★★★★☆ ★★★★★ 建造者模式(Builder Pattern) 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 ★★★★☆ ★★☆☆☆ 原型模式(Prototype Pattern) 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。 ★★★☆☆ ★★★☆☆ 单例模式(Singleton Pattern) 确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。 ★☆☆☆☆ ★★★★☆ 简单工厂模式概述简单工厂模式并不属于GoF的23种经典设计模式，但通常将它作为学习其他工厂模式的基础，下面通过一个简单实例来引出简单工厂模式。 考虑一个水果农场，当用户需要某一种水果时，该农场能够根据用户所提供的水果名称返回该水果。在此，水果农场被称为工厂（Factory），而生产出的水果被称为产品（Product），水果的名称则被称为参数，工厂可以根据参数的不同返回不同的产品，这就是简单工厂模式的动机。该过程的示意图如图1所示，用户无须知道苹果（Apple）、橙（Orange）、香蕉（Banana）如何创建，只需要知道水果的名称即可得到对应的水果。 图1 简单工厂模式示意图 作为最简单的设计模式之一，简单工厂模式的设计思想和实现过程都比较简单，其基本实现流程如下： 首先将需要创建的各种不同产品对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入参数的不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。 简单工厂模式（Simple Factory Pattern）的定义如下：1定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。 由于在简单工厂模式中用于创建实例的方法通常是静态（static）方法，所以简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它是一种类创建型模式。简单工厂模式的要点在于：如果需要什么，只需要传入一个正确的参数，就可以获取所需要的对象，而无须知道其创建细节。 简单工厂模式的结构与实现简单工厂模式的结构简单工厂模式的结构比较简单，其核心是工厂类的设计，其结构如图2所示。 图2 简单工厂模式结构图 由图2可知，简单工厂模式包含以下3个角色。 (1)Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法FactoryMethod()，它的返回类型为抽象产品类型Product。 (2)Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公共方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 (3)ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 简单工厂模式的实现在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。 在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现。典型的抽象产品类代码如下：1234567891011abstract class Product&#123; // 所有产品类的公共业务方法 public void MethodSame() &#123; // 公共方法的实现 &#125; // 声明抽象业务方法 public abstract void MethodDiff();&#125; 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。典型的具体产品类代码如下：1234567891011121314151617class ConcreteProductA : Product&#123; // 实现业务方法 public override void MethodDiff() &#123; // 业务方法的实现 &#125;&#125;class ConcreteProductB : Product&#123; // 实现业务方法 public override void MethodDiff() &#123; // 业务方法的实现 &#125;&#125; 简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品。在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入参数的不同可以创建不同的产品对象。典型的工厂类代码如下:1234567891011121314151617181920class Factory&#123; // 静态工厂方法 public static Product GetProduct(string arg) &#123; Product product = null; if(arg.Equals("A")) &#123; product = new ConcreteProductA(); // 初始化设置product &#125; else if(arg.Equals("B")) &#123; product = new ConcreteProductB(); // 初始化设置product &#125; return product; &#125;&#125; 在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。其典型代码如下：12345678910class Program&#123; static void Main(string[] args) &#123; Product product; product = Factory.GetProduct("A"); // 通过工厂类创建产品对象 product.MethodSame(); product.MethodDiff(); &#125;&#125; 简单工厂模式的应用实例下面通过一个应用实例来进一步学习和理解简单工厂模式。 1.实例说明 某软件公司要基于C#语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart）等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。现使用简单工厂模式来设计该图表库。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 图表库结构图 在图3中，Chart接口充当抽象产品类，其子类HistogramChart、PieChart和LineChart充当具体产品类，ChartFactory充当工厂类。 3.实例代码 (1)Chart：抽象图标接口，充当抽象产品类。 1234567namespace SimpleFactorySample&#123; interface Chart &#123; void Display(); &#125;&#125; (2)HistogramChart：柱状图类，充当具体产品类。 1234567891011121314151617using System;namespace SimpleFactorySample&#123; class HistogramChart : Chart &#123; public HistogramChart() &#123; Console.WriteLine("创建柱状图！"); &#125; public void Display() &#123; Console.WriteLine("显示柱状图！"); &#125; &#125;&#125; (3)PieChart：饼状图类，充当具体产品类。 1234567891011121314151617using System;namespace SimpleFactorySample&#123; class PieChart : Chart &#123; public PieChart() &#123; Console.WriteLine("创建饼状图！"); &#125; public void Display() &#123; Console.WriteLine("显示饼状图！"); &#125; &#125;&#125; (4)LineChart：折线图类，充当具体产品类。 1234567891011121314151617using System;namespace SimpleFactorySample&#123; class LineChart : Chart &#123; public LineChart() &#123; Console.WriteLine("创建折线图！"); &#125; public void Display() &#123; Console.WriteLine("显示折线图！"); &#125; &#125;&#125; (5)ChartFactory：图表工厂类，充当工厂类。 123456789101112131415161718192021222324252627282930using System;namespace SimpleFactorySample&#123; class ChartFactory &#123; // 静态工厂方法 public static Chart GetChart(string type) &#123; Chart chart = null; if (type.Equals("histogram")) &#123; chart = new HistogramChart(); Console.WriteLine("初始化设置柱状图！"); &#125; else if (type.Equals("pie")) &#123; chart = new PieChart(); Console.WriteLine("初始化设置饼状图！"); &#125; else if (type.Equals("line")) &#123; chart = new LineChart(); Console.WriteLine("初始化设置折线图！"); &#125; return chart; &#125; &#125;&#125; (6)Program：客户端测试类。1234567891011121314151617using System;namespace SimpleFactorySample&#123; class Program &#123; static void Main(string[] args) &#123; Chart chart; chart = ChartFactory.GetChart("histogram"); // 通过静态工厂方法创建产品 chart.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：123创建柱状图! 初始化设置柱状图! 显示柱状图 在客户端测试类中，使用工厂类ChartFactory的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可。例如将柱状图改为饼状图，只需将代码：1chart = ChartFactory.GetChart("histogram"); 改为：1chart = ChartFactory.GetChart("pie"); 编译并运行程序，输出结果如下：123创建饼状图! 初始化设置饼状图! 显示饼状图! 不难发现，本实例在创建具体Chart对象时，必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象，客户端代码需要重新编译，这对于客户端而言，违背了开闭原则。 下面介绍一种常用的解决方案，可以实现在不修改客户端代码的前提下让客户端能够更换具体产品对象。 首先将静态工厂方法的参数存储在XML格式的配置文件App.config中，如下所示：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="chartType" value="histogram"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 然后将客户端代码修改如下：1234567891011121314151617181920using System;using System.Configuration;namespace SimpleFactorySample&#123; class Program &#123; static void Main(string[] args) &#123; Chart chart; // 读取配置文件 string chartStr = ConfigurationManager.AppSettings["chartType"]; chart = ChartFactory.GetChart(chartStr); // 通过静态工厂方法创建产品 chart.Display(); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：123创建柱状图！ 初始化设置柱状图! 显示柱状图！ 在上述客户端代码中，通过使用ConfigurationManager类的AppSettings属性可以获取存储在配置文件（例如App.config）中的字符串，在C#源代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件App.config即可，无须修改任何源代码，符合开闭原则。 需要注意的是，在某些版本的Visual Studio中需要手动引入组件“System.Configuration”，否则无法使用ConfigurationManager类。步骤如下: 在“解决方案资源管理器”项目树形结构中的“引用”结点上右击，在快捷菜单中选择“添加引用”命令，在弹出的对话框中选择“.NET”选项卡，选中名称为“System.Configuration”的组件，即可添加该组件，并使用其中的ConfigurationManager等类。 创建对象与使用对象本节将讨论工厂类的作用以及如何通过工厂类来创建对象。在一个面向对象软件系统中，与一个对象相关的职责通常有3种：对象本身所具有的职责、创建对象的职责和使用对象的职责。对象本身的职责比较容易理解，就是对象自身所具有的一些数据和行为，可通过一些公开的（public）方法来实现。本节将重点讨论创建对象的职责和使用对象的职责。 在C#语言中，通常有以下几种创建对象的方式： (1)使用new关键字直接创建对象。 (2)通过反射机制创建对象（工厂方法模式）将学习此方式。 (3)通过克隆方法创建对象（原型模式）将学习此方式。 (4)通过工厂类创建对象。 毫无疑问，在客户端代码中直接使用new关键字是最简单的创建对象的方式，但是它的灵活性较差，下面通过一个简单的实例来加以说明：123456789101112131415161718class Login&#123; private UserDAO udao; public Login() &#123; // 创建对象 udao = new OracleUserDAO(); &#125; public void Execute() &#123; // 其他代码 // 使用对象 udao.FindUserById(); // 其他代码 &#125;&#125; 以上代码中，在Login类中定义了一个UserDAO类型的对象udao，在Login的构造函数中创建了OracleUserDAO类型的udao对象，并在Execute()方法中调用了udao对象的FindUserById()方法。Login类负责创建一个UserDAO子类的对象并使用该对象的方法来完成相应的业务处理，也就是说，Login既负责udao的创建又负责udao的使用，创建对象和使用对象的职责耦合在一起，这样的设计会导致一个很严重的问题：如果在Login中希望能够使用UserDAO的另一个子类，例如SQLServerUserDAO类型的对象，必须修改Login类的源代码，这将违背开闭原则。 当遇到这种情况时，最常用的一种解决方法是将udao对象的创建职责从Login类中移除，在Login类之外创建对象，由专门的工厂类来负责udao对象的创建。通过引入工厂类，让客户类（例如Login）不涉及对象的创建，对象的创建者也不会涉及对象的使用。引入工厂类UserDAOFactory之后的结构如图4所示。 图4 引入工厂类之后的结构图 工厂类的引入将降低因为产品或工厂类改变所造成的维护工作量。如果UserDAO的某个子类的构造函数发生改变或者需要添加或移除不同的子类，只要维护UserDAOFactory的代码，不会影响到Login；如果UserDAO接口发生改变，例如添加、移除方法或改变方法名，只需要修改Login，不会给UserDAOFactory带来任何影响。 所有的工厂模式都强调一点：两个类A和B之间的关系应该仅仅是A创建B或者是A使用B，而不能两种关系都有。将对象的创建和使用分离，使得系统更加符合单一职责原则，有利于对功能的复用和系统的维护。 此外，将对象的创建和使用分离还有一个好处：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中。因为有时创建一个对象不只是简单调用其构造函数，还需要设置一些参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入工厂类来封装对象的创建逻辑和客户代码的实例化配置选项。 使用工厂类还有一个优点，一个类可能拥有多个构造函数，而在C#、Java等语言中构造函数的名称都与类名相同，客户端只能通过传入不同的参数来调用不同的构造函数创建对象，从构造函数和参数列表中大家很难了解不同构造函数所构造的产品的差异。如果将对象的创建过程封装在工厂类中，可以提供一系列名称完全不同的工厂方法，每一个工厂方法对应一个构造函数，客户端就可以以一种更加可读、易懂的方式来创建对象，而且，从一组工厂方法中选择一个意义明确的工厂方法，比从一组名称相同参数不同的构造函数中选择一个构造函数要方便很多，如图5所示。 图5 矩形工厂与矩形类 在图5中，矩形工厂类RectangleFactory提供了CreateRectangle()和CreateSquare()两个工厂方法，一个用于创建长方形，一个用于创建正方形，这两个方法比直接通过构造函数来创建长方形或正方形意义更加明确，在一定程度上降低了客户端调用时出错的概率。 但是，并不需要为系统中的每一个类都配备一个工厂类，如果一个类很简单，而且不存在太多变化，其构造过程也很简单，此时就无须为其提供工厂类，直接在使用之前实例化即可，例如C#语言中的String类（或string），就无须为它专门提供一个StringFactory，这样做反而会导致工厂泛滥，增加系统的复杂度。 以上关于创建对象和使用对象的讨论也适用于工厂方法模式和抽象工厂模式。 简单工厂模式的简化有时为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移到抽象产品类中，如图6所示。 图6 简化的简单工厂模式 在图6中，客户端可以通过调用产品父类的静态工厂方法，根据不同参数创建不同类理的产品子类对象，这种方法在很多类库和框架中也广泛存在。 简单工厂模式的优缺点与适用环境简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。 简单工厂模式的优点简单工厂模式的主要优点如下： (1)工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。 (2)客户端无须知道所创建的具体产品类的类名，只需知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度上减少使用者的记忆量。 (3)通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 简单工厂模式的缺点简单工厂模式的主要缺点如下： (1)由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。 (2)使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。 (3)系统扩展困难，一旦添加新产品不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 (4)简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。在C#语言中，不能通过类的实例对象来访问静态方法和静态变量，无法在客户端代码中针对工厂父类编程，而在运行时使用工厂子类对象来覆盖父类，因此，工厂类不能得到很好的扩展。 简单工厂模式的适用环境在以下情况下可以考虑使用简单工厂模式： (1)工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑过于复杂。 (2)客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 本章小结(1)创建型模式关注对象的创建过程，它对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例创建细节。在GoF设计模式中一共包含5种创建型模式，通常将简单工厂模式作为学习其他工厂模式的基础，简单工厂模式不是GoF设计模式。 (2)在简单工厂模式中，定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。简单工厂模式是一种类创建型模式。 (3)简单工厂模式包含工厂角色、抽象产品角色和具体产品角色3个角色。其中，工厂角色是简单工厂模式的核心，负责实现创建产品实例的内部逻辑；抽象产品角色是工厂类所创建的所有对象的父类，封装了各种产品对象的公共方法；具体产品角色是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。 (4)简单工厂模式的主要优点在于实现了对象创建和使用的分离；客户端无须知道所创建的具体产品类的类名，只需知道具体产品类所对应的参数即可；通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。其主要缺点在于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响；增加了系统中类的个数且增加了系统的复杂度和理解难度系统扩展困难，一旦添加新产品不得不修改工厂逻辑，且工厂角色无法形成基于继承的等级结构。 (5)简单工厂模式适用的环境：工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂；客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 (6)将对象的创建和使用分离，使得系统更加符合单一职责原则，有利于对功能的复用和系统的维护。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概述与UML类图]]></title>
    <url>%2F2019%2F09%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%E4%B8%8EUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 类模式处理类和子类之间的关系，对象模式处理对象间的关系。各举一个例子。 UML图中的1..*是什么意思？实心菱形是什么意思？ 聚合和组合有什么关系和区别？ 设计模式1.使用桥接模式时系统中的类必须存在两个独立变化的维度，在使用组合模式时系统中必须存在整体和部分的层次结构。 2.设计模式根据范围分类，即模式主要是处理类之间的关系还是处理对象之间的关系，模式可分为类模式和对象模式两种类型。 (1)类模式：此类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定下来，是一种静态模式。 (2)对象模式：此类模式处理对象间的关系，这些关系在运行时变化，更具动态性。 UML类和类的UML表示在UML2.0的13种图形中，类图是使用最广泛的图形之一，它用于描述系统中所包含的类以及它们之间的相互关系，每一个设计模式的结构都可以使用类图来表示。类图帮助人们简化对系统的理解，是系统分析和设计阶段的重要产物，也是系统编码的重要模型依据。 1.类 类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类通常有且仅有一种职责。在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。类的属性即类的数据职责，类的操作即类的行为职责。设计类是面向对象设计中最重要的组成部分，也是最复杂和最耗时的部分。 在软件系统运行时，类将被实例化成对象（Object），对象对应于某个具体的事物，是类的实例（Instance）。 类图（Class Diagram）使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系。 2.类的UML图示 在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示，例如定义一个Employee类，它包含属性name、age和name和email，以及操作ModifyInfo()，在UML类图中该类如图1所示。 图1 类的UML图示 图1对应的C#代码片段如下：1234567891011public class Employee &#123; private string name; private int age; private string email; public void ModifyInfo() &#123; ... &#125;&#125; 在UML类图中，类一般由三部分组成： (1)第一部分是类名，每个类都必须有一个名字，类名是一个字符串。 (2)第二部分是类的属性（Attributes），属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。 UML规定属性的表示方式如下：1可见性 名称:类型[ = 默认值] 其中： ①“可见性”表示该属性对于类外的元素而言是否可见，包括公有（public）、私有（private）和受保护（protected）3种，在类图中分别用符号“+”、“-”和“#”表示。在C#语言中还新增了internal和protected internal两种可见性，其中，internal表示程序集内可见，protected internal表示程序集内可见或者子类可见，分别用符号“i”和“r”表示。为了保证数据的封装性，属性的可见性通常为private，它们通过公有的Getter方法和Setter方法供外界使用。 ②“名称”表示属性名，用一个字符串表示，按照C#语言的命名规范，属性命名采用驼峰命名法（Camel Case），即属性名中的第一个单词全小写，之后每个单词的首字母大写。 ③“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。 ④“默认值”是一个可选项，即属性的初始值。 (3)第三部分是类的操作（Operations），操作是类的任意一个实例对象都拥有的行为，是类的成员方法。 UML规定操作的表示方式如下：1可见性 名称(参数列表) [ : 返回类型] 其中：①“可见性”的定义与属性的可见性定义相同。 ②“名称”即方法名或操作名，用一个字符串表示，按照C#语言的命名规范，方法命名采用帕斯卡命名法（Pascal Case），即方法名中的每个单词首字母都大写。 ③“参数列表”表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“,”隔开。 ④“返回类型”是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型（void），如果是构造方法，则无返回类型。 类之间的关系在软件系统中，类并不是孤立存在的，类与类之间存在着各种关系，对于不同类型的关系，UML提供了不同的表示方式。 1.关联关系 关联（Association）关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。在UML类图中，用实线连接有关联关系的对象所对应的类，在使用C、C++和Java等编程语1言实现关联关系时，通常将一个类的对象作为另一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必需的，可以根据需要增加，其目的是使类之间的关系更加明确。 例如在一个登录界面类LoginForm中包含一个Button类型的注册按钮loginButton，它们之间可以表示为关联关系，代码实现时可以在LoginForm中定义一个名为loginButton的属性对象，其类型为Button，如图2所示。 图2 关联关系实例 图2对应的C#代码片段如下： 12345678910public class LoginForm&#123; private Button loginButton; ...&#125;public class Button&#123; ...&#125; 在UML中，关联关系通常又包含以下几种形式。 (1)双向关联：默认情况下，关联是双向的。例如顾客（Customer）购买商品（Product）并拥有商品，反之，卖出的商品总有某个顾客与之相关联。因此，Customer类和Product类之间具有双向关联关系，如图3所示。 图3 双向关联实例 图3对应的C#代码片段如下：1234567891011public class Customer&#123; private Product[] products; ...&#125;public class Product&#123; private Customer customer; ...&#125; (2)单向关联：类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如顾客（Customer）拥有地址（Address），则Customer类与Address类具有单向关系，如图4所示。 图4 单向关联实例 图4对应的C#代码片段如下：12345678910public class Customer&#123; private Address address; ...&#125;public class Address&#123; ...&#125; (3)自关联：在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如，一个结点类（Node）的成员又是结点Node类型的对象，如图5所示。 图5 自关联实例 图5对应的C#代码片段如下：12345public class Node&#123; private Node subNode; ...&#125; (4)多重性关联：多重性关联关系又称为重数性（Multiplicity）关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。 对象之间可以存在多种多重性关联关系，常见的多重性表示方式如表1所示。 表1 多重性表示方式列表 表示方式 多重性说明 1..1 表示另一个类的一个对象只与该类的一个对象有关系 0..* 表示另一个类的一个对象与该类的零个或多个对象有关系 1..* 表示另一个类的一个对象与该类的一个或多个对象有关系 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系 m..n 表示另一个类的一个对象与该类最少m个最多n个对象有关系 例如一个界面（Form）可以拥有零个或多个按钮（Button），但是一个按钮只能属于一个界面，因此，一个Form类的对象可以与零个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联，如图6所示。 图6 多重性关联实例 图5对应的C#代码片段如下：12345678910public class Form&#123; private Button[] buttons; // 定义一个集合对象 ...&#125;public class Button&#123; ...&#125; (5)聚合关系：聚合（Aggregation）关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。例如汽车发动机（Engine）是汽车（Car）的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系，如图7所示。 图7 聚合关系实例 在用代码实现聚合关系时，成员对象通常作为构造方法、Setter方法或业务方法的参数注入整体对象中。图7对应的C#代码片段如下： 12345678910111213141516171819202122public class Car&#123; private Engine engine; // 构造注入 public Car(Engine engine) &#123; this.engine = engine; &#125; public Engine Engine &#123; get &#123; return engine; &#125; set &#123; engine = value; &#125; // 设值注入 &#125; ...&#125;public class Engine&#123; ...&#125; (6)组合关系：组合（Composition）关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。例如人的头（Head）与嘴巴（Mouth），嘴巴是头的组成部分之一，如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系，如图8所示。 图8 组合关系实例 在用代码实现组合关系时，通常在整体类的构造方法中直接实例化成员类。图8对应的C#代码片段如下：123456789101112131415public class Head&#123; private Mouth mouth; public Head() &#123; mouth = new Mouth(); // 实例化成员类 &#125; ...&#125;public class Mouth&#123; ...&#125; 2.依赖关系 依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的 虚线表示，由依赖的一方指向被依赖的一方。例如驾驶员开车，在Driver类的Drive()方法中将Car类型的对象car作为一个参数传递，以便在Drive()方法中能够调用car的Move()方法，驾驶员的Drive()方法依赖车的Move()方法，因此类Driver依赖类Car，如图9所示。 图9 依赖关系实例 在系统实施阶段，依赖关系通常通过3种方式来实现，第一种也是最常用的一种方式，如图9所示，将一个类的对象作为另一个类中方法的参数，第二种方式是在一个类的方法中将另一个类的对象作为其局部变量，第三种方式是在一个类的方法中调用另一个类的静态方法。图9对应的C#代码片段如下：1234567891011121314151617public class Driver&#123; public void Drive(Car car) &#123; car. Move(); &#125; ...&#125;public class Car&#123; public void Move() &#123; ... &#125; ...&#125; 3.泛化关系 泛化（Generaliation）关系也就是继承关系，用于描述父类与子类之间的关系，父类又称为基类或超类，子类又称为派生类。在UML中，泛化关系用带空心三角形的直线来表示。在用代码实现时，使用面向对象的继承机制来实现泛化关系，在C#中使用冒号“：”来实现。例如Student类和Teacher类都是Person类的子类，Student类和Teacher类继承了Person类的属性和方法，Person类的属性包含姓名（name）和年龄（age），每一个Student和Teaeher也都具有这两个属性，另外，Student类增加了属性学号（studentNo），Teacher类增加了属性教师编号（teacherNo），Person类的方法包括行走Move()和说话Say()，Studen类和Teaeher类继承了这两个方法，而且Student类还新增了方法Study()，Teaeher类还新增了方法Teach()，如图10所示。 图10 泛化关系实例 图10对应的C#代码片段如下：1234567891011121314151617181920212223242526272829303132333435363738// 父类public class Person&#123; protected string name; protected int age; public void Move() &#123; ... &#125; public void Say() &#123; ... &#125;&#125;// 子类public class Student : Person&#123; private string studentNo; public void Study() &#123; ... &#125;&#125;// 子类public class Teacher : Person&#123; private string teacherNo; public void Teach() &#123; ... &#125;&#125; 4.接口与实现关系 在很多面向对象语言中都引入了接口的概念，例如C#、Java等，在接口中通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。在C#中，接口中的方法默认可见性均为public，无须再使用任何可见性关键字。在UML中用与类的表示法类似的方式表示接口，如图11所示。 图11 接口的UML图示 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现（Realization）关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。例如定义了一个交通工具接口Vehicle，包含一个抽象操作Move()，在类Ship和类Car中都实现了该Move()操作，不过具体的实现细节将会不一样，如图12所示。 图12 实现关系实例 实现关系在用代码实现时，不同的面向对象语言也提供了不同的语法，在C#中使用冒号“：”来实现。图12对应的C#代码片段如下：1234567891011121314151617181920public interface Vehicle&#123; void Move();&#125;public class Ship : Vehicle&#123; public void Move() &#123; ... &#125;&#125;public class Car : Vehicle&#123; public void Move &#123; ... &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC和AOP的一些基本概念]]></title>
    <url>%2F2019%2F09%2F11%2FIOC%E5%92%8CAOP%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是IOCIoC就是Inversion of Control，控制反转。在Java开发中，IoC意味着将你设计好的类交给系统去控制，而不是在你的类内部控制。这称为控制反转。 下面我们以几个例子来说明什么是IoC 假设我们要设计一个Girl和一个Boy类，其中Girl有kiss方法，即Girl想要Kiss一个Boy。那么，我们的问题是，Girl如何能够认识这个Boy？ 在我们中国，常见的ＭＭ与GG的认识方式有以下几种 １ 青梅竹马； ２ 亲友介绍； ３ 父母包办 那么哪一种才是最好呢？ 青梅竹马：Girl从小就知道自己的Boy。1234567public class Girl &#123; void kiss() &#123; Boy boy = new Boy(); &#125;&#125; 然而从开始就创建的Boy缺点就是无法在更换。并且要负责Boy的整个生命周期。如果我们的Girl想要换一个怎么办？（笔者严重不支持Girl经常更换Boy）亲友介绍：由中间人负责提供Boy来见面1234567public class Girl &#123; void kiss() &#123; Boy boy = BoyFactory.createBoy(); &#125;&#125; 亲友介绍，固然是好。如果不满意，尽管另外换一个好了。但是，亲友BoyFactory经常是以Singleton的形式出现，不然就是，存在于Globals，无处不在，无处不能。实在是太繁琐了一点，不够灵活。我为什么一定要这个亲友掺和进来呢？为什么一定要付给她介绍费呢？万一最好的朋友爱上了我的男朋友呢？ 父母包办：一切交给父母，自己不用费吹灰之力，只需要等着Kiss就好了。12345678public class Girl &#123; void kiss(Boy boy) &#123; // kiss boy boy.kiss(); &#125;&#125; Well，这是对Girl最好的方法，只要想办法贿赂了Girl的父母，并把Boy交给他。那么我们就可以轻松的和Girl来Kiss了。看来几千年传统的父母之命还真是有用哦。至少Boy和Girl不用自己瞎忙乎了。 这就是IOC，将对象的创建和获取提取到外部。由外部容器提供需要的组件。 我们知道好莱坞原则：“Do not call us, we will call you.” 意思就是，You, girlie, do not call the boy. We will feed you a boy。 我们还应该知道依赖倒转原则即 Dependence Inversion Princinple，DIP。 Eric Gamma说，要面向抽象编程。面向接口编程是面向对象的核心。 组件应该分为两部分，即 Service, 所提供功能的声明 Implementation, Service的实现 好处是：多实现可以任意切换，防止 “everything depends on everything” 问题．即具体依赖于具体。 所以，我们的Boy应该是实现Kissable接口。这样一旦Girl不想kiss可恶的Boy的话，还可以kiss可爱的kitten和慈祥的grandmother。 IOC的typeIoC的Type指的是Girl得到Boy的几种不同方式。我们逐一来说明。 IOC type 0：不用IOC 12345678910111213141516public class Girl implements Servicable &#123; private Kissable kissable; public Girl() &#123; kissable = new Boy(); &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; Girl自己建立自己的Boy，很难更换，很难共享给别人，只能单独使用，并负责完全的生命周期。 IOC type 1，先看代码： 1234567891011121314public class Girl implements Servicable &#123; Kissable kissable; public void service(ServiceManager mgr) &#123; kissable = (Kissable) mgr.lookup(“kissable”); &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; 这种情况出现于Avalon Framework。一个组件实现了Servicable接口，就必须实现service方法，并传入一个ServiceManager。其中会含有需要的其它组件。只需要在service方法中初始化需要的Boy。 另外，J2EE中从Context取得对象也属于type 1。 它依赖于配置文件123456&lt;Container&gt; &lt;component name=“kissable“ class=“Boy"&gt; &lt;configuration&gt; … &lt;/configuration&gt; &lt;/component&gt; &lt;component name=“girl" class=“Girl" /&gt;&lt;/container&gt; IOC type 2： 123456789101112131415public class Girl &#123; private Kissable kissable; public void setKissable(Kissable kissable) &#123; this.kissable = kissable; &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; Type 2出现于spring Framework，是通过JavaBean的set方法来将需要的Boy传递给Girl。它必须依赖于配置文件。12345678&lt;beans&gt; &lt;bean id=“boy" class=“Boy"/&gt; &lt;bean id=“girl“ class=“Girl"&gt; &lt;property name=“kissable"&gt; &lt;ref bean=“boy"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; IOC type 31234567891011121314public class Girl &#123; private Kissable kissable; public Girl(Kissable kissable) &#123; this.kissable = kissable; &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; 这就是PicoContainer的组件 。通过构造函数传递Boy给Girl。 123456789PicoContainer container = new DefaultPicoContainer();container.registerComponentImplementation(Boy.class);container.registerComponentImplementation(Girl.class);Girl girl = (Girl) container.getComponentInstance(Girl.class);girl.kissYourKissable(); ================AOP 关注与主要的东西，也可以说让你只关注与业务，其他的东西就让AOP帮你完成。 我们要吃武昌鱼：1234567891011public class Dinner &#123; Customer yangyi; public void eatfish() &#123; yangyi.cookFish(); yangyi.eatFish(); yangyi.washDish(); &#125;&#125; prog 1 现在我觉得这顿饭吃的太不爽了，还要自己做,洗碗。 我想这样123456789public class Dinner &#123; ICustomer yangyi; public void eatfish() &#123; yangyi.eatFish(); &#125;&#125; prog 2 就是说我现在只用吃就行了，但是这样可以么？谁来帮我做鱼呢？这个我想就是所谓AOP吧，我只用关心我吃鱼的方面就行了，做鱼又食堂关注就行了。 现在看看谁来帮我cook fish呢，它怎么做到的呢？ 我看到上面prog 1中的Customer已经变成了prog 2中的ICustomer了，就是说如果愿意，我可以用任意的ICustomer实现来替代yangyi了，这个就是一个Customer的代理，在调用 yangyi.eatfish的时候，之前代理会帮我调用cookfish()，之后代理会帮我调用washdish()还是看看代码吧123456789101112131415161718class Customer implements ICustomer &#123; void eatfish() &#123; // haha eat, delicious &#125;&#125;class CustomerProxy implements ICustomer &#123; Customer yangyi = new Customer() //just for example. proxy is implement by dynamic proxy or other tech in real world void eatfish() &#123; cookfish(); yangyi.eatfish(); washdish(); &#125;&#125; 基本上就是说proxy会在调用我的Customer代码之前和之后做一些工作，ok, 这就是AOP，不知道我讲清楚了没有。在spring中，proxy是用java的动态代理做的，在运行的时候自动生成CustomerProxy这个东西，然后用这个Proxy替代我的Customer。 为什么老把IOC和AOP放在一起讲呢，想想我们的Customer是怎么来的吧 如果在某个时候我们说yangyi = new Customer()，那这样Proxy怎么替代这个Customer啊。所以IoC说，你要用Customer么，你直接说我要用，声明他，告诉我怎么样能够设置这个Customer，用的时候我会来调用你的(don’t call me, but I call you) 所以真正的代码应该是这样的1234567891011121314public class Dinner &#123; ICustomer yangyi; public void eatfish() &#123; yangyi.eatFish(); &#125; public void setYangyi(ICustomer customer) &#123; this.yangyi = customer; &#125;&#125; 我提供一个SetYangyi的方法，IoC会在运行时把yangyi设置成CustomerProxy，然后，我的代码就只用尽情的享受武昌鱼的美味了。其它的，留给ioc了。 BTW,烦死JDBC的connection.close()了吧，呵呵，IOC＋AOP应该最适合这方面了。 这两个概念基本上是一个设计层的概念，主要讲的就是怎么去分离关注，用面向对象的话说，就是怎么把职责进行分离。而这两个模式，我个人认为都有一个共同点，就是变以前的主动为被动，而我认为，这种改变可能也是将来面向对象发展的一个趋势。 首先说说什么叫主动。写过面向对象程序的人都知道，面向对象与面向过程的区别就是，面向对象是由一大堆对象组成的，对象通过协作完成面向过程中的任务。假设现在有对象A和B，那么当A需要使用B中的方法时，那么在A内部，就会有有一个对B方法的调用，这种调用就称为主动调用。代码大概会如下：123456789public class A&#123; B b; public void methodA() &#123; b.methodB(); &#125;&#125; 这里为了下文解释方便，我增加了一个调用点的定义，调用点就是调用发生的地方。也就是上面 b.methodB()中的b。 理解了什么叫主动之后，我想就先介绍什么叫IoC。IoC的全称这里就不说了，他的字面意思就是控制反转。在上面的代码当中，由于A调用了B的方法，因此就形成了一个A对B的依赖，这本身并没有什么问题。但是OO的思想是希望我们基于接口编程，而不是基于实现编程。因此，系统设计将不止是原有的A，B，而需要变成IA，IB，A，B，其中IA，IB是接口，A，B是对应的实现类，然后为了使得A中现在对B的实现依赖变成对接口的依赖，代码应该变成这样。123456789public class A implements IA&#123; IB b; public void methodA() &#123; b.methodB(); &#125;&#125; 这里虽然我们是基于接口编程了，但大家知道，在这中间，我们需要有一个步骤把b指向一个IB的实现类B，这个怎么做，就是IoC要做的事情，这里就不细说了。但简单来说，没有IoC，我们可能需要在A中通过某种方法去获取一个B的实例，但有了IoC，她就能在A不参与的情况下，给我们一个B的实例，所以，IoC要做的就是在调用点上从原来的主动生成一个调用点，变成被动的接受一个调用点。 接着就是AOP，全称也不说了，字面意思就是面向方面编程。举一个最普遍的例子，就是如果我们代码需要做日志的话，那么在没有AOP的时候，我们的代码可能就是这样：12345678public class A&#123; public void methodA() &#123; do log; b.methodB(); &#125;&#125; 这里methodA()中的做日志并不是方法本身的逻辑功能，而是一个附属功能，因此，我们需要把它分离出去。怎么分离，就是AOP要做的事情，简单来说，就是系统在调用者不知情的情况下，为我们的类A增加了一个代理类，她把我们的类A包装了起来，像这样：12345678910111213141516171819public class AP extends A&#123; A a; public void methodA() &#123; do log; a.methodA(): &#125;&#125;public class A&#123; public void methodA() &#123; b.methodB(); &#125;&#125; 于是，当我们以为自己在调用A的methodA()方法时，实际调用的将是AP中的methodA()，于是就可以把做日志的功能从原有的methodA()中分离了出去。所以，AOP要做的就是在用户不知道的情况下，将我们的调用点包裹了起来，从而把原来的功能进行了分离。]]></content>
  </entry>
  <entry>
    <title><![CDATA[职责链模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 职责链设计模式的好处是，任何对象都可以向处理请求的对象发送请求，而且处理请求的对象可以改变，从而可以结合更多或不同的对象来处理请求。怎么理解？ 本章涵盖： 推卸责任职责链设计模式将请求的发送者与接收者分开，这样可以避免请求者与接收者的耦合。另外，这个模式允许将请求沿着一个链传递到多个不同的对象，使这些对象都有机会处理请求。发送者并不需要知道哪一个对象处理这个请求，而对象也不需要知道是谁发送了这个请求。在这二者之间不存在耦合。 职责链设计模式的好处是，任何对象都可以向处理请求的对象发送请求，而且处理请求的对象可以改变，从而可以结合更多或不同的对象来处理请求。所以请求者和请求处理器都可以改变，而不必担心对更大的系统带来破坏。图1显示了这个职责链设计模式的类图。 图1：职责链设计模式类图 注意，Client是这个程序中不可缺少的一部分。实际上，在这个结构中，它要完成很重要的工作，因为Client不仅要启动请求，可能还需要启动具体处理器中实现的后继。为此，一种方法是在Handler接口中建立后继方法，并在具体处理器中实现。当Client发出一个请求时，它可以同时建立这个链，并确定后继的顺序。 看到职责链模式时，有些人可能会认为“这只不过是一个大的switch语句而已”。从某种程度上看似乎如此，不过实际上并不是这样。它确实会检查一个请求，确定它是否与某个case条件匹配。不过， switch语句是固定的，而职责链会由各个具体处理器定义其后继。基于这种组织，可以把任意多个响应存储在一个MySQL数据库表中，这样一来，多个不同的“咨询台”可以使用相同的表以及相同的PHP职责链。由于每个具体处理器都包含一个方法来指定它自己的后继， Client通过具体处理器对象指定后继时也就定义了顺序。 另外，由于Client要启动请求链，它可以在开发人员指定的任何位置开始。假设具体请求处理器4、10、15和30可以作为你希望的新咨询台，就可以指定处理器4作为链中的第一个处理器，然后指定处理器10作为它的后继，再指定15为10的后继，而30作为15的后继。所以，职责链具有switch语句所没有的灵活性。 MySQL咨询台中的职责链职责链的第一个实现是一个咨询台，用户可以从一系列帮助主题中选择一个要询问的主题。不论是作为PHP设计模式，还是使用MySQL作为一个文本数据存储系统，这都是一个简单的实现。基本说来，在这个实现中，用户将从一组单选钮中选择一个查询，发出请求，然后通过一个响应链搜索。找到正确的响应时，对象从一个MySQL表获取响应，并在屏幕上显示。 构建和加载响应表首先要构建一个表，在其中存储文本响应。这一章中的MySQL连接同样使用第11章中的连接类和接口。为便于查看，这里再次给出这些类和接口。首先来看接口：12345678910&lt;?php// 文件名： IConnectInfo.phpinterface IConnectInfo&#123; const HOST = "localhost"; const UNAME = "phpWorker"; const PW = "easyWay"; const DBNAME = "dpPatt"; public function doConnect（）;&#125; 当然，你要使用你自己的连接信息。现在来看实现这个接口的连接类：12 这一章需要的每一个MySQL连接都会使用这个连接接口和类。 响应表只需要一个ID、一个指示链对象的字段，以及一个文本字段（提供咨询台中的“帮助”文本）：12 这里增加了自动id字段，因为将来有可能对表进行编辑，这算是一种预备措施，不过如果你愿意也可以将其忽略。另外，这里首先删除一个表，然后再创建一个表，这种做法在开发中很常用。这样可以加速这个过程，并确保在继续处理之前先将原来的表删除。完成表的调试之后，可以使用MySQL命令来创建表（去掉之前首先删除表的那些代码）：123```要让这个表真正发挥作用，需要在表中填入对应查询的响应，所以需要一个数据输入模块，包括一个PHP类和一个HTML表单。另外还必须更新咨询素材，所以除了数据输入外，还需要一个数据更新模块。先来看HTML：```html InsertData和UpdateData类获得HTML表单发送的数据，将数据存储在helpdesk表中。 InsertData.php&lt;/span&gt; 12 UpdateData.php&lt;/span&gt; 12 对于这个职责链咨询台，要在数据库表中输入或更新数据，这需要一个简单的表单。图2显示了这个数据输入/更新管理工具的外观。 图2：输入响应数据 只有应用管理员才能输入帮助数据，用户无权访问这个数据输入表单。图2中的查询链值（Query Chain Value）是用户搜寻的请求或帮助的一个标识符。这个特定的程序是这样组织的：请求用一个值来标识查询（q1到q（查询数））。在这个例子中，“咨询台”只有5个查询，所以是q1到q5。不过，完全可以有更多的查询。另外，一旦完成这个程序，如果想增加更多查询，可以使用咨询台数据输入模块（Help Desk Data EntryModule）来增加。接下来只需增加更多具体处理器，构成职责链模式。利用更新模块，咨询台就有了一个微型的内容管理系统（content management system， CMS）。 咨询台职责链一旦输入请求的响应数据，可以使用职责链来提供一个程序，不仅获取信息，还可以对链序列排序。图3显示了这个咨询台应用的类图。 图3：咨询台类图 在职责链的这个实现中，Client使用一个辅助类（Request）首先发起一个请求，将这个请求发送到第一个具体处理器。Client会以所需的方式设置这个链序列。这里有5个具体处理器类（从Q1到05），调用其中第一个具体处理器之后，这个具体处理器负责其余的工作，可能会处理查询，也可能将请求继续传递到下一个处理器类。 HTML数据输入、客户和请求参与者&lt;/span&gt; 数据输入表单是一个HTML文档，包含5个单选钮，分别对应不同的“帮助”请求。每个单选钮用一个值标识（表示相应的问题），从q1到q5：12 css样式表提供了一种“公司”风格（当然，你可以建立你喜欢的任何样式）。将这个文件保存为help.css：12 这里的想法是提供一种便捷的方法，允许用户选择，另外允许开发人员创建一个请求（将进入一个职责链流）。图4显示了这个用户界面，用户可以在这里选择要咨询的问题。 图4：数据输入用户界面 Client类处理从HTML表单发出的请求。它从一个$POST变量接受请求，将请求保存在一个变量squeryNow中。然后Client实例化链中各个具体响应（处理器）的实例。实例化这些对象变量后，Client再使用setSuccessor()方法为各个具体处理器建立后继。所以，现在就会以序列顺序“加载”这个链：12 一旦实例化具体处理器，并分别指定了一个后继（但链上最后一个具体处理器除外，它没有后继）， Client就可以做出请求了。为了帮助做出请求，Client使用了一个辅助类Request：12 处理器接口和具体处理器&lt;/span&gt; 职责链的接口是一个抽象类。在这个实现中，它包括两个抽象方法，另外还包含多个属性（将由具体处理器使用）：12 这些具体处理器分别提供了方法来处理请求和设置后继。这个例子中，处理请求方法非常简单.handleRequest()方法传递请求（将请求作为参数）。（由Client首先发起请求，启动这个链—就像是点燃导火索。）如果$handle变量与Client通过Request辅助类传递的$request匹配，就会由这个具体处理器来处理这个查询。否则，它会将请求继续传递给链中的后继：12 按照这个职责链的设计，用户只可有5个帮助请求，所以链尾的处理器后继为NULL-也就是说， Client没有为它定义后继。这样可以确保所有请求都有相应的处理器，不会有请求无法得到处理。 自动职责链和工厂方法下面这个例子显示了职责链模式如何与工厂方法模式结合使用。这里不再由一个UI（用户界面）做出请求，职责链使用了一个日期函数作为“请求”。由此可以说明职责链的灵活性。接下来，程序中的具体处理器调用一个工厂方法应用，加载所请求的文本和图像。图5显示了这个应用中两个设计模式之间的关系。 图5：职责链通过工厂方法模式处理请求 实际中，很多开发人员都可能根据应用的需要组合使用多个设计模式。工厂方法模式就经常与其他模式结合使用，以建立产品请求。 这个应用是针对学生每周要完成的一项加分作业设计的，这些学生们在研究全球饥荒情况。首先有一个地图，其中包括城市、河流、海洋和其他标志性地点，另外还要为页面增加一个照片和一个文本说明。学生们要找出正确的国家，明确饥荒情况、文明情况和性别差异，最后返回答案来得到学分。 职责链和日期驱动请求链接到这个应用的地址后，会通过一个index.php文件自动启动Client， Client再把当前日期放在一个变量$queryNow中，这个变量将传递到一个Request辅助类。沿着职责链，查询会查找第一个合适的具体处理器作为工厂方法的客户，由它创建和显示图像和文字素材。 日期函数为什么改变：时间巴别塔如果你用PHP创建过需要在世界范围使用的区分日期的应用，可能会注意到，可能要应用一些奇怪的时区规则（也可能不应用） 。使用PHP 5.4时， 日期对象要求你在php.net/manuallenltimezones.php中查找时区码，把它作为一个字符串直接量放在一个变量中来设置默认时区。例如，Client中使用下面的代码设置请求变量：123$tz = 'America/New_York';date_default_timezone_set（$tz）;$this-&gt;queryNow-getdate(); 这里设置了美国东海岸的时区。有些国家，比如印度，时间与UTC相差半小时。中国西部的喀什与东部的北京相差一个时区，二者距离约3400 km（2100英里）按这个距离，在美国很可能跨4个时区。要把时区从”Europe/Minsk”设置为”Australia/Tasmania” ，需要查看时区标识符（如果你住在印第安纳州，可能会查找8个时间标识符一”America/Indiana/Knox”-以及”America/ndianaIndianapolis” 和”America/Indianapolis” ） 。该学学地理了。 首先，要建立一个自动启动，下面的“触发器”文件会启动Client，并保存为index.php：12 除了由一个日期创建请求外，Client还负责建立后继列表：12 这里相继建立了类D1到D15，它们是对应不同日期的具体处理器。如果第一个处理器（D1）与请求日期不匹配，则会继续查找下一个，直到找到正确的日期。这里的Request类与第一个职责链例子中相同，用作为Client辅助类：12 处理器参与者同样是一个抽象类，作为一个接口。其中包含同样的方法，不过针对日期请求还增加了一些属性：12 接下来，实现请求处理的具体处理器包含有日期范围，用来确定这个具体处理器是否适合完成当前任务：12 通过使用一个布尔变量（$handleNow）和布尔表达式，处理器首先查询shandleNow，如果为true，则指向一个工厂方法，由它加载必要的素材。从这个角度来看，职责链具体处理器（D1到D15）是一个客户，将从工厂方法做出一个请求。图6显示了这两个模式如何协作。 链接点的代码就包含在具体处理器对象（DI到D15）中。请求代码与所有其他客户请求并没有不同：12$this-&gt;hungerFactory = new HungerFactory();echo $this-&gt;hungerFactory-&gt;feedFactory(new C1()); 下一节将分析职责链具体处理器调用的工厂方法设计模式的作用。 工厂方法完成任务工厂方法模式的工作与第5章中的一个例子类似（见图5-6） ，只是稍有区别。请求由具体处理器发出，而不是从”Client”类发出，不过这一点不会带来任何差异。如图6所示，handleRequest()方法相当于一个客户。 Creator和HungerFactory&lt;/span&gt; 标识客户来源之后，第一步构造Creator抽象类，这要作为工厂方法设计的接口：12 factoryMethod()函数和feedFactory()方法使用了类型提示，以确保参数包含Product接口。不过，由于feedFactory()函数不是抽象方法，Creator的所有具体实现都会自动包含这个方法。 正如第5章中看到的，一些工厂方法模式实现会为不同的产品使用不同的工厂（具体创建者）。不过，如果产品类似，具体创建者可以处理任意多个不同的具体产品：123456789&lt;?php// HungerFactory-phpclass HungerFactory extends Creator&#123; private $country; protected function factoryMethod(Product $product) $this-&gt;country=$product return($this-&gt;country-&gt;getProperties());&#125; factoryMethod()实现包含一个参数，以便接收具体产品实例。在具体处理器中（即工厂的客户），这个参数在职责链中确定，并发送到工厂方法。各具体产品将满足通过职责链发送的原始请求 产品和不同国家&lt;/span&gt; 最终结果显示了一个web页面，其中包含一个照片、一个地图和一段简短的文字说明。学生们使用这个应用研究全球饥荒情况，必须找出国家名、婴儿死亡率和不同文化程度的性别差异。 Product接口有一个方法getProperties()，HungerFactory使用这个方法得到所请求的产品。具体的产品类（C1到C15）显示了所需的各个部分：12 集成产品之后，将返回给客户，在这里客户就是职责链中的具体处理器。图7显示了最后得到的产品。 图片和文字部分放在单独的文件夹中。 辅助类、资源和样式&lt;/span&gt; 具体产品对象使用了外部样式表，另外有单独的文件夹提供文本和图片文件，还有一个辅助类来完成格式化。图8显示了整个应用的总布局。 图8：资源 主资源文件夹名为hunger。其中包含文件夹c01到c15，这些文件夹中分别包含3个文件：clue.txt、map.gif和pic.jpg，我们可以改变任何文件的内容，而不用担心破坏程序。不过需要指出一个诀窍，如果图片的大小改变，相应的具体产品大小也必须改变，以与之匹配。 FormatHelper类可以减少创建输出所使用的HTML：12 最后，需要利用外部样式表（products.css）把最终产品集成在一起，以便清楚地表达信息：12 对于所有这些部分，合理的组织至关重要，从长期来看，为这个应用增加新素材以及做出修改都极其容易。 易于更新设计模式最重要的特性是：基于设计模式，开发人员可以顺利地做出改变以及增加新素材，而不会让整个应用像一摞纸牌一样坍塌。一般来讲，开发人员很可能为了达到一些短期目标而选择走捷径，以节省编程时间，但是从长远来看，这种做法有一个严重的后果：最后即使只做简单的修改也必须重构整个程序。 上一节介绍的饥荒应用就是一个很好的例子，对于这样一个应用，重用和改变非常重要。由于这个应用是区分日期的，所以每个学期都需要改变，不过这很容易，因为所有日期查询都在D系列处理器（D1到D15）类中完成，这些处理器都作为职责链模式的一部分。同样，具体产品很容易修改，因为只要图片大小保持不变，所要修改的就只有新图像。名字是不变的（例如，clue.txt、map.gin），而且这样一来，开发人员不必操心程序在给定的文件夹中查找什么。如果增加了新素材，对应新增加的每个素材会增加一个新类，另外对于新增的资源还会增加一个新的文件夹。 出于某种原因，开发人员可能决定职责链采用一种不同的顺序。这很容易，只需要改变原客户的后继，其他所有内容都不用改变。不论如何计划，使用设计模式完成修改都会比尽可能缩减代码要容易得多。有些做法尽管短期奏效，但长期来看可能并不合适。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式的灵活性]]></title>
    <url>%2F2019%2F08%2F23%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 封装算法结合MySQL使用PHP时，要完成的任务之一是需要编写算法来处理对MySQL应用做出的不同类型的请求。一般的请求包括创建表，或者输入、选择、修改和删除数据。对于这些不同的请求，算法可能很简单，也可能很复杂，这取决于请求以及表的复杂性。 设计模式的主要原则之一是封装变化的内容。对于发送到PHP类的不同类型的请求，分别有不同的算法来处理这些MySQL请求，变化的显然是算法。这些变化可能很小，也可能是显著的变化，不过通过使用策略（Strategy）设计模式，我们可以大大简化这个过程。 一般来讲，使用设计模式时，首先要考虑“什么会导致重新设计”？然后要避免那些导致重新设计的因素。不过，有没有一种方法既能做出改变又无需重新设计呢？通过封装那些变化的内容，程序员应首先确定程序中哪些会变化，然后封装这些特性。这样一来，一个设计需要改变时，可以改变封装的元素，而不会影响系统的其余部分。由于不同的MySQL任务需要不同的算法，可以封装这些算法（任务），所以策略设计模式非常适用。 区分策略和状态设计模式首先来看图1，它是策略设计模式的类图。 图1：策略设计模式类图 再回到第10章，看看图1，其中模式参与者的组织与图1中非常相似。在两个设计中，Context参与者都与一个接口有一个聚合关系。在状态模式中，接口为State，在策略模式中则是Strategy接口。除此以外，它们看起来是一样的。 要了解二者的差别，需要了解两个Context参与者与Strategy和State接口及其具体实现的关系有什么不同。表1对这些差别做了一个总结。 表1：状态和策略设计模式中上下文和变化的差别 模式 什么会变化？ 上下文 状态 状态 维护子类当前状态的一个实例（定义了当前状态） 策略 算法 配置为具体策略对象，这是一个封装的算法。 在第10章可以看到， Context包含一个变量，保存了当前的具体状态。这个具体状态提供了一些方法，可以从Context变量中记录的当前状态变迁到另一个状态。 不过，策略模式中的Context参与者并没有记录当前使用的策略。它没有理由这么做，这是因为，与不断改变的状态不同，一般来讲，改变的算法并不依赖于当前正在使用的算法。显然，有些情况下，执行一个算法之前可能首先要使用另一个算法，如试图访问一个表中的数据之前，需要先在表中插入数据。不过，这并不妨碍使用算法尝试从一个空表获取数据。但在状态模式中很容易出现这样一种情况：即一个状态只能进入某些状态，而不能转移到另外一些状态。在第10章中的三路灯泡例子中，如果灯泡处于第二个on状态，就不能进入第一个on状态，也不能进入off状态。它只能转移到第3个on状态。（见第10章中的图5）大多数算法都不是这样。 请不要加条件语句状态和策略设计模式有很多共同的特性，其中之一是Context参与者要避免使用条件语句。如果查看第10章中的例子，你会注意到，这些例子都没有条件语句。第10章的“何时使用状态模式？ ”一节中提供了一些伪代码，指出使用条件语句从一个单元格到下一个单元格难度很大。（不过不用担心，要在一组已有的状态中增加新状态，或者要改变已有的状态，这些都很容易！） 设计模式并不是要求永远不要使用条件或case语句，不过在一些模式中（如状态和策略设计模式），使用条件语句可能会导致维护相当困难。如果要改变一个策略（封装的算法），而且需要改变一大堆条件或case语句，那么引入错误的可能性会更大。另外需要说明，使用这两个模式时，客户参与者中引入条件或case语句是可以接受的，因为客户所要做的就是做出请求。另外，在封装的算法中（具体策略），完成某个任务可能需要一个条件或case语句。类似地，在使用mysqli实现数据输出和错误检查时，往往都会有条件语句。利用策略，不再需要条件语句来选择所需的行为。不同的任务由不同的具体策略来处理，因为客户通过上下文请求具体策略，它必须知道有哪些可用的策略。这并不是说客户选择过程中不能使用条件语句，而是说条件语句不是上下文的一部分。 算法族GoF的《设计模式》中，有些元素的介绍不太详细，其中就包括“算法族”（family of algorithms）的概念。开发人员需要定义一个算法族，但GoF并没有指定设计模式上下文中“族”（family）一词的确切含义。不过，在《Head First Design Patterns》一书中，提出了一个很简单但很有用的概念——行为集（a set of behaviors）。任何依赖于一组特定行为的项目都可以转换为一种策略设计模式，将那些行为封装为策略。也就是说，需要某种算法才能实现这些行为。通过将它们封装为具体的策略，就能使用、重用和完成修改。 这一章中的“族”由使用MySQL表通常所需的行为组成。一般需要输入、修改、获取和删除数据。这些涉及数据操作的行为就构成了一个“族” ，每个族成员可以转换为一个策略。实现这些策略需要不同的算法，还要结合使用MySQL命令和PHP mysqli类。把这些操作放在不同的具体类中（所有具体类实现一个公共接口） ，就成为了策略设计模式的一部分。 最简单的策略模式为了查看使用MySQL连接的一般模式，第一个例子中并没有使用表，而是建立了一个一般模式，以便以后加入各个策略中的细节。由于HTML表单不能把选择的参数传递给PHP类或文件，这个例子会使用多个短小的PHP触发器脚本。这些触发器脚本调用客户的不同方法，客户再通过上下文调用所请求的具体策略。 图2显示了这个实现的文件图。对于每个策略，HTML文件中分别包含相应的表单，表单数据通过一个PHP触发器脚本传递到Client中的方法。Client再通过Context进一步将请求传递到一个具体策略。连接辅助类包括一个接口和类，可以用来连接一个MySQL数据库。 有些开发人员在处理MySQL数据库方面有着丰富的经验，对他们来说，图2看起来可能有些“过度设计”。不过，设计模式的目的是为了便于修改和重用对象。每个具体策略会得到封装，因此只要保持所实现的接口不变，对具体策略的任何修改都不会破坏系统。即使从这个最小策略的角度来看，也很容易看出具体策略中的行为是开放的，允许各种不同的实现。 客户和触发器脚本Client类通过Context做出请求，来创建一个具体策略。这里利用了一组方法来完成对不同策略的请求。请求的关键是下面这两行代码：12$context = new Context(new ConcreteStrategy());$context-&gt;algorithm(); 每个Client方法提供了要实现的具体策略的名，algorithm()是具体策略中实现的一个Context方法。这个过程可以展示多态（polymorphism）是如何工作的。Client通过一个Context实例发出请求，来请求具体方法的算法，所以所有算法请求看起来都很像，都是$context-&gt;algorithm()。不过， Client要实例化Context，并提供一个具体策略作为参数。通过实现具体策略的algorithm()方法，这个参数允许Context使用所请求的具体策略。这样一来，通过采用策略模式，算法就可以独立变化，而不影响使用该算法的客户。在下面的例子中，没有使用多个不同的Client类，而是利用多个不同的触发器脚本来使用相同的客户： 为了触发不同具体策略（封装的算法）的方法，HTML会调用以下的一个PHP触发器脚本：12 HTML文档中的表单分别调用各个不同的PHP触发器。触发器脚本发出的请求传递到客户，客户再针对各个请求使用相应的一个方法。在策略设计模式中，客户通常会创建一个具体对象并传递到上下文。不过，最初的请求是由HTML文档发出：12 在这个设计中，比较困难的一点是要保护$_POST数据，为此可以使用mysqli-&gt;realescape-string()方法抽取由HTML文档发送的数据值。可以在提交的所有数据中包含-个额外的变量，指示客户将要使用一个具体策略请求方法，这样就能做出选择而无需使用大量触发器脚本。可以在客户中建立MySQL连接，取出数据、关闭连接，然后把请求继续传递到具体策略，在这里打开第二个连接，通过适当的策略处理这个请求。不过，这个例子的重点是设计模式，而不是解决所有安全问题。所以这里分别提供不同的触发器脚本来完成各个请求。 Context类和Strategy接口在状态模式设计中，Context类相当于一个“跟踪者”（track keeper），它会跟踪当前的状态。在策略模式设计中， Context则有完全不同的功能，用于将请求与具体策略分离，使策略和请求可以独立地工作。这体现了请求与后果之间的另外一种松绑定。与此同时，它还有利于从Client发出请求。 Context不是一个接口（既不是抽象类也不是接口），不过它与Strategy接口有聚合关系。“四人帮”指定了以下特征： 用一个具体策略对象来配置（参见“客户与触发器脚本”一节中Client类如何实例化Context） 维护Strategy对象的一个引用 可以定义一个接口，允许strategy访问其数据。 在下面的代码清单中，可以看到ConText类的上述特征：12 对于以上的3个特性，第一，构造函数希望有一个Istrategy实现作为参数。第二，通过-个封装的属性$strategy（可见性为私有）来维护strategy对象的一个引用。$strategy属性从构造函数参数接收strategy对象实例，这将成为一个具体策略实例。第三，algorithm()方法实现了Istrategy的algorithm()方法，实现为通过Client选择的具体策略。由于Context和Istrategy构成一个聚合关系，所以Context具有抽象类或接口的某些特性。实际上，最好通过聚合来理解Context。查看策略接口Istrategy时，可以看到要实现的方法是algorithm()：12345&lt;?phpinterface IStrategy&#123; public function algorithm();&#125; 各个具体策略可以采用所需的方式实现这个方法。 具体策略构成具体策略的封装算法族提供了所有可能的策略。对于这个最简单的例子，关键是要了解策略设计模式中不同的参与者如何协同工作。在这一节中，你会看到一个完全实现的例子。 5个具体策略包括以下类： DataEntry DisplayData SearchData UpdateData DeleteData 这些具体策略分别表示结合使用PHP和MySQL的典型算法。 DataEntry 第一个策略表示向一个表中输入数据：12 DisplayData 在这个例子中并没有使用$_POST[‘data’]，因为这个算法只显示字符串”Here’s all thedata!”，它作为一个字符串直接量赋给变量$test：12 SearchData 搜索项在$_POST[‘data’]中，将传递到$test变量：12 UpdateData “新”数据在$_PoST[‘data’]中，并传递到$test变量。在实际的实现中，还可能包含字段名： DeleteRecord 最后，会有一个唯一标识符传入$-POST[‘data’]并存储在stest中，通过使用这个唯一标识符，可以从表中删除一个记录：12 连接接口和类 所有具体策略都实现相同的连接对象（与其他章中一样）。下面的接口包含了实际程序使用的名：12 通过使用一个连接类和单独的接口，可以更容易地重用和修改。这里只会修改接口中的常量值。 增加数据安全性和参数化算法来扩展策略模式在上一节给出的最简单的例子中，可以看到结合使用MySQL数据库时PHP策略设计模式的所有基本元素。为了构建一个更健壮的例子，下面这个例子会为不同策略增加功能。这里还增加了一个辅助类，来处理数据从HTML客户到MySQL数据库的安全移动。这说明，客户可以使用通过mysqli-&gt;real_escapestring($_POST[‘data’])函数传递的数据做出安全的请求。Client类可以自己处理安全性，不过这样一来，除了做出请求外，会为Client类增加额外的责任。 数据安全性辅助类通过使用mysqli-&gt;real_escape_string($_POST[‘data’])函数，在HTML表单和PHP类之间安全地传递数据，需要有一个MySQL连接，不过一旦打开连接并安全地传递了数据，可以再关闭这个连接，释放连接占用的资源。 考虑到会有不同的具体策略，这个辅助类对于保证各个具体策略的数据安全性分别提供了不同的方法。一个方法是向Client传回一个数组，其中包含该请求所需的数据。图3通过图示表示了辅助类与Strategy的关系。 图3：增加一个辅助类处理数据安全性 图3中没有显示策略模式中Context类后面的部分，不过它仍然遵循图1所示的标准类图。另外，前面使用了MySQL辅助类处理数据库请求，SecureData类同样使用这个辅助类来创建MySQL连接。 对于每一个依赖于HTML表单数据的具体策略， SecureData类中分别提供了相应的方法。DisplayA11具体策略请求显示所有数据，所以它不需要由HTML表单传递的特殊数据：12 除了setEntry()之外，所有方法都生成一个名为dataPack的数组。setEntry()方法会返回这个dataPack数组的当前内容。取决于具体的请求， SecureData类生成将置于数组中的值，这会传回到Client，并通过algorithm()方法作为请求的一部分发送到一个具体策略。 为算法方法增加参数第二个要增加的特性是修改Strategy算法方法。我们将增加一个数组作为函数的一个参数，这样可以增加灵活性，处理更多的内容。每个算法函数调用都包含一个数组，其中包含从HTML表单传递的数据：123456&lt;?phpinterface IStrategy&#123; const TABLENOW ="survey"; public function algorithm(Array $dataPack);&#125; 同样，还要为接口增加一个常量TABLENON，由于这个实现中各个具体策略都使用相同的表，而且PHP能够通过接口传递常量，因此可以建立一个松耦合而且可重用的代码。显然，如果不同的具体策略要使用不同的表，就必须在各个具体策略中指定表引用。参数中的类型提示指示要将数组用作为一个实参。 调查表下面的脚本用于创建一个调查表（数据库表） 。策略设计模式中可以使用更大或更小的表，为此只需要调整具体策略中所用数组的大小：12 这个特定的类用于创建数据库表，仅在开发和调试阶段使用。一旦建立了所要的表，而且希望安装在不同的系统上，可以删除下面这段代码：123456$drop = "DROP TABLE IF EXISTS sthis-tableMaster";if(sthis-&gt;hookup-&gt;query($drop) = true)&#123; printf("Old table %s has been dropped.&lt;br/&gt;"，$this-&gt;tableMaster);&#125; 并将以下代码：1$sql = "CREATE TABLE Sthis-tableMaster （ 修改为：1$sql= "CREATE TABLE IF NOT EXISTS sthis-&gt;tableMaster （ 这样一来，如果原来的表中已经存储有数据，就不会被CreateTable类删除。本章中所有其他的MySQL连接都会使用同样的UniversalConnect类。 数据输入模块利用SecureData辅助类和修改后的IStrategy接口（可以为algorithm()方法包含一个参数），对于不同的HTML表单请求，Client可以根据相应的方法更容易地做出请求。在继续学习下面的内容之前，先来看看HTML表单中发出的请求。这里使用了两个表单：一个允许用户输入调查数据，另一个用于查看存储在MySQL表中的数据。两个表单都非常简单，是很通用的HTML表单。两个表单使用同一个CSS文件：12 CSS只是用来稍做区分。 首先，调查表单只有一个简单的文本输入，另外可以利用单选钮做一些选择：12 图4显示了在一个平板设备上打开的调查表单。 第二个HTML文档提供了一个管理工具，可以用来检查数据库中的表。同样的，这个HTML表单也很简单，通过策略设计模式将数据从其来源（数据库表）放入HTML表单中：12 这两个用户界面（UI）都使用了移动布局，只有一列，可以调整这个布局以便在支持互联网功能的移动手机上查看。 两个HTML文档中的按钮分别表示不同的表单。每个表单调用一个触发器文件，再实例化Client类，并调用所需的方法来完成所请求的任务。 客户请求帮助Client没有构造函数，不过有多个方法，可以做不同的请求。这些方法与最简单的例子类似，不过在前面讨论的SecureData辅助类（见“数据安全性辅助类”一节）的帮助下，这些方法可以做更多工作。 首先请回顾SecureData类的工作，然后再来分析Client：12 除了showAll()方法外，Client中的所有方法都会首先实例化SecureData类、然后使用具体方法作为参数来创建一个上下文对象。接下来，SecureData对象调用具体策略的相应方法创建所需的数组。最后Client方法调用Context-&gt;algorithm（），并使用SecureData类返回$secure-&gt;setEntry（）数组作为参数。数组的内容取决于HTML表单发送的用户输入以及所请求的策略类型。 “四人帮”指出，不论是否使用，所有具体策略类都有一个共同的接口。因此，所有具体策略类都必须实现Strategy接口的方法（Istrategy中的algorithm()方法）。不过，并不是所有具体策略都需要这个算法，当然实现方式也不完全相同。 可以看到，从某种程度上讲，Client类中的showAll()方法就不需要这个算法。这个方法没有使用SecureData类返回的一个数组，而是创建了一个dummy数组，并把它用作为Context-&gt;algorithm()的参数。这是为了满足IStrategy接口的需求，接口要求这个方法必须包含一个数组作为参数。 Context类重要的小改变与这一章第一部分中最简单的例子相比，Context类几乎没有改动，只是为algorithm()方法增加了一个参数，这是更新后的Istrategy接口提出的要求。由于context类和IStrategy之间有一种聚合关系，Context类必须包含Istrategy的一个引用。类似于前面最简单的例子，同样要用一个具体策略对象创建Context，这一部分未做任何改变。不过，它还包含一个方法，将实例化具体策略的algorithm()方法实现：12 注意：Context类方法的名字也是”algorithm” ，它要求有一个数组参数。两个方法都命名为algorithm，其目的是为了强调上下文和策略参与者之间的聚合关系。如果觉得有些混淆，可以把这个方法重命名为contextAlgorithm，使它与IStrategy的algorithm()方法有所区别。 Context还有另外一个属性$dataPack，反映了通过Context algorithm()方法传递的数组的名字。然后再传递到具体策略的algorithm()方法。 具体策略通过一个数组向具体策略传递数据的根本目的是允许不同的策略对不同的请求做出响应。这样可以为设计提供灵活性，因为利用数组可以传递大量数据。在下面的具体策略类中可以看到，每个策略类都实现了IStrategy algorithm()方法，其中使用了通过方法数组参数传递的数据。 最简单的策略例子中使用了一个UniversalConnect类，这里的所有具体类同样使用了这个类。表名作为一个常量（TABLENOw）存储在IStrategy接口中。 DataEntry 在所有具体策略中，DataEntry类使用的数组最大。这是因为它必须插入HTML调查表提交的所有数据：12 这里只是标准MySQL语句中使用了条件语句。作为这个类的核心，通用算法没有使用任何条件语句。 DisplayAll将为这个类传递一个dummy数组。可以看到，它只是使用一个通用算法从数据库表向屏幕发送数据：12 表格可以更好地显示数据，不过它可不是最优的实现。实际上，由于我们的重点是实现设计模式，所以这个格式要尽可能简单。图6显示了这个输出。 SearchData 搜索算法将从一个指定字段选择一个指定值。字段名和搜索值通过数组作为一个参数传入algorithm（）方法。如果匹配，则会显示匹配的记录，如果没有找到匹配，就不显示任何结果：12 也可以替换一个更精巧的算法和显示设计，这很容易。如果需要更多数据，可以修改HTML文档中生成的数据，并把它们放在SecureData类中的一个数组中，这很简单，很容易做到，而且不会影响程序的任何其他组件，对于所有设计模式来说，这都是必不可少的一个要素。图7显示了在Designer/Developer字段中搜索”designer”的结果。 图7：输出显示”designer”的所有匹配结果 UpdateData 要改变当前字段中的值，这个实现只需要三个要素：字段名、原来的值和新值。这个算法很灵活，与所有其他具体策略一样，可以修改算法来反映具体的需求：12 这个输出通知用户已经完成了一个修改。 DeleteRecord 最后一个具体策略将删除一条记录，为此只需要数组中的一个元素来传递要删除的记录号。由于创建表时采用的是一种自动编号机制，标识号是一个整数：12 这个类和相应的具体策略很简单，如果想增加一个更健壮的算法，也很容易做到，而不会破坏程序的其余部分。 灵活的策略模式策略模式很灵活，改变算法时可以只改变一个实现，不仅如此，模式本身还可以有多个实现。一方面，这一章展示了一个最简单的策略设计模式，它可以调用不同的算法，这些算法独立于具体策略之外的数据;另一方面，第二个例子使用了参数，可以向具体策略传递安全的数据。 “四人帮”指出，一种做法是由Context通过参数向Strategy操作传递数据。这正是第二个例子采用的做法。这种方法可以得到提交给策略的数据，同时保证Context与Strategy解耦合，但也可能向Strategy传递它不需要的数据。对于这个问题，可以使用一个数组来解决，利用这个数组（这也包括一个空数组），为Strategy传递数据时会有更大的灵活性。 特定的策略模式实现依赖于特定算法的需求以及它具体需要些什么。一些策略模式实现会存储其上下文的一个引用，因此没有必要传递数据。不过，这样一来， Context和Strategy会更紧密地耦合。 还有一个问题需要考虑：即策略模式所生成的对象（具体策略）个数。在这一章的例子中可以看到，它们都构建了大量的对象（类）来处理一个简单MysQL调查（由PHP驱动）的不同请求。还有可能构建更多对象。不过，相对于重用性以及改变模式所带来的好处，这可能不算太大的问题。构建设计模式是为了提高管理一个应用的速度，而不是为了提高执行代码的速度。如果采用了良构的策略模式，开发人员可以很容易地优化和重新优化封装的算法，而不会搞得一团乱麻。所以速度表现在重用和修改时间上，而且额外对象的开销很小。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 什么是模板方法模式首先，要区别两个概念，模板方法（Template Method）设计模式中使用了一个类方法templateMethod()，要知道这二者是不同的。templateMethod()是抽象类中的一个具体方法。这个方法的作用是对抽象方法序列排序，具体实现留给具体类来完成。关键在于，模板方法模式定义了操作中算法的“骨架”，而由具体类来实现。 关于模板方法模式，值得高兴的是它相当简短，实现很容易。只需要一个抽象类和一个具体类，如图1所示。 图1：模板方法类图 可以把抽象类中的模板方法操作看做是“基本操作的组织者”。后面提到模板方法设计模式时，我会将首字母大写（Template Method），谈到模板方法操作时，则会用小写（template method operation）。就像考虑婚礼司仪，她要按某种顺序安排仪式中的一系列事件（操作），包括宴会、切蛋糕、第一支舞、发表感言以及仪式中可能的所有事件。婚礼司仪会遵循一个模板，按一种给定的顺序合理地组织事件，不过她会让新娘的家人具体决定希望如何执行这些事件。例如，宴会可能是一个正式宴会，也可以是一个户外的烧烤晚会，舞蹈可能选择华尔兹也可能是街舞（hip-hop），乐队可以是整个乐团，也可以只请一位手风琴师。事件发生的顺序都是一样的，不过它们的实现有所不同。 何时使用模板方法如果已经明确算法中的一些步骤，不过这些步骤可以采用多种不同的方法实现，就可以使用模板方法模式。“四人帮”指出，如果算法中的步骤不变，可以把这些步骤留给子类具体实现。在这种情况下，可以使用这种设计模式来组织抽象类中的基本操作（函数/方法）。然后由子类实现应用所需的这些操作。 还有一种用法稍微复杂一些，可能需要把子类共同的行为放在一个类中，以避免代码重复。“四人帮”援引了Opdyke和Johnson的“重构为一般性”（refactoring togeneralize），以此描述将重复的代码组织到模板方法模式中的过程。如果使用多个类来解决同一个大型问题，可能很快就会出现重复代码。 最后一点，还可以使用模板方法模式控制子类扩展。这里涉及一个“钩子”操作，将在“模板方法设计模式中的钩子”一节中讨论。可以利用“钩子”控制扩展：只在钩子操作所在的某些位置允许扩展。 最简单的例子：对图像和图题使用模板方法模式在PHP编程中，可能经常会遇到一个问题：要建立带图题的图像。这个算法相当简单，无非是显示图像，然后在图像下面显示文本。 由于模板方法设计中只涉及两个参与者，所以这是最容易理解的模式之一，同时也非常有用。抽象类建立templateMethod()（具体的方法），并由具体类实现这个方法。 抽象类抽象类是这里的关键，因为它同时包含具体和抽象方法。模板方法（这里是指方法本身）往往是具体方法，其操作是抽象的。 要加载一个图片，只需要一个操作使用HTML包装器调用图像URL，要得到文本作为图题并把它放在图像下面，这个操作也同样很简单。 两个抽象方法分别是addPix($pix)和addCaption($cap)。这两个操作都包含一个参数，分别表示图像的URL信息和图题字符串。templateMethod()函数中设置了这两个属性，属性可见性为保护（protected），以提供封装：12 在模板方法函数中增加这两个参数，以便接收实参，再将接收到的实参进一步传递到保护属性。 具体类要使用模板方法的具体类扩展这个抽象类，并实现基本操作addPix()和addCaption()。算法要求提供相应的代码，可以用来显示图像和适当的图题：12 这里并没有返回一个对象，而是由这两个操作使用echo语句将结果发送到屏幕。这样做是为了尽可能简化这个例子。现在客户可以使用addPix()和addCaption()方法了。 客户“四人帮”讨论这种设计模式时并没有提到客户，不过类似于客户作为其他设计模式中的一部分，在这里客户就相当于UI连接的基础。所以，可能需要模板方法模式的任何上下文中，都可以考虑这样一个简单的Client类：12 注意，$mo变量实例化了ConcretecClass，但是它调用templateMethod()，这是从父类继承的一个具体操作。父类（AbstractClass）通过templateMethod()调用子类的操作。图2显示了相应的输出。 图2：模板方法建立的图片-图题序列 实际上，客户只需要提供图像URL和图题文本串。 好莱坞原则“反向控制结构”概念另外也称为“好莱坞原则”（the Hollywood Principle）。这个原则是指父类调用子类的操作，而子类不调用父类的操作。（就像试镜之后，导演告诉年轻的演员，“如果你拿到这个角色，我们会通知你。不要打电话来询问；我们会打电话给你的”。正因如此，这种反向控制结构被称为好莱坞原则。） 与好莱坞原则关联最紧密的模式就是模板方法模式，因为它在父类中实现。除了templateMethod()，父类中的其他操作（方法）都是抽象和保护方法。所以，尽管客户实例化一个具体类，但它调用了父类中实现的方法。图3可以帮助你更清楚地理解这种反向控制结构。 图3：好莱坞原则 不过，我们真正想问的是：为什么好莱坞原则对于OOP和设计模式很重要？从某些方面来讲，这个问题和答案的关键在于与顺序和过程编程思维划定界限。在过程编程中，关键问题是控制流（flow of control），在OOP中，关键问题则是对象职责（object responsibility）。由于过程编程的重点在于控制流，一些解释会使用“控制反向”（inversion of control）来解释好莱坞原则。控制反向从过程编程的角度来讲很有意义，不过在OOP中，大多数控制流都会通过对象职责和协作抽取出来。也就是说，并不是考虑控制流，而应考虑哪些对象将处理某些职责，另外对象如何协作来完成任务。 要在OOP上下文中准确地理解好莱坞原则，最简单的方法就是从框架以及框架中可能的改变来考虑[这里我使用“框架”（framework）这个词来表示程序中的小结构，而不是第3章中与设计模式相区别的那些更大的结构]。模板方法定义了框架，子类可以扩展或重新实现算法的可变部分，不过它们不能改变模板方法的控制流。从子类发出“调用”是重新实现父类的方法，这是好莱坞原则不允许的一种“调用”。只有父类可以做出“调用”来建立或改变框架（操作的执行顺序）。 要理解好菜坞原则，更好的办法可能是按幼儿园里老师和学生之间的关系来考虑，也就是幼儿园原则（Kindergarten Principle）。老师建立一些项目，让孩子们按某种顺序完成，比如数数、认时间，背单词。老师设定好顺序，但是孩子们具体如何完成或者如何实现则由孩子们自己决定。不过，孩子们不能改变老师定好的这个顺序。换句话说，孩子在数数练习中间不能说“我现在想背单词”。这个结构是有序的： 1.数数2.认时间3.背单词 老师说，“抱歉，Elmo，我们现在要数数。过一会再背单词吧”。对孩子们来说，这个顺序是不可变的。所以只能由老师来掌控，没有其他可能。在这种情况下，控制反向是不合适的：由父类建立顺序，子类按自己特有的方式完成这些操作。直观看来这并不是“反向”。所以，如果讨论好莱坞原则时谈到控制反向，要记住这个“反向”只在过程编程的控制流上下文中才有意义。 结合其他设计模式使用模板方法模式设计模式并不是孤立存在的，它们存在于编码对象的大环境中，其中一些对象可能是其他设计模式。为了说明这一点，下面结合工厂方法模式来实现第一个例子，我们可以得到相同的结果，即显示一个有图题的图片。由于这个例子只使用了一个图像和图题，看起来有点像高射炮打蚊子——大材小用了，不过，关键是要知道这两个设计模式如何合作。如果你理解了模式之间的交互，就能结合使用更多的模式。模板方法模式将建立算法的顺序，以给定的顺序来显示图像和图题，工厂方法模式则具体创建对象。图4给出了相应的文件图，两个不同模式分别用灰边框区分。 图4：有关联关系的模板方法和工厂方法文件图 结合使用这两个模式是因为它们分别承担不同的角色。模板方法模式建立算法的顺序（首先是图像，然后是图题），工厂方法模式则创建图像和图题。看到这个，你可能认为客户不得不做出请求；不过，情况正好相反。 客户工作负担减轻客户的请求会通过模板方法模式做出。模板方法模式负责组织操作，从而能按适当的顺序自动地传递请求：12 在这里，Client类主要是错误检查和加载必要的类。只有两行代码与请求有关：12$mo = new TmFac();$mo-&gt;templateMethod(); 连接两个不同的设计模式之后，Client的工作居然会减少，这看起来有些讽刺，不过利用模式很容易做到。模板方法模式将建立算法的顺序，这些算法再调用工厂来创建图像和图题。所以，Client所请求的只是将接收请求的方法。 模板方法参与者与之前最简单的例子相比，创建模板方法模式的两个类稍有改变。在某些方面， TmFac类相当于一个客户，因为它会向工厂方法模式中的工厂发出请求：12 templateMethod()操作指定TmFac类中方法的顺序，调用templateMethod()后会按指定的顺序来调用工厂。 工厂方法参与者Client类与工厂方法模式之间没有任何通信。最初的请求由模板方法操作传递，不过它们没有留下任何“足迹”（暂且这么说）。工厂方法参与者所响应的是来自TmFac对象的请求：12 图5与图2几乎完全相同，只是图题的样式不同。从templateMethod()向工厂做出请求后，由工厂实现的产品会生成图题的样式。 图5：按照templateMethod()中的步骤生成的图像和图题 图5的重点是，由于设计模式力求所有参与者（类和相应的对象）松耦合但相互连接，所以程序很灵活，完全可以通过所有类和接口来返回图像和图题。对于一个简单的图像和图题，可能注意不到这个好处。不过，对于更复杂的算法，如果有更多的步骤，模板方法模式可以提供一个可重用的顺序来组织职责集。产品以及产品中的变化都将通过同样的接口来处理。 模板方法设计模式中的钩子有时模板方法函数中可能有一个你不想要的步骤，某些特定情况下你可能不希望执行这个步骤。例如，假设有一个模板方法，可以累加一个订单的总费用，另外加上税和运费，然后显示交易总金额。不过，顾客告诉你，如果买家购买需要送货的商品超过200美元，可以免运费。这里就可以用到模板方法钩子。 在模板方法设计模式中，利用钩子可以将一个方法作为模板方法的一部分，不过不一定会用到这个方法。换句话说，它是方法的一部分，不过它包含一个钩子，可以处理例外情况。子类可以为算法增加一个可选元素，这样一来，尽管仍按模板方法建立的顺序执行，但有可能并不完成模板方法期望的动作。对于上面这种运费可选的情况，钩子就是解决这个问题最理想的工具。 你可能认为，这与好莱坞原则有冲突（子类没有遵循父类设置的顺序），这样想也没错。好莱坞原则要求只有父类能够改变框架。钩子很特殊，因为尽管它实现了模板方法中的方法，但实现的方法有一个“后门”，也就是说，它会处理例外情况。 要了解钩子是如何工作的，来看一个简单的例子。一家公司销售GPS设备和地图，为顾客沿赞比西河徒步旅行提供帮助。它还提供租船业务。公司老板决定，如果买家购买的需要送货的商品超过200美元，可以免收运费。不过，这不包括租船的费用。所以，他需要这样一个程序，可以累加送货商品的费用，确定是否增加运费，然后加上租船的费用，最后显示总金额。图6显示了这个程序的用户界面。 UI HTML代码使用了一个表单，以便数据输入，表单中使用了单选钮和复选框。单选钮和复选框都有一个值，分别表示产品或服务的价格。下面的HTML代码清单中包括一个HTML数组，用来提供地图选择：12 一旦用户单击“Send order”（发送订单）按钮，PHP Client类就会启动。不过，先来看这里采用的模板方法模式。 建立钩子在模板方法接口中建立钩子方法看起来很有意思，尽管子类可以改变钩子的行为，但仍然要遵循模板方法中定义的顺序：12 这里有3个抽象方法——addTax()、addShippingHook()和displayCost()，抽象类IHook实现的templateMethod()中确定了它们的顺序。在这里，钩子方法放在中间，实际上模板方法指定的顺序中，钩子可以放在任意位置。模板方法需要两个参数：一个是总花费，另外还需要一个变量用来确定顾客是否免收运费。这些值必须由Client类提供，Client类则从HTML文档接收原始数据。 实现钩子一旦抽象类中建立了这些抽象方法，并指定了它们执行的顺序，子类将实现所有这3个方法：12 addTax()和displayCost()方法都是标准方法，只有一个实现。不过，addShippingHook()的实现有所不同，其中有一个条件来确定是否增加运费。这就是钩子。 客户以及捕获钩子由于可以使用二进制字符，开发人员通常会忽视布尔变量的重要性。不过，实际上处理布尔变量很简洁，速度也很快，我发现它们对于捕获钩子尤其适合。在所有钩子操作中，必须有人警告控制流：将有不同的情况发生，而不是正常地执行模板方法中指定的那些默认操作。 用比较操作符设置布尔值 不必使用条件语句来建立一个布尔状态，使用比较操作符会更容易，也更简洁。客户中包含以下代码行，可以为前面的模板方法例子中的钩子设置布尔值。1$this-&gt;special = （$this-&gt;buyTotal &gt;= 200）; 这会为布尔变量$this-&gt;special赋一个状态true或false，Zambezi Trading Post为货运商品超过200美元的所有订单提供了免收运费的特殊优惠。 接下来看Client类，可以看到模板方法设计模式中的请求如何访问钩子。 Client类 Client类根据从HTML表单接收的数据做出一个请求。它必须将租船的费用与购买设备的费用区分开，只根据设备购买费用来计算特殊折扣。将special设置为true或false后，再累加总金额，还要加上税费。由于变量$special是一个布尔变量，不会把它增加到总金额。实际上，$special会作为一个参数传递到templateMethod()方法：12 首先，利用从单选钮传入$gpsNow变量的值来确定设备的总费用，然后通过一个循环将所有传入复选框数组（$mapNow）的值累加起来，如上一节所述，此时已经建立了布尔变量$special；最后，加上通过一个单选钮传入的$boatNow值。设置$special之后，程序将$boatNow值与$buyTotal值相加。现在可以把这两个变量中的值发送到主程序，主程序将在$templateMethod()参数中使用这两个值。 这个例子很简单，用户的数据输入也很容易，最重要的是，只需要重写Client，就可以很容易地重用这个设计。换句话说，这个设计是可改变而且可重用的。这个例子中使用直接量来表示运费和税费，不过，它们同样也可以修改为不同的值取代直接量。完全可以用客户传入的值，甚至可以使用可计算的费用，而不是直接量。 短小精悍的模板方法模式学习设计模式很不容易，并不适合那些心存畏惧的人，不过模板方法模式不仅很简单，还有很多经验可以借鉴。首先，要解释好莱坞原则，采用模板方法模式是最适合的。这个原则中的“调用”概念实际上是指“遵循某个顺序”。父类（抽象类）建立操作，并设置它们的顺序，而子类具体实现这些操作。“不要打电话来询问，我们会打电话给你的”可以改写为：“我们会建立面试、试镜和才艺测试；你要按我们建立的顺序完成这些测试，但是可以采用你喜欢的任何方式。只是不要改变这个顺序！” 模板方法模式还有一个重要的方面，要记住这是一个设计模式，可以与其他设计模式结合使用。你已经看到，它能与工厂方法模式很好地合作，同样地，这个模式还能与抽象工厂模式协作（而且这样更有帮助）。模板方法模式很简短，所以可以作为其他模式的一部分，也可以作为一个辅助类在很多其他模式中使用。 关于模板方法模式，最好的一点是它很容易学习，而且有重要的经验可以借鉴。不错，模板方法模式有很多应用，这也很重要，不过概念和思想才是设计模式中最重要的部分。作为一个很容易掌握和学习的模式，尽管它很短小，但确实很有意义。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式1]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 什么是装饰器模式作为一种结构型模式，装饰器（Decorator）模式就是对一个已有的结构增加“装饰”。对于适配器模式，为现有结构增加的是一个适配器类，用来处理不兼容的接口。装饰器模式会向现有对象增加对象。装饰器也称为包装器（类似于适配器），Decorator参与者用具体组件包装Component参与者。图1显示了这个类图，不过在详细介绍这个类图之前，需要先考虑几个细节问题。 图1：装饰器类图[隐含Client] 首先，有些设计模式包含一个抽象类，而且该抽象类还继承了另一个抽象类，这种设计模式为数不多，而装饰器模式就是其中之一。从图1可以看到，通过一个环状聚合将Decorator连接到Component参与者。（“四人帮”给出的类图中使用的是直线，与直线相比，这里的环线看起来更像“包装”。）可以称为Decorator装饰器“包装”了Component。 这个设计既要创建要装饰的组件，还要创建装饰器。可以把Component参与者想成是一个要装修的空房间，要配上家具和地毯——家具和地毯就是具体装饰器。还要注意，所有参与者通过Component共享一个公共的接口。 这个图中包含有Client，不过它实际上并不是这个模式的一部分——甚至连隐含包含都不算是。基于这种松耦合，可以直接请求任何具体组件或装饰器。不过，使用装饰器模式时，Cient包含有Component接口的一个引用。 何时使用装饰器模式“四人帮”指出了使用装饰器的一般原则。基本说来，如果想为现有对象增加新功能而不想影响其他对象，就可以使用装饰器模式。如果你好不容易为客户创建了一个网站格式，主要组件的工作都很完美，客户请求新功能时，你肯定不希望推翻重来，再重新创建网站。例如，假设你已经构建了客户原先请求的所有组件，之后客户又有了新的需求，希望在网站中包含视频功能。你不用重写原先的组件，只需要“装饰”现有组件，为它们增加视频功能。这样一来，既可以保持原来的功能，还可以增加新功能。 有些项目可能有时需要装饰，而有时不希望装饰，这些项目体现了装饰器设计模式的另一个重要特性。假设你的基本网站开发模型可以满足大多数客户的要求。不过，有些客户还希望有一些特定的功能来满足他们的特殊需求。并不是所有人都希望或需要这些额外的功能。作为开发人员，你希望你创建的网站能满足客户的业务目标，所以需要提供“本地化”（customerization）特性，即针对特定业务提供的特性。利用装饰器模式，不仅能提供核心功能，还可以用客户要求的特有功能“装饰”这些核心功能。 由于Web和互联网日新月异（其范围更是飞速扩张），装饰器模式可能是你的开发工具包中的一个宝贵财富。使用装饰器模式就相当于你可以吃到蛋糕，或者至少可以装饰一些“糖霜”。 最简单的装饰器例子第一个例子先考虑最简单的装饰器模式，这里只包含最基本的参与者，不过完全可以清楚地展示一个PHP应用。这个例子描述了一个web开发企业，企业计划建立一个基本网站，并提供一些增强功能。不过，web开发人员知道，尽管这个基本计划适用于大多数客户，但客户以后很可能还希望进一步提升。 从这个最简单的装饰器例子还可以看出，利用装饰器模式，可以很容易地增加多个具体装饰器。除了这个例子中提供的3个装饰器之外，看看你能不能增加更多的装饰器。实际上这很容易。 另外由于你能选择要增加的装饰器，所以企业不仅能控制功能，还可以控制项目的成本。装饰器模式很容易使用，不仅能选择装饰中增加什么，还能选择哪些不用增加。 Component接口Component参与者是一个接口，在这里，它是一个抽象类IComponent。这个抽象类只有一个属性$site，另外有两个抽象方法getSite()和getPrice()。Component参与者为具体组件和Decorator参与者抽象类建立了接口：12 在PHP中，抽象方法只有一个很简短的签名，所以尽管getSite()和getPrice()会有期望的返回结果，但抽象方法声明中没有提供更多信息来指示应当生成何种类型的返回结果。 Decorator接口这个例子中的装饰器接口可能会让你感到惊讶。这是一个抽象类，而且它扩展了另一个抽象类！这个类的作用就是维护组件接口（IComponent）的一个引用，这是通过扩展IComponent完成的：12 与所有其他抽象类一样，你也可以实现方法和增加属性。不过，在这个最简单的例子中，Decorator类的主要作用就是维护组件接口的一个链接（引用）。 讨论具体组件参与者之前，下面来看这个装饰器模式实现的类图，如图2所示。 图2：最简单的装饰器模式实现的类图 所有这些参与者都有相同的接口。在所有装饰器模式实现中，你会发现，具体组件和装饰器都有相同的接口。它们的实现可能不同，另外除了基本接口的属性和方法外，组件和装饰器可能还会有额外的属性和方法。不过，从第一个例子我们可以得出，所有具体组件和装饰器都有共同的接口。 具体组件这个例子中只有一个具体组件，它生成一个网站名，另外生成一个基本网站报价（$1200）： 12 两个抽象方法都使用直接量赋值来实现（“Basic Site”和1200），不过灵活性并不体现在如何改变设置的值。实际上，要通过增加装饰器值来改变“Basic Site”值。下一小节会介绍这是如何做到的。 具体装饰器这个例子中的具体装饰器与具体组件有相同的接口。实际上，它们是从Decorator抽象类（而不是IComponent类）继承了这个接口。不过，要记住，Decorator所做的就是继承IComponent接口。 Maintenance 12 查看这个具体构造函数，你会发现，它看起来与装饰器几乎完全相同。不过，每个具体装饰器在它包装的具体组件价格上还会增加它自己的一个价格。另外两个具体装饰器与Maintenance装饰器也类似。 Video 12 Database 12 测试这个应用时，可以看到，在基本价格之上还会增加各个装饰器的价格。另外还指定了装饰器名的格式，增加了两个空格，使之缩进。 装饰器实现中最重要的元素之一就是构造函数，要为构造函数提供一个组件类型。由于这里只有一个具体组件，所有装饰器的实例化都会使用这个组件。使用多个组件时，装饰器可以包装应用中的一部分或全部组件，也可以不包装任何组件。 客户Client类并不是这个设计模式的一部分，甚至连隐含包含都不算是，尽管如此，正确使用Client类至关重要。每个装饰器必须在实例化时“包装”组件，这在上一节已经看到。不过，首先必须创建一个要包装的BasicSite类实例：12 一旦Client实例化BasicSite，会有一个wrapComponent()方法检查这个实例，以确保参数有正确的数据类型（IComponent），然后分别实例化3个装饰器。（在装饰器设计模式的典型用法中，只会包含所选择的装饰器；可以注释掉两个装饰器，看看不同的组合会对总价有什么影响。） wrapComponent()方法返回组件时（$this-&gt;basicSite），组件已经改变，现在已经包含了增加的装饰。由输出可以看到，具体组件实例现在由3个装饰器包装，不过，要记住，这里给出的是最简单的输出：12 也可以把wrapComponent()方法中的语句写在构造函数中，这样不用wrapComponent()方法Client也可以包装装饰器。不过，我们还是增加了wrapComponent()方法，这样就能把注意力更多地放在模式中的包装过程上。 关于包装器适配器和装饰器模式都有另外一个名字“包装器”（wrapper）。实际上，在一些定义中，就把包装器描述为适配器。如果你还不太明确包装器的定义，可以先停一下，来看看如何编写一般的包装器，另外如何编写PHP包装器。 包装器包装基本类型要了解包装器，最好的办法就是查看如何包装基本类型。下面的代码显示了如何将一个整数包装在一个对象中，以及如何获取这个整数：12 如果需要将一个基本类型包装在对象中，如PrimitiveWrap，有些语言允许用内置的包装器来包装基本类型，相比之下，PHP中则要困难一些。一些语言（如Java）对于每一个基本类型都有相应的包装器类，所以在这些语言中，无需再构建新的包装器类。 PHP中的内置包装器尽管PHP没有为所有基本类型都提供包装器，不过它确实有自己的包装器。例如，在第5章中就用到过一个包装器的例子，即file_get_contents()包装器。它将一个指定资源（如一个文件名，或者一个文件名的URL）绑定到一个流。下面的例子使用一首诗来说明这一点。首先，将这首诗保存为一个文本文件（haha.txt）：123456&lt;strong&gt;真正的粉丝&lt;/strong&gt;&lt;p&gt;苟利国家生死以，&lt;br/&gt;岂因祸福避趋之。&lt;br/&gt;&lt;/p&gt;--林则徐&lt;br/&gt; file_get_contents()包装器打开haha.txt，以便PHP程序输出。下面显示了这个包装器如何工作：12 这段代码生成以下输出：12 文件名（haha.txt）“包装”在内置的file_get_contents()包装器中。 设计模式包装器在第7章中，你已经看到对象适配器模式中的适配器（Adapter）参与者如何“包装”被适配者（Adaptee）。采用这种做法，就能创建一个与Adaptee兼容的接口。同样，从以上最简单的装饰器模式例子中可以看到，装饰器（Decorator）参与者可以“包装”一个组件对象，这样就能为这个已有的组件增加职责，而无须对它做任何修改。下面的代码展示了Client如何将组件对象（$component）包装在装饰器（Maintenance）中：1$component = new Maintenance（$component）; 类似于“接口”，在计算机编程中用到“包装器”时，不同的上下文中会有不同的用法和含义。一般来讲，在设计模式中使用“包装器”是为了处理接口的不兼容，或者希望表示用来减少不兼容性的策略。 包装多个组件的装饰器尽管以上最简单的装饰器模式例子中只使用了一个具体组件，不过使用多个组件的情况也很常见。例如，图3显示了一个包含多个具体组件的类图。 图3：装饰器模式中使用多个具体组件 Male和Female类表示IComponent抽象类的具体实现。装饰器采用数组方式增加属性。在这一节后面，我们会分别详细介绍这些属性。 多个具体组件对于实现或装饰来说，包含多个具体组件并不成问题。只要这些具体组件与传入装饰器的组件有相同的接口，就可以在具体装饰器中包装任何组件，就像包含一个组件的程序或系统一样。 包含多个状态和值的具体装饰器在图3中，继承IComponent抽象类接口的装饰器实现了一些方法。有几个问题需要说明。首先，装饰器（Decorator）实现了设置装饰状态时所有没有用到的方法。实际上，装饰器可以识别出组件中某些元素在装饰中不会改变（如组件的年龄和名字）。如果组件对应的方法只是在Decorator中实现，就不必在具体装饰器中重新实现这些方法。其次，在图1中可以看到，装饰器类图指示它至少要实现Component的一些接口。方法Operation()没有用斜体显示，这表示这个方法已经实例化。getAge()和setAge($a)方法已经实现，但是没有使用。如果它们未在Decorator中实现，就必须在各个具体装饰器中实现，因为继承的所有抽象方法都必须在子类中实现。 开发人员约会服务为了说明如何实现一个包装多个组件的装饰器，下面给出一个例子，它为软件开发人员建立了一个约会服务。这里有两个组件，分别是Male和Female，可以分别为这两个组件装饰不同的约会关注点。可以用相同或不同的具体装饰采用任意组合来装饰这些组件。 基本说来，每个组件都有一个名字和指定的年龄。我们假设年龄不是装饰。具体装饰会有不同的状态。各个装饰可以增加到具体组件，不仅如此，与第一个例子中一样，每个具体装饰可以有不同的状态。 组件接口 组件接口包括3个属性和5个方法。$date属性用来标识这是一个“约会”，而不是普通的日/月/年形式的日期对象。$ageGroup是该组件所属的组，$feature是由某个具体装饰提供的特性：12 所以的方法都是抽象的，另外所有属性都是保护属性。 具体组件 两个具体组件实现为Male和Female，它们分别有一个构造函数，将$date值（ID）设置为“Male”或“Female”。另外获取方法/设置方法设置了年龄和其他可能增加的装饰：12 基于两个具体组件设置的初始特性，基本描述了男性（male）和女性（female）的特点：12 可以使用$setFeature()方法为这两个组件增加其他特性作为装饰。可以把$setFeature()看作是一个组件增强器，而不只是一个组件设置方法。 包含组件方法的装饰器 装饰器接口扩展了组件接口。不过，如前所述，它还实现了年龄属性的获取方法和设置方法：12 如果想增加一个else语句来捕获错误，这很容易做到。不过，目前采用了一种“安静失败”的做法，即不会传递对象。 具体装饰器 这个例子中的具体装饰器与前面最简单例子中的具体装饰器有很大不同。并不是只有一个状态，这些具体装饰器都包含数组，其中有多个属性值。除了使用一个包含4种不同语言的具体装饰器作为具体装饰，也可以有4个不同的具体装饰，分别表示一种不同的计算机语言。不过，将相同的选择结合到一个数组中可以达到同样的目标，还可以保持松耦合：12 所有具体装饰器都有相同的格式。首先使用getFeature()为一个输出变量赋值，设置为所选择的元素，然后在这个输出变量后面加上格式化标记和一般的具体组件信息，共同作为输出：12 通过使用关联数组（即字符串元素作为键的数组），选择装饰属性时会更为容易一些。 对于每一个特性，所有具体装饰器都有类似的数组：12 客户应当能很容易地访问具体装饰，所以所有获取方法和设置方法都有public可见性。 不过，不同属性（数组）中设置的值为private，这样可以增加组件装饰过程的封装性。 Client 最后，Client类请求一个组件和具体装饰。首先通过实例化选择一个具体组件，然后Client设置感兴趣的年龄组。Client将4个年龄组分别设置为字符串“Age Group N”，其中“N”是1-4之间的一个字符串值：12 实例化这两个具体组件之一之后，Client将它们包装在某个具体装饰器中来完成装饰。整个过程都在wrapComponent()方法中完成。创建各个实例时，setFeature()方法利用参数（由一个关联数组键构成）来完成组件的装饰。客户会生成以下输出：123456FemaleAge Group 4Grrrl programmer features: Preferred programming language:PHP Current Hardware: Linux Favorite food: Veggies 可以看到，装饰器就是具体装饰器类中关联数组的元素。 HTML用户界面到目前为止，这本书还没有介绍HTML用户界面（UI）。在第5部分中，所有应用都包括一个HTML用户界面。之所以目前还没有增加HTML用户界面，原因在于我们现在重点强调的是不同设计模式的基本原理。PHP并未嵌在一个HTML包装器中，所生成的HTML也只用于一般的格式化。 下面要用HTML UI来显示如何通过Client类（对象）连接到一个PHP设计模式。使用“开发人员约会服务”一节中的例子，可以看到，HTML与PHP之间的通信与其他项目中任何其他HTML-&gt;PHP程序中的通信是一样的。在PHP中，唯一有改变的是允许从HTML表单向Client类传递值。模式中的所有其他参与者都保持不变。 首先，来看我们完成的HTML UI，如图4所示。可以看到，页面使用单选钮来提供所有数据输入。 图4：装饰器的数据输入 数据输入很简单，只需要提供这个页面的标准HTML/CSS文件。首先，页面使用了以下CSS文件：12 这个页面是针对移动设备的垂直布局建立的，不过也可以很好地用在平板电脑或桌面系统上。接下来给出页面的HTML，如以下代码所示。它调用了一个页面（ClientH.php）。类和文件名中的H表示它将接收HTML数据（可能需要为HTML或PHP脚本增加验证代码；如果某一组单选钮均未选择，就会抛出错误！）：12 基本上，这个页面会把数据传递到一个PHP页面，就像通过PHP从一个HTML页面向一个MySQL数据库发送数据一样。所以，尽管数据发送到一个装饰器设计模式中的Client类，在传递数据方面，与以往向PHP文件传递其他数据并没有不同。 Client类传递HTML数据前面已经指出，从HTML向一个PHP Client类发送数据与向一个数据库表发送数据是类似的。查看ClientH类，可以看到它类似于Client类，只不过使用了DeveloperDating.html文件的数据：12 通过使用$_POST关联数组，可以把单选钮变量和值传递到PHP变量。性别（gender）和年龄（age）变量通过构造函数传递，而组件变量（$hotDate）和3个装饰器变量（$proLang、$hardware和$food）都声明为私有变量，取代在原来Client类中使用相应直接量。 从变量名到对象实例要实例化一个对象实例，一般做法是为类实例指定一个命名变量。在这本书中，约定所有类名首字母大写，变量类实例名都使用小写，如下：1$someInstance = new Someclass(); 只要知道类名，这种格式会很合适。不过，如果需要通过一个从HTML页面传递的变量来声明多个组件，类名必须来自这个变量的值。利用PHP，这个过程极其容易，尤其是与使用某个eval函数的方法相比（使用eval函数也可以达到这个目的，不过烦琐得多）。 在第6章已经看到，通过一个变量命名和实例化一个类时，一般过程就是将类名赋至一个变量，然后用这个变量实例化这个类。例如，假设有一个类名为Nature；可以通过一个变量动态地实例化一个类实例：12$quack = "Nature";$myNature = new $quack(); 这样一来，$myNature是Nature类的一个实例。在类ClientH中，可以看到$hotDate变量必须实例化Female或Male组件类。用户要选择男性或女性，需要在两个单选钮中做出选择（两个单选钮都命名为gender） 。两个值分别为类名Female和Male，所以，这些值传递到PHP变量$gender时，就会实例化相应的具体组件类。下面这行代码完成实例化：1$this-&gt;hotDate = new $gender(); 需要说明，这个表达式包含new关键字，另外变量$gender后面有开始和结束小括号。 增加装饰你可能希望最好包含一个查询来了解用户喜欢哪一类电影，以此衡量约会双方的契合度。例如，动作片、爱情片、科幻片和音乐片都可能是用户喜欢的电影类型。可以考察一下你对装饰器设计模式的理解程度，自己动手增加一个具体装饰器类，由用户喜欢的电影类型来装饰所选择的具体组件。 这很简单。实际上，可以复制粘贴现有的某个具体组件，把它重命名为Films，然后改变类别选项，使用Client类中的直接量值测试。如果一切正常，再更新HTML UI，加入电影选择，并修改ClientH类向程序传递这个请求。 程序越庞大，OOP编程和结构型设计模式就越有用。这是因为，第3部分中讨论的所有模式都可以用来改变现有结构的功能，而不必重写原来的结构。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么组合优先于继承？ 本章涵盖： 什么是适配器模式 何时使用适配器模式 使用继承的适配器模式 使用组合的适配器模式 从桌面环境转向移动环境 适配器和变化 能生存下来的物种，不是最强壮的，也不是最聪明的，而是能因应环境变化的物种。——查尔斯·达尔文 智力的详测要看其变革能力。——阿尔伯特·爱因斯坦 什么是适配器模式这一章会同时介绍对象适配器和类适配器。其中最有意思的是查看使用继承和使用组合的差别。类适配器设计模式使用继承，如图1中的类图所示。 图1：使用继承的适配器类图 从这个类图可以看到，这个模式实现中一个类有双重继承。要知道，双重继承在PHP（C#）中是不允许的，不过实现双重继承有一些替代方法，可以结合继承和实现来正确地实现这种模式。 设计模式有一个重要格言：组合优先于继承。再来看第二个适配器模式（图2），Adapter参与者使用组合来包含Adaptee的一个引用，这里没有使用继承。 图2：使用组合的适配器类图 一般来说，组合要优先于继承，因为参与者之间的绑定更宽松，在重用、结构和修改等方面有很多优点，这与使用继承不同，继承具体类或者所继承的类中包含已实现的方法时，存在一种紧密绑定，使用组合就没有这种紧密绑定的缺点。 何时使用适配器模式适配器很容易理解，我们一直都在使用适配器。大多数家庭都有手机转接器，用来为移动电话充电，这就是一种适配器。如果只有USB连接头，就无法将移动电话插到标准插座上。实际上，必须使用一个适配器，一端接USB插头，另一端接插座。图3显示了为移动电话或电脑充电的一个典型的适配器。 图3：适配器在电气领域很常见 如果有人问：“什么时候使用适配器模式？”从某种程度上讲，这个问题与“什么时候使用某种适配器”是一样的，会得到类似的答案。例如，如果有人问如何为移动电话充电，你可能会告诉他：需要用到一个适配器，使USB连接头和墙上插座相互兼容。 分解这个问题可以得到： USB连接头——不变 标准墙上插座——不变 当然，你可以拿出你的电气工具，改装USB连接头，或者重新安装墙上插座，不过这样会带来很多额外的工作，而且可能会把连接头或插座弄坏（甚至两个都弄坏）。或者，你也可以找一个适配器。最可取的做法就是找一个适配器。软件开发也是如此。 假设你和你的同事已经开发了一个PHP程序，可以很容易地为客户创建定制的桌面web设计。这个系统可以处理所有工作，包括网站的外观以及一个MySQL数据库的处理。对于笔记本电脑和台式机的屏幕来说，很适合采用一种多栏设计以及相应的用户体验设计（User experience design，UX）。实际上，这样得到的系统非常类似于用PHP创建的一个桌面CMS（Content Management System）。 某一天，一些客户要求你为这个网站增加一个移动版本。设计人员告诉你移动平台更适合采用水平设计，所以你必须重新设计外观。相应地，整个用户体验设计也必须修改。设计人员开发出一个移动模块后，你发现这个模块与你原先的桌面模块并不兼容。图4描述了这个问题。 图4：与移动电话适配器一样，适配器设计模式也遵循同样的原则 我们不想改变web开发模块（这个系统原本工作得很好，其中包含链接web页面和数据库的所有类和操作），也不想改变新开发的移动模块，那么你该怎么做呢？答案很简单，就像为手机充电一样，可以使用一个适配器。在“使用组合的适配器模式”一节中，你会找到这样一个例子，从中可以了解如何使用适配器设计模式更新系统来包含一个新模块。 适配器模式还有很多其他的应用。很多专业的web开发人员可能会使用开发商提供的一些特殊的加速器、UI或其他增强模块，为了与现有软件一同使用，他们通常需要某种适配器。类似地，如果两个不同的开发小组开发了不兼容的模块，也可以使用一个适配器，与要求某个小组重新开发模块相比，使用适配器通常更节省时间。 使用继承的适配器模式类适配器设计模式很简单，不过与对象适配器模式相比，类适配器模式的灵活性稍弱。类适配器模式更简单的原因在于，适配器（Adapter）会从被适配者（Adaptee）继承功能，所以适配器模式中需要重新编写的代码比较少。当然，由于给定了一个将由适配器（Adapter）继承的具体被适配者（Adaptee），这种绑定很紧密，所以使用类适配器模式创建应用时，必须非常清楚将在哪里发生适配。 由于类适配器包含双重继承，如图1中所示，下面的PHP例子首先用了一点技巧。实际上，PHP并不支持双重继承。你会发现很多设计精巧的例子都展示了PHP可以模拟双重继承，不过最重要的是，PHP本身可以很好地处理接口实现和类继承的组合。下面的语句展示了一个正确的结构，这里不仅继承了一个类，同时还实现了一个接口：1class ChildClass extends ParentClass implements ISomeInterface 所以，实现类适配器模式时，参与者必须包括一个PHP接口。 最简单的类适配器例子：货币兑换 假设有一个企业网站在同时销售软件服务和软件产品，目前，所有交易都在美国进行，所以完全可以用美元来完成所有计算。现在开发人员希望能有一个转换器能处理美元与欧元的兑换，而不要改变原来按美元计算交易金额的类。通过增加一个适配器，现在程序既可以用美元计算也可以用欧元计算。 首先，假设有一个很好的类DollarCalc，它能累加所购买服务和产品的价格，然后返回总金额：1234567891011121314151617181920212223&lt;?php// DollarCalc.phpclass DollarCalc&#123; private $dollar; private $product; private $service; public $rate = 1; public function requestCalc($productNow, $serviceNow) &#123; $this-&gt;product = $productNow; $this-&gt;service = $serviceNow; $this-&gt;dollar = $this-&gt;product + $this-&gt;service; return $this-&gt;requestTotal(); &#125; public function requestTotal() &#123; $this-&gt;dollar *= $this-&gt;rate; return $this-&gt;dollar; &#125;&#125; 查看这个类，可以看到其中有一个属性$rate，requestTotal()方法使用$rate来计算一次交易的金额。在这个版本中，这个值设置为1，另外将两个参数变量的值乘以1，实际上总金额无需再乘以兑换率。不过，如果要为客户提供折扣或者要增加额外服务或产品的附加费，$rate变量会很方便。这个类并不是类适配器模式的一部分，不过这是一个起点。 加入欧元 客户宣布她的公司决定向欧洲拓展，所以需要开发一个应用，能够用欧元完成同样的计算。你希望这个欧元计算能像DollarCalc一样，所要做的就是改变变量名。1234567891011121314151617181920212223&lt;?php// EuroCalc.phpclass DollarCalc&#123; private $euro; private $product; private $service; public $rate = 1; public function requestCalc($productNow, $serviceNow) &#123; $this-&gt;product = $productNow; $this-&gt;service = $serviceNow; $this-&gt;euro = $this-&gt;product + $this-&gt;service; return $this-&gt;requestTotal(); &#125; public function requestTotal() &#123; $this-&gt;euro *= $this-&gt;rate; return $this-&gt;euro; &#125;&#125; 接下来，再把应用的其余部分插入到EuroCalc类中，你已经做好了准备。不过，你知道客户的所有数据都是按美元计算的。换句话说，如果不重新开发整个程序，就无法在系统中“插入”这个欧元计算。但你不想这么做。为了加入EuroCalc，你需要一个适配器。 创建一个欧元适配器 我们先停一下，理一理思路。图5显示了一个类图，这里使用了这个类适配器模式实现中的类名。 图5：使用继承实现的适配器类图 就像找一个适配器来适应欧洲的插座一样，可以创建一个适配器，使你的系统能够使用欧元。幸运的是，类适配器模式正是为这种情况设计的。首先需要创建一个接口。在这个类图中，这个接口名为ITarget。它只有一个方法requester()。requester()是一个抽象方法，要由接口的具体实现来实现这个方法：123456&lt;?php// ITarget.phpinterface ITarget &#123; function requester();&#125; 现在开发人员可以实现requester()方法，请求欧元而不是美元。 在使用继承的适配器设计模式中，适配器（Adapter）参与者既实现ITarget接口，还实现了具体类EuroCalc。创建EuroAdapter不需要做太多工作。大部分工作已经在EuroCalc类中完成，这是一个具体类。现在要做的就是实现requester()方法，使它能把美元值转换为欧元值：12345678910111213141516171819&lt;?php// EuroAdapter.php// Adapterinclude_once('EuroCalc.php');include_once('ITarget.php');class EuroAdapter extends EuroCalc implements ITarget&#123; function __construct() &#123; $this-&gt;requester(); &#125; function requester() &#123; $this-&gt;rate = 0.8111; return $this-&gt;rate; &#125;&#125; 类适配器模式中，一个具体类会继承另一个具体类，有这种结构的设计模式很少见。大多数设计模式中，几乎都是继承一个抽象类，并由具体类根据需要实现其抽象方法和属性。换句话说， 一般谈到继承时，都是具体类继承抽象类。 由于既实现了一个接口又扩展了一个类，所以EuroAdapter类同时拥有该接口和具体类的接口。通过使用requester()方法，EuroAdapter类可以设置rate值（兑换率），从而能使用被适配者的功能，而无需做任何改变。 下面来看具体是如何工作的，Client类从EuroAdapter和DollarCalc类发出请求。可以看到，原来的DollarCalc仍能很好地工作，不过它没有ITarget接口。EuroAdapter类同时实现了接口和具体类，通过使用类型提示，可以保证与其接口一致：1234567891011121314151617181920212223242526272829303132&lt;?php// Client.php// Clientinclude_once('EuroAdapter.php');include_once('DollarCalc.php');class Client&#123; private $requestNow; private $dollarRequest; public function __construct() &#123; $this-&gt;requestNow = new EuroAdapter(); $this-&gt;dollarRequest = new DollarCalc(); echo "Euros: €".$this-&gt;makeAdapterRequest($this-&gt;requestNow)."&lt;br/&gt;"; echo "Dollars: $".$this-&gt;makeDollarRequest($this-&gt;dollarRequest); &#125; private function makeAdapterRequest(ITarget $req) &#123; return $req-&gt;requestCalc(40, 50); &#125; private function makeDollarRequest(DollarCalc $req) &#123; return $req-&gt;requestCalc(40, 50); &#125;&#125;$worker = new Client(); 由输出可以看到，现在美元或欧元都可以处理，这要归功于适配器模式：12Euros: €72.999Dollars: $90 这个计算很简单，不过对于更为复杂的计算，继承要提供建立类适配器的Target接口的必要接口和具体实现。 使用组合的适配器模式&lt;/span&gt;对象适配器模式使用组合而不是继承，不过它也会完成同样的目标。通过比较这两个版本的适配器模式，可以看出它们各自的优缺点。采用类适配器模式时，适配器可以继承它需要的大多数功能，只是通过接口稍做调整。在对象适配器模式中，适配器（Adapter）参与者使用被适配者（Adaptee），并实现Target接口。在类适配器模式中，适配器（Adapter）则是一个被适配者（Adaptee），并实现Target接口。 从桌面环境转向移动环境PHP程序员经常会遇到这样一个问题：需要适应移动环境而做出调整。不久之前，你可能只需要考虑提供一个网站来适应多种不同的桌面环境。大多数桌面环境都使用一个布局，再由设计人员让它更美观。对于移动设备，设计人员和开发人员不仅需要重新考虑桌面和移动环境中页面显示的设计元素，还要考虑如何从一个环境切换到另一个环境。 这个例子使用了对象适配器模式，首先给出一个简单的PHP类，它提供一个简单的页面，其中包含文本和图片。对于文本，这个例子使用了一个占位文本（“loremipsum”）作为填充内容（存储在一个文本文件中）。CSS也很简单，使用一个很基本的两栏设计，文本图片关系为左边显示文本，右边显示图片。CSS存储为一个单独的CSS文件。 桌面 要了解组合适配器，首先来看原来的类（它将需要一个适配器）。这个类使用了一个简单但很宽松的接口：12 它支持多个CSS和图片选择，不过其中一个方法指示一种水平布局，我们知道，这种布局并不适用于小的移动设备。这个接口的实现相当简单，下面给出这个接口实现（Desktop）类：12 这个类中的大多数代码都是在完成HTML页面的格式化，以便浏览。文本、图像以及页眉都是最简单的例子。CSS提供了一个样式表，用来设置调色板、体文本、页眉、“第二列”（以便将图像放在文本右边）以及图像周围的边距：12 这个CSS保存在一个名为desktop.css的文件中，通过PHP生成的HTML \标记来调用。 图6：简单的两栏桌面设计 在图6中可以看到，这个布局对于小的移动设备来说太宽了。所以我们的目标是仍采用同样的内容，但调整为一种移动设计。 调整为移动设计。首先来看图7，这里显示了创建移动网站时要使用的具体类名和操作。我增加了Mobile类原来的接口（IMobileFormat），不过，由于使用了MobileAdapter，它要实现IFormat接口。 图7：对象适配器类图中的MobileAdapter 查看IMobileFormat和IFormat接口时，可以看到它们是不兼容的：一个包含方法horizontalLayout()，而另一个包含verticalLayout()方法。不过，通过使用MobileAdapter（适配器），它继承了Desktop类原来使用的IFormat（Target），现在Mobile（Adaptee）类可以以兼容的方式与IFormat接口的其他实现交互。 适配器模式也称为包装器模式，这一点并不奇怪。适配器（MobileAdapter）参与者“包装了”被适配者（Mobile）参与者，使被适配者可以使用同样的接口。要看包装过程是如何工作的，首先来看IMobileFormat接口和Mobile类，Mobile类与Desktop类几乎完全相同，只不过它有一个不同的接口：12 要记住，这个过程的目的是让两个不兼容的接口合作。它们的差别很小，不过你要知道，从桌面设计转换到移动设计时，最主要的区别是：桌面设计可以采用水平的多栏布局，而移动设计要使用垂直布局。下面的Mobile类实现了IMobileFormat（它看起来与Desktop类几乎完全相同）：12 前面已经提到，它与Desktop类非常相似，不过图片的设置不同，而且提供了一个不同的图片。它还调用了另一个不同的CSS文件。这个CSS文件包含一个@media语句，提供了不同的分辨率选择：12 尽管这个CSS看起来很重要，但在这里它只用于对移动设计的页面外观完成格式化。设计人员还可以做更多工作。重要的是，不论是桌面设计还是移动设计，负责页面外观的不同的类（Desktop类和Mobile类）要协同工作。下面来看关键的适配器（Adapter）参与者，它将Desktop类和Mobile类结合在一起：12 可以看到，MobileAdapter实例化时要提供一个Mobile对象实例。还要注意，类型提示中使用了IMobileFormat，来确保参数是一个Mobile对象。有意思的是，Adapter参与者通过实现horizontalLayout()方法来包含Mobile对象的verticalLayout()方法。实际上，所有MobileAdapter方法都包装了一个Mobile方法。碰巧的是，适配器参与者中的一个方法并不在适配器接口中（verticalLayout()）。它们可能完全不同，适配器只是把它们包装在适配器接口（IFormat）的某一个方法中。 Client类作为参与者 最后一步是使用MobileAdapter类启动应用。要记住，Client类是这个设计模式中不可缺少的一部分，尽管它只是做出请求，但其请求方式要与适配器模式的目标和设计相一致：12 适配器模式中的Client类必须包装Adaptee（Mobile）的一个实例，以便集成到Adapter本身。实例化Adapter时，Client使用Adaptee作为参数来完成Adapter的实例化。所以客户必须首先创建一个Adaptee对象（new Mobile()），然后创建一个Adapter实例（(new MobileAdapter（$this-&gt;mobile)）。 Client类的大多数请求都通过MobileAdapter实例发出。不过，在这个代码的最后，它使用了Mobile类的实例。由于应用不需要特殊的closeHTML()方法实现，Client直接调用了Mobile实例的这个方法。 图8显示了为一个移动设备配置相同内容时得到的结果。在这个例子中，所使用的移动设备是一个iPhone。 图8：为移动设备调整为单栏布局 关于如何设计和配置移动web应用，有很多相关的书和资料，这些设计都可以采用适配器模式。关键在于，适配器模式能够以一个桌面设计为起点，选择并使用适合移动设备的不同设计，而不会破坏原来的桌面设计实现。 适配器和变化PHP程序员要时刻面对变化。不同版本的PHP会有变化，可能增加新的功能，另外还可能取消一些功能。而且，随着PHP的大大小小的变化，MySQL也在改变。例如，mysql扩展包升级为mysqli，PHP开发人员需要相应调整，要改为使用mysqli中的新API，这里适合采用适配器模式吗？可能不适合。适配器可能适用，也可能不适用，这取决于你的程序如何配置。当然可以重写所有连接和交互代码，不过这可不是适配器模式的本意。这就像是重新安装USB连接头，想把它插进标准的墙上插座一样。不过，如果所有原来的mysql代码都在模块中，你可以修改这个模块（类），换入一个有相同接口的新模块，只是要使用mysqli而不是mysql。我不认为交换等同于适配器，不过道理是一样的。在适配器模式中，原来的代码没有任何改变。有变化的只是适配器。 如果需要结合使用两个不兼容的接口，这种情况下，适配器模式最适用。适配器可以完成接口的“联姻”。可以把适配器看作是一个婚姻顾问：通过创建一个公共接口来克服双方的差异。利用这种设计模式，可以促成二者的合作，而避免完全重写某一部分。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式的分类]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 设计模式分为哪三类？为什么这么分？各举几个例子。 本章涵盖： 创建型设计模式 结构型设计模式 行为型设计模式 创建型设计模式创建型设计模式强调的是实例化过程。设计这些模式的目的是隐藏实例的创建过程，并封装对象使用的知识。5个创建型设计模式包括： 单例（Singleton） 工厂方法（Factory Method） 抽象工厂（Abstract Factory） 建造者（Builder） 原型（Prototype） 工厂方法模式是这5个设计模式中唯一的一种类设计模式。原型模式属于对象类模式，可以使用PHP _clone()方法实现。首先基于原型实例化（创建）一个对象，然后由这个实例化对象进一步克隆其他对象。你会发现这种模式很容易使用，相当方便。 使用创建型模式时，最有意思的是，程序和系统越来越依赖于对象组合而不是依赖于类继承时，创建型模式就会很重要——确切地说是至关重要。程序变成由对象构成的系统，而对象又由其他对象组合而成，所以任何单个对象的创建都不应该依赖于创建者。换句话说，对象不应与创建对象的过程紧密绑定。这样一来，就不会由于请求对象的特定特性而影响对象组合。此类设计模式会告诉你如何以最优的方式实现创建过程。图1概要描述了创建型模式如何工作。 图1：创建型模式结构 结构型设计模式结构型设计模式研究的是如何组合对象和类来构成更大的结构。在类结构型设计中，要通过多个接口来创建新结构。一个类可能继承多个父类来创建一个新的结构。更常见的是对象结构结合不同的对象来形成新的结构。下面7种模式称为结构型模式。 适配器模式（Adapter）（类和对象） 桥接模式（Bridge） 组合模式（Composite） 装饰器模式（Decorator） 外观模式（Pacade） 享元模式（Flyweight） 代理模式（Proxy） 如果需要通过适配（使用多重继承或组合）来结合两个不兼容的系统，适配器就非常重要。但有一个棘手的问题需要处理：PHP不支持多重继承，不过可以看到，PHP提供了一种变通方法来实现类适配器模式。另外，组合不仅适用于对象适配器模式，也适用于装饰器模式。图2提供了结构型设计模式的一个可视化表示。 图2：结构型模式强调由现有结构创建新结构 结构型设计模式的重点是创建新结构而不破坏原有的结构。在这个基础上，结构型模式可以保持并提升松耦合标准以实现重用和灵活改变。 行为型设计模式“四人帮”所提供的设计模式中，行为型设计模式占了绝大部分。这一部分将介绍一个类设计模式（模板方法模式）和一个对象设计模式（状态模式）。有11个行为型模式: 职责链模式（Chain of Responsibility） 命令模式（Command） 解释器模式（Interpreter）（类设计模式） 迭代器模式（Iterator） 中介者模式（Mediator） 备忘录模式（Memento） 观察者模式（Observer） 状态模式（State） 策略模式（Strategy） 模板方法模式（Template Method）（类设计模式） 访问者模式（Visitor） 理解行为型设计模式的关键是通信。对于这些模式，重点不再是构成一个设计模式的对象和类，而应转变为对象和类之间的通信。实际上，最好考虑对象如何相互合作来完成任务，从这个角度来理解行为型设计模式。 图3：行为型模式强调模式参与者之间的通信 要重点考虑构成模式的元素之间的交互，这一点非常重要，有些模式的类图看起来是一样的，如状态模式和策略模式。不过，由于参与者通信的方式不同，另外它们处理职责的方式也不同，所以这些模式实际上有很大不同。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则 (2)]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%20(2)%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是依赖倒转原则？和依赖注入和控制反转有什么不同？ 依赖倒置的“细节”可以理解为实现类。接口类和实现类是什么，是什么关系？ 什么是里氏替换原则？ 单一职责原则1就一个类而言，应该仅有一个引起它变化的原因。 我们在做编程的时候，很自然地就会给一个类加各种各样的功能，比如我们写一个窗体应用程序，一般都会生成一个Form1这样的类，于是我们就把各种各样的代码，像某种商业运算的算法呀，像数据库访问的SQL语句呀什么的都写到这样的类当中，这就意味着，无论任何需求要来，你都需要更改这个窗体类，这其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。 方块游戏的设计拿手机里的俄罗斯方块游戏为例。要是让你开发这个小游戏，你如何考虑？ 首先它方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个方块。不断地绘出和擦掉就形成了动画，所以应该要有画和擦方块的代码。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。 如果就用WinForm的方式开发，打算怎么开发呢？ 那当然是先建立一个窗体Form，然后加一个用于游戏框的控件，比如Panel或者PictureBox，一个按钮Button来控制‘开始’，最后再放一个Timer控件用于分时动画的编程。写代码当然就是编写Timer_Tick事件来绘出和擦除方块，并做出堆积和消层的判断。再编写控件的键盘事件，按了左箭头则左移，右箭头则右移等等。对了，还需要用到些GDI+技术的方法来画方块和擦方块。 你能不能就这些代码划分一下类呢？ 分类？这里好像关键在于各种事件代码如何写吧，这里有什么类可言呢？ 看来你的面向过程开发已经根深蒂固了。你把所有的代码都写在了Form1.cs这个类里，你觉得这合理吗？ 打个比方，如果现在要你写的是手机版的俄罗斯方块程序，即Pocket PC或者Windows CE上运行的程序，它们可以安装.NET框架的精简版，运行C#语言编写的应用程序，但PC上的普通WinForm界面的程序不能使用。那你现在这个代码有什么可以复用的吗？ 这当中，有些东西是始终没变的。 下落、旋转、碰撞判断、移动、堆积这些都是和游戏有关的逻辑，和界面如何表示没有什么关系，为什么要写在一个类里面呢？如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。事实上，你完全可以找出哪些是界面，哪些是游戏逻辑，然后进行分离。 方块的可移动的游戏区域，可以设计为一个二维整型数组用来表示坐标，宽10，高20，比如‘int[，] arraySquare=new int[10，20];’，那么整个方块的移动其实就是数组的下标变化，比如原方块在arraySquare [3，5]上，则下移时变成arraySquare [3，6]，如果下移同时还按了左键，则是arraySquare [2，6]。每个数组的值就是是否存在方块的标志，存在为1，不存在时缺省为0。这下你该明白，所谓的碰撞判断，是否能左移，就是判断arraySquare[x，y]中的x–1是否小于0，否则就撞墙了。或者arraySquare[x–1，y]是否等于1，否则就说明左侧有堆积的方块。所谓堆积，不过是判断arraySquare[x，y+1]是否等于1的过程，如果是，则将自己arraySquare [x，y]的值改1。那么消层，其实就是arraySquare [x，y]中循环x由0到9，判断arraySquare [x，y]是否都等于1，是则此行数据清零，并将其上方的数组值遍历下移一位。” 所谓游戏逻辑，不过就是数组的每一项值变化的问题，下落、旋转、碰撞判断、移动、堆积这些都是在做数组具体项的值的变化。而界面表示逻辑，不过是根据数组的数据进行绘出和擦除，或者根据键盘命令调用数组的相应方法进行改变。因此，至少应该考虑将此程序分为两个类，一个是游戏逻辑的类，一个是WinForm窗体的类。当有一天要改变界面，或者换界面时，不过是窗体类的变化，和游戏逻辑无关，以此达到复用的目的。 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。其实要去判断是否应该分离出类来，也不难，那就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。 界面的变化是和游戏本身没有关系的，界面是容易变化的，而游戏逻辑是不太容易变化的，将它们分离开有利于界面的改动。 编程时，要在类的职责分离上多思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。 开放-封闭原则在软件设计模式中，不能修改，但可以扩展的思想是最重要的一种设计原则，它就是开放-封闭原则（The Open-Closeed Principle，简称OCP）或叫开-闭原则。” 这个原则其实是有两个特征，一个是说‘对于扩展是开放的（Open for extension）’，另一个是说‘对于更改是封闭的（Closed for modification）’。 在做任何系统的时候，都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推倒重来。怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？，开放-封闭给我们答案。 设计软件要容易维护又不容易出问题的最好的办法，就是多扩展，少修改？ 何时应对变化开放-封闭原则的意思是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。 绝对的对修改关闭是不可能的。无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。 我们很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，等到变化发生时立即采取行动。正所谓，同一地方，摔第一跤不是你的错，再次在此摔跤就是你的不对了。 在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。比如，我之前让你写的加法程序，你很快在一个client类中就完成，此时变化还没有发生。然后我让你加一个减法功能，你发现，增加功能需要修改原来这个类，这就违背了今天讲到的‘开放-封闭原则’，于是你就该考虑重构程序，增加一个抽象的运算类，通过一些面向对象的手段，如继承，多态等来隔离具体加法、减法与client耦合，需求依然可以满足，还能应对变化。这时我又要你再加乘除法功能，你就不需要再去更改client以及加法减法的类了，而是增加乘法和除法子类就可。即面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。这就是‘开放-封闭原则’的精神所在。（样例代码见第1章） 当然，并不是什么时候应对变化都是容易的。我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。” 如果加减运算都在很多地方应用了，再考虑抽象、考虑分离，就很困难。 开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。切记，切记。 我还以为尽量地抽象是好事呢，看来过犹不及呀。 依赖倒转原则依赖倒转和依赖注入，控制反转是不一样的东西。 面向对象的四个好处是： 可维护 可扩展 可复用 灵活性好 电脑好修而收音机不好修的原因是电脑是模块化的，而收音机不是，各组件紧密结合。 可以把PC电脑理解成是大的软件系统，任何部件如CPU、内存、硬盘、显卡等都可以理解为程序中封装的类或程序集，由于PC易插拔的方式，那么不管哪一个出问题，都可以在不影响别的部件的前提下进行修改或替换。 面向对象里把这种关系叫强内聚、松耦合吧，即高内聚，低耦合。 面向对象的几大设计原则 单一职责原则，对象各自的职责是明确的。开放-封闭原则，对扩展开放，对修改关闭 依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，就是要针对接口类编程，不要对实现类编程。通过接口声明对象，通过具体对象来调用。 依赖倒转原则 A.高层模块不应该依赖低层模块。两个都应该依赖抽象。B.抽象不应该依赖细节。细节应该依赖抽象。 为什么要叫倒转呢? 面向过程的开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些低层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用这些函数。这也就叫做高层模块依赖低层模块。 我们要做新项目时，发现业务逻辑的高层模块都是一样的，但客户却希望使用不同的数据库或存储信息方式，这时就出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与低层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。就像刚才说的，PC里如果CPU、内存、硬盘都需要依赖具体的主板，主板一坏，所有的部件就都没用了，这显然不合理。反过来，如果内存坏了，也不应该造成其他部件不能用才对。而如果不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。这才是最好的办法。 为什么依赖了抽象的接口或抽象类，就不怕更改呢? 原因就是里氏代换原则。 里氏替换原则里氏代换原则是在1988年发表的，它的白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型[ASD]. 里氏代换原则1子类型必须能够替换掉它们的父类型。 子类继承了父类，所以子类可以以父类的身份出现。如果在面向对象设计时，一个是鸟类，一个是企鹅类，如果鸟是可以飞的，企鹅不会飞，那么企鹅是鸟吗?企鹅可以继承鸟这个类吗” 企鹅是一种特殊的鸟，尽管不能飞，但它也是鸟呀，当然可以继承。 子类拥有父类所有非private的行为和属性。鸟会飞，而企鹅不会飞。尽管在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅不能以父类—鸟的身份出现，因为前提说所有鸟都能飞，而企鹅飞不了，所以，企鹅不能继承鸟类。 也正因为有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。比方说，猫是线承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。 收音机就是典型的耦合过度，只要收音机出故障，不管是没有声音、不能调频，还是有杂音，反正都很难修理，不懂的人根本没法修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难以维护。非常复杂的PC电脑可以修，反而相对简单的收音机不能修，这其实就说明了很大的问题。当然，电脑的所谓修也就是更换配件， CPU或内存要是坏了，老百姓是没法修的。现在在软件世界里，收音机式的强耦合开发还是太多了，比如前段时间某银行出问题，需要服务器停机大半天的排查修整，这要损失多少钱。如果完全面向对象的设计，或许问题的查找和修改就容易得多。依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。 用子类对象实例化父类对象 注意： 只能调用到子类对象里面的父类对象 如果父类成员方法被子类重写了，那么就调用子类里面重写的方法 里氏替换原则有三种表现形式： 1、用子类对象实例化父类对象。 2、父类作为参数，传入子类对象。 3、父类作为返回值，可以返回子类对象。 使用场景： 游戏中的宠物商店123456789101112131415static Animal GetAnimal(string name)&#123; if (name == "Cat") &#123; return new Cat(); &#125; else if (name == "Dog") &#123; return new Dog(); &#125; else &#123; return null; &#125; &#125; 单例模式两个作用1、主要是让内存中只有一个对象，保证数据的正确性。2、节省内存 自己的总结并不是写一个继承就能自动满足里氏替换原则的。比如鸟类，写了一个会飞的方法，然后鸵鸟继承了这个类，某处调用了父类鸟飞的方法，然后就满足不了里氏替换原则了。 不能用鸵鸟替换掉鸟类，因为鸵鸟不会飞，所以这个父类设计错误。 再比如设计一个宠物类，宠物的属性有重量、价格、颜色，返回值是宠物类，然后根据传参返回具体的宠物。然后直接使用宠物类Pets.climbTree()肯定不行，因为狗不会上树。 所以设计父类的时候一定要拿到所有的共同点。 迪米特法则哪怕两个人，也应该有管理才好。 迪米特法则（LoD）也叫最少知识原则。 迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。 需要公开的字段，通常就用属性来体现了。这就是封装的思想。 面向对象的设计原则和面向对象的三大特性本就不是矛盾的。迪米特法则其根本思想，是强调了类之间的松耦合。 我们在程序设计时，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐藏促进了软件的复用。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 命令模式的应用场景是什么？命令模式必须使用吗？命令模式属于哪种设计模式？ 先使用继承自抽象命令类的具体命令类对厨师类（Receiver）进行引用和方法封装。最后再引入服务员类（Invoker）对命令进行管理。怎么理解？ 命令模式的缺点是什么？ 不使用命令模式做不到对请求的排队和撤销。为什么？ 第1版：紧耦合设计 代码结构图 路边烤羊肉串的实现 123456789101112131415// 烤肉串者public class Barbecuer&#123; // 烤羊肉 public void BakeMutton() &#123; Console.WriteLine("烤羊肉串!"); &#125; // 烤鸡翅 public void BakeChickenWing() &#123; Console.WriteLine("烤鸡翅!"); &#125;&#125; 客户端调用 123456789101112131415161718class Program&#123; static void Main(string[] args) &#123; Barbecuer maimaiti = new Barbecuer(); // 客户端程序与“烤肉串者”紧耦合，尽管简单，但却极为僵化，有许许多多的隐患 maimaiti.BakeMutton(); maimaiti.BakeMutton(); maimaiti.BakeMutton(); maimaiti.BakeChickenWing(); maimaiti.BakeMutton(); maimaiti.BakeMutton(); maimaiti.BakeChickenWing(); Console.Read(); &#125;&#125; 这就是‘行为请求者’与‘行为实现者’的紧耦合，对请求排队或记录请求日志，以及支持可撤销的操作等行为时，‘行为请求者’与‘行为实现者’的紧耦合是不太适合的。 第二版：松耦合设计 代码结构图 抽象命令类 123456789101112// 抽象命令类，只需要确定“烤肉串者”是谁。public abstract class Command&#123; protected Barbecuer receiver; public Command(Barbecuer receiver) &#123; this.receiver = receiver; &#125; abstract public void ExecuteCommand();&#125; 具体命令类 12345678910111213141516171819202122class BakeMuttonCommand : Command&#123; public BakeMuttonCommand(Barbecuer receiver) : base(receiver) &#123;&#125; // 执行命令 public override void ExecuteCommand() &#123; receiver.BakeMutton(); &#125;&#125;class BakeChickenWingCommand : Command&#123; public BakeChickenWingCommand(Barbecuer receiver) : base(receiver) &#123;&#125; public override void ExecuteCommand() &#123; receiver.BakeChickenWing(); &#125;&#125; 服务员类 1234567891011121314151617// 服务员类，不用管用户想要什么烤肉，反正都是‘命令’，只管记录订单，然后通知‘烤肉串者’执行即可public class Waiter&#123; private Command command; // 设置订单 public void SetOrder(Command command) &#123; this.command = command; &#125; // 通知执行 public void Notify() &#123; command.ExecuteCommand(); &#125;&#125; 烤肉串者类与之前相同，略。 客户端实现 12345678910111213141516171819202122232425class Program&#123; static void Main(string[] args) &#123; // 烧烤店事先就找好了烤肉厨师、服务员和烤肉菜单，就等客户上门 Barbecuer tangniu = new Barbecuer(); Command bakeMuttonCommand1 = new BakeMuttonCommand(tangniu); Command bakeMuttonCommand2 = new BakeMuttonCommand(tangniu); Command bakeChickenWingCommand1 = new BakeChickenWingCommand(tangniu); Waiter girl = new Waiter(); // 开门营业 // 服务员根据用户要求，通知厨房开始制作 girl.SetOrder(bakeMuttonCommand1); girl.Notify(); girl.SetOrder(bakeMuttonCommand2); girl.Notify(); girl.SetOrder(bakeChickenWingCommand1); girl.Notify(); Console.Read(); &#125;&#125; 这样写有几个问题： 第一，真实的情况其实并不是用户点一个菜，服务员就通知厨房去做一个，那样不科学，应该是点完烧烤后，服务员一次通知制作； 第二，如果此时鸡翅没了，不应该是客户来判断是否还有，客户哪知道有没有呀，应该是服务员或烤肉串者来否决这个请求； 第三，客户到底点了哪些烧烤或饮料，这是需要记录日志的，以备收费，也包括后期的统计； 第四，客户完全有可能因为点的肉串太多而考虑取消一些还没有制作的肉串。这些问题都需要得到解决。 第三版：松耦合后 服务员类 1234567891011121314151617181920212223242526272829303132333435// 服务员public class Waiter&#123; private IList&lt;Command&gt; orders = new List&lt;Command&gt;(); // 设置订单 public void SetOrder(Command command) &#123; if (command.ToString() == "命令模式.BakeChickenWingCommand") &#123; Console.WriteLine("服务员：鸡翅没有了，请点别的烧烤。"); &#125; else &#123; orders.Add(command); Console.WriteLine("增加订单：" + command.ToString() + " 时间：" + DateTime.Now.ToString()); &#125; &#125; // 取消订单 public void CancelOrder(Command command) &#123; orders.Remove(command); Console.WriteLine("取消订单：" + command.ToString() + " 时间：" + DateTime.Now.ToString()); &#125; // 通知全部执行 public void Notify() &#123; foreach (Command cmd in orders) &#123; cmd.ExcuteCommand(); &#125; &#125;&#125; 客户端代码实现 12345678910111213141516171819202122class Program&#123; static void Main(string[] args) &#123; //开店前的准备 Barbecuer boy = new Barbecuer(); Command bakeMuttonCommand1 = new BakeMuttonCommand(boy); Command bakeMuttonCommand2 = new BakeMuttonCommand(boy); Command bakeChickenWingCommand1 = new BakeChickenWingCommand(boy); Waiter girl = new Waiter(); //开门营业 顾客点菜 girl.SetOrder(bakeMuttonCommand1); girl.SetOrder(bakeMuttonCommand2); girl.SetOrder(bakeChickenWingCommand1); //点菜完闭，通知厨房 girl.Notify(); Console.Read(); &#125;&#125; 执行结果： 12345日志：命令模式.烤羊肉串 时间：200x-xx-xx xx:xx:xx 日志：命令模式.烤羊肉串 时间：200x-xx-xx xx:xx:xx 服务员：鸡翅没有了，请点别的烧烤。烤羊肉串！烤羊肉串！ 命令模式1命令模式（Command）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 命令模式（Command）结构图 Command类，用来声明执行操作的接口。 1234567891011abstract class Command&#123; protected Receiver receiver; public Command(Receiver receiver) &#123; this.receiver = receiver; &#125; abstract public void Execute();&#125; ConcreteCommand类，将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。 12345678910class ConcreteCommand : Command&#123; public ConcreteCommand(Receiver receiver) : base(receiver) &#123; &#125; public override void Execute() &#123; receiver.Action(); &#125;&#125; Invoker类，要求该命令执行这个请求。 1234567891011121314class Invoker&#123; private Command command; public void SetCommand(Command command) &#123; this.command = command; &#125; public void ExecuteCommand() &#123; command.Execute(); &#125;&#125; Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。 1234567class Receiver&#123; public void Action() &#123; Console.WriteLine("执行请求！"); &#125;&#125; 客户端代码，创建一个具体命令对象并设定它的接收者。 123456789101112131415161718static void Main(string[] args)&#123; // 本来的代码执行是这样 // Receiver r = new Receiver(); // r.Action()直接执行 Receiver r = new Receiver(); // r.action已经变成了c对象的一个方法。 Command c = new ConcreteCommand(r); Invoker i = new Invoker(); i.SetCommand(c); // 这个地方就是定义里说的可用不同的请求对客户进行参数化 // 这里是排队，记录，撤销操作 i.ExecuteCommand(); Console.Read();&#125; 命令模式作用命令模式的优点： 1.它能较容易地设计一个命令队列； 2.在需要的情况下，可以较容易地将命令记入日志； 3.允许接收请求的一方决定是否要否决请求。 4.可以容易地实现对请求的撤销和重做； 5.由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。 其实还有最关键的优点就是命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。 但是否是碰到类似情况就一定要实现命令模式呢？ 这就不一定了，比如命令模式支持撤销/恢复操作功能，但你还不清楚是否需要这个功能时，你要不要实现命令模式？ 要，万一以后需要就不好办了。 其实应该是不要实现。敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。 学习设计模式的时候，要抛弃所有的可以直接通过函数执行的想法，所有的功能都必须通过类来完成。 命令模式的缺点： 可能产生大量具体命令类。因为针对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 某个方法需要完成某一个功能，完成这个功能的大部分步骤已经确定了，但可能有少量具体步骤无法确定，必须等到执行该方法时才可以确定。具体一点：假设有个方法需要遍历某个数组的数组元素，但无法确定在遍历数组元素时如何处理这些元素，需要在调用该方法时指定具体的处理行为。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[［设计模式］唠唠依赖注入]]></title>
    <url>%2F2019%2F07%2F17%2F%EF%BC%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%BD%E5%94%A0%E5%94%A0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 啥是依赖注入(Dependency injection)？ 直接上例子： 这不是依赖注入！123456789101112131415161718192021//这不是依赖注入！！！class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct() &#123; $this-&gt;bar = new Bar(); &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$foo = new Foo(); 这就是依赖注入12345678910111213141516171819202122//这就是依赖注入。。。class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct(Bar $bar) &#123; $this-&gt;bar = $bar; &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$bar = new Bar();$foo = new Foo($bar); 这也是依赖注入123456789101112131415161718192021222324252627//这也是依赖注入。。。class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct() &#123; &#125; public function setBar(Bar $bar) &#123; $this-&gt;bar = $bar; &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$bar = new Bar();$foo = new Foo();$foo-&gt;setBar($bar); 依赖注入就是new好了依赖的对象注入进去，而不是在类中显式的new一个依赖的对象。其实，就是这么简单。。。 为啥要用依赖注入？虽然思想简单，但是在降低耦合度方面作用巨大。 依赖注入都可以怎么用下面举个例子说明（just for demonstration）： 比如我们做了个小游戏，里面的男人可以亲自己的妻子。123456789101112131415161718192021222324abstract class Human&#123;&#125;class Woman extends Human&#123;&#125;class Man extends Human&#123; protected $wife; public function __construct() &#123; $this-&gt;wife = new Woman(); &#125; public function kissWife() &#123; echo "the man kissed his wife"; &#125;&#125;$man = new Man();$man-&gt;kissWife(); 玩的人越来也多，新需求随之而来。。。 产品经理（腐腐）：妻子改成可以是男的吧，好多用户有这个需求，这样玩我们游戏的肯定更多。 程序员（猿猿）心里：擦，Wife又可以是Man，又可以是Woman，这可咋整。 这个时候，依赖注入就可以闪亮登场了。123456789101112131415161718192021222324252627282930abstract class Human&#123;&#125;class Woman extends Human&#123;&#125;class Man extends Human&#123; protected $wife; public function setWife(Human $human) &#123; $this-&gt;wife = $human; &#125; public function kissWife() &#123; echo "the man kissed his wife"; &#125;&#125;$man = new Man();$man-&gt;setWife(new Woman());$man-&gt;kissWife();$anotherMan = new Man();$anotherMan-&gt;setWife(new Man());$anotherMan-&gt;kissWife(); 这里我们看到，依赖注入的可以是继承依赖类的任何类，所以现在Man的Wife既可以是Woman也可以是Man。 玩的人越来也多，新需求随之而来。。。 产品经理（宅宅）：把妻子改成伴侣吧，伴侣里面除了Man和Woman再加个Cat，好多用户有这个需求，这样玩我们游戏的肯定更多。 程序员（猿猿）心里：擦，又是Man又是Woman还有Cat，幸好我会依赖注入。123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Human&#123;&#125;interface canBePartner&#123;&#125;class Cat implements canBePartner&#123;&#125;class Woman extends Human implements canBePartner&#123;&#125;class Man extends Human implements canBePartner&#123; protected $partner; public function setPartner(canBePartner $partner) &#123; $this-&gt;partner = $partner; &#125; public function kissPartner() &#123; echo "the man kissed his partner"; &#125;&#125;$man = new Man();$man-&gt;setPartner(new Woman());$man-&gt;kissPartner();$man2 = new Man();$man2-&gt;setPartner(new Man());$man2-&gt;kissPartner();$man3 = new Man();$man3-&gt;setPartner(new Cat());$man3-&gt;kissPartner(); 这里我们看到，依赖注入不但可以是继承依赖类的所有子类，也可以是实现依赖接口的所有类。 所以如果我们在伴侣中再加入一个Dog，只需要让它实现canBePartner接口就可以了：12345class Dog implements canBePartner&#123;&#125;$man = new Man();$man-&gt;setPartner(new Dog()); 实际应用依赖注入虽然降低了耦合度，但是也有缺点，就是需要我们自己管理注入的对象。 所以，在实际应用中，我们通常需要实现一个容器去管理和实现依赖对象的注入。实际上，PHP的常用Web框架中都是这么做的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Cluster]]></title>
    <url>%2F2019%2F07%2F06%2FMySQL-Cluster%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： MySQL Cluster也称为MySQL集群或者MySQL簇，是一种允许在无共享架构（SNA，share nothing architecture）系统中部署“内存”数据库集群的技术。通过无共享架构，可以使系统使用廉价的硬件获取持续的高可用性。本章首先介绍了MySQL集群的基础知识，重点介绍了MySQL集群的环境搭建方法。 MySQL Cluster简介MySQL Cluster是一个高性能、可扩展、集群化的数据库技术。MySQL集群是一种分布式架构，通常由一组计算机构成，每台计算机运行至少一个MySQL集群进程，每个MySQL集群进程对应一个“节点”（node）。通过节点间的切换，可以确保集群出现节点故障或者网络故障时的持续高可用性。 说明在很多情况下，一个“节点”对应一台计算机。但在讨论MySQL集群时，一个“节点”表示的是一个“集群进程”。如果在单台计算机开启了多个集群进程，那么这台计算机上存在了多个节点。 MySQL集群的组成MySQL集群由4类节点组成：SQL节点、数据节点、管理节点以及客户机节点。 1．客户机节点 为了实现MySQL集群中数据的增、删、改、查，需要通过MySQL客户机编辑、提交SQL语句（这里将MySQL客户机简称为客户机节点）。MySQL集群中最简单的客户机节点是打开CMD命令提示符窗口，然后输入“mysql -h localhost -u root -p”命令，接着连接MySQL 服务器。 2．SQL节点 SQL节点主要用于提供MySQL服务，提供了访问MySQL集群中数据节点中数据的“接口”。在MySQL集群体系中，客户机节点通过SQL节点访问数据节点中的数据，任意一个数据节点都是连接到所有的SQL节点的。当任意一个SQL节点出现故障时，客户机节点都可以将请求转移到其他SQL节点。当然，数据库开发人员应该提供一种当一个SQL节点出现故障时，客户机节点能够自行切换到其他SQL节点的机制。 事实上，MySQL集群主要是通过将NDB Cluster内存集群存储引擎与MySQL服务器集成实现的，因此SQL节点的MySQL服务必须支持NDB存储引擎才能实现MySQL集群。而传统的MySQL服务默认情况下仅支持8种存储引擎（不支持NDB Cluster存储引擎），为了实现MySQL集群，需下载、安装支持MySQL集群的MySQL服务软件。 通常，SQL节点使用命令“mysqld–ndbcluster”启动，或在my.ini配置文件的[mysqld]选项组中添加“ndbcluster”参数，使得SQL节点支持NDB Cluster 存储引擎。每个SQL节点对应一个mysqld.exe进程。 说明NDB是网络数据库（network database）的缩写。NDB存储引擎支持所有通常的MySQL数据类型和SQL语句，该存储引擎还提供了完整的事务支持，而且是ACID兼容的。 3．数据节点 数据节点用于存储所有属于MySQL集群的数据，这些数据在数据节点之间被复制，以保证在一个或多个数据节点出现故障时，MySQL集群仍然持续可用。可以这样理解：在MySQL集群体系中，客户机节点通过SQL节点访问数据节点中的数据，任意一个SQL节点都是连接到所有的数据节点的，当任意一个数据节点出现故障时，SQL节点都可以将请求转移到另一个数据节点。 数据节点是通过命令“ndbd”启动的，每个数据节点对应一个ndbd.exe进程。 MySQL集群中的事务安全是由数据节点保证的，任意一个事务产生的数据变化会同时反映到所有数据节点中；某个事务在执行过程中，某个数据节点数据更新的失败会导致整个事务的回滚。说明 每个数据节点中都有两个检查点，即本地检查点以及全局检查点。本地检查点的目的是将内存中的数据和硬盘上的数据进行同步。全局检查点是在各节点中进行通信，以保证事务的一致性。 4．管理节点 管理节点用于控制MySQL集群启动时的初始配置，管理MySQL集群内的其他节点。管理节点的初始配置由集群配置文件决定，集群配置文件默认的文件名为config.ini，该配置文件提供了数据节点和SQL节点的全局配置信息，包括数据、索引所占用内存大小、各个节点的IP地址信息、数据存放的目录信息等。 MySQL集群期间，管理节点会获取其他节点的状态和错误信息，并将这些信息写入集群日志，反馈给集群中的其他所有节点。例如，当数据节点出现新的事件时，数据节点将关于该事件的信息传输到管理节点，然后由管理节点将事件信息写入集群日志，并反馈给其他节点。由于管理节点担任了集群中各个节点的沟通工作，因此在启动其他节点之前，应该首先启动管理节点。管理节点是通过命令“ndb_mgmd”启动的，每个管理节点对应一个ndb_mgmd.exe进程。 说明管理节点只在集群启动和发生配置变化的时候起作用，集群正常运行期间停止管理节点，整个集群都将保持在线和可用状态。通常只需配置一个管理节点，然而为了排除单点故障需要，可能需要增加管理节点的数量。 MySQL集群架构可以看出：MySQL集群架构可以简单地分为4个区域，客户机节点、SQL节点、数据节点、管理节点，如图1所示。 图1 MySQL集群架构 MySQL集群中的数据保存在NDB存储引擎的表中（数据节点中），MySQL集群中的表结构保存在MySQL服务器中（SQL节点中）。数据库用户通过客户机节点连接SQL节点访问集群数据，为了保证每个数据节点中的数据均匀分布，在进行数据插入时，SQL节点采用分片的策略将数据均匀分配到不同的数据节点上。管理节点通过管理工具（ndb_mgmd）管理数据节点与SQL节点，MySQL Cluster所有的这些节点构成一个完整的MySQL集群体系。 MySQL Cluster环境搭建目前支持MySQL Cluster的操作系统有Linux、Mac OS X和Solaris，最新版本的MySQL Cluster支持更多的操作系统，包括Windows操作系统。本章以Windows操作系统为例，讲解MySQL Cluster配置的最简单方法。 准备工作MySQL集群的准备工作包括下载MySQL集群软件、准备主机以及网络环境。 主机：对于实验目的的MySQL集群主机而言，MySQL集群可以在一台单独的计算机上成功部署，每个数据节点、SQL节点设置不同的目录以及端口号，即可进行MySQL集群实验。为了让读者更好地理解MySQL集群，本书以5台主机为例部署MySQL集群环境。 网络环境：集群内的主机必须可以通过IP地址相互通信（读者可以通过ping命令判断集群内的主机是否连通）。为了提升MySQL集群的性能以及高可用性，MySQL集群通常在单独的子网中部署（不建议跨越公网部署MySQL集群）。除此之外，还要确保集群内所有主机的防火墙关闭，否者可能导致SQL节点与管理节点无法连接。 MySQL集群软件：所需的MySQL集群软件可以在 MySQL Cluster 官网免费下载，最新的MySQL集群软件提供了两种安装程序：图形化安装包msi与zip免安装压缩文件。本章以最新版本的免安装压缩文件mysql-cluster-gpl-7.3.2-win32.zip为例，讲解MySQL集群的配置过程（对于64 位Windows操作系统而言，读者可以下载mysql- cluster-gpl-7.3.2- winx64.zip）。 说明为了便于学习，读者也可以到本书指定的网址下载MySQL集群软件mysql-cluster-gpl-7.3.2-win32.zip。 假设当前的网络环境存在M、S1、S2、D1、D2五台主机，五台主机的IP 地址如表15-1所示，这些主机可以通过IP地址相互通信，并且它们的防火墙已经关闭。五台主机中，M主机是管理节点，D1和D2主机是数据节点，S1和S2是SQL节点。 表1 MySQL集群环境 对于免安装压缩文件mysql-cluster-gpl-7.3.2-win32.zip，将该文件分别拷贝到M、S1、S2、D1 与D2 五台主机的C盘，接着解压缩至当前文件夹，然后重命名为mysql-cluster，如图2所示。 为了便于启动管理节点、数据节点以及 SQL 节点，将图 15-2 中 bin 目录所在的路径（即C：\mysql-cluster\bin）添加到Path系统环境变量中（方法为：鼠标右键单击我的电脑高级环境变量系统变量Path），如图3所示。 图3 配置MySQL Cluster环境变量说明 如果当前主机存在其他MySQL服务，并且这些MySQL服务bin目录所在的路径已经配置到了 PATH 环境变量，建议删除这些环境变量的配置，或者将图2中bin目录所在的路径配置到Path环境变量最开始处。 数据节点的配置数据节点的配置较为简单，分别将D1与D2主机中mysql-cluster目录中的my-default.ini配置文件重命名为my.ini，然后分别在两个my.ini配置文件中添加[mysql_cluster]选项组，并在该选项组中添加下列参数信息，如下所示。12[mysql_cluster]ndb-connectstring = 192.168.4.15 说明[mysql_cluster]选项组的 ndb-connectstring 参数用于指定当前的数据节点连接哪一台管理节点主机（IP地址为192.168.4.15的M主机提供了管理节点服务）。至此，MySQL集群中的数据节点已经配置完毕。接下来讲解管理节点的配置方法。 SQL节点的配置步骤1：在S1、S2主机上注册MySQL服务。为了方便管理MySQL服务，便于启动、停止SQL节点，分别在S1、S2主机的CMD命令提示符窗口中运行下列命令，注册MySQL服务，执行结果如图15-4所示。cd C：\mysql-cluster\binmysqld.exe -install mysqlcluster▲图15-4 安装MySQL服务说明同一台主机的服务名不能重名，否则将提示如图15-4所示的“The service already exists！”错误信息。出现重名问题后，如果不想修改服务名，可以在CMD命令提示符窗口中运行“sc delete mysqlcluster”命令，删除指定的服务（如果该服务正在运行，删除服务时将失败）。成功注册MySQL服务后，右键单击“我的电脑”，在弹出的菜单中单击“管理”，在弹出的“计算机管理”窗口中双击“服务和应用程序”，然后单击“服务”选项，即可找到刚刚注册的MySQL服务（服务名为“mysqlcluster”），如图15-5所示（建议将MySQL服务的启动类型由自动修改为手动，再进行其他配置工作）。由于名字为“mysqlcluster”的MySQL服务缺失my.ini配置文件，mysqlcluster服务尚不能启动。 步骤2：启动MySQL服务。分别将S1与S2主机中mysql-cluster目录中的my-default.ini配置文件重命名为“my.ini”，然后单击图15-5 中的“启动”链接，或者在CMD 命令提示符窗口输入命令“net start mysqlcluster”启动MySQL服务，接着在CMD命令提示符窗口输入下面的命令，开启MySQL客户机，并连接MySQL服务器，如图15-6所示（默认情况下，初始密码为空字符串）。mysql -h localhost -u root -p▲图15-6 启动MySQL服务执行MySQL命令“show engines;”，执行结果如图15-7所示。从图15-7中可以看到，当前的MySQL服务默认的存储引擎为InnoDB，并且不支持NDB存储引擎。▲图15-7 查看MySQL服务存储引擎 ▲图15-7 查看MySQL服务存储引擎步骤3：开启S1、S2 主机MySQL服务的NDB Cluster 存储引擎支持。单击图15-8中的“停止”链接，或者在CMD命令提示符窗口输入命令“net stop mysqlcluster”，停止S1与S2主机的MySQL服务。分别在S1与S2主机my.ini配置文件的[mysqld]选项组中添加下列参数信息，该参数用于开启MySQL 服务的NDB Cluster 存储引擎支持。ndbcluster步骤4：指定管理节点。分别在S1与S2主机my.ini配置文件的[mysqld]选项组中添加下列参数信息，该参数用于指定当前的SQL节点连接哪一台管理节点主机（IP地址为192.168.4.15的A主机提供了管理节点服务）。ndb-connectstring = 192.168.4.15至此，MySQL集群中的数据节点以及SQL节点已经配置完毕，接下来讲解管理节点的配置方法。由于MySQL集群中SQL节点、数据节点以及管理节点的启动顺序有特殊要求，配置管理节点前，暂且不能启动数据节点与SQL节点。▲图15-8 MySQL服务管理 管理节点的配置管理节点负责管理MySQL集群内所有其他节点，管理节点的配置比较复杂。管理节点的初始配置由集群配置文件决定，该文件配置了所有管理节点、所有数据节点以及所有SQL节点的基本信息。这里将IP地址为192.168.4.15的M主机作为“管理节点”，在M主机C盘根目录创建conf目录，在该目录下创建config.ini文件作为集群配置文件，并输入如下内容：12345678910111213141516[NDBD DEFAULT]NoOfReplicas=2DataDir=C：/data[NDB_MGMD]HostName=192.168.4.15DataDir=C：/logs#数据节点[NDBD]HostName=192.168.4.11[NDBD]HostName=192.168.4.12#SQL节点[MYSQLD]HostName=192.168.4.13[MYSQLD]HostName=192.168.4.14 接着在M主机的C盘创建logs目录，在D1与D2主机的C盘创建data目录。需要注意的是：创建config.ini文件时，一定不能隐藏已知文件类型的扩展名。说明集群配置文件 config.ini 中共有 6 种选项组，分别是[NDB_MGMD DEFAULT]、[NDB_MGMD]、[MYSQLD DEFAULT]、[MYSQLD]、[NDBD DEFAULT]以及[NDBD]。其中，名字中包含有“DEFAULT”的选项组最多出现一次，分别用于配置管理节点、SQL 节点以及数据节点参数的默认值。[NDB_MGMD]、[MYSQLD]以及[NDBD]选项组分别用于单个管理节点、单个 SQL 节点以及单个数据节点的个性化配置。例如，[NDBD DEFAULT]选项组的 DataDir 参数定义了所有数据节点日志信息默认存放的路径；[NDB_MGMD]选项组的 DataDir 参数定义了当前管理节点日志信息存放的路径。每个节点都有各自的个性化配置，例如，每个节点的主机 IP 地址需要使用 HostName参数进行单独的配置。说明NoOfReplicas=2：表示在集群环境中，定义两个数据节点为一个节点组，同组存储的数据是相同的，继而避免了单点故障。可以看出，该参数定义了相同数据的份数，即数据的冗余次数。NoOfReplicas参数只能设置在[NDBDDEFAULT]选项组中，该参数对所有数据节点有效。NoOfReplicas参数的默认值为2，原因在于：假设当前MySQL集群环境存在两个数据节点D1和D2，需要存储两个数据A和B。如果将NoOfReplicas的值设为1，则数据A存储在节点D1上，数据B存储在节点D2上，此时，节点D1与节点D2中只要有一个节点宕机，数据将不再完整。但如果将NoOfReplicas的值设为2，则数据A存储在节点D1上，数据A的“副本”也将存储在节点D2上；数据B存储在节点D2上，数据B的“副本”也将存储在节点D1上，此时，即便节点D1与节点D2中有一个节点宕机，数据依然完整。 MySQL集群的启动MySQL集群的启动包括管理节点的启动、数据节点的启动以及SQL节点的启动，启动顺序依次是：先启动管理节点，接着是数据节点，最后是SQL节点。 步骤1：启动管理节点。 在M主机的CMD命令行窗口中运行如下命令，即可启动管理节点，如图15-9所示。ndb_mgmd ——configdir=c：/conf -f c：/conf/config.ini - initial▲图15-9 管理节点的启动管理节点成功启动后，M主机的C：/logs目录中将自动创建ndb_1.pid文件、ndb_1_cluster.log文件以及ndb_1_out.log文件，如图15-10所示。其中，ndb_1_cluster.log文件以及ndb_1_out.log文件用于记录管理节点的日志信息，ndb_1.pid用于记录管理节点的进程ID。 ▲图15-10 管理节点的日志同时，M主机的C：/conf目录中将自动创建ndb_1_config.bin.1文件，如图15-11所示。该文件是config.ini 集群配置文件的二进制缓存文件“副本”，以后每次重新启动管理节点时，管理节点将直接加载二进制缓存文件ndb_1_config.bin.1的配置信息。如果config.ini集群配置文件的内容发生了变动，需要删除ndb_1_config.bin.1文件后，再启动管理节点。步骤2：查看管理节点的状态。管理节点一旦启动，即可通过管理节点客户机了解管理节点当前的状态信息。打开 M 主机新的CMD命令行窗口，输入ndb_mgm命令，接着输入show命令，即可查看管理节点当前的状态信息，如图15-12所示。▲图15-11 管理节点的二进制缓存文件▲图15-12 查看管理节点的状态图15-12中状态信息的含义依次如下：① 连接本地主机的管理节点，管理节点默认情况下占用的端口号为1186。② 管理节点的配置如下：[ndbd(NDB)] 2 node(s)：两个数据节点。③ id=2 的数据节点主机 IP 地址为 192.168.4.11，该数据节点没有连接管理节点。集群中的每个节点都有唯一的标识。④ id=3的数据节点主机IP 地址为192.168.4.12，该数据节点没有连接管理节点。⑤ [ndb_mgmd(MGM)] 1 node(s)：一个管理节点。⑥ id=1的管理节点主机IP 地址为192.168.4.15。⑦ [mysqld(API)] 2 node(s)：两个SQL节点。⑦ [mysqld(API)] 2 node(s)：两个SQL节点。⑧ id=4的SQL 节点主机IP 地址为192.168.4.13，该SQL节点没有连接管理节点。⑨ id=5的SQL 节点主机IP 地址为192.168.4.14，该SQL节点没有连接管理节点。步骤3：启动D1、D2主机的数据节点。在D1主机的CMD命令行窗口中运行如下命令，执行结果如图15-13所示，此时D1主机的数据节点服务成功启动。从图15-13中可以看出，管理节点默认情况下占用的是1186端口号。Ndbd – initial▲图15-13 启动D1主机的数据节点D1主机的数据节点服务成功启动后，D1主机的C：/data目录中将自动创建如图15-14所示的文件（或者目录）。▲图15-14 D1数据节点的文件在D2主机的CMD命令行窗口中运行如下命令，执行结果如图15-15所示，此时D2主机的数据节点服务成功启动。Ndbd – initial▲图15-15 启动D2主机的数据节点D2主机的数据节点服务成功启动后，D2主机的C：/data目录中将自动创建如图15-16所示的文件（或者目录）。▲图15-16 D2数据节点的文件说明第一次启动数据节点时，或者config.ini配置文件改动后，在ndbd命令后建议添加“– initial”参数，以便进行数据节点的初始化工作。以后再次启动数据节点时，无需添加该参数，否则该参数将会使数据节点删除由早期ndbd进程创建的、用于恢复的任何文件，包括恢复用途的日志文件。 步骤4：启动S1、S2主机的MySQL服务。 重新启动S1、S2主机的MySQL服务，重新执行MySQL命令“show engines;”， 重新启动 S1、S2 主机的MySQL服务，重新执行MySQL命令“show engines;”，执行结果如图15-17所示。从图15-17中可以看到，当前的MySQL 服务已经支持NDB Cluster存储引擎。 步骤5：查看管理节点的状态。 打开M主机新的CMD命令行窗口，输入“ndb_mgm”命令，接着输入“show”命令，查看管理节点当前的状态信息，如图15-18所示。从图15-18可以看出：MySQL集群的所有节点已经成功启动。▲图15-17 查看S1、S2主机的存储引擎▲图15-18 查看管理节点的状态15.2.6 集群测试在S1 主机上打开CMD 命令提示符窗口，并输入“mysql -h localhost -u root -p”命令连接S1 主机的MySQL服务。接着依次输入下面的SQL语句，执行结果如图15-19所示。1234create database student;use student;create table teacher(teacher_no int primary key) engine=ndb;insert into teacher values(1); ▲图15-19 添加测试数据由于 teacher 表的存储引擎是 NDB Cluster，teacher 表对应的表结构文件存放在 S1 主机C：\mysql-clusterdata\student目录下，如图15-20所示。▲图15-20 NDB存储引擎的表结构文件在另一台S2主机上打开CMD 命令提示符窗口，并输入“mysql -h localhost -u root -p”命令连接S2主机的MySQL服务。接着依次输入下面的SQL语句，执行结果如图15-21所示。123show databases;use student;select * from teacher; ▲图15-21 集群测试 可以看到：针对S1主机NDB Cluster存储引擎teacher表的数据更新同步到了S2主机。至此MySQL集群的环境搭建工作已经完毕。鉴于目前MySQL Cluster的成熟案例并不太多，为了便于读者快速地部署 MySQL Cluster 环境，上述 MySQL Cluster 环境搭建方法仅仅是集群的最简化配置方法。有关MySQL Cluster 的复杂配置，读者可以登录MySQL Cluster官网查看具体资料。 说明SQL节点和数据节点在启动的时候需要连接到管理节点读取MySQL集群的配置信息，SQL节点和数据节点启动完成后，管理节点是可以停止工作的。因此MySQL集群过程中，即便管理节点宕机，也不会影响整个集群服务，所以管理节点一般只需要一台主机即可满足应用要求。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句优化]]></title>
    <url>%2F2019%2F07%2F06%2FSQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： SQL语句优化的首要任务是了解SQL语句的频率，分析当前的应用是查询操作频繁还是更新操作频繁。一条频繁执行但是性能糟糕的SQL语句可能对整个应用产生严重的负面影响，例如消耗过多的服务器内存资源，消耗过多的网络带宽。 如果当前的应用更新操作较为频繁，需要解决更新操作带来的并发问题，例如锁等待、死锁问题。可以采用InnoDB存储引擎引入行级锁缩小锁的粒度，解决更新操作的并发问题。读者可以参考事务与锁机制章节的内容，这里不再赘述。 如果当前的应用查询操作较为频繁，此时需要借助explain命令分析select语句，了解select语句的执行情况，分析select语句的性能瓶颈，进而对select语句进行重新设计或者对表结构进行重新设计（例如添加索引或者拆分表），让查询优化器能够更好地工作，提升查询性能，这是本节着重讲解的内容。 了解SQL的执行频率单个数据库用户对数据库中的少量数据进行操作，无法挖掘数据库的瓶颈。只有数据库服务器长时间运行，并且有批量用户进行频繁操作的时候，数据库服务器的性能瓶颈才会体现出来。 1．每秒查询率QPS每秒查询率QPS（query per second）是指MySQL每秒执行的查询总量，在MySQL 5.1.30及以下版本可以通过Questions状态值每秒内的变化量来近似表示，而从MySQL 5.1.31开始，可以通过Queries状态值每秒内的变化量来近似表示。引入Queries的目的是解决Questions状态变量没有记录存储程序中执行的Query的问题。执行MySQL命令“show status like ‘questions’;”以及“show status like ‘queries’;”可以查看两个状态值，如图1所示。 图1 Queries与Questions Questions：MySQL服务执行的MySQL语句数量，仅仅包含MySQL客户机发送到MySQL服务器的MySQL语句，存储程序中的MySQL语句不包含在内。该状态变量不统计com_ping、com_statistics、com_stmt_prepare、com_stmt_close以及com_stmt_reset命令。 Queries：MySQL服务执行的MySQL语句数量，包括存储程序中的MySQL语句。该状态变量不统计com_ping以及com_statistics命令。 使用MySQL命令“show global status like ‘Com_％’;”可以查看当前MySQL服务实例执行各种SQL语句的次数。由于该命令的统计信息比较多，这里不再一一罗列，下面仅列出几种典型的统计信息。 Com_select：记录了执行select操作的次数。 Com_insert：记录了执行insert操作的次数，对于批量插入的insert操作，只累加一次。 Com_update：记录了执行update操作的次数。 Com_delete：记录了执行delete操作的次数。 通过查看上面的统计信息，可以计算得出当前应用中数据更新语句与查询语句的大致比例，从而了解当前应用偏向于OLTP还是OLAP，以便对存储引擎进行适当调整。针对InnoDB表的更新操作，可以通过Com_commit和Com_rollback得到事务提交的次数以及回滚的次数，如果回滚频繁，就说明应用程序存在某些问题。 说明Com_xxx计数器状态变量表示xxx类型语句执行的次数。 2．数据处理状态信息执行了删除语句，删除语句影响的行数可能为0，使用MySQL命令“show status like ‘handler％’;”可以查看表数据的处理情况。 Handler_delete：表示记录从表中删除的次数。Handler_delete与Com_delete不一样，只要执行delete操作，Com_delete状态值就会增加；只有从表中删除了记录的时候，Handler_delete状态值才会增加。 Handler_commit：表示提交SQL语句数。 Handler_rollback：表示rollback语句的执行次数。 Handler_update：更新表的行数。 Handler_write：向表插入记录的行数。Handler_savepoint：在事务中放置保护点的次数。 Handler_savepoint_rollback：在事务中回滚到保护点的次数。 3．索引使用情况 Handler_read_first：表示索引中第一个键值被读的次数。值如果较高，说明执行了大量的全索引扫描select语句。例如select column_name from table，假设column_name列上有索引。 Handler_read_key：表示根据索引读一行记录的请求数。值如果较高，说明 select 语句正在使用索引进行查询操作。 Handler_read_next：表示按照索引的顺序读下一行记录的请求数，按索引的顺序读取数据。 Handler_read_prev：表示按照索引的顺序读前一行记录的请求数，按索引的倒序读取数据，主要用于优化order by …… desc子句。 说明Handler_xxx计数器状态变量表示xxx类型语句执行的次数或者对记录影响的行数。从MySQL5.6开始，新增了下面的数据处理状态信息。 Handler_read_last：表示索引中最后一个键值被读的次数。对索引字段使用order by 子句时，首先发起第一个索引值的请求，然后是下一个索引值的请求。对索引字段使用order by…desc子句时，首先发起最后一个索引值的请求，然后是前一个索引值的请求。 Handler_read_rnd：表示根据固定位置读一行记录的请求数。如果执行了大量需要对结果进行排序的查询，该值较高。该值较高，通常意味着很多查询扫描了整个表，或者表中没有创建合适的索引。 Handler_read_rnd_next：表示读取数据文件中下一行记录的请求数。如果进行了大量的全表扫描，该值较高。该值较高，通常意味着表中没有创建合适的索引或者查询没有利用好已有的索引。 另外，使用MySQL 命令“show status like ‘Innodb_rows％’;”可以查看InnoDB表记录的查询、更新行数。 Innodb_rows_read：从InnoDB表中读取的记录行数。 Innodb_rows_inserted：向InnoDB表插入的记录行数。 Innodb_rows_updated：更新InnoDB表的记录行数。 Innodb_rows_deleted：从InnoDB表中删除的记录行数。 定位执行效率较低的SQL语句分析Select_scan、Select_full_join、Select_full_range_join、Select_range_check、Handler_read_rnd以及Handler_read_rnd_next等状态信息，可以查看当前MySQL服务实例中select语句没有使用索引的次数。开启慢查询日志，可以在慢查询日志中找出超过某一个时间阈值（该值由 long_query_time参数设置）或者没有使用索引的SQL语句。如果这些SQL语句频繁执行，则可能对MySQL的性能造成负面影响。 慢查询日志只包含成功执行过的SQL语句，在查询语句执行期间，当系统性能出现问题时，使用慢查询日志并不能定位问题，可以使用MySQL命令“show processlist;”查看当前MySQL服务实例正在执行询日志并不能定位问题，可以使用MySQL命令“show processlist;”查看当前MySQL服务实例正在执行的线程，包括线程的状态（例如是否出现表锁现象等）。这样就可以实时地查看MySQL服务实例的执行情况，同时可以对一些表级锁操作进行适当优化。状态信息出现在Command列，一条查询从开始运行到运行结束，它的状态变化多次（共有12个状态）。这里仅罗列其中几个，如表1所示。 表1 线程的常用状态 另外，还可以使用MySQL命令“show status like ‘uptime’;”查询当前MySQL服务实例的工作时间，使用MySQL命令“show status like ‘slow_queries’;”查询当前MySQL服务实例执行的慢查询的次数等信息。 分析select语句有的应用对select语句的性能要求较高，此时单纯依靠开发者的直觉设计select语句，可能导致“理想”与“现实”出现偏差。可以使用explain命令或desc命令分析select语句的执行计划，从而了解select语句的执行情况，进而分析select语句的性能瓶颈，然后对select语句进行重新设计或者对表结构进行重新设计（例如添加索引或者拆分表），让查询优化器能够更好地工作，提升查询性能。explain的语法格式非常简单（desc语法格式与explain的语法格式相同），如下所示： explain select语句 说明desc命令通常用于获取表结构的相关信息。而explain命令通常用于获取查询的执行计划，例如，多个表进行 join 连接运算时，这些表如何连接、连接顺序如何等信息都可以通过explain命令获取。在MySQL 5.7中，使用explain命令还可以获取select、delete、insert、replace以及update等语句的执行计划。然而，一般而言，由于select语句对MySQL的性能影响较大，通常使用explain命令获取select语句的执行计划。explain命令返回了一行或者多行记录，包括了select语句中用到的各个表的信息。 例如，查询姓“张”学生的信息，可以使用下面的SQL语句。使用explain对该SQL语句进行分析，如图2所示。1explain select * from student where student_name like '张_'\G 图2 分析select语句 explain命令的返回信息说明如下。 id：查询的序列号。 select_type：查询语句的类型，可以为以下任何一种。 simple：简单查询语句（不使用union或子查询的查询）。 primary：主查询语句。 union：union中的第二个或后面的select语句。 dependent union：相关子查询中的union语句，union中的第二个或后面的select语句。 union result：union 的合并结果。 subquery：非相关子查询中的第一个select语句。 uncacheable subquery：结果集无法缓存的子查询。 dependent subquery：相关子查询中的第一个select语句。 derived：派生表的select语句。 table：执行该查询时所访问的数据库表。 type：表数据的访问类型。下面给出各种访问类型，按照性能从最佳类型到最坏类型进行排序。 system：结果集中仅有一条记录。这是const连接类型的一个特例。 const：表中有多条记录，但结果集只包含一条记录。例如比较运算符中含有主键字段或者唯一性约束字段，只查询出表的一条记录。 eq_ref：最多只会有一条匹配结果。两个表进行连接运算时，一个表使用主键字段或者唯一性约束字段与另一个表连接，查询出若干条记录。除了const类型，是比较好的连接类型。 ref：两个表进行连接运算时，一个表使用普通索引与另一个表连接，查询出若干条记录。 ref_or_null：两个表进行连接运算时，一个表使用普通索引与另一个表连接（这与ref类似），不同之处在于，检索时额外搜索包含null值的记录。 index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行merge之后再读取表数据。在这种情况下，key字段表示使用了哪个索引，key_len字段表示使用索引时关键字的最长长度（字节数）。 unique_subquery：使用了子查询，且子查询的返回结果包括主键字段或者唯一性约束字段。 index_subquery：使用了子查询，且子查询使用了普通索引（不是主索引或唯一索引）。 range：使用索引字段，检索给定范围的记录。在这种情况下，key字段表示使用了哪个索引。key_len字段表示使用索引时关键字的最长长度（字节数）。在该类型中，ref字段值为NULL。 index：从第一个关键字开始，对索引进行顺序扫描。即便如此，index通常比ALL快，因为索引文件比数据文件小。 all：对表进行全表扫描。说明检索数据时MySQL可能没有使用索引，效率会受到重大影响，应尽可能地优化select语句或者添加索引以避免此类情况的发生。 fulltext：全文索引。说明从全表扫描（full table scan）、索引扫描（index scans）、范围扫描(range scans)、唯一索引查找（unique index lookups）到常量（constants）扫描，访问速度依次递增，访问的数据越来越少。 possible_keys：检索数据时可能使用到的索引，这就意味着possible_keys里面所包含的索引可能在 select 语句实际运行过程中根本没有用到。如果这个字段的值是 null，就表示没有索引被用到。这种情况下，可以检查where子句中哪些字段适合增加索引以提高查询的性能。 key：实际使用的索引。当没有任何索引被用到的时候，这个字段的值就是NULL。想让MySQL强行使用或者忽略在possible_keys 字段中的索引列表，可以在select 语句中使用关键字force index，use index或ignore index。 key_len：使用的索引关键字的长度（字节数）。当key字段的值为NULL时，索引的长度就是NULL。 ref：显示了哪些字段或者常量被用来和索引关键字匹配以从表中查询记录。 rows：返回MySQL认为在查询中应该检索的记录数。 extra：显示了查询中MySQL的附加信息。以下是这个字段的几个不同值的解释。 distinct：当MySQL找到第一个匹配记录后，就不再搜索其他记录了。 not exists：MySQL 能够对查询进行left join 优化，当在当前表中找到一条记录符合left join匹配标准时，就不再搜索更多的记录了。 range checked for each record (index map：#)：MySQL 没找到合适的可用的索引，但是发现来自前面表的字段值已知，部分索引可以使用。 using filesort：当查询中包含order by子句，而且无法利用索引完成排序操作的时候，MySQL查询优化器不得不选择相应的排序算法，在内存或者硬盘上进行排序。应尽可能地优化select语句或者添加索引以避免此类情况的发生。 using index：直接从索引中取得信息，不需要从表中获取数据。这就意味着查询时的字段是索引的关键字。 using temporary：MySQL需要创建临时表存储结果集以完成查询。在group by以及order by查询中比较常见。 using where：如果查询不是读取表的所有数据，也不是仅仅通过索引就可以获取所有需要的数据，则会出现using where信息。 using sort_union(……), using union(……), using intersect(……)：说明如何为index_merge连接类型合并索引扫描。 using index for group-by：类似于访问表的using index 方式，using index for group-by表示在进行group by或distinct查询时，分组字段也在索引中。 Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问NULL 值的时候使用。Impossible WHERE noticed after reading const tables：MySQL 查询优化器通过收集到的统计信息判断出不可能存在的结果。No tables：查询语句中使用不包含任何FROM的子句。Select tables optimized away：当使用某些聚合函数来访问某个索引字段的时候，MySQL 查询优化器会通过索引直接一次定位到所需的数据行，完成整个查询。当然，前提是在查询语句中不能有group by操作。使用下面的SQL语句在student表的student_name字段创建两个普通索引，其中name_index1索引仅仅对学生的“姓”创建了索引。然后重新使用explain命令分析两条select语句，如图14-69所示。1234create index name_index on student (student_name);create index name_index1 on student (student_name(1));explain select * from student where student_name like '张％'\Gexplain select * from student use index (name_index1) where student_name like '张％'\G 图14-69 分析select语句从图中可以分析，第一条select语句执行时使用了name_index索引检索了student表，第二条select语句由于指定使用索引name_index1，执行时使用了name_index1索引检索了student表（注意两个索引的长度key_len的值不相同）。 索引与select语句有时数据库表即使存在了合理的索引，不良的select语句也可能导致索引无法使用，对于InnoDB表而言，这样不仅会降低检索性能，还会导致行级锁升级为表级锁。因此，为了提升select语句的性能，合理的select语句与良好的索引结构缺一不可。（1）对索引关键字字段使用了函数将导致索引无法使用。下面的SQL语句同样实现了查询姓“张”学生的信息，使用explain或desc对该SQL语句进行分析，如图14-70所示。可以看到：由于type为ALL，并且rows的值为6（总共有6条学生信息），可以得知该select语句进行的是全表扫描，当学生表中的记录非常多时，该select语句会导致MySQL的性能瓶颈。事实上，where条件语句后的索引字段加上了函数处理的话，将不能使用索引。1explain select * from student where substring(student_name,1,1)='张'\G ▲图14-70 索引与select语句（1）（2）对索引字段进行模糊查询时，模式的第一个字符是通配符时，将导致索引无法使用。下面的SQL语句实现了查询姓名中含有“张”的学生信息，使用explain或desc对该SQL语句进行分析，如图14-71所示。同样，该select语句会导致MySQL的性能瓶颈。事实上,模糊查询时，查询模式的第一个字符是通配符时，将不能使用索引。 1explain select * from student where student_name like '％张％'\G ▲图14-71 索引与select语句（2）3）违反最左前缀原则的select语句，将导致索引无法使用。例如，下面的SQL语句首先在teacher表的（teacher_name、teacher_contact）组合字段创建一个组合索引name_contact，然后查询teacher_contact值为“11000000000”的教师信息，执行结果如图14-72所示。12create index name_contact on teacher (teacher_name,teacher_contact);explain select * from teacher where teacher_contact='11000000000'\G 上面的select语句并没有使用组合索引name_contact，原因是该select语句违反了最左前缀原则。下面的select语句适用于最左前缀原则，因此使用了组合索引name_contact，执行结果如图14-73所示。explain select * from teacher where teacher_name=’张老师’\G4）使用不等于（not操作符、！=或者&lt;&gt;）作为查询条件，将导致索引无法使用。例如查询不是姓“张”学生的信息，可以使用下面的SQL语句。使用explain或desc对该SQL语句进行分析，执行结果如图14-74所示。1desc select * from student where student_name not like '张_'\G 图14-72 索引与select语句（3）▲图14-73 索引与select语句（4）5）检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引。例如，下面的两条select语句从student表中检索出学号为“2012001”的学生信息，使用explain或desc对这两条select语句进行分析，第二条select语句没有使用索引，如图14-75所示。12desc select * from student where student_no='2012001'\Gdesc select * from student where student_no=2012001\G ▲图14-74 索引与select语句(5) 图14-75 索引与select语句（6） 分页与select对于MySQL而言，只需要指定select语句limit关键字start与length的值，就可以轻松地实现分页功能。但是如果考虑性能因素，当start的值比较大的时候，MySQL的分页性能会明显下降。下面的操作步骤意在说明start的取值与MySQL分页性能之间的关系。步骤1：准备海量测试数据。假设某个新闻发布系统存在新闻表news，主键是news_id，创建news 表的create table 语句如下所示。title表示新闻的标题，content表示新闻的内容，publish_time表示新闻的发布时间。123456create table news(news_id int auto_increment primary key,title char(100) not null,content text,publish_time datetime); 下面的MySQL语句负责创建存储过程insert_n()，该存储过程的功能是向news表中插入n条新闻信息。12345678910111213delimiter $$create procedure insert_n(n int)modifies sql databegindeclare start int default 0;while start&lt;n doset start = start + 1;insert into news values(start,'title','content',now());end while;end;$$delimiter ; 下面的MySQL语句负责调用存储过程insert_n()，向news表插入百万级别的新闻信息。1call insert_n(1000000); 主机执行该存储过程共用了将近 30 分钟的时间，如图14-76所示。▲图14-76 批量插入百万条数据所需要的时间步骤2：数据库用户需要分页浏览其中的10条新闻信息。假设数据库用户分页浏览新闻内容时，每一页最多容纳 10 条新闻信息，当前页的第一条新闻的news_id是900001，最后一条新闻的news_id应该是900010。对于该应用，数据库开发人员可能使用下列方法实现。 方法一：1select * from news limit 900000,10; 方法二：1select * from news order by news_id limit 900000,10; 方法三：1select * from news where news_id&gt;900000 order by news_id limit 10; 或者1select * from news where news_id&gt;900000 limit 10; 比较这3种方法的执行时间，如图14-77、图14-78、图14-79所示。第三种方法耗费的时间最短，大概是0.05秒；前面的两个方法执行时间大致相当，耗时最长，大概是4秒多钟的时间（耗费的时间是第三种方法的80倍）。如果多个数据库用户同时分页浏览新闻信息，第三种方法的性能优势更加明显。 图14-77 方法一的执行时间▲图14-78 方法二的执行时间▲图14-79 方法三的执行时间 分析：limit 900000,10的意思是扫描满足条件的900010行记录，扔掉前面的900000行记录，返回最后的10行记录。对于方法一的select语句而言，实际上执行的是全表扫描，如图14-80所示；对于方法二的select语句而言，使用聚簇索引（或者主键索引）扫描前900010行记录；对于方法三的select语句而言，使用聚簇索引（或者主键索引）进行范围扫描，扫描201394行记录。可以看出：方法三的分页性能更加优越。结论：在进行分页时，如果使用聚簇索引（或者主键索引）进行范围扫描，性能更加优越。 扩展：同样的道理，假设数据库用户分页浏览新闻内容时，每一页最多容纳 10 条新闻信息，当前页的第一条新闻的news_id是900001，最后一条新闻的news_id是900010。那么当前页的下一页可以使用下面的select语句实现。1select * from news where news_id&gt;900010 limit 10; 或者1select * from news where news_id&gt;900010 order by news_id limit 10; 当前页的上一页可以使用下面的select语句实现。1select * from news where news_id&lt;900000 order by news_id desc limit 10; SQL语句其他注意事项SQL语句的编写是一门艺术，在编写SQL语句时，首先应该确保SQL语句能够正确地执行，除此以外，还要考虑SQL语句的效率。下面介绍几点在编写SQL语句时应该注意的问题。 1）获取了不需要的字段。如果应用程序并不需要表的所有字段，避免使用“*”可以减轻MySQL服务器内存压力以及网络带宽压力。2）同一功能的SQL语句，书写格式尽量保持统一。例如查询学生的所有信息，如果A、B程序员分别写为：12select * from student;select * from student;（中间多了空格） 上面两个select语句功能完全相同，并且它们产生的结果以及执行的时间是一样的。但是如果考虑到缓存因素（例如查询缓存Query Cache 开启时），功能相同的两条select语句可能导致查询缓存失效。原因在于：查询缓存匹配的过程是一个区分大小写的hash查找，在缓存中两个相似的查询哪怕是一个单字节不一样，也不会匹配。 3）使用存储程序。存储程序在解析时，自动检查语法错误、权限以及所有对象的依赖性。而等到执行的时候，会直接执行，而不会进行上述检查，这也是存储程序执行效率高的主要原因。当存储程序所依赖的对象发生了变化，MySQL会自动将存储程序的状态设置为INVALID，而存储程序的状态如果是INVALID，则会在下次执行的时候尝试重新解析。4）使用预处理prepared statement。使用预处理prepared statement可以提升SQL语句的性能，原因在于预处理中的SQL语句只需要解析一次，之后执行SQL语句时，就不需要再进行解析操作。如果需要多次执行同一个SQL语句，可以使用预处理prepared statement提升SQL语句的性能。5）根据齿轮原则，多个表进行join连接运算时，使用小结果集启动大结果集。6）当查询结果集只有一行数据时使用limit 1，可以提前终止查询语句的执行。 7）使用连接（join）来代替子查询连接（join）之所以更有效率一些，是因为连接（join）不需要在内存中使用临时表，而子查询需要在内存中创建临时表来完成，逻辑上需要两个步骤的查询工作。14.6.7 profiling性能分析工具通过慢查询日志可以得知哪些SQL语句执行效率低下，通过explain命令可以得知SQL语句的执行计划、索引使用等信息。如果这些信息还不够详细，可以通过profiling性能分析工具得到更准确的SQL执行消耗系统资源的信息。profiling是另一个常用的性能分析工具，profiling能够显示SQL语句执行过程中消耗各种系统资源的信息。通过分析这些信息可以及时发现不良的SQL语句，从而对其进行调优。例如，通过profiling工具可以查看SQL语句的执行时间、System lock 以及Table lock花费的时间等信息，这对定位一条I/O或CPU消耗严重的SQL语句非常重要。默认情况下，profiling是关闭的。 1）使用下面的set命令开启profiling1set profiling=1; 2）使用下面的SQL语句查询姓“张”学生的信息。1select * from student where student_name like '张％'; 3）使用MySQL命令“show profiles;”查看所有SQL语句的执行时间（Duration 的单位为秒），执行结果如图14-81所示。 4）使用MySQL命令“show profile for query 1;”查询Query_ID 值为1 的SQL语句的具体执行时间，如图14-82所示。 ▲图14-82 profiling性能分析工具 5）测试完毕以后，关闭profiling。1set profiling=0;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁资源的优化]]></title>
    <url>%2F2019%2F07%2F04%2F%E9%94%81%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 锁是数据库实现数据并发访问最为重要的资源。不合适的锁粒度，不适当的加锁时机、解锁时机，不恰当的锁作用范围等都会导致锁资源的争用现象，继而出现锁等待问题，甚至是死锁问题。 表级锁资源竞争对于表级锁而言，读锁与写锁是相互排斥的锁，可以简单地理解为：使用表级锁时，对同一个表的查询操作与对同一个表的更新操作是完全串行化的，不能并发地执行，否则将出现锁等待现象。数据库管理员可以使用MySQL命令“show status like ‘table_locks％’;”，通过查看表级锁状态变量的值，分析当前MySQL服务实例上表级锁资源竞争的情况，如图1所示。这两个状态变量的解释如下。 图1 表级锁资源竞争 Table_locks_immediate：使用表级锁后立即释放表级锁的次数，从MySQL服务启动后开始记录。 Table_locks_waited：出现表级锁争用而发生的锁等待次数，从MySQL服务启动后开始记录。如果 Table_locks_waited 的值较大，说明表级锁争用严重，存在严重的并发瓶颈（表级锁不存在死锁问题）。 表级锁资源竞争的解决方案表级锁允许多个线程同时从一个表中进行读取操作，但如果一个线程想要对表进行更新操作，它必须首先获得独占访问。更新期间，所有其他想要访问该表的线程必须等待直到更新完成。通常认为表更新比表检索更重要，因此通常给更新操作赋予更高的优先级，确保了更新操作不被“饿死”，即使该表有很繁重的检索操作。 然而这种设计会导致读操作被“饿死”，假设MySQL客户机A针对MyISAM表执行长时间的select语句A，期间，MySQL客户机B对该表进行更新操作B，MySQL客户机B必须等待直到select语句A完成；MySQL客户机C对该表执行另一个select语句C，由于更新操作B比select语句C优先级高，select语句C等待更新操作B完成，并且等待select语句A完成。MySQL允许改变语句调度的优先级，使得多个MySQL客户机的查询更好地协作，确保特定类型的查询被更早地处理。 ● 使用“-low-priority-updates”选项启动mysqld。此时所有更新操作的优先级比select语句的优先级低。在这种情况下，select语句C将在更新操作B前执行，而不需要等候select语句A完成。● 使用MySQL命令“set low_priority_updates=1;”指定某一个会话中的更新操作使用低优先级。● 向特定的insert、delete、update、replace或者load data语句添加low_priority选项，降低这些操作的优先级。● 向特定的select语句添加high_priority选项，提高检索操作的优先级。● 为max_write_lock_count系统变量指定一个低值启动mysqld，强制MySQL在具体数量的插入完成后临时提高所有等待执行的select语句的优先级。这样允许在一定数量的写锁后存在读锁。● 使用延迟插入。● 对SELECT语句使用sql_buffer_result可以使表锁定时间变短。● 对同一个表混合使用select和delete语句出现问题时，在delete语句中添加limit选项指定删除的记录行数。● 启用并发插入。 MyISAM表上有一个读锁时，原则上其他MySQL客户机不能对该表进行插入操作。但启用并发插入后，MyISAM表支持查询和插入的并发操作，可以在一定程度上缓解表级锁争用问题。全局系统变量concurrent_insert专门用以控制并发插入的行为。该参数值可以使用MySQL命令“show variables like ‘concurrent％’;”进行获取，如图14-84 所示。 图2 concurrent_insert系统变量 ● 当concurrent_insert设置为0时，不允许并发插入。● 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），在一个MySQL客户机读表的同时，MyISAM允许另一个MySQL客户机从表尾插入记录。这也是MySQL的默认设置。● 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。注意：并发插入对隐式表级锁有效，对显式表级锁无效。使用InnoDB替换MyISAM存储引擎是表级锁资源竞争的最有效解决方案。 行级锁的资源竞争数据库管理员可以使用MySQL命令“show status like ‘innodb_row_lock％’;”，通过检查行级锁状态变量的值，分析当前MySQL服务实例上行级锁资源竞争的情况，如图14-85所示。这5个状态变量的解释如下。 ▲图14-85 行级锁的资源竞争 ● Innodb_row_lock_current_waits：当前锁等待的数量，从MySQL服务启动后开始记录。● Innodb_row_lock_time：锁等待的总时间，从 MySQL 服务启动后开始记录。● Innodb_row_lock_time_avg：锁等待的平均时间，从MySQL服务启动后开始记录。该值较大时，说明锁冲突大。● Innodb_row_lock_time_max：最长的一次锁等待时间，从MySQL服务启动后开始记录。● Innodb_row_lock_waits：锁等待的次数，从MySQL服务启动后开始记录。如果Innodb_row_lock_waits以及Innodb_row_lock_time_avg的值较大，说明行级锁争用严重，影响了其他MySQL线程的正常处理，存在严重的并发瓶颈，需要查找出原因并解决。 行级锁资源竞争的解决方案如果行级锁争用严重，可以采取如下方案解决行级锁的并发瓶颈。 ● 尽量缩短锁的生命周期。例如在事务中避免使用长事务，可以将长事务拆分成若干个短事务。在事务中避免使用循环语句。● InnoDB 默认的事务隔离级别是 repeatable read，而 repeatable read 隔离级别使用间隙锁实现InnoDB的行级锁。优化索引，优化SQL语句，避免行级锁升级为表级锁。● 优化表结构，优化SQL语句，尽量缩小锁的作用范围。例如可以将大表拆分成小表，从而缩小锁的作用范围。● 优化表结构，优化SQL语句，尽量缩小锁的作用范围。例如可以将大表拆分成小表，从而缩小锁的作用范围。● 对于InnoDB行级锁而言，设置锁等待超时参数为合理范围，编写锁等待超时异常处理程序，解决发生的锁等待问题（甚至死锁）。● 为避免死锁，一个事务对多条记录进行更新操作时，获得所有记录的排他锁后，再进行更新操作。● 为避免死锁，一个事务对多个表进行更新操作时，获得所有表的排他锁后，再进行更新操作。● 为避免死锁，确保所有关联事务均以相同的顺序访问表和记录。● 必要时，使用表级锁来避免死锁。● 必要时，可以开启全局系统变量innodb_print_all_deadlocks。死锁发生后，死锁所有的相关信息将记录到MySQL错误日志中。 禁用InnoDB间隙锁在事务与锁机制章节曾经提到：利用间隙锁的特点，对查询结果集施加共享锁（lock in share mode）或者排他锁（for update）可以避免幻读现象。然而有时事务中如果存在太多的间隙锁，反而会影响事务之间的并发性能。可以使用下面两种办法禁用InnoDB间隙锁。方法一：把事务隔离级别修改为READ COMMITTED。方法二：将全局变量innodb_locks_unsafe_for_binlog设置为ON（或者1），禁用间隙锁。 事务监控与锁监控新版本的InnoDB存储引擎中，在information_schema数据库中添加了INNODB_TRX、INNODB_LOCKS、InnoDB_LOCK_WAITS三张表。通过这三张表，可以更简单地新版本的 InnoDB 存储引擎中，在 information_schema 数据库中添加了 INNODB_TRX、INNODB_LOCKS、InnoDB_LOCK_WAITS三张表。通过这三张表，可以更简单地监控当前的事务并分析可能存在的锁的问题。例如读者在演示间隙锁与死锁章节的代码时，可以通过查看这三张表的记录信息，监控当前的事务并分析可能存在的锁问题。 INNODB_TRX表包含了当前InnoDB执行的每一条事务信息，其中包括事务的开始时间、事务正在执行的SQL语句等信息，这些内容存储在INNODB_TRX表的24个字段中，限于篇幅这里仅介绍常用的几个字段，如表14-4所示。 表14-4 INNODB_TRX表的常用字段INNODB_LOCKS表包含了当前InnoDB的锁信息（但不包括元数据锁信息，有关元数据锁的相关知识稍后进行介绍），其中包括锁住的事务ID、锁的模式等信息。这些内容存储在INNODB_LOCKS表的10个字段中，如表14-5所示。 INNODB_LOCK_WAITS表包含了当前InnoDB的锁资源信息及被锁住的事务信息，该表由4个字段组成，如表14-6所示。 表14-6 INNODB_LOCK_WAITS表的常用字段 元数据锁metadata locks从MySQL 5.5.3 开始，任何已经开始的事务将一直持有InnoDB表的元数据锁，直到事务提交。除此之外，使用alter table语句对InnoDB表的表结构进行修改时，alter table语句也会持有InnoDB表的元数据锁，直到alter table语句执行结束。下面的操作步骤意在说明元数据锁的存在。 步骤1：打开MySQL客户机A，输入如下命令，将account表的存储引擎修改为InnoDB。alter table account engine=InnoDB; 步骤2：在MySQL客户机A中输入如下命令，首先开启事务，然后查询account表中的所有记录，执行结果如图14-86所示。12start transaction;select * from account; 步骤3：打开MySQL客户机B，输入如下命令，首先开启事务，然后查询account表中的所有记录，执行结果如图14-87所示。12start transaction;select * from account; 步骤4：打开MySQL客户机C，输入如下alter table语句，修改account表结构，向该表增加address字段（默认值为beijing），alter table语句被阻塞，执行结果如图14-88 所示。1alter table account add column address char(32) default 'beijing';]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支管理策略]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 这句话的说明如下：此时master分支没有做任何代码的改动。切换到master分支合并有代码改动的dev，此时默认使用Fast forward模式，git log不会有合并的信息。12345678910$ git checkout -b cb_dev （此时在master分支）$ vim 1.txt （此时在cb_dev分支）$ git commit -am 'test'$ git checkout master$ git merge cb_dev$ git log * e429856 test* 121be0f 更新 xiaoxiaole.json* 649f161 更新 README.md* 3d02ba4 更新消消乐web版为手机预览版本 如果再把分支删了，则分支信息一点都没有了 而如果master也有改动，则是会有分支的信息的。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下—no-ff方式的git merge：首先，仍然创建并切换dev分支：$ git checkout -b devSwitched to a new branch ‘dev’ 修改readme.txt文件，并提交一个新的commit：$ git add readme.txt$ git commit -m “add merge”[dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master：$ git checkout masterSwitched to branch ‘master’ 准备合并dev分支，请注意—no-ff参数，表示禁用Fast forward：$ git merge —no-ff -m “merge with no-ff” devMerge made by the ‘recursive’ strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并后，我们用git log看看分支历史：$ git log —graph（图表） —pretty（pretty）=oneline —abbrev（缩写）-commit e1e9c68 merge with no-ff|\| * f52c633 add merge|/ cf810e4 conflict fixed… 可以看到，不使用Fast forward模式，merge后就像这样： 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样：]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git标签管理]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 快照 关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。快照的作用主要是能够进行在线数据备份与恢复。1、当存储设备发生应用故障或者文件损坏时可以进行快速的数据恢复，将数据恢复某个可用的时间点的状态。2、快照的另一个作用是为存储用户提供了另外一个数据访问通道，当原数据进行在线应用处理时，用户可以访问快照数据，还可以利用快照进行测试等工作。所有存储系统，不论高中低端，只要应用于在线系统，那么快照就成为一个不可或缺的功能。好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。那个存盘就是快照，存储了那个时间点的状态。 标签可以针对某一时间点的版本做标记，常用于版本发布。主要用来发布版本的。 标签就是跟某个commit关联起来，便于发布和查找。 步骤1、切换到某个分支上。12345$ git branch* dev master$ git checkout masterSwitched to branch 'master' 2、然后，敲命令git tag 就可以打一个新标签：打在了最近的那一次commit上1$ git tag v1.0 添加标签说明1$ git tag -a v0.1 -m "version 0.1 released" 如果想打之前的commit，找历史然后再打就行了12$ git log --pretty=oneline --abbrev-commit$ git tag v0.9 6224937 3、推送到远程1git push origin &lt;tagname&gt; 命令git push origin —tags可以推送全部未推送过的本地标签； 4、切换到标签与切换分支命令相同，用git checkout [tagname] 5、删除标签先从本地删除：1$ git tag -d v0.9 然后，从远程删除。删除命令也是push，但是格式如下：1$ git push origin :refs/tags/v0.9 6、查看标签查看所有标签：123$ git taggit show &lt;tagname&gt;查看标签信息$ git tag -l 'v1.4.2.*' 没有不同分支下tag这个概念，也就是说tag不是属于某个分支的，而是全局的tag,是对于commit编号的一个别称。 标签是为了打上版本号信息，不能乱叫，通常用：v1.0, v1.1, v2.0 …或者按发布日期：build-20150702, build-20150910 … 一般来说都是在master分支commit后打标签。 TortoiseGit]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git忽略文件权限和设置大小写敏感]]></title>
    <url>%2F2019%2F06%2F05%2FGit%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[在发布项目到线上时，很多时候需要修改文件的权限，如果是使用git来发布的话，那么下次更新线上文件的时候就会提示文件冲突。明明文件没有修改，为什么会冲突呢？原来git把文件权限也算作文件差异的一部分。下面笔者自己做了个简单的例子来演示这种情况。 忽略文件权限修改版本库的文件的权限，然后使用diff查看下改变。12$ chmod 777 pack.php$ git diff pack.php 可以看到git把文件权限也列入了版本管理。 git中可以加入忽略文件权限的配置，具体如下：1$ git config core.filemode false 这样就设置了忽略文件权限。查看下配置：1$ cat .git/config git忽略文件权限的配置这时候再更新代码就OK了。 文件所有者和所有组的修改不列入版本管理。 对文件名大小写敏感当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.然后你在本地修改文件名为 Readme.md 接着你去提交,发现代码没有变化.控制台输入git status 也不显示任何信息 那么就配置git 使其对文件名大小写敏感git config core.ignorecase false]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL乐观锁与悲观锁]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 悲观并发控制实际上是“先取锁再访问”的保守策略，但影响效率。怎么理解？ 来源：漫话：如何给女朋友解释什么是乐观锁与悲观锁 为什么加购物车的时候还有，但是付款的时候提示没有了呢？是因为下单减库存是用了乐观锁，属于并发控制的一种方式。 并发控制当程序中可能出现并发的情况时，我们就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当用户和其他用户一起操作时，所得到的结果和他单独操作时得到的结果是一样的。 这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。 没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。 我们常说的并发控制，一般都和数据库管理系统（DBMS）有关，在DBMS中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 实现并发控制的主要手段大致可以分为乐观并发控制和悲观并发控制两种。 在开始介绍之前要明确一下：无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。 悲观锁当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。 这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。 之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。 但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 乐观锁乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。 悲观锁实现方式悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下： 在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 我们拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; 我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁：12345678//0.开始事务begin; //1.查询出商品库存信息select quantity from items where id=1 for update;//2.修改商品库存为2update items set quantity=2 where id = 1;//3.提交事务commit; 以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。 如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 乐观锁实现方式使用乐观锁就不需要借助数据库的锁机制了。 乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。 CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 比如前面的扣减库存问题，通过乐观锁可以实现如下：1234//查询出商品库存信息，quantity = 3select quantity from items where id=1//修改商品库存为2update items set quantity=2 where id=1 and quantity = 3; 以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。 以上更新语句存在一个比较重要的问题，即传说中的ABA问题。 比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。 有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：1234//查询出商品信息，version = 1select version from items where id=1//修改商品库存为2update items set quantity=2,version = 3 where id=1 and version = 2; 乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。 除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。 以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。 对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。 有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：1234//修改商品库存update item set quantity=quantity - 1 where id = 1 and quantity - 1 &gt; 0 以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。 以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。 高并发环境下锁粒度把控是一门重要的学问，选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。 如何选择在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。 1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。 2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。 随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL脏读、不可重复读和幻读]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是脏读？ 什么是不可重复读？ 什么是幻读？ “读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。 事务隔离级别在数据库中，事务是要满足ACID的，即满足原子性、一致性、持久性以及隔离性。 在数据库事务的ACID四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级。 但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。 具体的隔离级别和读现象有什么关系呢？ 不同的隔离级别会导致和解决不同的读现象，我先给你介绍下都有哪些读现象吧。 脏读脏读，就是读到了脏数据，即无效数据。 脏读。是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交（commit）到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 打个比方，什么情况下会出现脏读呢，就是我在我的本地修改了AbstractPayExecutor这个类的代码，我还没提交。 为了更快的知道这个类被我改成了什么样，你跑到我的电脑前面阅读了我修改后的代码。这就是脏读了。因为我没有提交代码，说明我随时可能撤销刚刚的修改，这时你之前读取到的数据就是脏数据了。 这种情况下，多个开发者之间的并发性很高，几乎没有任何阻塞。师妹想知道代码最新的是什么样，她就读到了最新代码。但是，这个代码我还没有提交，这就是个脏数据。我们之间的隔离性很差。 这显然不是我们想要看到的现象，我们不希望代码在未提交的状态下被别人读到，所以我们需要提高一点隔离性。 不可重复读为了解决脏读问题，我们决定提高一点隔离性，我在修改代码的时候，不允许她跑到我的电脑前面读代码。她只能读取到我提交后的代码。 当我需要修改AbstractPayExecutor这个类的时候，我需要告诉师妹让她等一下，等我提交完代码她再读。这就有效的解决了脏读，因为师妹读到的代码全部都是我已经提交的代码。 但是，提高了我们之间的隔离性，并发性就降低了一些。因为她要等我提交代码后才能阅读。 脏读没有了，但是还会存在不可重复读问题。 不可重复读，就是开始我说的那种AbstractPayExecutor中常量被删除的现象吗。 差不多吧。 我们已经提高了一点隔离级别，使得脏读现象没有了。但是并没有办法避免以下现象： 师妹在阅读AbstractPayExecutor的代码，代码中定义了一个LOGGER常量。然后我修改了代码，把这个常量删除了，并提交。师妹更新了代码继续阅读，但是她却发现LOGGER这个常量没有了。 两次读取，得到的文件内容不一样。严重了影响了她的学习进度。这就是不可重复读现象。 不可重复读。是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 那么有没有可能我在读某个类的代码的时候，你先不要修改这个类呢？这就是进一步提升了隔离性了。 幻读为了让师妹可以更好的学习代码。我们约定好，当她阅读某个类的代码的时候，她通知我一下，然后我就不修改这个类的代码。避免出现不可重复读的情况。 这样，我们之间的并发性就又降低了一些。不仅仅她阅读哪个类有了一些限制，我修改哪个类也有了要求了。 就这样相安无事了一段时间，师妹又来找我了。 师兄呀，你又新增了几个类了么，刚刚我看的时候只有20几个类呀。 嗯嗯，是的呀，我又增加了2个枚举类和1个Java类。 好吧，那我只能继续阅读这几个新增的类了。 在提升了隔离性之后，虽然我不会修改师妹正在阅读的类，师妹也不会阅读我正在修改的类。但是我可能会增加或者删除几个类。这时候和师妹之前读取到的类的总个数就有了变化。也就是说，她之前读到的数据就不准确了。这就是幻读。 幻读。指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却有n+1条记录，这就好像产生了幻觉。 幻读是不可重复读的一种特殊场景。 幻读的情况其实也是可以解决的，就是我读代码的时候你不要做任何修改。 如果想要解决幻读问题，那么就只能在师妹阅读代码的时候，我什么也不做了。这样我们之间的隔离性最高，但是并发性就最低了。 要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。 总结事务的隔离性上，从低到高可能产生的读现象分别是：脏读、不可重复读、幻读。 脏读指读到了未提交的数据。 不可重复读指一次事务内的多次相同查询，读取到了不同的结果。 幻读是不可重复读的特殊场景。一次事务内的多次范围查询得到了不同的结果。 通过在写的时候加锁，可以解决脏读。 通过在读的时候加锁，可以解决不可重复读。 通过串行化，可以解决幻读。 以上这几种解决方案其实是数据库的几种隔离级别。 背景数据库的锁是在多线程高并发的情况下用来保证数据稳定性和一致性的一种机制。MySQL根据底层存储引擎的不同，锁的支持粒度和实现机制也不同。MyISAM只支持表锁，InnoDB支持行锁和表锁。目前MySQL默认的存储引擎是InnoDB，这里主要介绍InnoDB的锁。 InnoDB存储引擎使用InnoDB的两大优点：一是支持事务；二是支持行锁。 MySQL的事务在高并发的情况下事务的并发处理会带来几个问题 1、脏读：指在事务A处理过程里读取到了事务B未提交的事务中的数据。比如在转账的例子中：小A开了一个事务给小B转了1000块，还没提交事务的时候就跟小B说，钱已经到账了。这个时候小B去看了一下余额，发现果真到账了（然后就开开心心刷抖音去了），这个时候小A回滚了事务，把1000块又搞回去了。小B刷完抖音再去看下余额，发现钱又不见了。 2、不可重复读：指在一个事务执行的过程中多次查询某一数据的时候结果不一致的现象，由于在执行的过程中被另一个事务修改了这个数据并提交了事务。比如：事务A第一次读小明的年龄是18岁，此时事务B将小明的年龄改成了20并提交了，这个时候事务A再次读取小明的年龄发现是20，这就是同一条数据不可重复读。 3、幻读：幻读通常指的是对一批数据的操作完成后，有其他事务又插入了满足条件的数据导致的现象。比如：事务A将数据库性别为男的状态都改成1表示有钱人，这个时候事务B又插入了一条状态为0没钱人的记录，这个时候，用户再查看刚刚修改的数据时就会发现还有一行没有修改，这就出现了幻读。幻读往往针对insert操作，脏读和不可重复读针对select操作。 由于高并发事务带来这几个问题，所以就产生了事务的隔离级别。 Read uncommitted（读未提交）：最低级别，任何情况都无法保证。 Read committed（读已提交）：可避免脏读的发生。 Repeatable read（可重复读）：可避免脏读、不可重复读的发生。 Serializable（串行化）：可避免脏读、不可重复读、幻读的发生。 InnoDB 常见的几种锁机制1、共享锁和独占锁（Shared and Exclusive Locks），InnoDB通过共享锁和独占所两种方式实现了标准的行锁。共享锁（S锁）：允许事务获得锁后去读数据，独占锁（X锁）：允许事务获得锁后去更新或删除数据。一个事务获取的共享锁S后，允许其他事务获取S锁，此时两个事务都持有共享锁 S，但是不允许其他事务获取X锁。如果一个事务获取的独占锁（X），则不允许其他事务获取S或者X锁，必须等到该事务释放锁后才可以获取到。大家可以通过下面的SQL感受下。 123456789101112131415161718# T1START TRANSACTION WITH CONSISTENT SNAPSHOT;SELECT * FROM category WHERE category_no = 2 lock in SHARE mode; #共享锁SELECT * FROM category WHERE category_no = 2 for UPDATE; #独占锁COMMIT;# T2START TRANSACTION WITH CONSISTENT SNAPSHOT;SELECT * FROM category WHERE category_no = 2 lock in SHARE mode; #共享锁UPDATE category set category_name = '动漫' WHERE category_no = 2; #独占锁COMMIT; 意向锁（Intention Locks），上面说过InnoDB支持行锁和表锁，意向锁是一种表级锁，用来指示接下来的一个事务将要获取的是什么类型的锁（共享还是独占）。意向锁分为意向共享锁（IS）和意向独占锁（IX），依次表示接下来一个事务将会获得共享锁或者独占锁。意向锁不需要显示的获取，在我们获取共享锁或者独占锁的时候会自动的获取，意思也就是说，如果要获取共享锁或者独占锁，则一定是先获取到了意向共享锁或者意向独占锁。 意向锁不会锁住任何东西，除非有进行全表请求的操作，否则不会锁住任何数据。存在的意义只是用来表示有事务正在锁某一行的数据，或者将要锁某一行的数据。原文：Intention locks are table-level locks that indicate which type of lock （shared or exclusive） a transaction requires later for a row in a table. 记录锁（record Locks），锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么InnoDB会创建一个隐藏的聚簇索引加锁。所以我们在进行查询的时候尽量采用索引进行查询，这样可以降低锁的冲突。 间隙锁（Gap Locks），间隙锁是一种记录行与记录行之间存在空隙或在第一行记录之前或最后一行记录之后产生的锁。间隙锁可能占据的单行，多行或者是空记录。通常的情况是我们采用范围查找的时候，比如在学生成绩管理系统中，如果此时有学生成绩60，72，80，95，一个老师要查下成绩大于72的所有同学的信息，采用的语句是select * from student where grade &gt; 72 for update，这个时候InnoDB锁住的不仅是80，95，而是所有在72-80，80-95，以及95以上的所有记录。为什么会这样呢？实际上是因为如果不锁住这些行，那么如果另一个事务在此时插入了一条分数大于72的记录，那会导致第一次的事务两次查询的结果不一样，出现了幻读。所以为了在满足事务隔离级别的情况下需要锁住所有满足条件的行。 Next-Key Locks，NK 是一种记录锁和间隙锁的组合锁。是2和3的组合形式，既锁住行也锁住间隙。并且采用的左开右闭的原则。InnoDB对于查询都是采用这种锁的。 举个例子 123456789101112131415161718192021222324252627282930313233343536CREATE TABLE `a` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `uid` int(10) unsigned DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_uid` (`uid`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;INSERT INTO `a`(uid) VALUES (1);INSERT INTO `a`(uid) VALUES (2);INSERT INTO `a`(uid) VALUES (3);INSERT INTO `a`(uid) VALUES (6);INSERT INTO `a`(uid) VALUES (10);# T1START TRANSACTION WITH CONSISTENT SNAPSHOT; //1SELECT * FROM a WHERE uid = 6 for UPDATE; //2COMMIT; //5# T2START TRANSACTION WITH CONSISTENT SNAPSHOT; //3INSERT INto a(uid) VALUES(11);INSERT INto a(uid) VALUES(5); //4INSERT INto a(uid) VALUES(7);INSERT INto a(uid) VALUES(8);INSERT INto a(uid) VALUES(9);SELECT * FROM a WHERE uid = 6 for UPDATE;COMMIT;ROLLBACK; 按照上面 1，2，3，4的顺序执行会发现第4步被阻塞了，必须执行完第 5 步后才能插入成功。这里我们会很奇怪明明锁住的是uid=6的这一行，为什么不能插入 5 呢？原因就是这里采用了next-key的算法，锁住的是（3,10）整个区间。感兴趣的可以试一下。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Force Index]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL-Force-Index%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 以下的文章主要介绍的是MySQL Force Index强制索引，以及其他的强制操作其优先操作的具体操作步骤如下：我们以MySQL中常用的hint来进行详细的解析。 强制索引MySQL FORCE INDEX1SELECT * FROM TABLE1 FORCE INDEX (FIELD1) … 以上的SQL语句只使用建立在FIELD1上的索引，而不使用其它字段上的索引。 忽略索引 IGNORE INDEX1SELECT * FROM TABLE1 IGNORE INDEX (FIELD1, FIELD2) … 在上面的SQL语句中，TABLE1表中FIELD1和FIELD2上的索引不被使用。 关闭查询缓冲 SQL_NO_CACHE SELECT SQL_NO_CACHE field1, field2 FROM TABLE1;有一些SQL语句需要实时地查询数据，或者并不经常使用（可能一天就执行一两次）,这样就需要把缓冲关了,不管这条SQL语句是否被执行过，服务器都不会在缓冲区中查找，每次都会执行它。 MySQL force Index 强制索引：强制查询缓冲 SQL_CACHE1SELECT SQL_CALHE * FROM TABLE1; 如果在my.ini中的query_cache_type设成2，这样只有在使用了SQL_CACHE后，才使用查询缓冲。 优先操作 HIGH_PRIORITY HIGH_PRIORITY可以使用在select和insert操作中，让MySQL知道，这个操作优先进行。1SELECT HIGH_PRIORITY * FROM TABLE1; 滞后操作 LOW_PRIORITY LOW_PRIORITY可以使用在insert和update操作中，让MySQL知道，这个操作滞后。1update LOW_PRIORITY table1 set field1= where field1= … 延时插入 INSERT DELAYED1INSERT DELAYED INTO table1 set field1= … INSERT DELAYED INTO，是客户端提交数据给MySQL，MySQL返回OK状态给客户端。而这是并不是已经将数据插入表，而是存储在内存里面等待排队。当MySQL有空余时，再插入。另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。坏处是，不能返回自动递增的ID，以及系统崩溃时，MySQL还没有来得及插入数据的话，这些数据将会丢失。 强制连接顺序 STRAIGHT_JOIN1SELECT TABLE1.FIELD1, TABLE2.FIELD2 FROM TABLE1 STRAIGHT_JOIN TABLE2 WHERE … 由上面的SQL语句可知，通过STRAIGHT_JOIN强迫MySQL按TABLE1、TABLE2的顺序连接表。如果你认为按自己的顺序比MySQL推荐的顺序进行连接的效率高的话，就可以通过STRAIGHT_JOIN来确定连接顺序。 MySQL force Index 强制索引:强制使用临时表 SQL_BUFFER_RESULT SELECT SQL_BUFFER_RESULT * FROM TABLE1 WHERE …当我们查询的结果集中的数据比较多时，可以通过SQL_BUFFER_RESULT.选项强制将结果集放到临时表中，这样就可以很快地释放MySQL的表锁（这样其它的SQL语句就可以对这些记录进行查询了），并且可以长时间地为客户端提供大记录集。 分组使用临时表 SQL_BIG_RESULT和SQL_SMALL_RESULT1SELECT SQL_BUFFER_RESULT FIELD1, COUNT(\*) FROM TABLE1 GROUP BY FIELD1; 一般用于分组或DISTINCT关键字，这个选项通知MySQL，如果有必要，就将查询结果放到临时表中，甚至在临时表中进行排序。SQL_SMALL_RESULT比起SQL_BIG_RESULT差不多，很少使用。 创建索引索引的创建可以在CREATE TABLE语句中进行，也可以单独用CREATE INDEX或ALTER TABLE来给表增加索引。以下命令语句分别展示了如何创建主键索引（PRIMARY KEY），唯一索引（UNIQUE）和普通索引（INDEX）的方法。 12345678910111213mysql&gt;ALTER TABLE `表名` ADD INDEX `索引名` (column list); mysql&gt;ALTER TABLE `表名` ADD UNIQUE `索引名` (column list); mysql&gt;ALTER TABLE `表名` ADD PRIMARY KEY `索引名` (column list); mysql&gt;CREATE INDEX `索引名` ON `表名` (column_list); mysql&gt;CREATE UNIQUE INDEX `索引名` ON `索引名` (column_list); mysql&gt;ALTER TABLE `表名` ADD INDEX (`id`,`order_id`);给article表增加id索引，order_id索引 mysql&gt;ALTER TABLE `表名` ADD INDEX `id`;//给article表增加id索引 2、重建索引 重建索引在常规的数据库维护操作中经常使用。在数据库运行了较长时间后，索引都有损坏的可能，这时就需要重建。对数据重建索引可以起到提高检索效率。 Sql代码 收藏代码mysql&gt; REPAIR TABLE table_name QUICK; 3、查询数据表索引1mysql&gt; SHOW INDEX FROM `table_name`; 4、删除索引 删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下： 1234567mysql&gt;DROP index `index_name` ON `table_name` (column list); mysql&gt;ALTER TABLE `table_name` DROP INDEX `index_name` (column list); mysql&gt;ALTER TABLE `table_name` DROP UNIQUE `index_name` (column list); mysql&gt;ALTER TABLE `table_name` DROP PRIMARY KEY `index_name` (column list); 在前面的三条语句中，都删除了table_name中的索引index_name。而在最后一条语句中，只在删除PRIMARY KEY索引中使用，因为一个表只可能有一个PRIMARY KEY索引，因此也可不指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。 5、强制使用索引 1mysql&gt;SELECT * FROM TABLE1 FORCE INDEX (索引名或PRIMARY) ; 6、联合索引 1mysql&gt;alter table test add key id_a_b(a,b) ; 对于联合索引当条件为 a=1 and b=1 则使用索引 ，当a=1 时也使用索引 当单独使用b=1时则不使用索引。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Rewrite with Htaccess理解与技巧]]></title>
    <url>%2F2019%2F05%2F15%2FApache-Rewrite-with-Htaccess-%E7%90%86%E8%A7%A3%E4%B8%8E%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： .htaccess文件是做什么用的？ 一、开启Rewrite功能进行以下操作开启Rewrite模块（CentOS7编译安装）。 找到apache的配置文件httpd.conf并寻找下面这行：1LoadModule rewrite_module modules/mod_rewrite.so 将前面“#”去掉，如果不存在则添加此句。 确认是否已经开启模块了： 123$ cd /usr/local/apache/bin$ sudo apachectl -M | grep rewriterewrite_module (shared) 接着就可以开始在Site Config里面编写所需的RewriteRule了。 在理解Rewrite的过程中，常常会出现与之搭配的.htaccess文件。.htaccess称作「Hypertext Access」，以一个文件夹为单位改变Apache设定的配置（Override Config），简单来说就是可以根据每个文件夹Override原本Site Config，可以针对一个文件夹改写网址，所以RewriteRule并非就只能写在.htaccess当中哦！ 但本篇文章还是会以使用.htaccess作为范例，若要打开Override的功能，只要修改Site Config，加入AllowOverride All就可以了（例如/usr/local/apache/conf/vhost/example.conf）123&lt;Directory "/var/www/html"&gt; AllowOverride All&lt;/Directory&gt; All、FlieInfo都可以让.htaccess使用Rewrite功能，详情可以参考官方设定值的意义。 二、Rewrite Rule基本用法 就是改写网址条件的规则，它的写法结构如下：1RewriteRule [match_uri] [rewrite_uri] [flags] match_uri：符合Pattern的URI rewrite_uri：将被改写的URI 这两个也都可以使用正则表达式来写，一个Rule范例长这样：1Rewrite ^match\.html$ rewrite.html [NC,L] 意义等同于以下Pseudo Code：1234567// 假设输入网址：http://domain.com/a/b/c.htmluri = a/b/c.htmlif (uri.match("match.html") &#123; url = "rewrite.html"&#125; RewriteRule的Flag 最后面的flags代表设定Rule的行为，可用逗号代表多个Flag，中间不能有空格，介绍以下常用的： [L]：Last，代表成功执行这个Rule后就会停止，不继续往下执行。 [NC]：Non Case-sensitive，代表match_uri不比对大小写差异。 [QSA]：Query String Append，代表保留网址尾端带的GET参数，没使用flag的默认是会把参数去掉的。 [QSD]：Query String Discard（丢弃），与QSA相反的作用，apache v2.4才有。 [R]: Redirect，代表用转址的方式转到新的网址，默认是302 Status Code，如：[R=301]，也可以回传400、200、404等的Status Code，通常会跟[L]一起代表结束，也是排错常用的Flag [DPI]: 不要再接续的Rule中结尾中加上PathInfo，会在「五、一些小特性」的段落说明。 [F]: Forbidden 就是不给看啦！ 范例 接着来举例多个Rules加上Flag的功用，假设网站文件夹结构如下：123456root/ ├ match.html ├ rewrite.html ├ .htaccess └ secret/ └ database_password.json 而范例的.htaccess的內容为：123456789101112131415161718# 前面有井字号是注释### 开启RewriteRewriteEngine On### 设定Rewrite前面会加上的path，默认会是DocumentRoot(如：/var/www/html）RewriteBase /# Rules 将会由上往下依序执行# 直到最后一行或遇到有符合且有 L flag 的 Rule 就会停止### Rule 1. 输入 domain.com/match.html 将会显示 rewrite.html 的內容RewriteRule ^match\.html$ rewrite.html [NC,L]### Rule 2. 输入 domain.com/redirect.html 将会被导至 domain.com/rewrite.htmlRewriteRule ^redirect\.html$ rewrite.html [NC,R=302,L]### Rule 3. 如果输入 domain.com/secret/… 这样格式的网址，则去掉 secret/ 后，转回 root 并加上 .html### $1 是正则表达式的 group capture，就是 $1=(.*) 取得括号內的值RewriteRule ^secret/(.*)$ $1.html [NC,L] 在浏览器上输入match.html或redirect.html均会显示rewrite.html的內容，明显是Rule 2将网址改变了，而Rule 1没有，因为就是302 Status Code的关系。 在此建议可以使用POSTMAN或是cURL命令列或Request擷取等工具观察整个Response的差異，将会非常容易除错，详细原因将在「四、如何除错」段落中解释，以下使用cURL示范： 1.Request：http://localhost/match.html12$ curl &apos;http://localhost/match.html&apos;I’m rewrite.html 2.Request： http://localhost/redirect.html1234567891011$ curl &apos;http://localhost/redirect.html&apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=&quot;http://localhost/rewrite.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 与浏览器不同的是，这里的Response会指出网址被转移至另外一个新网址http://localhost/rewrite.html，浏览器自动帮忙处理转址的工作，根据上面回传的网址，再发出另一个Request取得网页內容，让使用者仅感觉到网址与页面改变而已。 这时候读者可试着把RewriteBase这行注释，将会发现回传结果出错了，Rewrite结果与Domain之间被加上DocumentRoot预设的路径。 1234567891011$ curl &apos;http://localhost/redirect.html&apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=&quot;http://localhost/var/www/html/rewrite.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 前面两个Rule仅是一个基本的示范，平常应用当然会难上许多，来继续看第三个Rule吧 1234### Rule 3. 如果输入domain.com/secret/…这样格式的网址，则去掉 secret/后，转回root并加上.html### $1是正则表达式的group capture，就是取得那个满足括号内的值RewriteRule ^secret/(.*)$ $1.html [NC,L] 第三个Rule是禁止使用者访问敏感的secret文件夹，来试着访问database_password.json看能不能得到结果： 123456789$ curl &apos;http://localhost/secret/database_password.json&apos;HTTP/1.1 404 Not FoundDate: Sun, 07 Oct 2018 13:39:11 GMTServer: Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7Vary: accept-language,accept-charsetAccept-Ranges: bytesContent-Type: text/html; charset=utf-8Content-Language: en 不管网址改成任何http://localhost/secret/...，都会回传404找不到页面，是理想中的状况，非常棒！但是访问 http://localhost/secret/反而变成403禁止访问了耶，咦？123456789$ curl &apos;http://localhost/secret/&apos;HTTP/1.1 403 ForbiddenDate: Sun, 07 Oct 2018 13:43:08 GMTServer: Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7Vary: accept-language,accept-charsetAccept-Ranges: bytesContent-Type: text/html; charset=utf-8Content-Language: en 这时候不知出了什么错的话，可以将Rule的Flag加上R=302，检查最后改写的结果出了什么状况：1234567891011$ curl &apos;http://localhost/secret/&apos;&lt;!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=”http://localhost/.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 发现 $1没有抓到任何字串，所以没有任何檔名加上 .html，就变成 403 的结果，所以只要在 Rule 3 之前加上以下新的 Rule 就可以！1RewriteRule ^secret/$ / [R=302,NC,L] 以上就是RewriteRule与简单的Debug方法，只要再加上看得懂正则表达式就能懂一般常见的Rules！继续看更难一点的RewriteCond吧～ 三、RewriteCondRewriteRule仅仅只能判断Request URI是否匹配而改写URI，但有很多需求是希望根据一些Request Header（Host、User-agent）与Apache的环境变量做改写，先满足某些条件后，再次Rewrite URI，因此有了RewriteCond的出现，它的写法结构如下：12RewriteCond [test_string] [match_string] [flags]RewriteRule … test_string：要比对的条件 match_string：符合的条件 以上这两个都可以使用正则表达式撰写，而且RewriteCond结束一定会接着一个RewriteRule，真正的范例会长这样：12RewriteCond %&#123;HTTP_USER_AGENT&#125; (facebookexternalhit)RewriteRule ^blog/(.*)$ fb-bot.html?path=$1&amp;type=%1 [L] 以上意义等同于以下Pseudo Code：1234567if ($HTTP_USER_AGENT == 'facebookexternalhit') &#123; if (url.match('^blog/(.*)$')) &#123; url = 'fb-bot.html?path=$1&amp;type=facebookexternalhit'; &#125;&#125; 前面说到$1是Group Capture的用法，而RewriteCond则是用%1表示 RewriteCond可使用的变量 ${HTTP_USER_AGENT}是RewriteCond可使用的变量，有以下常见的变量：123456789%&#123;REQUEST_URI&#125;：Domain后面完整的URI Path，Rule其实会拿到不完整的URI，详情可以参考「五、一些小特性」段落%&#123;QUERY_STRING&#125;：后面GET带的参数%&#123;HTTP_HOST&#125;：Domain 例：163.com%&#123;HTTP_COOKIE&#125;：Cookie%&#123;HTTPS&#125;：判断是否用https或http，如果是https就等于「on」，否则为“off”%&#123;HTTP_USER_AGENT&#125;：User Agent%&#123;REQUEST_FILENAME&#125;：访问的文件名称其实变量也可以放在RewriteRule的rewrite url当中 以及判断文件时，很常见搭配这两个match用法：12-d：directory. 代表如果有这个文件夹-f：regular file. 代表如果有这个文件 搭配起来写法就像以下范例，代表着如果没有这个文件就转到首页：12RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.html 其实还有不同的match写法，可以参考Apache官网的 RewriteCond 。 RewriteCond的Flag用法 12NC：Non case-sensitiveOR：就是OR条件，下面会说明 RewriteCond也有OR跟AND的条件，先前提到RewriteCond后面一定会接一个RewriteRule，有个特性是它只吃接续的第一个rule，来看下面的范例：123456789101112131415161718192021222324252627282930### 范例 ARewriteCond 1RewriteRule 1RewriteRule 2// 等同于if (Cond1) &#123; Rule1&#125;Rule 2### 范例 BRewriteCond 1RewriteCond 2RewriteRule 1// 等同于if (Cond1 &amp;&amp; Cond2) &#123; Rule1&#125;### 范例 CRewriteCond 1 [OR]RewriteCond 2RewriteRule 1// 等同于if (Cond1 || Cond2) &#123; Rule1&#125; 了解RewriteCond跟RewriteRule的用法与每一行执行下来的逻辑，就可以更轻易的改写网络上別人写好的规则。 四、如何排错先前在RewriteRule的段落有稍微简单展示Debug的流程，这里仅使用文字讲解一些小秘诀。 1.该使用什么Debug工具 使用POSTMAN、cURL等的工具，浏览器除了有Cache外，也会帮忙转址，此时就没办法观察第一次转址的网址內容，譬如：最常见就是浏览器直接显示转址太多次的错误，但使用工具的话，就可以看到Response回传的转址结果。 2.如何知道撰写的Regular Expression是否正确？ 把RewriteRule的Flag加上[R=302]，302 Status Code代表Moved Temporarily，浏览器并不会Cache302的转址结果，但301会，可以确定Rule无误后再拿掉或改为原本301就好，像这样观察转址的结果：1RewriteRule ^(.*)$ =$1 [L,R=302] 3.非得要修改正在运行中的网站怎么办？ 可以用一些识別的Header，加上RewriteCond来测试撰写的RewriteRule，譬如自定义一个User-agent，每次Reuqest都用这个User-agent即可。 4.浏览器有Cache 前面提到浏览器cache的问题，若认为写的没问题，但访问网站仍是旧有结果的话，就开启私密浏览访问看看，最后仍没办法只好重开Apache看看。 五、关于一些小特性1.RewriteRule在嵌套.htaccess当中不会取得完整URI Path 直接看范例，假设文件夹结構如下：123456root/ ├ a/ ├ b.html └ .htaccess ├ c.html └ .htaccess 12### 两个.htaccess都只有这一行內容RewriteRule ^(.*)$ $1 [L] 1.Request：c.html 使用root/.htaccessRule结果：c.html 2.Request： a/b.html 使用root/a/.htaccessRule结果： b.html没错，发生了不会拿到 a/ 的路径的情况。 Apache会自动选择最接近的.htaccess文件（详情会在下一段落说明） 3.如果拿掉root/a/.htaccess文件，重新Request： a/b.html 使用root/.htaccessRule结果：a/b.html这样的结果又正常了，如果真的想确保拿到完整的 URI Path，可以使用 %{REQUEST_URL}变量来取得 URI ！12RewriteCond %&#123;REQUEST_URI&#125; ^(.*)$RewriteRule ^ %1 [L] 2.RewriteRule自动附加在结尾的PATH_INFO 有时候会希望遇到Rule1改写之后，再传递至下一个Rule2判断与改写，可是会遇到后面莫名多了先前的URI，来看一个简单的示范例子：123RewriteRule ^(.*)$ web/$1 [NC]RewriteRule ^(.*)$ sec======$1====== [NC,R=301]Request： a/b/c.html 经过第一个Rule变成：web/a/b/c.html最后到第二个Rule变成：sec======web/a/b/c.html/b/c.html====== 发现它在Rule1的结果末端多了一个不需要的/b/c.html，这是因为PATH_INFO的缘故，若不需要后面Path的话，可以在Rule 1加上DPI Flag移除它，由于一些php的CMS或是Framework会使用到PATH_INFO的功能，所以是否关掉PATH_INFO的作用还是要注意一下！ 3.重新寻找.htaccess文件 有时候要的Rule很纯，就只是将所有Request都转到web/文件夹下：12RewriteBase /RewriteRule ^(.*)$ web/$1 [QSA,L] 但在Apache 2.4后就会遇到出现Redirect Loop的错误，原因是第一次Request URI被改写后成web/xxxx，它会根据新URI找对应最近的.htaccess并再重跑一次RewriteRule。 此时有两种解法，第一种是在web/ 文件夹下放一个空的.htaccess ，第二种是可以参考下一点停止Redirect Loop的写法，放在RewriteRule前面。 4.停止Redirect Loop的情况 有时候会遇到无穷Loop 的问题：1Request exceeded the limit of 10 internal redirects due to probable configuration error. Use &apos;LimitInternalRecursion&apos; to increase the limit if necessary. Use &apos;LogLevel debug&apos; to get a backtrace. 可以在所有RewriteRule之前加上判断，若Redirect Status是200的话，就停止Loop：12RewriteCond %&#123;ENV:REDIRECT_STATUS&#125; 200RewriteRule ^ - [L] 不过建议还是检查RewriteRule=哪边有写错的，毕竟这解不太算是万灵药。 六、使用Htaccess的缺点使用Override很方便，只要将.htaccess放到文件夹下面就有效果，但官方其实不推荐开启Override的功能，它会降低效能，主要是有以下缺点： 1.每次Request的嵌套搜寻 每一次Request都会使得Apache透过嵌套递归的方式搜寻.htaccess文件，导致Apache缓慢，譬如送出这个Request： Request： /example/sub/index.html Apache 则会根据路径寻找以下 .htaccess文件123/var/www/.htaccess/var/www/example/.htaccess/var/www/example/sub/.htaccess 最后Apache选择离文件最近的/var/www/example/sub/.htaccess 2.重复Compile RewirteRule 由于每次Request都会嵌套搜寻.htaccess，所以再遇到RewriteRule 都会重新Compile一次，不像Site Config只会Compile一次后做 cache，所以RewriteRule非常多的话，也会导致apache缓慢。 笔者使用Apache Benchmark做了一个小型的压力测试，连续访问10000次，同时1000个连线，取其三次执行ab指令的平均值，分别比较是否有打开Override功能，和Rewrite数量多寡是否有影响，Rewrite的状况都是以跑到倒数第三行结束为主，且每行RewriteRule跟RewriteCond不重复。 有开启Override功能比没开启花的时间多了一些，而行数的多寡也会影响到花費的时间，但筆者还是有点疑惑，差0.1秒好像也没什么关系吶。 官方认为.htaccess主要还是给无法编辑Site Config的情况下使用，像是一台主机上有多站共用，但真的想用.htaccess效果又不想开启Override的话怎么办呢？也是有一个取得中间值的做法。 在Site Config中预先指定.htaccess文件路径，把Override功能关掉，并使用Include指定引入的.htaccess，如下写法：123456DocumentRoot /var/www/&lt;Directory /var/www/&gt; AllowOverride None Include /var/www/.htaccess …&lt;/Directory&gt; 但这方法也是有个小缺点：每次更新.htaccess都必须重新启动Apache重新读取设定。 如果主机流量不大的话，效能问题并没这么严重，最后还是得依据主机上的网站与情况，衡量哪种做法比较好哦！]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设计高性能的索引？]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 回表就是通过辅助索引拿到主键id之后，要再去遍历聚集索引的B+树，这个过程就叫做回表。怎么理解？ 上回我们主要研究了为什么使用索引，以及索引的数据结构。今天带你了解如何设计高性能的索引。 其中，有这么一个点，说的是InnoDB引擎中使用的是聚簇索引，其主索引的实现树中的叶子结点存储的是完整的数据记录，而辅助索引中存储的则只是辅助键和主键的值。 这样在用辅助索引进行查询时，会先查出主键的值，然后再去主索引中根据主键的值查询目标值。 比如，假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。 Id Name Company 5 Gates Microsoft 7 Bezos Amazon 11 Jobs Apple 14 Ellison Oracle 对于聚簇索引，若使用主键索引进行查询，select * from tab where id = 14;这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。 若使用辅助索引进行查询，对Name列进行条件搜索，则需要两个步骤： 1、第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键值。 2、第二步根据主键值在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。 上面这个过程称为回表。 回表：在数据中，当查询数据的时候，在索引中查找索引后，获得该行的rowid，根据rowid再查询表中数据，就是回表。 显然，使用辅助索引出现了回表操作，这势必会影响查询性能，那有什么办法能够减少回表吗？ 覆盖索引上面，我们查询的是select *，如果是根据Name查询Id呢？即select Id from tab where Name=’Jobs’。 很明显，由于辅助索引Name上已经存储了Id的值，所以这时，查询便不会再次回表查询。 如果索引已经包含了所有满足查询需要的数据，这时我们称之为覆盖索引（Covering Index），这时就不再需要回表操作。 覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不用读取数据有以下一些优点： 1、索引条目通常远小于数据行大小，只需要读取索引，则 MySQL 会极大地减少数据访问量。 2、因为索引是按照列值顺序存储的，所以对于IO密集的范围查找会比随机从磁盘读取每一行数据的IO少很多。 3、覆盖索引对 InnoDB 表特别有用。因为 InnoDB 的辅助索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询； 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 联合索引/最左匹配原则又名复合索引，由两个或多个列的索引。 它规定了MySQL从左到右地使用索引字段，对字段的顺序有一定要求。 另外，一个查询可以只使用索引中的一部分，更准确地说是最左侧部分（最左优先），这就是传说中的最左匹配原则。 即最左优先，如： 如果有一个2列的索引(col1,col2)，则相当于已经对(col1)、(col1,col2)上建立了索引； 如果有一个3列索引(col1,col2,col3)，则相当于已经对(col1)、(col1,col2)、(col1,col2,col3) 上建立了索引； 但是(col2,col3)上并没有。 假定数据表有一个包含2列的联合索引（a, b），则索引的B+树结构可能如下： 键值都是排序的，通过叶子节点可以逻辑上顺序的读出所有数据。 数据（1,1）（1,2）（2,1）（2,4）（3,1）（3,2）是按照（a，b）先比较a再比较b的顺序排列。 所以从全局看，a是全局有序的，而b则不是。 基于上面的结构，对于以下查询显然是可以使用（a，b）这个联合索引的：123select * from table where a=xxx and b=xxx ;select * from table where a=xxx; 但是对于下面的sql是不能使用这个联合索引的，因为叶子节点的b值，1,2,1,4,1,2显然不是排序的。1select * from table where b=xxx 只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。 注意 1、主键字段其实跟所有非主键索引建立了联合索引，只是说如果主键字段没有在联合索引中明确声明，只会在其他索引中处于最右边； 2、最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。 比如a = 1 and b = 2 and c &gt; 3 and d = 4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引，则都可以用到，a,b,d的顺序可以任意调整。 3、= 和 in 的条件可以乱序 MySQL的查询优化器会帮你优化成索引可以识别的形式。MySQL查询优化器会判断纠正SQL语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。 为什么要使用联合索引？1、减少开销 “一个顶三个”。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3) 三个索引。 每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！ 2、覆盖索引 对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机IO操作。 减少IO操作，特别的随机IO其实是DBA主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。 3、效率高 索引列越多，通过索引筛选出的数据越少。 有1000W条数据的表，有如下sql: select col1,col2,col3 from table where col1=1 and col2=2 and col3=3，假设假设每个条件可以筛选出10%的数据。 如果只有单值索引，那么通过该索引能筛选出1000W_10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页； 如果是联合索引，通过索引筛选出1000w_10% * 10% * 10%=1w，效率提升可想而知！ 索引下推索引条件下推（ICP：index condition pushdown）是MySQL中一个常用的优化，尤其是当MySQL需要从一张表里检索数据时。 ICP（index condition pushdown）是MySQL利用索引（二级索引）元组和筛字段在索引中的WHERE条件从表中提取数据记录的一种优化操作。 ICP的思想是：存储引擎在访问索引的时候检查筛选字段在索引中的where条件，如果索引元组中的数据不满足推送的索引条件，那么就过滤掉该条数据记录。 ICP（优化器）尽可能的把index condition的处理从server层下推到存储引擎层。 存储引擎使用索引过滤不相关的数据，仅返回符合index condition条件的数据给server层。也是说数据过滤尽可能存储引擎层进行，而不是返回所有数据给server层，然后后再根据where条件进行过滤。 下推过程优化器没有使用ICP时，数据访问和提取的过程如下： ①：MySQL Server发出读取数据的命令，调用存储引擎的索引读或全表表读。此处进行的是索引读。 ②、③：进入存储引擎，读取索引树，在索引树上查找，把满足条件的（红色的）从表记录中读出（步骤④，通常有IO）。 ⑤：从存储引擎返回标识的结果。 以上，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要进行进行步骤④，通常有IO。 ⑥：从存储引擎返回查找到的多条数据给MySQL Server，MySQL Server在⑦得到较多的元组。 ⑦—⑧：依据WHERE子句条件进行过滤，得到满足条件的数据。 注意在MySQL Server层得到较多数据，然后才过滤，最终得到的是少量的、符合条件的数据。 在不支持ICP的系统下，索引仅仅作为data access使用。 优化器使用ICP时： ①：MySQL Server发出读取数据的命令，过程同图一。 ②、③：进入存储引擎，读取索引树，在索引树上查找，把满足已经下推的条件的（红色的）从表记录中读出（步骤 ④，通常有 IO）； ⑤：从存储引擎返回标识的结果。 此处，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要在③这个阶段依据下推的条件进行进行判断，不满足条件的，不去读取表中的数据，直接在索引树上进行下一个索引项的判断，直到有满足条件的，才进行步骤④，这样，较没有ICP的方式，IO量减少。 ⑥：从存储引擎返回查找到的少量数据给MySQL Server，MySQL Server在⑦得到少量的数据。 因此比较图一无ICP的方式，返回给MySQL Server层的即是少量的、 符合条件的数据。 在ICP优化开启时，在存储引擎端首先用索引过滤可以过滤的where条件，然后再用索引做data access，被index condition过滤掉的数据不必读取，也不会返回server端。 举例 比如：1SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man'; 在没有ICP时，首先通过索引前缀从存储引擎中读出所有first_name为Mary的记录，然后在server端用where筛选last_name的like条件； 而启用ICP后，由于last_name的like筛选可以通过索引字段进行，那么存储引擎内部通过索引与where条件的对比来筛选掉不符合where条件的记录，这个过程不需要读出整条记录，同时只返回给server筛选后条记录，因此提高了查询性能。 注意事项 有几个关于ICP的事情要注意： ICP只能用于二级索引，不能用于主索引； 也不是全部where条件都可以用ICP筛选，如果某where条件的字段不在索引中，当然还是要读取整条记录做筛选，在这种情况下，仍然要到server端做where筛选； ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例； 总结建索引的几大原则1、最左前缀匹配原则，非常重要的原则，MySQL 会一直向右匹配直到遇到范围查询 （&gt;、&lt;、between、like）就停止匹配； 2、=和in的条件可以乱序； 3、尽量选择区分度高的列作为索引，区分度表示字段不重复的比例，比例越大我们扫描的记录数越少； 4、索引列不能参与计算，保持列「干净」。原因很简单，B+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。 5、尽量的扩展索引，不要新建索引。 索引是最好的解决方案吗？ 索引不是最好的，但已经是相当好的了。 当表非常小时，没必要使用索引，直接全表查询好了； 当表是中大型时，比较适合使用索引，来快速定位目标数据； 当表是超大型时，创建和维护索引都是不小的代价，需要专业的DBA来分析，这种情况下可以尝试使用分表技术；]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在PHP中使用yield来做内存优化]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%9C%A8PHP%E4%B8%AD%E4%BD%BF%E7%94%A8yield%E6%9D%A5%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是yield？ yield&amp;return的区别？ 什么是yield生成器函数看上去就像一个普通函数，除了不是返回一个值之外，生成器会根据需求产生更多的值。 来看以下的例子：123456function getValues() &#123; yield 'value';&#125;// 输出字符串 "value"echo getValues(); 当然，这不是他生效的方式，前面的例子会给你一个致命的错误： 类生成器的对象不能被转换成字符串， 让我们清楚的说明： yield&amp;return的区别前面的错误意味着getValues()方法不会如预期返回一个字符串，让我们检查一下他的类型：123456789function getValues() &#123; return 'value';&#125;var_dump(getValues()); // string(5) "value"function getValues() &#123; yield 'value';&#125;var_dump(getValues()); // class Generator#1 (0) &#123;&#125; 生成器类实现了迭代器接口，这意味着你必须遍历getValue()方法来取值：123456789foreach (getValues() as $value) &#123; echo $value;&#125;// 使用变量也是好的$values = getValues();foreach ($values as $value) &#123; echo $value;&#125; 但这不是唯一的不同！ 一个生成器允许你使用循环来迭代一组数据，而不需要在内存中创建是一个数组，这可能会导致你超出内存限制。 在下面的例子里我们创建一个有800,000元素的数字同时从getValues()方法中返回他，同时在此期间，我们将使用函数memory_get_usage()来获取分配给次脚本的内存，我们将会每增加200,000个元素来获取一下内存使用量，这意味着我们将会提出四个检查点：12345678910111213141516171819202122&lt;?phpfunction getValues() &#123; $valuesArray = []; // 获取初始内存使用量 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB' . PHP_EOL; for ($i = 1; $i &lt; 800000; $i++) &#123; $valuesArray[] = $i; // 为了让我们能进行分析，所以我们测量一下内存使用量 if (($i % 200000) == 0) &#123; // 来 MB 为单位获取内存使用量 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB'. PHP_EOL; &#125; &#125; return $valuesArray;&#125;$myValues = getValues(); // 一旦我们调用函数将会在这里创建数组foreach ($myValues as $value) &#123;&#125; 前面例子发生的情况是这个脚本的内存消耗和输出：12340.34 MB8.35 MB16.35 MB32.35 MB 这意味着我们的几行脚本消耗了超过30MB的内存，每次你你添加一个元素到$valuesArray数组中，都会增加他在内存中的大小。 让我们使用yield同样的例子:12345678910111213141516171819&lt;?phpfunction getValues() &#123; // 获取内存使用数据 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB' . PHP_EOL; for ($i = 1; $i &lt; 800000; $i++) &#123; yield $i; // 做性能分析，因此可测量内存使用率 if (($i % 200000) == 0) &#123; // 内存使用以 MB 为单位 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB'. PHP_EOL; &#125; &#125;&#125;$myValues = getValues(); // 在循环之前都不会有动作foreach ($myValues as $value) &#123;&#125; // 开始生成数据 这个脚本的输出令人惊讶：12340.34 MB0.34 MB0.34 MB0.34 MB 这不意味着你从return表达式迁移到yield，但如果你在应用中创建会导致服务器上内存出问题的巨大数组，则yield更加适合你的情况。 什么是”yield”选项这里有很多yield的选项，我将强调他们中的几个： a. 使用yield，你也可以使用return。1234567891011function getValues() &#123; yield 'value'; return 'returnValue';&#125;$values = getValues();foreach ($values as $value) &#123;&#125;echo $values-&gt;getReturn(); // 'returnValue' b. 返回键值对： 1234567function getValues() &#123; yield 'key' =&gt; 'value';&#125;$values = getValues();foreach ($values as $key =&gt; $value) &#123; echo $key . ' =&gt; ' . $value;&#125; 使用情景http://www.php100.com/9/20/19693.html laravel ORM中的cursor游标cursor方法允许你使用游标遍历数据库，它只执行一次查询。处理大量的数据时,可以大大减少内存的使用量通过对比cursor与get方法，查找到了其中的一点不同，get方法是直接fetchAll返回所有数据，cursor方法是使用yield构建了一个生成器，逐步返回fetch的数据PDO mysql中的查询一般查询如下：12345$sql = "select * from `user` limit 100000000";$stat = $pdo-&gt;query($sql);$data = $stat-&gt;fetchAll(); //mysql buffered直接全部返回给phpvar_dump($data); 使用yield如下：1234567891011function get()&#123; $sql = "select * from `user` limit 100000000"; $stat = $pdo-&gt;query($sql); while ($row = $stat-&gt;fetch()) &#123; //一个一个地返回给php yield $row; &#125;&#125;foreach (get() as $row) &#123; var_dump($row);&#125; PDO参数 这个PDO参数，侧面说明了，如果这个参数为ture,MySQL驱动程序将使用MySQL API的缓冲版本。 注意，这个参数只对Mysql起作用，如果要编写可移植的sql代码，请使用fetchAll 查看php手册MYSQL_ATTR_USE_BUFFERED_QUERY 在使用了yield的情况下，内存使用量的确减少了，但是在逐渐使用yield中，内存会逐渐增大，这样的情况与以下函数不一致，下面这个函数的内存使用量将会不变12345function getNum() &#123; for($i=0; $i &lt; 100000000; $i++) &#123; yield $i; &#125;&#125; 结论在使用fetch、fetchAll之前，查找数据结果集还存在于mysql的缓冲区内，而每次yield和fetch配合，才取回一条结果存入内存，这就能解释，为什么内存使用量会逐步增大。 而上面的这个getNum函数之所以内存使用量不变，是因为，每次只返回一个数字。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化表]]></title>
    <url>%2F2018%2F11%2F29%2FMySQL%E4%BC%98%E5%8C%96%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： MySQL主要支持4种模式的分区，分别是range（范围）分区、list（预定义列表）分区、hash（哈希）分区以及key（键值）分区。有什么区别？ 优化表同样可以提升数据库性能，其中包括优化表结构、表的拆分、分区、表的分析与检查等内容。 优化表结构1）尽量将字段定义为NOT NULL约束。这是由于：在MySQL中，含有空值的列很难进行查询优化，NULL值会使索引、索引的统计信息以及比较运算变得更加复杂。推荐使用0、一个特殊的值或者一个空字符串代替NULL值。 2）考虑使用enum、set等复合数据类型。对于一个只包含有限数目的特定值的字段，可以考虑将其设计为enum、set等复合数据类型。enum、set等复合数据类型的值可以更快地处理，因为它们在内部是以数值表示的。 3）虽然MySQL支持blob类型，可以存储二进制数据，但是设计数据库表时，图片、音频、视频等二进制数据不要使用数据库存储，毕竟处理这些二进制数据并不是数据库的强项。 4）数值型（例如整型）字段的比较比字符串的比较效率高很多，这也符合一项优化原则：字段类型尽量使用最小、最简单的数据类型，典型的例子是IP地址的存储。当前还有很多应用使用char(15)存储IP地址，然而使用无符号整数存储IP地址效率会更高，MySQL提供了inet_aton()和inet_ntoa()函数来解决IP地址与整数之间的转换。 表的拆分表的拆分是指将某个表按照某个（或一些）条件拆分成两个或多个独立表。表的拆分分为垂直拆分与水平拆分。 1．垂直拆分垂直拆分按照字段（或者列）进行拆分，其实就是把组成一行的多个列分开，放到不同的表中。这些表具有不同的结构，拆分后的表含有更少的列，例如可以将频繁访问的列置于一张表中，不经常访问的列（例如长文本信息）置于另一张表中，然后在这两张表的记录与记录之间创建1∶1关系。举例来说，对于一张用户表而言，不仅包含账号、账户名、密码、性别等基本信息，还包括兴趣爱好（不经常使用的信息）、自我介绍（长文本信息）等扩展信息。设计用户表时，可以将用户表拆分成两个表user1表与user2表，其中user1表中包含账号、账户名、密码、性别等基本信息，user2表中包含兴趣爱好、自我介绍等扩展信息。由于user1表中的记录与user2表中的记录存在1∶1关系，此时还需要在user2表中增加user1表的主键字段user1_no作为外键，并将外键设置为唯一性约束。user1表为父表，user2表为子表。12user1（user1_no，account_name，password，sex）user2（user2_no，interest，introduction，user1_no） 使用垂直拆分的优点在于：垂直拆分可以使得列数据变小，一个数据块（Block）就可以存放更多行的记录，对频繁访问的字段执行select语句，硬盘I/O次数也会相应减少。另外，垂直拆分表可以达到最大化利用Cache的目的。 使用垂直拆分的缺点在于：由于拆分出来的两张表的记录与记录之间存在1∶1关系，这种1∶1关系需要使用冗余字段进行维护。另外，一旦访问不经常使用的字段，会引起表之间的join连接操作，额外增加了CPU的负担。 2．水平拆分水平拆分按照记录（或者行）进行拆分，其实就是把一个表分成几个表，这些表具有相同的列，但是存放更少的数据。拆分的原则通常是按照日期时间维度、地区维度或者特殊的业务维度进行表的拆分。 案例1：某个公司销售记录数据量非常大，可以对销售记录按月进行水平拆分，每个月的销售记录拆分成一张独立表，共拆分成12张独立表。 案例2：某个集团在各个地区都有分公司，该集团的订单数据量非常大，可以按分公司所在的地区进行水平拆分。 案例3：某电信公司的话单按月份、地市水平拆分后，发现数据量依然很大，可以按号码段进行3次水平拆分。 使用水平拆分的优点在于：将维度作为查询条件执行select语句时，如果维度范围很小（例如查询12月份的销售记录），可以有效降低需要扫描的数据和索引的数据块数，加快查询速度。 使用水平拆分的缺点在于：水平拆分会给应用增加复杂度，它通常在查询时需要多个表名。查询所有数据需要union操作，有时，这种复杂度会超过它带来的优点。例如，将维度作为查询条件执行select语句时，如果维度范围很大（例如查询1月份到12月份的销售记录），此时需要进行11个union操作，硬盘I/O次数也会增加。 分区分区是按照指定的规则，跨文件系统分配单个表的多个部分。对于海量数据库或者OLAP的应用而言，对表进行适当的分区可以提升数据库性能。MySQL主要支持4种模式的分区，分别是range（范围）分区、list（预定义列表）分区、hash（哈希）分区以及key（键值）分区。无论使用哪一种分区模式，它们都是对表进行“水平分区”。并且，如果表中存在主键或者唯一性约束字段，要求分区字段必须是主键字段或唯一性约束字段的一部分。分区的原则是按照日期时间维度、地区维度或者特殊的业务维度进行分区，这与水平拆分的原则相同，分区与水平拆分的不同之处如表1所示。 表1 水平拆分与分区的比较 range（范围）分区：这种分区模式允许数据库管理员将数据划分不同范围。例如，数据库管理员可以将销售记录表按照销售年度对该表划分分区。 list（预定义列表）分区：这种分区模式允许系统通过数据库管理员定义的离散值列表进行分区。例如：数据库管理员建立了一个横跨3个分区的表，分别根据2011年、2012年和2013年所对应的数据进行分区。 hash（哈希）分区：这种分区模式允许数据库管理员通过对表的一个或多个列的hash值进行计算，最后通过这个hash码不同数值对应的数据区域进行分区。例如数据库管理员可以建立一个对表主键hash值进行分区的表。 key（键值）分区：hash分区的一种延伸，这里的key由MySQL自动生成。 上述4种模式的分区中，range（范围）分区最为常用。下面以range分区为例讲解MySQL表分区的方法。下面的SQL语句首先创建一个sale销售记录表，然后再向该表添加销售年度分区（注意sale表的存储引擎为MyISAM）。12345678910create table sale( sale_id int not null, sale_date datetime, money int)engine=myisam;alter table sale partition by range columns (sale_date) ( partition p01 values less than ('2011-1-1'), partition p02 values less than ('2012-1-1')); MyISAM的sale表经过分区后，产生分区定义文件sale.par、分区索引文件（sale#P#p01.MYI与sale#P#p02.MYI）以及分区数据文件（sale#P#p01.MYD与sale#P#p02.MYD），如图1所示。 图1 MyISAM表分区的物理文件 说明如果sale表的存储引擎为InnoDB，则sale表经过分区后，仅仅产生分区定义文件sale.par。如果sale表的存储引擎为InnoDB，并且使用的是独享表空间（ibd）文件，则sale表经过分区后，除了产生分区定义文件sale.par外，还会产生分区独享表空间文件sale#P#p01.ibd与sale#P#p02.ibd，如图2所示。 图2 InnoDB独享表空间分区的物理文件 接着使用下面的SQL语句向sale表插入记录信息，运行结果如图3所示。12insert into sale values(1, '2011-1-2',100);insert into sale values(1, '2012-1-2',100); 图3 向sale表插入记录信息 注意：第二条记录插入失败，原因在于插入的值‘2012-1-2’不在sale表的两个分区范围之内。对于此类问题，可以向sale表添加一个maxvalue（无穷大值）分区。这样，第二条记录就可以成功插入p03分区中，执行结果如图4所示。1alter table sale add partition(partition p03 values less than maxvalue); 图4 maxvalue分区 查询2011年的销售记录可以使用下面的SQL语句，如图5所示。1explain partitions select * from sale where sale_date&lt;='2011-12-31' and sale_date&gt;='2011-1-1'\G 图5 分区select语句的分析 通过explain partitions命令可以发现，查询优化器只需要搜索p02 分区，查询范围的缩小可以有效提升检索性能。 如果要删除2011年度的数据，只需要删除p02分区即可，可以使用下面的SQL语句。此时对应分区的物理文件也随之删除。1alter table sale drop partition p02; 表分析与表检查表结构一旦确定，随着向表插入记录、更新记录以及删除记录，索引文件和数据文件之间的链接可能会发生错误，或者表空间中数据文件可能存在碎片，这时需要使用一些MySQL命令对表进行分析或者检查，从而提升数据库性能。 1．analyze table在执行select语句时，MySQL查询优化器需要收集一些相关信息，进而优化select语句，其中就包括索引字段的cardinality（离散度），它表示某个索引字段中包含多少个不同的值。如果索引字段cardinality的值远远小于索引字段实际的离散度，那么索引就基本失效了。通过使用show index 命令可以查看某个表所有索引字段的离散度，索引字段实际的离散度可以通过“select count(distinct(字段名))from表名;”获取。 MySQL查询优化器是基于成本的，并且最主要的成本因素就是这个查询要访问多少数据。如果这个统计信息没有生成，或者如果统计信息已经过期，优化器可能就会有个比较差的决定。analyze table命令负责对表进行分析，获得索引字段的分布情况，分析的结果可以使MySQL查询优化器得到准确的统计信息，使得SQL能够生成正确的执行计划。 举例来说：当索引字段的离散度远远小于字段实际的离散度时，可以使用MySQL命令“analyze table表名”修复某个表的索引，提高索引字段的离散度，进而为MySQL查询优化器优化select语句提供依据。例如，优化student表的索引离散度可以使用MySQL命令“analyze table student;”，执行结果如图6所示。 图6 对表进行分析说明 如果开启了二进制文件，那么analyze table的结果会写入二进制文件，可以在analyze和table之间添加关键字local以取消写入。 analyze table命令是通过执行全索引扫描来计算统计信息的，这个过程对表是锁定的。因此，对于数据基本没有发生变化的表，是不需要经常进行表分析的。但是如果表的数据量变化很明显，且实际的执行计划和预期的执行计划不同的时候，执行一次表分析可能有助于产生预期的执行计划。 2．optimize table如果某个数据库表不断地执行delete、insert或者update等更新语句，那么表的内部结构就会出现很多碎片以及未利用的空间，使用MySQL命令“optimize table表名”可以整理MyISAM以及InnoDB表的碎片，从而提升系统性能。例如，整理student表的碎片可以使用MySQL命令“optimize table student\G”，执行结果如图7所示。需要注意的是，该MySQL命令整理student表碎片失败。 图7 对表进行优化1 在启动MySQL服务前，在my.ini配置文件[mysqld]选项组中加入skip-new或者safe-mode选项，然后重启MySQL服务，此时MySQL才支持optimize table功能。重新运行MySQL命令“optimize table student\G”，执行结果如图8所示。 图8 对表进行优化2说明 如果开启了二进制日志，那么optimize table的结果会写入二进制日志，可以在optimize和table之间添加关键字local，取消写入。 3．check table所有存储引擎的表都会因为硬件问题、MySQL内部BUG或者操作系统的原因导致索引的损坏，索引没有同步更新。损坏的索引会导致诸多问题，例如，查询返回不正确的结果；当没有重复值出现时却抛出重复键值的错误；查询死锁以及宕机。 可以使用check table命令检查表、索引是否损坏，检测MyISAM和InnoDB表的健康程度。check table还可以指定下面一些选项。 quick：速度最快的选项，在检查各列的数据时，不会检查索引文件和数据文件之间链接的正确与否。如果没有遇到什么问题，可以使用这个选项。 fast：只检查没有正常关闭的表，如果在系统掉电之后没有遇到严重问题，可以使用这个选项。 changed：只检查上次检查时间之后更改的表以及没有正常关闭的表。 medium：默认的选项，会删除索引文件和数据文件之间错误的链接。 extended：最慢的选项，对索引所有关键字进行一个全面的检查。 check table也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。例如，下面的SQL语句首先创建了名字为“view1”的视图，该视图从student表中获取信息。12345create view view1 as select student_no,student_name,student_contact from student;``` 然后使用check table命令检查该视图。```sqlcheck table view1; 接着使用下面的SQL语句删除student表中的student_contact字段。1alter table student drop student_contact; 最后再次使用check table命令检查该视图，将出现如图9所示的错误信息。1check table view1; 图9 对表进行检查 4．repair table如果一个表或索引已经损坏，遇到如下错误时：1Incorrect key file for table：&apos; &apos;．Try to repair it. 可以使用MySQL命令repair table尝试修复它，该命令只对MyISAM和ARCHIVE表有效。repair table命令同样可以指定下面一些选项。 quick：最快的选项，只修复索引树。 extended：最慢的选项，需要逐行重建索引。 use_frm：只有当MYI索引文件丢失时才使用这个选项，全面重建整个索引。 与analyze table一样，repair table也可以使用local来取消写入二进制日志。 说明修复MyISAM和ARCHIVE存储引擎的表前，建议首先备份数据。 5．checksum tableMySQL主从复制环境中，从表出现写入操作或者主表执行了具备不确定性的查询指令，或者主从数据在网络传输过程中发生了数据变化，这些情况都会导致从属数据未能与主体数据正确同步，继而出现主从数据不一致问题。 对于复制环境中的每一对主从表，可以使用checksum table语句计算主从表的checksum（校验值），从而确定主从数据是否一致。通常情况下，对于每一对主从表而言，如果两个表存储的数据相同、表结构相同（字段数据类型相同以及字段的顺序相同），那么主从表的checksum校验值是相同的。 在执行checksumtable时，可以在命令的最后指定选项quick或是extended。quick 表示返回存储的checksum（校验值），而extended会重新计算checksum（校验值），如果没有指定选项，则默认使用extended。 说明创建MyISAM存储引擎的表时，如果在create table语句后加上“CHECKSUM=1”选项，那么MyISAM存储引擎的表会把checksum存储起来，称为live checksum，当数据发生变化时，checksum会相应变化。 NULL值对统计信息的影响使用analyze table命令统计索引字段的分布情况时，如果索引字段包括NULL值，MySQL如何统计该字段的cardinality（离散度）？对于MyISAM而言，myisam_stats_method参数用于控制MySQL如何处理NULL值；对于InnoDB而言，innodb_stats_method参数用于控制MySQL如何处理NULL值。这两个参数用于控制MySQL如何统计、处理NULL值，共有如下3种取值。 nulls_equal：所有的NULL值被看成相等的一个值。 nulls_unequal：每个NULL值被看成单独的一个值。 nulls_igored：NULL值被忽略。 使用MySQL命令“show variables like ‘％stats_method％’;”可以查看这两个参数的相关信息，如图10所示。innodb_stats_method的默认值为“nulls_equal”，如果此时InnoDB表的某个索引字段的NULL值较多，那么该索引字段的离散度较小，这就意味着该索引基本失效。myisam_stats_method的默认值为“nulls_unequal”，如果此时MyISAM表的某个索引字段的NULL值较多，那么该索引字段的离散度依然较大，这样就会让查询优化器处理查询语句的时候使用该索引的倾向性更高。如果索引字段的NULL值本身就很少，此时不管使用nulls_unequal还是nulls_equal，对查询优化器选择执行计划的影响很小。 图10 NULL值对统计信息的影响 记录的格式使用MySQL命令“show table status;”可以查看某个数据库的所有表或者视图（不包括临时表）的状态信息。如果需要查看某一个表的状态信息，可以使用“show table status like ‘表名’;”。例如，下面的命令负责查看account表的状态信息（注意，该表的存储引擎目前为MyISAM），如图11所示。1show table status like 'account'\G 图11 查看MyISAM表的状态信息 使用下面的命令将account表的存储引擎修改为InnoDB，然后查看account表的状态信息，如图12所示。12alter table account engine=innodb;show table status like 'account'\G 图12 查看InnoDB表的状态信息 show table status显示了表的大量信息，如表2所示。 表2 表的状态信息 说明对于MyISAM表，记录的格式有3种：Dynamic，Fixed或Compressed。Dynamic记录格式是指表的每一行记录长度是可变的。Fixed记录格式是指表的每一行记录使用固定大小的空间。Compressed记录格式仅仅用在compressed tables中。使用create table或alter table创建或者修改表结构时，可以使用row_format选项强制表的记录格式为fixed固定格式或dynamic动态格式，这会导致char和varchar列因fixed格式变成char，或因dynamic格式变成varchar。如果表的row_format是fixed，该表是静态表，静态表每条记录所占用的字节空间系统，静态表的优点是读取速度快，缺点是浪费存储空间。如果表的row_format是dynamic，该表是动态表，动态表的每条记录所占用的字节空间是动态的，动态表的优点是节省储存空间，缺点是读取速度较慢。 说明对于InnoDB表而言，记录的格式有两种：Compact以及Redundant。MySQL5.0.3之前的版本仅支持Redundant，MySQL5.0.3以及MySQL5.0.3 之后的版本，默认的row_format是Compact。 与Redundant相比，Compact以牺牲CPU使用为代价，节省大约20％的行储存空间。如果当前应用系统的负荷受限于缓存命中率以及硬盘的速度，推荐使用 Compact。如果当前应用系统的负荷受限于CPU的速度，推荐使用Redundant。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务的ACID特性]]></title>
    <url>%2F2018%2F11%2F27%2FMySQL%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 事务的隔离性通过事务的隔离级别实现，而事务的隔离级别则是通过锁机制实现。有哪些事务隔离级别？ 为什么使用间隙锁能避免幻读现象？ 事务的首要任务是保证一系列更新语句的原子性，锁的首要任务是解决多用户并发访问可能导致的数据不一致问题。如果事务与事务之间存在并发操作，此时可以通过事务之间的隔离级别实现事务的隔离性，从而实现事务间数据的并发访问。 事务的ACID特性事务的ACID特性由原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durabilily）4个英文单词的首字母组成（如图1所示）。 图1 事务的ACID特性 1．原子性（atomicity） 原子性用于标识事务是否完全地完成。一个事务的任何更新都要在系统上完全完成，如果由于某种原因出错，事务不能完成它的全部任务，那么系统将返回到事务开始前的状态。回顾银行转账业务，如果在转帐的过程中出现错误，那么整个事务将被回滚。只有事务中的所有修改操作成功执行，事务的更新才被写入外存（例如硬盘），并使更新永久化。 2．一致性（consistency） 事务的一致性保证了事务完成后，数据库能够处于一致性状态。如果事务执行过程中出现错误，那么数据库中的所有变化将自动地回滚，回滚到另一种一致性状态。回顾银行转账业务，在转账前，两个账户处于某个初始状态（一致性状态），如果转账成功，则两个账户处于新的一致性状态。如果转账失败，那么事务将被回滚到初始状态（一致性状态）。 3．隔离性（isolation） 同一时刻执行多个事务时，一个事务的执行不能被其他事务干扰。事务的隔离性确保多个事务并发访问数据时，各个事务不能相互干扰，好像只有自己在访问数据。事务的隔离性通过事务的隔离级别实现，而事务的隔离级别则是通过锁机制实现。不同种类的事务隔离级别使用的锁机制也不相同，可以这样认为，事务是对一系列更新操作的封装（保证了多个更新操作的原子性），事务的隔离级别是对锁机制的封装（保证了多个事务可以并发地访问数据）。 4．持久性（durabilily） 持久性意味着事务一旦成功执行，在系统中产生的所有变化将是永久的。回顾银行转账业务，无论转账成功还是失败，资金的转移将永久地保存在数据库的服务器硬盘中。 事务的隔离级别与并发问题事务的隔离级别是事务并发控制的整体解决方案，是综合利用各种类型的锁机制解决并发问题的整体解决方案。SQL标准定义了4种隔离级别：read uncommitted（读取未提交的数据）、read committed（读取提交的数据）、repeatable read（可重复读）以及serializable（串行化）。4种隔离级别逐渐增强，其中，read uncommitted的隔离级别最低，serializable的隔离级别最高。 1．read uncommitted（读取未提交的数据） 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。该隔离级别很少用于实际应用，并且它的性能也不比其他隔离级别好多少。 2．read committed（读取提交的数据） 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。 3．repeatable read（可重复读） 这是MySQL默认的事务隔离级别，它确保在同一事务内相同的查询语句的执行结果一致。 4．serializable（串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突。换言之，它会在每条select语句后自动加上lock in share mode，为每个查询数据施加一个共享锁。该级别可能会导致大量的锁等待现象。该隔离级别主要用于InnoDB存储引擎的分布式事务。 低级别的事务隔离可以提高事务的并发访问性能，却可能导致较多的并发问题（例如脏读、不可重复读、幻读等并发问题）；高级别的事务隔离可以有效避免并发问题，但会降低事务的并发访问性能，可能导致出现大量的锁等待，甚至死锁现象。如表1所示，read uncommitted隔离级别可能导致脏读、不可重复读、幻读等并发问题；而read committed隔离级别解决了脏读问题，却无法解决不可重复读、幻读等并发问题；repeatable read隔离级别可以解决脏读、不可重复读问题，却无法解决幻读问题；serializable隔离级别可以解决脏读、不可重复读、幻读等并发问题，却可能导致大量的锁等待现象。4种隔离级别逐渐增强，每种隔离级别解决一个并发问题。 表1 事务的隔离级别与并发问题 脏读（dirty read）：一个事务可以读到另一个事务未提交的数据，脏读问题显然违背了事务的隔离性原则。 不可重复读（non-repeatable read）：同一个事务内，两条相同的查询语句的查询结果不一致。 幻读（phantom read）：同一个事务内，两条相同的查询语句的查询结果应该相同。但是，如果另一个事务同时提交了新数据，当本事务再更新时，就会“惊奇地”发现这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。 查看当前MySQL会话的事务隔离级别可以使用MySQL命令“select @@session.tx_isolation;”。查看MySQL服务实例全局的事务隔离级别可以使用MySQL命令“select @@global.tx_isolation;”。执行结果如图2所示，从图中可以看出，MySQL默认的事务隔离级别为repeatable read（可重复读）。 图2 查看MySQL的事务隔离级别 设置事务的隔离级别InnoDB支持4种事务隔离级别，在InnoDB存储引擎中，可以使用以下命令设置事务的隔离级别。123set &#123; global | session &#125; transaction isolation level &#123; read uncommitted | read committed | repeatable read | serializable&#125; 合理地设置事务的隔离级别，可以有效避免脏读、不可重复读、幻读等并发问题。 场景描述1：脏读现象。 将事务的隔离级别设置为read uncommitted可能出现脏读、不可重复读以及幻读等问题，以脏读现象为例。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为read uncommitted，接着开启事务，查询account表中的所有记录，执行结果如图3所示。123456alter table account engine=InnoDB;set session transaction isolation level read uncommitted;select @@tx_isolation;start transaction;select * from account; 图3 将事务的隔离级别设置为read uncommitted 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为read uncommitted，然后开启事务，接着将account表中account_no=1的账户增加1000元钱。123set session transaction isolation level read uncommitted;start transaction;update account set balance=balance+1000 where account_no=1; 步骤3：在MySQL客户机A上执行下面的SQL语句，查询account表中的所有记录，执行结果如图4所示。从图中可以看出，MySQL客户机A看到了MySQL客户机B尚未提交的更新结果，造成脏读现象。1select * from account; 图4 read uncommitted隔离级别可能造成脏读问题 步骤4：关闭MySQL客户机A与MySQL客户机B，由于MySQL客户机A与MySQL客户机B的事务没有提交，因此，account表中的数据没有发生变化，“甲”账户的余额依然是200元。 场景描述2：不可重复读现象。 将事务的隔离级别设置为read committed可以避免脏读现象，但可能出现不可重复读以及幻读等现象，以不可重复读现象为例。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为read committed，接着开启事务，查询account表中的所有记录，执行结果如图5所示。123456alter table account engine=InnoDB;set session transaction isolation level read committed;select @@tx_isolation;start transaction;select * from account; 图5 将事务的隔离级别设置为read committed 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为read committed，然后开启事务，接着将account表中account_no=1的账户增加1000元钱，最后提交事务。1234set session transaction isolation level read committed;start transaction;update account set balance=balance+1000 where account_no=1;commit; 步骤3：在MySQL客户机A上执行下面的SQL语句，查询account表中的所有记录，执行结果如图6所示。两次查询结果对比可以看出，MySQL客户机A在同一个事务中两次执行“select * from account;”的结果不相同，造成不可重复读现象。1select * from account; 图6 read committed隔离级别可能造成不可重复读 说明不可重复读现象与脏读现象的区别在于，脏读现象是读取了其他事务未提交的数据；而不可重复读现象读到的是其他事务已经提交（commit）的数据。 步骤4：关闭MySQL客户机A与MySQL客户机B，由于MySQL客户机B的事务已经提交，因此，account表中“甲”账户的余额从200元增加到1200元。 场景描述3：幻读现象。 将事务的隔离级别设置为repeatable read可以避免脏读以及不可重复读现象，但可能出现幻读现象。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，查询account表中是否存在account_no=100的账户信息，执行结果如图7所示。 12345alter table account engine=InnoDB;set session transaction isolation level repeatable read;select @@tx_isolation;start transaction;select * from account where account_no=100; 图7 事务的隔离级别设置为repeatable read 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，然后向account表中添加一条“己”账户信息，并将account_no赋值为100，最后提交事务，执行结果如图8所示。1234set session transaction isolation level repeatable read;start transaction;insert into account values(100,'己',5000);commit; 图8 向account表中添加一条“己”账户信息 步骤3：接着在MySQL客户机A上执行下面的SQL语句，查询account表中是否存在account_no=100的账户信息，执行结果如图9所示。从图中可以看出，account 表中不存在account_no=100的账户信息。1select * from account where account_no=100; 图9 查询account表中是否存在account_no=100的账户信息 步骤4：由于MySQL客户机A检测到account表中不存在account_no=100的账户信息，因此MySQL客户机A就可以向account表中插入一条account_no=100的账户信息。在MySQL客户机A上执行下面的insert语句，向account表中添加一条“庚”的账户信息，并将account_no赋值为100，执行结果如图10所示。1insert into account values(100,'庚',5000); 图10 repeatable read隔离级别可能造成幻读问题 从运行结果可以看出，account表中确实存在account_no=100的账户信息，但由于repeatable read（可重复读）隔离级别使用了“障眼法”，使得MySQL客户机A无法查询到account_no=100的账户信息，这种现象称为幻读现象。 说明幻读现象与不可重复读现象不同之处在于，幻读现象读不到其他事务已经提交（commit）的数据，而不可重复读现象读到的是其他事务已经提交（commit）的数据。 场景描述4：并发访问性能问题 避免幻读现象的方法有两个。 方法一：保持事务的隔离级别repeatable read不变，利用间隙锁的特点，对查询结果集施加共享锁（lock in share mode）或者排他锁（for update）。这种方法要求数据库开发人员了解间隙锁的特点。 方法二：将事务的隔离级别设置为serializable，可以避免幻读现象，这种方法最为简单，先以方法二为例。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为serializable，接着开启事务，查询account表中是否存在account_no=200的账户信息，执行结果如图11所示。12345alter table account engine=InnoDB;set session transaction isolation level serializable;select @@tx_isolation;start transaction;select * from account where account_no=200; 图11 将事务的隔离级别设置为serializable 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为serializable，然后开启事务，接着向account表中添加一条“庚”的账户信息，并将account_no赋值为200，执行结果如图12所示。从图中可以看出，MySQL客户机B发生锁等待现象，降低了事务间的并发访问性能（虽然解决了幻读问题）。1234set session transaction isolation level serializable;start transaction;insert into account values(200,'庚',5000); 图12 serializable隔离级别可以防止幻读问题说明 由于InnoDB存储引擎发生了锁等待超时引发的错误异常，InnoDB存储引擎回滚引发了该错误异常的事务，因此，“庚”的账户信息并没有添加到account表中。 将事务隔离级别设置为serializable，可以有效避免幻读现象。然而，serializable隔离级别会降低MySQL的并发访问性能，因此，不建议将事务的隔离级别设置为serializable。 使用间隙锁避免幻读现象MySQL默认的事务隔离级别为repeatable read。为了保持事务的隔离级别repeatable read不变，利用间隙锁的特点对查询结果集施加共享锁（lock in share mode）或者排他锁（for update），同样可以避免幻读现象，同时也不至于降低MySQL的并发访问性能。当然这种方法首先要求数据库开发人员了解InnoDB间隙锁的特点。 场景描述5：将事务的隔离级别设置为repeatable read，可以避免脏读以及不可重复读现象，但可能出现幻读现象。通过引入间隙锁，可以避免幻读现象。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，查询account表中是否存在account_no=200的账户信息，执行结果如图13所示。 12345alter table account engine=InnoDB;set session transaction isolation level repeatable read;select @@tx_isolation;start transaction;select * from account where account_no=200 lock in share mode; 图13 将事务的隔离级别设置为repeatable read 说明虽然account表中不存在account_no=200的账户信息，但最后一条 select语句为account_no=200的账户信息施加了间隙锁（共享锁）。 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，然后向account表中添加一条“庚”的账户信息，并将account_no赋值为200。insert语句将被阻塞，执行结果如图14所示。 123set session transaction isolation level repeatable read;start transaction;insert into account values(200,'庚',5000); 图14 使用间隙锁锁定account_no=200的账户，insert语句被阻塞 步骤3：接着在MySQL客户机A上执行下面的SQL语句，查询account表中是否存在account_no=200的账户信息，执行结果如图15所示。从图中可以看出，account表中不存在account_no=200的账户信息。 1select * from account where account_no=200;lock in share mode 图15 查询account表中是否存在account_no=200的账户信息 步骤4：由于MySQL客户机A检测到account表中不存在account_no=200的账户信息，因此MySQL客户机A就可以向account表中插入一条account_no=200的账户信息。在MySQL客户机A上执行下面的insert语句，向account表中添加一条“庚”的账户信息，并将account_no赋值为200，执行结果如图16所示。1insert into account values(200,'庚',5000); 图16 成功添加account_no=200的账户信息 从运行结果可以看出，当MySQL的事务隔离级别是repeatable read时，数据库开发人员可以利用间隙锁的特点，避免幻读现象。 事务与锁机制注意事项使用事务与锁机制还应该注意以下内容。 锁的粒度越小，应用系统的并发性能就越高。由于InnoDB支持行级锁，如果需要提高应用系统的并发性能，建议选用InnoDB存储引擎。 如果事务的隔离级别无法解决事务的并发问题，数据库开发人员只有在完全了解锁机制的情况下，才能在SQL语句中手动设置锁，否则应该使用事务的隔离级别。 使用事务时，尽量避免在一个事务中使用不同存储引擎的表。 尽量缩短锁的生命周期。例如，在事务中避免使用长事务，可以将长事务拆分成若干个短事务。在事务中避免使用循环语句。 优化表结构，优化SQL语句，尽量缩小锁的作用范围。例如，可以将大表拆分成小表，从而缩小锁的作用范围。 InnoDB 默认的事务隔离级别是 repeatable read，而 repeatable read 隔离级别使用间隙锁实现InnoDB的行级锁。不合理的索引可能导致行级锁升级为表级锁，从而引发严重的锁等待问题。 对于InnoDB行级锁而言，设置锁等待超时参数为合理范围，编写锁等待超时异常处理程序，解决发生锁等待问题（甚至死锁）。 为避免死锁，一个事务对多条记录进行更新操作时，当获得所有记录的排他锁后，再进行更新操作。 为避免死锁，一个事务对多个表进行更新操作时，当获得所有表的排他锁后，再进行更新操作。 为避免死锁，确保所有关联事务均以相同的顺序访问表和记录。 必要时，使用表级锁来避免死锁。 避免在一个单独事务中混合使用存储引擎。在服务器级别，MySQL不能管理事务，事务是由存储引擎实现的，尽量避免在一个单独事务中混合使用存储引擎。如果在一个单独事务中混合了事务表和非事务表，若一切正常，这个事务就没有问题；但是如果执行回滚操作，非事务表改变的数据并不会回滚。若数据库的一致性遭到了破坏，则很难恢复和呈现完整的事务。 习题1．请简单描述事务的必要性。 2．关闭MySQL自动提交的方法有哪些？您推荐数据库开发人员使用哪一种方法？ 3．关闭MySQL自动提交后，提交更新语句的方法有哪些？您推荐数据库开发人员使用哪一种方法？ 4．请简单描述典型的事务处理使用方法。 5．请简单描述典型的事务保存点使用方法。您是如何理解保存点是“临时状态”这句话的？ 6．请简单描述锁机制的必要性。 7．为MyISAM表施加表级锁的语法格式是什么？ 8．为MyISAM表施加表级锁时，read local与read选项有什么区别？ 9．您是如何理解锁的粒度、隐式锁与显式锁、锁的类型、锁的钥匙以及锁的生命周期等概念的？ 10．您如何理解锁的粒度、锁的生命周期与数据库的并发性能之间的关系？ 11．您如何理解锁的粒度、锁的生命周期与服务器资源之间的关系？ 12．“选课系统”应该使用哪种粒度的锁机制？为什么？ 13．为InnoDB表施加行级锁的语法格式是什么？ 14．请列举现实生活中的“资源竞争”问题，如何使用锁机制解决此类“资源竞争”问题？ 15．完成调课功能的replace_course_proc()存储过程以及完成选课功能choose_proc()存储过程使用了行级锁解决了“资源竞争”问题，能不能将存储过程中下面的select语句写在“start transaction;”语句之前，以便缩短行级锁的生命周期？1select state into status from course where course_no=c_no; 16．InnoDB什么时候使用间隙锁，什么时候使用记录锁？间隙锁与记录锁之间的区别是什么？ 17．锁等待与死锁之间是什么关系？ 18．请解释事务的ACID特性。 19．MySQL支持哪些事务隔离级别？默认的事务隔离级别是什么？ 20．每一种事务隔离级别可能引发什么问题？ 21．脏读现象、不可重复读现象以及幻读现象之间有什么区别？ 22．您如何理解事务、锁机制、事务的隔离级别之间的关系？]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态设计模式]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 什么是状态模式 何时使用状态模式 状态机 开灯关灯：最简单的状态设计模式 情景为王 状态 客户通过上下文做出请求 增加状态 改变接口 改变状态 更新Context类 更新客户 导航工具：更多选择和单元格 建立一个矩阵状态图 建立接口 上下文 状态 客户选择一条路径 状态模式与PHP 什么是状态模式状态（State）设计模式是GoF提出的最吸引人的模式之一，也是一种最有用的模式。游戏通常就采用状态模式，因为游戏中的对象往往会非常频繁地改变状态。状态模式的作用就是允许对象在状态改变时改变其行为。还有很多其他模拟应用（不一定是游戏）也依赖于状态模式。你会发现状态模式有很多应用。图1用类图方式显示了这种基本设计模式。 图1：状态设计模式类图 如图所示，这里没有Client类；不过，GoF指出Context是客户的主要接口。查看这个模式时，可以认为Client类通过ConText类做出请求。 何时使用状态模式如前所述，游戏开发人员通常使用状态模式来处理不同的状态。PHP中几乎每一个应用都会有一些状态改变，一个对象依赖于它的状态时，它肯定会频繁地改变，在这种情况下，状态模式就有绝对的优势。 对象中频繁的状态改变非常依赖于条件语句。就其自身来说，条件语句本身没有什么问题（如switch语句或那些带else子句的语句）。不过，如果选项太多，以至于程序开始出现混乱，或者增加或改变选项需要花费太多时间，甚至成为一种负担，这就出现了问题。 先来看模拟器或游戏的一个简单例子。假设有一个3x3的矩阵，也就是9个状态，不同的单元格（共有9个单元格）会有不同的选择。考虑图2中的矩阵。 图2：3 x 3矩阵 假设你创建了一个程序，可以上下移动和左右移动，但是不能沿对角线方向移动。如果在单元格5（见图2）上，对象可以向任何方向移动（上下和左右都可以），不过除了这个单元格以外，采用传统方式编程时，对于其他单元格都需要某个条件语句。考虑单元格4的移动，可能会有类似下面的代码:12345678910111213141516if($this-&gt;moveUp())&#123; $this-&gt;currentCell = $cell_1;&#125;elseif ($this-&gt;moveDown())&#123; $this-&gt;currentCell = $cell_7;&#125;elseif ($this-&gt;moveRight())&#123; $this-&gt;currentCell = $cell_5;&#125;elseif ($this-&gt;moveLeft())&#123; $this-&gt;currentCell = $errorMove;&#125; 在此基础上，程序必须跟踪对象在哪些单元格“中”。可以看到，条件语句的个数（或switch语句中的case个数）可能会大幅增长，使程序变得纠缠不清。 对于状态设计模式，每个状态都有自己的具体类，它们实现一个公共接口。我们不打算查看对象的控制流，而是从另一个角度来考虑，即对象的状态。下一节分析状态机，通过介绍，你将更好地理解“以状态为中心”的思路。 状态机状态机是一个模型，其重点包括不同的状态、一个状态到另一个状态的变迁，以及导致状态改变的触发器。要研究状态机，最好的起点是状态图（statechart），我们将用状态图来分析，而不是一个计算机流程图或类图。图3为一个简单的状态图，其中一个灯泡的状态从关（off）变为开（on）。 图3：显示灯泡状态的状态图 与类图相似，状态图强调的是控制流以外的东西。从图3可以看到状态模型的本质： 状态（关灯和开灯） 变迁（从关灯到开灯，以及从开灯到关灯） 触发器（灯开关） 对于打开和关上的灯，其状态、变迁和触发器都非常简单。变迁是即时的，触发器就是灯开关。不过，触发器请求一个改变之后，有些变迁可能需要渐进完成，或者要采用更复杂的方式完成。例如，天气触发树叶颜色的改变，这个变迁就是渐进完成的。不过，可以使用这个状态模型来理解从夏天状态变换到秋天状态，另外只要是通过一个触发器激活从一个状态到另一个状态的状态变迁，这种情况都可以使用这个状态模型来理解。 开灯关灯:最简单的状态设计模式尽管状态机的概念相当简单，但要知道，即使是最基本的状态设计模式也可能很有难度。考虑到这一点，这个最简单的PHP模式例子将重点考虑创建模式的步骤。有一个好消息，如果你能完成一个简单的状态设计模式，那么更大规模的模式也能轻松应对。所以我们慢慢来，先来看这个模式中的各个参与者。 情境为王所有状态模式都需要一个参与者来跟踪对象所处的状态。例如，对于前面的灯泡状态例子，就很有必要记住图2中的矩形。如果当前状态是单元格4，系统需要知道可以通过哪些变迁进入其他状态。这正是ConText类要完成的任务。要知道第一个例子只处理两个状态，即灯的状态（关或开）。Context要知道当前状态是什么。使用图3中的状态图作为指导，可以看到初始状态为关（由一个带箭头的黑色小球指示）。 作为一个参考点，首先来看ConText类。下面几小节将分析这个上下文，了解它的各个部分以及各部分的角色：1234567891011121314151617181920212223242526272829303132333435363738394041// Context.phpclass Context&#123; private $offState; private $onState; private $currentState; public function __construct() &#123; $this-&gt;offState = new OffState($this); $this-&gt;onState = new OnState($this); // 开始状态为off $this-&gt;currentState = $this-&gt;offState; &#125; // 调用状态方法触发器 public function turnOnLight() &#123; $this-&gt;currentState-&gt;turnLightOn(); &#125; public function turnOffLight() &#123; $this-&gt;currentState-&gt;turnLightOff(); &#125; // 设置当前状态 public function setState(IState $state) &#123; $this-&gt;currentState = $state; &#125; // 获得状态 public function getOnState(): &#123; return $this-&gt;onState; &#125; public function getOffState() &#123; return $this-&gt;offState; &#125;&#125; ConText类建立了3个属性，可见性均为私有(private):123$offState$onState$currentState 前两个分别是两个状态的实例，第三个属性用来跟踪给定时间系统所处的状态。 ConText类中的状态实例 在构造函数中，Context实例化IState实现的两个实例--一个对应关(off)状态，另一个对应开(on)状态:12$this-&gt;offState = new OffState($this);$this-&gt;onState = new OnState($this); 这个实例化过程用到了一种递归，称为自引用(self-referral)。构造函数参数中的实参写为$this，这是Context类自身的一个引用。状态类希望接收一个ConText类实例作为参数，为了在ConText类中实例化一个状态实例，它必须使用$this作为实参。 由于必然有某个状态作为启动时的当前状态，将$currentState属性赋为$offState值。(可以这样考虑，刚走进一个房间，当时灯是关着的。)这是offState类的一个实例。查看图3中的状态图，可以看到开始状态是off状态，所以代码只是遵循了状态图中的结构。 调用状态方法:上下文触发器方法Context类中的一些方法要调用状态类中的方法。可以把这些方法想成是触发器(triggers)。调用这些触发器，就会启动从当前状态到另外一个不同状态的变迁。举例来说，下面的方法就是一个触发器:1234public function turnOnLight()&#123; $this-&gt;currentState-&gt;turnLightOn();&#125; 注意， context方法的名字与状态方法稍有不同:这里是turnOnLight而不是turnLightOn，这些差别只是为了将Context类中的触发器方法与状态实例中的方法相区别。 设置当前状态Context类最重要的作用是跟踪当前状态，从而为系统提供一个正确的上下文或窗口。再回到图2中的矩阵，矩阵中的每一步移动都取决于当前单元格。对于单元格9，可以移到单元格8或单元格6 (不允许沿对角线方向移动)。不过，系统必须知道它的当前状态是单元格9，这样才能知道有哪些选择。 要设置一个当前状态，必须以某种方式向Context类发送信息，指定当前状态。这是通过某个状态类完成的。一旦触发一个状态，这个状态就会向Context发送一个消息，指示“我是当前状态”:1234public function setState(IState $state)&#123; $this-&gt;currentState = $state;&#125; setState()方法需要一个状态对象作为实参(由IState类型提示指示)。触发器方法触发时，它会调用一个状态和相关的方法。这个状态的方法必须向Context发送一个消息，指出现在该状态是当前状态。所以最近触发的状态会调用setState()方法，使它成为当前状态。 状态获取方法最后， context类需要有办法得到当前状态发送的消息。这个消息通过获取方法传递。对于每一个状态，context都要有相应的获取方法。由于这个例子有两个状态类，所以只需要两个获取方法。OffState的获取方法如下:.1234public function getOffState()&#123; return $this-&gt;offState;&#125; OnState的获取方法如下:1234public function getOnState()&#123; return $this-&gt;onState;&#125; 在实现的状态类中可以看到，这些方法将在设置当前状态时使用。 Context类小结Context实例化所有状态的实例，并设置默认状态。Context包含有一些方法，可以通过调用具体状态中的相应方法来触发不同的状态。设置方法会跟踪当前状态。为了帮助跟踪当前状态，对于每个状态Context还有一个获取方法，会在状态有改变调用。 状态如果了解了具体状态类如何实现Istate接口，就更能看出Context类的意义。这个接口只包含两个要实现的状态方法:123456//IState.phpinterface IState&#123; public function turnLightOn(); public function turnLightOff();&#125; 在Context类中，这两个方法都称为状态改变触发器。不过，重要的细节都在以下这两个状态类的实现中: OnState和OffState. OnState1234567891011121314151617181920// OnState.phpclass OnState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "Light is already on-&gt; take no action&lt;br/&gt;"; &#125; public function turnLightOff() &#123; echo "Lights off!&lt;br/&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOffState()); &#125;&#125; OffState12345678910111213141516171819// OffState.phpclass OffState implements IState&#123; private $context; public function __construct(Context $contextNow) $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "Lights on! Now I can see &lt;br/&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOnState()); &#125; public function turnLightOff() &#123; echo "Light is already off-&gt; take no action&lt;br/&gt;"; &#125;&#125; OnState和OffState类是IState的简单实现，会有文本消息指示这些状态。状态类在构造函数中包含了Context类的一个引用。应该记得，Context会实例化状态实例，并为状态构造函数类提供一个自引用。 默认状态是OffState，它必须实现IState方法turnLightOn和turnLightOff。Context调用turnLightOn方法，这会显示”Lights on! Now I can see” (开灯了，现在我能看见了)。然后它向Context方法getOnState发送一个消息，将OnState作为当前状态。不过，如果是调用OffState中的turnLightOff，就只有一个消息指示灯已经关了，不会有任何动作。它不会重置Context中的当前状态，因为这已经是当前状态。基本说来，如果请求一个状态启动它自身，就什么也不会做。类似地，如果请求触发一个无法触发的状态，同样什么也不会做。 再来看图2中9个单元格的矩阵。从单元格3可以合法地移动到单元格2或单元格6。不过，在单元格3状态中，它不能上移或右移。所以，如果它接收到一个指令，要求启动一个它无法达到的状态，对于这种不可达到的状态，通常程序员会提供一个null条件。 客户通过上下文做出请求Client的所有请求都通过Context做出。 Client与任何状态类之间都没有直接连接，包括IState接口。下面的Client显示了触发两个状态类中所有方法的请求:12345678910111213141516171819// Client.phpfunction __autoload($class_name)&#123; include $class_name . '.php';&#125;class Client&#123; private $context; public function __construct() &#123; $this-&gt;context = new Context(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnOffLight(); $this-&gt;context-&gt;turnOffLight(); &#125;&#125;$worker = new Client(); 实例化一个Context实例之后，初始请求是打开灯，因为灯的默认状态是“关”(off)状态。第二个请求是一样的，不过它只生成一个消息，指示系统目前所处的状态正是请求的这个状态，什么也不会发生。以下输出显示了这些请求的结果:1234Lights on! Now I can see!Light is already on-&gt; take no actionLights off!Light is already off-&gt; take no action OffState请求的工作类似于OnState请求。如果变迁是从一个状态到另一个状态(off-&gt;on)，就会启动这个改变。不过，如果再次请求当前状态(off-&gt;off)，只会生成一个消息，指示什么也不会发生。 增加状态对于所有设计模式来说，很重要的一个方面是:利用这些设计模式可以很容易地做出修改。与其他模式一样，状态模式同样也很易于更新和改变。对于前面最简单的例子(只包含基本的on/off状态) ，为了查看增加状态有什么影响，下面这个例子会扩展on/off状态，变成一个3路灯泡。在这个新应用中，状态将加倍，变成4个状态: 关(Off) 开(On) 更亮(Brighter) 最亮(Brightest) 图4显示了这个更新后的4态状态图。 查看这4个状态，序列有所改变。“关”(off)状态只能变到“开”(on)状态，on状态不能变到off状态。实际上，现在规则有变化，on状态只能变到“更亮”(brighter)状态和“最亮”(brightest)状态。只有brightest状态可以变到“关”(off)状态。 改变接口要改变的第一个参与者是接口IState，这个接口中必须指定相应的方法，可以用来迁移到brighter和brightest状态:12345678// IState.phpinterface IState&#123; public function turnLightOff(); public function turnLightOn(); public function turnBrighter(); public function turnBrightest();&#125; 现在所有状态类都必须包括这4个方法，它们都需要结合到Context类中。 改变状态状态设计模式中有改变时，这些新增的改变会对模式整体的其他各方面带来影响。不过，增加改变相当简单，因为状态图显示了变迁，而且在这种情况下，每个状态只有一个特定的变迁。我们不再使用文本，现在每个状态都有该状态的一个图形表示。如果变迁合法，就会显示一个特定的图像(如果变迁不合法，会显示nada.png图像) 。 OffState1234567891011121314151617181920212223242526272829// OffState.phpclass OffState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/on.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOnState()); &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; OnState1234567891011121314151617181920212223242526272829// OnState.phpclass OnState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/brighter.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getBrighterState()); &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; BrighterState1234567891011121314151617181920212223242526272829// BrighterState.phpclass BrighterState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/brightest.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getBrightestState()); &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; BrightestState1234567891011121314151617181920212223242526272829// BrightestState.phpclass BrighterState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/off.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOffState()); &#125;&#125; 需要说明，各个状态的方法中有且仅有一个方法会建立负图像。不过，三路灯具正是采用这种方式使用三路灯泡。打开灯之后，它必须经过另外两个状态(brighter和brightest)，才会最后关掉。 更新Context类最后一步是更新Context类，增加新的触发器，并加入新状态。另外，Context还需要为每个新状态增加状态实例和获取方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php// Context.phpclass Context&#123; private $offState; private $onState; private $brighterState; private $brightestState; private $currentState; public function __construct() &#123; $this-&gt;offState = new OffState($this); $this-&gt;onState = new OnState($this); $this-&gt;brighterState = new BrighterState($this); $this-&gt;brightestState = new BrightestState($this); // 开始状态为Off $this-&gt;currentState = $this-&gt;offState; &#125; //调用状态方法 public function turnOnLight() &#123; $this-&gt;currentState-&gt;turnLightOn(); &#125; public function turnoffLight() &#123; $this-&gt;currentState-&gt;turnLightOff(); &#125; public function turnBrighterLight() &#123; $this-&gt;currentState-&gt;turnBrighter(): &#125; public function turnBrightestLight() &#123; $this-&gt;currentState-&gt;turnBrightest(); &#125; //设置当前状态 public function setState(IState $state) &#123; $this-&gt;currentState = $state; &#125; //获得状态 public function getOnState() &#123; return $this-&gt;onState; &#125; public function getOffState() &#123; return $this-&gt;offState; &#125; public function getBrighterState() &#123; return $this-&gt;brighterState; &#125; public function getBrightestState() &#123; return $this-&gt;brightestState; &#125;&#125;?&gt; 增加的代码与之前状态的方法以及实例化是一样的。尽管Context类增加了代码，不过与原来的代码很类似，只是有更多内容。 更新客户在最初的例子中， Client可以请求两个状态on或off。增加两个状态后，Client有了更多选择，不过默认状态仍然是off，第一个请求必然是on状态。一旦建立on状态，接下来可以请求brighter状态，然后是brightest状态，之后才能再次请求off:12345678910111213141516171819202122// Client.phpfunction __autoload($class_name)&#123; include $class_name . '.php'; &#125;class Client&#123; private $context; public function __construct() &#123; $this-&gt;context = new Context(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnBrighterLight(); $this-&gt;context-&gt;turnBrightestLight(); $this-&gt;context-&gt;turnOffLight(); $this-&gt;context-&gt;turnBrightestLight(); &#125;&#125;$worker = new Client(); 修改后的Client中，按正确的序列发出请求，首先变迁到on状态。不过，在经过各个不同状态回到off状态之后，Client请求返回brightest状态。此时，会出现“错误指示灯”。图5显示了请求序列得到的不同图像。 前面4个灯泡从左到右分别显示了on，brighter，brightest和off状态。不过，第5个灯泡指示请求出现错误。在典型的状态模式实现中，不会出现错误消息(或图像)。这个请求将被简单忽略。 状态这9个状态表示3 x3矩阵中的不同单元格。为了唯一地显示各个单元格,会分别显示一个图像作为标签(有不同的数字和颜色) 。这样一来,能够更清楚地看出穿过矩阵的路线。这9个状态类都包含实现IMatrix接口所需的4个方法。在前面的状态例子中,如果一种选择不合法(如三路灯泡中从on状态直接变到brightes状态) ,并不是显示一个不合法的调用,这里只提供了注释行,指示代码中有一个不合法的移动。 状态模式与PHP很多人把状态设计模式看做是实现模拟器和游戏的主要方法。总的说来,这确实是状态模式的目标,不过除此以外,状态模型(状态引擎)和状态设计模式在PHP中也有很多应用。用PHP完成更大的项目时,包括Facebook和WordPress,会有更多的新增特性和当前状态需求。Grady Booch (http:libm.colyCL6se)指出, Facebook一方面要保证网站更新,同时在以指数速度扩张时(即使有很多程序员也不能满足需要)仍要保持正常工作,要做到这一点难度越来越大。对于这种不断有改变和增长的情况,就可以采用可扩展的状态模式来管理。PHP开发人员如何创建包含多个状态的程序,将决定状态模式的使用范围。所以不仅状态机在游戏和模拟世界中有很多应用,实际上状态模型还有更多适用的领域。只要PHP程序的用户会用到一组有限的状态,开发人员就可以使用状态设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL锁机制]]></title>
    <url>%2F2018%2F11%2F26%2FMySQL%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 只有通过索引字段检索数据的查询语句或者更新语句，才可能施加行级锁，否则InnoDB将使用表级锁。怎么理解？ 给MyISAM表施加表级锁不会导致死锁问题的发生，给InnoDB表施加行级锁可能导致死锁问题的发生。为什么？ MySQL为什么会存在内存中的数据与外存中的数据不同步？ for update必须写在事务吗？ InnoDB存储引擎支持行级锁和表级锁吗？ 为什么读锁也称为共享锁，写锁也称为排他锁或者独占锁？ lock tables account read;是什么意思？ 使用low_priority write选项降低写锁的优先级，以便MySQL客户机A及时取得读锁，不被饿死。怎么理解？ 在同一时刻，如果数据库仅仅为单个MySQL客户机提供服务，仅通过事务机制即可实现数据库的数据一致性。但更多时候，在同一时刻，多个并发用户往往需要同时访问（检索或者更新）数据库中的同一个数据，此时仅仅通过事务机制无法保证多用户同时访问同一数据的数据一致性，因此有必要引入另一种机制实现数据的多用户并发访问。锁机制是MySQL实现多用户并发访问的基石。 锁机制的必要性MySQL客户机A与MySQL客户机B执行同一条SQL语句“select * from account;”时产生的结果截然不同，继而产生数据不一致问题。这种数据不一致问题产生的深层次原因在于，内存中的数据与外存中的数据不同步造成的（或者说是由内存中的表记录与外存中的表记录之间存在“同步延迟”造成的）。 MySQL客户机A访问数据时，如果能够对该数据“加锁”，阻塞（或者延迟）MySQL客户机B对该数据访问，直到MySQL客户机A数据访问结束，内存与外存中的数据同步后，MySQL客户机A对该数据“解锁”，“解锁”后，被阻塞的MySQL客户机B“被唤醒”，继而可以继续访问该数据，这样就可以实现多用户下数据的并发访问，如图1所示。 图1 多用户下数据并发访问的实现原理 简言之，内存数据与外存数据之间的同步延迟，可以通过锁机制将“并发访问”延迟，进而实现数据的一致性访问以及并发访问。 当然，单条更新语句运行期间也会产生同步延迟。update语句的执行过程可以简单描述为如下步骤，如图2所示。1update account set balance = balance + 800 where account_no = 2; 图2 单条更新语句的延迟无法避免 步骤1：使用索引查询是否存在“account_no=2”的账户信息。 步骤2：若存在，将该账户信息从外存加载到内存，在内存中生成old记录。 步骤3：修改old记录中的balance字段值，在内存中生成new记录。 步骤4：将内存中的new记录写入到外存，完成update操作。 上述每一个步骤的执行都需要一定的时间间隔（虽然短暂）。单个update语句运行期间，从步骤1运行到步骤4同样会产生延迟，这种延迟根本就无法避免，数据库开发人员也无需理会这种延迟，毕竟单条SQL语句运行期间会作为一个“原子”操作运行。数据库开发人员需要考虑的问题是:如何借助锁机制，解决多用户并发访问可能引起的数据不一致问题？ MySQL锁机制的基础知识简单地说，MySQL锁机制涉及的内容包括：锁的粒度、隐式锁与显式锁、锁的类型、锁的钥匙以及锁的生命周期等。 锁的粒度锁的粒度是指锁的作用范围。就像读者有了防盗门的钥匙就可以回到“家”中，有了卧室的钥匙就可以进到卧室，有了保险柜的钥匙就可以打开保险柜，每一种“资源”存在一个与之对应“粒度”的锁，数据库亦是如此。对于MySQL而言，锁的粒度可以分为服务器级锁（server-level locking）和存储引擎级锁（storage-engine-level locking）。 服务器级锁是以服务器为单位进行加锁，它与表的存储引擎无关。在MySQL基础知识章节中讲解数据库备份时，为了保证数据备份过程中不会有新的数据写入，使用MySQL命令“flush tables with read lock;”锁定了当前MySQL服务实例，该锁是服务器级锁，并且是服务器级“读锁”。 也就是说， MySQL客户机A执行了MySQL命令“flush tables with read lock;”，锁定了当前MySQL服务实例后，MySQL客户机A针对服务器的写操作（例如insert，update，delete以及create等语句）抛出如下错误信息。1ERROR 1223（HY000）: Can't execute the query because you have a conflicting read lock 其他MySQL客户机（例如MySQL客户机B）针对服务器的写操作（例如insert，update，delete以及create等语句）被阻塞。 只有MySQL客户机A执行“unlock tables;”命令或者关闭MySQL客户机A的服务器连接，释放服务器级读锁后，才会“唤醒”MySQL客户机B的写操作，MySQL客户机B的写操作才能得以继续执行。MySQL客户机A施加的服务器级锁，只有MySQL客户机A才能解锁。 例如，在MySQL客户机A上锁定了当前MySQL服务实例后，在MySQL客户机B上创建视图test view将被阻塞，而在MySQL客户机A上创建视图test view将产生错误信息（ERROR 1223）。MySQL客户机A解锁后，MySQL客户机B才能成功创建视图test view，如图3所示（注意图中的粗体字）。从执行结果可以看出，MySQL客户机A施加服务器级锁后，该锁对MySQL客户机A的后续操作以及对MySQL客户机B的后续操作产生的效果并不相同。 图3 服务器级读锁的使用 存储引擎级锁分为表级锁以及行级锁。表级锁是以表为单位进行加锁，MyISAM与InnoDB存储引擎的表都支持表级锁。行级锁是以记录为单位进行加锁，在MyISAM与InnoDB存储引擎中，只有InnoDB存储引擎支持行级锁。 小结：服务器级锁的粒度最大，表级锁的粒度次之，行级锁的粒度最小。锁粒度越小，并发访问性能就越高，越适合做并发更新操作（InnoDB表更适合做并发更新操作）；锁粒度越大，并发访问性能就越低，越适合做并发查询操作（MyISAM表更适合做并发查询操作）。另外，锁粒度越小，完成某个功能时所需要的加锁、解锁的次数就会越多，反而会消耗较多的服务器资源，甚至会出现资源的恶性竞争，甚至发生死锁问题。 对于“选课系统”而言，系统需要为上百名学生，甚至几百名学生同时提供选课、调课、退课服务。为了提高并发性能，“选课系统”将选用行级锁，这也是“选课系统”的各个数据库表使用InnoDB存储引擎的原因（InnoDB存储引擎支持行级锁）。 隐式锁与显式锁MySQL锁分为隐式锁以及显式锁。多个MySQL客户机并发访问同一个数据时，为保证数据的一致性，数据库管理系统会自动地为该数据加锁、解锁，这种锁称为隐式锁。隐式锁无需数据库开发人员维护（包括粒度、加锁时机、解锁时机等）。 如果应用系统存在多用户并发访问数据的行为，有时单靠隐式锁无法实现数据的一致性访问要求（例如多个学生同时选修同一门课程），此时需要数据库开发人员手动地加锁、解锁，这种锁称为显式锁。对于显式锁而言，数据库开发人员不仅需要确定锁的粒度，还需要确定锁的加锁时机（何时加锁）、解锁时机（何时解锁）以及锁的类型。 锁的类型锁的类型包括读锁（read lock）和写锁（write lock），其中读锁也称为共享锁，写锁也称为排他锁或者独占锁。 读锁（read lock）：如果MySQL客户机A对某个数据施加了读锁，加锁期间允许其他MySQL客户机（例如MySQL客户机B）对该数据施加读锁，但会阻塞其他MySQL客户机（例如MySQL客户机C）对该数据施加写锁，除非MySQL客户机A释放该数据的读锁。简言之，读锁允许其他MySQL客户机对数据同时“读”，但不允许其他MySQL客户机对数据任何“写”（如图4所示）。如果“数据”是表，则该读锁是表级读锁；如果“数据”是记录，则该读锁是行级读锁。 图4 读锁的使用 写锁（write lock）：如果MySQL客户机A对某个数据施加了写锁，加锁期间会阻塞其他MySQL客户机（例如MySQL客户机B）对该数据施加读锁以及写锁，除非MySQL客户机A释放该数据的写锁。简言之，写锁不允许其他MySQL客户机对数据同时“读”，也不允许其他MySQL客户机对数据同时“写”（见图5）。如果“数据”是表，则该写锁是表级写锁；如果“数据”是记录，则该写锁是行级写锁。 图5 写锁的使用 锁的钥匙多个MySQL客户机并发访问同一个数据时，如果MySQL客户机A对该数据成功地施加了锁，那么只有MySQL客户机A拥有这把锁的“钥匙”，也就是说，只有MySQL客户机A能够对该锁进行解锁操作。 锁的生命周期锁的生命周期是指在同一个MySQL会话内，对数据加锁到解锁之间的时间间隔。锁的生命周期越长，并发访问性能就越低；锁的生命周期越短，并发访问性能就越高。另外，锁是数据库管理系统重要的数据库资源，需要耗费一定的服务器内存，锁的生命周期越长，该锁占用服务器内存的时间间隔就越长；锁的生命周期越短，该锁占用服务器内存的时间间隔就越短。因此为了节省服务器资源，数据库开发人员必须尽可能的缩短锁的生命周期，尽可能早地释放锁资源。 小结：不恰当的锁粒度、锁生命周期不仅会影响数据库的并发性能，还会造成锁资源的浪费。 MyISAM表的表级锁对MyISAM存储引擎的表进行检索（select）操作时，select语句执行期间（时间间隔虽然短暂），MyISAM存储引擎会自动地给涉及到的MyISAM表施加“隐式读锁”；select语句执行完毕后，MyISAM存储引擎会自动地为这些表进行“解锁”。因此select语句的执行时间就是“隐式读锁”的生命周期。 对MyISAM存储引擎的表进行更新（insert、update以及delete）操作时，更新语句（例如insert、update以及delete）执行期间（时间间隔虽然短暂），MyISAM存储引擎会自动地给涉及到的MyISAM表施加“隐式写锁”；更新语句执行完毕后，MyISAM存储引擎会自动地为这些表进行解锁，更新语句的执行时间就是“隐式写锁”的生命周期。 可以看到，任何针对MyISAM表的查询操作或者更新操作，都会隐式地施加表级锁。隐式锁的生命周期非常短暂，且不受数据库开发人员的控制。 有时，应用系统要求数据库开发人员延长MyISAM表级锁的生命周期，MySQL为数据库开发人员提供了显式地施加表级锁以及显式地解锁的MySQL命令，以便数据库开发人员能够控制MyISAM表级锁的生命周期，MySQL客户机A施加表级锁以及解锁的MySQL命令的语法格式如图6所示。 图6 表级锁的使用 注意事项： （1）上述语法格式主要针对MyISAM表显式地施加表级锁以及解锁，该语法格式同样适用于InnoDB表。只不过因为InnoDB表支持行级锁，在InnoDB表中表级锁的概念比较淡化。 （2）read与write选项的功能在于说明施加表级读锁还是表级写锁。对表施加读锁后，MySQL客户机A对该表的后续更新操作将出错，错误信息如上图所示；MySQL客户机B对该表的后续查询操作可以继续进行，而对该表的后续更新操作将被阻塞。出错与阻塞是两个不同的概念。 MySQL客户机A对表施加写锁后，MySQL客户机A的后续查询操作以及后续更新操作都可以继续进行；MySQL客户机B对该表的后续查询操作以及后续更新操作都将被阻塞。 MySQL客户机A为某个表加锁后，加锁期间MySQL客户机A对该表的后续操作，MySQL客户机B对该表的后续操作以及MySQL客户机B对该表加锁之间的关系如表1所示。 表1 表级锁与后续操作之间的关系 （3）MySQL客户机A使用lock tables命令可以同时为多个表施加表级锁（包括读锁或者写锁），并且加锁期间，MySQL客户机A不能对“没有锁定的表”进行更新及查询操作，否则将抛出“表未被锁定”的错误信息。例如，在MySQL客户机A上运行下面的MySQL代码，对account表施加读锁，加锁期间对book表的查询操作将抛出错误信息，如图7所示。读者可以自行分析，使用显式锁后，锁的生命周期是否延长。123456alter table account engine=MyISAM;alter table book engine=MyISAM;lock tables account read;select * from account; select * from book;unlock tables; 图7 表级锁使用的注意事项（1） （4）如果需要为同一个表同时施加读锁与写锁，那么需要为该表起两个别名，以区分读锁与写锁。 例如，下面的MySQL代码首先将account表的存储引擎设置为MyISAM。然后向account表同时施加读锁（account表的别名为a）以及写锁（account表的别名为b）。接着将account表重命名为a进行查询操作，将account表重命名为b进行查询操作。如果直接查询account表中的所有记录，则将抛出错误信息，原因是并没有为account表施加一个名字为account的锁，抛出错误信息”account表未被锁定”也在情理之中，执行结果如图8所示。读者可以自行分析，使用显式锁后，锁的生命周期是否延长。123456alter table account engine=MyISAM;lock tables account as a read，account as b write;select * from account as a;select * from account as b;select * from account; unlock tables; 图8 表级锁使用的注意事项（2） 说明为了便于理解，读者可以认为每个表的锁必须有锁名，且默认情况下锁名就是表名。当某个表既存在读锁又存在写锁时，需要为表名起多个别名，且每个别名对应一个锁名。 （5）read local与read选项之间的区别在于，如果MySQL客户机A使用read选项为某个MyISAM表施加读锁，加锁期间，MySQL客户机A以及MySQL客户机B都不能对该表进行插入操作。如果MySQL客户机A使用read local选项为某个MyISAM表施加读锁，加锁期间，MySQL客户机B可以对该表进行插入操作，前提是新记录必须插入到表的末尾。对InnoDB表施加读锁时，read local选项与read选项的功能完全相同。 场景描述1：read local与read选项之间的区别。 首先在MySQL客户机A上执行下面的MySQL命令，并为account表施加local读锁。12alter table account engine=MyISAM;lock tables account read local; 然后打开MySQL客户机B，在MySQL客户机B上执行下面的insert语句，向account表中添加一条记录，执行结果如图9所示。从执行结果可以看出，MySQL客户机A为account表施加local读锁后，MySQL客户机B可以向account表中添加记录。local关键字使得MyISAM表最大限度地支持查询和插入的并发操作。1insert into account values（null， '丁'， 1000）; 图9 read local选项的使用 最后在MySQL客户机A上执行下面的MySQL命令，为account表解锁。1unlock tables; （6）MySQL客户机A对某个表施加读锁的同时， MySQL客户机B对该表施加写锁，默认情况下会优先施加写锁，这是因为更新操作比查询操作更为重要。如果MySQL客户机C…Z对该表同时也施加了写锁，可能造成读锁“饿死”。为了避免读锁“饿死”，MySQL客户机B….Z可以使用low_priority write选项降低写锁的优先级，以便MySQL客户机A及时取得读锁，不被饿死。 （7）unlock tables用于解锁，它会解除当前MySQL服务器连接中所有MyISAM表的所有锁。 （8）lock tables与unlock tables语句会引起事务的隐式提交。 （9）MySQL客户机一旦关闭， unlock tables语句将会被隐式地执行。因此，如果要让表锁定生效就必须一直保持MySQL服务器连接。 InnoDB表的行级锁InnoDB表的锁比MyISAM表的锁更为复杂，原因在于InnoDB表既支持表级锁，又支持行级锁，又存在意向锁，再把事务掺入其中，会给初学者的学习带来不少麻烦。使用lock tables命令为InnoDB表施加表级锁与使用lock tables命令为MyISAM表施加表级锁的用法基本相同，不再赘述，这里主要讨论InnoDB行级锁以及意向锁的用法。 InnoDB提供了两种类型的行级锁，分别是共享锁（S）以及排他锁（X），其中共享锁也叫读锁，排他锁也叫写锁。InnoDB行级锁的粒度仅仅是受查询语句或者更新语句影响的那些记录。在查询（select）语句或者更新（ insert，update以及delete）语句中，为受影响的记录施加行级锁的方法也非常简单。 方法1：在查询（select）语句中，为符合查询条件的记录施加共享锁，语法格式如下所示。 select from 表 where 条件语句 *lock in share mode; 方法2：在查询（select）语句中，为符合查询条件的记录施加排他锁，语法格式如下所示。 select from 表 where 条件语句 *for update; 方法3：在更新（insert，update以及delete）语句中，InnoDB存储引擎将符合更新条件的记录自动施加排他锁（隐式锁），即InnoDB存储引擎自动地为更新语句影响的记录施加隐式排他锁。 说明方法1与方法2是显式地施加行级锁，方法3是隐式地施加行级锁。这3种方法施加的行级锁的生命周期非常短暂，为了延长行级锁的生命周期，最为通用的做法是开启事务。事务提交或者回滚后，行级锁才被释放，这样就可以延长行级锁的生命周期，此时事务的生命周期就是行级锁的生命周期。 场景描述2：通过事务延长行级锁的生命周期。 步骤1：在MySQL客户机A上执行下面的MySQL语句，开启事务，并为student表施加行级写锁。123use choose;start transaction;select * from student for update; 步骤2：打开MySQL客户机B ，在MySQL客户机B上执行下面的MySQL语句，开启事务，并为student表施加行级写锁。此时，MySQL客户机B被阻塞。123use choose;start transaction;select * from student for update; 步骤3：在MySQL客户机A上执行下面的MySQL命令，为student表解锁。此时，MySQL客户机A释放了student表的行级写锁，MySQL客户机B被“唤醒” ，得以继续执行。1commit; 可以看到，通过事务延长了MySQL客户机A针对student表的行级锁的生命周期。 结论：事务中的行级共享锁（S）以及行级排他锁（X）的生命周期从加锁开始，直到事务提交或者回滚，行级锁才会释放。 MySQL客户机A使用“select * from 表 where 条件语句 lock in share mode;”为InnoDB表中符合条件语句的记录施加共享锁后，加锁期间，MySQL客户机A可以对该表的所有记录进行查询以及更新操作。加锁期间，MySQL客户机B可以查询该表的所有记录（甚至施加共享锁），可以更新不符合条件语句的记录，然而为符合条件语句的记录施加排他锁时将被阻塞。 MySQL客户机A使用“select * from 表 where 条件语句 for update;”或者更新语句（例如insert，update以及delete）为InnoDB表中符合条件语句的记录施加排他锁后，加锁期间，MySQL客户机A可以对该表的所有记录进行查询以及更新操作。加锁期间，MySQL客户机B可以查询该表的所有记录，可以更新不符合条件语句的记录，然而为符合条件语句的记录施加共享锁或者排他锁时将被阻塞。 为了便于读者更好地理解共享锁以及排他锁之间的关系，可以参看表2所示的内容。 表2 行级锁与后续操作之间的关系 “选课系统”中的行级锁场景描述3：实现调课功能的存储过程replace_course_proc()存在功能缺陷。考虑这样的场景：张三与李四“同时”选择同一门目标课程，且目标课程就剩下一个席位（此时目标课程available的字段值为1）。张三以及李四为了实现调课功能，“同时”调用存储过程replace_course_proc()，假设两人“同时”执行存储过程中的select语句“查询目标课程available字段值”：1select available into s from course where course_no=c_after; 张三以及李四可能都读取到available的值为1（大于零），最后的结果是张三与李四都选择了目标课程，如图10所示。 图10 存储过程replace_course_proc()存在功能缺陷 可以看出，存储过程replace_course_proc()读取课程的available字段值时，有必要为张三与李四选择相同的目标课程施加排他锁，避免多名学生同时读取同一门课程的available字段值。将存储过程replace_course_proc()中的代码片段:1select available into s from course where course_no=c after; 修改为如下的代码片段：1select available into s from course where course_no=c_after for update; 说明为了延长行级排他锁的生命周期，将该select语句写在了start transaction语句后，封装到事务中。 此时，当张三、李四以及其他更多的学生同时“争夺”同一门目标课程的最后一个席位时，可以保证只有一个学生能够读取该席位，其他学生将被阻塞（如图11所示）。这样就可以防止张三与李四都选择了目标课程的最后一个席位。很多读者可能觉得：多个学生同时选择“最后一个席位”的可能性微乎其微，但如果最后的一个“席位”是春运期间某趟列车的最后一张火车票呢？现实生活中，类似的“资源竞争”问题还有很多（例如团购、秒杀等），使用锁机制可以有效解决此类“资源竞争”问题。 图11 解决存储过程replace_course_proc()的功能缺陷 同样的道理，在前面的章节中，实现选课功能的存储过程choose_proc()也需要进行相应的修改（粗体字部分为代码改动部分）。删除存储过程choose_proc()，并重建该存储过程。12345678910111213141516171819202122232425262728293031323334drop procedure choose_proc;delimiter $$create procedure choose_proc(in s_no char(11),in c_no int,out state int)modifies sql databegin declare s1 int; declare s2 int; declare s3 int; declare status char(8); set state= 0; set status='未审核'; select count(*) into s1 from choose where student_no=s_no and course_no=c_no ; if(s1&gt;=1) then set state = -1; else select count(*) into s2 from choose where student_no=s_no; if(s2&gt;=2) then set state = -2; else start transaction; select state into status from course where course_no=c_no; select available into s3 from course where course_no=c_no for update; if(s3=0 || status='未审核') then set state = -3; else insert into choose values(null,s_no,c_no,null,now()); set state = last_insert_id(); end if; commit; end if; end if;end$$delimiter ; InnoDB表的意向锁InnoDB表既支持行级锁，又支持表级锁。考虑如下场景：MySQL客户机A获得了某个InnoDB表中若干条记录的行级锁，此时，MySQL客户机B出于某种原因需要向该表显式地施加表级锁（使用lock tables命令即可），为了获得该表的表级锁，MySQL客户机B需要逐行检测表中是否存在行级锁，而这种检测需要耗费大量的服务器资源。 试想：如果MySQL客户机A获得该表若干条记录的行级锁之前，MySQL客户机A直接向该表施加一个“表级锁”（这个表级锁是隐式的，也叫意向锁），MySQL客户机B仅仅需要检测自己的表级锁与该意向锁是否兼容，无需逐行检测该表是否存在行级锁，这样就会节省不少服务器资源，如图12所示。 图12 InnoDB表的意向锁 由此可以看出，引入意向锁的目的是为了方便检测表级锁与行级锁之间是否兼容。意向锁是隐式的表级锁，数据库开发人员向InnoDB表的某些记录施加行级锁时，InnoDB存储引擎首先会自动地向该表施加意向锁，然后再施加行级锁，意向锁无需数据库开发人员维护。MySQL提供了两种意向锁：意向共享锁（IS）和意向排他锁（IX）。 意向共享锁（IS）：向InnoDB表的某些记录施加行级共享锁时，InnoDB存储引擎会自动地向该表施加意向共享锁（IS）。也就是说，执行“select * from 表 where 条件语句 lock in share mode;”后，InnoDB存储引擎在为表中符合条件语句的记录施加共享锁前，InnoDB会自动地为该表施加意向共享锁（IS）。 意向排他锁（IX）：向InnoDB表的某些记录施加行级排他锁时，InnoDB存储引擎会自动地向该表施加意向排他锁（IX）。也就是说，执行更新语句（例如insert、update或者delete语句）或者“select * from 表 where 条件语句 for update;”后，InnoDB存储引擎在为表中符合条件语句的记录施加排他锁前，InnoDB会自动地为该表施加意向排他锁（IX）。 说明意向锁虽是表级锁，但是却表示事务正在查询或更新某一行记录，而不是整个表，因此意向锁之间不会产生冲突。 每执行一条“select…lock in share mode”语句，该select语句在执行期间自动地施加意向共享锁，执行完毕后，意向共享锁会自动解锁，因此意向共享锁的生命周期非常短暂，且不受人为控制；意向排他锁也是如此。 某个InnoDB表已经存在了行级锁，此时其他MySQL客户机再向该表施加表级锁时，可能引发意向锁与表级锁之间的冲突。意向锁与意向锁之间以及意向锁与表级锁之间的关系如表3所示。 表3 意向锁与表级锁之间的关系 InnoDB行级锁与索引之间的关系InnoDB表的行级锁是通过对“索引”施加锁的方式实现的，这就意味着，只有通过索引字段检索数据的查询语句或者更新语句，才可能施加行级锁，否则InnoDB将使用表级锁，而使用表级锁势必会降低InnoDB表的并发访问性能。 场景描述4：索引设置不当，降低InnoDB表的并发访问性能。 步骤1：打开MySQL客户机A，在MySQL客户机A上执行下面的MySQL命令，首先将account账户表的存储引擎设置为InnoDB，接着关闭MySQL自动提交，最后对账户名为“甲”的记录施加行级排他锁，执行结果如图13所示。123alter table account engine=InnoDB;set autocommit=0;select * from account where account_name='甲' for update; 图13 对账户名为“甲”的记录施加行级排他锁 步骤2：打开MySQL客户机B，在MySQL客户机B上执行下面的MySQL命令，首先关闭MySQL自动提交，对账户名为“乙”的记录施加行级排他锁时被阻塞，执行结果如图14所示。从MySQL客户机B的执行结果可以看出，MySQL客户机B对“乙”账户施加排他锁时，出现了“锁等待”现象（被阻塞）。12set autocommit=0;select * from account where account_name='乙' for update; 图14 对账户名为“乙”的记录施加行级排他锁 按理MySQL客户机A仅仅对“甲”账户施加了排他锁，不会影响MySQL客户机B对“乙”账户施加排他锁，然而事实并非如此。原因在于，查询语句或者更新语句施加行级锁时，如果没有使用索引，查询语句或者更新语句会自动地对 InnoDB 表施加表级锁，最终导致出现了“锁等待”现象，降低了InnoDB表的并发访问性能。 说明使用MySQL命令“show variables like ‘innodb_lock_wait_timeout’;”可以查看锁InnoDB等待超时的时间（默认值为50秒，如图15所示）。当InnoDB锁等待的时间超过参数innodb_lock_wait_timeout的值时，将引发InnoDB锁等待超时错误异常（如图14所示）。图15 查看锁等待超时时间 步骤3：锁等待期间，在MySQL客户机A上执行MySQL命令“show full processlist\G”可以查看当前MySQL服务实例上正在运行的MySQL线程的状态信息，如图16所示。各个状态信息说明如下。 图16 查看MySQL服务实例上正在运行的MySQL线程 Id列：是一个标识，唯一标记了一个MySQL线程或者一个MySQL服务器连接。 User列：显示了当前的MySQL账户名。 Host列：显示每条SQL语句或者MySQL命令是从哪个MySQL客户机的哪个端口上发出。 db列：显示当前的MySQL线程操作的是哪一个数据库。 Command 列：显示该线程的命令类型，命令类型的取值一般是休眠（sleep）、查询（query）或者连接（connect）。例如，命令类型的取值是Sleep时，表示当前的线程正在等待MySQL客户机向它发送一条新语句。 Time列：显示了该线程执行时的持续时间，单位是秒。例如，time=48时，意味着该线程执行的持续时间为48秒。 State列：显示了该线程的状态，状态取值一般是init、update、sleep、sending data、空字符串或者waiting for锁类型lock。例如，当状态取值是Waiting for table metadata lock时，表示当前的线程正在等待MySQL客户机获得元数据锁，即发生了锁等待现象;当状态取值是sending data时，表示当前的线程正在向MySQL服务器发送数据。如果处于某种状态（例如sending data）的持续时间较长（例如48秒），可能出现了锁等待现象。 Info列：显示了SQL语句，因为长度有限，所以长的SQL语句仅仅显示一部分。 步骤4：使用MySQL命令“kill 49;”即可杀死图16中状态持续时间较长的线程49，并关闭与之对应的MySQL服务器连接。 对于数据库开发人员而言，如果不了解InnoDB行级锁是基于索引实现的这一特性，可能导致大量的锁冲突，从而影响并发性能：当“甲”账户在银行柜台前办理存款或者取款业务时，其他账户无法同时办理存款或者取款业务。 解决办法：使用下面的SQL语句为account表的account_name字段添加索引（索引名为account_name_index）。添加索引后，读者可以再次尝试：MySQL客户机A对“甲”账户施加了排他锁后，MySQL客户机B对“乙”账户施加排他锁时，是否还会产生“InnoDB锁等待”现象（被阻塞）。1alter table account add index account_name_index(account_name); 结论：InnoDB表的行级锁是通过对索引施加锁的方式实现的，了解InnoDB行级锁的实现方式后，很多问题都可以找到答案。例如，当检索条件为某个区间（例如account_no between 1 and 100）范围时，对该区间范围施加共享锁或排他锁后，满足该区间范围的记录（例如account_no=1或者account_no=2的记录）存在共享锁或排他锁；满足该区间范围，但表中不存在的记录（例如account_no=50 或者 account_no=100 的记录）也会存在共享锁或排他锁，即行级锁会锁定相邻的键（next-key locking），这种锁机制就是所谓的间隙锁（next-key锁），可以看出，间隙锁与索引密切相关。如果间隙锁使用得当，可以避免幻读现象；如果间隙锁使用不当，可能导致死锁问题，有关间隙锁的使用请参看本章后续内容。 说明当事务的隔离级别设置为repeatable read（这是MySQL默认的事务隔离级别），此时为InnoDB表施加行级锁，默认情况下使用间隙锁。当事务的隔离级别设置为read uncommitted或者read committed，此时为InnoDB表施加行级锁，默认情况下使用记录锁（record lock）。与间隙锁不同，记录锁仅仅为满足该查询范围的记录施加共享锁或排他锁。 数据库开发人员可以使用explain命令对查询语句进行分析，从而判断该查询语句是否使用了索引。虽然explain命令只能搭配select类型语句使用，如果想查看更新语句（例如update、delete语句）的索引效果，则保持更新条件不变，把更新语句替换成select即可。 即便在条件中使用了索引关键字，MySQL最终是根据执行计划决定是否使用索引。 间隙锁与死锁场景描述5：MySQL默认的事务隔离级别是repeatable read（稍后介绍），此时如果MySQL客户机A与MySQL客户机B针对“符合查询条件但不存在记录”施加了共享锁或者排他锁（此时的锁实际上是间隙锁），那么MySQL客户机A与MySQL客户机B都会加锁成功。加锁期间，如果MySQL客户机A与MySQL客户机B都试图添加一条“符合查询条件的记录”，此时会进入死锁状态。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，接着开启事务，查询account表中account_no=20的账户信息，并对该账户信息施加共享锁，执行结果如图17所示。从执行结果可以得知，account表中不存在account_no=20的账户信息。123alter table account engine=InnoDB;start transaction;select * from account where account_no=20 lock in share mode; 图17 对account_no=20的账户施加共享锁（1） 步骤2：打开MySQL客户机B，执行下面的SQL语句，然后开启事务，接着查询account表中account_no=20账户信息，并对该账户信息施加共享锁，执行结果如图18所示。从执行结果可以得知，account表中不存在account_no=20的账户信息。12start transaction;select * from account where account_no=20 lock in share mode; 图18 对account_no=20的账户施加共享锁（2） 步骤3：由于MySQL客户机A已经得知，account表中不存在account_no=20的账户信息，因此MySQL客户机A可以使用下面的insert语句，向account表中添加一条account_no=20的账户信息。此时该insert语句被阻塞，进入锁等待状态。1insert into account values(20,'戊',5000); 步骤4：由于MySQL客户机B已经得知，account表中不存在account_no=20的账户信息，因此，MySQL客户机B可以使用下面的insert语句，向account表中添加一条account_no=20的账户信息。但此时该insert语句导致死锁问题的发生，执行结果如图19所示。1insert into account values(20,'戊',6000); 图19 间隙锁导致死锁问题说明 默认情况下InnoDB存储引擎会自动检测死锁，通过比较参与死锁问题的事务权重，继而选择权重值最小的事务进行回滚，并释放锁，以便其他事务获得锁，继续完成事务。每个事务的权重值存储在information_schema 数据库的INNODB_TRX表的trx_weight字段中。 步骤5：如果MySQL客户机A获得锁，此时MySQL客户机A上的insert语句成功执行，如图20所示（注意观察insert语句的执行时间）。 图20 MySQL客户机A获得锁，继续完成事务 步骤6：在MySQL客户机A上执行commit命令，提交insert语句，并解锁。然后执行select语句查询account表的所有记录，执行结果如图21所示。 图21 查询account表的所有记录 死锁与锁等待给MyISAM表施加表级锁不会导致死锁问题的发生，这是由于MyISAM总是一次性地获得SQL语句的全部锁。给InnoDB表施加行级锁可能导致死锁问题的发生，这是由于执行SQL语句期间，可以继续施加行级锁。因此，这里讨论的死锁问题主要是InnoDB行级锁产生的死锁问题。 上面的死锁问题由间隙锁产生，间隙锁如果使用不当，可能导致死锁问题。不仅仅是间隙锁可以导致死锁问题，错误的加锁时机也会导致死锁问题的发生。 场景描述6：如果account账户表的存储引擎为InnoDB，“甲”在银行柜台前通过MySQL客户机A将“甲”账户（account_no=1）的部分金额（例如1000元）转账给“乙”账户的“同时”，“乙”在银行柜台前通过MySQL客户机B将“乙”账户（account_no=2）的部分金额（例如500元）转账给“甲”账户，通过MySQL客户机A以及MySQL客户机B实现转账业务时都需要调用transfer_proc()存储过程。假设甲的转账存储过程与乙的转账存储过程的执行过程如图22所示，两个transfer_proc()存储过程正在分时、并发、交替运行，请读者注意每条语句执行的先后顺序。 注意：现实生活中，这种假设存在的可能性微乎其微，但即便这样，数据库开发人员也需要应对这种低概率事件的发生。 图22 两个账户并发、互相转账 步骤3后，MySQL客户机A首先获得了“乙”账户的排他锁，如图9-39所示（注意箭头的指向）；步骤4后，MySQL客户机B获得了“甲”账户的排他锁。为了实现转账业务，MySQL客户机A接着申请“甲”账户的排他锁（步骤5），此时需要等待MySQL客户机B释放“甲”账户的排他锁，产生“锁等待”现象（被阻塞），注意：此时并没有产生死锁问题。为了实现转账业务，MySQL客户机B接着申请“乙”账户的排他锁（步骤6），当MySQL客户机B申请“乙”账户的排他锁时，形成一个“环路等待”，此时进入死锁状态。步骤6对应的update语句执行后将产生死锁问题，并抛出如下错误信息：1ERROR 1213 (40001)：Deadlock found when trying to get lock; try restarting transaction 从图23中可以看到，锁等待与死锁是两个不同的概念。锁等待是为了保证事务可以正常地并发运行，锁等待不一定导致死锁问题的发生。而死锁问题的发生一定伴随着锁等待现象。 图23 锁等待与死锁 默认情况下，InnoDB存储引擎会自动检测死锁，通过比较参与死锁问题的事务权重，继而选择权重值最小的事务进行回滚，并释放锁，以便其他事务获得锁，继续完成事务。但即便如此，对于数据库开发人员而言，显式地处理死锁异常是一个好的编程习惯。下面的MySQL代码，首先删除原有的transfer_proc()存储过程，然后重新创建transfer_proc()存储过程，并将代码修改为下面的代码（粗体字部分为代码改动部分，其他代码不变）。粗体字部分的代码主要用于处理死锁异常，发生死锁异常问题后，回滚整个事务。123456789101112131415161718192021drop procedure transfer_proc;delimiter $$create procedure transfer_proc(in from_account int,in to_account int,in money int)modifies sql databegindeclare continue handler for 1690begin rollback;end;declare continue handler for 1213begin rollback;end;start transaction;update account set balance=balance+money where account_no=to_account;update account set balance=balance-money where account_no=from_account;commit;end$$delimiter ; 说明有些时候InnoDB并不能自动检测到死锁，可以通过设置InnoDB锁等待超时参数innodb_lock_wait_timeout的值，设置合适的锁等待超时阈值。当然锁等待超时参数innodb_lock_wait_timeout 并不只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而被阻塞，会占用大量数据库服务器资源，降低数据库服务器性能，设置合适的锁等待超时阈值也可以解决锁占用时间过长等问题。 默认情况下，InnoDB存储引擎一旦出现锁等待超时异常，InnoDB存储引擎既不会提交事务，也不会回滚事务，而这是十分危险的。一旦发生锁等待超时异常，应用程序应该自定义错误处理程序，由程序开发人员选择是进一步提交事务还是回滚事务。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务机制]]></title>
    <url>%2F2018%2F11%2F25%2FMySQL%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数据库与文件系统的最大区别在于数据库实现了数据的一致性以及并发性。对于数据库管理系统而言事务机制与锁机制是实现数据一致性与并发性的基石。 事务机制事务通常包含一系列更新操作，这些更新操作是一个不可分割的逻辑工作单元。如果事务成功执行，那么该事务中所有的更新操作都会成功执行，并将执行结果提交到数据库文件中，成为数据库永久的组成部分。如果事务中某个更新操作执行失败，那么事务中的所有更新操作均被撤销。简言之：事务中的更新操作要么都执行，要么都不执行，这个特征叫做事务的原子性。 说明更新语句或更新操作主要是update、insert以及delete等语句。 事务机制的必要性对于银行系统而言，转账业务是银行最基本、最常用的业务，有必要将转账业务封装成存储过程，银行系统调用该存储过程后即可实现两个银行账户间的转账业务。 场景描述1：假设某个银行存在两个借记卡账户（account）甲与乙，并且要求这两个借记卡账户不能用于透支，即两个账户的余额（balance）不能小于零。 步骤1：创建account账户表，并将其设置为InnoDB存储引擎。account_no字段是账户表的主键，其值由MySQL自动生成；account_name字段是账户名；balance字段是余额，由于余额不能为负数，将其定义为无符号数。12345create table account( account_no int auto_increment primary key, account_name char(10) not null, balance int unsigned) ENGINE=innodb; 步骤2：添加测试数据。下面的SQL语句向账户account表中插入了“甲”和“乙”两条账户信息，余额都是1000元。123insert into account values(null,'甲',1000);insert into account values(null,'乙',1000); 步骤3：创建存储过程。下面的MySQL代码创建了transfer_proc()存储过程，将from_account账户的money金额转账到to_account账户中，继而实现两个账户之间的转账业务。123456789101112delimiter $$ create procedure transfer_proc(in from_account int,in to_account int,in money int) modifies sql data begin update account set balance=balance+money where account_no=to_account; update account set balance=balance-money where account_no=from_account; end$$delimiter ; 步骤4：测试存储过程。下面的MySQL代码首先调用了transfer_proc()存储过程，将账户“甲”的800元转账到了“乙”账户中。然后查询了账户表中的所有账户信息，执行结果如图9-1所示，此时两个账户的余额之和为2000元。123call transfer_proc(1,2,800);select * from account; 步骤5：再次测试存储过程。再次调用transfer_proc()存储过程，将账户“甲”的800元转账到“乙”账户中。由于账户余额不能为负数，甲的账户余额200元减去800元，产生了错误代码1690对应的错误信息（稍后为该错误代码定义错误处理程序）。1234561690 - BIGINT UNSIGNED value is out of range in &apos;(`test`.`account`.`balance` - money@2``` 然后查询账户表中的所有账户信息：```sqlcall transfer_proc(1,2,800);select * from account; 执行结果如下。account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600 结论：甲账户的余额没有丝毫变化，但是乙账户的余额却凭空多出800元。甲、乙账户的余额之和由转账前2000元，变成了转账后的2800元，由此产生了数据不一致问题。 为了避免出现数据不一致问题，需要在存储过程中引入事务的概念，将transfer_proc()存储过程的两条update语句绑定到一起，让它们成为一个“原子性”的操作：两条update语句要么都执行，要么都不执行。 关闭MySQL自动提交默认情况下，MySQL开启了自动提交（auto_increment），这就意味着，之前编写的任意一条更新语句，一旦发送到MySQL服务器，MySQL服务实例会立即解析、执行，并将更新结果提交到数据库文件中，成为数据库永久的组成部分。 以转账存储过程transfer_proc()为例，该存储过程包含两条update语句，第一条update语句执行“加法”运算，第二条update语句执行“减法”运算。由于MySQL默认情况下开启了自动提交，因此第二条update语句无论执行成功还是失败，都不会影响第一条update语句的成功执行。如果第一条update语句成功执行，而第二条update语句执行失败，最终将导致数据不一致问题的发生。可以这样理解：产生上述数据不一致问题的根源在于MySQL开启了自动提交，并且没有引入事务的概念。 因此，对于诸如银行转账的业务逻辑而言，首要步骤是关闭MySQL自动提交，只有当所有的更新语句成功执行后，才提交（commit）所有的更新语句，否则回滚（rollback）所有的更新语句。关闭自动提交的方法有两种：一种是显式的关闭自动提交；另一种是隐式的关闭自动提交。 方法一：显式的关闭自动提交 使用MySQL命令“show variables like ‘autocommit’;”可以查看MySQL是否开启了自动提交。系统变量@@autocommit的值为ON或者1时，表示MySQL开启自动提交，默认情况下，MySQL开启了自动提交。系统变量@@autocommit 的值为OFF或者0时，表示MySQL关闭自动提交。使用MySQL命令“set autocommit=0;”可以显式的关闭MySQL自动提交。 说明 系统变量@@autocommit是会话变量，MySQL客户机A对该系统会话变量的更改，不会影响到MySQL客户机B中该系统会话变量的值。 方法二：隐式的关闭自动提交使用MySQL命令“start transaction;”可以隐式地关闭自动提交。隐式的关闭自动提交不会修改系统会话变量@@autocommit的值。 注意：对MyISAM存储引擎的表进行更新操作时，自动提交无论开启还是关闭，更新操作都将立即解析、执行，并将执行结果提交到数据库文件中，成为数据库永久的组成部分。 回滚关闭MySQL自动提交后，数据库开发人员可以根据需要回滚（也叫撤销）更新操作。 场景描述2：接场景描述1的步骤，当甲、乙账户的余额分别变为200元以及2600元后，打开MySQL客户机A，然后输入下面的MySQL命令。该MySQL命令首先关闭MySQL的自动提交，接着修改乙账户（account_no=2）的余额（加800元），然后查询所有账户的余额。1234set autocommit=0;update account set balance=balance+800 where account_no=2;select * from account; 结果为：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 3400 从运行结果可以看到，乙账户的余额已经从2600元修改为3400元，事实果真如此？打开另一个MySQL客户机B，选择当前的数据库为choose数据库，使用select语句再次查询所有账户的余额。123use choose;select * from account; 结果为：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600 从MySQL客户机B的执行结果可以看到乙的余额依然是2600元，并没有增加800元。对于这个问题，可以通过下图进行解释。从图中可以得知：MySQL客户机A的update操作影响的仅仅是内存中new记录的值，且该值并没有写入数据库文件；当MySQL客户机A执行select语句时，查询到的3400元实际上是MySQL服务器内存中new记录的字段值；MySQL客户机B执行select语句时，看到的2600元是外存数据2600在服务器内存的一个副本。 乙的最终余额究竟应该是多少元？这要取决于MySQL客户机A接下来的操作（可以分成两种情形：场景描述3与场景描述4）。 场景描述3：接场景描述2的步骤，在MySQL客户机A上执行MySQL命令“rollback;”，接着在MySQL客户机A、MySQL客户机B上执行select语句查询甲、乙账户的余额，两次执行结果相同（乙账户的余额均为2600），结果如下：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600可以这样理解：MySQL客户机A关闭MySQL自动提交后，MySQL客户机A执行的所有更新操作，都会在MySQL服务器内存中产生若干条new记录。如果在MySQL客户机A上执行了rollback命令，MySQL服务器内存中，与MySQL客户机A对应的new记录将被丢弃，回滚了（也叫撤销了）MySQL客户机A执行的更新操作。 说明 insert语句产生new记录，delete语句产生old记录，update语句产生new记录以及old记录，关于这方面的知识请参看视图与触发器章节的内容。 提交MySQL自动提交一旦关闭，数据库开发人员需要“提交”更新语句，才能将更新结果提交到数据库文件中，成为数据库永久的组成部分。自动提交关闭后，MySQL的提交方式分为显式的提交与隐式的提交。显式的提交：MySQL自动提交关闭后，使用MySQL命令“commit;”可以显式的提交更新语句。 隐式的提交：MySQL自动提交关闭后，使用下面的MySQL语句，可以隐式的提交更新语句。begin、set autocommit=1、start transaction、rename table、truncate table等语句；数据定义（create、alter、drop）语句，例如create database、create table、create index、create function、create procedure、alter table、alter function、alter procedure、drop database、drop table、drop function、drop index、drop procedure等语句；权限管理和账户管理语句（例如grant、revoke、set password、create user、drop user、rename user等语句）；锁语句（lock tables、unlock tables）。举例来说，MySQL客户机A关闭MySQL自动提交后，执行了若干条更新语句。此时如果MySQL客户机A执行了“create table test_commit(a int primary key);”语句，该语句成功创建test_commit表后，还会提交之前的所有更新语句。 为了有效地提交事务，推荐数据库开发人员尽可能地使用显式的提交方式，尽量不要使用（或者避免使用）隐式的提交方式。 场景描述4：重做场景描述2中的所有操作，在MySQL客户机A上执行MySQL命令“commit;”，接着在MySQL客户机A、MySQL客户机B上执行select语句查询甲、乙账户的余额，两次执行结果相同（乙账户的余额增加了800元，变为3400）。从执行结果可以看出,MySQL客户机A执行commit命令后, MySQL服务器内存中的new记录被更新到数据库文件中,成为数据库永久的组成部分。 说明关闭MySQL的自动提交后,需要显式提交（或者隐式提交）更新语句,否则所有的更新语句影响的仅仅是MySQL服务器内存中的new记录,更新语句提交后,才会将new记录的值写入数据库文件。 无论开启自动提交,还是关闭自动提交,使用触发器时,InnoDB存储引擎都会保证触发事件与触发程序的原子性操作。 事务使用MySQL命令”start transaction;”可以开启一个事务,该命令开启事务的同时,会隐式的关闭MySQL自动提交。使用commit命令可以提交事务中的更新语句;使用rollback命令可以回滚事务中的更新语句。典型的事务处理使用方法如下图所示。 场景描述5:银行转账业务的两条update语句是一个整体,如果其中任意一条update语句执行失败,则所有的update语句应该撤销,从而确保转账前后的总额不变。使用事务机制、错误处理机制可以避免银行转账时数据不一致问题的发生 下面的MySQL代码,首先删除原有的transfer_proc()存储过程,然后重建ransfer_proc()存储过程,并将代码修改为下面的代码。其中, “declare continue handler for 1690”负责处理MysQL错误代码1690,当发生该错误时,执行回滚操作; “start transaction”负责开启事务,并隐式地关闭自动提交;”commit”负责提交事务。12345678910111213141516drop procedure transfer_proc;delimiter $$create procedure transfer_proc (in from_account int,in to_account int,in money int) modifies sql data begin declare continue handler for 1690 begin rollback; end; start transaction; update account set balance=balance+money where account_no=to_account; update account set balance=balance-money where account_no=from_account; commit;end$$delimiter ; 说明如果账户余额balance字段定义为整数(不是无符号整数) ,那存储过程transfer_proc()也可以通过判断账户余额是否小于零,继而决定是否回滚(rollback)转账业务 默认情况下, InnoDB存储引擎既不会对异常进行回滚,也不会对异常进行提交,而这是十分危险的。异常发生后,数据库开发人员需要借助错误处理程序,显式地提交事务或者显式地回滚事务。可以这样理解:事务的提交与回滚,好比if-else语句中的then子句与else子句,两者只能选其一。 在实际的数据库开发过程中,不建议使用MySQL命令”set autocommit=0;”显式地关闭MySQL自动提交,建议选用”start transaction;”命令,该命令不仅可以开启新的事务,还可以隐式地关闭MySQL自动提交,而且”start transaction;”命令不会影响@@autocommit系统会话变量的值。 保存点默认情况下,事务一旦回滚,事务内的所有更新操作都将撤销。有些时候,仅仅希望撤销事务内的一部分更新操作,保存点(也称为检查点)可以实现事务的”部分”提交或者“部分”撤销。使用MySQL命令”savepoint 保存点名;”可以在事务中设置一个保存点,使用MySQL命令”rollback to savepoint 保存点名;”可以将事务回滚到保存点状态,如下图所示。当事务回滚到保存点后,那么数据库将进入到一致性状态B。 场景描述6:为了演示保存点的使用,下面两个存储过程save_point1_proc()与save_point2_proc()都试图在同一条事务中创建两个账号相同的银行账户。由于银行账号account_no是主键,两个银行账号不能相同,因此第二条insert语句会产生MySQL错误代码1062,两个存储过程处理MySQL错误代码1062的方法截然不同。 方法一:下面的MySQL代码创建了save_point1_proc()存储过程,该存储过程撤销了所有的insert语句。12345678910111213141516delimiter $$ create procedure save_point1_proc()modifies sql data begin declare continue handler for 1062 begin rollback to B; rollback; end; start transaction; insert into account values(null,'丙', 1000); savepoint B; insert into account values(last_insert_id(),'丁', 1000); commit; end$$delimiter ; 说明 存储过程save_point1_proc()中,为了保证”丙”与”丁”两个账户的账号相同,创建”丁”账户的insert语句使用last_insert_id()函数获取了”丙”账户的账号。第二条insert语句将抛出错误信息(ERROR 1062:主键不能相同) ,第二条insert语句出错后,错误处理程序将事务回滚到B保存点(rollback to B) ,然后回滚整个事务(rollback)如上图所示。调用存储过程save_point1_proc(),然后查询账户account表的所有记录。从查询结果可以看出,两条insert语句都被撤销。12call save_point1_proc();select * from account; mysql&gt; call save_point1_proc();Query OK, 0 rows affected (0.03 sec) mysql&gt; select * from account;account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 34002 rows in set (0.08 sec) 方法二:下面的MySQL代码创建了save_point2_proc()存储过程,该存储过程仅仅撤销第二条insert语句,但提交了第一条insert语句。12345678910111213141516delimiter $$create procedure save_point2_proc()modifies sql data begin declare continue handler for 1062 begin rollback to B; commit; end; start transaction; insert into account values(null,'丙', 1000); savepoint B; insert into account values(last_insert_id(),'丁', 1000); commit; end$$delimiter ; 存储过程save_point2_proc()中,第二条insert语句出错后,错误处理程序将事务回滚到B保存点(rollback to B),并提交事务(commit),导致第一条insert语句成功提交到数据库中,。 调用存储过程save_point2_proc(),然后查询账户account表的所有记录。从查询结果可以看出,第一条insert语句成功执行,第二条insert语句被撤销。12call save_point2_proc();select * from account; mysql&gt; call save_point2_proc();Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from account;+——————+———————+————-+| account_no | account_name | balance |+——————+———————+————-+| 1 | 甲 | 200 || 2 | 乙 | 3400 || 4 | 丙 | 1000 |+——————+———————+————-+3 rows in set (0.06 sec)说明“rollback to savepoint B”仅仅是让数据库回到事务中的某个”一致性状态B” ,而”一致性状态B”仅仅是一个“临时状态”,该“临时状态”并没有将更新回滚,也没有将更新提交。事务回滚必须借助于rollback(而不是”rollback to savepoint B”) ,而事务的提交需借助于commit 使用MySQL命令”release savepoint 保存点名;”可以删除一个事务的保存点。如果该保存点不存在,则该命令将出现错误信息: ERROR 1305 (42000): SAVEPOINT does not exist。如果当前的事务中存在两个相同名字的保存点,则旧保存点将被自动丢弃。 “选课系统”中的事务“选课系统”中,最为复杂的业务逻辑莫过于”学生选课”以及“学生调课”功能的实现,之前的章节已经编写了choose proc)存储过程,实现了学生的选课功能。本章将借用事务的概念编写调课存储过程replace course-proco,实现”选课系统”的调课功能。 场景描述7:使用存储过程实现“选课系统”的调课功能,图9-13所示的程序流程图阐述了某个学生的调课流程(其中, c before表示调课前的课程, c after表示目标课程或者调课后的课程)。从程序流程图中可以看到,调课时,首先要判断调课前的课程与目标课程是否相同,如果相同,则将调课的状态值state设置为-1;接着判断目标课程是否已经审1核,是否已经报满,如果课程未审核或者课程available字段值为0 (课程报满) ,则将状态值state设置为-2;如果调课成功,则将状态值state设置为调课成功后的课程course no。由于调课涉及3条update语句,为了保证它们的原子性,必须将它们封装到事务中。 下面的SQL语句创建了名字为replace course proc)的存储过程,该存储过程接收学生学号(s no)、课程号(c before)以及课程号(c after)为输入参数,经过存储过程一系列处理,返回调课state状态值。如果输出参数state的值大于0,则说明学生调课成功;如果输出参数state的值等于-1,则意味着该生调课前后选择的课程相同;如果输出参数state的值等于-2,则意味着目标课程未审核或者已经报满。请读者注意粗体字代码。1234567delimiter $$create procedure replace course proc(in s no char(11),in c before int,in c after int,out state int)modifies sql databegindeclare s int;declare status char(8);set state =0;set status="未审核";if(c before=c after) thenset state =-1;elsestart transactionselect state into status from course where course no=c after;select available into s from course where course no-c after;if(s=0 1l status=未审核) therset state =-2:elseif(state=0) therupdate choose set course no-c after,choose time-now0) where student no=s no andcourse no=c before;update course set available-available+1 where course no-c beforeupdate course set available=available-1 where course no=c after;set state =c after;end if;commit;end if;end$:delimiter; 下面的MySQL语句负责调用replace-course-proc)存储过程,对该存储过程进行简单的测试。首先使用下面的select语句查看学号2012002的选课信息,执行结果如图9-14所示。select * from choose where student no=2012002; 接着将该生选修的课程号3,调换为课程号1,执行下面的MySQL命令,执行结果如图9-15所示。set @s no =’2012002;set @c before =3;set @c after =1;set @state =0;call replace course proc(@s no,@c before,@c after,@state);select @state最后使用下面的select语句查看学号2012002最终的选课信息,验证调课是否成功,执行结果如图9-16所示。select * from choose where student no=2012002; 说明学生选课以及学生调课是”选课系统”的核心功能。存储过程与游标章节编写的”选课存储过程” chooseproco使用了触发器维护course表的available字段值。由于InnoDB存储引擎中,触发器已经保证了触发事件与触发程序的原子性,因此choose proc)存储过程可以保证insert语句与insert触发程序的原子性。而本章编写的”调课存储过程” replace course proc)使用事务的概念,将3条update语句封装到一个事务中,同样也可以保证3条update语句的原子性操作。在真正的项目案例中,推荐使用事务实现更新语句的原子性操作,不建议使用触发器。 一般情况下,一系列关系紧密的更新语句(例如insert, delete或者update语句)都需要封装到一个事务中。由于查询语句不会导致数据发生变化,因此一般不需要封装到事务中。细心的读者会发现,在replace course proc)存储过程中,粗体字的select语句负责”查询目标课程的available字段值” ,该select语句也封装到了事务中,具体原因在”锁机制”章节中进行讲解]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的索引]]></title>
    <url>%2F2018%2F11%2F24%2FMySQL%E7%9A%84%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： MySQL数据库中，数据是如何检索的？ 什么是前缀索引？什么是复合索引？ 什么是主索引和聚簇索引？ 索引越多越好吗？ 索引与约束有什么关系？ 最左前缀原则是什么意思？ 理解索引（1）索引的本质是什么？ 本质上，索引其实是数据表中字段值的复制，该字段称为索引的关键字。 （2）MySQL数据库中，数据是如何检索的？ 简言之，MySQL在检索表中的数据时，先按照索引“关键字”的值在索引中进行查找，如果能够查到，则可以直接定位到数据所在的起始页；如果没有查到，只能全表扫描查找数据了。 （3）一个数据库表只能创建一个索引吗？ 当然不是。想象一下《现代汉语词典》，除了将汉语拼音编入“音节表”实现汉字的检索功能外，还将所有汉字的部首编入“部首检字表”实现汉字的检索功能，“部首检字表”是《现代汉语词典）的另一个“索引”。同样对于数据库表而言，一个数据库表可以创建多个索引。 （4）什么是前缀索引？ “部首检字表”的使用方法是：首先确定一个字的部首，结合笔画可以查找到该字所在的起始页。例如部首“礻”，结合“羊”的笔画是6，可以快速地在“部首检字表”中查到“祥-&gt;1488”。 “部首检字表”中的部首“礻”仅仅是汉字的一个部分（part），不是整个汉字的拷贝。同样对于数据库表而言，索引中关键字的值可以是索引“关键字”字段值的一个部分，这种索引称为“前缀索引”。例如，可以仅仅对教师姓名（例如“张老师”）中的“姓”（“张”）建立前缀索引。 （5）索引可以是字段的组合吗？ 当然可以。《现代汉语词典》中的“部首检字表”中，部首是“索引”的第一关键字（也叫主关键字），部首相同时，“笔画”未必相同，笔画是“索引”的第二关键字（也叫次关键字），同样对于数据库而言，索引可以是字段的组合。数据库表的某个索引如果由多个关键字构成，此时该索引称为“复合索引”。无论索引的关键字是一个字段，还是一个字段的组合，需要注意的是，这些字段必须来自于同一张表，并且关键字的值必须是表中相应字段值的拷贝。另外，数据库为了提高查询“索引”的效率，需要对索引的关键字进行排序。 （6）能跨表创建索引吗？ 当然不能。这个问题如同在问：是否可以在《牛津高阶英汉双解词典》创建一个“偏旁部首”索引？数据库中同一个索引允许有多个关键字，但每个关键字必须来自同一张表。 （7）索引数据需要额外的存储空间吗？ 当然需要。翻开词典后，几十页甚至上百页的内容存放的是“索引”数据（音节表、部首检字表）。对于数据库表的索引而言，索引关键字经排序后存放在外存中。对于MyISAM表而言，索引数据存放在外存MYI索引文件中。对于InnoDB数据库表而言，索引存在InnoDB表空间文件中（可能是共享表空间文件，也可能是独享表空间文件）。就像“音节表”是按照“从a到z”的升序顺序排放，部首检字表是按照笔画的升序顺序排放一样。为了提升数据的检索效率，无论MyISAM表的索引，还是InnoDB表的索引，索引关键字经排序（默认为升序排序）后存放在外存文件中。 （8）表中的哪些字段适合选作表的索引？什么是主索引？什么是聚簇索引？ 想象一下，单独的笔画能作为《现代汉语词典》的索引吗？显然不能，原因在于同一个笔画的汉字太多。反过来说，由于表的主键值不可能重复，表的主键当作索引最合适不过了。 对于MyISAM表而言，MySQL会自动地将表中所有记录主键值的“备份”及每条记录所在的起始页编入索引中，像“部首检字表”一样形成一张“索引表”，存放在外存，这种索引称为“主索引” （primary index）， MyISAM表的MYI索引文件与MYD数据文件位于两个文件，通过MYI索引文件中的“表记录指针”可以找到MYD数据文件中表记录所在的物理地址。如果teacher表是MyISAM存储引擎，teacher表的主索引如图1所示。 图1 MyISAM存储引擎teacher表的主索引以及普通索引 说明图中teacher表的记录，并没有按照教师的工号teacher_no字段进行排序，即主索引关键字的顺序与表记录主键值的顺序无需一致。 InnoDB表的“主索引”与MyISAM表的主索引不同。InnoDB表的“主索引”关键字的顺序必须与InnoDB表记录主键值的顺序一致，严格地说，这种“主索引”称为“聚簇索引”，并且每一张表只能拥有一个聚簇索引，如图2所示。假设一个汉语拼音只对应一个汉字，《现代汉语词典》中的“音节表”就变成了汉语词典的聚簇索引。 图2 InnoDB存储引擎teacher表的聚簇索引 MySQL的聚簇索引与其他数据库管理系统不同之处在于，即便是一个没有主键的MySQL表， MySQL也会为该表自动创建一个“隐式”的主键。对于InnoDB表而言，必须有聚簇索引（有且仅有一个聚簇索引） 。 前面曾经提到，由于InnoDB表记录与索引位于同一个表空间文件中，因此InnoDB表就是聚簇索引，聚簇索引就是InnoDB表。就像一本撕掉音节表、部首检字表的汉语词典一样，读者同样可以通过拼音直接在汉语词典中查找汉字，原因在于，撕掉音节表、部首检字表后的汉语词典本身就是聚簇索引。 对于InnoDB表而言，MySQL的非聚簇索引统称为“辅助索引”（secondary index），辅助索引的“表记录指针”称为“书签”（bookmark），实际上是主键值，如图3所示，可以看到，所有的辅助索引都包含主键列，所有的InnoDB表都是通过主键来聚簇的。 图3 InnoDB存储引擎teacher表的聚簇索引与辅助索引 说明 这里为了更直观地描述索引，图中将表的索引制作成了一个表格。事实上，表的索引往往通过更为复杂的数据结构（例如双向链表、B+树btree、hash等数据结构）实现，从而可以大幅提升数据的检索效率。 MyISAM存储引擎的表支持主索引，并且还可以采用压缩机制（Packed：Packed的说明如下表所示）存储索引的关键字，比如第一个关键字的值为“her”，第二关键字的值为“here”，那么第二关键字会被存储为“3, e”。 InnoDB存储引擎的表支持聚簇索引。由于创建聚簇索引时需要对“索引”中的数据以及表中的数据进行排序，为了避免更新数据（例如插入数据）耗费过多的时间，建议将InnoDB表的主键设置为自增型字段。 （9）索引与数据结构是什么关系？ 数据库中的索引关键字在索引文件中的存储规则远比词典中的“音节表”复杂得多。为了有效提升数据检索效率，索引通常使用平衡树（btree）或者哈希表等复杂的数据结构进行“编排”。当然在操作数据库的过程中，数据库用户并不会感觉到这些数据结构的存在，原因在于SQL语句（例如select语句等）已经实现了复杂数据结构的“封装”，在执行这些SQL语句时，其底层操作实际上执行的是复杂数据结构的操作。 （10）索引非常重要，同一个表中，表的索引越多越好吗？ 如果没有索引， MySQL必须从第1条记录开始，甚至读完整个表才能找出相关的记录，表越大，花费的时间越多。有了索引，索引就可以帮助数据库用户快速地找出相关的记录，并且索引由MySQL自动维护，但这不意味着表的索引越多越好。 索引确实可以提高检索效率，但要记住，索引是冗余数据，冗余数据不仅需要额外的存储空间，而且还需要额外的维护（虽然不需要人为的维护） 。 如果索引过多，在更新数据（添加、修改或者删除）时，除了需要修改表中的数据外，还需要对该表的所有索引进行维护，以维持表字段值和索引关键字值之间的一致性，反而降低了数据的更新速度。实践表明，当修改表记录的操作特别频繁时，过多的索引会导致硬盘I/O次数明显增加，反而会显著地降低服务器性能，甚至可能会导致服务器宕机。不恰当的索引不但于事无补，反而会降低系统性能。因此，索引是把双刃剑，并不是越多越好，哪些字段（或字段组合）更适合选作索引的关键字？ 索引关键字的选取原则索引的设计往往需要一定的技巧，掌握了这些技巧，可以确保索引能够大幅地提升数据的检索效率，弥补索引在数据更新方面带来的缺陷。 原则1：表的某个字段值的离散度越高，该字段越适合选作索引的关键字。 考虑现实生活中的场景：学生甲到别的学校找学生乙，但甲只知道乙的性别，那么学生甲要想找到乙，无异于“大海捞针”。原因很简单，性别字段的值要么是男，要么是女，取值离散度较低（Cardinality的值最多为2），因此，性别字段就没有必要选作索引的关键字了。 如果甲知道的是乙的学号，情况就比较乐观了，因为对于一个学校而言，有多少名学生，就会有多少个学号与之相对应。学号的取值特别离散，因此，比较适合选作学生表索引的关键字。 主键字段以及唯一性约束字段适合选作索引的关键字，原因就是这些字段的值非常离散。尤其是在主键字段创建索引时， Cardinality的值就等于该表的行数。MySQL在处理主键约束以及唯一性约束时，考虑得比较周全。数据库用户创建主键约束的同时，MySQL会自动创建主索引（primary index），且索引名称为PRIMARY；数据库用户创建唯一性约束的同时，MySQL会自动地创建唯一性索引（unique index），默认情况下，索引名为唯一性约束的字段名。 原则2：占用储存空间少的字段更适合选作索引的关键字。 如果索引中关键字的值占用的存储空间较多，那么检索效率势必会造成影响。例如，与字符串字段相比，整数字段占用的存储空间较少，因此，较为适合选作索引的关键字。 原则3：储存空间固定的字段更适合选作索引的关键字。 与text类型的字段相比，char类型的字段较为适合选作索引的关键字。 原则4：where子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。 引入索引的目的是提高数据的检索效率，因此索引关键字的选择与select语句息息相关。这句话有两个方面的含义：select语句的设计可以决定索引的设计；索引的设计也同样影响着select语句的设计。例如原则1与原则2，可以影响select语句的设计；而select语句中的where子句、group by子句以及order by子句，又可以影响索引的设计。两个表的连接字段应该创建索引，外键约束一经创建，MySQL会自动地创建与外键相对应的索引，这是由于外键字段通常是两个表的连接字段。 原则5：更新频繁的字段不适合创建索引，不会出现在where子句中的字段不应该创建索引。 原则6：最左前缀原则。 复合索引还有另外一个优点，它通过被称为“最左前缀”（leftmost prefixing）的概念体现出来。假设向一个表的多个字段（例如firstname、lastname、address）创建复合索引（索引名为fname_lname_address）。当where查询条件是以下各种字段的组合时，MySQL将使用fname_lname_address索引。其他情况将无法使用fname_lname_address索引。 firstname， lastname， addressfirstname， lastnamefirstname 可以这样理解：一个复合索引（firstname、lastname、address）等效于（firstname、lastname、age）、（firstname、lastname）以及（firstname）三个索引。 基于最左前缀原则，应该尽量避免创建重复的索引，例如创建了fname_lname_address索引后，就无需在first_name字段上单独创建一个索引。 原则7：尽量使用前缀索引。 例如，仅仅在姓名（例如“张三”）中的姓氏部分（“张”）创建索引，从而可以节省索引的存储空间，提高检索效率。 当然，索引的设计技巧还有很多，而且不是千篇一律的，更不是照本宣料的，没有索引的表同样可以完成数据检索任务。索引的设计没有对错之分，只有合适与不合适之分。与数据库的设计一样，索引的设计同样需要数据库开发人员经验的积累以及智慧的沉淀，同时需要依据系统各自的特点设计出更好的索引，在“加快检索效率”与“降低更新速度”之间做好平衡，从而大幅提升数据库的整体性能。 索引与约束MySQL中表的索引与约束之间存在怎样的关系？约束分为主键约束、唯一性约束、默认值约束、检查约束、非空约束以及外键约束。其中，主键约束、唯一性约束以及外键约束与索引的联系较为紧密。 约束主要用于保证业务逻辑操作数据库时数据的完整性；而索引则是将关键字数据以某种数据结构的方式存储到外存，用于提升数据的检索性能。约束是逻辑层面的概念；而索引既有逻辑上的概念，更是一种物理存储方式，且事实存在，需要耗费一定的存储空间。 对于一个MySQL数据库表而言，主键约束、唯一性约束以及外键约束是基于索引实现的。因此，创建主键约束的同时，会自动创建一个主索引，且主索引名与主键约束名相同（PRIMARY）；创建唯一性约束的同时，会自动创建一个唯一性索引，且唯一性索引名与唯一性约束名相同；创建外键约束的同时，会自动创建一个普通索引，且索引名与外键约束名相同。 在MySQL数据库中，删除了唯一性索引，对应的唯一性约束也将自动删除。若不考虑存储空间方面的因素，唯一性索引就是唯一性约束。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的依赖注入(DI)和控制反转(IoC)]]></title>
    <url>%2F2018%2F07%2F17%2FPHP%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IoC%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 这两种模式的目的是什么？ 整个过程中参与者都有谁？ 依赖：谁依赖于谁？为什么会产生依赖？ 注入：谁注入于谁？到底注入了什么？ 控制反转：谁控制谁？控制什么？为何叫反转（有反转就应该有正转了，正转是什么呢？） 依赖注入和控制反转是同一概念吗？ A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。怎么理解？ 应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。怎么理解？ 简介 IoC - Inversion of Control 控制反转 DI - Dependency Injection 依赖注入 依赖注入和控制反转说的实际上是同一个东西，它们是一种设计模式，这种设计模式用来减少程序间的耦合。 **优势（为什么使用）** 使用依赖注入，最重要的一点好处就是有效的分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 **概念** 依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。 依赖注入是从应用程序的角度在描述，可以把依赖注入，即：应用程序依赖容器创建并注入它所需要的外部资源； 而控制反转是从容器的角度在描述，即：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。 问答对于一个菜鸟，如果你看了上面的概念还是一头雾水的话，那么恭喜你，你和我一样不是天才，那么下面就让我们借助于几个问答来搞清楚这个概念的意思吧。 整个过程中参与者都有谁？ 一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。 某个对象指的就是任意的、普通的PHP对象。 IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序。 对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。 谁依赖于谁： 当然是某个对象依赖于IoC/DI的容器。 为什么需要依赖： 对象需要IoC/DI的容器来提供对象需要的外部资源。 谁注入于谁： 是IoC/DI的容器注入某个对象。 到底注入什么： 就是注入某个对象所需要的外部资源。 谁控制谁： 当然是IoC/DI的容器来控制对象了。 控制什么： 主要是控制对象实例的创建。 为何叫反转： 反转是相对于正向而言的，那么什么算是正向的呢？ 考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C（$c = new C();），这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。 用图例来说明一下，先看没有IoC/DI的时候，常规的A类使用C类的示意图，如下图所示： 代码示意：1234567891011121314151617181920212223242526272829303132333435&lt;?php/** * 没有IoC/DI的时候，常规的A类使用C类的示例 *//** * Class c */class C&#123; public function say() &#123; echo 'hello'; &#125;&#125;/** * Class A */class A&#123; private $c; public function __construct() &#123; $this-&gt;c = new C(); // 实例化创建C类 &#125; public function sayC() &#123; echo $this-&gt;c-&gt;say(); // 调用C类中的方法 &#125;&#125;$a = new A();$a-&gt;sayC(); 当有了IoC/DI的容器后，A类不再主动去创建C了，如下图所示： 而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中，如下图所示： 代码示意：1234567891011121314151617181920212223242526272829303132333435363738&lt;?php/** * 当有了IoC/DI的容器后，A类依赖C类实例注入的示例 *//** * Class C */class C&#123; public function say() &#123; echo 'hello'; &#125;&#125;/** * Class A */class A&#123; private $c; public function setC(C $c) &#123; $this-&gt;c = $c; // 实例化创建C类 &#125; public function sayC() &#123; echo $this-&gt;c-&gt;say(); // 调用C类中的方法 &#125;&#125;$c = new C();$a = new A();$a-&gt;setC($c); // 先set，$c作为C类的实例不是在A类里创建的。$a-&gt;sayC(); 什么是正转？ 正转就是按照普通的，在类中直接创建对象实例，如$c = new C(); 依赖注入和控制反转是同一概念吗？ 根据上面的讲述，我们不难出来，“依赖注入”和“控制反转”确实是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。 总结其实IoC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。 注意我们上面说了，这是一种“设计模式”，就像“工厂模式”和“单例模式”等是一样的，它是一种面向对象中的编程“思想”，自然它也不仅限于PHP，而是所有面向对象的语言基本都是可以适用的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第14章-对付空间限制]]></title>
    <url>%2F2018%2F07%2F15%2F%E7%AC%AC14%E7%AB%A0-%E5%AF%B9%E4%BB%98%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是空间复杂度？ 本章涵盖： 描述空间复杂度的大O记法 时间和空间之间的权衡 本书至此，在分析各种算法的效率时，我们只关注了它们的时间复杂度。换句话说，就是它们运行得有多快。但有些时候，我们还得以另一种名为空间复杂度的度量方式，去估计它们会消耗多少内存。 当内存有限时，空间复杂度便会成为选择算法的一个重要的参考因素。比如说，在给小内存的小型设备写程序时，或是处理一些会迅速占满大内存的大数据时都会考虑空间复杂度。 既省时又省内存的算法当然是最理想的。但有些情况下我们却只能二者选其一，这时要想做出正确选择，就得仔细分析了。 描述空间复杂度的大O记法有趣的是，计算机科学家还是用描述时间复杂度的大O记法来描述空间复杂度。 至今我们一直这样用大O记法来描述一个算法的速度：当所处理的数据有N个元素时，该算法所需的步数相对于元素数量是多少。例如，O(N)算法就是处理N个元素需要N步的算法。O(N2)算法就是处理N个元素需要N2步的算法。 类似地，我们也可以用大O来描述一个算法需要多少空间：当所处理的数据有N个元素时，该算法还需额外消耗多少元素大小的内存空间。让我们看一个简单的例子。 假设要写一个JavaScript函数，它接收一个字符串数组，并返回一个含有那些字符串的大写形式的数组。如果接收的数组是[“amy”, “bob”, “cindy”, “derek”] ，那么返回的就是[“AMY”, “BOB”, “CINDY”, “DEREK”] 。以下是该函数的一种写法。123456789function makeUpperCase(array) &#123; var newArray = []; for(var i = 0; i &lt; array.length; i++) &#123; newArray[i] = array[i].toUpperCase(); &#125; return newArray;&#125; makeUpperCase函数接收一个数组作为参数array。然后它创建了一个全新的数组，名为newArray，并将原数组array里的字符串的大写形式填进去。 等到该函数结束的时候，内存里会存在两个数组，一个是array，它里面是[“amy”, “bob”,”cindy”, “derek”]；另一个是newArray ，它里面是[“AMY”, “BOB”, “CINDY”, “DEREK”] 。 分析该函数的话，你会发现它接收一个N元素的数组，就会产生另一个新的N元素数组。 因此，我们会说这个makeUpperCase函数的空间效率是O(N)。 这种复杂度的图应该很熟悉了。 注意它的画法跟前面章节的O(N)是一样的，只是这次的纵坐标不是代表速度，而是代表内存。 我们再写一个更高效利用内存的makeUpperCase。12345678function makeUpperCase(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; array[i] = array[i].toUpperCase(); &#125; return array;&#125; 在这第二个版本里，我们没有创建任何新的变量或新的数组，也确实没有消耗额外的内存空间。我们只是变动了原array里的每个字符串，将它们逐一换成大写。最后返回这个修改过的array。 因为该函数并不消耗额外的内存空间，所以我们把它的空间复杂度描述为O(1)。记住，时间复杂度的O(1)意味着一个算法无论处理多少数据，其速度恒定。相似地，空间复杂度的O(1)则意味着一个算法无论处理多少数据，其消耗的内存恒定。 刚才的例子中，无论传入的array包含4个元素还是100个元素，该算法所需的额外的空间都一样（为零）。因此，我们认为新版的makeUpperCase的空间效率是O(1)。 值得一再强调的是，空间复杂度是根据额外需要的内存空间（也叫辅助空间）来算的，也就是说原本的数据不纳入计算。尽管在第二个版本里我们有array这一入参，占用了N个元素的空间，但除此之外它并没有消耗额外的内存，所以它是O(1)。 （有些参考书在计算空间复杂度时是连原始输入也一起算的，那没问题。但此处我们不计算它，当你在其他地方看到某一算法的空间复杂度的描述时，最好留意一下它是否计算原始输入。） 我们比较一下makeUpperCase两个版本的时间复杂度和空间复杂度。 版 本 时间复杂度 空间复杂度 1 O(N) O(N) 2 O(N) O(1) 因为N项数据要花N步去处理，所以两个版本的时间复杂度都是O(N)。然而在空间复杂度方面，第二个版本只有O(1)，与第一个版本的O(N)相比，它对内存的使用效率更高。 因此选择第二个版本更为合理。 时间和空间之间权衡第4章我们写了一个用于检查数组是否含有重复值的JavaScript函数。它的第一版是这样的：1234567891011121314function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 它用了嵌套循环，时间复杂度为O(N2)。 后来我们又写了一版效率更高的，如下所示。1234567891011121314151617function hasDuplicateValue(array) &#123; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 该版本会创建一个名为existingNumbers的数组，然后以array遇到的每个数字为索引，到existingNumbers那里找到相应的格子填个 1。如果相应的格子里已被填了1，则可知该数字已经存在，证明有重复值。 因为与第一版的O(N2)相比，它的时间复杂度只有O(N)，所以我们宣称它胜过第一版。确实，单从时间角度考虑的话，第二版是更快的。 但要是把空间也考虑进去的话，你会发现它与第一版相比有一缺点。第一版除了原数组，并不会消耗额外的内存，因此它的空间复杂度为 O(1)。第二版却要创建一个与原数组大小相等的全新数组，因此它的空间复杂度为O(N)。（一般情况下不太可能大小相等，应该分析两个数组的稀疏程度。） 我们来给两个版本的hasDuplicateValue做个全面的对比。 版 本 时间复杂度 空间复杂度 1 O(N2) O(1) 2 O(N) O(N) 可见第一版所用的内存更少，但跑得更慢，第二版虽跑得快但用的内存更多。那要怎么决定该用哪个呢？ 答案当然是看情况。如果你想要程序跑得超级快，而且你的内存十分充足，那么用第二版会比较好。但如果你不看重速度，而且你的程序是跑在需要谨慎使用内存的嵌入式系统上，那你应该选择第一版。所有技术讨论都是这样的，当需要做出取舍时，你应从全局看待问题。 写在最后的话通过这次学习之旅，你已掌握了很多知识，其中最重要的是，你懂得了数据结构和算法的分析，这对代码的速度、内存占用，甚至其可读性都有着重大影响。 在此书中你收获了一套思路清晰的技术分析框架。你明白了计算包含各种细节，尽管大O之类的理论会建议你哪种做法更好，但若考虑其他因素，你可能会做出不同的选择。机器对内存的管理方式和编程语言的底层实现都会影响程序的性能，甚至有时你以为是最高效的做法也可能会随着外部环境的变化而变得低效。 因此，你最好时刻配备性能测试工具来验证你的调优是否有效。测量代码速度和内存消耗的优秀工具有很多。本书的知识只告诉你调优的方向，而测试工具会负责检验你调优的具体实现是否正确。 很多看似复杂、深奥的事物，其实都是由你所掌握的简单概念构筑而成的。不要因为某些资料没解释到位，就以为它很困难而被吓退，你一定能找到更详尽的解释资料。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第13章-连接万物的图]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%AC%AC13%E7%AB%A0-%E8%BF%9E%E6%8E%A5%E4%B8%87%E7%89%A9%E7%9A%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是图？怎么用代码表示图？每个顶点都是一个对象，维护一个列表。怎么理解？ 什么是顶点？什么是边？怎么才叫相邻？ 什么是有向图？什么是无向图？ 什么是二度联系人？ 什么是广度优先搜索？ 什么是加权图？要往图里加上权重，要把表示邻接点的数组换成散列表。怎么换？ 以二维数组来保存朋友关系会在查询a的朋友时有什么问题？ 遍历图还需要一个队列。怎么理解？ Neo4j是什么软件？ 本章涵盖： 图 广度优先搜索 图数据库 加权图 Dijkstra算法 假设我们正在打造一个像Facebook那样的社交网络。在该应用里，大家可以加别人为“朋友”。这种朋友关系是相互的，如果Alice是Bob的朋友，那么Bob也会是Alice的朋友。 这些关系数据要怎么管理才好呢？ 一种简单的方法是，以二维数组来保存每一对关系。123456789relationships = [ ["Alice", "Bob"], ["Bob", "Cynthia"], ["Alice", "Diana"], ["Bob", "Diana"], ["Elise", "Fred"], ["Diana", "Fred"], ["Fred", "Alice"]] 不幸的是，这样无法快速地知道Alice的朋友是哪些人。你只能在数组里按逐对关系检查，看Alice在不在那对关系中。在检查过程中，你还得创建一个列表来暂存查出的朋友（此例中有Bob、Diana和Fred）。 由于数据以这种结构存储，若想查找Alice的朋友就得检查数据库中的所有关系，需要O(N)的时间复杂度。 其实有一种更好的存储方法。使用图这种数据结构的话，我们可以在O(1)时间内找出Alice的所有朋友。 图图是一种善于处理关系型数据的数据结构，使用它可以很轻松地表示数据之间是如何关联的。 下图是我们的Facebook网络。 每个人都是一个结点，人与人之间的朋友关系则以线段表示。按照图的术语来说，每个结点都是一个顶点，每条线段都是一条边。当两个顶点通过一条边联系在一起时，我们会说这两个顶点是相邻的。 图的实现形式有很多，最简单的方法之一就是用散列表。例如，使用Ruby散列表来实现一个极为基础的社交网络。12345678friends = &#123; "Alice" =&gt; ["Bob", "Diana", "Fred"], "Bob" =&gt; ["Alice", "Cynthia", "Diana"], "Cynthia" =&gt; ["Bob"], "Diana" =&gt; ["Alice", "Bob", "Fred"], "Elise" =&gt; ["Fred"], "Fred" =&gt; ["Alice", "Diana", "Elise"]&#125; 因为从散列表里查找一个键所对应的值只需要1步，所以查找Alice的朋友能以O(1)的时间复杂度完成，如下所示。1friends["Alice"] 跟Facebook不同，Twitter里面的关系不是相互的。Alice可以关注Bob，但Bob不一定要关注Alice。让我们构造一个新的图来表示谁关注了谁。 图中箭头表示了关系的方向。Alice关注了Bob和Cynthia，但没有人关注Alice。Bob和Cynthia互相关注。 用散列表来表示的话，就是这样：12345followees = &#123; "Alice" =&gt; ["Bob", "Cynthia"], "Bob" =&gt; ["Cynthia"], "Cynthia" =&gt; ["Bob"]&#125; 虽然Facebook跟Twitter的例子很相似，但它们本质上是不一样的。Twitter中的关系是单向的，我们也在图中用箭头表示了其方向，因此它的图是有向图。Facebook中的关系则是相互的，我们只画成了普通的线段，它的图是无向图。 尽管只用散列表也可以实现一个图，但是以面向对象的方法来写会更加健壮。 以下便是一种更为健壮的实现方式，它采用的语言是Ruby。123456789101112class Person attr_accessor :name, :friends def initialize(name) @name = name @friends = [] end def add_friend(friend) @friends &lt;&lt; friend # 数组添加对象元素 endend 12345678910111213141516class Person &#123; private $name; private $friends; function __construct($name) &#123; $this-&gt;name = $name; $this-&gt;friends = []; &#125; public function add_friend($friend) &#123; $this-&gt;friends[] = $friend; &#125;&#125; 有了这个Ruby类，我们就可以创建人物并且给他们添加朋友了。1234mary = Person.new("Mary")peter = Person.new("Peter")mary.add_friend(peter)peter.add_friend(mary) 12345$mary = new Person('Mary');$peter = new Person('Peter');$mary-&gt;add_friend($peter);$peter-&gt;add_friend($mary); 广度优先搜索LinkedIn也是一个流行的社交网络，其专注于职业社交。LinkedIn的一个有名的功能就是，你除了能够看到自己直接添加的联系人，还可以发掘你的二度、三度联系人。 如图所示，Alice能直接联系到Bob，Bob能直接联系到Cynthia。但Alice无法直接联系到Cynthia。由于她们之间的联系要经过Bob，因此Cynthia是Alice的二度联系人。 如果我们想查看Alice的整个关系网，包括她那些间接的关系，需要怎么做呢？ 图有两种经典的遍历方式：广度优先搜索和深度优先搜索。在此我们会研究广度优先搜索，深度优先搜索你可以自己去学习。两者是相似的，并且在大多数情况下都一样好用。 广度优先搜索算法需要用队列（参见队列）来记录后续要处理哪些顶点。该队列最初只含有起步的顶点（对本例来说，就是Alice）。于是算法一开始，我们的队列如下所示。 [Alice] 然后处理Alice顶点。我们将其移出队列，标为“已访问”，并记为当前顶点。（很快我们就会走一遍整个流程，让你看得更明白一些。） 接着按照以下3步去做。 (1)找出当前顶点的所有邻接点。如果有哪个是没访问过的，就把它标为“已访问”，并且将它入队。（尽管该顶点并未作为“当前顶点”被访问过。） (2) 如果当前顶点没有未访问的邻接点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点。 (3) 如果当前顶点没有未访问的邻接点，且队列里也没有其他顶点，那么算法完成。 下面来实际演示一遍。Alice的LinkedIn关系网如下图所示。 首先，将Alice设为当前顶点。为了在图中表示她是当前顶点，我们用线段将其围绕。为了表示Alice已被访问，我们在她旁边打了个钩。继续该算法，找出一个未访问的邻接点--本例中的Bob，在他名字旁边打个钩，如下图所示。 我们也将Bob入队，使队列变为[Bob]。这意味着Bob未曾作为当前顶点。注意，虽然当前顶点是Alice，但我们也能访问Bob。 接着，检查当前顶点Alice是否还有未访问的邻接点。发现有Candy，于是将其标为已访问。 现在队列为[Bob, Candy] 。 Alice还有邻接点Derek没访问过，于是访问他。 现在队列为[Bob, Candy, Derek] 。 Alice还有一个未访问的关系Elaine，于是我们也要访问她。 现在队列为[Bob, Candy, Derek, Elaine] 。 因为Alice已经没有未访问的邻接点了，所以执行本算法的第2条规则，从队列里移出一个顶点，把它设为当前顶点。回想第8章提到的，队列只能在队头移除数据，于是现在要移出的就是Bob。 现在队列变为[Candy, Derek, Elaine]，Bob成为了当前顶点。 然后回到第1条规则，找出当前顶点的所有未访问的邻接点。Bob有一个邻接点Fred，于是将他标记为已访问，并把他加入队列。 现在队列为[Candy, Derek, Elaine, Fred]。 因为Bob没有其他未访问的邻接点了，所以出队一个顶点--Candy--作为当前顶点。 然而Candy没有未访问的邻接点。于是再从队列中拿出一个顶点--Derek--使得队列变成[Elaine, Fred]。 Derek有一个未访问的邻接点Gina，我们将其标记为已访问。 现在队列为[Elaine, Fred, Gina]。 Derek没有邻接点需要访问了，于是我们从队列里拿出Elaine，将她标记为当前顶点。 Elaine没有未访问的邻接点，于是从队列中拿出Fred。 此时队列变为[Gina]。 Fred有一个联系人要访问--Helen--于是将其标为已访问，并且入队，使队列变成[Gina, Helen]。 Fred已经没有未访问的关系了，所以我们将Gina移出队列，将她设为当前顶点。 现在队列里只剩[Helen]了。 Gina有一个邻接点要访问--Irena。 现在队列为[Helen, Irena]。 Gina没有其他关系需要访问了，所以让Helen出队，将她设为当前顶点，于是队列里剩下的是[Irena]。Helen没有什么人需要访问，于是我们让Irena出队，将她设为当前顶点。因为Irena没有顶点需要访问，而且队列空了，所以算法结束！ 我们在Person类里加上display_network方法，以广度优先搜索的方式展示一个人的关系网里所有的名字。123456789101112131415161718192021222324252627282930313233343536373839class Person attr_accessor :name, :friends, :visited # visited表示是否标记 def initialize(name) @name = name @friends = [] @visited = false end def add_friend(friend) @friends &lt;&lt; friend end def display_network # 记下每个访问过的人，以便算法完结后能重置他们的 visited 属性为 false to_reset = [self] # 创建一个开始就含有根顶点的队列 queue = [self] self.visited = true while queue.any? # 设出队的顶点为当前顶点 current_vertex = queue.shift puts current_vertex.name # 将当前顶点的所有未访问的邻接点加入队列 current_vertex.friends.each do |friend| if !friend.visited to_reset &lt;&lt; friend queue &lt;&lt; friend friend.visited = true end end end # 算法完结时，将访问过的结点的 visited 属性重置为 false to_reset.each do |node| node.visited = false end endend 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person &#123; private $name; private $friends; private $visited ; function __construct($name) &#123; $this-&gt;name = $name; $this-&gt;friends = []; $this-&gt;visited = false; &#125; public function add_friend($friend) &#123; $this-&gt;friends[] = $friend; &#125; public function display_network() &#123; $to_reset = [$this]; $queue = [$this]; $this-&gt;visited = true; while (!empty($queue)) &#123; $current_vertex = array_shift($queue); echo $current_vertex-&gt;name; foreach ($current_vertex-&gt;friends as $friend) &#123; if ($friend-&gt;visited == false) &#123; $to_reset[] = $friend; $queue[] = $friend; $friend-&gt;visited = true; &#125; &#125; &#125; foreach ($to_reset as $node) &#123; $node-&gt;visited = false; &#125; &#125;&#125; 为了使它运作起来，我们还给Person类增加了visited属性，来记录一个人在本次搜索中是否已被访问。 将算法的步骤分为两类之后，我们可以看出图的广度优先搜索的效率。 让顶点出队，将其设为当前顶点。 访问每个顶点的邻接点。 这样看来，每个顶点都会有一次出队的经历。以大O记法表示，就是O(V)，意思是有V个顶点，就有V次出队。 既然要处理N个顶点，不应该表示为O(N)吗？不是的，因为在此算法（以及很多其他图的算法）中，除了处理顶点本身，还得处理边，下面就来解释。 我们观察一下访问邻接点需要多少步。 以当前顶点为Bob的时候为例。 此时我们会运行如下代码。123456current_vertex.friends.each do |friend| if !friend.visited queue &lt;&lt; friend friend.visited = true endend 12345678foreach ($current_vertex-&gt;friends as $friend) &#123; if ($friend-&gt;visited == false) &#123; $queue[] = $friend; $friend-&gt;visited = true; &#125;&#125; 就是说，我们会访问Bob所有的邻接点，其中不但有Fred，还有Alice！尽管她曾被访问过，不用再入队，但访问她还是增加了一次each循环。 要是你再认真地运行一遍整个广度优先搜索的流程，你会发现访问邻接点所用的步数，是图中边数的两倍。因为一条边连接着两个顶点，对于每个顶点，我们都要访问其所有邻接点。所以每条边都会被使用两次。 因此，有E条边，就会有2E步来访问邻接点，即每对邻接点都会被访问两次。不过由于大O忽略常数，所以只写作O(E)。 因为广度优先搜索有O(V)次出队，还有O(E)次访问，所以我们说它的效率为O(V + E)。 图数据库因为图擅长处理关系信息，所以有些数据库就以图的形式来存储数据。传统的关系型数据库（以行和列的形式保存数据的数据库）也能存储这类信息，我们不妨比较一下它们处理社交网络之类的数据时的表现。 假设有一个5人的社交网络，分别是Alice、Bob、Cindy、Dennis和Ethel，他们互相都有联系。保存他们个人信息的图数据库大概会如下图所示。 这种信息也可以用关系型数据库来存储。那得需要两张表--一张保存个人信息，另一张保存朋友关系。以下是Users表。 另一张Friendships表记录着谁是谁的朋友。 我们不会太过深入地研究数据库理论，但你得知道在Friendships表中只需以用户id来指代用户。 如果这个社交网络允许用户查看其朋友的全部信息，而Cindy也正要这么做，那意味着她想看到一切关于Alice、Bob、Dennis和Ethel的信息，包括他们的邮件地址和电话号码。 那我们就来看看以关系型数据库为后端的应用会怎样执行她的请求。首先，我们得找出User表中Cindy的id。 然后，找出Friendships表中所有user_id为3的行。 我们就得到了Cindy朋友的id列表：[1, 2, 4, 5]。 有了id列表之后，我们还得回Users表找出这些id对应的行。计算机从Users表查找一行的速度大概是O(log N)。因为数据库中的行会按照id的顺序来维护，所以我们可以用二分查找来找出id对应的行。（以上解释只适用于部分关系型数据库，其他关系型数据库可能有不同做法。） Cindy有4个朋友，所以计算机需要做4次O(log N)查询才能提取出她全部朋友的个人信息。推广开来，若有M个朋友，那么提取他们个人信息的效率就为O(M log N)。换句话说，对于每个朋友，都要执行一次步数为log N的搜索。 相比之下，后端为图数据库时，一旦在数据库中定位到Cindy，那么只需一步就能查到她任一朋友的信息。因为数据库中的每个顶点已经包含了该用户的所有信息，所以你只需遍历那些连接Cindy与朋友的边即可。如下图所示，总共也就4步。 用图数据库的话，有N个朋友就需要O(N)步去获取他们的数据。与关系型数据库的O(M log N)相比，确实是极大的效率提升。 Neo4j是开源的图数据库中比较受欢迎的一个。我建议你上它的官网去了解更多关于图数据库的知识。其他开源的图数据库还有ArangoDB和Apache Giraph。 但记住，图数据库也并不总是最好的解决方案。你得谨慎地评估每个应用场景的需求再做选择。 加权图还有一种图叫作加权图。它跟普通的图类似，但边上带有信息。 以下这个包含了美国几个主要城市的简陋地图，就是一个加权图。 此图中，每条边上都有一个数字，它表示那条边所连接的两个城市相距多少英里。例如，Chicago和New York City之间的距离为714英里。 加权图可以是有方向的。以下图为例，尽管从Dallas飞到Toronto只要138美元，但从Toronto飞到Dallas要216美元。 要往图里加上权重，得稍微更改一下我们的Ruby代码。具体来说，我们要把表示邻接点的数组换成散列表。对于上图来说，一个顶点就是一个City类的对象。12345678910111213class City attr_accessor :name, :routes def initialize(name) @name = name # 把表示邻接点的数组换成散列表 @routes = &#123;&#125; end def add_route(city, price) @routes[city] = price endend 这样就可以创建城市和不同价格的航线了。1234dallas = City.new("Dallas")toronto = City.new("Toronto")dallas.add_route(toronto, 138)toronto.add_route(dallas, 216) 我们可以借助加权图来解决最短路径问题。 下图展示了5个城市之间的航线价格。 假设我目前身在Atlanta，想飞去El Paso。不幸的是，现在没有直达航班。然而，我也可以在其他城市转机过去。例如，先从Atlanta到Denver，再从Denver到El Paso。这会花费300美元。但再看仔细一点，你会发现从Atlanta沿Denver、Chicago再到ElPaso会更加便宜。虽然多转一次，但只需花280美元。 这就是一种最短路径问题：如何以最低的价钱从Atlanta飞往El Paso。 Dijkstra算法解决最短路径问题的算法有好几种，其中一种有趣的算法是由Edsger Dijkstra于1959年发现的。该算法也很自然地被称为Dijkstra算法。 Dijkstra算法的规则如下（别担心，之后我们跟着例子运行一遍就会更明白了）。 (1)以起步的顶点为当前顶点。 (2)检查当前顶点的所有邻接点，计算起点到所有已知顶点的权重，并记录下来。 (3)从未访问过（未曾作为当前顶点）的邻接点中，选取一个起点能到达的总权重最小的顶点，作为下一个当前顶点。 (4)重复前3步，直至图中所有顶点都被访问过。 下面来一步步地运行一遍整个算法。 我们用以下表格来记录Atlanta到其他城市最便宜的价格。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** ？ ？ ？ ？ 首先，以起步顶点（Atlanta）作为当前顶点。此时我们能访问的就是当前顶点以及其邻接点。为指明哪个点是当前顶点，我们以线段将其围绕。为指明哪些点曾作为当前顶点，我们给它们打上钩。 接着检查所有邻接点，记下从起点（Atlanta）到所有已知地点的权重。可见从Atlanta到Boston是100美元，从Atlanta到Denver是160美元，于是记录到表格里。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 ？ 160 ？ 接着从Atlanta可到达但又未访问过的顶点中，找出最便宜的那个。就目前所知，从Atlanta出发可以到达Boston和Denver，并且Boston（100美元）比Denver（160美元）更便宜。因此，选择Boston作为当前顶点。 然后检查从Boston出发的航线，更新从起点Atlanta到所有已知地点的花费。我们看到Boston到Chicago是120美元。Atlanta到Boston是100美元，Boston到Chicago是120美元，所以从Atlanta到Chicago最便宜的（而且是目前唯一的）路线要220美元。我们把它记在表里。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 220 160 ？ 再看看从Boston出发的另一条航线--Denver--要180美元。于是我们又发现了一条从Atlanta到Denver的路线：Atlanta到Boston再到Denver。不过这条路线要280美元，而Atlanta直飞Denver才160美元，所以无须更新价格表，毕竟我们只想记录最便宜的路线。 既然从当前顶点（Boston）出发的航线都已探索过了，就得找下一个从起点Atlanta所能到达的最便宜的未访点了。根据表格来看，最便宜的还是Boston，但它已经打过钩了。这样最便宜的未访问城市应该是Denver了，因为与220美元的Chicago相比，它只要160美元。于是Denver变成了当前顶点。 那么我们就来观察由Denver出发的航线，其中一条从Denver到Chicago的航线是40美元。于是我们可以更新Atlanta到Chicago的最低价格了。因为现在的价格表里Atlanta到Chicago要220美元，但若经Denver转机，则只需200美元。所以更新一下表格。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 ？ 从Denver飞出的航班还有一个，它的目的地是El Paso。我们要计算Atlanta到El Paso的最低价格，目前只能从Atlanta到Denver再到El Paso，共300美元。将价钱记下。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 300 现在还没访问的顶点有两个：Chicago和El Paso。Atlanta到Chicago的最低价（200美元）比Atlanta到El Paso的最低价（300美元）要低，所以下一步选择Chicago作为当前顶点。 Chicago只有一个出发航班：80美元到El Paso。于是Atlanta到El Paso路线的最低价格得以更新：从Atlanta到Denver，再到Chicago，最后抵达El Paso，总共花费280美元。我们把它记下。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 280 最后只剩一个城市可作为当前顶点了，那就是El Paso。 El Paso只有一个出发航班：100美元飞到Boston。这并没刷新Atlanta到其他地方的最低价，所以我们无须更新价格表。 现在所有顶点都访问过了，这就意味着Atlanta到其他城市的所有路径都已发掘。于是算法结束，我们也可以从价格表得知从Atlanta到地图上任一城市的最低价格了。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 280 以下是Dijkstra算法的Ruby实现。 我们先创建一个代表城市的Ruby类。一个城市就是图上的一个结点，它记有自己的名字以及可到达的城市。123456789101112131415class City attr_accessor :name, :routes def initialize(name) @name = name # 把表示邻接点的数组换成散列表 @routes = &#123;&#125; # 如果此城市是 Atlanta，则散列表应包含： # &#123;boston =&gt; 100, denver =&gt; 160&#125; end def add_route(city, price_info) @routes[city] = price_info endend 然后用add_route来建立城市间的航线。123456789101112atlanta = City.new("Atlanta")boston = City.new("Boston")chicago = City.new("Chicago")denver = City.new("Denver")el_paso = City.new("El Paso")atlanta.add_route(boston, 100)atlanta.add_route(denver, 160)boston.add_route(chicago, 120)boston.add_route(denver, 180)chicago.add_route(el_paso, 80)denver.add_route(chicago, 40)denver.add_route(el_paso, 140) Dijkstra算法的代码是有点复杂的，所以我在每一步都做了注释。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def dijkstra(starting_city, other_cities) # 散列表 routes_from_city 用来保存从给定城市到其他所有城市的价格 # 以及途经的城市 routes_from_city = &#123;&#125; # 它的格式如下： # &#123;终点城市 =&gt; [价格, 到达终点城市前所要经过的那个城市]&#125; # 以上图为例，此散列表最后会是： # &#123;atlanta =&gt; [0, nil], boston =&gt; [100, atlanta], chicago =&gt; [200, denver], # denver =&gt; [160, atlanta], el_paso =&gt; [280, chicago]&#125; # 从起点城市到起点城市是免费的 routes_from_city[starting_city] = [0, staring_city] # 初始化该散列表时，因为去往所有其他城市的花费都未知，所以先设为无限 other_cities.each do |city| routes_from_city[city] = [Float::INFINITY, nil] end # 以上图为例，此散列表起初会是： # &#123;atlanta =&gt; [0, nil], boston =&gt; [Float::INFINITY, nil], # chicago =&gt; [Float::INFINITY, nil], # denver =&gt; [Float::INFINITY, nil], el_paso =&gt; [Float::INFINITY, nil]&#125; # 已访问的城市记录在这个数组里 visited_cities = [] # 一开始先访问起点城市，将 current_city 设为它 current_city = starting_city # 进入算法的核心逻辑，循环访问每个城市 while current_city # 正式访问当前城市 visited_cities &lt;&lt; current_city # 检查从当前城市出发的每条航线 current_city.routes.each do |city, price_info| # 如果起点城市到其他城市的价格比 routes_from_city 所记录的更低， # 则更新记录 if routes_from_city[city][0] &gt; price_info + routes_from_city[current_city][0] routes_from_city[city] = [price_info + routes_from_city[current_city][0], current_city] end end # 决定下一个要访问的城市 current_city = nil cheapest_route_from_current_city = Float::INFINITY # 检查所有已记录的路线 routes_from_city.each do |city, price_info| # 在未访问的城市中找出最便宜的那个， # 设为下一个要访问的城市 if price_info[0] &lt; cheapest_route_from_current_city &amp;&amp; !visited_cities.include?(city) cheapest_route_from_current_city = price_info[0] current_city = city end end end return routes_from_cityend 该方法可以这样使用：1234routes = dijkstra(atlanta, [boston, chicago, denver, el_paso])routes.each do |city, price_info|p "#&#123;city.name&#125;: #&#123;price_info[0]&#125;"end 虽然这个例子是找出最便宜的航线，但其解决方法也适用于地图软件和GPS技术。如果边上的权重不是表示价格，而是表示行车用时，那就可以用Dijkstra算法来确定从一个城市去另一个城市应该走哪条路线。 总结这一章讲的是本书最后一种重要的数据结构，我们的学习之旅也接近了尾声。我们知道了图是处理关系型数据的强大工具，它除了能让代码跑得更快，还能帮忙解决一些复杂的问题。 学习至今，我们关注的主要是代码运行的速度。我们以时间和算法的步数来衡量代码的性能。 然而，性能的衡量方法不止这些。在某些情况下，还有比速度更重要的东西，比如我们可能更关心一种数据结构或算法会消耗多少内存。下一章，我们就来学习如何分析一段代码在空间上的效率。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第12章-让一切操作都更快的二叉树]]></title>
    <url>%2F2018%2F06%2F13%2F%E7%AC%AC12%E7%AB%A0-%E8%AE%A9%E4%B8%80%E5%88%87%E6%93%8D%E4%BD%9C%E9%83%BD%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是树？什么是二叉树？ 二叉树既可以保持顺序，又可以快速查找、插入和删除。为什么？ 先创建节点类，然后再用节点对象构建二叉树类。怎么理解？ 二叉树查找的时间复杂度是O(log N)。因为每行进一步，我们就把剩余的结点排除了一半。怎么理解？ 本章涵盖： 二叉树 查找 插入 删除 二叉树实战 之前介绍了二分查找这一概念，并演示了当数组有序时，运用二分查找就能以O(log N)的时间复杂度找出任意值的所在位置。可见，有序的数组是多么美好。 但是有序数组存在着另一个问题。 有序数组的插入和删除是缓慢的。往有序数组中插入一个值前，你得将所有大于它的元素右移一格。从有序数组中删除一个值后，你得将所有大于它的元素左移一格。最坏情况下（插入或删除发生在数组开头）这会需要N步，平均情况则是N/2步。不管怎样，都是O(N)的效率，而O(N)算是挺慢的。 后来，学到了散列表能以O(1)的效率进行查找、插入和删除，但它又有另一明显的不足：不保持顺序。 既要保持顺序，又要快速查找、插入和删除，看来有序数组和散列表都不行。那还有什么数据结构可以选择？ 看看二叉树吧。 二叉树上一章我们通过链表见识了基于结点的数据结构。一个普通的链表里，每一个结点会包含一个连接自身和另一结点的链。树也是基于结点的数据结构，但树里面的每个结点，可以含有多个链分别指向其他多个结点。 以下是一棵典型的树 此例中，每个结点链接着另外两个结点。简单起见，我们也可以不用画出存储链的格子。 谈论树的时候，我们会用到以下术语。 最上面的那一结点（此例中的“j”）被称为根。是的，图中的根位于树的顶端，请自行意会。 此例中，“j”是“m”和“b”的父结点，反过来，“m”和“b”是“j”的子结点。“m”又是“q”和“z”的父结点，“q”和“z”是“m”的子结点。 树可以分层。此例中的树有3层。 基于树的数据结构有很多种，但本章只关注其中一种--二叉树。二叉树是一种遵守以下规则的树。 每个结点的子结点数量可为0、1、2。 如果有两个子结点，则其中一个子结点的值必须小于父结点，另一个子结点的值必须大于父结点。 以下是一个二叉树的例子，其中结点的值是数字。 注意，小于父结点的子结点用左箭头来表示，大于父结点的子结点则用右箭头来表示。 尽管下图是一棵树，但它不是二叉树。 之所以不是二叉树，是因为它的两个子结点的值都小于父结点。 以Python来实现一个树结点的话，大概是这样：12345class TreeNode: def __init__(self,val,left=None,right=None): self.value = val self.leftChild = left self.rightChild = right 然后就可以用它来构建一棵简单的树了。123node = TreeNode(1)node2 = TreeNode(10)root = TreeNode(5, node, node2) 因为二叉树具有这样独特的结构，所以我们能在其中非常快速地进行查找操作，下面就来看看。 查找这是一棵二叉树。 二叉树的查找算法先从根结点开始。 (1)检视该结点的值。 (2)如果正是所要找的值，太好了！ (3)如果要找的值小于当前结点的值，则在该结点的左子树查找。 (4)如果要找的值大于当前结点的值，则在该结点的右子树查找。 以下是用Python写的递归式查找。12345678910111213def search(value, node): # 基准情形：如果 node 不存在 # 或者 node 的值符合 if node is None or node.value == value: return node # 如果 value 小于当前结点，那就从左子结点处查找 elif value &lt; node.value: return search(value, node.leftChild) # 如果 value 大于当前结点，那就从右子结点处查找 else: # value &gt; node.value return search(value, node.rightChild) 假设现在我们要找61，那来看看整个过程要花多少步。 树的查找必须从根开始。 接着，计算机会问自己：我们要找的值与该结点的值相比，是大还是小呢？如果小于当前结点，那就在左子结点上找。如果大于当前结点，那就在右子结点上找。 本例中，因为61大于50，所以它只能在树的右侧，于是我们检查右子结点。 算法继续检查该结点的值。因为75不是我们要找的61，所以还得往下一层找。由于61小于75，它只能在75的左侧，于是下一步去的是左子结点。 因为 61大于 56，所以到 56的右子结点上找。 在这棵树里找出61，我们总共用了4步。 推广开来，我们会说二叉树查找的时间复杂度是O(log N)。因为每行进一步，我们就把剩余的结点排除了一半（不过很快就能看到，只在最好情况下，即理想的平衡二叉树才有这样的效率）。 再与二分查找比较，它也是每次尝试会排除一半可能性的O(log N)算法，可见二叉树查找跟有序数组的二分查找拥有同样的效率。 要说二叉树哪里比有序数组更亮眼，那应该是插入操作。 插入要探索二叉树插入的算法，我们还是从一个实例入手吧。假设现在要往刚才的树里插入45。 首先要做的就是找出45应该被链接到哪个结点上。先从根开始找起。 因为45小于50，所以我们转到左子结点上。 因为45大于25，所以我们检查右子结点。 45大于33，所以检查33的右子结点。 至此，我们到达了一个没有子结点的结点，也就无法再往下了。这意味着可以做插入了。 因为45大于40，所以将其作为40的右子结点来插入。 在这个例子里，插入花了5步，包括4步查找和1步插入。插入这1步总是发生在查找之后，所以总共log N+1步。按照忽略常数的大O来说，就是O(log N)步。 有序数组的插入则是O(N)，因为该过程中除了查找，还得移动大量的元素来给新元素腾出空间。 这就是二叉树的高效之处。有序数组查找需要O(log N)，插入需要O(N)，而二叉树都是只要O(log N)。当你估计应用会发生许多数据改动时，这一比较将有助你做出正确选择。 以下是二叉树插入的Python实现，它跟search一样都是递归的。12345678910111213def insert(value, node): if value &lt; node.value: # 如果左子结点不存在，则将新值作为左子结点 if node.leftChild is None: node.leftChild = TreeNode(value) else: insert(value, node.leftChild) elif value &gt; node.value: # 如果右子结点不存在，则将新值作为右子结点 if node.rightChild is None: node.rightChild = TreeNode(value) else: insert(value, node.rightChild) 注意，只有用随意打乱的数据创建出来的树才有可能是比较平衡的。要是插入的都是已排序的数据，那么这棵树就失衡了，它用起来也会比较低效。比如说，按顺序插入1、2、3、4、5的话，得出的树就会是这样。 从中查找5，效率会是O(N)。 但要是按3、2、4、1、5的顺序来插入的话，得出的树就是平衡的。 因此，假若你要用有序数组里的数据来创建二叉树，最好先把数据洗乱。 在完全失衡的最坏情况下，二叉树的查找需要O(N)。在理想平衡的最好情况下，则是O(log N)。在数据随机插入的一般情况下，因为树也大致平衡，所以查询效率也大约是O(log N)。 删除删除是二叉树的各种操作中最麻烦的一个，必须考虑周全才好动手。假设现在要删除这棵二叉树中的4。 首先，我们查找出它所在的结点，然后一步将该结点删掉。 这看起来好像很简单，那我们再试试删掉10吧。 如果删掉10的话，就会导致11的那个结点从树上脱离。当然这是不允许的，否则这个11就永远都找不到了。好在我们还有解决办法：将11放到之前10所在的位置。 至此，删除操作遵循以下规则。 如果要删除的结点没有子结点，那直接删掉它就好。 如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上。 要删除带有两个子结点的结点是最复杂的。比如说现在要删除56。 那52和61要怎么处理呢？显然不能将它们都放到 56原本的位置上，还需要第三条规则。 如果要删除的结点有两个子结点，则将该结点替换成其后继结点。一个结点的后继结点，就是所有比被删除结点大的子结点中，最小的那个。 上面这句话听起来有点绕。或者你把这些结点按顺序排好，那么每个结点后续的那个结点就是其后继结点。就像本例中56的所有后裔中，只有61能被称为其后继结点。按照这个规则，我们将56替换成61。 那计算机是怎么找出后继结点的呢？这是有算法可循的。 跳到被删除结点的右子结点，然后一路只往左子结点上跳，直到没有左子结点为止，则所停留的结点就是被删除节点的后继结点。 再来看一个更复杂的删除，这次我们删除根结点。 现在需要找后继结点来填补根的位置。 首先，访问右子结点，然后一路往左下方向移步，直至没有左子结点的结点上。 这就找出后继结点52了，接着我们将其填到被删除结点的位置上。 删除完成！ 然而，还有一种情况我们没遇到过，那就是后继结点带有右子结点。让我们回到根被删除之前的状态，并且给52加上一个右子结点。 如此一来，就不能只将后继结点52移到根那里了，因为这样会使其子结点55悬空。于是，我们再加一条关于删除的规则。 如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点。 下面运行一遍这个流程。 首先，将后继结点填到根处。 此时55便悬在半空中了。接下来，将55转换为继承节点的父节点的左子节点，本例中，61是继承结点的父结点，所以55成为61的左子结点。 这才算真正完成了。 以下为二叉树的删除算法的所有规则。 如果要删除的结点没有子结点，那直接删掉它就好。 如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上。 如果要删除的结点有两个子结点，则将该结点替换成其后继结点。一个结点的后继结点，就是所有比被删除结点大的子结点中，最小的那个。 如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点。 以下是用Python写的二叉树递归式删除算法。为了易于理解，安插了一些注释进去。12345678910111213141516171819202122232425262728293031323334353637383940414243444546def delete(valueToDelete, node): # 当前位置的上一层无子结点，已到达树的底层，即基准情形 if node is None: return None # 如果要删除的值小于（或大于）当前结点， # 则以左子树（或右子树）为参数，递归调用本方法， # 然后将当前结点的左链（或右链）指向返回的结点 elif valueToDelete &lt; node.value: node.leftChild = delete(valueToDelete, node.leftChild) # 将当前结点（及其子树，如果存在的话）返回， # 作为其父结点的新左子结点（或新右子结点） return node elif valueToDelete &gt; node.value: node.rightChild = delete(valueToDelete, node.rightChild) return node # 如果要删除的正是当前结点 elif valueToDelete == node.value: # 如果当前结点没有左子结点， # 则以右子结点（及其子树，如果存在的话）替换当前结点成为当前结点之父结点的新子结点 if node.leftChild is None: return node.rightChild # 如果当前结点没有左子结点，也没有右子结点，那这里就是返回 None elif node.rightChild is None: return node.leftChild # 如果当前结点有两个子结点，则用 lift 函数（见下方）来做删除， # 它会使当前结点的值变成其后继结点的值 else: node.rightChild = lift(node.rightChild, node) return node def lift(node, nodeToDelete): # 如果此函数的当前结点有左子结点， # 则递归调用本函数，从左子树找出后继结点 if node.leftChild: node.leftChild = lift(node.leftChild, nodeToDelete) return node # 如果此函数的当前结点无左子结点， # 则代表当前结点是后继结点，于是将其值设置为被删除结点的新值 else: nodeToDelete.value = node.value # 用后继结点的右子结点替代后继结点的父节点的左子结点 return node.rightChild 跟查找和插入一样，平均情况下二叉树的删除效率也是O(log N)。因为删除包括一次查找，以及少量额外的步骤去处理悬空的子结点。有序数组的删除则由于需要左移元素去填补被删除元素产生的空隙，最终导致O(N)的时间复杂度。 二叉树实战二叉树在查找、插入和删除上引以为傲的O(log N)效率，使其成为了存储和修改有序数据的一大利器。它尤其适用于需要经常改动的数据，虽然在查找上它跟有序数组不相伯仲，但在插入和删除方面，它迅速得多。 比如说你正在做一个书目维护的应用，它需要具备以下功能。 该应用可以将书名依照字母序打印。 该应用可以持续更新书目。 该应用可以让用户从书目中搜索书名。 如果你预期该书目不常变动的话，那么用有序数组作为存储结构是可以的。但这个应用偏偏要经常实时更新数据。要是其中包含上百万册图书，那还是用二叉树来保存比较好。 存储书名的二叉树大概是下面这个样子。 书名的搜索和更新，可以按我们之前介绍的二叉树查找、插入和删除来解决。但依照字母序打印书名该怎么做呢？ 首先，我们得学会如何访问树上的所有结点。访问数据结构中所有元素的过程，叫作遍历数据结构。 接着，为了使书名以字母序打印，我们得确保遍历也是以字母序进行。虽然有多种方法可以遍历树，但对于这个要求字母序打印的应用，我们采用中序遍历。 递归是实施中序遍历的有力工具。我们将创建一个名为traverse的递归函数，它可以在任一结点上调用。然后执行以下步骤。 (1) 如果此结点有左子结点，则在左子结点上调用自身（traverse）。(2) 访问此结点（对于书目应用来说，就是打印结点的值）。(3) 如果此结点有右子结点，则在右子结点上调用自身（traverse）。 若当前结点没有子结点，则意味着该递归算法到达了基准情形，这时我们无须再调用traverse，只需打印结点中的书名就行了。 在“Moby Dick”上调用traverse的话，就能以下图的顺序访问树上的所有结点。 这样就能依照字母序打印书目了。遍历会访问树上所有的结点，所以树的遍历效率为O(N)。 以下是用Python写的以字母序打印书目的traverse_and_print函数。123456def traverse_and_print(node): if node is None: return traverse_and_print(node.leftChild) print(node.value) traverse_and_print(node.rightChild) 总结二叉树是一种强大的基于结点的数据结构，它既能维持元素的顺序，又能快速地查找、插入和删除。尽管比它的近亲链表更为复杂，但它更有用。 值得一提的是，树形的数据结构除了二叉树以外还有很多种，包括堆、B树、红黑树、2-3-4树等。它们也各有自己适用的场景。 下一章，我们还会遇见另一种基于结点的数据结构--图。图是社交网络和地图软件等复杂应用的核心组成部分，强大且灵活。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章-基于结点的数据结构]]></title>
    <url>%2F2018%2F06%2F12%2F%E7%AC%AC11%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数组和链表有什么区别？ 什么是链表？什么是结点？什么是链？每个结点需要几个格子？ 链表的第一个节点有什么作用？ 链表的物理结构与数组不同怎么理解？链表相对数组有什么好处？ 用一种语言来实现链表。写链表需要两个类，哪两个？为什么？ 链表的读取和查找如何进行？是什么时间复杂度？ 链表的开头插入和末尾插入如何进行？是什么时间复杂度？ 什么场景适合使用链表？链表在删除操作中有优势，也是可实际使用的地方。怎么理解？ 链表的另一个引人注目的应用，就是作为队列的底层数据结构。为什么？ 什么是双向链表？ 本章涵盖： 链表 实现一个链表 读取 查找 插入 删除 链表实战 双向链表 接下来的几章将要学习的各种数据结构，都涉及一种概念--结点。基于结点的数据结构拥有独特的存取方式，因此在某些时候具有性能上的优势。 本章我们会探讨链表，它是最简单的一种基于结点的数据结构，而且也是后续内容的基础。 你会发现，虽然链表和数组看上去差不多，但在性能上却各有所长。 链表像数组一样，链表也用来表示一系列的元素。事实上，能用数组来做的事情，一般也可以用链表来做。然而，链表的实现跟数组是不一样的，在不同场景它们会有不同的性能表现。 计算机的内存就像一大堆格子，每格都可以用来保存比特形式的数据。当要创建数组时，程序会在内存中找出一组连续的空格子，给它们起个名字，以便你的应用存放数据，见下图。 我们之前说过，计算机能够直接跳到数组的某一索引上。如果代码要求它读取索引4的值，那么计算机只需一步就可以完成任务。重申一次，之所以能够这样，是因为程序事先知道了数组开头所在的内存地址--例如地址是1000--当它想去索引4时，便会自动跳到1004处。 与数组不同的是，组成链表的格子不是连续的。它们可以分布在内存的各个地方。这种不相邻的格子，就叫作结点。 那么问题来了，计算机怎么知道这些分散的结点里，哪些属于这个链表，哪些属于其他链表呢？ 这就是链表的关键了：每个结点除了保存数据，它还保存着链表里的下一结点的内存地址。 这份用来指示下一结点的内存地址的额外数据，被称为链。链表如下图所示。 此例中，我们的链表包含4项数据：“a”、“b”、“c”和“d”。因为每个结点都需要2个格子，头一格用作数据存储，后一格用作指向下一结点的链（最后一个结点的链是null，因为它是终点），所以整体占用了8个格子。 若想使用链表，你只需知道第一个结点在内存的什么位置。因为每个结点都有指向下一结点的链，所以只要有给定的第一个结点，就可以用结点1的链找到结点2，再用结点2的链找到结点3……如此遍历链表的剩余部分。 链表相对于数组的一个好处就是，它可以将数据分散到内存各处，无须事先寻找连续的空格子。 实现一个链表我们用Ruby来写一个链表，最终实现包含两个类：Node和LinkedList 。先是Node。12345678class Node # 创建读写变量data,next_node attr_accessor :data, :next_node def initialize(data) @data = data endend Node类有两个属性：data表示结点所保存的数据，next_node表示指向下一结点的链，使用方法如下。1234567node_1 = Node.new("once")node_2 = Node.new("upon")node_1.next_node = node_2node_3 = Node.new("a")node_2.next_node = node_3node_4 = Node.new("time")node_3.next_node = node_4 以上代码创建了4个连起来的结点，它们分别保存着“once”、“upon”、“a”和“time”4项数据。 虽然只用Node也可以创建出链表，但我们的程序无法由此轻易地得知哪个结点是链表的开端。因此我们还得创建一个LinkedList类。下面是一个最基本的LinkedList的写法。12345678class LinkedList attr_accessor :first_node def initialize(first_node) @first_node = first_node endend 有了这个类，我们就可以用以下代码让程序知道链表的起始位置了。1list = LinkedList.new(node_1) LinkedList的作用就是一个指针，它指向链表的第一个结点。 既然知道了链表是什么，那么接下来做个它跟数组的性能对比，观察它们在读取、查找、插入和删除上有何优劣。 读取我们曾经说过，当计算机要从数组中读取一个值时，它会一步跳到对应的格子上，其效率为O(1)。但在链表中就不是这样了。 假设程序要读取链表中索引2的值，计算机不可能在一步之内完成，因为无法一下子算出它在内存的哪个位置。毕竟，链表的结点可以分布在内存的任何地方。程序知道的只有第1个结点的内存地址，要找到索引2的结点（即第3个），程序必须先读取索引0的链，然后顺着该链去找索引1。接着再读取索引1的链，去找索引2，这才能读取到索引2里的值。 下面我们在LinkedList类中加入读取操作。12345678910111213141516171819202122232425class LinkedList attr_accessor :first_node def initialize(first_node) @first_node = first_node end def read(index) # 从第一个结点开始 current_node = first_node current_index = 0 while current_index &lt; index do # 顺着链往下找，直至我们要找的那个索引值 current_node = current_node.next_node current_index += 1 # 如果读到最后一个结点之后，就说明 # 所找的索引不在链表中，因此返回 nil return nil unless current_node end return current_node.data endend 当想要读取某个索引时，可以这样写：1list.read(3) 读取链表中某个索引值的最坏情况，应该是读取最后一个索引。这种情况下，因为计算机得从第一个结点开始，沿着链一直读到最后一个结点，于是需要N步。由于大O记法默认采用最坏情况，所以我们说读取链表的时间复杂度为O(N)。这跟读取数组的O(1)相比，的确是一大劣势。 查找链表的查找效率跟数组一样。记住，所谓查找就是从列表中找出某个特定值所在的索引。对于数组和链表来说，它们都是从第一格开始逐个格子地找，直至找到。如果是最坏情况，即所找的值在列表末尾，或完全不在列表里，那就要花O(N)步。 下面是查找方法的实现。12345678910111213141516171819202122232425class LinkedList attr_accessor :first_node # 其他方法略…… def index_of(value) # 从第一个结点开始 current_node = first_node current_index = 0 begin # 如果找到，就返回 if current_node.data == value return current_index end # 否则，看下一个结点 current_node = current_node.next_node current_index += 1 end while current_node # 如果遍历整个链表都没找到，就返回 nil return nil endend 有了它我们就可以这样来查找了：1list.index_of("time") 插入在某些情况下，链表的插入跟数组相比，有着明显的优势。回想插入数组的最坏情况：当插入位置为索引0时，因为需要先将插入位置右侧的数据都右移一格，所以会导致O(N)的时间复杂度。然而，若是往链表的表头进行插入，则只需一步，即O(1)。下面看看为什么。 假设我们的链表如下所示。 要在表头增加“yellow”，我们只需创建一个新的结点，然后使其链接到“blue”那一结点。 因为无须平移其他数据，所以与数组相比，链表在前端插入数据更为便捷。 虽然理论上在链表的任何一处做插入都只需要1步，但事实上没那么简单。假设现在链表是这样的： 然后我们想在索引2（“blue”和“green”之间）插入“purple”。由于插入动作创建了一个新的结点，如下图那样改动“blue”和“purple”的链，因此实际的操作只需1步。 但是，在该动作之前，计算机还得先找到索引1的结点（“blue”），让结点1的链指向新的结点。这个过程就是之前所说的读取链表，其效率为O(N)。下面我们来演示一下。 因为新结点是加在索引1之后，所以计算机要先找出索引1。这得从第一个结点开始。 接着通过第一个链访问下一个结点。 既然已到达索引1的结点，那就可以增加新的结点进去了。 刚才添加“purple”的例子花了3步。若想将它添加到链表的末尾，就得花5步：先是用4步跳到索引3上，再用1步插入新结点。 因此，链表的插入效率为O(N)，与数组一样。 有趣的是，通过以上分析，你会发现链表的最坏情况和最好情况与数组刚好相反。在链表开头插入很方便，在数组开头插入却很麻烦；在数组的末尾插入是最好情况，在链表的末尾插入却是最坏情况。总结起来如下表所示。 场 景 数 组 链 表 在前端插入 最坏情况 最好情况 在中间插入 平均情况 平均情况 在末端插入 最好情况 最坏情况 下面给LinkedList类加上插入方法。12345678910111213141516171819202122232425262728class LinkedListattr_accessor :first_node # 其他方法略…… def insert_at_index(index, value) # 创建新结点 new_node = Node.new(value) # 如果在开头插入，则将新结点的 next_node 指向原 first_node， # 并为其设置新的 first_node if index == 0 new_node.next_node = first_node return @first_node = new_node end current_node = first_node current_index = 0 # 先找出新结点插入位置前的那一结点 prev_index = index - 1 while current_index &lt; prev_index do current_node = current_node.next_node current_index += 1 end new_node.next_node = current_node.next_node # 使前一结点的链指向新结点 current_node.next_node = new_node endend 删除从效率上来看，删除跟插入是相似的。如果删除的是链表的第一个结点，那就只要1步：将链表的first_node设置成当前的第二个结点。 回到“once”、“upon”、“a”和“time”的例子。如果要删除“once”，那直接让链表以“upon”为开头就好了。1list.first_node = node_2 再回想删除数组的第一个元素时，得把剩余的所有元素左移一格，需要O(N)的时间复杂度。 删除链表的最后一个结点，其实际的删除动作只需1步--令倒数第二的结点的链指向null。 然而，要找出倒数第二的结点，得花N步，因为我们依然只能从第一个结点顺着链往下一个个地找。 下面这个表格对比了各种情况下数组和链表删除操作的效率。注意它跟插入效率的表格几乎一模一样。 场 景 数 组 链 表 在前端删除 最坏情况 最好情况 在中间删除 平均情况 平均情况 在末端删除 最好情况 最坏情况 要在链表中间做删除，计算机需要修改被删结点的前一结点的链，看下面的例子你就会明白。 假设现在要删除刚才例子的索引2的值（“purple”），计算机就会找出索引1的结点，将其链指向”green”结点。 LinkedList类的删除操作实现如下。12345678910111213141516171819202122232425262728293031class LinkedList attr_accessor :first_node # 其他方法略…… def delete_at_index(index) # 如果删除的是第一个结点， # 则将 first_node 重置为第二个结点， # 并返回原第一个结点 if index == 0 deleted_node = first_node @first_node = first_node.next_node return deleted_node end current_node = first_node current_index = 0 # 先找出被删结点前的那一结点， # 将其命名为 current_node while current_index &lt; index - 1 do current_node = current_node.next_node current_index += 1 end # 再找出被删结点后的那一结点 deleted_node = current_node.next_node node_after_deleted_node = deleted_node.next_node # 将 current_node 的链指向 node_after_deleted_node， # 这样被删结点就被排除在链表之外了 current_node.next_node = node_after_deleted_node deleted_node endend 经过一番分析，链表与数组的性能对比如下所示。 操 作 数 组 链 表 读取 O(1) O(N) 查找 O(N) O(N) 插入 O(N)（在末端是O(1)） O(N)（在前端是O(1)） 删除 O(N)（在末端是 O(1)） O(N)（在前端是O(1)） 尽管两者的查找、插入、删除的效率看起来差不多，但在读取方面，数组比链表要快得多。 既然如此，那为什么还要用链表呢？ 链表实战高效地遍历单个列表并删除其中多个元素，是链表的亮点之一。假设我们正在写一个整理电子邮件地址的应用，它会删掉列表中无效格式的地址。具体算法是，每次读取一个地址，然后用正则表达式（一种用于识别数据格式的特定模式）来校验其有效性。如果发现该地址无效，就将它从列表中移除。 不管这个列表是数组还是链表，要检查每个元素的话，都得花N步。然而，当要删除邮件地址时，它们的效率却不同，下面我们来验证一下。 用数组的话，每次删除邮件地址，我们就要另外再花O(N)步去左移后面的数据，以填补删除所产生的空隙。而且还必须完成这些平移才能执行下一次邮件地址的检查。 所以如果存在需要删除的无效地址，那么除了遍历邮件地址的N步，还得加上N步乘以无效地址数。 假设每10个地址就有1个是无效的。如果列表包含1000个地址，那么无效的就应该会有100个。于是我们的算法就要花1000步来读取，再加上删除所带来的大约100000步的操作（100个无效地址 × N）。 但要是链表的话，每次删除只需1步就好，因为只需改动结点中链的指向，然后就可以继续检查下一邮件地址了。按这种算法去处理1000个邮件地址，只需要1100步（1000步读取和100步删除）。 双向链表链表的另一个引人注目的应用，就是作为队列的底层数据结构。第8章我们已经介绍过队列，你应该还记得它就是一种只能在末尾插入元素，在开头删除元素的数据结构。当时我们用数组作为队列的底层，并解释说队列只是有约束条件的数组。其实，改用链表来做队列的底层也可以，同样地，只要使该链表的元素只在末尾插入，并在开头删除就好了。那么用链表来代替数组有什么好处呢？下面来分析一下。 再强调一次，队列插入数据只能在末尾。如上文所述，在数组的末尾插入是极快的，时间复杂度为O(1)。链表则要O(N)。所以在插入方面，选择数组比链表更好。 但到了删除的话，就是链表更快了，因为它只要O(1)，而数组是O(N)。 基于以上分析，似乎用数组还是链表都无所谓。因为它们总有一种操作是O(1)，另一种是O(N)：数组的插入是O(1)，删除是O(N)；链表则反过来，分别是O(N)和O(1)。 然而，要是采用双向链表这一链表的变种，就能使队列的插入和删除都为O(1)。 双向链表跟链表差不多，只是它每个结点都含有两个链--一个指向下一结点，另一个指向前一结点。此外，它还能直接访问第一个和最后一个结点。 以下是一个双向链表。 用代码来表述的话，如下所示。123456789101112131415161718class Node attr_accessor :data, :next_node, :previous_node def initialize(data) @data = data endendclass DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node endend 由于双向链表总会记住第一个和最后一个结点，因此能够一步（以O(1)的时间）访问到它们。 更进一步地，在末尾插入数据也可以一步完成，如下所示。 这里创建了一个新结点（“Sue”），并使其previous_node指向双向链表的last_node(“Greg”)。然后，再将last_node(“Greg”)的next_node指向这个新结点（“Sue”）。最后，把last_node改为新结点（“Sue”）。 以下是在双向链表中实现的新方法insert_at_end 。1234567891011121314151617181920212223class DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node end def insert_at_end(value) new_node = Node.new(value) # 如果链表还没有任何结点 if !first_node @first_node = new_node @last_node = new_node else new_node.previous_node = @last_node @last_node.next_node = new_node @last_node = new_node end endend 因为双向链表能直接访问前端和末端的结点，所以在两端插入的效率都为O(1)，在两端删除的效率也为O(1)。由于在末尾插入和在开头删除都能在O(1)的时间内完成，因此拿双向链表作为队列的底层数据结构就最好不过了。 以下是基于双向链表的队列的完整代码示例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Node attr_accessor :data, :next_node, :previous_node def initialize(data) @data = data endendclass DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node end def insert_at_end(value) new_node = Node.new(value) # 如果链表还没有任何结点 if !first_node @first_node = new_node @last_node = new_node else new_node.previous_node = @last_node @last_node.next_node = new_node @last_node = new_node end end def remove_from_front removed_node = @first_node @first_node = @first_node.next_node return removed_node endendclass Queue attr_accessor :queue def initialize @queue = DoublyLinkedList.new end def enque(value) @queue.insert_at_end(value) end def deque removed_node = @queue.remove_from_front return removed_node.data end def tail return @queue.last_node.data endend 总结尽管目前还没用到队列，或者用了数组但没用双向链表也运行得很好。但是现在，你知道了还有其他选择，也学习了什么时候应该做出什么选择。 你学会了在特定情况下使用链表来改善性能。后面还会介绍更复杂的基于结点的数据结构，它们更常用，并且对性能的提升更大。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章-飞快的递归算法]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%AC%AC10%E7%AB%A0-%E9%A3%9E%E5%BF%AB%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么大多数编程语言都使用快速排序？ 快速排序依赖于一个名为分区的概念。怎么理解？ 本章涵盖： 分区 快速排序 快速排序的效率 最坏情况 快速选择 递归给我们带来了新的算法实现方式，例如上一章的文件系统遍历。本章我们还会看到，递归能使算法效率大大提高。 前几章我们学会了一些排序算法，包括冒泡排序、选择排序和插入排序。但在现实中，数组排序不是通过它们来做的。为了免去大家重复编写排序算法的烦恼，大多数编程语言都自带用于数组排序的函数，其中很多采用的都是快速排序。 虽然它已经实现好了，但我们还是想研究一下它的原理，因为其运用递归来给算法提速的做法极具推广意义。 快速排序真的很快。尽管在最坏情况（数组逆序）下它跟插入排序、选择排序的效率差不多，但在日常多见的平均情况中，它的确表现优异。 快速排序依赖于一个名为分区的概念，所以我们先从它开始了解。 分区此处的分区指的是从数组随机选取一个值，以其为轴，将比它小的值放到它左边，比它大的值放到它右边。分区的算法实现起来很简单，例子如下所示。 假设有一个下面这样的数组。 从技术上来说，选任意值为轴都可以，我们就以数组最右的值为轴吧。现在轴就是3了，我们把它圈起来。 然后放置指针，它们应该分别指向排除轴元素的数组最左和最右的元素。 接着就可以分区了，步骤如下。 (1)左指针逐个格子向右移动，当遇到大于或等于轴的值时，就停下来。 (2)右指针逐个格子向左移动，当遇到小于或等于轴的值时，就停下来。 (3)将两指针所指的值交换位置。 (4)重复上述步骤，直至两指针重合，或左指针移到右指针的右边。 (5)将轴与左指针所指的值交换位置。 当分区完成时，在轴左侧的那些值肯定比轴要小，在轴右侧的那些值肯定比轴要大。因此，轴的位置也就确定了，虽然其他值的位置还没有完全确定。 让我们来把此流程套到示例数组上。 第1步：拿左指针（正指向0）与轴（值为3）比较。 由于0比轴小，左指针可以右移。 第2步：右移左指针。 将左指针（值为5）与轴比较。它比轴小吗？不。于是左指针停在这里，下一步我们启动右指针。 第3步：比较右指针（值为6）和轴。它比轴大吗？对。于是右指针左移。 第4步：左移右指针。 比较右指针（值为1）和轴。它比轴大吗？不。于是右指针停下。 第5步：因为两个指针都停住了，所以交换它们的值。 随后，再次启动左指针。 第6步：右移左指针。 比较左指针（值为2）和轴。它比轴小吗？对。于是继续右移。 第7步：左指针移到下一格子。注意，这时两个指针都指向同一个值了。 比较左指针和轴。由于左指针的值比轴要大，我们将其停在那里。而且现在左指针与右指针重合，无须再移动指针了。 第8步：到了分区的最后一步，将左指针的值与轴交换位置。 虽然数组还没完全排好序，但我们已完成了一次分区。即比轴（值为3）小的值都聚在了它的左侧，比轴大的值都聚在了它的右侧，这就意味着3已经被放置到正确的位置上了。 下面是用Ruby写的SortableArray类，其中的partition!方法能如上所述对数组进行分区。12345678910111213141516171819202122232425262728293031323334353637383940414243class SortableArray attr_reader :array def initialize(array) @array = array end def partition!(left_pointer, right_pointer) # 总是取最右的值作为轴 pivot_position = right_pointer pivot = @array[pivot_position] # 将右指针指向轴左边的一格 right_pointer -= 1 while true do while @array[left_pointer] &lt; pivot do left_pointer += 1 end while @array[right_pointer] &gt; pivot do right_pointer -= 1 end if left_pointer &gt;= right_pointer break else swap(left_pointer, right_pointer) end end # 最后将左指针的值与轴交换 swap(left_pointer, pivot_position) # 根据快速排序的需要，返回左指针 # 具体原因接下来会解释 return left_pointer end def swap(pointer_1, pointer_2) temp_value = @array[pointer_1] @array[pointer_1] = @array[pointer_2] @array[pointer_2] = temp_value endend 此partition!方法接受两个参数作为左指针和右指针的起始位置，并在结束时返回左指针的最终位置。这是实现快速排序所必需的，下面我们将会看到。 快速排序快速排序严重依赖于分区。它的运作方式如下所示。 (1)把数组分区。使轴到正确的位置上去。 (2)对轴左右的两个子数组递归地重复第1、2步，也就是说，两个子数组都各自分区，并形成各自的轴以及由轴分隔的更小的子数组。然后也对这些子数组分区，以此类推。 (3)当分出的子数组长度为0或1时，即达到基准情形，无须进一步操作。 将以下quicksort!方法加到刚才的SortableArray类中，快速排序就完整了。12345678910111213def quicksort!(left_index, right_index) # 基准情形：分出的子数组长度为 0 或 1 if right_index - left_index &lt;= 0 return end # 将数组分成两部分，并返回分隔所用的轴的索引 pivot_position = partition!(left_index, right_index) # 对轴左侧的部分递归调用 quicksort quicksort!(left_index, pivot_position - 1) # 对轴右侧的部分递归调用 quicksort quicksort!(pivot_position + 1, right_index)end 想看实际效果的话，可执行以下代码。1234array = [0, 5, 2, 1, 6, 3]sortable_array = SortableArray.new(array)sortable_array.quicksort!(0, array.length - 1)p sortable_array.array 再回到刚才的例子。最初的数组是[0, 5, 2, 1, 6, 3]，然后我们做了一次分区。所以我们的快速排序已经有一点进度了，目前状态如下。 正如你看到的，其中3为轴。它已经处于正确的位置，接下来对其左右两侧的元素进行排序。 注意，虽然我们看到左侧的元素碰巧已经按顺序排好了，但计算机是不知道的。 下一步，我们把轴左侧的那些元素当作一个独立的数组来分区。 除此之外的元素则先不用看，暂时给它们涂上阴影。 现在，对于这个 [0, 1, 2]的子数组，我们选取其最右端的元素作为轴。于是，轴为 2。 然后，设置左右指针。 让我们接着之前的第 8步，开始子数组的分区。 第9步：比较左指针（值为0）与轴（值为2）。由于0小于轴，可将左指针右移。 第10步：将左指针右移一格，这时它刚好跟右指针重合了。 比较左指针与轴。由于 1小于轴，继续右移。 第11步：将左指针右移一格，它便指向轴了。 这时左指针的值与轴相等了（因为它正指向轴），左指针停下。 第12步：启动右指针。然而，右指针（值为 1）小于轴，所以不用动。 因为左指针已经跑到右指针的右边了，所以本次分区无须再移动指针。 第13步：最后，将左指针的值跟轴交换。但左指针已经指向轴，因此轴与自身交换，结果没有任何改变。至此，分区完成，轴（值为 2）也到达正确位置了。 于是轴（值为 2）分出了左侧的子数组[0, 1]，右侧没有子数组。那么接下来将左侧的[0, 1]分区。 为了专注于 [0, 1] ，我们将其余的元素涂上阴影。 然后选取其最右的元素（值为 1）作为轴。但是左右指针应该如何放置呢？是的，左指针指向0，右指针因为总是从轴左侧那格开始，所以也是指向0，如下所示。 可以开始分区了。 第14步：比较左指针（值为 0）与轴（值为 1）。 它比轴小，继续右移。 第15步：将左指针往右移一格，这时它指向了轴。 由于左指针不再小于轴了（因为它的值就是轴），于是停下。 第16步：比较右指针与轴。由于其值小于轴，就不用再左移了。而且现在左指针走到了右指针的右边，所以指针无须继续移动，可以进入最后一步。 第17步：将左指针与轴交换。但同样地，这次左指针也指向了轴，所以交换不会产生什么位置改变。于是轴的位置便排好了，分区结束。 此时数组如下所示。 接着，对最近一次的轴的左侧子数组 [0] 进行分区。因为它只包含一个元素，到达了“数组长度为0或1”的基准情形，所以我们什么都不用干。该元素已随着之前的分区被挪到了正确的位置。现在数组如下所示。 最开始我们以3为轴，然后把其左侧的子数组[0, 1, 2]做了分区。按照约定，现在轮到了它右侧的[6, 5] 。 [0, 1, 2, 3]已经排好了，所以将它们涂上阴影，以便我们专注于[6, 5] 。 接下来的分区以最右端的元素（值为5）为轴，如下所示。 左右指针只能同时指向6。 第18步：比较左指针（值为6）与轴（值为5）。由于6大于轴，左指针不再右移。 第19步：本来指着6的右指针应该左移，但6的左边已经没有其他元素了，所以右指针停止。由于左指针与右指针重合，也不用再做任何移动了，可以跳到最后一步。 第20步：将左指针的值与轴交换。 这样轴（值为5）就放到正确位置上了，数组变成了下面这样。 尽管随后我们应该递归地对[5, 6]左右两侧的子数组进行分区，但现在轴左侧没有元素，右侧也只有长度为1的子数组，即到达了基准情形--6已自动挪到了正确位置。 于是整个排序完成！ 快速排序的效率为了搞清楚快速排序的效率，我们先从分区开始。分解来看，你会发现它包含两种步骤。 比较：每个值都要与轴做比较。 交换：在适当时候将左右指针所指的两个值交换位置。 一次分区至少有N次比较，即数组的每个值都要与轴做比较。因为每次分区时，左右指针都会从两端开始靠近，直到相遇。 交换的次数则取决于数据的排列情况。一次分区里，交换最少会有1次，最多会有N/2次，因为即使所有元素都需要交换，我们也只是将左半部分与右半部分进行交换，如下图所示。 对于随机排列的数据，粗略来算就是N/2的一半，即N/4次交换。于是，N次比较加上N/4次交换，共1.25N步。最后根据大O记法的规则，忽略常数项，得出分区操作的时间为O(N)。 这就是一次分区的效率。但完整的快速排序需要对多个数组以及不同大小的子数组分区，想知道整个过程所花的时间，还要再进一步分析才行。 为了更形象地描述，我们将一个含有8个元素的数组的快速排序过程画了出来。它旁边有每一次分区所作用的元素个数。由于元素值并不重要，因此就不显示了。注意，作用范围就是那些白色的格子。 这里有8次分区，但每次作用的范围大小不一。因为只含1个元素的子数组就是基准情形，无须任何交换和比较，所以只有元素量大于或等于2的子数组才要算分区。 由于此例属于平均情况的一种，因此我们假设每次分区大约要花1.25N步，得出：1234 8 个元素 * 1.25 = 10 步 3 个元素 * 1.25 = 3.75 步 4 个元素 * 1.25 = 5 步+ 2 个元素 * 1.25 = 2.5 步 总共约为21步 如果再对不同大小的数组做统计，你会发现N个元素，就要N×log N步。想体会什么是N log N的话，可参考下表。 N log N N×log N 4 2 8 8 3 24 16 4 64 在上面一个数组含8个元素的例子中，快速排序花了大约21步，也很接近8×log8（等于 24）。这种时间复杂度的算法我们还是第一次遇到，用大O记法来表达的话，它是O(N log N)算法。 快速排序的步数接近N×log N绝非偶然。如果我们以更平均的情况来考察快速排序，就能看出原因了。 快速排序开始时会对整个数组进行分区。假设此次分区会将轴最终安放到数组中央--这也是平均情况--然后我们就要对由此切开的两半进行分区。巧合的是，它们的轴也最终落在各自的中央，分出4个大小为原数组四分之一的子数组。并且，接下来所有分区都出现了这种轴在中央的情况。 这样一来，我们基本上就是在不断地对半切分子数组，直至产生出的子数组长度为1。那么，一个数组要经历多少次分区才能切到这么小呢？如果数组元素有N个，那就是log N次。假设元素有8个，那就要对半切3次，才能分出只有1个元素的子数组。这个原理你应该在二分查找那节学过了。 对两个新的子数组所执行的分区操作，需要处理的数据量还是相当于对原数组所做的分区。如下图所示。 因为等分发生了log N次，而每次都要对总共N个元素做分区，所以总步数为N×log N。 之前我们看到的很多算法，最佳情况都发生在元素有序的时候。但在快速排序里，最佳情况应该是每次分区后轴都刚好落在子数组的中间。 最坏情况快速排序最坏的情况就是每次分区都使轴落在数组的开头或结尾。导致这种情况的原因有好几种，包括数组已升序排列，或已降序排列。下面我们把这种情况用图来说明一下。 虽然在此情况下，每次分区都只有一次交换，但比较的次数却变得很多。在轴总落在中央的例子里，每次分区都能划分出比原数组小得多的子数组（过程中产生的最大的子数组长度为4），使各部分都能很快地到达基准情形。然而如果轴落在其中一端，前5次分区就需要处理长度大于4的数组。而且这5次分区里，每次所需的比较次数还是和子数组的元素量一样多。 于是在最坏情况下，对8 + 7 + 6 + 5 + 4 + 3 + 2个元素进行分区，一共35次比较。 写成公式的话，就是N个元素，需要N + (N - 1) + (N - 2) + (N - 3) + … + 2步，即N2/ 2步，如下图所示。 又因为大O忽略常数，所以最终我们会说，快速排序最坏情况下的效率为O(N2)。 既然把快速排序分析完了，我们将它与插入排序比较一下。 最好情况 平均情况 最坏情况 插入排序 O(N) O(N2) O(N2) 快速排序 O(N log N) O(N log N) O(N2) 虽然快速排序在最好情况和最坏情况都没能超越插入排序，但在最常遇见的平均情况，前者的O(N log N)比后者的O(N2)好得多，所以总体来说，快速排序优于插入排序。 以下是各种时间复杂度的对比。 由于快速排序在平均情况下表现优异，于是很多编程语言自带的排序函数都采用它来实现。因此一般你不需要自己写快速排序。但你可能需要学会写快速选择--它是一种类似快速排序的实用算法。 快速选择假设有一个无序的数组，你不需要将它排序，只要找出里面第10小的值，或第5大的值。就像从一堆测试成绩中找出第25百分位，或找出中等成绩那样。 你首先想到的，可能是把整个数组排序，然后再跳到对应的格子里去找。 但这样做的话，即使是用快速排序那样高效的算法，一般也需要O(N log N)。虽然这也不算差，但一种名为快速选择的算法可以做得更好。快速选择需要对数组分区，这跟快速排序类似，或者你可以把它想象成是快速排序和二分查找的结合。 如之前所述，分区的作用就是把轴排到正确的格子上。快速选择就利用了这一点。 例如要在一个长度为8的数组里，找出第2小的值。 先对整个数组分区。 轴很可能落到数组中间某个地方。 现在轴已安放在正确位置了，因为那是第5个格子，所以我们掌握了数组第5小的值是什么。虽然我们要找的是第2小的值，但刚才的操作足以让我们忽略轴右侧的那些元素，将查找范围缩小到轴左侧的子数组上。这看起来就像是不断地把查找范围缩小一半的二分查找。 然后，继续对轴左侧的子数组分区。 假设子数组的轴最后落到第3个格子上。 现在第3个格子的值已经确定了，该值就是数组第3小的值，第2小的值也就是它左侧的某个元素。于是再对它左侧的元素分区。 这次分区过后，最小和第 2小的元素也就能确定了。 这么一来，我们就可以拿出第2个格子的值，告诉别人找到第2小的元素了。快速选择的优势就在于它不需要把整个数组都排序就可以找到正确位置的值。 如果像快速排序那样，每次分区后还是要处理原数组那么多的数据，就会导致O(N log N)的步数。但快速选择不同，下一次的分区操作只需在上一次分出的一半区域上进行，即值可能存在的那一半。 分析快速选择的效率，你会发现它的平均情况是O(N)。回想每次分区的步数大约等于作用数组的元素量，你便可算出，对于一个含有 8个元素的数组，会有3次分区：第一次处理整个数组的8个元素，第二次处理子数组的4个元素，还有一次处理更小的子数组的2个元素。加起来就是8 + 4 + 2 = 14步。于是8个元素大概是14步。 如果是64个元素，就会是64 + 32 + 16 + 8 + 4 + 2 = 126步；如果是128个元素，就会是254步；如果是256个元素，就会是510步。 用公式来表达，就是对于N个元素，会有N + (N / 2) + (N / 4) + (N / 8) + … + 2步。结果大概是2N步。由于大O忽略常数，我们最终会说快速选择的效率为O(N)。 你可以把以下实现了快速选择的quickselect!方法加到刚才的SortableArray里。你会发现它跟quicksort!很像。1234567891011121314151617181920def quickselect!(kth_lowest_value, left_index, right_index) # 当子数组只剩一个格子——即达到基准情形时， # 那我们就找到所需的值了 if right_index - left_index &lt;= 0 return @array[left_index] end # 将数组分成两部分，并返回分隔所用的轴的索引 pivot_position = partition!(left_index, right_index) if kth_lowest_value &lt; pivot_position quickselect!(kth_lowest_value, left_index, pivot_position - 1) elsif kth_lowest_value &gt; pivot_position quickselect!(kth_lowest_value, pivot_position + 1, right_index) else # 至此 kth_lowest_value 只会等于 pivot_position # 如果分区后返回的轴的索引等于 kth_lowest_value， # 那这个轴就是我们要找的值 return @array[pivot_position] endend 想要从一个无序数组中找出第2小的值，可以运行如下代码。123array = [0, 50, 20, 10, 60, 30]sortable_array = SortableArray.new(array)p sortable_array.quickselect!(1, 0, array.length - 1) 此方法的第一个参数是查找的位置。因为数组索引从0开始算起，所以我们传入1来查找第2小的值。 总结由于运用了递归，快速排序和快速选择可以将棘手的问题解决得既巧妙又高效。这也提醒了我们，有些看上去很普通的算法，可能是经过反复推敲的高性能解法。 其实能递归的不只有算法，还有数据结构。后面几章将要接触的链表、二叉树以及图，就利用了自身递归的特性，给我们提供了迅速的数据操作方式。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章-递归]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%AC%AC9%E7%AB%A0-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是递归？递归适用于什么场景？ 几乎所有循环都能够转换成递归怎么理解？ 什么是基准情形？ 如何阅读递归代码？ 什么是调用栈？递归发生时内存是怎么处理的？ 计算机处理3的阶乘的过程是什么样的？ 什么是栈溢出，为什么会发生？ 本章涵盖： 用递归代替循环 基准情形 阅读递归代码 计算机眼中的递归 递归实战 总结 在学习本书其余算法之前，你得先学会递归。解决很多看似复杂的问题时，如果从递归的角度去思考，会出人意料地简单，而且代码量还会大大减少。 不过，我们先做一个突击测试！ 运行一个定义如下的blah()函数，会发生什么？1234function blah() &#123; blah();&#125; 正如你所想的，blah()会调用blah()，后者也会调用blah()，于是就这样无限地调用下去。 函数调用自身，就叫作递归。无限递归用处不大，甚至还挺危险，但是有限的递归很强大。掌控好递归能帮助我们解决某些棘手的问题，我很快就会证明给你看。 用递归代替循环假设在NASA工作的你，需要写一个用于发射飞船的倒数程序。该程序接收一个数字，例如10，然后显示从10到0的数字。现在先暂停一下，选择一门编程语言来实现这个程序，做完以后，再往下阅读。 或许你用了JavaScript，并且写了如下循环。12345678function countdown(number) &#123; for(var i = number; i &gt;= 0; i--) &#123; console.log(i); &#125;&#125;countdown(10); 这样写没什么问题，只是你可能没想到循环以外的做法。 那还能怎么做呢？ 试试换成递归吧。以下是初级版的递归countdown 。123456function countdown(number) &#123; console.log(number); countdown(number - 1);&#125;countdown(10) 让我们一步步来分析。 第1步：调用countdown(10)，因此参数number为 10。 第2步：将number（值为10）打印到控制台。 第3步：countdown函数在结束前，调用了countdown(9)（因为number - 1等于 9）。 第4步：countdown(9)被执行，会将number（值为9）打印到控制台。 第5步：countdown(9)结束前，调用了countdown(8) 。 第6步：countdown(8)被执行，会将number（值为8）打印到控制台。 在继续步骤分解之前，先回顾下该递归是怎样实现我们的需求的。countdown里并没有任何循环结构，它通过调用自身就能够从10开始倒数并将每个数字打印出来。 几乎所有循环都能够转换成递归。但能用不代表该用。递归的强项在于巧妙地解决问题，但在上面的例子中，它并不比普通的循环更加优雅、高效。我们很快就会看到能让递归发挥威力的场景，但在那之前，还是先理清递归的运作方式。 基准情形让我们把countdown函数继续下去。为了简洁一点，我们跳过一些步骤。 第21步：调用countdown(0) 。 第22步：将number（值为0）打印到控制台。 第23步：调用countdown(-1) 。 第24步：将number（值为1）打印到控制台。 糟了，你也看到了，这种写法不够完善，这样下去我们就会不断地打印负数。 要解决这个问题，得在数到0时就停住，以免递归一直往下数。 我们可以加个条件判断，来保证当number为0时，不再调用countdown()。12345678910111213function countdown(number) &#123; console.log(number); if(number === 0) &#123; return; &#125; else &#123; countdown(number - 1); &#125;&#125;countdown(10); 这样，当number为0时，我们的代码就不会再去调用countdown()，而是直接返回。 在递归领域（真有这么一个地方），不再递归的情形称为基准情形。对于刚才的countdown()函数来说，0就是基准情形。 阅读递归代码递归是需要时间和练习才能适应的，到那时候，你会掌握两种技巧：阅读递归代码和编写递归代码。阅读递归代码相对简单一点，所以就先从这里入手吧。 我们会以阶乘作为例子。阶乘的演示如下所示。 3的阶乘是：3 2 1 = 6 5的阶乘是：5 4 3 2 1 = 120 以此类推。以下Ruby代码会以递归计算的方式返回一个数的阶乘。1234567def factorial(number) if number == 1 return 1 else return number * factorial(number - 1) endend 此代码初看可能会让人有点困惑，可以按照以下流程来读。 (1) 找出基准情形。 (2) 看该函数在基准情形下会做什么。 (3) 看该函数在到达基准情形的前一步会做什么。 (4) 就这样往前推，看每一步都在做什么。 让我们将此流程应用到刚才的代码上。稍作分析，就可以看出里面有两条路径。12345if number == 1 return 1else return number * factorial(number - 1)end 第二条路的factorial有调用自身，是递归发生的地方。123else return number * factorial(number - 1)end 第一条路并没有调用自身，因此这里是基准情形。12if number == 1 return 1 于是，number为1时，是基准情形。 接着，想象factorial方法在基准情形下，即factorial(1) 的处理流程。其相关代码如下。12if number == 1 return 1 好，这很简单，因为是基准情形，所以没有递归。调用factorial(1)就会直接返回1。于是找来一张纸，记下该结果。 然后，回到上一步的factorial(2)，相关代码如下。123else return number * factorial(number - 1)end 调用factorial(2)就会返回2 factorial(1) 。要计算2 factorial(1)，就得先知道factorial(1)的结果。要是检查下前面所记，你会发现那是1。因此，2 factorial(1)就是2 1 ，即是2。 把这个也记到纸上。 那么，factorial(3)又会是什么呢？再回看代码。123else return number * factorial(number - 1)end 代入参数便是3 factorial(2) 。那么factorial(2)是什么呢？你不用从头计算，因为它的结果已经写在纸上了，是2。于是factorial(3)会返回 6（3 2 = 6）。将结果记下，然后继续。 现在请自行计算factorial(4) 。 如你所见，这种从基准情形入手再往上分析的思路，对理解递归代码是多么有益。 事实上，此方法不仅为人类所利用，计算机也差不多是这样做的。下面就来看看。 计算机眼中的递归细想一下我们的factorial方法，你会发觉当factorial(3)执行时，会有如下事情发生。 计算机调用factorial(3)，并在该方法返回前，调用了factorial(2)，而在factorial(2)返回前，又调用了factorial(1)。从技术上来说，当计算机执行factorial(1)时，它其实还在factorial(2)之中，而factorial(2)又正在factorial(3)之中。 计算机是用栈来记录每个调用中的函数。这个栈就叫作调用栈。 让我们以factorial为例来观察调用栈如何运作。 起初计算机调用的是factorial(3)。然而，在该方法完成之前，它又调用了factorial(2)。为了记住自己还在factorial(3)中，计算机将此事压入调用栈中。 接着计算机开始处理factorial(2)。该factorial(2)会调用factorial(1)。不过在进入factorial(1)前，计算机得记住自己还在factorial(2)中，于是，它将此事也压入调用栈中。 然后计算机执行factorial(1)。因为1已经是基准情形了，所以它可以返回，不用再调用factorial。 尽管factorial(1)结束了，但调用栈内仍存在数据，意味着整件事还没完，计算机还处于其他函数当中。你应该还记得，栈的规定是只有栈顶元素（即最后的元素）才能被看到。所以，计算机接下来就去检查了调用栈的栈顶，发现那是factorial(2)。 由于factorial(2)是调用栈的最后一项，因此代表最近调用并且最应该先完成的是factorial(2)。 于是计算机将factorial(2)从调用栈弹出。 并将其结束。 然后计算机再次检查调用栈，看下一步应该结束哪个方法。调用栈如下所示。 于是计算机将factorial(3)从调用栈弹出，并将其结束。 到这里，调用栈就清空了，计算机也因此得知所有方法都执行完了，递归结束。 从更高的角度去看，可以看出计算机处理3的阶乘时，步骤如下。 (1)factorial(3)被第一个调用。 (2)factorial(2)被第二个调用。 (3)factorial(1)被第三个调用。 (4)factorial(1)被第一个完成。 (5)factorial(2)在factorial(1)的基础上完成。 (6)最后，factorial(3)在factorial(2)的基础上完成。 有趣的是，无限递归（如本章开头的例子）的程序会一直将同一方法加到调用栈上，直到计算机的内存空间不足，最终导致栈溢出的错误。 递归实战虽然上面的NASA倒数程序和阶乘计算能用递归来解决，但用普通的循环来做也不难。除了好玩以外，递归在这些问题上没体现出什么优势。 事实上，递归可以自然地用于实现那些需要重复自身的算法。在这些情况下，递归可以增强代码的可读性，你接下来就会看到。 比如说遍历文件系统。假设你现在要写一个脚本，它用于对一个目录下的所有文件进行某种操作。这里的“所有文件”，不仅指的是该目录中的文件，还包括其子目录的文件，以及子目录里的子目录的文件，以此类推。 我们先用Ruby写一个打印某目录下所有子目录名字的脚本。123456789def find_directories(directory) Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") 此脚本遍历给定目录下的所有文件。当遇到的某个文件为子目录时（即文件类型为目录，但又不是代表“当前目录”“上级目录”的句号和双句号的那些文件），将其名字打印出来。 虽然这跑起来没问题，但它只打印了当前目录的直属子目录的名字，并没有打印出那些子目录的子目录的名字。 接着我们改进一下，使该脚本能再深入到下一层目录。1234567891011121314151617def find_directories(directory) # 遍历给定目录下的文件 Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" # 遍历其子目录下的文件 Dir.foreach("#&#123;directory&#125;/#&#123;filename&#125;") do |inner_filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;/#&#123;inner_filename&#125;") &amp;&amp;inner_filename != "." &amp;&amp; inner_filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;/#&#123;inner_filename&#125;" end end end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") 这样，我们就可以对每个子目录再发起另一个循环去遍历其中的孙子目录了。不过，它只能进到两层目录的深度而已。如果我们还想进到第三层、第四层、第五层，甚至最底层，那要怎么做呢？以目前的思路似乎不可能实现。 这就是递归出马的时候了。使用递归的话，我们可以写一个进入任意深度的脚本，而且很简洁！1234567891011def find_directories(directory) Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" find_directories("#&#123;directory&#125;/#&#123;filename&#125;") end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") find_directories会对所遇到的每个子目录再调用find_directories 。这样一来，所有子目录都会被挖出来，没有一个会漏掉。 此算法如下图所示，其中的号码代表目录被访问的顺序。 注意，改用递归并不会改变算法的大O。但是，在下一章你会看到，递归可以作为算法的核心组件，影响算法的速度。 总结正如文件系统的例子所示，递归十分适用于那些无法预估计算深度的问题。 掌握递归，你就解锁了一批高效但更为高深的算法。它们都离不开递归的原理。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章-用栈和队列来构造灵巧的代码]]></title>
    <url>%2F2018%2F06%2F05%2F%E7%AC%AC8%E7%AB%A0-%E7%94%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%9D%A5%E6%9E%84%E9%80%A0%E7%81%B5%E5%B7%A7%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么栈和队列都是处理临时数据的灵活工具？ 栈的数据结构是什么样的？应用场景有哪些？ 队列的数据结构是什么样的？应用场景有哪些？ 本章涵盖： 栈 栈实战 队列 队列实战 迄今为止，我们对数据结构的讨论都集中于它们在各种操作上表现出的性能。但其实，掌握多种数据结构还有助于简化代码，提高可读性。 本章你将会学习两种新的数据结构：栈和队列。事实上它们并不是全新的东西，只不过是多加了一些约束条件的数组而已。但正是这些约束条件为它们赋予了巧妙的用法。 具体一点说，栈和队列都是处理临时数据的灵活工具。在操作系统、打印任务、数据遍历等各种需要临时容器才能构造出美妙算法的场景，它们都大有作为。 处理临时数据就像是点餐。在菜做好并送到客人手上之前，订单是有用的，但过后，你无须保留那张订单。临时数据就是一些处理完便不再有用的信息，因此没有保留的必要。此外，就像出菜时应先出给早下单的客人，你可能还得注意数据按什么顺序去处理。栈和队列就正好能把数据按顺序处理，并在处理完成后将其抛弃。 栈栈存储数据的方式跟数组一样，都是将元素排成一行。只不过它还有以下 3条约束。 只能在末尾插入数据。 只能读取末尾的数据。 只能移除末尾的数据。 你可以将栈看成一叠碟子：你只能看到最顶端那只碟子的碟面，其他都看不到。另外，要加碟子只能往上加，不能往中间塞，要拿碟子只能从上面拿，不能从中间拿（至少你不应该这么做）。绝大部分计算机科学家都把栈的末尾称为栈顶，把栈的开头称为栈底。 尽管这些约束看上去令人很拘束，但很快你就会发现它们带来的好处。 我们先从一个空栈开始演示。 往栈里插入数据，也叫作压栈。你可以想象把一个碟子压在其他碟子上的画面。 首先，将5压入栈中。 这没什么特别的，就如往数组插入数据一样平常。 接着，将3压入栈中。 再将0压入栈中。 注意，每次压栈都是把数据加到栈顶（也就是栈的末尾）。如果想把0插入到栈底或中间，那是不允许的，因为这就是栈的特性：只能在末尾插入数据。 从栈顶移除数据叫作出栈。这也是栈的限制：只能移除末尾的数据。 来把栈中的一些数据弹出。 首先，弹出0。 现在剩下两个元素，5和3。 接着，弹出3。 这就剩下5了。 压栈和出栈可被形容为LIFO（last in，first out）后进先出。解释起来就是最后入栈的元素，会最先出栈。就像无心向学的学生，最迟到校的总是他，最早回家的也是他。 栈实战栈很少用于需要长期保留数据的场景，却常用于各种处理临时数据的算法。 下面我们来写一个初级的JavaScript分析器--一种用来检查JavaScript代码的语法是否正确的工具。因为JavaScript的语法规则很多，所以它可以做得很复杂。简单起见，我们就只专注于检查括号的闭合情况吧，包括圆括号、方括号、花括号，这些地方搞错的话是很令人郁闷的。 在写之前，先分析一下括号的语法错误会有哪些情况。分类就是以下3种。 首先是有左括号没有右括号的情况。1(var x = 2; 这种归为第1类。 接着是没有左括号但有右括号的情况。1var x = 2;) 这种归为第2类。 还有第3类，右括号类型与其前面最近的左括号不匹配，例如：1(var x = [1, 2, 3)]; 此例中，虽然圆括号和方括号都左右成对出现，但位置不对，右圆括号前面最近的竟是左方括号。 那么怎样才能实现一种能检查一行代码里括号写得对不对的算法呢？用栈就好办了。 先准备一个空栈，然后从左至右读取代码的每一个字符，并执行以下规则。 (1) 如果读到的字符不是任一种括号（圆括号、方括号、花括号），就忽略它，继续下一个。 (2) 如果读到左括号，就将其压入栈中，意味着后面需要有对应的右括号来做闭合。 (3) 如果读到右括号，就查看栈顶的元素，并做如下分析。 如果栈里没有任何元素，也就是遇到了右括号但没有左括号，即第2类语法错误。 如果栈里有数据，但与刚才读到的右括号类型不匹配，那就是第3类语法错误。 如果栈顶元素是匹配的左括号，则表示它已经闭合。那么就可以将其弹出，因为已经不需要再记住它了。(4) 如果一行代码读完，栈里还留有数据，那就表示存在左括号，没有右括号与之匹配，即第1类语法错误。 让我们用以下代码作为例子来演示一遍。 备好一个空栈之后，就可以开始从左至右读取代码的每个字符了。 第1步：首先是第一个字符，它是一个左圆括号。 第2步：因为它是一个左括号，所以将其压入栈中。 接下来的var x = ，没有一个是括号，因此会被忽略。 第3步：遇到一个左花括号。 第4步：将其压入栈中。 然后忽略y:。 第5步：遇到一个左方括号。 第6步：同样把它压入栈中。 然后忽略1, 2, 3 。 第7步：这时我们第一次看到了右括号，是一个右方括号。 第8步：于是检查栈顶的元素，发现那是一个左方括号。因为刚才读到的右方括号能与其配对，所以将左方括号弹出。 第9步：继续，下一个读到的是右花括号。 第10步：检查栈里的最后一个元素，刚好是可以配对的左花括号。于是将其弹出。 第11步：读到一个右圆括号。 第12步：检查栈里的最后一个元素，刚好是可以配对的左圆括号。于是将其弹出，剩下一个空栈。 至此，代码读完了，栈也空着，所以我们的分析器可以定论，这段代码在括号方面没有语法错误。 以下是上述算法的Ruby实现。Ruby的数组自带push和pop方法，是在数组结尾插入和删除元素的便捷调用。只使用这两个方法的话，数组便形同于栈。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Linter attr_reader :error def initialize # 用一个普通的数组来当作栈 @stack = [] end def lint(text) # 循环读取文本的每个字符 text.each_char.with_index do |char, index| if opening_brace?(char) # 如果读到左括号，则将其压入栈中 @stack.push(char) elsif closing_brace?(char) if closes_most_recent_opening_brace?(char) # 如果读到右括号，并且它与栈顶的左括号匹配， # 则将栈顶弹出 @stack.pop else # 如果读到右括号，但它与栈顶的左括号不匹配 @error = "Incorrect closing brace: #&#123;char&#125; at index #&#123;index&#125;" return end end end if @stack.any? # 如果读完所有字符后栈不为空，就表示文中存在着没有相应右括号的左括号 @error = "#&#123;@stack.last&#125; does not have a closing brace" end end private def opening_brace?(char) ["(", "[", "&#123;"].include?(char) end def closing_brace?(char) [")", "]", "&#125;"].include?(char) end def opening_brace_of(char) &#123;")" =&gt; "(", "]" =&gt; "[", "&#125;" =&gt; "&#123;"&#125;[char] end def most_recent_opening_brace @stack.last end def closes_most_recent_opening_brace?(char) opening_brace_of(char) == most_recent_opening_brace endend 如果这样使用的话：123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] &#125; )")puts linter.error 因为该段代码语法正确，所以不会有错误信息打印出来。然而，要是不小心调转了最后两个字符：123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] ) &#125;")puts linter.error 就会出现以下信息。1Incorrect closing brace: ) at index 25 如果丢掉最后那个右括号：123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] &#125;")puts linter.error 就会出现如下的报错。1( does not have a closing brace 在刚才的例子中，栈被巧妙地用来跟踪那些还没有配对的左括号。到了下一章，我们会类似地用栈去跟踪函数的调用，那也是递归的核心思想。 当数据的处理顺序要与接收顺序相反时（LIFO），用栈就对了。像文字处理器的“撤销”动作，或网络应用程序的函数调用，你应该都会需要栈来实现。 队列队列对于临时数据的处理也十分有趣，它跟栈一样都是有约束条件的数组。区别在于我们想要按什么顺序去处理数据，而这个顺序当然是要取决于具体的应用场景。 你可以将队列想象成是电影院排队。排在最前面的人会最先离队进入影院。套用到队列上，就是首先加入队列的，将会首先从队列移出。因此计算机科学家都用缩写“FIFO”（first in, first out）先进先出，来形容它。 与栈类似，队列也有3个限制（但内容不同）。 只能在末尾插入数据（这跟栈一样）。 只能读取开头的数据（这跟栈相反）。 只能移除开头的数据（这也跟栈相反）。 下面来看看它是怎么运作的，先准备一个空队列。 首先，插入5（虽然栈的插入就叫压栈，但队列的插入却没有固定的叫法，一般可以叫放入、加入、入队）。 然后，插入9。 接着，插入100。 目前为止，队列表现得还跟栈一样，但要是移除数据的话，就会跟栈反着来了，因为队列是从开头移除数据的。 想移除数据，得先从5开始，因为开头就是它。 接着，移除9。 这样一来，队列就只剩下100了。 队列实战队列应用广泛，从打印机的作业设置，到网络应用程序的后台任务，都有队列的存在。 假设你正在用Ruby编写一个简单的打印机接口，以接收网络上不同计算机的打印任务。利用Ruby数组的push 方法，将数据加到数组末尾，以及 shift方法，将数据从数组开头移除。 你可以这样来编写接口类。123456789101112131415161718192021class PrintManager def initialize @queue = [] end def queue_print_job(document) @queue.push(document) end def run while @queue.any? # Ruby 的 shift 方法可移出并返回数组的第一个元素 print(@queue.shift) end end private def print(document) # 让打印机去打印文档（为了演示，暂时先打到终端上） puts document endend 然后这样使用它。12345print_manager = PrintManager.newprint_manager.queue_print_job("First Document")print_manager.queue_print_job("Second Document")print_manager.queue_print_job("Third Document")print_manager.run 接着打印机就会按3份文档的接收顺序来把它们打印出来。123First DocumentSecond DocumentThird Document 尽管这个例子把打印机的工作方式写得很抽象，简化了细节，但其中对队列基本用法的描述是真实的，以此为基础去构建真正的打印系统是可行的。 队列也是处理异步请求的理想工具--它能保证请求按接收的顺序来执行。此外，它也常用于模拟现实世界中需要有序处理事情的场景，例如飞机排队起飞、病人排队看医生。 总结如你所见，栈和队列是能巧妙解决各种现实问题的编程工具。 掌握了栈和队列，就解锁出了下一个目标：学习基于栈的递归。递归也是其他高级算法的基础，我们将会在本书余下的部分讲解它们。 数组与数据结构 在强类型编程语言中，有专用的数据结构解决方案。通常是创建一个容器，在这个容器中可以存储任意类型的数据，并且可以根据容器中存储的数据决定容器的容量，达到可以变长的容器结构，比如链表、堆栈和队列等都是数据结构中常用的形式。在PHP中，通常都是使用数组来完成其它语言使用数据结构才能完成的工作。它是弱类型语言，在同一个数组中就可以存储多种类型的数据，而且php中的数组没有长度限制，数组存储数据的容量还可以根据里面元素个数的增减自动调整。 1、使用数组实现堆栈 堆栈是数据结构的一种实现形式，数据存储时采用“先进后出”的数据结构。在php中，将数组当作一个栈使用array_push()和array_pop()两个函数即可完成数据的进栈和出栈操作。12--&gt;array_push():将一个或多个单元压入数组末尾（入栈），然后返回新组的长度。--&gt;array_pop():将数组最有一个单元弹出数组（出栈） 2、使用数组实现队列 队列是数据结构的一种实现形式，数据存储时采用“先进先出”的数据结构。在php中，将数组当作一个栈使用array_push()和array_shift()两个函数即可完成数据的队列操作。12--&gt;array_shift():将数组开头的单元移出数组，然后返回被删元素值。--&gt;array_shift():在数组开头插入一个或多个单元]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章-查找迅速的散列表]]></title>
    <url>%2F2018%2F06%2F02%2F%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE%E8%BF%85%E9%80%9F%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 散列表是一种什么数据结构？优势在哪里？ 为什么查找值只要一步？ 什么是散列？什么是散列函数？ 散列函数需要满足什么条件？ 散列表是如何存储数据的？为什么会产生冲突？ 分离链接法是怎么解决冲突的？ 散列表的效率取决于什么因素？ 什么是负载因子？理想的负载因子是多少？ 本章涵盖： 探索散列表 用散列函数来做散列 一个好玩又赚钱的同义词典 处理冲突 找到平衡 一个实例 总结 试想你在写一个快餐店的点单程序，准备实现一个展示各种食物及相应价格的菜单。你可能会用数组来做（当然这没问题）。1menu = [ ["french fries", 0.75], ["hamburger", 2.5], ["hot dog", 1.5], ["soda", 0.6] ] 该数组由一些子数组构成，每个子数组包含两个元素。第一个元素是表示食物名称的字符串，第二个元素是该食物的价格。 就如第2章学到的，在无序的数组里查找某种食物的价格，得用线性查找，需要O(N)步。 有序数组则可以用二分查找，只需要O(log N)步。 尽管O(log N)也不错，但我们可以做得更好。事实上，可以好很多。到了本章结尾，你会掌握一种名为散列表的数据结构，只用O(1)步就能找出数据。理解此数据结构的原理以及其适用场景，你就能依靠其快速查找的能力来应对各种状况。 探索散列表大多数编程语言都自带散列表这种能够快速读取的数据结构。但在不同的语言中，它有不同的名字，除了散列表，还有散列、映射、散列映射、字典、关联数组。散列就是hash。 以下便是用Ruby的散列表来实现的菜单。1menu = &#123; "french fries" =&gt; 0.75, "hamburger" =&gt; 2.5, "hot dog" =&gt; 1.5, "soda" =&gt; 0.6 &#125; 散列表由一对对的数据组成。一对数据里，一个叫作键，另一个叫作值。键和值应该具有某种意义上的关系。如上例，”french fries”是键，0.75是值，把它们组成一对就表示“炸薯条的价格为75美分”。 在Ruby中，查找一个键所对应的值，语法是：1menu["french fries"] 这会返回值0.75。 在散列表中查找值的平均效率为O(1)，因为只要一步。下面来看看为什么。 用散列函数来做散列还记得你小时候创建和解析密文时用的密码吗？ 例如以下这种字母和数字的简单转化方式。12345A = 1B = 2C = 3D = 4E = 5 以此类推。 由此可得，ACE会转化为135，CAB会转化为312，DAB会转化为412，BAD会转化为214。 将字符串转为数字串的过程就是散列，其中用于对照的密码，就是散列函数。 当然散列函数不只是这一种，例如对各字母匹配的数字求和的过程，也可以作为散列函数。 按此函数来做的话，BAD就是7，过程如下。 第1步：BAD转成214。 第2步：把每一位数字相加，2 + 1 + 4 = 7。 散列函数也可以是对各字母匹配的数字求积的过程。这样的话，BAD就会得出8。 第1步：BAD转成214。 第2步：把每一位数字相乘，2 × 1 × 4 = 8。 本章剩余部分将会采用最后一种散列函数。虽然现实世界中的散列函数比这复杂得多，但以简单的乘法函数为例会比较易懂。 一个散列函数需满足以下条件才有效：每次对同一字符串调用该散列函数，返回的都应是同一数字串。如果每次都返回不一样的结果，那就无效。 例如，计算过程中使用随机数或当前时间的函数就不是有效的散列函数。这种函数会将BAD一下转成12，一下又转成106。 我们刚才的乘法函数就只会把BAD转成8。因为B总是2，A总是1，D总是4，2 × 1 × 4总会是8，不可能有其他输出。 注意，经由此函数转换，DAB也会得到8，跟BAD一样。这确实会带来一些问题，我们之后会说明。 认识了散列函数，就可以进一步学习散列表的运作了。 一个好玩又赚钱的同义词典假设工作之余，你还一个人秘密研发着一款将要征服世界的软件。那是一个同义词典，它叫Quickasaurus。你相信它势必一鸣惊人，因为它只会返回一个最常用的同义词，而不是像其他词典那样，返回所有的同义词。 因为每个词都有一个同义词，所以正好作为散列表的用例。毕竟，散列表就是一堆成对的元素。下面我们马上来开发。 该词典可以用一个散列表来表示。1thesaurus = &#123;&#125; 散列表可以看成是一行能够存储数据的格子，就像数组那样。每个格子都有对应的编号，如下所示。 现在往散列表里加入我们的第一条同义词。1thesaurus["bad"] = "evil" 散列表变成了下面这样。1&#123;"bad" =&gt; "evil"&#125; 再看看散列表是如何存储数据的。 首先，计算机用散列函数对键进行计算。为了方便演示，这里我们依然使用之前提及的那个乘法函数。1BAD = 2 * 1 * 4 = 8 “bad”的散列值为8，于是计算机将”evil”放到第8个格子里。 接着，我们再试另一对键值。1thesaurus["cab"] = "taxi" 同样地，计算机要计算散列值。1CAB = 3 * 1 * 2 = 6 因其结果为6，所以将”taxi”放到第6格。 再多加一对试试。1thesaurus["ace"] = "star" ACE的散列值为15（ACE = 1 × 3 × 5 = 15），于是”star”被放到第15格。 现在，用代码来表示这个散列表的话，就是这样：1&#123;"bad" =&gt; "evil", "cab" =&gt; "taxi", "ace" =&gt; "star"&#125; 既然散列表词典建好了，那就来看看从里面查词时会发生什么吧。假设现在要查”bad”的同义词，写成代码的话，如下所示。1thesaurus["bad"] 收到命令后，计算机就会进行如下两步简单的操作。 (1)计算这个键的散列值：BAD = 2 × 1 × 4 = 8。 (2)由于结果是 8，因此去到第8格并返回其中的值。在本例中，该值为 “evil” 。 这下你应该明白为什么从散列表里读取数据只需O(1)了吧，因为其过程所花的时间是恒定的。它总是先计算出键的散列值，然后根据散列值跳到对应的格子去。 现在总算理解为什么我们的快餐店菜单用散列表会比用数组要快了。当要查询某种食物的价格时，如果是用数组，那么就得一个格子一个格子地去找，直至找到为止。无序数组需要O(N)，有序数组需要O(log N)。但用散列表的话，我们就能够以食物作为键来做O(1)的查找。这就是散列表的好处。 处理冲突不过，散列表也会带来一些麻烦。 继续同义词典的例子：把下面这条同义词也加到表里，会发生什么呢？1thesaurus["dab"] = "pat" 首先，计算散列值。1DAB = 4 * 1 * 2 = 8 然后，将”pat”放进第8个格子。 噢，第8格已经是”evil”了，这的确不好（evil）。 往已被占用的格子里放东西，会造成冲突。幸好，我们有解决办法。 一种经典的做法就是分离链接。当冲突发生时，我们不是将值放到格子里，而是放到该格子所关联的数组里。 现在仔细观察该散列表的冲突位置。 因为要放入”pat”的第8格，已经存在”evil”了，于是我们将第8格的内容换成一个数组。 该数组又以子数组构成，每个子数组含两个元素，第一个是被检索的词，后一个是其相应的同义词。 下面运行一遍”dab”的查找过程，执行：1thesaurus["dab"] 计算机就会按如下步骤执行。(1)计算散列值DAB = 4 × 1 × 2 = 8。(2)读取第8格，发现其中不是一个单独的值，而是一个数组。(3)于是线性地在该数组中查找，检查每个子数组的索引0位置，如果碰到要找的词（”dab”），就返回该子数组的索引1的值。 再图形化地演示一次。 求得DAB的散列值为8，于是计算机读取第8格。 因为第8格里面是一个数组，所以对该数组进行线性查找。首先是第1格，它又是一个数组，于是查看这个子数组的索引0。 它并非我们要找的词（”dab”），于是跳到下一格。 这一格的子数组的索引0正是”dab”，因此其索引1的值就是我们要找的同义词（”pat”）。 若散列表的格子含有数组，因为要在这些数组上做线性查找，所以步数会多于1。如果数据都刚好存在同一个格子里，那么查找就相当于在数组上进行。因此散列表的最坏情况就是O(N)。 为了避免这种情况，散列表的设计应该尽量减少冲突，以便查找都能以O(1)完成。 接着，我们就来看一下现实中的散列表是如何做到的。 找到平衡归根到底，散列表的效率取决于以下因素。 要存多少数据。 有多少可用的格子。 用什么样的散列函数。 前两点很明显。如果要放的数据很多，格子却很少，就会造成大量冲突，导致效率降低。但为什么和散列函数本身也有关系呢？我们这就来看看。 假设你准备用一个散列值总是落在1至9之间的散列函数，例如，将字母转成其对应的序号，然后一直相加，直至结果只剩一位数字的函数。 就像这样：PUT = 16 + 21 + 20 = 57因为57不止一位数字，于是将57拆成5 + 7。5 + 7 = 1212也不止一位数字，于是拆成1 + 2。1 + 2 = 3最终，PUT的散列值为3。因为这种计算逻辑，该散列函数只会返回1到9的数字。 再回到散列表的样子。如果是用刚才的散列函数，那么该散列表的10到16号格子就都用不上了，数据只会被放到1到9的格子里。 所以，一个好的散列函数，应当能将数据分散到所有可用的格子里去。 如果一个散列表只需要保存5个值，那么它应该多大，以及采用什么散列函数呢？ 要是散列表只有5个格子，那么散列函数需要算出1到 5的散列值。但就算我们想保存的值也只有5个，冲突还是很可能发生，因为散列值只有5种可能。 然而，如果散列表有100个格子，散列函数的结果为1到100之间的数，存5个值进去时发生冲突的可能性就小得多，因为落入的格子有100种可能。 尽管100个格子能很好地避免冲突，但只用来放5个值的话，就太浪费空间了。 这就是使用散列表时所需要权衡的：既要避免冲突，又要节约空间。 要想解决这个问题，可参考计算机科学家研究出的黄金法则：每增加7个元素，就增加10个格子。 如果要保存14个元素，那就得准备20个格子，以此类推。 数据量与格子数的比值称为负载因子。把这个术语代入刚才的理论，就是：理想的负载因子是0.7（7个元素/10个格子）。 如果你一开始就将7个元素放进散列表，那么计算机应该会创建出一个含有10个格子的散列表。随着你添加元素，计算机也会添加更多的格子来扩展这个散列表，并改变散列函数，使新数据能均匀地分布到新的格子里去。 幸运的是，一般编程语言都自带散列表的管理机制，它会帮你决定散列表的大小、散列函数的逻辑以及扩展的时机。既然你已经理解了散列表的原理，那么在处理一些问题时你就可以用它取代数组，利用其O(1)的查找速度来提升代码性能。 一个实例散列表有各种用途，但目前我们只考虑用它来提高算法速度。 第1章我们学习了基于数组的集合--一种能保证元素不重复的数组。每次往其中插入新元素时，都要先做一次线性查找来确定该元素是否已存在（如果是无序数组）。 如果要在一个大集合上进行多次插入，效率将会下降得很快，因为每次插入都需要O(N)。 很多时候，我们都可以把散列表当成集合来用。 把数组作为集合的话，数据是直接放到格子里的。用散列表时，则是将数据作为键，值可以为任何形式，例如数字1，或者布尔值true也行。 假设在Javascript里建立了如下所示的散列表。1var set = &#123;&#125;; 并加入一些数据。123set["apple"] = 1;set["banana"] = 1;set["cucumber"] = 1; 这样每次插入新值，都只需花O(1)的时间，而不是线性查找的O(N)。即使数据已存在时也是这个速度。1set["banana"] = 1; 再次插入”banana”时，我们并不需要检查它存在与否，因为即使存在，也只是将其对应的值重写成1。 散列表确实非常适用于检查数据的存在性。第4章我们讨论过如何在Javascript 里检查一个数组有没有重复数据。一开始的方案如下所示。1234567891011121314function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 当时我们说了，该嵌套循环的效率是O(N2)。 于是有了第二个O(N)的方案，不过它只能处理数据全为非负整数的数组。如果数组含有其他东西，例如字符串，那怎么办呢？ 使用类似的逻辑，但换成散列表（在Javascript里叫作对象），就可以处理字符串了。12345678910111213141516function hasDuplicateValue(array) &#123; var existingValues = &#123;&#125;; for(var i = 0; i &lt; array.length; i++) &#123; if(existingValues[array[i]] === undefined) &#123; existingValues[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 这种方法也是O(N)，其中的existingValues不是数组而是散列表，用字符串作为键（索引）是没有问题的。 假设我们要做一个电子投票机，投票者可以投给现有的候选人，也可以推荐新的候选人。因为会在选举的最后统计票数，我们可以将票保存在一个数组里，每投一票就将其插入到末尾。12345var votes = [];function addVote(candidate) &#123; votes.push(candidate);&#125; 最终数组就会变得很长。1["Thomas Jefferson", "John Adams", "John Adams", "Thomas Jefferson", "John Adams", ...] 这样插入很快，只有O(1)。 那点票的效率又如何呢？因为票都在数组里，所以我们会用循环来遍历它们，并用一个散列表来记录每人的票数。12345678910111213141516function countVotes(votes) &#123; var tally = &#123;&#125;; for(var i = 0; i &lt; votes.length; i++) &#123; if(tally[votes[i]]) &#123; tally[votes[i]]++; &#125; else &#123; tally[votes[i]] = 1; &#125; &#125; return tally;&#125; 不过这样需要O(N)，也太慢了！ 不如换种方式，一开始就用散列表来收集票数。123456789101112131415161718var votes = &#123;&#125;;function addVote(candidate) &#123; if(votes[candidate]) &#123; votes[candidate]++; &#125; else &#123; votes[candidate] = 1; &#125;&#125;function countVotes() &#123; return votes;&#125; 这样一来，投票是O(1)，并且因为投票时就已经在计数，所以已完成了点票的步骤。 总结高效的软件离不开散列表，因为其O(1)的读取和插入带来了无与伦比的性能优势。 到现在为止，我们探讨各种数据结构时都只考虑了性能。但你知道有些数据结构的优点并不在于性能吗？下一章就研究两种能帮助改善代码可读性和可维护性的数据结构。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章-乐观地调优]]></title>
    <url>%2F2018%2F05%2F31%2F%E7%AC%AC6%E7%AB%A0-%E4%B9%90%E8%A7%82%E5%9C%B0%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 插入排序的第二层为什么是while循环？ 插入排序包含4种步骤：移除、比较、平移和插入。各需要多少步？ 用Python和C#实现插入排序。 冒泡排序、选择排序、插入排序都需要双循环吗？ 本章涵盖： 插入排序 插入排序实战 插入排序的实现 插入排序的效率 平均情况 之前我们衡量一个算法的效率时，都是着眼于它在最坏情况下需要多少步。原因很简单，连最坏的情况都做足准备了，其他情况自然不在话下。 然而，本章会告诉你最坏情况不是唯一值得考虑的情况。全面分析各种情况，能帮助你为不同场景选择适当的算法。 插入排序我们已经学过两种排序算法：冒泡排序和选择排序。虽然它们的效率都是O(N2)，但其实选择排序比冒泡排序快一倍。现在来学第三种排序算法--插入排序。你会发现，顾及最坏情况以外的场景将是多么有用。 插入排序包括以下步骤。 (1)在第一轮里，暂时将索引1（第2格）的值移走，并用一个临时变量来保存它。这使得该索引处留下一个空隙，因为它不包含值。 在之后的轮回，我们会移走后面索引的值。 (2)接着便是平移阶段，我们会拿空隙左侧的每一个值与临时变量的值进行比较。 如果空隙左侧的值大于临时变量的值，则将该值右移一格。 随着值右移，空隙会左移。如果遇到比临时变量小的值，或者空隙已经到了数组的最左端，就结束平移阶段。 (3)将临时移走的值插入当前空隙。 (4)重复第(1)至(3)步，直至数组完全有序。 插入排序实战下面尝试对[4, 2, 7, 1, 3]数组运用插入排序。 第1轮先从索引1开始，其值为2。 准备工作：暂时移走2，并将其保存在变量temp_value中。图中被移到数组上方的就是temp_value。 第1步：比较4与temp_value中的2。 第2步：因为4大于2，所以把4右移。 于是空隙移到了数组最左端，没有其他值可以比较了。 第3步：将temp_value插回数组，完成第一轮。 开始第2轮。 准备工作：暂时移走索引2的值，并保存到temp_value中。于是temp_value等于7。 第4步：比较4与temp_value 。 4小于7，所以无须平移。因为遇到了小于temp_value的值，所以平移阶段直接结束。 第5步：将temp_value插回到空隙中，结束第2轮。 开始第3轮。 准备工作：暂时移走1，并将其保存到temp_value中。 第6步：比较7与temp_value。 第7步：7大于1，于是将7右移。 第8步：比较4与temp_value。 第9步：4大于1，于是也要将4右移。 第10步：比较2与temp_value。 第11步：2比较大，所以将2右移。 第12步：空隙到了数组最左端，因此我们将temp_value插进去，结束这一轮。 开始第4轮。 准备工作：暂时移走索引4的值3，保存到temp_value中。 第13步：比较7和temp_value。 第14步：7更大，于是将7右移。 第15步：比较4与temp_value 。 第16步：4大于3，所以将4右移。 第17步：比较2与temp_value。2小于3，于是平移阶段完成。 第18步：把temp_value插回到空隙。 至此整个数组都排好序了。 插入排序的实现以下是插入排序的Python实现。12345678910def insertion_sort(array): for index in range(1, len(array)): position = index temp_value = array[index] while position &gt; 0 and array[position - 1] &gt; temp_value: array[position] = array[position - 1] position = position - 1 array[position] = temp_value 让我们来一步步地讲解。我会先摘出代码片段，然后给出解释。1for index in range(1, len(array)): 首先，发起一个从索引1开始的循环来遍历数组。变量 index保存的是当前索引。12position = indextemp_value = array[index] 接着，给position赋值为index，给temp_value赋值为index所指的值。123while position &gt; 0 and array[position - 1] &gt; temp_value: array[position] = array[position - 1] position = position - 1 然后在内部发起一个while循环，以检查position左侧的值是否大于temp_value。若是，则用array[position] = array[position - 1]将该值右移一格，并将position减1。然后继续检查新position左侧的值是否大于temp_value……如此重复，直至遇到的值比temp_value小。1array[position] = temp_value 最后，将temp_value放回到数组的空隙中。 插入排序的效率插入排序包含4种步骤：移除、比较、平移和插入。要分析插入算法的效率，就得把每种步骤都统计一遍。 首先看看比较。每次拿temp_value跟空隙左侧的值比大小就是比较。 在数组完全逆序的最坏情况下，我们每一轮都要将temp_value左侧的所有值与temp_value比较。因为那些值全都大于temp_value，所以每一轮都要等到空隙移到最左端才能结束。 在第一轮，temp_value为索引1的值，由于temp_value左侧只有一个值，所以最多进行一次比较。到了第二轮，最多进行两次比较，以此类推。到最后一轮时，就要拿temp_value以外的所有值与其进行比较。换言之，如果数组有N个元素，则最后一轮中最多进行N - 1次比较。 因而可以得出比较的总次数为：1 + 2 + 3 + … + N - 1次。 对于有 5个元素的数组，最多需要：1 + 2 + 3 + 4 = 10次比较。 对于有 10个元素的数组，最多需要：1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45次比较。 （对于有20个元素的数组，最多需要190次比较，以此类推。） 由此可发现一个规律：对于有N个元素的数组，大约需要N2/2次比较（102/2是50，202/2是200）。 接下来看看其他几种步骤。 我们每次将值右移一格，就是平移操作。当数组完全逆序时，有多少次比较就要多少次平移，因为每次比较的结果都会使你将值右移。 把最坏情况下的比较步数和平移步数相加。N2/2次比较 + N2/2次平移 = N2步 temp_value的移除跟插入在每一轮里都会各发生一次。因为总是有N - 1轮，所以可以得出结论：有N - 1次移除和N - 1次插入。 把它们都相加。 N2比较和平移的合计 + N - 1次移除 + N - 1次插入 = N2 + 2N - 2步 我们已经知道大O有一条重要规则--忽略常数，于是你可能会将其简化成O(N2 + N)。 不过，现在来学习一下大O的另一条重要规则： 大O只保留最高阶的N。 换句话说，如果有个算法需要N4 + N3 + N2 + N步，我们就只会关注其中的N4，即以O(N4)来表示。为什么呢？ 请看下表。 N N2 N3 N4 2 4 8 16 5 25 125 625 10 100 1000 10000 100 10000 1000000 1000000000 1000 1000000 1000000000 1000000000000 随着N的变大，N4的增长越来越抛离其他阶。当N为1000时，N4就比N3大了1000倍。因此，我们只关心最高阶的N。 所以在插入排序的例子中，O(N2 + N)还得进一步简化成O(N2)。 你会发现，在最坏的情况里，插入排序的时间复杂度跟冒泡排序、选择排序一样，都是O(N2)。 不过上一章曾指出，虽然冒泡排序和选择排序都是O(N2)，但选择排序实际上是N2/2步，比N2步的冒泡排序更快。乍一看，你可能会觉得插入排序跟冒泡排序一样，因为它们都是O(N2)，其实插入排序是N2 + 2N - 2步。 如果本书到此为止，你或许会认为比冒泡排序和插入排序快一倍的选择排序是三者中最优的，但事情并没有这么简单。 平均情况确实，在最坏情况里，选择排序比插入排序快。但是我们还应该考虑平均情况。 为什么呢？ 所谓平均情况，就是那些最常遇见的情况。最坏情况和最好情况都是不常见的。看下面这个钟形的曲线。 最好情况和最坏情况很少发生。现实世界里，最常出现的是平均情况。 这是很有道理的。你设想一个随便洗乱的数组，出现完全升序或完全降序的可能性有多大？ 最可能出现的情况应该是随机分布。 下面试试在各种场景中测试插入排序。 完全降序的最坏情况之前已经见过，它每一轮都要比较和平移所遇到的值（这两种操作合计N2步）。 对于完全升序的最好情况，因为所有值都已在其正确的位置上，所以每一轮只需要一次比较，完全不用平移。 但若是随机分布的数组，你就可能要在一轮里进行比较并平移所有数据、部分数据，或无须平移。回头看看之前步骤分解的例子，可以发现在第 1、3轮，我们比较并平移了所有遇到的数据。在第4轮，我们只对部分数据进行了操作。在第2轮，则没有平移，只有一次比较。 最坏情况是所有数据都要比较和平移；最好情况是每轮一次比较、零次平移；对于平均情况，总的来看，是比较和平移一半的数据。 如果说插入排序的最坏情况需要N2步，那么平均情况就是N2/2步。尽管最终大O都会写成O(N2)。 来看一些具体的例子。 最好情况就像[1 ,2, 3, 4]，已经预先排好序。用同样的数据，最坏情况就是[4, 3, 2, 1] 。 平均情况，则如[1, 3, 4, 2] 。 这里的最坏情况需要6次比较和6次平移，共12步。平均情况需要4次比较和2次平移，共6步。最好情况是3次比较、0次平移。 可以看到插入排序的性能在不同场景中差异很大。最坏、平均、最好情况，分别需要N2、N2/2、N步。 这是由于有些轮次需要比较temp_value左侧的所有值，有些轮次却因为遇到了小于temp_value的值而提早结束。 3种情况的步数如下图所示。 再跟选择排序对比一下。选择排序是无论何种情况，最坏、平均、最好，都要N2/2步。 因为这个算法没有提早结束某一轮的机制，不管遇到什么，每一轮都得比较所选索引右边的所有值。 那么哪种算法更好？选择排序还是插入排序？答案是：看情况。对于平均情况（数组里的值随机分布），它们性能相近。如果你确信数组是大致有序的，那么插入排序比较好。如果是大致逆序，则选择排序更快。如果你无法确定数据是什么样，那就算是平均情况了，两种都可以。 一个实例假设你在写一个Javascript应用，你需要找出其中两个数组的交集。所谓交集，就是两个数组都有的值所组成的集合。举个例子，[3, 1, 4, 2]和[4, 5, 3, 6]的交集为[3, 4]，因为两个数组都有3和4。 Javascript并没有自带求交集的函数，因此我们只能自己写一个。以下是其中一种写法。1234567891011121314151617function intersection(first_array, second_array)&#123; var result = []; for (var i = 0; i &lt; first_array.length; i++) &#123; for (var j = 0; j &lt; second_array.length; j++) &#123; if (first_array[i] == second_array[j]) &#123; result.push(first_array[i]); &#125; &#125; &#125; return result;&#125; 它运用了一个简单嵌套循环。外部循环用来遍历第一个数组，并在每遇到一个值时，就发起内部循环去检查第二个数组有没有值与其相同。 此算法有两种步骤：比较和插入。也就是将两个数组的所有值相互比较，并把相同的值插入到result。插入的步数微不足道，因为即使两个数组完全一致，步数也不过是其中一个数组的数据量。所以这里主要考虑的是比较。 要是两个数组同样大小，那么比较需要N2步。这是因为数组一的每个值，都要与数组二的每个值进行对比。于是，两个数据量都为5的数组，最终会比较25次。这种算法效率为O(N 2)。 （如果数组大小不一，比如说分别含N、M个元素，那么此过程的步数就是O(N × M)，但简单起见，就当它们大小一样吧。） 那能不能改进一下呢？ 这就是为什么我们不能只考虑最坏情况的原因了。以现在的intersection函数的实现，无论遇到什么情况都是O(N2)的，不管你输入的两个数组完全不同还是完全相同。 如果两个数组真的没有交集，那你别无选择，只能检查完每个值才能确定。 但若是二者有交集，我们其实不用拿数组一的每个值去跟数组二的每个值对比。下面我就来解释为什么。 在以上例子中，一旦找到一个共有的值（8），那就没必要跑完内部循环了。再跑下去是为了检查什么呢？既然知道数组二中也存在数组一的那个值这就够了。 要改进的话，加一个命令就可以。123456789101112131415161718function intersection(first_array, second_array)&#123; var result = []; for (var i = 0; i &lt; first_array.length; i++) &#123; for (var j = 0; j &lt; second_array.length; j++) &#123; if (first_array[i] == second_array[j]) &#123; result.push(first_array[i]); break; &#125; &#125; &#125; return result;&#125; break可以中断内部循环，节省步数和时间。 这样的话，在没有交集的最坏情况下，我们仍然要做N2次比较；在数组完全一样的最好情况下，就只需要N次比较；在数组不同但有部分重复的平均情况下，步数会介于N到N2之间。 其性能提升是很明显的，因为在最初的实现里，无论什么情况，步数都是N2。 总结懂得区分最好、平均、最坏情况，是为当前场景选择最优算法以及给现有算法调优以适应环境变化的关键。记住，虽然为最坏情况做好准备十分重要，但大部分时间我们面对的是平均情况。 下一章我们会学习一种跟数组类似的数据结构，它的一些特点使其在某些场景中的性能优于数组。就像现在你得根据需求选择合适的算法，数据结构的性能也有差异，你也需要为此做出选择。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章-用或不用大O来优化代码]]></title>
    <url>%2F2018%2F05%2F29%2F%E7%AC%AC5%E7%AB%A0-%E7%94%A8%E6%88%96%E4%B8%8D%E7%94%A8%E5%A4%A7O%E6%9D%A5%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 选择排序算法是怎么样的？是两层循环吗？用js实现选择排序算法。 选择排序的步骤可分为两类：比较和交换，次数分别是什么样？ 选择排序比冒泡排序快在哪里？ 选择排序的效率如何？ 为什么两种算法的大O记法完全一样，但实际上其中一个比另一个要快得多？ 大O记法忽略常数是什么意思？ 本章涵盖： 选择排序 选择排序实战 选择排序的实现 选择排序的效率 忽略常数 大O的作用 大O是一种能够比较算法效率，并告诉我们在特定环境下应采用何种算法的伟大工具。但我们不能完全依赖于它。因为有时候即使两种算法的大O记法完全一样，但实际上其中一个比另一个要快得多。 本章我们就来学习如何分辨那些效率貌似一样的算法，从而选出较快的那个。 选择排序上一章分析了冒泡排序算法，其效率是O(N2)。现在我们再来探索另一种排序算法，选择排序，并将它跟冒泡排序对比一下。 选择排序的步骤如下： (1)从左至右检查数组的每个格子，找出值最小的那个。在此过程中，我们会用一个变量来记住检查过的数字的最小值（事实上记住的是索引，但为了看起来方便，下图就直接写出数值）。如果一个格子中的数字比记录的最小值还要小，就把变量改成该格子的索引，如图所示。 (2)知道哪个格子的值最小之后，将该格与本次检查的起点交换。第1次检查的起点是索引0，第2次是索引1，以此类推。下图展示的是第一次检查后的交换动作。 (3)重复第(1)(2)步，直至数组排好序。 选择排序实战以数组[4,2,7,1,3]为例，步骤如下。 开始第1轮检查。 首先读取索引0。根据此算法的定义，它是目前遇到的最小值（因为现在只检查了一个格子），于是记下其索引。 第1步：将索引1的值2与目前的最小值4进行比较。 2比4还要小，于是将目前的最小值改为2。 第2步：再与下一个值做比较。因为7大于2，所以最小值还是2。 第3步：将1和目前的最小值做比较。 1比2还要小，于是目前的最小值更新为1。 第4步：比较3和目前的最小值1。因为现在已经走到数组尽头了，所以可以断定1是整个数组的最小值。 第5步：本次检查的起点是索引0，不管那里的值是什么，我们都应该将最小值1换到那里。 现在1就排到正确的位置上了。 可以开始第2轮检查了。 准备工作：因为索引0的值已符合其排位，所以这一轮从下一个格子开始，即索引1，其值为2，也是目前本轮所遇到的最小值。 第6步：将7跟目前的最小值2进行比较。因为2小于7，所以最小值仍为2。 第7步：将4跟目前的最小值2进行比较。因为2小于4，所以最小值仍为2。 第8步：将3跟目前的最小值2进行比较。因为2小于3，所以最小值仍为2。 又走到数组尽头了。本轮不需要做任何交换，2已在其正确位置上。于是第2轮检查结束，现在数组如下图所示。 开始第3轮检查。 准备工作：从索引2起，其值为7。于是本轮目前最小值为7。 第9步：比较4与7。 将4记为目前的最小值。 第10步：遇到3，它比4还小。 于是3成了目前的最小值。 第11步：到数组尽头了，将3跟本轮起点7进行交换。 于是3排到正确位置上了。 虽然我们可以看到现在整个数组都有序了，但计算机是看不到的，它只会继续第4轮检查。 准备工作：此轮检查从索引3开始，其值4是目前的最小值。 第12步：比较4和7。 4仍为最小值，而且它也处于本轮起点，因此无须任何交换。 因为最后一个格子左侧的那些值都已在各自的正确位置上，所以最后一格也必然正确，于是排序结束。 选择排序的实现以下是用Javascript写的选择排序。123456789101112131415161718192021222324function selectionSort(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; var lowestNumberIndex = i; for(var j = i + 1; j &lt; array.length; j++) &#123; if(array[j] &lt; array[lowestNumberIndex]) &#123; lowestNumberIndex = j; &#125; &#125; if(lowestNumberIndex != i) &#123; var temp = array[i]; array[i] = array[lowestNumberIndex]; array[lowestNumberIndex] = temp; &#125; &#125; return array;&#125; 让我们来一行行地分析。我会先摘出代码片段，然后给出解释。1for(var i = 0; i &lt; array.length; i++) &#123;&#125; 这个外层的循环代表每一轮检查。在一轮检查之初，我们会先记住目前的最小值的索引。1var lowestNumberIndex = i; 因此每轮开始时lowestNumberIndex都会是该轮的起点索引i。注意我们实际上记录的是最小值的索引，而非最小值本身。于是，第1轮开始时最小值的索引是0，到第2轮则是1，以此类推。1for(var j = i + 1; j &lt; array.length; j++) &#123;&#125; 此行代码发起一个以i + 1开始的内层循环。1234if(array[j] &lt; array[lowestNumberIndex]) &#123; lowestNumberIndex = j;&#125; 循环内逐个检查数组未排序的格子，若遇到比之前记录的本轮最小值还小的格子值，就将lowestNumberIndex更新为该格子的索引。 内层循环结束时，会得到未排序数值中最小值的索引。123456if(lowestNumberIndex != i) &#123; var temp = array[i]; array[i] = array[lowestNumberIndex]; array[lowestNumberIndex] = temp;&#125; 然后再看看这个最小值是否已在正确位置，即该索引是否等于i。如果不是，就将i所指的值与最小值交换。 选择排序的效率选择排序的步骤可分为两类：比较和交换，也就是在每轮检查中把未排序的值跟该轮已遇到的最小值做比较，以及将最小值与该轮起点的值交换以使其位置正确。 在之前5个元素的例子里，我们总共进行了10次比较。每轮分别如下。 第#轮 #次比较 1 4 2 3 3 2 4 1 于是4 + 3 + 2 + 1 = 10次比较。 推广开来，若有N个元素，就会有(N - 1) + (N - 2) + (N - 3) + … + 1次比较。 但每轮的交换最多只有1次。如果该轮的最小值已在正确位置，就无须交换，否则要做1次交换。相比之下，冒泡排序在最坏情况（完全逆序）时，每次比较过后都要进行1次交换。 下表为冒泡排序和选择排序的并列对比。 N个元素 冒泡排序最多要#步 选择排序最多要#步 5 20 14(10次比较 + 4次交换) 10 90 54(45次比较 + 9次交换) 20 380 199(180次比较 + 19次交换) 40 1560 819(780次比较 + 39次交换) 80 6320 3239(3160次比较 + 79次交换) 从表中可以清晰地看到，选择排序的步数大概只有冒泡排序的一半，即选择排序比冒泡排序快一倍。 忽略常数但有趣的是，选择排序的大O记法跟冒泡排序是一样的。 还记得我们说过，大O记法用来表示步数与数据量的关系。所以你可能会以为步数约为N2的一半的选择排序，其大O会写成O(N2/2)，以表示N个元素需要N2/2步。如下表所示。 N个元素 N2/2 选择排序最多要#步 5 52 / 2 = 12.5 14 10 102 / 2 = 50 54 20 202 / 2 = 200 199 40 402 / 2 = 800 819 80 802 / 2 = 3200 3239 但事实上，选择排序的大O记法为O(N2)，跟冒泡排序一样。这是因为大O记法的一条重要规则我们至今还没提到： 大O记法忽略常数。 换一种不那么数学的表达方式，就是：大O记法不包含一般数字，除非是指数。 如刚才的例子，严格来说本应为O(N2/2)，最终得写成O(N2)。类似地，O(2N)要写成O(N)；O(N/2)也写成O(N)；就算是比O(N)慢100倍的O(100N)，也要写成O(N)。 速度相差100倍的两种算法，它们的大O记法却一样，这或许会让人觉得大O没什么意义。就像同为O(N)的选择排序和冒泡排序，其实前者比后者快1倍，要在二者之中挑选，无疑是用选择排序。 那么，大O还凭什么值得我们学习呢？ 大O的作用尽管不能比较冒泡排序和选择排序，大O还是很重要的，因为它能够区分不同算法的长期增长率。当数据量达到一定程度时，O(N)的算法就会永远快过O(N2)，无论这个O(N)实际上是O(2N)还是O(100N)。即使是O(100N)，这个临界点也是存在的。（第3章在比较一个100步的算法与O(N)算法时，也提过这个概念，不过这次我们会用另一个例子来讲解。） 下图为O(N)和O(N2)的对比。 此图在上一章里出现过。它显示了不管数据量是多少，O(N)总是快过O(N2)。 在第二幅图中，我们看到当数据量少于某个值时，O(N2)是比O(100N)要快的，但过了这个值之后，O(100N)便反超O(N2)，并一直保持优势。 这就是大O记法忽略常数的原因。大O记法只表明，对于不同分类，存在一临界点，在这一点之后，一类算法会快于另一类，并永远保持下去。至于这个点在哪里，大O并不关心。 因此，不需要写成O(100N)，归类到O(N)就好了。 同样地，在数据量增大到某个点时，O(log N)便会永远超越O(N)，即使该O(log N)算法的实际步数为O(2log N)。 所以大O是极为有用的工具，当两种算法落在不同的大O类别时，你就很自然地知道应该选择哪种。因为在大数据的情况下，必然存在一临界点使这两种算法的速度永远区分开来。 不过，本章的主要结论是即使两种算法的大O记法一样，但实际速度也可能并不一样。虽然选择排序比冒泡排序快1倍，但它们的大O记法都是O(N2)。因此，大O记法非常适合用于不同大O分类下的算法的对比，对于大O同类的算法，我们还需要进一步的解析才能分辨出具体差异。 一个实例假设你要写一个Ruby程序，从一个数组里取出间隔的元素，来组成新的数组。你可能会用数组的each_with_index方法来做如下遍历。 123456789def every_other(array) new_array = [] array.each_with_index do |element, index| new_array &lt;&lt; element if index.even? end return new_arrayend 它迭代原数组的每一个元素，如果元素索引值为偶数，则将该元素插入到新数组里。 分析其中步骤，会发现它们可分为两种：一种是读取数组元素，另一种是插入元素到新数组。 因为要读取数组的每一个元素，所以读取有N步。插入则只有N/2步，因为只有间隔的元素才被放到新数组里。从技术上来说，N次读取加N/2次插入，这算法的效率应该是O(N+(N/2))，或者是O(1.5N)。但因为大O记法要把常数丢掉，所以只写成O(N)。 此算法虽然能达到效果，但我们还是要再审视一下它有没有提升的空间。事实上，有。 与其迭代每个元素并检查它们的索引是否为偶数，不如只读取数组中间隔的元素。123456789def every_other(array) new_array = [] index = 0 while index &lt; array.length new_array &lt;&lt; array[index] index += 2 end return new_arrayend 这种做法的while循环会跳过间隔的元素，因此避免了检查每个元素。结果就是有N个元素，会有N/2次读取，N/2次插入。它跟第一种做法一样，记为O(N)。 然而，第一种做法实际有1.5N步，比只有N步的第二种明显要慢。虽然第一种的写法在Ruby界更为惯用，但如果要处理的数据量庞大，不妨尝试第二种，以获得性能的飞升。 总结现在我们已经掌握了一些非常强大的算法分析手法。我们能够使用大O去判断各种算法的效率，即便两种算法的大O记法一样，也知道如何对比它们。 不过在对比算法时，还需要考虑一个重要因素。至今我们关注的都是最坏情况下算法会跑得多慢，但其实最坏情况并不总会发生。没错，我们遇到的大都是平均情况。下一章，我们会学习怎样顾及所有情况。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章-运用大O来给代码提速]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%AC%AC4%E7%AB%A0-%E8%BF%90%E7%94%A8%E5%A4%A7O%E6%9D%A5%E7%BB%99%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 冒泡排序为什么叫冒泡排序？冒泡排序的大O记法是什么？为什么？ 冒泡排序的执行步骤是哪两步？图是什么样的？也叫作什么？ 嵌套循环算法的效率是怎么样的？ 检查数组中是否有重复值怎么进行线性解决？ 本章涵盖： 冒泡排序 冒泡排序实战 冒泡排序的实现 冒泡排序的效率 二次问题 线性解决 大O记法能客观地衡量各种算法的时间复杂度，是比较算法的利器。我们也试过用它来对比二分查找和线性查找的步数差异，发现二分查找的步数为O(log N)，比线性查找的O(N)快得多。 然而，写代码的时候并不总有这样明确的二选一，更多时候你可能就直接采用首先想到的那种算法了。不过有了大O的话，你就可以与其他常用的算法比较，然后问自己：“我的算法跟它们相比，是快还是慢？” 如果你通过大O发现自己的算法比其他的要慢，你就应该退一步，好好想想怎样优化它，才能使它变成更快的那种大O。虽然并不总有提升空间，但在确定编码之前多加考虑还是好的。 本章我们会写些代码来解决一个实际问题，并且会用大O来测量算法的性能，然后看看是否能对算法做些修改，使得性能提升。（剧透：能。） 冒泡排序但在讨论实际问题之前，先来学习一种新的时间复杂度。我们会从计算机科学的经典算法之一开始阐述。 排序算法是计算机科学中被广泛研究的一个课题。历时多年，它发展出了数十种算法，这些算法都着眼于一个问题： 如何将一个无序的数字数组整理成升序？ 你会在本章以及下一章看到这些算法。起初我们会学习一些“简单排序”，它们很好懂，但效率不如其他排序算法。 冒泡排序是一种很基本的排序算法，步骤如下。 (1)指向数组中两个相邻的元素（最开始是数组的头两个元素），比较它们的大小。 (2)如果它们的顺序错了（即左边的值大于右边），就互换位置。 如果顺序已经是正确的，那这一步就什么都不用做。 (3)将两个指针右移一格。 重复第(1)步和第(2)步，直至指针到达数组末尾。 (4)重复第(1)至(3)步，直至从头到尾都无须再做交换，这时数组就排好序了。 这里被重复的第(1)至(3)步是一个轮回，也就是说，这个算法的主要步骤被“轮回”执行，直到整个数组的顺序正确。 冒泡排序实战下面来举一个完整的例子。假设要对[4, 2, 7, 1, 3]进行排序。它现在是无序的，我们的目标是产生一个包含相同元素、升序的数组。 开始第1次轮回。 数组一开始如下图所示。 第1步：首先，比较4和2。如图可见它们的顺序是错的。 第2步：交换它们的位置。 第3步：比较4和7。 它们的顺序正确，所以不用做什么交换。 第4步：比较7和1。 第5步：顺序错误，于是进行交换。 第6步：比较7和3。 第7步：顺序错误，于是进行交换。 因为我们一直把较大的元素换到右边，所以现在最右侧的7正处于其正确位置上。我将那个格子用虚线圈起来了。 这也正是此种算法名为冒泡排序的原因：每一次轮回过后，未排序的值中最大的那个都会“冒”到正确的位置上。 因为刚才那次轮回做了不止一次的交换，所以得继续轮回。 下面来第2次轮回。 此时7已经在正确的位置上了。 第8步：从比较2和4开始。 它们已经按顺序排好了，所以直接进行下一步。 第9步：比较4和1。 第10步：它们的顺序错误，于是交换。 第11步：比较4和3。 第12步：顺序错误，进行交换。 因为7已经在上一次轮回里排好了，所以无须比较4和7。此外，4移到了正确的位置，本次轮回结束。因为这次轮回也做了不止一次的交换，所以得继续轮回。 下面来第3次轮回。 第13步：比较2和1。 第14步：顺序错误，进行交换。 第15步：比较2和3。 顺序正确，不用交换。 这时3也“冒”到其正确位置了。因为这次轮回做了不止一次的交换，所以还要继续。 于是开始第4次轮回。 第 16步：比较1和2。 顺序正确，不用交换。而且剩下的元素也都排好序了，轮回结束。 因为刚才的轮回没有任何交换，可知整个数组都已排好序。 冒泡排序的实现以下是用Python写的冒泡排序。1234567891011121314def bubble_sort(list): unsorted_until_index = len(list) - 1 sorted = False while not sorted: sorted = True for i in range(unsorted_until_index): if list[i] &gt; list[i+1]: sorted = False list[i], list[i+1] = list[i+1], list[i] unsorted_until_index = unsorted_until_index - 1list = [65, 55, 45, 35, 25, 15, 10]bubble_sort(list)print list 让我们来一行行地分析。我会先摘出代码片段，然后给出解释。1unsorted_until_index = len(list) - 1 变量unsorted_until_index表示“该索引之前的数据都没排过序”。一开始整个数组都是没排过序的，所以此变量赋值为数组的最后一个索引。1sorted = False 另外还有一个sorted变量，被用来记录数组是否已完全排好序。当然一开始它应该是False 。12while not sorted: sorted = True 接着是一个while循环，除非数组排好了序，不然它不会停下来。然后，我们先将sorted初步设置为True。当发生任何交换时，我们会将其改为False。如果在一次轮回里没有做过交换，那么sorted就确定为True，我们知道数组已排好序了。1234for i in range(unsorted_until_index): if list[i] &gt; list[i+1]: sorted = False list[i], list[i+1] = list[i+1], list[i] 在while循环里，还有一个for循环会迭代未排序元素的索引值。此循环中，我们会比较相邻的元素，如果有顺序错误，就会进行交换，并将sorted改为False 。1unsorted_until_index = unsorted_until_index - 1 到了这一行，就意味着一次轮回结束了，同时该次轮回中冒泡到右侧的值处于正确位置。因为unsorted_until_index所指的位置已放上了正确的元素，所以减1，以便下一次轮回能略过该位置。 一次while 循环就是一次轮回，循环会持续直至sorted确定为True 。 冒泡排序的效率冒泡排序的执行步骤可分为两种。 比较：比较两个数看哪个更大。 交换：交换两个数的位置以使它们按顺序排列。 先看看冒泡排序要进行多少次比较。 回顾之前那个5个元素的数组，你会发现在第1次轮回我们为4对元素进行了4次比较。 到了第2次轮回，则只做了3次比较。这是因为第1次轮回已经确定了最后一个格子的元素，所以不用再比较最后两个元素了。 第3次轮回，只比较2次；第4次，只比较1次。 算起来就是： 4 + 3 + 2 + 1 = 10 次比较。 推广到N个元素，需要 (N - 1) + (N - 2) + (N - 3) + … + 1次比较。 分析过比较之后，再来看看交换。 如果数组不只是随机打乱，而是完全反序，在这种最坏的情况下，每次比较过后都得进行一次交换。因此10次比较加10次交换，总共20步。 现在把两种步骤放在一起来看。一个含有10个元素的数组，需要： 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45次比较，以及45次交换，共90步。 20个元素的话，就是： 19 + 18 + 17 + 16 + 15 + 14 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 190次比较，以及190次交换，共380步。 效率太低了。元素量呈倍数增长，步数却呈指数增长，如下表所示。 N个元素 最多步数 5 20 10 90 20 380 40 1560 80 6320 再看仔细一点，你会发现随着N的增长，步数大约增长为N2 。 N个元素 最多步数 N2 5 20 25 10 90 100 20 380 400 40 1560 1600 80 6320 6400 因此描述冒泡排序效率的大O记法，是O(N2)。 规范一些来说：用O(N2)算法处理N个元素，大约需要N2步。 O(N2)算法是比较低效的，随着数据量变多，其步数也剧增，如下图所示。 注意O(N2)代表步数的曲线非常陡峭，O(N)的则只呈对角线状。 最后一点：O(N2)也被叫作二次时间。 二次问题假设你正在写一个JavaScript应用，它要检查数组中是否有重复值。 首先想到的做法可能是类似下面的嵌套for循环。123456789101112131415function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 此函数用var i来遍历数组元素。每当i指向下一元素时，我们又发起第二个for循环，用var j来遍历数组元素，并在这第二个循环过程中检查i和j两个位置的值是否相同。若相同，则表示数组有重复值。如果两层循环都没遇到重复值，则最终返回false，以示数组没有重复值。 虽然可以这么做，但它的效率高吗？既然我们学过一点大O记法，那么就试试用大O来评价一下这个函数吧。 记住，大O测量的是步数与数据量的关系。因此，我们要测的就是：给hasDuplicateValue函数传入一个含有N个元素的数组，最坏情况下需要多少步才能完成。 要回答这个问题，得先搞清楚这个函数有哪些步骤，以及其最坏情况是什么。 该函数只有一种步骤，就是比较。它重复地比较i和j所指的值，看它们是否相等，以判断数组有没有重复值。最坏的情况就是没有重复，这将使我们跑遍内外两层循环，比较完所有i、j组合，才返回false 。 由此可知N个元素要比较N2次。因为外层循环需要N步来遍历数组，而这里的每1步，又会发起内层循环去用N步遍历数组。所以N步乘以N步等于N2步，此函数为一个O(N2)算法。 想要证明的话，还可以往函数里添加一些跟踪步数的代码。12345678910111213141516171819function hasDuplicateValue(array) &#123; var steps = 0; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; steps++; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; console.log(steps); return false;&#125; 执行hasDuplicateValue([1,2,3])的话，你会看到Javascript console输出9，表示9次比较。3个元素需要9次比较，这个函数是O(N2)的经典例子。 毫无疑问，嵌套循环算法的效率就是O(N2)。一旦看到嵌套循环，你就应该马上想到O(N2)。 虽然hasDuplicateValue是我们目前唯一想到的解决方法，但在确定采用之前，应意识到它的O(N2)意味着低效。当遇到低效的算法时，我们都应该花些时间思考下有没有更快的做法。 特别是当数据量巨大的时候，优化不足的应用甚至可能会突然挂掉。尽管这可能已经是最佳方案，但你还是要确认一下。 线性解决以下是hasDuplicateValue的另一种实现，它没有嵌套循环。看看它是否会比之前的更加高效。1234567891011121314151617function hasDuplicateValue(array) &#123; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 此实现只有一个循环，并将迭代过程中遇到的数字用数组existingNumbers记录下来。其记录方法很有趣：每发现一个新的数字，就以其为索引找出existingNumbers中对应的格子，将其赋值为1。 举个例子，如果参数array为[3,5,8]，那么循环结束时，existingNumbers就会变成以下这样。1[undefined, undefined, undefined, 1, undefined, 1, undefined, undefined, 1] // 第一次索引为3,5,8的时候和undefined比较是相等的，所以赋值为1。0,1,2,4等索引没有赋值，所以是undefined 里面那些1的位置为索引3、5、8，因为array包含的这些数字已被发现。 不过，在将1赋值到对应的索引上之前，还得先检查索引上是否已有1。如果有，那就意味着这个数字曾经遇到过，也就是传入的数组有重复值。 为了确定这一新算法的时间复杂度符合哪种大O，我们得考察其最坏情况下需要多少步。与上一算法类似，此算法的主要步骤也是比较。读取existingNumbers上某索引的值，并与undefined比较，代码如下。1if(existingNumbers[array[i]] === undefined) （其实除了比较，我们还要对existingNumbers进行插入，但这无关紧要，原因会在下一章进行讲解。） 同样，最坏的情况就是无重复，因为你得跑完整个循环才能发现。 可见N个元素就要N次比较。因为这里只有一个循环，数组有多少个元素，它就要迭代多少次。要证明这个猜想，可以用JavaScript console来打印步数。12345678910111213141516171819202122function hasDuplicateValue(array) &#123; var steps = 0; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; steps++; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; console.log(steps); return false;&#125; 执行hasDuplicateValue([1,2,3])的话，你会看到输出为3，跟元素个数一致。 因此其大O记法是O(N)。 我们知道O(N)远远快于O(N2)，所以采用第二种算法能极大地提升hasDuplicateValue的效率。如果这个程序处理的数据量很大，那么性能差别是很明显的（其实第二种算法有一个缺点，不过我们在最后一章才会讲到）。 总结毫无疑问，熟悉大O记法能使我们发现低效的代码，有助于我们挑选出更快的算法。然而，偶尔也会有两种算法的大O相同，但实际上二者快慢不一的情况。下一章我们就来学习当大O记法太过粗略的时候，如何识别两种算法的效率高低。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章-大O记法]]></title>
    <url>%2F2018%2F05%2F27%2F%E7%AC%AC3%E7%AB%A0-%E5%A4%A7O%E8%AE%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是大O记法？解答的是什么样的问题？ O(1)是什么意思？有哪些算法是O(1)？ O(N)是什么意思？哪些算法是O(N)？ O(1)和O(N)分别又叫做什么？ 线性查找的最好情况是O(1)，最坏情况是O(N)如何理解？大O记法一般都是指最坏情况如何理解？ 二分查找的大O记法是什么样的？也叫作什么？ 什么是对数和指数？ O(log N)算法是什么意思？ O(1)、O(log N)、O(N)的效率比较是什么样的？在图中如何表示？ 本章涵盖： 大O：数步数 常数时间与线性时间 同一算法，不同场景 第三种算法 对数 解释O(log N) 从之前的章节中我们了解到，影响算法性能的主要因素是其所需的步数。 然而，我们不能简单地把一个算法记为“22步算法”，把另一个算法记为“400步算法”，因为一个算法的步数并不是固定的。以线性查找为例，它的步数等于数组的元素数量。如果数组有22个元素，线性查找就需要22步；如果数组有400个元素，线性查找就需要400步。 量化线性查找效率的更准确的方式应该是：对于具有N个元素的数组，线性查找最多需要N步。当然，这听起来很啰唆。 为了方便表达数据结构和算法的时间复杂度，计算机科学家从数学界借鉴了一种简洁又通用的方式，那就是大O记法。这种规范化语言使得我们可以轻松地指出一个算法的性能级别，也令学术交流变得简单。 掌握了大O记法，就掌握了算法分析的专业工具。 虽说大O记法源于数学领域，但接下来我们不会讲解任何数学术语，只介绍跟计算机科学相关的部分。并且，我们会循序渐进，先用简单的词汇来解释它，然后在接下来的三章中将其构建完善。大O记法不复杂，但我们还是分成了几个章节来细述，使其更容易理解。 大O：数步数为了统一描述，大O不关注算法所用的时间，只关注其所用的步数。 第1章介绍过，数组不论多大，读取都只需1步。用大O记法来表示，就是： O(1) 很多人将其读作“大O1”，也有些人读成“1数量级”。我一般读成“O1”。虽然大O记法有很多种读法，但写法只有一种。 O(1)意味着一种算法无论面对多大的数据量，其步数总是相同的。就像无论数组有多大，读取元素都只要1步。这1步在旧机器上也许要花20分钟，而用现代的硬件却只要1纳秒。但这两种情况下，读取数组都是1步。 其他也属于O(1)的操作还包括数组末尾的插入与删除。之前已证明，无论数组有多大，这两种操作都只需1步，所以它们的效率都是O(1)。 下面研究一下大O记法如何描述线性查找的效率。回想一下，线性查找在数组上要逐个检查每个格子。在最坏情况下，线性查找所需的步数等于格子数。即如前所述：对于N个元素的数组，线性查找需要花N步。 用大O记法来表示，即为： O(N) 我将其读作“O N”。 若用大O记法来描述一种处理一个N元素的数组需花N步的算法的效率，很简单，就是O(N)。 数学解释前面提过，本书要采用一种易于理解的方式来讨论大O。当然这不是唯一的方式，如果你去上传统的大学算法课程，老师很可能从数学角度来介绍大O。因为大O本就是一个数学概念，所以人们经常用数学词汇介绍它，比如说“大O记法可用来描述一个函数的增长率的上限”，或者“如果函数g(x)的增长速度不比函数f(x)快，那么就称g属于O(f)”。大家数学背景不同，所以这些说法可能对你有意义，也可能没什么帮助。有了这本书，你不需要了解太多数学知识，就可以理解大O。 常数时间与线性时间从O(N)可以看出，大O记法不只是用固定的数字（如22、440）来表示算法的步数，而是基于要处理的数据量来描述算法所需的步数。或者说，大O解答的是这样的问题：当数据增长时，步数如何变化？ O(N)算法所需的步数等于数据量，意思是当数组增加一个元素时，O(N)算法就要增加1步。而O(1)算法无论面对多大的数组，其步数都不变。 下图展示了这两种时间复杂度。 从图中可以看出，O(N)呈现为一条对角线。当数据增加一个单位时，算法也随之增加一步。也就是说，数据越多，算法所需的步数就越多。O(N)也被称为线性时间。 相比之下，O(1)则为一条水平线，因为不管数据量是多少，算法的步数都恒定。所以，O(1)也被称为常数时间。 因为大O主要关注的是数据量变动时算法的性能变化，所以你会发现，即使一个算法的恒定步数不是1，它也可以被归类为O(1)。假设有个算法不能1步完成，而要花3步，但无论数据量多大，它都需要3步。如果用图形来展示，该算法应该是这样： 因为不管数据量怎样变化，算法的步数都恒定，所以这也是常数时间，也可以表示为O(1)。虽然从技术上来说它需要3步而不是1步，但大O记法并不纠结于此。简单来说，O(1)就是用来表示所有数据增长但步数不变的算法。 如果说只要步数恒定，3步的算法也属于O(1)，那么恒为100步的算法也属于O(1)。虽然100步的算法在效率上不如1步的算法，但如果它的步数是恒定的，那么它还是比O(N)更高效。 为什么呢？如图所示。 对于元素量少于100的数组，O(N)算法的步数会少于100步的O(1)算法。当元素刚好为100个时，两者的步数同为100。而一旦超过100个元素，注意，O(N)的步数就多于O(1)。 因为数据量从这个临界点开始，直至无限，O(N)都会比O(1)花更多步数，所以总体上来说，O(N)比O(1)低效。 这对于步数恒为1000000的O(1)算法来说也是一样的。当数据量一直增长时，一定会到达一个临界点，使得O(N)算法比O(1)算法低效，而且这种落后的状况会持续到数据量无限大的时候。 同一算法，不同场景之前的章节我们提到，线性查找并不总是O(N)的。当要找的元素在数组末尾，那确实是O(N)。但如果它在数组开头，1步就能找到的话，那么技术上来说应该是O(1)。所以概括来说，线性查找的最好情况是O(1)，最坏情况是 O(N)。 虽然大O可以用来表示给定算法的最好和最坏的情景，但若无特别说明，大O记法一般都是指最坏情况。因此尽管线性查找有O(1)的最好情况，但大多数资料还是把它归类为O(N)。 这种悲观主义其实是很有用的：知道各种算法会差到什么程度，能使我们做好最坏打算，以选出最适合的算法。 第三种算法上一章我们学到：在同一个有序数组里，二分查找比线性查找要快。下面就来看看如何用大O记法描述二分查找。 它不能写成O(1)，因为二分查找的步数会随着数据量的增长而增长。它也不能写成O(N)，因为步数比元素数量要少得多，正如之前我们看到的，包含100个元素的数组只要7步就能找完。 看来，二分查找的时间复杂度介于O(1)和O(N)之间。 好了，二分查找的大O记法是： O(log N) 我将其读作“O log N”。归于此类的算法，它们的时间复杂度都叫作对数时间。 简单来说，O(log N)意味着该算法当数据量翻倍时，步数加1。这确实符合之前章节我们所介绍的二分查找。下面我们先整理一下至今学到的东西，之后马上就解释采取这种记法的原因。 到这里我们所提过的3种时间复杂度，按照效率由高到低来排序的话，会是这样： O(1) O(log N) O(N) 下图为它们三者的对比。 注意O(log N)曲线的微弯，使其效率略差于O(1)，却远胜于O(N)。 若想理解这种时间复杂度为什么是O(log N)，我们得先学习一下对数。如果你对这个数学概念已经很熟悉了，那么可以跳过下一节。 对数让我们来研究下为什么二分查找之类的算法被记为O(log N)，到底log是什么？ log即是对数（logarithm）。注意，虽然它的英文看起来和读起来都跟算法（algorithm）很像，但它与算法无关。 对数是指数的反函数，所以我们先回顾一下指数。 23等于：12 × 2 × 2 结果为8。 log28 则将上述计算反过来，它意思是：要把2乘以自身多少次，才能得到8。因为需要3次，所以，log28 = 3。 再来一个例子。 26可以解释为：12 × 2 × 2 × 2 × 2 × 2 = 64 因为2要乘以自身6次才得到64，所以，log264 = 6。 不过以上都是教科书式的定义，我打算换一种更形象和更易于理解的方式来解释。 log2 8可以表达为：将8不断地除以2直到1，需要多少个2。（注：按照从左到右的顺序计算。） 18 / 2 / 2 / 2 = 1 或者说，将8不断地除以2，要除多少次才能到1呢？答案是3，所以，log28 = 3。 类似地，log264可以解释为：将64除以2多少次，才能得到1。 164 / 2 / 2 / 2 / 2 / 2 / 2 = 1 因为这里有6个2，所以，log264 = 6。 现在你应该明白对数是怎么回事了，那么O(log N)就很好懂了。 解释O(log N)现在回到大O记法。当我们说O(log N)时，其实指的是O(log2N)，不过为了方便就省略了2而已。 你应该还记得O(N)代表算法处理N个元素需要N步。如果元素有8个，那么这种算法就需要8步。 O(log N)则代表算法处理N个元素需要log2N步。如果有8个元素，那么这种算法需要3步，因为log28 = 3。 从另一个角度来看，如果要把8个元素不断地分成两半，那么得拆分3次才能拆到只剩1个元素。 这正是二分查找所干的事情。它就是不断地将数组拆成两半，直至范围缩小到只剩你要找的那个元素。 简单来说，O(log N)算法的步数等于二分数据直至元素剩余1个的次数。 下表是O(N)和O(log N)的效率对比。 N个元素 O(N) O(log N) 8 8 3 16 16 4 32 32 5 64 64 6 128 128 7 256 256 8 512 512 9 1024 1024 10 每次数据量翻倍时，O(N)算法的步数也跟着翻倍，O(log N)算法却只需加 1。 后面的章节我们还会学到除了这3种时间复杂度以外的算法。不过现在，我们还是先把已经学会的实践到日常的代码中。 实例以下是打印列表所有元素的典型Python代码。123things = ['apples', 'baboons', 'cribs', 'dulcimers']for thing in things: print "Here's a thing: %s" % thing 它的效率要怎么用大O记法来表示呢？ 首先，这是一个算法的例子。虽然它并没有多么厉害，但不管一段代码做什么事情，技术上来说它都是一个算法--因为它是解决某种问题的一个独特的过程。在此例中，问题是打印列表的所有元素，而算法是在for循环中使用print 。 为了得出它的大O记法，我们需要分析这个算法的步数。这段代码的主要部分--for循环会走4步，因为列表总共有4个元素。 然而，此过程不一定总是这样。如果列表有10个元素，那么for循环就会是10步。因为这里for的步数等于元素数量，所以整个算法的效率是O(N)。 再来一个例子，这是大家都知道的最基础的代码。1print('Hello world!') 它永远都只会是1步，所以是O(1)。 以下的例子是代码判断一个数字是否为质数。12345def is_prime(number): for i in range(2, number): if number % i == 0: return Falsereturn True 它接受一个参数，名为number ，然后用一个for 循环来测试number除以2到number之间的数，看是否有余数。如果没有，则number非质数，可以马上返回False。但如果一直测到number除以number的前一个数都有余数，那么它就是一个质数，最后会返回True。 此算法的效率为O(N)。它不以数组为参数，而是用一个数字。如果is_prime传入的是7，那么for循环就要差不多走7次（准确来说是5步，因为是从2开始，直到该数字的前一个数）。如果是101，那就循环差不多101次。因为步数与参数的大小一致，所以它的效率是O(N)。 总结学会大O记法，我们在比较算法时就有了一致的参考系。有了它，我们就可以在现实场景中测量各种数据结构和算法，写出更快的代码，更轻松地应对高负荷的环境。 下一章会用一个实际的例子，让你看到大O记法如何帮助我们显著地提高代码的性能。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-算法为何重要]]></title>
    <url>%2F2018%2F05%2F26%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BD%95%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 有序数组和普通数组在线性查找方面有什么不同？ 有序数组还可以使用什么查找方法？为什么普通数组无法使用？ 有序数组在插入方面和普通数组有什么区别？谁快谁慢？ 用Python或Ruby代码实现线性查找和二分查找。 本章涵盖： 有序数组 查找有序数组 二分查找 二分查找与线性查找 上一章我们学习了两种数据结构，并明白了选择合适的数据结构将会显著地提升代码的性能。即使是像数组和集合这样相似的两种数据结构，在高负荷的运行环境下也会表现得天差地别。 在本章，你将会发现，就算数据结构确定了，代码的速度也还会受另一重要因素影响，那就是算法。 算法这个词听起来很深奥，其实不然。它只是解决某个问题的一套流程。准备一碗麦片的流程也可以说是一种算法，它包含以下4步（对我来说是4步吧）。 (1) 拿个碗。(2) 把麦片倒进碗里。(3) 把牛奶倒进碗里。(4) 把勺子放到碗里。 在计算机的世界里，算法则是指某项操作的过程。上一章我们研究了4种主要操作，包括读取、查找、插入和删除。这一章我们还是会经常提到它们，而且一种操作可能会有不止一种做法。 也就是说，一种操作会有多种算法的实现。我们很快会看到不同的算法能使代码变快或者变慢——高负载时甚至慢到停止工作。不过，现在先来认识一种新的数据结构：有序数组。它的查找算法就不止一种，我们将会学习如何选出正确的那种。 有序数组有序数组跟上一章讨论的数组几乎一样，唯一区别就是有序数组要求其值总是保持有序（你猜对了）。即每次插入新值时，它会被插入到适当的位置，使整个数组的值仍然按顺序排列。常规的数组则并不考虑是否有序，直接把值加到末尾也没问题。 以数组[3, 17, 80, 202]为例。 假设这是个常规的数组，你准备将75插入，那就可以把它放到尾端，如下所示。 如上一章所述，计算机只要1步就能完成这种操作。 但如果这是一个有序数组，你就必须要找到一个适当的位置，使插入75之后整个数组依然有序。 做起来可不像说的那么简单。整个过程不可能一步完成，因为计算机需要先找出那个适当的位置，然后将其及以后的值右移来腾出空间给75。下面就来介绍分解的步骤。 先回顾一下原始的数组。 第1步：检查索引0的值，看75应该在它的左边还是右边。 因为75大于3，所以75应该在它右边的某个位置。而具体的位置，目前还是不能确定，于是，再检查下一个格子。 第2步：检查下一格的值。 因为75大于17，所以继续。 第3步：检查下一格的值。 这次是80，大于75。因为这是第一次遇到大于75的值，可想而知，必须把75放在80的左侧以使整个数组维持有序。但要在这里插入75，还得先将它的位置空出来。 第4步：将最后一个值右移。 第5步：将倒数第二个值右移。 第6步：终于可以把75插入到正确的位置上了。 可以看到，往有序数组中插入新值，需要先做一次查找以确定插入的位置。这是它跟常规数组的关键区别（在性能方面）之一。 虽然插入的性能比不上常规数组，但在查找方面，有序数组却有着特殊优势。 查找有序数组上一章介绍了常规数组的查找方式：从左至右，逐个格子检查，直至找到。这种方式称为线性查找。 接下来看看有序数组的线性查找跟常规数组有何不同。 设一个常规数组[17,3,75,202,80]，如果想在里面查找22（其实并不存在），那你就得逐个元素去检查，因为22可能在任何一个位置上。要想在到达末尾之前结束检查，那么所找的值必须在末尾之前出现。 然而对于有序数组来说，即便它不包含要找的值，我们也可以提早停止查找。假设要在有序数组[3,17,75,80,202]里查找22，我们可以在查到75的时候就结束，因为22不可能出现在75的右边。 以下是用Ruby语言实现的有序数组线性查找。1234567891011121314def linear_search(array, value) # 遍历数组的每一个元素 array.each do |element| # 如果这个元素等于我们要找的值，则将其返回 if element == value return value # 如果这个值大于我们要找的值，则提早退出循环 elsif element &gt; value break end end # 如果没找到，则返回空值 return nilend 因此，有序数组的线性查找大多数情况下都会快于常规数组。除非要找的值是最后那个，或者比最后的值还大，那就只能一直查到最后了。 只看到这里的话，可能你还是不会觉得两种数组在性能上有什么巨大区别。 这是因为我们还没释放算法的潜能。这是接下来就要做的。 至今我们提到的查找有序数组的方法就只有线性查找。但其实，线性查找只不过是查找算法的其中一种而已。这种逐个格子检查直至找到为止的过程，并不是查找的唯一途径。 有序数组相比常规数组的一大优势就是它可以使用另一种查找算法。此种算法名为二分查找，它比线性查找要快得多。 二分查找你小时候或许玩过这样一种猜谜游戏（或者现在跟你的小孩玩过）：我心里想着一个1到100之间的数字，在你猜出它之前，我会提示你的答案应该大一点还是小一点。 你应该凭直觉就知道这个游戏的策略。一开始你会先猜处于中间的50，而不是1。为什么？ 因为不管我接下来告诉你更大或是更小，你都能排除掉一半的错误答案！ 如果你说50，然后我提示要再大一点，那么你应该会选75，以排除掉剩余数字的一半。如果在75之后我告诉你要小一点，你就会选62或63。总之，一直都猜中间值，就能不断地缩小一半的范围。 下面来演示这个过程，但仅以1到10为例。 这就是二分查找的通俗描述。 有序数组相比常规数组的一大优势就是它除了可以用线性查找，还可以用二分查找。常规数组因为无序，所以不可能运用二分查找。 为了看出它的实际效果，假设有一个包含9个元素的有序数组。计算机不知道每个格子的值，如下图所示。 然后，用二分查找来找出7，过程如下。 第1步：检查正中间的格子。因为数组的长度是已知的，将长度除以2，我们就可以跳到确切的内存地址上，然后检查其值。 值为9，可推测出7应该在其左边的某个格子里。而且，这下我们也排除了一半的格子，即9右边的那些（以及9本身）。 第2步：检查9左边的那些格子的最中间那个。因为这里最中间有两个，我们就随便挑了左边的。 它的值为4，那么7就在它的右边了。由此4左边的格子也就排除了。 第3步：还剩两个格子里可能有7。我们随便挑个左边的。 第4步：就剩一个了。（如果还没有，那就说明这个有序数组里真的没有7。） 终于找到7了，总共4步。是的，这个有序数组要是用线性查找也会是4步，但稍后你就会见识到二分查找的强大。 以下是二分查找的Ruby实现。1234567891011121314151617181920212223242526272829def binary_search(array, value) # 首先，设定下界和上界，以限定所查之值可能出现的区域。 # 在开始时，以数组的第一个元素为下界，以最后一个元素为上界 lower_bound = 0 upper_bound = array.length - 1 # 循环检查上界和下界之间的最中间的元素 while lower_bound &lt;= upper_bound do # 如此找出最中间的格子之索引 #（无须担心商是不是整数，因为 Ruby 总是把两个整数相除所得的小数部分去掉） midpoint = (upper_bound + lower_bound) / 2 # 获取该中间格子的值 value_at_midpoint = array[midpoint] # 如果该值正是我们想查的，那就完事了。 # 否则，看你是要往上找还是往下找，来调整下界或上界 if value &lt; value_at_midpoint upper_bound = midpoint - 1 elsif value &gt; value_at_midpoint lower_bound = midpoint + 1 elsif value == value_at_midpoint return midpoint end end # 当下界超越上界，便知数组里并没有我们所要找的值 return nilend 二分查找与线性查找对于长度太小的有序数组，二分查找并不比线性查找好多少。但我们来看看更大的数组。 对于拥有100个值的数组来说，两种查找需要的最多步数如下所示。 线性查找：100步 二分查找：7步 用线性查找的话，如果要找的值在最后一个格子，或者比最后一格的值还大，那么就得查遍每个格子。有100个格子，就是100步。 二分查找则会在每次猜测后排除掉一半的元素。100个格子，在第一次猜测后，便排除了50个。 再换个角度来看，你就会发现一个规律。 长度为3的有序数组，二分查找所需的最多步数是2。 若长度翻倍，变成7（以奇数为例会方便选择正中间的格子，于是我们把长度翻倍后又增加了一个数），则最多步数会是3。 若再翻倍（并加1），变成15个元素，那么最多步数会是4。 规律就是，每次有序数组长度乘以2，二分查找所需的最多步数只会加1。 这真是出奇地高效。 相反，在3个元素的数组上线性查找，最多要3步，7个元素就最多要7步，100个元素就最多要100步，即元素有多少，最多步数就是多少。数组长度翻倍，线性查找的最多步数就会翻倍，而二分查找则只是增加1步。 这种规律可以用下图来展示。 如果数组变得更大，比如说10000个元素，那么线性查找最多会有10000步，而二分查找最多只有14步。再增大到1000000个元素，则线性查找最多有1000000步，二分查找最多只有20步。 不过还要记住，有序数组并不是所有操作都比常规数组要快。如你所见，它的插入就相对要慢。衡量起来，虽然插入是慢了一些，但查找却快了许多。还是那句话，你得根据应用场景来判断哪种更合适。 总结关于算法的内容就是这些。很多时候，计算一样东西并不只有一种方法，换种算法可能会极大地影响程序的性能。 同时你还应意识到，世界上并没有哪种适用于所有场景的数据结构或者算法。你不能因为有序数组能使用二分查找就永远只用有序数组。在经常插入而很少查找的情况下，显然插入迅速的常规数组会是更好的选择。 如之前所述，比较算法的方式就是比较各自的步数。 下一章，我们将会学习如何规范地描述数据结构和算法的时间复杂度。有了这种通用的表达方式，就能更容易地观察出哪种算法符合我们的实际需求。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-数据结构为何重要]]></title>
    <url>%2F2018%2F05%2F25%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BD%95%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数据结构是什么？为什么重要？举几个数据结构。 内存是什么样子的？ 数组读取为什么快？ 什么是线性查找？在含有N个元素的数组上进行线性查找最多要多少步呢？ 一个含有N个元素的数组，其插入数据的最好情况会花费多少步？最坏呢？ 一个含有N个元素的数组，其删除数据的最好情况会花费多少步？最坏呢？ 集合作为不重复的数组在插入上与数组有什么区别？ 什么是时间复杂度？ 本章涵盖： 基础数据结构：数组 读取 查找 插入 删除 集合：一条规则决定性能 总结 哪怕只写过几行代码的人都会发现，编程基本上就是在跟数据打交道。计算机程序总是在接收数据、操作数据或返回数据。不管是求两数之和的小程序，还是管理公司的企业级软件，都运行在数据之上。 数据是一个广义的术语，可以指代各种类型的信息，包括最基本的数字和字符串。在经典的“Hello World!”这个简单程序中，字符串“Hello World!”就是一条数据。事实上，无论是多么复杂的数据，我们都可以将其拆成一堆数字和字符串来看待。 数据结构则是指数据的组织形式。看看以下代码。12345x = "Hello!"y = "How are you"z = "today?"print(x + y + z) 这个非常简单的程序把3条数据串成了一句连贯的话。如果要描述该程序中的数据结构，我们会说，这里有3个独立的变量，分别引用着3个独立的字符串。 但数据结构不只是用于组织数据，它还极大地影响着代码的运行速度。因为数据结构不同，程序的运行速度可能相差多个数量级。如果你写的程序要处理大量的数据，或者要让数千人同时使用，那么你采用何种数据结构，将决定它是能够运行，还是会因为不堪重负而崩溃。 一旦对各种数据结构有了深刻的理解，并明白它们对程序性能方面的影响，你就能写出快速而优雅的代码，从而使软件运行得快速且流畅。当然，你的编程技能也会更上一层楼。 本章接下来将会分析两种数据结构：数组和集合。它们从表面上看好像差不多，但通过即将介绍的分析工具，你将会观察到它们在性能上的差异。 基础数据结构：数组数组是计算机科学中最基本的数据结构之一。如果你用过数组，那么应该知道它就是一个含有数据的列表。它有多种用途，适用于各种场景，下面就举个简单的例子。 一个允许用户创建和使用购物清单的食杂店应用软件，其源代码可能会包含以下的片段。1array = ["apples", "bananas", "cucumbers", "dates", "elderberries"] 这就是一个数组，它刚好包含5个字符串，每个代表我会从超市买的食物。 此外，我们会用一些名为索引的数字来标识每项数据在数组中的位置。 在大多数的编程语言中，索引是从0算起的，因此在这个例子中，“apples”的索引为0，“elderberries”的索引为4，如下所示。 若想了解某个数据结构（例如数组）的性能，得分析程序怎样操作这一数据结构。 一般数据结构都有以下4种操作（或者说用法）。 读取：查看数据结构中某一位置上的数据。对于数组来说，这意味着查看某个索引所指的数据值。例如，查看索引2上有什么食品，就是一种读取。 查找：从数据结构中找出某个数据值的所在。对于数组来说，这意味着检查其是否包含某个值，如果包含，那么还得给出其索引。例如，检查“dates”是否存在于食品清单之中，给出其对应的索引，就是一种查找。 插入：给数据结构增加一个数据值。对于数组来说，这意味着多加一个格子并填入一个值。例如，往购物清单中多加一项“figs”，就是一种插入。 删除：从数据结构中移走一个数据值。对于数组来说，这意味着把数组中的某个数据项移走。例如，把购物清单中的“bananas”移走，就是一种删除。 本章我们将会研究这些操作在数组上的运行速度。 同时，我们也将学到本书的第一个重要理论：操作的速度，并不按时间计算，而是按步数计算。 为什么呢？ 因为，你不可能很绝对地说，某项操作要花5秒。它在某台机器上要跑5秒，但换到一台旧一点的机器，可能就要多于5秒，而换到一台未来的超级计算机，运行时间又将显著缩短。所以，受硬件影响的计时方法，非常不可靠。 然而，若按步数来算，则确切得多。如果A操作要5步，B操作要500步，那么我们可以很肯定地说，无论是在什么样的硬件上对比，A都快过B。因此，衡量步数是分析速度的关键。 此外，操作的速度，也常被称为时间复杂度。在本书中，我们会提到速度、时间复杂度、效率、性能，但它们其实指的都是步数。 事不宜迟，我们现在就来探索上述4种操作方式在数组上要花多少步。 读取首先看看读取，即查看数组中某个索引所指的数据值。 这只要一步就够了，因为计算机本身就有跳到任一索引位置的能力。在 [“apples”, “bananas”, “cucumbers”, “dates”, “elderberries”]的例子中，如果要查看索引2的值，那么计算机就会直接跳到索引2，并告诉你那里有“cucumbers”。 计算机为什么能一步到位呢？原因如下。 计算机的内存可以被看成一堆格子。下图是一片网格，其中有些格子有数据，有些则是空白。 当程序声明一个数组时，它会先划分出一些连续的空格子以备使用。换句话说，如果你想创建一个包含5个元素的数组，计算机就会找出5个排成一行的空格子，将其当成数组。 内存中的每个格子都有各自的地址，就像街道地址，例如大街123号。不过内存地址就只用一个普通的数字来表示。而且，每个格子的内存地址都比前一个大1，如下图所示。 购物清单数组的索引和内存地址，如下图所示。 计算机之所以在读取数组中某个索引所指的值时，能直接跳到那个位置上，是因为它具备以下条件。 (1)计算机可以一步就跳到任意一个内存地址上。（就好比，要是你知道大街123号在哪儿，那么就可以直奔过去。） (2)数组本身会记有第一个格子的内存地址，因此，计算机知道这个数组的开头在哪里。 (3)数组的索引从0算起。 回到刚才的例子，当我们叫计算机读取索引3的值时，它会做以下演算。 (1)该数组的索引从0算起，其开头的内存地址为1010。 (2)索引3在索引0后的第3个格子上。 (3)于是索引3的内存地址为1013，因为1010 + 3 = 1013。 当计算机一步跳到1013时，我们就能获取到“dates”这个值了。 所以，数组的读取是一种非常高效的操作，因为它只要一步就好。一步自然也是最快的速度。这种一步读取任意索引的能力，也是数组好用的原因之一。 如果我们问的不是“索引3有什么值”，而是“”dates”在不在数组里”，那么这就需要进行查找操作了。下面我们就来看看。 查找如前所述，对于数组来说，查找就是检查它是否包含某个值，如果包含，还得给出其索引。那么，我们就试试在数组中查找“dates”要用多少步。 对于我们人来说，可以一眼就看到这个购物清单上的“dates”，并数出它的索引为3。但是，计算机并没有眼睛，它只能一步一步地检查整个数组。 想要查找数组中是否存在某个值，计算机会先从索引0开始，检查其值，如果不匹配，则继续下一个索引，以此类推，直至找到为止。 我们用以下图来演示计算机如何从购物清单中查找“dates”。 首先，计算机检查索引0。 因为索引0的值是“apples”，并非我们所要的“dates”，所以计算机跳到下一个索引上。 索引1也不是“dates”，于是计算机再跳到索引2。 但索引2的值仍不匹配，计算机只好再跳到下一格。 啊，真是千辛万苦，我们找到“dates”了，它就在索引3那里。自此，计算机不用再往后跳了，因为结果已经得到。 在这个例子中，因为我们检查了4个格子才找到想要的值，所以这次操作总计是4步。 这种逐个格子去检查的做法，就是最基本的查找方法--线性查找。第2章我们还会学习另一种查找方法。 但在那之前，我们再思考一下，在数组上进行线性查找最多要多少步呢？ 如果我们要找的值刚好在数组的最后一个格子里（如本例的elderberries），那么计算机从头到尾检查每个格子，会在最后才找到。同样，如果我们要找的值并不存在于数组中，那么计算机也还是得查遍每个格子，才能确定这个值不在数组中。 于是，一个5格的数组，其线性查找的步数最大值是5，而对于一个500格的数组，则是500。 以此类推，一个N格的数组，其线性查找的最多步数是N（N可以是任何自然数）。 可见，无论是多长的数组，查找都比读取要慢，因为读取永远都只需要一步，而查找却可能需要多步。 接下来，我们再研究一下插入，准确地说，是插入一个新值到数组之中。 插入往数组里插入一个新元素的速度，取决于你想把它插入到哪个位置上。 假设我们想要在购物清单的末尾插入“figs”。那么只需一步。因为之前说过了，计算机知道数组开头的内存地址，也知道数组包含多少个元素，所以可以算出要插入的内存地址，然后一步跳到那里插入就行了。图示如下。 但在数组开头或中间插入，就另当别论了。这种情况下，我们需要移动其他元素以腾出空间，于是得花费额外的步数。 例如往索引2处插入”figs”，如下所示。 为了达到目的，我们必须先把“cucumbers”、“dates”和“elderberries”往右移，以便空出索引2。而这也不是一步就能移好，因为我们首先要将“elderberries”右移一格，以空出位置给“dates”，然后再将“dates”右移，以空出位置给“cucumbers”，下面来演示这个过程。 第1步：“elderberries”右移。 第2步：“date”右移。 第3步：“cucembers”右移。 第4步：至此，可以在索引2处插入“figs”了。 如上所示，整个过程有4步，开始3步都是在移动数据，剩下1步才是真正的插入数据。 最低效（花费最多步数）的插入是插入在数组开头。因为这时候需要把数组所有的元素都往右移。 于是，一个含有N个元素的数组，其插入数据的最坏情况会花费N + 1步。即插入在数组开头，导致N次移动，加上一次插入。 最后要说的“删除”，则相当于插入的反向操作。 删除数组的删除就是消掉其某个索引上的数据。 我们找回最开始的那个数组，删除索引2上的值，即“cucumbers”。 第1步：删除“cucumbers”。 虽然删除“cucumbers”好像一步就搞定了，但这带来了新的问题：数组中间空出了一个格子。因为数组中间是不应该有空格的，所以，我们得把“dates”和“elderberries”往左移。 第2步：将”dates”左移。 第3步：将”elderberries”左移。 结果，整个删除操作花了3步。其中第1步是真正的删除，剩下的2步是移数据去填空格。 所以，删除本身只需要1步，但接下来需要额外的步骤将数据左移以填补删除所带来的空隙。 跟插入一样，删除的最坏情况就是删掉数组的第一个元素。因为数组不允许空元素，当索引0空出，那么剩下的所有元素都要往左移去填空。 对于含有5个元素的数组，删除第一个元素需要1步，左移剩余的元素需要4步。而对于500个元素的数组，删除第一个元素需要1步，左移剩余的元素需要499步。可以推出，对于含有N个元素的数组，删除操作最多需要N步。 既然学会了如何分析数据结构的时间复杂度，那就可以开始探索各种数据结构的性能差异了。了解这些非常重要，因为数据结构的性能差异会直接造成程序的性能差异。 下一个要介绍的数据结构是集合，它跟数组似乎很像，甚至让人以为就是同一种东西。然而，我们将会看到它跟数组在性能上是有区别的。 集合：一条规则决定性能来看看另一种数据结构：集合。它是一种不允许元素重复的数据结构。 其实集合是有不同形式的，但现在我们只讨论基于数组的那种。这种集合跟数组差不多，都是一个普通的元素列表，唯一的区别在于，集合不允许插入重复的值。 要是你想往集合[“a”, “b”, “c”]再插入一个“b”，计算机是不会允许的，因为集合中已经有“b”了。 集合就是用于确保数据不重复。 如果你要创建一个线上电话本，你应该不会希望相同的号码出现两次吧。如果这个电话本程序用集合来处理，那就不会搞出这种麻烦了。 总之，集合就是一个带有“不允许重复”这种简单限制的数组。而该限制也导致它在4种基本操作中有1种与数组性能不同。 下面就来分析读取、查找、插入和删除在基于数组的集合上表现如何。 集合的读取跟数组的读取完全一样，计算机只要一步就能获取指定索引上的值。如之前解释的那样，这是因为计算机知道集合开头的内存地址，所以能够一步跳到集合的任意索引。 集合的查找也跟数组的查找无异，需要N步去检查某个值在不在集合当中。删除也是，总共需要N步去删除和左移填空。 但插入就不同了。先看看在集合末尾的插入。对于数组来说，末尾插入是最高效的，它只需要1步。 而对于集合，计算机得先确定要插入的值不存在于其中--因为这就是集合：不允许重复值。于是每次插入都要先来一次查找。 假设我们的购物清单是一个集合--用集合还是不错的，毕竟你不会想买重复的东西。如果当前集合是[“apples”, “bananas”, “cucumbers”, “dates”, “elderberries”]，然后想插入“figs”，那么就需要做一次如下的查找。 第1步：检查索引0有没有“figs”。 没有，不过说不定其他索引会有。为了在真正插入前确保它不存在于任何索引上，我们继续。 第2步：检查索引1。 第3步：检查索引2。 第4步：检查索引3。 第5步：检查索引4。 直到检查完整个集合，才能确定插入“figs”是安全的。于是，到最后一步。 第6步：在集合末尾插入“figs”。 在集合的末尾插入也属于最好的情况，不过对于一个含有5个元素的集合，你仍然要花6步。因为，在最终插入的那一步之前，要把5个元素都检查一遍。 换句话说，在N个元素的集合中进行插入的最好情况需要N+1步--N步去确认被插入的值不在集合中，加上最后插入的1步。 最坏的情况则是在集合的开头插入，这时计算机得检查N个格子以保证集合不包含那个值，然后用N步来把所有值右移，最后再用1步来插入新值。总共2N+1步。 这是否意味着因为它的插入比一般的数组慢，所以就不要用了呢？当然不是。在需要保证数据不重复的场景中，集合是非常重要的。但如果没有这种需求，那么选择插入比集合快的数组会更好一些。具体哪种数据结构更合适，当然要根据你的实际应用场景而定。 总结理解数据结构的性能，关键在于分析操作所需的步数。采取哪种数据结构将决定你的程序是能够承受住压力，还是崩溃。本章特别讲解了如何通过步数分析来判断某种应用该选择数组还是集合。 不同的数据结构有不同的时间复杂度，类似地，不同的算法（即使是用在同一种数据结构上）也有不同的时间复杂度。既然我们已经学会了时间复杂度的分析方法，那么现在就可以用它来对比各种算法，找出能够发挥代码极限性能的那个。这正是下一章所要讲的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx负载均衡与高可用]]></title>
    <url>%2F2018%2F04%2F07%2FNginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 正向代理Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的Internet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。 负载均衡客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 配置可以将nginx.conf配置文件分为三部分： 第一部分：全局块 从配置文件开始到events块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户（组）、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。 比如第一行配置的：1worker_processes 1; 这是Nginx服务器并发处理服务的关键配置，worker_processes值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。 第二部分：events块 123events&#123; worker_connections 1024;&#125; events块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。 上述例子就表示每个work process支持的最大连接数为1024。 这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置。 第三部分：http块 123456789101112131415161718192021222324http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 这算是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http块也可以包括http全局块、server块。 ①http全局块 http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。 ②server块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。 而每个server块也分为全局server块，以及可以同时包含多个locaton块。 1、全局server块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 2、location块 一个server块可以配置多个location块。 这块的主要作用是基于Nginx服务器接收到的请求字符串（例如server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 配置实例-反向代理实例一 实现效果：使用nginx反向代理，访问www.123.com直接跳转到127.0.0.1:8080 123456789server&#123; listen 80; server_name www.123.com; location / &#123; proxy_pass http://127.0.0.1:8080; index index.html index.htm index.jsp; &#125;&#125; 实例二 实现效果：使用nginx反向代理，根据访问的路径跳转到不同端口的服务中。 nginx监听端口为9001访问http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8001访问http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8002 123456789101112server&#123; listen 9001; server_name localhost; location ~ /edu/ &#123; proxy_pass http://localhost:8001; &#125; location ~ /vod/ &#123; proxy_pass http://localhost:8002; &#125;&#125; location指令说明 该指令用于匹配URL。语法如下：123location [ = | ~ | ~* | ^~ ] uri&#123;&#125; 1、=：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。2、~：用于表示uri包含正则表达式，并且区分大小写。3、~*：用于表示uri包含正则表达式，并且不区分大小写。4、\^~：用于不含正则表达式的uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。 注意：如果uri包含正则表达式，则必须要有~或者~*标识。 配置实例-负载均衡实现效果：配置负载均衡 123456789101112131415161718http&#123; ... upstream myserver&#123; ip_hash; server 115.28.52.63:8080 weight=1; server 115.28.52.63:8180 weight=1; &#125; ... server&#123; location / &#123; ... proxy_pass http://myserver; proxy_connect_timeout 10; &#125; ... &#125;&#125; 随着互联网信息的爆炸性增长，负载均衡（load balance）已经不再是一个很陌生的话题，顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx就是其中的一个，在linux下有Nginx、LVS、Haproxy等等服务可以提供负载均衡服务，而且Nginx提供了几种分配方式（策略）： 1、轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 2、weight weight代表权重，默认为1，权重越高被分配的客户端越多指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如：1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10;&#125; 3、ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如：12345upstream server_pool &#123; ip_hash ; server 192.168.5.21:80; server 192.168.5.22:80;&#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream server_pool &#123; server 192.168.5.21:80; server 192.168.5.22:80; fair ;&#125; 配置实例-动静分离Nginx动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过location指定不同的后缀名实现不同的请求转发。通过expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体Expires定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用Expires来缓存），我这里设置3d，表示在这3天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200。 1234567891011121314server&#123; listen 9001; server_name 192.168.17.129; location /www/ &#123; root /data/; index index.html index.htm; &#125; location /image/ &#123; root /data/; autoindex on; &#125;&#125; 重点是添加location 最后检查Nginx配置是否正确即可，然后测试动静分离是否成功，之需要删除后端tomcat服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源nginx直接返回了，不走后端tomcat服务器 Nginx原理与优化参数配置 master-workers的机制的好处 首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。 需要设置多少个worker Nginx 同 redis 类似都采用了io多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个 cpu的性能发挥到极致。所以worker数和服务器的cpu数相等是最为适宜的。设少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的损耗。123456# 设置 worker 数量。worker_processes 4#work 绑定 cpu(4 work 绑定 4cpu)。worker_cpu_affinity 0001 0010 0100 1000#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。worker_cpu_affinity 0000001 00000010 00000100 00001000 连接数worker_connection 这个值是表示每个worker进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求 本 地 资 源 来 说 ， 能够支持的最大并发数量是worker_connections * worker_processes，如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes/2，而如果是HTTP作为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。 Nginx搭建高可用集群Keepalived+Nginx高可用集群（主从模式）&lt;/span&gt; Keepalived+Nginx高可用集群（双主模式）&lt;/span&gt;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
