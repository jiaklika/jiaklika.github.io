<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  这种可以把一种类型替换为满足同一接口的另一种类型的特性称为可取代性（substitutability），这也是面向对象语言的典型特征。怎么理解？">
<meta name="keywords" content="Go程序设计语言">
<meta property="og:type" content="article">
<meta property="og:title" content="第7章 接口">
<meta property="og:url" content="http://yoursite.com/2021/08/16/第7章-接口/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  这种可以把一种类型替换为满足同一接口的另一种类型的特性称为可取代性（substitutability），这也是面向对象语言的典型特征。怎么理解？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/08/16/第7章-接口/1.png">
<meta property="og:image" content="http://yoursite.com/2021/08/16/第7章-接口/2.png">
<meta property="og:image" content="http://yoursite.com/2021/08/16/第7章-接口/3.png">
<meta property="og:image" content="http://yoursite.com/2021/08/16/第7章-接口/4.png">
<meta property="og:image" content="http://yoursite.com/2021/08/16/第7章-接口/6.png">
<meta property="og:updated_time" content="2022-03-30T01:38:19.921Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第7章 接口">
<meta name="twitter:description" content="思考并回答以下问题：  这种可以把一种类型替换为满足同一接口的另一种类型的特性称为可取代性（substitutability），这也是面向对象语言的典型特征。怎么理解？">
<meta name="twitter:image" content="http://yoursite.com/2021/08/16/第7章-接口/1.png">






  <link rel="canonical" href="http://yoursite.com/2021/08/16/第7章-接口/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第7章 接口 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/16/第7章-接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第7章 接口

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-16 10:51:42" itemprop="dateCreated datePublished" datetime="2021-08-16T10:51:42+08:00">2021-08-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-03-30 09:38:19" itemprop="dateModified" datetime="2022-03-30T09:38:19+08:00">2022-03-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">47k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">42 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>这种可以把一种类型替换为满足同一接口的另一种类型的特性称为可取代性（substitutability），这也是面向对象语言的典型特征。怎么理解？</li>
</ul>
<a id="more"></a>
<p>接口类型是对其他类型行为的概括与抽象。通过使用接口，我们可以写出更加灵活和通用的函数，这些函数不用绑定在一个特定的类型实现上。</p>
<p>很多面向对象的语言都有接口这个概念，Go语言的接口的独特之处在于它是隐式实现。换句话说，对于一个具体的类型，无须声明它实现了哪些接口，只要提供接口所必需的方法即可。这种设计让你无须改变已有类型的实现，就可以为这些类型创建新的接口，对于那些不能修改包的类型，这一点特别有用。</p>
<p>本章首先会介绍接口类型的基本机制。然后会讨论标准库中的几种重要接口。因为在很多Go程序中，相对于新创建的接口，标准库中的接口使用得并不少。最后，我们还要了解一下类型断言（见7.10节）以及类型分支（见7.13节），以及它们如何实现另一种类型的通用化。</p>
<h1 id="接口即约定"><a href="#接口即约定" class="headerlink" title="接口即约定"></a><span style="color:#339AFF;">接口即约定</span></h1><p>之前介绍的类型都是具体类型。具体类型指定了它所含数据的精确布局，还暴露了基于这个精确布局的内部操作。比如对于数值有算术操作，对于slice类型我们有索引、append、range等操作。具体类型还会通过其方法来提供额外的能力。总之，如果你知道了一个具体类型的数据，那么你就精确地知道了它是什么以及它能干什么。</p>
<p>Go语言中还有另外一种类型称为接口类型。接口是一种抽象类型，它并没有暴露所含数据的布局或者内部结构，当然也没有那些数据的基本操作，它所提供的仅仅是一些方法而已。如果你拿到一个接口类型的值，你无从知道它是什么，你能知道的仅仅是它能做什么，或者更精确地讲，仅仅是它提供了哪些方法。</p>
<p>本书通篇使用两个类似的函数实现字符串的格式化：<code>fmt.Printf</code>和<code>fmt.Sprintf</code>。前者把结果发到标准输出（标准输出其实是一个文件），后者把结果以string类型返回。格式化是两个函数中最复杂的部分，如果仅仅因为两个函数在输出方式上的轻微差异，就需要把格式化部分在两个函数中重复一遍，那么就太糟糕了。幸运的是，通过接口机制可以解决这个问题。其实，两个函数都封装了第三个函数<code>fmt.Fprintf</code>，而这个函数对结果实际输出到哪里毫不关心：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">int</span>,error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintf(os.Stdout, format, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    Fprintf(&amp;buf, format, args...)</span><br><span class="line">    <span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fprintf的前缀F指文件，表示格式化的输出会写入第一个实参所指代的文件。对于Printf，第一个实参就是<code>os.Stdout</code>，它属于<code>*os.File</code>类型。对于Sprintf，尽管第一个实参不是文件，但它模拟了一个文件：&amp;buf就是一个指向内存缓冲区的指针，与文件类似，这个缓冲区也可以写入多个字节。</p>
<p>其实Fprintf的第一个形参也不是文件类型，而是<code>io.Writer</code>接口类型，其声明如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer接口封装了基础的写入方法</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Write从p向底层数据流写入len(p)个字节的数据</span></span><br><span class="line">    <span class="comment">// 返回实际写入的字节数（0≤n≤len(p)）</span></span><br><span class="line">    <span class="comment">// 如果没有写完，那么会返回遇到的错误</span></span><br><span class="line">    <span class="comment">// 在Write返回n＜len(p)时，err必须为非nil</span></span><br><span class="line">    <span class="comment">// Write不允许修改p的数据，即使是临时修改</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 实现时不允许残留p的引用</span></span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>io.Writer</code>接口定义了Fprintf和调用者之间的约定。一方面，这个约定要求调用者提供的具体类型（比如<code>*os.File</code>或者<code>*bytes.Buffer</code>）包含一个与其签名和行为一致的Write方法。另一方面，这个约定保证了Fprintf能使用任何满足<code>io.Writer</code>接口的参数。Fprintf只需要能调用参数的Write函数，无须假设它写入的是一个文件还是一段内存。</p>
<p>因为<code>fmt.Fprintf</code>仅依赖于<code>io.Writer</code>接口所约定的方法，对参数的具体类型没有要求，所以我们可以用任何满足<code>io.Writer</code>接口的具体类型作为<code>fmt.Fprintf</code>的第一个实参。这种可以把一种类型替换为满足同一接口的另一种类型的特性称为<span style="color:red">可取代性</span>（substitutability），这也是面向对象语言的典型特征。</p>
<p>让我们创建一个新类型来测试这个特性。如下所示的<code>*ByteCounter</code>类型的Write方法仅仅统计传入数据的字节数，然后就不管那些数据了。（下面的代码中出现的类型转换是为了让<code>len(p)</code>和<code>*c</code>满足+=操作。）<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteCounter <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ByteCounter)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    *c += ByteCounter(<span class="built_in">len</span>(p)) <span class="comment">// 转换int为ByteCounter类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为<code>*ByteCounter</code>满足<code>io.Writer</code>接口的约定，所以可以在Fprintf中使用它，Fprintf察觉不到这种类型差异，ByteCounter也能正确地累积格式化后结果的长度。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c ByteCounter</span><br><span class="line"></span><br><span class="line">c.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(c)<span class="comment">// "5", =len("hello")</span></span><br><span class="line">c = <span class="number">0</span> <span class="comment">// 重置计数器</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Dolly"</span></span><br><span class="line">fmt.Fprintf(&amp;c,<span class="string">"hello, %s"</span>, name)</span><br><span class="line">fmt.Println(c) <span class="comment">// "12", =len("hello, Dolly")</span></span><br></pre></td></tr></table></figure></p>
<p>除了<code>io.Writer</code>之外，fmt包还有另一个重要的接口。Fprintf和Fprintln提供了一个让类型控制如何输出自己的机制。在2.5节中，给Celsius类型定义了一个String方法，这样可以输出“100°C”这样的结果。在6.5节中，也给<code>*IntSet</code>类型加了一个String方法，这样可以输出类似“{1 2 3}”的传统集合表示形式。定义一个String方法就可以让类型满足这个广泛使用的接口<code>fmt.Stringer</code>：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"><span class="comment">// 在字符串格式化时如果需要一个字符串</span></span><br><span class="line"><span class="comment">// 那么就调用这个方法来把当前值转化为字符串</span></span><br><span class="line"><span class="comment">// Print这种不带格式化参数的输出方式也是调用这个方法</span></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.10节会解释fmt包如何发现哪些值满足这个接口。</p>
<p>练习7.1：使用类似ByteCounter的想法，实现单词和行的计数器。实现时考虑使用<code>bufio.ScanWords</code>。</p>
<p>练习7.2：实现一个满足如下签名的CountingWriter函数，输入一个<code>io.Writer</code>，输出一个封装了输入值的新Writer，以及一个指向int64的指针，该指针对应的值是新的Writer写入的字节数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountingWriter</span><span class="params">(w io.Writer)</span><span class="params">(io.Writer, *<span class="keyword">int64</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>练习7.3：为gopl.io/ch4/treesort中的<code>*tree</code>类型（见4.4节）写一个String方法，用于展示其中的值序列。</p>
<h1 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a><span style="color:#339AFF;">接口类型</span></h1><p>一个接口类型定义了一套方法，如果一个具体类型要实现该接口，那么必须实现接口类型定义中的所有方法。</p>
<p>io.Writer是一个广泛使用的接口，它负责所有可以写入字节的类型的抽象，包括文件、内存缓冲区、网络连接、HTTP客户端、打包器（archiver）、散列器（hasher）等。io包还定义了很多有用的接口。Reader就抽象了所有可以读取字节的类型，Closer抽象了所有可以关闭的类型，比如文件或者网络连接。（现在你大概已经注意到Go语言的单方法接口的命名约定了。）<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，我们还可以发现通过组合已有接口得到的新接口，比如下面两个例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上的语法称为嵌入式接口，与嵌入式结构类似，让我们可以直接使用一个接口，而不用逐一写出这个接口所包含的方法。如下所示，尽管不够简洁，但是可以不用嵌入式来声明<code>io.ReadWriter</code>：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以混合使用两种方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三种声明的效果都是一致的。方法定义的顺序也是无意义的，真正有意义的只有接口的方法集合。</p>
<p>练习7.4：<code>strings.NewReader</code>函数输入一个字符串，返回一个从字符串读取数据且满足<code>io.Reader</code>接口（也满足其他接口）的值。请自己实现该函数，并且通过它来让HTML分析器（参考5.2节）支持以字符串作为输入。</p>
<p>练习7.5：io包中的LimitReader函数接受<code>io.Reader r</code>和字节数n，返回一个Reader，该返回值从r读取数据，但在读取n字节后报告文件结束。请实现该函数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r io.Reader, n <span class="keyword">int64</span>)</span> <span class="title">io</span>.<span class="title">Reader</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a><span style="color:#339AFF;">实现接口</span></h1><p>如果一个类型实现了一个接口要求的所有方法，那么这个类型实现了这个接口。比如<code>*os.File</code>类型实现了io.Reader、Writer、Closer和ReadWriter接口。<code>*bytes.Buffer</code>实现了Reader、Writer和ReadWriter，但没有实现Closer，因为它没有Close方法。为了简化表述，Go程序员通常说一个具体类型“是一个”（is-a）特定的接口类型，这其实代表着该具体类型实现了该接口。比如，<code>*bytes.Buffer</code>是一个<code>io.Writer</code>；<code>*os.File</code>是一个<code>io.ReadWriter</code>。</p>
<p>接口的赋值规则（参考2.4.2节）很简单，仅当一个表达式实现了一个接口时，这个表达式才可以赋给该接口。所以：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout         <span class="comment">// 0K：*os.File有Write方法</span></span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// 0K：*bytes.Buffer有Write方法</span></span><br><span class="line">w = time.Second       <span class="comment">// 编译错误：time.Duration缺少Write方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwc io.ReadWriteCloser</span><br><span class="line">rwc = os.Stdout         <span class="comment">// 0K：*os.File有Read、Write、Close方法</span></span><br><span class="line">rwc = <span class="built_in">new</span>(bytes.Buffer) <span class="comment">// 编译错误：*bytes.Buffer缺少Close方法</span></span><br></pre></td></tr></table></figure></p>
<p>当右侧表达式也是一个接口时，该规则也有效；<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = rwc <span class="comment">// 0K：io.ReadWriteCloser有Write方法</span></span><br><span class="line">rwc = w <span class="comment">// 编译错误：io.Writer缺少Close方法</span></span><br></pre></td></tr></table></figure></p>
<p>因为ReadWriter和ReadWriterCloser接口包含了Writer的所有方法，所以任何实现了ReadWriter或ReadWriterCloser类型的方法都必然实现了Writer。</p>
<p>在进一步讨论之前，我们先解释一下一个类型有某一个方法的具体含义。6.2节曾提到，对每一个具体类型T，部分方法的接收者就是T，而其他方法的接收者则是<code>*T</code>指针。同时我们对类型T的变量直接调用<code>*T</code>的方法也可以是合法的，只要改变量是可变的，编译器隐式地帮你完成了取地址的操作。但这仅仅是一个语法糖，类型T的方法没有对应的指针<code>*T</code>多，所以实现的接口也可能比对应的指针少。</p>
<p>比如，6.5节提到的IntSet类型的String方法，需要一个指针接收者，所以我们无法从一个无地址的IntSet值上调用该方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSet <span class="keyword">struct</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*IntSet)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> _ = <span class="title">IntSet</span></span>&#123;&#125;.String() <span class="comment">// 编译错误：String方法需要*IntSet接收者</span></span><br></pre></td></tr></table></figure></p>
<p>但可以从一个IntSet变量上调用该方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s IntSet</span><br><span class="line"><span class="keyword">var</span> _ = s.String() <span class="comment">// 0K：s是一个变量，&amp;s有String方法</span></span><br></pre></td></tr></table></figure></p>
<p>因为只有<code>*IntSet</code>有String方法，所以也只有<code>*IntSet</code>实现了<code>fmt.Stringer</code>接口：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ fmt.Stringer = &amp;s <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">var</span> _ fmt.Stringer = s  <span class="comment">// 编译错误：IntSet缺少String方法</span></span><br></pre></td></tr></table></figure></p>
<p>在12.8节，有一个程序可以输出一个任意值的方法，<code>godoc-annalysis=type</code>工具（见10.7.4节）也可以显示每个类型的方法，以及接口和具体类型的关系。</p>
<p>正如信封封装了信件，接口也封装了所对应的类型和数据，只有通过接口暴露的方法才可以调用，类型的其他方法则无法通过接口来调用：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">os.Stdout.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>)) <span class="comment">// 0K：*os.File有Write方法</span></span><br><span class="line">os.Stdout.Close()                <span class="comment">// 0K：*os.File有Close方法</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>)) <span class="comment">// 0K：io.Writer有Write方法</span></span><br><span class="line">w.Close()                <span class="comment">// 编译错误：io.Writer缺少Close方法</span></span><br></pre></td></tr></table></figure></p>
<p>一个拥有更多方法的接口，比如<code>io.ReadWriter</code>，与<code>io.Reader</code>相比，给了我们它所指向数据的更多信息，当然也给实现这个接口提出更高的门槛。那么对于接口类型interface{}，它完全不包含任何方法，通过这个接口能得到对应具体类型的什么信息呢？</p>
<p>确实什么信息也得不到。看起来这个接口没有任何用途，但实际上称为空接口类型的interface{}是不可缺少的。正因为空接口类型对其实现类型没有任何要求，所以我们可以把任何值赋给空接口类型。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">any = <span class="literal">true</span></span><br><span class="line">any = <span class="number">12.34</span></span><br><span class="line">any = <span class="string">"hello"</span></span><br><span class="line">any = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>:<span class="number">1</span>&#125;</span><br><span class="line">any = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure></p>
<p>其实在本书的第一个示例中就用了空接口类型，靠它才可以让<code>fmt.Println</code>、errorf（参考5.7节）这类的函数能够接受任意类型的参数。</p>
<p>当然，即使我们创建了一个指向布尔值、浮点数、字符串、map、指针或者其他类型的interface{}接口，也无法直接使用其中的值，毕竟这个接口不包含任何方法。我们需要一个方法从空接口中还原出实际值，在7.10节中我们可以看到如何用类型断言来实现该功能。</p>
<p>判定是否实现接口只需要比较具体类型和接口类型的方法，所以没有必要在具体类型的定义中声明这种关系。也就是说，偶尔在注释中标注也不坏，但对于程序来讲，这种关系声明不是必需的。如下声明在编译器就断言了<code>*byte.Buffer</code>类型的一个值必然实现了<code>io.Writer</code>：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *bytes.Buffer必须实现io.Writer</span></span><br><span class="line"><span class="keyword">var</span> w io.Writer = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure></p>
<p>我们甚至不需要创建一个新的变量，因为<code>*bytes.Buffer</code>的任意值都实现了这个接口，甚至nil，在我们用<code>(*bytes.Buffer)(nil)</code>来强制类型转换后，也实现了这个接口。当然，既然我们不想引用w，那么我们可以把它替换为空白标识符。基于这两点，修改后的代码可以节省不少变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *bytes.Buffer必须实现io.Writer</span></span><br><span class="line"><span class="keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<p>非空的接口类型（比如<code>io.Writer</code>）通常由一个指针类型来实现，特别是当接口类型的一个或多个方法暗示会修改接收者的情形（比如Write方法）。一个指向结构的指针才是最常见的方法接收者。</p>
<p>指针类型肯定不是实现接口的唯一类型，即使是那些包含了会改变接收者方法的接口类型，也可以由Go的其他引用类型来实现。我们已经见过slice类型的方法（<code>geometry.Path</code>，参考6.1节），以及map类型的方法（<code>url.Values</code>，参考6.2.1节），稍后我们还可以看到函数类型的方法（<code>http.HandlerFunc</code>，参考7.7节）。基础类型也可以实现方法，比如我们会在7.4节见到的<code>time.Duration</code>类型实现了<code>fmt.Stringer</code>。</p>
<p>一个具体类型可以实现很多不相关的接口。比如一个程序管理或者销售数字文化商品，比如音乐、电影和图书。那么它可能定义了如下具体类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Album</span><br><span class="line">Book</span><br><span class="line">Movie</span><br><span class="line">Magazine</span><br><span class="line">Podcast</span><br><span class="line">TVEpisode</span><br><span class="line">Track</span><br></pre></td></tr></table></figure></p>
<p>我们可以把感兴趣的每一种抽象都用一种接口类型来表示。一些属性是所有商品都具备的，比如标题、创建日期以及创建者列表（作者或者艺术家）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Artifact <span class="keyword">interface</span> &#123;</span><br><span class="line">    Title() <span class="keyword">string</span></span><br><span class="line">    Creators() []<span class="keyword">string</span></span><br><span class="line">    Created() time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他属性则局限于特定类型的商品。比如字数这个属性只与书和杂志相关，而屏幕分辨率则只与电影和电视剧相关。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Text <span class="keyword">interface</span> &#123;</span><br><span class="line">    Pages() <span class="keyword">int</span></span><br><span class="line">    Words() <span class="keyword">int</span></span><br><span class="line">    PageSize() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Audio <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, error)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="keyword">string</span> <span class="comment">// 比如"MP3"、"WAV"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Video <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, error)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="keyword">string</span> <span class="comment">// 比如"MP4"、"WMV"</span></span><br><span class="line">    Resolution() (x,y <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些接口只是一种把具体类型分组并暴露它们共性的方式，未来我们也可以发现其他的分组方式。比如，如果我们要把Audio和Video按照同样的方式来处理，就可以定义一个Streamer接口来呈现它们的共性，而不用修改现有的类型定义。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Streamer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stream() (io.ReadCloser, error)</span><br><span class="line">    RunningTime() time.Duration</span><br><span class="line">    Format() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从具体类型出发、提取其共性而得出的每一种分组方式都可以表示为一种接口类型。与基于类的语言（它们显式地声明了一个类型实现的所有接口）不同的是，在Go语言里我们可以在需要时才定义新的抽象和分组，并且不用修改原有类型的定义。当需要使用另一个作者写的包里的具体类型时，这一点特别有用。当然，还需要这些具体类型在底层是真正有共性的。</p>
<h1 id="使用flag-Value来解析参数"><a href="#使用flag-Value来解析参数" class="headerlink" title="使用flag.Value来解析参数"></a><span style="color:#339AFF;">使用flag.Value来解析参数</span></h1><p>在本节中，我们将看到如何使用另外一个标准接口<code>flag.Value</code>来帮助我们定义命令行标志。考虑如下一个程序，它实现了睡眠指定时间的功能。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> period = flag.Duration(<span class="string">"period"</span>, <span class="number">1</span>*time.Second, <span class="string">"sleep period"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Printf(<span class="string">"Sleeping for %v..."</span>, *period)</span><br><span class="line">    time.Sleep(*period)</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序进入睡眠前输出了睡眠时长。fmt包调用了<code>time.Duration</code>的String方法，可以按照一个用户友好的方式来输出，而不是输出一个以纳秒为单位的数字。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch7/sleep</span><br><span class="line">$ ./sleep</span><br><span class="line">Sleeping <span class="keyword">for</span> 1s...</span><br></pre></td></tr></table></figure></p>
<p>默认的睡眠时间是1s，但可以用<code>-period</code>命令行标志来控制。<code>flag.Duration</code>函数创建了一个<code>time.Duration</code>类型的标志变量，并且允许用户用一种友好的方式来指定时长，比如可以用String方法对应的记录方法。这种对称的设计提供了一个良好的用户接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>因为时间长度类的命令行标志广泛应用，所以这个功能内置到了flag包。支持自定义类型其实也不难，只须定义一个满足<code>flag.Value</code>接口的类型，其定义如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value接口代表了存储在标志内的值</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">    Set(<span class="keyword">string</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>String方法用于格式化标志对应的值，可用于输出命令行帮助消息。由于有了该方法因此每个<code>flag.Value</code>其实也是<code>fmt.Stringer</code>。Set方法解析了传入的字符串参数并更新标志值。可以认为Set方法是String方法的逆操作，两个方法使用同样的记法规格是一个很好的实践。</p>
<p>下面定义了celsiusFlag类型来允许在参数中使用摄氏温度或华氏温度。注意，celsiusFlag内嵌了一个celsius类型（参考2.5节），所以已经有String方法了。为了满足<code>flag.Value</code>接口，只须再定义一个Set方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> celsiusFlag <span class="keyword">struct</span>&#123; Celsius &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *celsiusFlag)</span> <span class="title">Set</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> unit <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">var</span> value <span class="keyword">float64</span></span><br><span class="line">    fmt.Sscanf(s, <span class="string">"%f%s"</span>, &amp;value, &amp;unit) <span class="comment">// no error check needed</span></span><br><span class="line">    <span class="keyword">switch</span> unit &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"C"</span>, <span class="string">"°C"</span>:</span><br><span class="line">        f.Celsius = Celsius(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"F"</span>, <span class="string">"°F"</span>:</span><br><span class="line">        f.Celsius = FToC(Fahrenheit(value))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid temperature %q"</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fmt.sscanf函数用于从输入s解析一个浮点值（value）和一个字符串（unit）。尽管通常都必须检查sscanf的错误结果，但在这种情况下我们无须检查。因为如果出现错误，那么接下来的跳转条件没有一个会满足。</p>
<p>如下CelsuisFlag函数封装了上面的逻辑。这个函数返回了一个Celsius指针，它指向嵌入在celsuisFlag变量f中的一个字段。Celsuis字段在标志处理过程中会发生变化（经由Set方法）。调用Var方法可以把这个标志加人到程序的命令行标记集合中，即全局变量flag. Commandline。如果一个程序有非常复杂的命令行接口，那么单个全局变量flag.commandline就不够用了，需要有多个类似的变量来支撑。调用Var方法时会把*celsuisFlag实参赋给flag.value形参，编译器会在此时检查*celsuisFlag类型是否有flag.value所必需的方法。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CelsiusFlag defines a Celsius flag with the specified name,</span></span><br><span class="line"><span class="comment">// default value, and usage, and returns the address of the flag variable.</span></span><br><span class="line"><span class="comment">// The flag argument must have a quantity and a unit, e.g., "100C".</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CelsiusFlag</span><span class="params">(name <span class="keyword">string</span>, value Celsius, usage <span class="keyword">string</span>)</span> *<span class="title">Celsius</span></span> &#123;</span><br><span class="line">    f := celsiusFlag&#123;value&#125;</span><br><span class="line">    flag.CommandLine.Var(&amp;f, name, usage)</span><br><span class="line">    <span class="keyword">return</span> &amp;f.Celsius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在可以在程序中使用这个新标志了：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>接下来是一些典型的使用方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch7/tempflag</span><br><span class="line">$ ./tempflag</span><br><span class="line">200C</span><br><span class="line">$./tempflag -temp-18c</span><br><span class="line">-180C</span><br><span class="line">$./tempflag -temp 212oF</span><br><span class="line">100C</span><br><span class="line">$./tempflag -temp 273.15K</span><br><span class="line">invalid value <span class="string">"273.15K"</span> <span class="keyword">for</span> flag -temp:invalid temperature <span class="string">"273.15K"</span> Usage of ./tempflag:</span><br><span class="line">-temp value</span><br><span class="line">the temperature (default 2eoc)</span><br><span class="line">$./tempflag -<span class="built_in">help</span></span><br><span class="line">Usage of ./tempflag:</span><br><span class="line">-temp value</span><br><span class="line">the temperature (default 200c)</span><br></pre></td></tr></table></figure></p>
<p>练习7.6：在tempflag中支持热力学温度。</p>
<p>练习7.7：请解释为什么默认值20.0没写。c，而帮助消息中却包含。C。</p>
<h1 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a><span style="color:#339AFF;">接口值</span></h1><p>从概念上来讲，一个接口类型的值（简称接口值）其实有两个部分：一个具体类型和该类型的一个值。二者称为接口的动态类型和动态值。</p>
<p>对于像Go这样的静态类型语言，类型仅仅是一个编译时的概念，所以类型不是一个值。在我们的概念模型中，用类型描述符来提供每个类型的具体信息，比如它的名字和方法。对于一个接口值，类型部分就用对应的类型描述符来表述。</p>
<p>如下四个语句中，变量w有三个不同的值（最初和最后是同一个值）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wio.Writer</span><br><span class="line">w=os.Stdout</span><br><span class="line">W= <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w= <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p>
<p>接下来让我们详细地查看一下在每个语句之后w的值和相关的动态行为。第一个语句声明了w：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wio.Writer</span><br></pre></td></tr></table></figure></p>
<p>在Go语言中，变量总是初始化为一个特定的值，接口也不例外。接口的零值就是把它的动态类型和值都设置为nil，如图7-1所示。</p>
<blockquote>
<p>图7-1 一个nil接口值</p>
</blockquote>
<img src="/2021/08/16/第7章-接口/1.png">
<p>一个接口值是否是nil取决于它的动态类型，所以现在这是一个nil接口值。可以用w== nil或者w！=nil来检测一个接口值是否是nil。调用一个nil接口的任何方法都会导致崩溃：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write（[]<span class="keyword">byte</span>（ <span class="string">"hello"</span>））<span class="comment">//崩溃：对空指针取引用值</span></span><br></pre></td></tr></table></figure></p>
<p>第二个语句把一个*os.File类型的值赋给了w：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w=os.stdout</span><br></pre></td></tr></table></figure></p>
<p>这次赋值把一个具体类型隐式转换为一个接口类型，它与对应的显式转换io.Writer（os.stdout）等价。不管这种类型的转换是隐式的还是显式的，它都可以转换操作数的类型和值。接口值的动态类型会设置为指针类型*os.File的类型描述符，它的动态值会设置为os.stdout的副本，即一个指向代表进程的标准输出的os.File类型的指针，如图7-2所示。</p>
<blockquote>
<p>图7-2 包含os.File指针的接口值</p>
</blockquote>
<img src="/2021/08/16/第7章-接口/2.png">
<p>调用该接口值的Write方法，会实际调用（*0s.File）.Write方法，即输出”hello”。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>)) <span class="comment">// "hello'</span></span><br></pre></td></tr></table></figure></p>
<p>一般来讲，在编译时我们无法知道一个接口值的动态类型会是什么，所以通过接口来做调用必然需要使用动态分发。编译器必须生成一段代码来从类型描述符拿到名为Write的方法地址，再间接调用该方法地址。调用的接收者就是接口值的动态值，即os.stdout，所以实际效果与直接调用等价：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.Stdout.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>)) <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></p>
<p>第三个语句把一个*bytes.Buffer类型的值赋给了接口值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure></p>
<p>动态类型现在是*bytes.Buffer，动态值现在则是一个指向新分配缓冲区的指针，如图7-3所示。</p>
<blockquote>
<p>图7-3 包含*bytes.Buffer指针的接口值</p>
</blockquote>
<img src="/2021/08/16/第7章-接口/3.png">
<p>调用Write方法的机制也跟第二个语句一致：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Write（[]<span class="keyword">byte</span>（<span class="string">"hello"</span>））<span class="comment">//把“hello”写入bytes.Buffer</span></span><br></pre></td></tr></table></figure></p>
<p>，这次，类型描述符是*bytes.Buffer，所以调用的是（*bytes.Buffer）.Write方法，方法的接收者是缓冲区的地址。调用该方法会追加”hello”到缓冲区。</p>
<p>最后，第四个语句把nil赋给了接口值：</p>
<p>这个语句把动态类型和动态值都设置为nil，把w恢复到了它刚声明时的状态（如图7-1所示）。</p>
<p>-个接口值可以指向多个任意大的动态值。比如，time.Time类型可以表示一个时刻它是一个包含几个非导出字段的结构。如果从它创建一个接口值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;=time.Now()</span><br></pre></td></tr></table></figure></p>
<p>结果可能如图7-4所示。从理论上来讲，无论动态值有多值大，它永远在接口值内部（当然这只是一个理论模型；实际的实现是很不同的）。</p>
<blockquote>
<p>图7-4 持有time.Time结构</p>
</blockquote>
<img src="/2021/08/16/第7章-接口/4.png">
<p>接口值可以用==和！=操作符来做比较。如果两个接口值都是nil或者二者的动态类型完全一致且二者动态值相等（使用动态类型的=操作符来做比较），那么两个接口值相等。因为接口值的接口值是可以比较的，所以它们可以作为map的键，也可以作为switch语句的操作数。</p>
<p>需要注意的是，在比较两个接口值时，如果两个接口值的动态类型一致，但对应的动态值是不可比较的（比如slice），那么这个比较会以崩溃的方式失败：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;= []<span class="keyword">int</span>&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;</span><br><span class="line">fmt.print1n（x==x）<span class="comment">//宕机：试图比较不可比较的类型[]int</span></span><br></pre></td></tr></table></figure></p>
<p>从这点来看，接口类型是非平凡的。其他类型要么是可以安全比较的（比如基础类型和指针），要么是完全不可比较的（比如slice、map和函数），但当比较接口值或者其中包含接口值的聚合类型时，我们必须小心崩溃的可能性。当把接口作为map的键或者switch语句的操作数时，也存在类似的风险。仅在能确认接口值包含的动态值可以比较时，才比较接口值。</p>
<p>当处理错误或者调试时，能拿到接口值的动态类型是很有帮助的。可以使用fmt包的%T来实现这个需求：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,w)<span class="comment">// "&lt;nil&gt;\*</span></span><br><span class="line">W =os.Stdout</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, w) <span class="number">1</span>/\*\*os.File<span class="string">"</span></span><br><span class="line"><span class="string">W = new(bytes.Buffer)</span></span><br><span class="line"><span class="string">fmt. Printf("</span>%T\n<span class="string">", w)//"</span>\*bytes.Buffer\*</span><br></pre></td></tr></table></figure></p>
<p>在内部实现中，fmt用反射来拿到接口动态类型的名字。第12章将进一步讨论反射。</p>
<p>注意：含有空指针的非空接口<br>空的接口值（其中不包含任何信息）与仅仅动态值为nil的接口值是不一样的。这种微妙的区别成为让每个Go程序员都困惑过的陷阱。</p>
<p>考虑如下程序，当debug设置为true时，主函数收集函数f的输出到一个缓冲区中：</p>
<p>当设置debug为false时，我们会觉得仅仅是不再收集输出，但实际上会导致程序在调用out.Write时崩溃：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">out.Write（[]<span class="keyword">byte</span>（ <span class="string">"done！\n"</span>））<span class="comment">//宕机：对空指针取引用值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当main函数调用f时，它把一个类型为*bytes.Buffer的空指针<br>类型*bytes.Buffer赋给了out参数，所以out的动态值确实为空。但它的动态类型是值nil<br>*bytes.Buffer，这表示out是一个包含空指针的非空接口（见图7-5），图7-5包含空指针的所以防御性检查out！=ni1仍然是true。</p>
<p>非空接口</p>
<p>如前所述，动态分发机制决定了我们肯定会调用（*bytes.Buffer）.Write，只不过这次接收者值为空。对于某些类型，比如*os.File，空接收值是合法的（参考6.2.1节），但对于*bytes.Buffer则不行。方法尽管被调用了，但在尝试访问缓冲区时崩溃了。</p>
<p>问题在于，尽管一个空的*bytes.Buffer指针拥有的方法满足了该接口，但它并不满足该接口所需的一些行为。特别是，这个调用违背了（*bytes.Buffer）.Write的一个隐式的前置条件，即接收者不能为空，所以把空指针赋给这个接口就是一个错误。解决方案是把main函数中的buf类型修改为io.Writer，从而避免在最开始就把一个功能不完整的值赋给一个接口。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf io.Writer</span><br><span class="line"><span class="keyword">if</span> debug &#123; buf = <span class="built_in">new</span>（bytes.Buffer）<span class="comment">//启用输出收集</span></span><br><span class="line">f(buf) <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></p>
<p>既然我们已经了解过接口值的机制，接下来就要看一下Go标准库的一些重要接口。在接下来的三节中，我们将看到接口在排序、Web服务、错误处理中的应用。</p>
<h1 id="使用sort-Interface来排序"><a href="#使用sort-Interface来排序" class="headerlink" title="使用sort.Interface来排序"></a><span style="color:#339AFF;">使用sort.Interface来排序</span></h1><p>与字符串格式化类似，排序也是一个在很多程序中广泛使用的操作。尽管一个最小的快排（Quicksort）只需15行左右，但一个健壮的实现长很多。所以我们无法想象在每次需要时都重新写一遍或者复制一遍。</p>
<p>幸运的是，sort包提供了针对任意序列根据任意排序函数原地排序的功能。这样的设计其实并不常见。在很多语言中，排序算法跟序列数据类型绑定，排序算法则跟序列元素类型绑定。与之相反的是，Go语言的sort.sort函数对序列和其中元素的布局无任何要求，它使用sort.Interface接口来指定通用排序算法和每个具体的序列类型之间的协议（contract）。这个接口的实现确定了序列的具体布局（经常是一个slice），以及元素期望的排序方式。</p>
<p>一个原地排序算法需要知道三个信息：序列长度、比较两个元素的含义以及如何交换两个元素，所以sort.Interface接口就有三个方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span> <span class="comment">// i，j是序列元素的下标</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要对序列排序，需要先确定一个实现了如上三个方法的类型，接着把sort.sort函数应用到上面这类方法的实例上。我们先考虑几乎是最简单的一个例子：字符串slice。定义的新类型Stringslice以及它的Len、Less、Swap三个方法如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; p[i],p[j]=p[j],p[i] &#125;</span><br></pre></td></tr></table></figure></p>
<p>现在就可以对一个字符串slice进行排序，只须简单地把一个slice转换为stringslice类型即可，如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(StringSlice(names))</span><br></pre></td></tr></table></figure></p>
<p>类型转换生成了一个新的slice，与原始的names有同样的长度、容量和底层数组，不同的就是额外增加了三个用于排序的方法。</p>
<p>字符串slice的排序太常用了，所以sort包提供了stringslice类型，以及一个直接排序的Strings函数，于是上面的代码可以简写为sort.strings（names）。</p>
<p>这种技术可以方便地复用到其他排序方式，比如，忽略大小写或者特殊字符。（本书的索引词和页码排序也用了这个技术，只是加了额外的罗马数字逻辑。）对于更复杂的排序，也可以使用同样的思路，只用加上更复杂的数据结构和更复杂的sort.Interface方法实现。</p>
<p>这里的排序示例将是一个以表格方式显示的音乐播放列表。每首音乐占一行，每个字段都是这首音乐的一个属性，比如艺术家、标题和时间。考虑使用图形用户界面来展示一个表，单击列头会按该列对应的属性来进行排序，再次单击同一个列头会逆序排列。接下来看一下如何响应每一次单击。</p>
<p>如下变量tracks包含一个播放列表。（作者之一对其他作者的音乐品味表示遗憾。）每个元素都是一个指向Track的指针。尽管我们不用指针，而改为直接存储Tracks，后面的代码也能运行，考虑到sort函数要交换很多对元素，所以在元素是一个指针的情况下代码运行速度会更快，毕竟，一个指针的大小只有一个字长，而一个完整的Track则需要8个甚至更多的字。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch7/sorting</span></span><br><span class="line"><span class="keyword">type</span> Track <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title  <span class="keyword">string</span></span><br><span class="line">    Artist <span class="keyword">string</span></span><br><span class="line">    Album  <span class="keyword">string</span></span><br><span class="line">    Year   <span class="keyword">int</span></span><br><span class="line">    Length time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tracks = []*Track&#123;</span><br><span class="line">    &#123;<span class="string">"Go"</span>, <span class="string">"Delilah"</span>, <span class="string">"From the Roots Up"</span>, <span class="number">2012</span>, length(<span class="string">"3m38s"</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"Go"</span>, <span class="string">"Moby"</span>, <span class="string">"Moby"</span>, <span class="number">1992</span>, length(<span class="string">"3m37s"</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"Go Ahead"</span>, <span class="string">"Alicia Keys"</span>, <span class="string">"As I Am"</span>, <span class="number">2007</span>, length(<span class="string">"4m36s"</span>)&#125;,</span><br><span class="line">    &#123;<span class="string">"Ready 2 Go"</span>, <span class="string">"Martin Solveig"</span>, <span class="string">"Smash"</span>, <span class="number">2011</span>, length(<span class="string">"4m24s"</span>)&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">length</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    d, err := time.ParseDuration(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>printTracks函数将播放列表输出为一个表格。当然，一个图形界面肯定会更好，但这个例程使用的<code>text/tabwriter</code>包可以生成一个如下所示的干净整洁的表格。注意，<code>*tabwriter.writer</code>满足<code>io.Writer</code>接口，它先收集所有写入的数据，在Flush方法调用时才格式化整个表格并且输出到<code>os.Stdout</code>。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTracks</span><span class="params">(tracks []*Track)</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> format = <span class="string">"%v\t%v\t%v\t%v\t%v\t\n"</span></span><br><span class="line">    tw := <span class="built_in">new</span>(tabwriter.Writer).Init(os.Stdout, <span class="number">0</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="string">' '</span>, <span class="number">0</span>)</span><br><span class="line">    fmt.Fprintf(tw, format, <span class="string">"Title"</span>, <span class="string">"Artist"</span>, <span class="string">"Album"</span>, <span class="string">"Year"</span>, <span class="string">"Length"</span>)</span><br><span class="line">    fmt.Fprintf(tw, format, <span class="string">"-----"</span>, <span class="string">"------"</span>, <span class="string">"-----"</span>, <span class="string">"----"</span>, <span class="string">"------"</span>)</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tracks &#123;</span><br><span class="line">        fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)</span><br><span class="line">    &#125;</span><br><span class="line">    tw.Flush() <span class="comment">// 计算各列宽度并输出表格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要按照Artist字段来对播放列表排序，需要先定义一个新的slice类型，以及必需的Len、Less和Swap方法，正如Stringslice一样。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byArtist []*Track</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> x[i].Artist &lt; x[j].Artist &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byArtist)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; x[i], x[j] = x[j], x[i] &#125;</span><br></pre></td></tr></table></figure></p>
<p>要调用通用的排序例称，必须先把tracks转换为定义排序规则的新类型byArtist：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(byArtist(tracks))</span><br></pre></td></tr></table></figure></p>
<p>按照艺术家排序之后，从printTracks生成的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album              Year  Length</span><br><span class="line">-----       ------          -----              ----  ------</span><br><span class="line">Go Ahead    Alicia Keys     As I Am            2007  4m36s</span><br><span class="line">Go          Delilah         From the Roots Up  2012  3m38s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash              2011  4m24s</span><br><span class="line">Go          Moby            Moby               1992  3m37s</span><br></pre></td></tr></table></figure></p>
<p>如果用户第二次请求“按照艺术家排序”，就需要把这些音乐反向排序。我们不需要定义一个新的byReverseArtist类型和对应的反向Less方法，因为sort包已经提供了一个Reverse函数，它可以把任意的排序反向。</p>
<p>按照艺术家对slice反向排序之后，从printTracks生成的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album              Year  Length</span><br><span class="line">-----       ------          -----              ----  ------</span><br><span class="line">Go          Moby            Moby               1992  3m37s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash              2011  4m24s</span><br><span class="line">Go          Delilah         From the Roots Up  2012  3m38s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am            2007  4m36s</span><br></pre></td></tr></table></figure></p>
<p>sort.Reverse函数值得仔细看一下，因为它使用了一个重要概念：组合（参考6.3节）。</p>
<p>sort包定义了一个未导出的类型reverse，这个类型是一个嵌人了sort.Interface的结构。reverse 的Less方法直接调用了内嵌的sort.Interface值的Less方法，但只交换传人的下标，就可以颠倒排序的结果。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sort</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span>&#123; Interface &#125; <span class="comment">// that is, sort.Interface</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span> <span class="title">Less</span><span class="params">(i,jint)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> r.Interface.less(j，i)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span> &#123; <span class="keyword">return</span> reverse&#123;data&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>reverse的另外两个方法Len和Swap，由内嵌的sort.Interface隐式提供。导出的函数Reverse则返回一个包含原始sort.Interface值的reverse实例。<br>如果要按其他列来排序，就需要定义一个新的类型，比如byYear：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> byYear []*Track</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> x[i].Year &lt; x[j].Year &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x byYear)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; x[i], x[j] = x[j], x[i] &#125;</span><br></pre></td></tr></table></figure></p>
<p>把tracks按照sort.sort（byYear（tracks））排序后，printTracks就可以输出一个按照年代排序的列表了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album              Year  Length</span><br><span class="line">-----       ------          -----              ----  ------</span><br><span class="line">Go          Moby            Moby               1992  3m37s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am            2007  4m36s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash              2011  4m24s</span><br><span class="line">Go          Delilah         From the Roots Up  2012  3m38s</span><br></pre></td></tr></table></figure></p>
<p>对于每一类slice和每一种排序函数，都需要实现一个新的sort.Interface。如你所见，Len和Swap方法对所有的slice类型都是一样的。在下一个例子中，具体类型customSort组合了一个slice和一个函数，让我们只写一个比较函数就可以定义一个新的排序。顺便说一下，实现sort.Interface的具体类型并不一定都是slice，比如customSort就是一个结构类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> customSort <span class="keyword">struct</span> &#123;</span><br><span class="line">    t    []*Track</span><br><span class="line">    less <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(x customSort)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x.t) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> x.less(x.t[i], x.t[j]) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x customSort)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们定义个一个多层的比较函数，先按照标题（Title）排序，接着是年份Year，最后是时长Length。如下sort调用就是一个使用匿名排序函数来这样排序的例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(customSort&#123;tracks, <span class="function"><span class="keyword">func</span><span class="params">(x, y *Track)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.Title != y.Title &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Title &lt; y.Title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Year != y.Year &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Year &lt; y.Year</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x.Length != y.Length &#123;</span><br><span class="line">        <span class="keyword">return</span> x.Length &lt; y.Length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如下就是结果。注意，对于两首标题都是“Go”的音乐，年份较早的排序靠前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title       Artist          Album              Year  Length</span><br><span class="line">-----       ------          -----              ----  ------</span><br><span class="line">Go          Moby            Moby               1992  3m37s</span><br><span class="line">Go          Delilah         From the Roots Up  2012  3m38s</span><br><span class="line">Go Ahead    Alicia Keys     As I Am            2007  4m36s</span><br><span class="line">Ready 2 Go  Martin Solveig  Smash              2011  4m24s</span><br></pre></td></tr></table></figure></p>
<p>对一个长度为n的序列进行排序需要O（nlogn）次比较操作，而判断一个序列是否已经排好序则只需最多（n-1）次比较。sort包提供的IsSorted函数就可以做这个判断。与sort. Sort类似，它使用sort.Interface来抽象序列及其排序函数，只是从不调用Swap方法而已。下面的代码就演示了IntsAreSorted、Ints函数和IntSlice类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">values := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// "false"</span></span><br><span class="line">sort.Ints(values)</span><br><span class="line">fmt.Println(values)                     <span class="comment">// "[1 1 3 4]"</span></span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// "true"</span></span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(values)))</span><br><span class="line">fmt.Println(values)                     <span class="comment">// "[4 3 1 1]"</span></span><br><span class="line">fmt.Println(sort.IntsAreSorted(values)) <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure></p>
<p>为了简便起见，sort包专门提供了对于[]int、[]string、[]f1oat64自然排序的函数和相关类型。对于其他类型，比如[]int64或者[]uint，则需要自己写，反正写起来也不复杂。</p>
<p>练习7.8：很多图形界面提供了一个表格控件，它支持有状态的多层排序：先按照最近单击的列来排序，接着是上一次单击的列，依次类推。请定义sort.Interface接口实现来满足如上需求。试比较这个方法与多次使用sort.stable排序的异同。</p>
<p>练习7.9：利用html/template包（见4.6节）来替换printTracks函数，使用HTML表格来显示音乐列表。结合上一个练习，来实现通过单击列头来发送HTTP请求，进而对表格排序。</p>
<p>练习7.10：sort.Interface也可以用于其他用途。试写一个函数IsPalindrome（s sort.Interface）bool来判断一个序列是否是回文，即序列反转后是否保持不变。可以假定对于下标分别为i、j的元素，如果！s.Less（i，j）&amp;&amp;！s.less（j，i），那么两个元素相等。</p>
<h1 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a><span style="color:#339AFF;">http.Handler接口</span></h1><p>第1章简单介绍了如何用net/http包来实现Web客户端（参考1.5节）和服务器（参考1.7节）。本节将进一步讨论服务端API，以及作为其基础的<code>http.Handler</code>接口。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(address <span class="keyword">string</span>, h Handler)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p>ListenAndServe函数需要一个服务器地址，比如“localhost:8000”，以及一个Handler接口的实例（用来接受所有的请求）。这个函数会一直运行，直到服务出错（或者启动时就失败了）时返回一个非空的错误。</p>
<p>设想一个电子商务网站，使用一个数据库来存储商品和价格（以美元计价）的映射。如下程序将展示一个最简单的实现。它用一个map类型（命名为database）来代表仓库，再加上一个ServeHTTP方法来满足<code>http.Handler</code>接口。这个函数遍历整个map并且输出其中的元素：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch7/http1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">"shoes"</span>: <span class="number">50</span>, <span class="string">"socks"</span>: <span class="number">5</span>&#125;</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, db))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dollars <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dollars)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">"$%.2f"</span>, d) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="keyword">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s: %s\n"</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果启动服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch7/http1</span><br><span class="line">$ ./http1 &amp;</span><br></pre></td></tr></table></figure></p>
<p>使用1.5节的fetch程序来连接服务器（也可以用Web浏览器），可以得到如下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./fetch http://localhost:8000</span><br><span class="line">shoes: <span class="variable">$50</span>.00</span><br><span class="line">socks: <span class="variable">$5</span>.00</span><br></pre></td></tr></table></figure></p>
<p>到现在为止，这个服务器只能列出所有的商品，而且是完全不管URL，对每个请求都是如此。一个更加真实的服务器会定义多个不同URL，每个触发不同的行为。我们把现有功能的URL设为<code>/list</code>，再加上另外一个<code>/price</code>用来显示单个商品的价格，商品可以在请求参数中指定，比如<code>/price?item=socks</code>：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> req.URL.Path &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/list"</span>:</span><br><span class="line">        <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">"%s: %s\n"</span>, item, price)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/price"</span>:</span><br><span class="line">        item := req.URL.Query().Get(<span class="string">"item"</span>)</span><br><span class="line">        price, ok := db[item]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">            fmt.Fprintf(w, <span class="string">"no such item: %q\n"</span>, item)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s\n"</span>, price)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">"no such page: %s\n"</span>, req.URL)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，处理函数基于URL的路径部分（<code>req.URL.Path</code>）来决定执行哪部分逻辑。如果处理函数不能识别这个路径，那么它通过调用<code>w.WriteHeader(http.StatusNotFound)</code>来返回一个HTTP错误。注意，这个调用必须在往w中写入内容之前完成（顺带说一下，<code>http.ResponseWriter</code>也是一个接口，它扩充了<code>io.Writer</code>，加了发送HTTP响应头的方法）。也可以使用<code>http.Error</code>这个工具函数来达到同样目的。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := fmt.Sprintf(<span class="string">"no such page: %s\n"</span>, req.URL)</span><br><span class="line">http.Error(w, msg, http.StatusNotFound) <span class="comment">// 404</span></span><br></pre></td></tr></table></figure></p>
<p>对于<code>/price</code>的场景，它调用了URL的Query方法，把HTTP的请求参数解析为一个 map，或者更精确来讲，解析为一个multimap，由<code>net/url</code>包的<code>url.Values</code>类型（6.2.1节）实现。它找到第一个item请求参数，查询对应的价格。如果商品没找到，则返回一个错误。</p>
<p>与新服务端的交互范例如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch7/http2</span><br><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$ ./http2 &amp;</span><br><span class="line">$ ./fetch http://localhost:8000/list</span><br><span class="line">shoes: <span class="variable">$50</span>.00</span><br><span class="line">socks: <span class="variable">$5</span>.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=socks</span><br><span class="line"><span class="variable">$5</span>.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=shoes</span><br><span class="line"><span class="variable">$50</span>.00</span><br><span class="line">$ ./fetch http://localhost:8000/price?item=hat</span><br><span class="line">no such item: <span class="string">"hat"</span></span><br><span class="line">$ ./fetch http://localhost:8000/<span class="built_in">help</span></span><br><span class="line">no such page: /<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<p>显然，可以继续给ServeHTP方法增加功能，但对于一个真实的应用，应当把每部分逻辑分到独立的函数或方法。进一步来讲，某些相关的URL可能需要类似的逻辑，比如几个图片文件的URL可能都是<code>/images/*.png</code>形式。因为这些原因，<code>net/http</code>包提供了一个请求多工转发器ServeMux，用来简化URL和处理程序之间的关联。一个ServeMux把多个<code>http.Handler</code>组合成单个<code>http.Handler</code>。在这里，我们再次看到满足同一个接口的多个类型是可以互相替代的，Web服务器可以把请求分发到任意一个<code>http.Handler</code>，而不用管后面具体的类型是什么。</p>
<p>对于一个更复杂的应用，多个ServeMux会组合起来，用来处理更复杂的分发需求。Go语言并没有一个类似于Ruby的Rails或者Python的Django那样的权威Web框架。这并不是说那样的框架无法存在，只是Go语言的标准库提供的基础单元足够灵活，以至于那样的框架通常不是必需的。进一步来讲，尽管框架在项目初期带来很多便利，但框架带来了额外复杂性，增加长时间维护的难度。</p>
<p>在下面的代码中，创建了一个ServeMux，用于将<code>/list</code>、<code>/price</code>这样的URL和对应的处理程序关联起来，这些处理程序也已经拆分到不同的方法中。最后作为主处理程序在ListenAndServe调用中使用这个ServerMux：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">"shoes"</span>: <span class="number">50</span>, <span class="string">"socks"</span>: <span class="number">5</span>&#125;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.Handle(<span class="string">"/list"</span>, http.HandlerFunc(db.list))</span><br><span class="line">    mux.Handle(<span class="string">"/price"</span>, http.HandlerFunc(db.price))</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, mux))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">map</span>[<span class="keyword">string</span>]dollars</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">list</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item, price := <span class="keyword">range</span> db &#123;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"%s: %s\n"</span>, item, price)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db database)</span> <span class="title">price</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    item := req.URL.Query().Get(<span class="string">"item"</span>)</span><br><span class="line">    price, ok := db[item]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        w.WriteHeader(http.StatusNotFound) <span class="comment">// 404</span></span><br><span class="line">        fmt.Fprintf(w, <span class="string">"no such item: %q\n"</span>, item)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"%s\n"</span>, price)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们先关注一下用于注册处理程序的两次<code>mux.Handle</code>调用。在第一个调用中，<code>db.list</code>是一个方法值（参考6.4节），即如下类型的一个值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span></span><br></pre></td></tr></table></figure></p>
<p>当调用<code>db.list</code>时，等价于以b为接收者调用<code>database.list</code>方法。所以<code>db.list</code>是一个实现了处理功能的函数（而不是一个实例），因为它没有接口所需的方法，所以它不满足<code>http.Handler</code>接口，也不能直接传给<code>mux.Handle</code>。</p>
<p>表达式<code>http.HandleFunc(db.list)</code>其实是类型转换，而不是函数调用。注意，<code>http.HandleFunc</code>是一个类型。它有如下定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/http</span></span><br><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(w ResponseWriter, r *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HandlerFunc演示了Go语言接口机制的一些不常见特性。它不仅是一个函数类型，还拥有自己的方法，也满足接口<code>http.Handler</code>。它的ServeHTTP方法就调用函数本身，所以HandlerFunc就是一个让函数值满足接口的一个适配器，在这个例子中，函数和接口的唯一方法拥有同样的签名。这个小技巧让database类型可以用不同的方式来满足<code>http.Handler</code>接口：一次通过list方法，一次通过price方法，依次类推。</p>
<p>因为这种注册处理程序的方法太常见了，所以serveMux引入了一个HandleFunc便捷方法来简化调用，处理程序注册部分的代码可以简化为如下形式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch7/http3a</span></span><br><span class="line">mux.HandleFunc(<span class="string">"/list"</span>, db.list)</span><br><span class="line">mux.HandleFunc(<span class="string">"/price"</span>, db.price)</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码，我们可以看到构造这样一个程序也是简单的：有两个不同的Web服务器，在不同的端口监听，定义不同的URL，分发到不同的处理程序。只须简单地构造另外一个ServeMux，再调用一次ListenAndserve即可（建议并发调用）。但对于绝大部分程序来说，一个Web服务就已经远远足够了。另外，一个程序可能在很多文件中来定义HTTP处理程序，如果每次都需要显式注册在应用本身的ServerMux实例上，那就太麻烦了。</p>
<p>所以，为简便起见，net/http包提供一个全局的ServeMux实例DefaultServeMux，以及包级别的注册函数http.Handle和http.HandleFunc。要让DefaultServeMux作为服务器的主处理程序，无须把它传给ListenAndserve，直接传nil即可。<br>服务器的主函数可以进一步简化为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gop.io/ch7/http4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db := database&#123;<span class="string">"shoes"</span>: <span class="number">50</span>, <span class="string">"socks"</span>: <span class="number">5</span>&#125;</span><br><span class="line">    http.HandleFunc(<span class="string">"/list"</span>, db.list)</span><br><span class="line">    http.HandleFunc(<span class="string">"/price"</span>, db.price)</span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">"localhost:8000"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后有一个重要的提示：1.7节曾提到，Web服务器每次都用一个新的goroutine来调用处理程序，所以处理程序必须要注意并发问题。比如在访问变量时的锁问题，这个变量可能会被其他goroutine访问，包括由同一个处理程序处理的其他请求。接下来的两章会继续讨论并发问题。</p>
<p>练习7.11：增加额外的处理程序，来支持创建、读取、更新和删除数据库条目。比如，<code>/update？item=socks&amp;price=6</code>这样的请求将更新仓库中物品的价格，如果商品不存在或者价格无效就返回错误。（注意：这次修改会引入并发变量修改。）</p>
<p>练习7.12：修改<code>/list</code>的处理程序，改为输出HTML表格，而不是纯文本。可以考虑使用<code>html/template</code>包（参考4.6节）。</p>
<h1 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a><span style="color:#339AFF;">error接口</span></h1><p>从本书的开始，我们就已经使用和创建了神秘的预定义error类型，但从来没解释过它具体是什么。实际上，它只是一个接口类型，包含一个返回错误消息的方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造error最简单的方法是调用<code>errors.New</code>，它会返回一个包含指定的错误消息的新error实例。完整的error包只有如下4行代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> &amp;errorString&#123;text&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123; text <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.text &#125;</span><br></pre></td></tr></table></figure></p>
<p>底层的errorString类型是一个结构，而没有直接用字符串，主要是为了避免将来无意间的（或者有预谋的）布局变更。满足error接口的是<code>*errorString</code>指针，而不是原始的errorString，主要是为了让每次New分配的error实例都互不相等。我们不希望出现像<code>io.EoF</code>这样重要的错误，与仅仅包含同样错误消息的一个错误相等。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(errors.New(<span class="string">"EOF"</span>) == errors.New(<span class="string">"EOF"</span>)) <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure></p>
<p>直接调用<code>errors.New</code>比较罕见，因为有一个更易用的封装函数<code>fmt.Errorf</code>，它还额外提供了字符串格式化功能。这个函数在第5章中我们已经用过几次了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(Sprintf(format, args...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管<code>*errorString</code>可能是最简单的error类型，但这样简单的error类型远不止一个。比如，syscall包提供了Go语言的底层系统调用API。在很多平台上，它也定义了一个满足error接口的数字类型Errno。在UNIX平台上，Errno的Error方法会从一个字符串表格中查询错误消息，如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syscall</span><br><span class="line"><span class="keyword">type</span> Errno <span class="keyword">uintptr</span><span class="comment">//操作系统错误码</span></span><br><span class="line"><span class="keyword">var</span> errors = [...]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="number">1</span>:.<span class="string">"operation not permitted"</span>,II EPERM</span><br><span class="line"><span class="number">2</span>:<span class="string">"no such file or directory"</span>, II ENOENT</span><br><span class="line"><span class="number">3</span>: <span class="string">"no such process"</span>,</span><br><span class="line"><span class="comment">//ESRCH</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(e Errno)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e &lt;= <span class="keyword">int</span>(e) &amp;&amp; <span class="keyword">int</span>(e) &lt; <span class="built_in">len</span>(errors) &#123; <span class="keyword">return</span> errors[e]</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"errno %d"</span>,e)</span><br></pre></td></tr></table></figure></p>
<p>如下语句创建一个接口值，其中包含值为2的Errno，这个值代表<code>POSIX ENOENT</code>状态：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error = syscall.Errno(<span class="number">2</span>)</span><br><span class="line">fmt Println（err.Error（））<span class="comment">//“没有文件或目录“</span></span><br><span class="line">err</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="comment">//"没有文件或目录"</span></span><br></pre></td></tr></table></figure></p>
<p>err的接口值如图7-6所示。</p>
<img src="/2021/08/16/第7章-接口/6.png">
<p>Errno是一个系统调用错误的高效表示手法，毕竟系统图7-6一个包含syscall.Errno 调用错误是一个有限的集合，尽管很简单，但是它也满足标整数的接口值准的error接口。在7.11节中我们可以看到满足error接口的其他类型。</p>
<h1 id="示例：表达式求值器"><a href="#示例：表达式求值器" class="headerlink" title="示例：表达式求值器"></a><span style="color:#339AFF;">示例：表达式求值器</span></h1><p>在本节中，我们将创建简单算术表达式的一个求值器。我们将使用一个接口xpr来代表这种语言中的任意一个表达式。现在，这个接口没有任何方法，但稍后我们会逐个添加。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Expr：算术表达式</span></span><br><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的表达式语言包括浮点数字面量，二元操作符+、-、*、/，一元操作符-x和+x，函数调用pow（x，y）、sin（x）和sqrt（x），变量（比如x和pi），当然，还有圆括号和标准的操作符优先级。所有的值都是float64类型。下面是几个示例表达式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqrt(A/pi)</span><br><span class="line">pow(x,<span class="number">3</span>) + pow(y，<span class="number">3</span>)</span><br><span class="line">(F<span class="number">-32</span>)\*<span class="number">5</span>/ <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>下面5种具体类型代表特定类型的表达式。Var代表变量应用（很快我们将了解到为什么这个类型需要导出）。literal代表浮点数常量。unary和binary类型代表有一个或者两个操作数的操作符表达式，而操作数则可以任意的Expr。call代表函数调用，这里限制它的fn字段只能是pow、sin和sqrt。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch7/eval</span><br><span class="line"><span class="comment">//Var表示一个变量，比如x</span></span><br><span class="line"><span class="keyword">type</span> Var <span class="keyword">string</span></span><br><span class="line"><span class="comment">// literal是一个数字常量，比如3.141 type literal float64</span></span><br><span class="line"><span class="comment">// unary表示一元操作符表达式，比如-x type unary struct &#123;</span></span><br><span class="line">op <span class="keyword">rune</span> <span class="comment">//'+</span></span><br><span class="line">.<span class="string">"中的一个</span></span><br><span class="line"><span class="string">xExpr</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// binary表示二元操作符表达式，比如x+y type binary struct</span></span><br><span class="line"><span class="string">op rune //</span></span><br><span class="line"><span class="string">'/'中的一个</span></span><br><span class="line"><span class="string">x,yExpr</span></span><br><span class="line"><span class="string">// call表示函数调用表达式，比如sin（x）</span></span><br><span class="line"><span class="string">type call struct &#123;</span></span><br><span class="line"><span class="string">fn string /I one of "</span>pow<span class="string">"，"</span>sin<span class="string">"，"</span>sqrt<span class="string">"中的一个args []Expr</span></span><br></pre></td></tr></table></figure></p>
<p>要对包含变量的表达式进行求值，需要一个上下文（environment）来把变量映射到数值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Env <span class="keyword">map</span>[Var]<span class="keyword">float64</span></span><br></pre></td></tr></table></figure></p>
<p>我们还需要为每种类型的表达式定义一个Eval方法来返回表达式在一个给定上下文下的值。既然每个表达式都必须提供这个方法，那么可以把它加到Expr接口中。这个包只导出了类型Expr、Env和Var。客户端可以在不接触其他表达式类型的情况下使用这个求值器。</p>
<p>下面是具体的Eval方法。Var的Eval方法从上下文中查询结果，如果变量不存在则返回0。literal的Eval方法则直接返回本身的值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vVar)</span> <span class="title">Eval</span><span class="params">(env Env)</span> <span class="title">float64</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> env[v]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(l literal)</span> <span class="title">Eval</span><span class="params">(_ Env)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(l)</span><br></pre></td></tr></table></figure></p>
<p>unary和binary的Eval方法首先对它们的操作数递归求值，然后应用op操作。我们不把除以0或者无穷大当做错误（尽管它们生成的结果显然不是有穷数）。最后，call方法先对pow、sin或者sqrt函数的参数求值，再调用math包中的对应函数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unary)</span> <span class="title">Eval</span><span class="params">(env Env)</span> <span class="title">float64</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> u.op&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span></span><br><span class="line"><span class="keyword">return</span> tu.x.Eval(env)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'.'</span></span><br><span class="line"><span class="keyword">return</span> -u.x.Eval(env)</span><br><span class="line"><span class="built_in">panic</span>(fmt.sprintf(<span class="string">"unsupported unary operator: %q"</span>, u.op))</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b binary)</span> <span class="title">Eval</span><span class="params">(env Env)</span> <span class="title">float64</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> b.op&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span> <span class="keyword">return</span> b.x.Eval(env)+b.y.Eval(env)</span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">return</span> b.x.Eval(env)_b.y.Eval(env)</span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">return</span> b.x.eval(env)\*b.y.Eval(env)</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span> <span class="keyword">return</span> b.x.eval(env)/b.y.Eval(env)</span><br><span class="line"><span class="built_in">panic</span>(fmt.sprintf(<span class="string">"unsupported binary operator: %q"</span>,b.op))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ccall)</span> <span class="title">Eval</span><span class="params">(env Env)</span> <span class="title">float64</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> c.fn &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"pow"</span>:</span><br><span class="line"><span class="keyword">return</span> math.Pow(c.args[<span class="number">8</span>].Eval(env),c.args[<span class="number">1</span>].Eval(env); <span class="keyword">case</span> <span class="string">"sin"</span>:</span><br><span class="line"><span class="keyword">return</span> math. sin(c.args[].Eval(env))</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sqrt"</span>:</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(c.args[<span class="number">0</span>].Eval(env))</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"unsupported function call: %s"</span>,c.fn))</span><br></pre></td></tr></table></figure></p>
<p>某些方法可能会失败，比如call表达式可能会遇到未知的函数，或者参数数量不对。也有可能用“！”或者“《”这类无效的操作符构造了一个unary或binary表达式（尽管后面的Parse函数不会产生这样的结果）。这些错误都会导致Eval崩溃。其他错误（比如对一个上下文中没有定义的变量求值）仅会导致返回不正确的结果。所有这些错误都可以在求值之前做检查来发现。后面的Check方法就负责完成这个任务，但我们先测试Eval。</p>
<p>下面的TestEval函数用于测试求值器，它使用testing包。testing包的详细情况会在第11章介绍，现在我们只须知道调用t.Errorf来报告错误。这个函数遍历一个表格，表格中定义了三个表达式并为每个表达式准备了不同上下文。第一个表达式用于根据圆面积A求半径，第二个用于计算两个变量x和y的立方和，第三个把华氏温度F转为摄氏温度。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEval</span><span class="params">(t \*testing.T)</span></span>&#123;</span><br><span class="line">tests :=[]<span class="keyword">struct</span>.&#123;</span><br><span class="line">expr <span class="keyword">string</span></span><br><span class="line">env Env</span><br><span class="line">want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="string">"sqrt(A/ pi)"</span>,Env&#123;<span class="string">"A"</span>:<span class="number">87616</span>,“pi<span class="string">":math.Pi&#125;,“167"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"pow(x,3) + pow(y,3)"</span>,Env&#123;<span class="string">"x"</span>:<span class="number">12</span>,<span class="string">"y"</span>:<span class="number">1</span>&#125;,“<span class="number">1729</span><span class="string">"&#125;,</span></span><br><span class="line"><span class="string">&#123;"</span>pow(x,<span class="number">3</span>) + pow(y,<span class="number">3</span>)<span class="string">",Env&#123;"</span>x<span class="string">": 9,"</span>y<span class="string">":10&#125;,“1729"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"5 1 9\*(F - 32)"</span>, Env&#123;<span class="string">"F"</span>:<span class="number">-40</span>&#125;, <span class="string">"-40"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"5 1 9 \* (F - 32)"</span>, Env&#123;<span class="string">"F"</span>:<span class="number">32</span>&#125;,<span class="string">"e"</span>&#125;,</span><br><span class="line">&#123;<span class="string">"5 1 9 \* (F - 32)"</span>, Env&#123;<span class="string">"F"</span>: <span class="number">212</span>&#125;,<span class="string">"100"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> prevExpr <span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">仅在表达式变更时才输出</span><br><span class="line"><span class="keyword">if</span> test.expr != prevExpr&#123;</span><br><span class="line">fmt.Printf(<span class="string">"\n%s\n"</span>,test.expr)</span><br><span class="line">prevExpr= test.expr</span><br><span class="line">expr,err :=Parse(test.expr)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line">t.Error（err）<span class="comment">//解析出错</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">got :=fmt.Sprintf(\*%<span class="number">.6</span>g<span class="string">",expr.Eval(test.env))</span></span><br><span class="line"><span class="string">fmt.Printf("</span>\t%v=&gt;%s\n<span class="string">", test.env,got)</span></span><br><span class="line"><span class="string">if got != test.want&#123;</span></span><br><span class="line"><span class="string">t.Errorf("</span>%s.Eval() in %v = %q, want %q\n<span class="string">",</span></span><br><span class="line"><span class="string">test.expr, test.env, got, test.want)</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure></p>
<p>对于表格中的每一行记录，该测试先解析表达式，在上下文中求值，再输出表达式。这里没有足够的空间来显示Parse函数，但可以通过goget来下载源码，自行查看。</p>
<p>go test命令（参考11.1节）可用于运行包的测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -v gopl.io/ch7/<span class="built_in">eval</span></span><br></pre></td></tr></table></figure></p>
<p>启用-v选项后可以看到测试的输出，通常情况下对于结果正确的测试输出就不显示了下面就是测试中fmt.printf语句输出的内容。</p>
<p>幸运的是，到现在为止所有的输人都是合法的，但这种幸运是不能持久的。即使在解释性语言中，通过语法检查来发现静态错误（即不用运行程序也能检测出来的错误）也是很常见的。通过分离静态检查和动态检查，我们可以更快发现错误，也可以只在运行前检查一次，而不用在表达式求值时每次都检查。</p>
<p>让我们给Expr方法加上另外一个方法。Check方法用于在表达式语法树上检查静态错误。它的vars参数将稍后解释。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Expr <span class="keyword">interface</span> &#123;</span><br><span class="line">Eval(env Env) <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// Check方法报告表达式中的错误，并把表达式中的变量加入Vars中</span></span><br><span class="line">Check(vars <span class="keyword">map</span>[Var]<span class="keyword">bool</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的Check方法如下所示。literal和Var的求值不可能出错，所以Check方法返回 nil。unary和binary的方法首先检查操作符是否合法，再递归地检查操作数。类似地，call 的方法首先检查函数是否是已知的，然后检查参数个数是否正确，最后递归检查每个参数。</p>
<p>下面分两列展示了一些有错误的输人，以及它们触发的错误。Parse函数（没有显示）报告了语法错误，Check方法报告了语义错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x%2</span><br><span class="line">unexpected  %</span><br><span class="line">math.Pi</span><br><span class="line">unexpected</span><br><span class="line">!true</span><br><span class="line">unexpected</span><br><span class="line">&quot;hello&quot;</span><br><span class="line">unexpected 。</span><br><span class="line">log(10)</span><br><span class="line">unknown function &quot;log&quot;</span><br><span class="line">sqrt(1，2)</span><br><span class="line">call to sqrt has 2 args, want 1</span><br></pre></td></tr></table></figure></p>
<p>Check的输入参数是一个Var集合，它收集在表达中发现的变量名。要让表达式能成功求值，上下文必须包含所有的这些变量。从逻辑上来讲，这个集合应当是Check的输出结果而不是输人参数，但因为这个方法是递归调用的，在这种情况下使用参数更为方便。调用方在最初调用时需要提供一个空的集合。</p>
<p>在3.2节，我们绘制了一个函数f（x，y），不过函数是在编译时指定的。既然我们可以对字符串形式的表达式进行解析、检查和求值，那么就可以构建一个Web应用，在运行时从客户端接收一个表达式，并绘制函数的曲面图。可以使用vars集合来检查表达式是一个只有两个变量x、y的函数（为了简单起见，还提供了半径r，所以实际上是3个变量）。使用Check方法来拒绝掉不规范的表达式，避免了在接下来的40000次求值中重复检查（4个象限中100x100的格子）。<br>下面的parseAndCheck函数组合了解析和检查步骤：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch7/surface</span><br><span class="line"><span class="keyword">import</span> <span class="string">"gopl.io/ch7/eva1"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseAndcheck</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(eval.Expr,error)</span></span>&#123;</span><br><span class="line">ifs=e<span class="string">" "</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"empty expression"</span>)</span><br><span class="line">expr, err :=eval.Parse(s)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">]</span><br><span class="line">vars := <span class="built_in">make</span>(<span class="keyword">map</span>[eval.Var]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">if</span> err :=expr.check(vars);err!=<span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> v :=<span class="keyword">range</span> vars &#123;</span><br><span class="line"><span class="keyword">if</span> v!=<span class="string">"x"</span> &amp;&amp; v != <span class="string">"y"</span> &amp;&amp; v != <span class="string">"r"</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"undefined variable:%s"</span>,v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> expr, <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p>
<p>要构造完这个Web应用，仅需要增加下面的plot函数，其函数签名与http.HandlerFunc类似：</p>
<p>plot函数解析并检查HTTP请求中的表达式，并用它来创建一个有两个变量的匿名函数。这个匿名函数与原始曲面图绘制程序中的f有同样的签名，且能对用户提供的表达式进行求值。上下文定义了x、y和半径r。最后，plot调用了surface函数，surface函数来自gopl.io/ch3/surface中的main函数，略做修改，加了参数用于接受绘制函数和输出用的io.Writer，原始版本直接使用了函数f和os.stdout。图7-7显示了用这个程序绘制的三张曲面图。</p>
<p>练习7.13：给Expr增加一个string方法用来美化输出语法树。要求生成的语法树重新解析后是完全一致的树。</p>
<p>练习7.14：定义一个新的满足Expr接口的具体类，提供一个新操作，比如计算它的操作数的最小值。因为Parse函数无法实例化新创建的类型，所以测试时需要直接构造语法树（当然，也可以扩充一下解析函数）。</p>
<p>练习7.15：写一个程序从标准输入读取一个表达式，提示用户输人表达式中变量的值，最后计算表达式的值。请妥善处理各种异常。</p>
<p>练习7.16：写一个基于Web的计算器程序。</p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a><span style="color:#339AFF;">类型断言</span></h1><p>类型断言是一个作用在接口值上的操作，写出来类似于x.(T)，其中x是一个接口类型的表达式，而T是一个类型（称为断言类型）。类型断言会检查作为操作数的动态类型是否满足指定的断言类型。</p>
<p>这儿有两个可能。首先，如果断言类型T是一个具体类型，那么类型断言会检查x的动态类型是否就是T。如果检查成功，类型断言的结果就是x的动态值，类型当然就是T。换句话说，类型断言就是用来从它的操作数中把具体类型的值提取出来的操作。如果检查失败，那么操作崩溃。比如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">f := w.(*os.File)      <span class="comment">// 成功：f == os.stdout</span></span><br><span class="line">c := w.(*bytes.Buffer) <span class="comment">// 崩溃：接口持有的是*os.File，不是*bytes.Buffer</span></span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure></p>
<p>其次，如果断言类型T是一个接口类型，那么类型断言检查x的动态类型是否满足T。如果检查成功，动态值并没有提取出来，结果仍然是一个接口值，接口值的类型和值部分也没有变更，只是结果的类型为接口类型T。换句话说，类型断言是一个接口值表达式，从一个接口类型变为拥有另外一套方法的接口类型（通常方法数量是增多），但保留了接口值中的动态类型和动态值部分。</p>
<p>如下类型断言代码中，w和rw都持有os.Stdout，于是所有对应的动态类型都是*os.File，但w作为io.Writer仅暴露了文件的Write方法，而rw还暴露了它的Read方法。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">rw := w.(io.ReadWriter) <span class="comment">// 成功：*os.File有Read和Write方法</span></span><br><span class="line">w = <span class="built_in">new</span>(ByteCounter)</span><br><span class="line">rw = w.(io.ReadWriter)  <span class="comment">// 崩溃：*ByteCounter没有Read方法</span></span><br></pre></td></tr></table></figure></p>
<p>无论哪种类型作为断言类型，如果操作数是一个空接口值，类型断言都失败。很少需要从一个接口类型向一个要求更宽松的类型做类型断言，该宽松类型的接口方法比原类型的少，而且是其子集。因为除了在操作nil之外的情况下，在其他情况下这种操作与赋值一致。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = rw             <span class="comment">// io.ReadWriter可以赋给io.Writer</span></span><br><span class="line">w = rw.(io.Writer) <span class="comment">// 仅当rw==nil时失败</span></span><br></pre></td></tr></table></figure></p>
<p>我们经常无法确定一个接口值的动态类型，这时就需要检测它是否是某一个特定类型。如果类型断言出现在需要两个结果的赋值表达式（比如如下的代码）中，那么断言不会在失败时崩溃，而是会多返回一个布尔型的返回值来指示断言是否成功。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.Stdout</span><br><span class="line">f, ok := w.(*os.File)       <span class="comment">// 成功：ok,f == os.Stdout</span></span><br><span class="line">b, ok := w.(*bytes.Buffer)  <span class="comment">// 失败：!ok,b == nil</span></span><br></pre></td></tr></table></figure></p>
<p>按照惯例，一般把第二个返回值赋给一个名为ok的变量。如果操作失败，ok为false，而第一个返回值为断言类型的零值，在这个例子中就是*bytes.Buffer的空指针。</p>
<p>ok返回值通常马上就用来决定下一步做什么。下面if表达式的扩展形式就可以让我们写出相当紧凑的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...使用f...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当类型断言的操作数是一个变量时，有时你会看到返回值的名字与操作数变量名一致，原有的值就被新的返回值掩盖了，比如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> w, ok := w.(*os.File); ok &#123;</span><br><span class="line">    <span class="comment">// ...use w...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用类型断言来识别错误"><a href="#使用类型断言来识别错误" class="headerlink" title="使用类型断言来识别错误"></a><span style="color:#339AFF;">使用类型断言来识别错误</span></h1><p>考虑一下os包中的文件操作返回的错误集合，I/O会因为很多原因失败，但有三类原因通常必须单独处理：文件已存储（创建操作），文件没找到（读取操作）以及权限不足。os包提供了三个帮助函数用来对错误进行分类：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsNotExist</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">IsPermission</span><span class="params">(err error)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure></p>
<p>一个幼稚的实现会通过检查错误消息是否包含特定的字符串来做判断：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err error)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意：不健壮</span></span><br><span class="line">    <span class="keyword">return</span> strings.Contains(err.Error(),<span class="string">"file does not exist"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但由于处理I/O错误的逻辑会随着平台的变化而变化，因此这种方法很不健壮，同样的错误可能会用完全不同的错误消息来报告。检查错误消息是否包含特定的字符串，这种方法在单元测试中还算够用，但对于生产级的代码则远远不够。</p>
<p>一个更可靠的方法是用专门的类型来表示结构化的错误值。os包定义了一个PathError类型来表示在与一个文件路径相关的操作上发生错误（比如Open或者Delete），一个类似的LinkError用来表述在与两个文件路径相关的操作上发生错误（比如Symlink和Rename）。下面是os.PathError的定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op <span class="keyword">string</span></span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    Err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Op + <span class="string">" "</span> + <span class="string">": "</span> + e.Err.Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很多客户端忽略了PathError，改用一种统一的方法来处理所有的错误，即调用Error方法。PathError的Error方法只是拼接了所有的字段，而PathError的结构则保留了错误所有的底层信息。对于那些需要区分错误的客户端，可以使用类型断言来检查错误的特定类型，这些类型包含的细节远远多于一个简单的字符串。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err := os.Open(<span class="string">"/no/such/file"</span>)</span><br><span class="line">fmt.Println(err) <span class="comment">// open /no/such/file: no such file or directory</span></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>,err)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// &amp;fs.PathError&#123;Op:"open", Path:"/no/such/file", Err:0x2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这也是之前三个帮助函数的工作方式。比如，如下所示的IsNotExist判断错误是否等于 syscal1.ENOENT（参见7.8节），或者等于另一个错误os.ErrNotExist（参见5.4.2节的io.EoF），或者是一个*patherror，并且底层的错误是上面二者之一。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> ErrNotExist = errors.New(<span class="string">"file does not exist"</span>)</span><br><span class="line"><span class="comment">// IsNotExist返回一个布尔值，该值表明错误是否代表文件或目录不存在</span></span><br><span class="line"><span class="comment">// ErrNotExist和其他一些系统调用错误会返回true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotExist</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> pe, ok := err.(*PathError); ok &#123;</span><br><span class="line">        err = pe.Err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err == syscall.ENOENT || err == ErrNotExist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际使用情况如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err := os.Open(<span class="string">"/no/such/file"</span>)</span><br><span class="line">fmt.Println(os.IsNotExist(err)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>当然，如果错误消息已被fmt.Errorf这类的方法合并到一个大字符串中，那么Patherror的结构信息就丢失了。错误识别通常必须在失败操作发生时马上处理，而不是等到错误消息返回给调用者之后。</p>
<h1 id="通过接口类型断言来查询特性"><a href="#通过接口类型断言来查询特性" class="headerlink" title="通过接口类型断言来查询特性"></a><span style="color:#339AFF;">通过接口类型断言来查询特性</span></h1><p>下面这段代码的逻辑类似于<code>net/http</code>包中的Web服务器向客户端响应诸如“Content-type:text/html”这样的HTTP头字段。<code>io.Writer w</code>代表HTTP响应，写入的字节最终会发到某人的Web浏览器上。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeader</span><span class="params">(w io.Writer, contentType <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write([]<span class="keyword">byte</span>(<span class="string">"Content-Type: "</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := w.Write([]<span class="keyword">byte</span>(contentType)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为Write方法需要一个字节slice，而我们想写入的是一个字符串，所以<code>[]byte(...)</code>转换就是必需的。这种转换需要进行内存分配和内存复制，但复制后的内存又会被马上抛弃。让我们假装这是Web服务器的核心部分，而且性能分析表明这个内存分配导致性能下降。那么我们能否避开内存分配呢？</p>
<p>从<code>io.Writer</code>接口我们仅仅能知道w中具体类型的一个信息，那就是可以写入字节slice。但如果我们深入<code>net/http</code>包查看，可以看到w对应的动态类型还支持一个能高效写入字符串的Writestring方法，这个方法避免了临时内存的分配和复制。（这个有点盲目猜测，但很多实现了<code>io.Write</code>r的重要类也有Writestring方法，比如<code>*bytes.Buffer</code>、<code>*os.File</code>和<code>*bufio.Write</code>。)</p>
<p>我们无法假定任意一个io.Writer w也有Writestring方法。但可以定义一个新的接口这个接口只包含Writestring方法，然后使用类型断言来判断w的动态类型是否满足这个新接口。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writestring将s写入w</span></span><br><span class="line"><span class="comment">//如果W有Writestring方法，那么将直接调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writestring</span><span class="params">(w io.Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line"><span class="keyword">type</span> stringWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">WriteString(<span class="keyword">string</span>)(nint, err error)</span><br><span class="line">tsw. ok := w.(stringWriter);ok</span><br><span class="line"><span class="keyword">return</span> sw.writestring（s）<span class="comment">//避免了内存复制</span></span><br><span class="line"><span class="keyword">return</span> w.Write（[]<span class="keyword">byte</span>（s））<span class="comment">//分配了临时内存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeHeader</span><span class="params">(w io.Writer, contentType <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">if_, err :=writestring(w,<span class="string">"Content-Type:"</span>);err!=<span class="literal">nil</span>&#123; <span class="keyword">return</span> err</span><br><span class="line">if_, err :=writestring(w, contentType); err!=<span class="literal">nil</span>&#123; <span class="keyword">return</span> err</span><br></pre></td></tr></table></figure></p>
<p>为了避免代码重复，我们把检查挪到了工具函数writestring中。实际上，标准库提供了io.Writestring，而且这也是向io.Writer写入字符串的推荐方法。</p>
<p>这个例子中比较古怪的地方是并没有一个标准的接口定义了Writestring方法并且指定它应满足的规范。进一步讲，一个具体的类型是否满足stringWriter接口仅仅由它拥有的方法来决定，而不是这个类型与一个接口类型之间的一个关系声明。这意味着上面的技术依赖于一个假定，即如果一个类型满足下面的接口，那么Writestring（s）必须与Write（[]byte（s））等效。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> &#123;</span><br><span class="line">io.Writer</span><br><span class="line">WriteString(s <span class="keyword">string</span>)(nint,err error)&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管io.writestring文档中提到了这个假定，但在调用它的函数的文档中就很少提到这个假定了。给一个特定类型多定义一个方法，就隐式地接受了一个特性约定。Go语言的初学者，特别是那些具有强类型语言背景的人，会对这种缺乏显式约定的方式感到不安，但在实践中很少产生问题。撇开空接口interface{}不谈，很少有因为无意识的巧合导致错误的接口匹配。</p>
<p>前面的writestring函数使用类型断言来判定一个更普适接口类型的值是否满足一个更专用的接口类型，如果满足，则可以使用后者所定义的方法。这种技术不仅适用于io.Readwriter这种标准接口，还适用于stringwriter这种自定义类型。</p>
<p>这个方法也用在了fmt.Printf中，用于从通用类型中识别出error或者fmt.stringer。在fmt.Fprintf内部，有一步是把单个操作数转换为一个字符串，如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fmt</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatoneValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err, ok :=x.(error);ok&#123;</span><br><span class="line"><span class="keyword">return</span> err.Error()</span><br><span class="line"><span class="keyword">if</span> str, ok := x.(Stringer);ok&#123;</span><br><span class="line"><span class="keyword">return</span> str.<span class="keyword">string</span>()</span><br><span class="line">]</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<p>.所有其他类型..<br>如果x满足这两种接口中的一个，就直接确定格式化方法。如果不满足，默认处理部分大致会使用反射来处理所有其他类型，详细情况在第12章讨论。</p>
<p>再说一次，上面的代码给出了一个假定，任何有String方法的类型都满足了fmt.Stringer的约定，即把类型转化为一个适合输出的字符串。</p>
<h1 id="类型分支"><a href="#类型分支" class="headerlink" title="类型分支"></a><span style="color:#339AFF;">类型分支</span></h1><p>接口有两种不同的风格。第一种风格下，典型的比如<code>io.Reader</code>、<code>io.Writer</code>、<code>fmt.Stringer</code>、<code>sort.Interface</code>、<code>http.Handler</code>和error，接口上的各种方法突出了满足这个接口的具体类型之间的相似性，但隐藏了各个具体类型的布局和各自特有的功能。这种风格强调了方法，而不是具体类型。</p>
<p>第二种风格则充分利用了接口值能够容纳各种具体类型的能力，它把接口作为这些类型的联合（union）来使用。类型断言用来在运行时区分这些类型并分别处理。在这种风格中，强调的是满足这个接口的具体类型，而不是这个接口的方法（何况经常没有），也不注重信息隐藏。我们把这种风格的接口使用方式称为可识别联合（discriminated union）。</p>
<p>如果你对面向对象编程很熟悉，那么你就知道这两种风格分别对应子类型多态（subtype polymorphism）和特设多态（ad hoc polymorphism），当然这些名词并不重要。本章其余部分将结合示例对第二种风格的接口进行讲解。</p>
<p>与其他语言一样，Go语言的数据库SQL查询API也允许我们干净地分离查询中的不变部分和可变部分。一个示例客户端如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listTracks</span><span class="params">(db sql.DB, artist <span class="keyword">string</span>, minYear, maxYear <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result, err := db.Exec(</span><br><span class="line">        <span class="string">"SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?"</span>,</span><br><span class="line">        artist, minYear, maxYear)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Exec方法把查询字符串中的每一个“?”都替换为与相应参数值对应的SQL字面量，这些参数可能是布尔型、数字、字符串或者nil。通过这种方式构造请求可以帮助避免SQL注入攻击，攻击者可以通过在输入数据中加入不恰当的引号来控制你的查询。在Exec的实现代码中，可以发现一个类似如下的函数，将每个参数值转为对应的SQL字面量。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqlQuote</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"NULL"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="keyword">int</span>); ok&#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>,x)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> _, ok := x.(<span class="keyword">uint</span>); ok&#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%d"</span>,x)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> b, ok := x.(<span class="keyword">bool</span>); ok&#123;</span><br><span class="line">        <span class="keyword">if</span> b &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"TRUE"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"FALSE"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> s, ok := x.(<span class="keyword">string</span>); ok&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlQuoteString(s) <span class="comment">// (not shown)</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"unexpected type %T:%v"</span>,x,x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个switch语句可以把包含一长串值相等比较的<code>if-else</code>语句简化掉。一个相似的类型分支（type switch）语句则可以用来简化一长串的类型断言<code>if-else</code>语句。</p>
<p>类型分支的最简单形式与普通分支语句类似，两个的差别是操作数改为<code>x.(type)</code>（注意：这里直接写关键词type，而不是一个特定类型），每个分支是一个或者多个类型。类型分支的分支判定基于接口值的动态类型，其中nil分支需要<code>x==nil</code>，而default分支则在其他分支都没有满足时才运行。sqlQuote的类型分支会有如下几个：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:       <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>, <span class="keyword">uint</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>:      <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与普通的switch语句（参考1.8节）类似，分支是按顺序来判定的，当一个分支符合时，对应的代码会执行。分支的顺序在一个或多个分支是接口类型时会变得重要，因为有可能两个分支都能满足。default分支的位置是无关紧要的。另外，类型分支不允许使用fallthrough。</p>
<p>注意，在原来的代码中，bool和string分支的逻辑需要访问由类型断言提取出来的原始值。这个需求比较典型，所以类型分支语句也有一种扩展形式，它用来把每个分支中提取出来的原始值绑定到一个新的变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x:=x.(<span class="keyword">type</span>)&#123;/\*...\*/&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里把新的变量也命名为x，与类型断言类似，重用变量名也很普遍。与switch语句类似，类型分支也隐式创建了一个词法块，所以声明一个新变量叫x并不与外部块中的变量x冲突。每个分支也会隐式创建各自的词法块。</p>
<p>用类型分支的扩展形式重写后的sqlQuote就更加清晰易读了：</p>
<p>在这个版本中，每个单一类型的分支块内，变量x的类型都与该分支的类型一致。比如，在bool分支中x的类型是bool，在string分支中则是string。在其他分支中，x的类型则与switch的操作数一致，在这个例子中就是interface{}。如果多个分支执行的代码一致，比如本例中的int和uint，使用类型分支语句就方便很多。</p>
<p>尽管sq1Quote支持任意类型的实参，但仅当实参类型能够符合类型分支中的一个时才能正常运行到结束，对于其他情况就会崩溃并抛出一条“unexpected type”（非期望类型）消息。表面上x的类型是interface{}，实际上我们把它当作int、uint、bool、string和nil的一个可识别联合。</p>
<h1 id="示例：基于标记的XML解析"><a href="#示例：基于标记的XML解析" class="headerlink" title="示例：基于标记的XML解析"></a><span style="color:#339AFF;">示例：基于标记的XML解析</span></h1><p>4.5节展示了如何用encoding/json包的Marshal和Unmarshal函数来把JSON文档解析为Go语言的数据结构。encoding/xml包提供了一个相似的API。当需要构造一个完整文档树的结构时这很方便，但对于很多程序这是不必要的。encoding/xml还为解析API提供了一个基于标记的底层XML。在这些API中，解析器读人输人文本，然后输出一个标记流。标记流中主要包含四种类型：StartElement、EndElement、charData和Comment，这四种类型都是encoding/xml包中的一个具体类型。每次调用（*xm1.Decoder）.Token都会返回一个标记。<br>API相关的部分如下所示。</p>
<p>Token的接口没有任何方法，这也是一个可识别联合的典型示例。一个传统的接口（比如io.Reader）的目标是隐藏具体类型的细节，这样可以轻松创建满足接口的新实现，对于每一种实现，使用方的处理方式都是一样的。可识别联合类型的接口正好与之相反，它的实现类型是固定的而不是随意增加的，实现类型是暴露的而不是隐藏的。可识别联合类型很少有方法，操作它的函数经常会使用类型switch，然后对每种类型应用不同的逻辑。</p>
<p>下面的xmlselect程序提取并输出XML文档树中特定元素下的文本。利用上面的API，可以在一遍扫描中就完成这个任务，还不用生成相应的文档树。</p>
<p>在main函数的每次循环中，如果遇到StartElement，就把元素的名字人栈，遇到 EndElement则把元素名字出栈。API保证了StartElement和EndElement标记是正确匹配的，对于不规范的文档也是如此。Comments被忽略了。当xmlselect遇到CharData时，如果栈中的元素名按顺序包含命令行参数中给定的名称，就输出对应的文本。</p>
<p>如下命令输出了在两层div元素下h2元素的内容。输人的内容是XML规范，这份规范本身也是一个XML文档：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch1/fetch</span><br><span class="line">$./fetchhttp://www.w3.org/TR/2006/REC-xm111-20060816|</span><br><span class="line">./xmlselect div div h2</span><br><span class="line">html body div div h2:1 Introduction</span><br><span class="line">html body div div h2:2 Documents</span><br><span class="line">html body div div h2: 3 Logical Structures</span><br><span class="line">html body div div h2: 4 Physical structures</span><br><span class="line">html body div div h2: 5 Conformance</span><br><span class="line">html body div div h2:6 Notation</span><br><span class="line">html body div div h2:A References</span><br><span class="line">html body div div h2:B Definitions <span class="keyword">for</span> character Normalization</span><br></pre></td></tr></table></figure></p>
<p>练习7.17：扩展xmlselect，让我们不仅可以用名字，还可以用CSS风格的属性来做选择。比如一个《divid=”page”class=”wide”》元素，不仅可以通过名字，还可以通过id和class来做匹配</p>
<p>练习7.18：使用基于标记的解析API，写一个程序来读人一个任意的XML文档，构造出一棵树来展现XML中的主要节点。节点包括两种类型：CharData节点表示文本字符串，Element节点表示元素及其属性。每个元素节点包含它的子节点数组。</p>
<p>可以参考如下类型定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"encoding/xml"</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">interface</span>&#123;&#125;<span class="number">1</span>I charData或\*Element</span><br><span class="line"><span class="keyword">type</span> CharData <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">Type xml.Name</span><br><span class="line">Attr []xml.Attr</span><br><span class="line">Children []Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a><span style="color:#339AFF;">一些建议</span></h1><p>当设计一个新包时，一个新手Go程序员会首先创建一系列接口，然后再定义满足这些接口的具体类型。这种方式会产生很多接口，但这些接口只有一个单独的实现。不要这样做。这种接口是不必要的抽象，还有运行时的成本。可以用导出机制（参考6.6节）来限制一个类型的哪些方法或结构体的哪些字段是对包外可见的。仅在有两个或者多个具体类型需要按统一的方式处理时才需要接口。</p>
<p>这个规则也有特例，如果接口和类型实现出于依赖的原因不能放在同一个包里边，那么一个接口只有一个具体类型实现也是可以的。在这种情况下，接口是一种解耦两个包的好方式。</p>
<p>因为接口仅在有两个或者多个类型满足的情况下存在，所以它就必然会抽象掉那些特有的实现细节。这种设计的结果就是出现了具有更简单和更少方法的接口，比如<code>io.Writer</code>和<code>fmt.Stringer</code>都只有一个方法。设计新类型时越小的接口越容易满足。一个不错的接口设计经验是仅要求你需要的。</p>
<p>本章关于方法和接口的讲解就结束了。Go语言能很好地支持面向对象编程风格，但这并不意味着你只能使用它。不是所有东西都必须是一个对象，全局函数应该有它们的位置，不完全封装的数据类型也应该有位置。综合来看，在本书第1章～第5章的示例中，我们用到的方法（比如<code>input.Scan</code>）不超过两打，这与诸如<code>fmt.Printf</code>之类的普通函数比起来并不多。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go程序设计语言/" rel="tag"># Go程序设计语言</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/15/第2章-理解类型/" rel="next" title="第2章 理解类型">
                <i class="fa fa-chevron-left"></i> 第2章 理解类型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/19/第1章-初识Go语言/" rel="prev" title="第1章 初识Go语言">
                第1章 初识Go语言 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#接口即约定"><span class="nav-number">1.</span> <span class="nav-text">接口即约定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口类型"><span class="nav-number">2.</span> <span class="nav-text">接口类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现接口"><span class="nav-number">3.</span> <span class="nav-text">实现接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用flag-Value来解析参数"><span class="nav-number">4.</span> <span class="nav-text">使用flag.Value来解析参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口值"><span class="nav-number">5.</span> <span class="nav-text">接口值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用sort-Interface来排序"><span class="nav-number">6.</span> <span class="nav-text">使用sort.Interface来排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http-Handler接口"><span class="nav-number">7.</span> <span class="nav-text">http.Handler接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#error接口"><span class="nav-number">8.</span> <span class="nav-text">error接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：表达式求值器"><span class="nav-number">9.</span> <span class="nav-text">示例：表达式求值器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型断言"><span class="nav-number">10.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用类型断言来识别错误"><span class="nav-number">11.</span> <span class="nav-text">使用类型断言来识别错误</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过接口类型断言来查询特性"><span class="nav-number">12.</span> <span class="nav-text">通过接口类型断言来查询特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型分支"><span class="nav-number">13.</span> <span class="nav-text">类型分支</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：基于标记的XML解析"><span class="nav-number">14.</span> <span class="nav-text">示例：基于标记的XML解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些建议"><span class="nav-number">15.</span> <span class="nav-text">一些建议</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
