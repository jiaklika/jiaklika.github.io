<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  Web服务需要在各自独立的套接字（socket）上同时接收多个数据请求是并发。那什么是并行呢？ 并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。怎么理解？ Go语言运行时的调度器是一个复杂的软件，能管理被创建的所有goroutine并为其分配执行时间。操作系统会在物理处理器上调度线程来运行，而Go语言的运行时会在逻辑处理器上调度gorou">
<meta name="keywords" content="Go语言实战">
<meta property="og:type" content="article">
<meta property="og:title" content="第6章 并发">
<meta property="og:url" content="http://yoursite.com/2021/08/19/第6章-并发/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  Web服务需要在各自独立的套接字（socket）上同时接收多个数据请求是并发。那什么是并行呢？ 并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。怎么理解？ Go语言运行时的调度器是一个复杂的软件，能管理被创建的所有goroutine并为其分配执行时间。操作系统会在物理处理器上调度线程来运行，而Go语言的运行时会在逻辑处理器上调度gorou">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-并发/1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-并发/2.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-并发/3.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-并发/4.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-并发/5.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-并发/6.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-并发/7.jpg">
<meta property="og:updated_time" content="2022-03-25T03:32:49.213Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第6章 并发">
<meta name="twitter:description" content="思考并回答以下问题：  Web服务需要在各自独立的套接字（socket）上同时接收多个数据请求是并发。那什么是并行呢？ 并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。怎么理解？ Go语言运行时的调度器是一个复杂的软件，能管理被创建的所有goroutine并为其分配执行时间。操作系统会在物理处理器上调度线程来运行，而Go语言的运行时会在逻辑处理器上调度gorou">
<meta name="twitter:image" content="http://yoursite.com/2021/08/19/第6章-并发/1.jpg">






  <link rel="canonical" href="http://yoursite.com/2021/08/19/第6章-并发/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第6章 并发 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/19/第6章-并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第6章 并发

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-19 17:41:40" itemprop="dateCreated datePublished" datetime="2021-08-19T17:41:40+08:00">2021-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-03-25 11:32:49" itemprop="dateModified" datetime="2022-03-25T11:32:49+08:00">2022-03-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">28k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">25 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>Web服务需要在各自独立的套接字（socket）上同时接收多个数据请求是并发。那什么是并行呢？</li>
<li>并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。怎么理解？</li>
<li>Go语言运行时的调度器是一个复杂的软件，能管理被创建的所有goroutine并为其分配执行时间。操作系统会在物理处理器上调度线程来运行，而Go语言的运行时会在逻辑处理器上调度goroutine来运行。怎么理解？</li>
<li>可以将进程看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器。这些资源包括但不限于内存地址空间、文件和设备的句柄以及线程。进程包含线程吗？</li>
<li>不仅可以使用原子函数和互斥锁来保证对共享资源的安全访问以及消除竞争状态，还可以使用通道。都是怎么做的？</li>
</ul>
<a id="more"></a>
<p>【本章主要内容】</p>
<ul>
<li>使用goroutine运行程序</li>
<li>检测并修正竞争状态</li>
<li>利用通道共享数据</li>
</ul>
<p>通常程序会被编写为一个顺序执行并完成一个独立任务的代码。如果没有特别的需求，最好总是这样写代码，因为这种类型的程序通常很容易写，也很容易维护。不过也有一些情况下，并行执行多个任务会有更大的好处。一个例子是，Web服务需要在各自独立的套接字（socket）上同时接收多个数据请求。每个套接字请求都是独立的，可以完全独立于其他套接字进行处理。具有并行执行多个请求的能力可以显著提高这类系统的性能。考虑到这一点，Go语言的语法和运行时直接内置了对并发的支持。</p>
<p>Go语言里的并发指的是能让某个函数独立于其他函数运行的能力。当一个函数创建为goroutine时，Go会将其视为一个独立的工作单元。这个单元会被调度到可用的逻辑处理器上执行。<span style="color:red">Go语言运行时的调度器是一个复杂的软件，能管理被创建的所有goroutine并为其分配执行时间。这个调度器在操作系统之上，将操作系统的线程与语言运行时的逻辑处理器绑定，并在逻辑处理器上运行goroutine。调度器在任何给定的时间，都会全面控制哪个goroutine要在哪个逻辑处理器上运行。</span></p>
<p>Go语言的并发同步模型来自一个叫作通信顺序进程（Communicating Sequential Processes，CSP）的范型（paradigm）。CSP是一种消息传递模型，通过在goroutine之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。用于在goroutine之间同步和传递数据的关键数据类型叫作通道（channel），对于没有使用过通道写并发程序的程序员来说，通道会让他们感觉神奇而兴奋。希望读者使用后也能有这种感觉。使用通道可以使编写并发程序更容易，也能够让并发程序出错更少。</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a><span style="color:#339AFF;">并发与并行</span></h1><p>让我们先来学习一下抽象程度较高的概念：什么是操作系统的线程（thread）和进程（process）。这会有助于后面理解Go语言运行时调度器如何利用操作系统来并发运行goroutine。当运行一个应用程序（如一个IDE或者编辑器）的时候，操作系统会为这个应用程序启动一个进程。<span style="color:red">可以将这个进程看作一个包含了应用程序在运行中需要用到和维护的各种资源的容器。</span></p>
<p>图6-1展示了一个包含所有可能分配的常用资源的进程。这些资源包括但不限于内存地址空间、文件和设备的句柄以及线程。一个线程是一个执行空间，这个空间会被操作系统调度来运行函数中所写的代码。每个进程至少包含一个线程，每个进程的初始线程被称作主线程。因为执行这个线程的空间是应用程序的本身的空间，所以当主线程终止时，应用程序也会终止。操作系统将线程调度到某个处理器上运行，这个处理器并不一定是进程所在的处理器。不同操作系统使用的线程调度算法一般都不一样，但是这种不同会被操作系统屏蔽，并不会展示给程序员。</p>
<blockquote>
<p>图6-1 一个运行的应用程序的进程和线程的简要描绘</p>
</blockquote>
<img src="/2021/08/19/第6章-并发/1.jpg">
<p>操作系统会在物理处理器上调度线程来运行，而Go语言的运行时会在逻辑处理器上调度goroutine来运行。每个逻辑处理器都分别绑定到单个操作系统线程。在1.5版本（直到目前最新的1.8版本都是同一逻辑。可预见的未来版本也会保持这个逻辑）上，Go语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器。在1.5版本之前的版本中，默认给整个应用程序只分配一个逻辑处理器。这些逻辑处理器会用于执行所有被创建的goroutine。即便只有一个逻辑处理器，Go也可以以神奇的效率和性能，并发调度无数个goroutine。</p>
<p>在图6-2中，可以看到操作系统线程、逻辑处理器和本地运行队列之间的关系。如果创建一个goroutine并准备运行，这个goroutine就会被放到调度器的全局运行队列中。之后，调度器就将这些队列中的goroutine分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中。本地运行队列中的goroutine会一直等待直到自己被分配的逻辑处理器执行。</p>
<blockquote>
<p>图6-2 Go调度器如何管理goroutine</p>
</blockquote>
<img src="/2021/08/19/第6章-并发/2.jpg">
<p>有时，正在运行的goroutine需要执行一个阻塞的系统调用，如打开一个文件。当这类调用发生时，线程和goroutine会从逻辑处理器上分离，该线程会继续阻塞，等待系统调用的返回。与此同时，这个逻辑处理器就失去了用来运行的线程。所以，调度器会创建一个新线程，并将其绑定到该逻辑处理器上。之后，调度器会从本地运行队列里选择另一个goroutine来运行。一旦被阻塞的系统调用执行完成并返回，对应的goroutine会放回到本地运行队列，而之前的线程会保存好，以便之后可以继续使用。</p>
<p>如果一个goroutine需要做一个网络I/O调用，流程上会有些不一样。在这种情况下，goroutine会和逻辑处理器分离，并移到集成了网络轮询器的运行时。一旦该轮询器指示某个网络读或者写操作已经就绪，对应的goroutine就会重新分配到逻辑处理器上来完成操作。调度器对可以创建的逻辑处理器的数量没有限制，但语言运行时默认限制每个程序最多创建10000个线程。这个限制值可以通过调用<code>runtime/debug</code>包的SetMaxThreads方法来更改。如果程序试图使用更多的线程，就会崩溃。</p>
<p>并发（concurrency）不是并行（parallelism），并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。这种“使用较少的资源做更多的事情”的哲学，也是指导Go语言设计的哲学。</p>
<p>如果希望让goroutine并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器会将goroutine平等分配到每个逻辑处理器上。这会让goroutine在不同的线程上运行。不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕Go语言运行时使用多个线程，goroutine依然会在同一个物理处理器上并发运行，达不到并行的效果。</p>
<p>图6-3展示了在一个逻辑处理器上并发运行goroutine和在两个逻辑处理器上并行运行两个并发的goroutine之间的区别。调度器包含一些聪明的算法，这些算法会随着Go语言的发布被更新和改进，所以不推荐盲目修改语言运行时对逻辑处理器的默认设置。如果真的认为修改逻辑处理器的数量可以改进性能，也可以对语言运行时的参数进行细微调整。后面会介绍如何做这种修改。</p>
<blockquote>
<p>图6-3 并发和并行的区别</p>
</blockquote>
<img src="/2021/08/19/第6章-并发/3.jpg">
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a><span style="color:#339AFF;">goroutine</span></h1><p>让我们再深入了解一下调度器的行为，以及调度器是如何创建goroutine并管理其寿命的。我们会先通过在一个逻辑处理器上运行的例子来讲解，再来讨论如何让goroutine并行运行。代码清单6-1所示的程序会创建两个goroutine，以并发的形式分别显示大写和小写的英文字母。</p>
<blockquote>
<p>代码清单6-1 listing01.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何创建goroutine</span></span><br><span class="line"><span class="comment">// 以及调度器的行为</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 分配一个逻辑处理器给调度器使用</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg用来等待程序完成</span></span><br><span class="line">    <span class="comment">// 计数加2，表示要等待两个goroutine</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Start Goroutines"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个匿名函数，并创建一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示字母表3次</span></span><br><span class="line">        <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</span><br><span class="line">            <span class="keyword">for</span> char := <span class="string">'a'</span>; char &lt; <span class="string">'a'</span>+<span class="number">26</span>; char++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%c "</span>, char)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个匿名函数，并创建一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示字母表3次</span></span><br><span class="line">        <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</span><br><span class="line">            <span class="keyword">for</span> char := <span class="string">'A'</span>; char &lt; <span class="string">'A'</span>+<span class="number">26</span>; char++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%c "</span>, char)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待goroutines结束</span></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码清单6-1的第14行，调用了runtime包的GOMAXPROCS函数。这个函数允许程序更改调度器可以使用的逻辑处理器的数量。如果不想在代码里做这个调用，也可以通过修改和这个函数名字一样的环境变量的值来更改逻辑处理器的数量。给这个函数传入1，是通知调度器只能为该程序使用一个逻辑处理器。</p>
<p>在第24行和第37行，我们声明了两个匿名函数，用来显示英文字母表。第24行的函数显示小写字母表，而第37行的函数显示大写字母表。这两个函数分别通过关键字go创建goroutine来执行。根据代码清单6-2中给出的输出可以看到，每个goroutine执行的代码在一个逻辑处理器上并发运行的效果。</p>
<blockquote>
<p>代码清单6-2 listing01.go的输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Start Goroutines</span><br><span class="line">Waiting To Finish</span><br><span class="line">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M </span><br><span class="line">N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z </span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m </span><br><span class="line">n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z </span><br><span class="line">Terminating Program</span><br></pre></td></tr></table></figure>
<p>第一个goroutine完成所有显示需要花的时间太短了，以至于在调度器切换到第二个goroutine之前，就完成了所有任务。这也是为什么会看到先输出了所有的大写字母，之后才输出小写字母。我们创建的两个goroutine一个接一个地并发运行，独立完成显示字母表的任务。</p>
<p>如代码清单6-3所示，一旦两个匿名函数创建goroutine来执行，main中的代码会继续运行。这意味着main函数会在goroutine完成工作前返回。如果真的返回了，程序就会在goroutine有机会运行前终止。因此，在第51行，main函数通过WaitGroup，等待两个goroutine完成它们的工作。</p>
<blockquote>
<p>代码清单6-3 listing01.go：第17行到第19行，第23行到第26行，第49行到第51行</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wg用来等待程序完成</span></span><br><span class="line"><span class="comment">// 计数加2，表示要等待两个goroutine</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个匿名函数，并创建一个goroutine</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待goroutines结束</span></span><br><span class="line">fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>waitGroup是一个计数信号量，可以用来记录并维护运行的goroutine。如果waitGroup的值大于0，wait方法就会阻塞。在第18行，创建了一个waitGroup类型的变量，之后在第19行，将这个waitGroup的值设置为2，表示有两个正在运行的goroutine。为了减小WaitGroup的值并最终释放main函数，要在第26和39行，使用defer声明在函数退出时调用Done方法。</p>
<p>关键字defer会修改函数调用时机，在正在执行的函数返回时才真正调用defer声明的函数。对这里的示例程序来说，我们使用关键字defer保证，每个goroutine一旦完成其工作就调用Done方法。</p>
<p>基于调度器的内部算法，一个正运行的goroutine在工作结束前，可以被停止并重新调度。调度器这样做的目的是防止某个goroutine长时间占用逻辑处理器。当goroutine占用时间过长时调度器会停止当前正运行的goroutine，并给其他可运行的goroutine运行的机会。</p>
<p>图6-4从逻辑处理器的角度展示了这一场景。在第1步，调度器开始运行goroutineA，而goroutineB在运行队列里等待调度。之后，在第2步，调度器交换了goroutineA和goroutineB。由于goroutineA并没有完成工作，因此被放回到运行队列。之后，在第3步，goroutineB完成了它的工作并被系统销毁。这也让goroutineA继续之前的工作。</p>
<blockquote>
<p>图6-4 goroutine在逻辑处理器的线程上进行交换</p>
</blockquote>
<img src="/2021/08/19/第6章-并发/4.jpg">
<p>可以通过创建一个需要长时间才能完成其工作的goroutine来看到这个行为，如代码清单6-4所示。</p>
<blockquote>
<p>代码清单6-4 listing04.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示goroutine调度器是如何在单个线程上</span></span><br><span class="line"><span class="comment">// 切分时间片的</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg用来等待程序完成</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 分配一个逻辑处理器给调度器使用</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数加2，表示要等待两个goroutine</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutines</span></span><br><span class="line">    fmt.Println(<span class="string">"Create Goroutines"</span>)</span><br><span class="line">    <span class="keyword">go</span> printPrime(<span class="string">"A"</span>)</span><br><span class="line">    <span class="keyword">go</span> printPrime(<span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待goroutine结束</span></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Terminating Program"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// printPrime显示5000以内的素数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPrime</span><span class="params">(prefix <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">    <span class="keyword">for</span> outer := <span class="number">2</span>; outer &lt; <span class="number">5000</span>; outer++ &#123;</span><br><span class="line">        <span class="keyword">for</span> inner := <span class="number">2</span>; inner &lt; outer; inner++ &#123;</span><br><span class="line">            <span class="keyword">if</span> outer%inner == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"%s:%d\n"</span>, prefix, outer)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Completed"</span>, prefix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单6-4中的程序创建了两个goroutine，分别打印1～5000内的素数。查找并显示素数会消耗不少时间，这会让调度器有机会在第一个goroutine找到所有素数之前，切换该goroutine的时间片。</p>
<p>在第12行中，程序启动的时候，声明了一个WaitGroup变量，并在第20行将其值设置为2，之后在第24行和第25行，在关键字go后面指定printPrime函数并创建了两个goroutine来执行。第一个goroutine使用前缀A，第二个goroutine使用前缀B。和其他函数调用一样，创建为goroutine的函数调用时可以传入参数。不过goroutine终止时无法获取函数的返回值。查看代码清单6-5中给出的输出时，会看到调度器在切换第一个goroutine。</p>
<blockquote>
<p>代码清单6-5 listing04.go的输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Create Goroutines</span><br><span class="line">Waiting To Finish</span><br><span class="line">B:2</span><br><span class="line">B:3</span><br><span class="line">...</span><br><span class="line">B:4583</span><br><span class="line">B:4591</span><br><span class="line">A:3          ** 切换goroutine</span><br><span class="line">A:5</span><br><span class="line">...</span><br><span class="line">A:4561</span><br><span class="line">A:4567</span><br><span class="line">B:4603       ** 切换goroutine</span><br><span class="line">B:4621</span><br><span class="line">...</span><br><span class="line">Completed B</span><br><span class="line">A:4457       ** 切换goroutine</span><br><span class="line">A:4463 </span><br><span class="line">...</span><br><span class="line">A:4993</span><br><span class="line">A:4999</span><br><span class="line">Completed A</span><br><span class="line">Terminating Program</span><br></pre></td></tr></table></figure>
<p>goroutineB先显示素数。一旦goroutineB打印到素数4591，调度器就会将正运行的goroutine切换为goroutineA。之后goroutineA在线程上执行了一段时间，再次切换为goroutineB。这次goroutineB完成了所有的工作。一旦goroutineB返回，就会看到线程再次切换到goroutineA并完成所有的工作。每次运行这个程序，调度器切换的时间点都会稍微有些不同。</p>
<p>代码清单6-1和代码清单6-4中的示例程序展示了调度器如何在一个逻辑处理器上并发运行多个goroutine。像之前提到的，Go标准库的runtime包里有一个名为GOMAXPROCS的函数，通过它可以指定调度器可用的逻辑处理器的数量。用这个函数，可以给每个可用的物理处理器在运行的时候分配一个逻辑处理器。代码清单6-6展示了这种改动，让goroutine并行运行。</p>
<blockquote>
<p>代码清单6-6 如何修改逻辑处理器的数量</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给每个可用的核心分配一个逻辑处理器</span></span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br></pre></td></tr></table></figure>
<p>包runtime提供了修改Go语言运行时配置参数的能力。在代码清单6-6里，我们使用两个runtime包的函数来修改调度器使用的逻辑处理器的数量。函数NumCPU返回可以使用的物理处理器的数量。因此，调用GOMAXPROCS函数就为每个可用的物理处理器创建一个逻辑处理器。需要强调的是，使用多个逻辑处理器并不意味着性能更好。在修改任何语言运行时配置参数的时候，都需要配合基准测试来评估程序的运行效果。</p>
<p>如果给调度器分配多个逻辑处理器，我们会看到之前的示例程序的输出行为会有些不同。让我们把逻辑处理器的数量改为2，并再次运行第一个打印英文字母表的示例程序，如代码清单6-7所示。</p>
<blockquote>
<p>代码清单6-7 listing07.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何创建goroutine</span></span><br><span class="line"><span class="comment">// 以及goroutine调度器的行为</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 分配2个逻辑处理器给调度器使用</span></span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg用来等待程序完成</span></span><br><span class="line">    <span class="comment">// 计数加2，表示要等待两个goroutine</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Start Goroutines"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个匿名函数，并创建一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示字母表3次</span></span><br><span class="line">        <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</span><br><span class="line">            <span class="keyword">for</span> char := <span class="string">'a'</span>; char &lt; <span class="string">'a'</span>+<span class="number">26</span>; char++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%c "</span>, char)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个匿名函数，并创建一个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示字母表3次</span></span><br><span class="line">        <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</span><br><span class="line">            <span class="keyword">for</span> char := <span class="string">'A'</span>; char &lt; <span class="string">'A'</span>+<span class="number">26</span>; char++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%c "</span>, char)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待goroutine结束</span></span><br><span class="line">    fmt.Println(<span class="string">"Waiting To Finish"</span>)</span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"\nTerminating Program"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单6-7中给出的例子在第14行中通过调用GOMAXPROCS函数创建了两个逻辑处理器。这会让goroutine并行运行，输出结果如代码清单6-8所示。</p>
<blockquote>
<p>代码清单6-8 listing07.go的输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Start Goroutines</span><br><span class="line">Waiting To Finish</span><br><span class="line">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T </span><br><span class="line">U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n </span><br><span class="line">o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h </span><br><span class="line">i j k l m n o p q r s t u v w x y z </span><br><span class="line">Terminating Program</span><br></pre></td></tr></table></figure>
<p>如果仔细查看代码清单6-8中的输出，会看到goroutine是并行运行的。两个goroutine几乎是同时开始运行的，大小写字母是混合在一起显示的。这是在一台8核的电脑上运行程序的输出，所以每个goroutine独自运行在自己的核上。记住，只有在有多个逻辑处理器且可以同时让每个goroutine运行在一个可用的物理处理器上的时候，goroutine才会并行运行。</p>
<p>现在知道了如何创建goroutine，并了解这背后发生的事情了。下面需要了解一下写并发程序时的潜在危险，以及需要注意的事情。</p>
<h1 id="竞争状态"><a href="#竞争状态" class="headerlink" title="竞争状态"></a><span style="color:#339AFF;">竞争状态</span></h1><p>如果两个或者多个goroutine在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作竞争状态（race condition），竞争状态的存在是让并发程序变得复杂的地方，十分容易引起潜在问题。对一个共享资源的读和写操作必须是原子化的，换句话说，同一时刻只能有一个goroutine对共享资源进行读和写操作。代码清单6-9中给出的是包含竞争状态的示例程序。</p>
<blockquote>
<p>代码清单6-9 listing09.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何在程序里造成竞争状态</span></span><br><span class="line"><span class="comment">// 实际上不希望出现这种情况</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// counter 是所有goroutine都要增加其值的变量</span></span><br><span class="line">    counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg 原来等待程序结束</span></span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计数加2，表示要等待两个goroutine</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待goroutine结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"Final Counter:"</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incCounter 增加包里counter变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">        <span class="comment">// 捕获counter的值</span></span><br><span class="line">        value := counter</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前goroutine从线程退出，并放回到队列</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加本地value变量的值</span></span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该值保存回counter</span></span><br><span class="line">        counter = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的输出如代码清单6-10所示。</p>
<blockquote>
<p>代码清单6-10 listing09.go的输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final Counter: 2</span><br></pre></td></tr></table></figure>
<p>变量counter会进行4次读和写操作，每个goroutine执行两次。但是，程序终止时，counter变量的值为2，图6-5提供了为什么会这样的线索。</p>
<blockquote>
<p>图6-5 竞争状态下程序行为的图像表达</p>
</blockquote>
<img src="/2021/08/19/第6章-并发/5.jpg">
<p>每个goroutine都会覆盖另一个goroutine的工作。这种覆盖发生在goroutine切换的时候。每个goroutine创造了一个counter变量的副本，之后就切换到另一个goroutine。当这个goroutine再次运行的时候，counter变量的值已经改变了，但是goroutine并没有更新自己的那个副本的值，而是继续使用这个副本的值，用这个值递增，并存回counter变量，结果覆盖了另一个goroutine完成的工作。</p>
<p>让我们顺着程序理解一下发生了什么。在第25行和第26行，使用incCounter函数创建了两个goroutine。在第34行，incCounter函数对包内变量counter进行了读和写操作，而这个变量是这个示例程序里的共享资源。每个goroutine都会先读出这个counter变量的值，并在第40行将counter变量的副本存入一个叫作value的本地变量。之后在第46行，incCounter函数对value的副本的值加1，最终在第49行将这个新值存回到counter变量。这个函数在第43行调用了runtime包的Gosched函数，用于将goroutine从当前线程退出，给其他goroutine运行的机会。在两次操作中间这样做的目的是强制调度器切换两个goroutine，以便让竞争状态的效果变得更明显。</p>
<p>Go语言有一个特别的工具，可以在代码里检测竞争状态。在查找这类错误的时候，这个工具非常好用，尤其是在竞争状态并不像这个例子里这么明显的时候。让我们用这个竞争检测器来检测一下我们的例子代码，如代码清单6-11所示。</p>
<blockquote>
<p>代码清单6-11 用竞争检测器来编译并执行listing09的代码</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ go build -race // 用竞争检测器标志来编译程序</span><br><span class="line">$ ./example // 运行程序</span><br><span class="line"></span><br><span class="line">=================</span><br><span class="line">WARNING:DATA RACE</span><br><span class="line">Write by goroutine 5:</span><br><span class="line">main.incCounter (</span><br><span class="line">/example/main.go:49 +0x96</span><br><span class="line">Previous <span class="built_in">read</span> by goroutine 6:main.incCounter (</span><br><span class="line">/example/main.go:40 +0x66</span><br><span class="line">Goroutine 5 (running)created at:main.main (</span><br><span class="line">/example/main.go:25 +0x5c</span><br><span class="line">Goroutine 6 (running)created at:main.main (</span><br><span class="line">/example/main.go:26 +0x73</span><br><span class="line">Final Counter:2</span><br><span class="line">Found 1 data race (s)</span><br></pre></td></tr></table></figure>
<p>代码清单6-11中的竞争检测器指出这个例子里面代码清单6-12所示的4行代码有问题。</p>
<blockquote>
<p>代码清单6-12 竞争检测器指出的代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tine49：counter=value</span><br><span class="line">Line40：value：=counterLine25：goinccounter（1）Line26：goinccounter（2）</span><br></pre></td></tr></table></figure>
<p>代码清单6-12展示了竞争检测器查到的哪个goroutine引发了数据竞争，以及哪两行代码有冲突。毫不奇怪，这几行代码分别是对counter变量的读和写操作。</p>
<p>一种修正代码、消除竞争状态的办法是，使用Go语言提供的锁机制，来锁住共享资源，从而保证goroutine的同步状态。</p>
<h1 id="锁住共享资源"><a href="#锁住共享资源" class="headerlink" title="锁住共享资源"></a><span style="color:#339AFF;">锁住共享资源</span></h1><p>Go语言提供了传统的同步goroutine的机制，就是对共享资源加锁。如果需要顺序访问一个整型变量或者一段代码，atomic和sync包里的函数提供了很好的解决方案。下面我们了解一下atomic包里的几个函数以及sync包里的mutex类型。</p>
<h2 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a><span style="color:#00ACC1;">原子函数</span></h2><p>原子函数能够以很底层的加锁机制来同步访问整型变量和指针。我们可以用原子函数来修正代码清单6-9中创建的竞争状态，如代码清单6-13所示。</p>
<blockquote>
<p>代码清单6-13 listing13.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何使用atomic包来提供</span></span><br><span class="line"><span class="comment">// 对数值类型的安全访问</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// counter是所有goroutine都要增加其值的变量</span></span><br><span class="line">    counter <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg用来等待程序结束</span></span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 数加2，表示要等待两个</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待goroutine结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示最终的值</span></span><br><span class="line">    fmt.Println(<span class="string">"Final Counter:"</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incCounter增加包里counter变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">        <span class="comment">// 安全地对counter加1</span></span><br><span class="line">        atomic.AddInt64(&amp;counter, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前goroutine从线程退出，并放回到队列</span></span><br><span class="line">        runtime.Gosched()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码清单6-14 listing13.go的输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final Counter: 4</span><br></pre></td></tr></table></figure>
<p>现在，程序的第43行使用了atmoic包的AddInt64函数。这个函数会同步整型值的加法，方法是强制同一时刻只能有一个goroutine运行并完成这个加法操作。当goroutine试图去调用任何原子函数时，这些goroutine都会自动根据所引用的变量做同步处理。现在我们得到了正确的值4。</p>
<p>另外两个有用的原子函数是LoadInt64和storeInt64，这两个函数提供了一种安全地读和写一个整型值的方式。代码清单6-15中的示例程序使用LoadInt64和storeInt64来创建一个同步标志，这个标志可以向程序里多个goroutine通知某个特殊状态。</p>
<blockquote>
<p>代码清单6-15 listing15.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何使用atomic包里的</span></span><br><span class="line"><span class="comment">// Store和Load类函数来提供对数值类型</span></span><br><span class="line"><span class="comment">// 的安全访问</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// shutdown是通知正在执行的goroutine停止工作的标志</span></span><br><span class="line">    shutdown <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg用来等待程序结束</span></span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计数加2，表示要等待两个</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> doWork(<span class="string">"A"</span>)</span><br><span class="line">    <span class="keyword">go</span> doWork(<span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定goroutine执行的时间</span></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该停止工作了，安全地设置shutdown标志</span></span><br><span class="line">    fmt.Println(<span class="string">"Shutdown Now"</span>)</span><br><span class="line">    atomic.StoreInt64(&amp;shutdown, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待goroutine结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doWork用来模拟执行工作的goroutine，</span></span><br><span class="line"><span class="comment">// 检测之前的shutdown标志来决定是否提前终止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Doing %s Work\n"</span>, name)</span><br><span class="line">        time.Sleep(<span class="number">250</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要停止工作了吗？</span></span><br><span class="line">        <span class="keyword">if</span> atomic.LoadInt64(&amp;shutdown) == <span class="number">1</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Shutting %s Down\n"</span>, name)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，启动了两个goroutine，并完成一些工作。在各自循环的每次迭代之后，在第52行中goroutine会使用LoadInt64来检查shutdown变量的值。这个函数会安全地返回shutdown变量的一个副本。如果这个副本的值为1，goroutine就会跳出循环并终止。</p>
<p>在第35行中，main函数使用Storeint64函数来安全地修改shutdown变量的值。如果哪个doworkgoroutine试图在main函数调用storeInt64的同时调用LoadInt64函数，那么原子函数会将这些调用互相同步，保证这些操作都是安全的，不会进入竞争状态。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><span style="color:#00ACC1;">互斥锁</span></h2><p>另一种同步访问共享资源的方式是使用互斥锁（mutex），互斥锁这个名字来自互斥（mutual exclusion）的概念。互斥锁用于在代码上创建一个临界区，保证同一时间只有一个goroutine可以执行这个临界区代码。我们还可以用互斥锁来修正代码清单6-9中创建的竞争状态，如代码清单6-16所示。</p>
<blockquote>
<p>代码清单6-16 listing16.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何使用互斥锁来</span></span><br><span class="line"><span class="comment">// 定义一段需要同步访问的代码临界区</span></span><br><span class="line"><span class="comment">// 资源的同步访问</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// counter是所有goroutine都要增加其值的变量</span></span><br><span class="line">    counter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg用来等待程序结束</span></span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mutex用来定义一段代码临界区</span></span><br><span class="line">    mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计数加2，表示要等待两个</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个goroutine</span></span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> incCounter(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待goroutine结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Printf(<span class="string">"Final Counter: %d\n"</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incCounter使用互斥锁来同步并保证安全访问，</span></span><br><span class="line"><span class="comment">// 增加包里counter变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</span><br><span class="line">        <span class="comment">// 同一时刻只允许一个goroutine进入</span></span><br><span class="line">        <span class="comment">// 这个临界区</span></span><br><span class="line">        mutex.Lock()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 捕获counter的值</span></span><br><span class="line">            value := counter</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前goroutine从线程退出，并放回到队列</span></span><br><span class="line">            runtime.Gosched()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加本地value变量的值</span></span><br><span class="line">            value++</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该值保存回counter</span></span><br><span class="line">            counter = value</span><br><span class="line">        &#125;</span><br><span class="line">        mutex.Unlock()</span><br><span class="line">        <span class="comment">// 释放锁，允许其他正在等待的goroutine</span></span><br><span class="line">        <span class="comment">// 进入临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对counter变量的操作在第46行和第60行的Lock()和Unlock()函数调用定义的临界区里被保护起来。使用大括号只是为了让临界区看起来更清晰，并不是必需的。同一时刻只有一个goroutine可以进入临界区。之后，直到调用Unlock()函数之后，其他goroutine才能进入临界区。当第52行强制将当前goroutine退出当前线程后，调度器会再次分配这个goroutine继续运行。当程序结束时，我们得到正确的值4，竞争状态不再存在。</p>
<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a><span style="color:#339AFF;">通道</span></h1><p>原子函数和互斥锁都能工作，但是依靠它们都不会让编写并发程序变得更简单，更不容易出错，或者更有趣。在Go语言里，你不仅可以使用原子函数和互斥锁来保证对共享资源的安全访问以及消除竞争状态，还可以使用通道，通过发送和接收需要共享的资源，在goroutine之间做同步。</p>
<p>当一个资源需要在goroutine之间共享时，通道在goroutine之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。</p>
<p>在Go语言中需要使用内置函数make来创建一个通道，如代码清单6-17所示。</p>
<blockquote>
<p>代码清单6-17 使用make创建通道</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无缓冲的整型通道</span></span><br><span class="line">unbuffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有缓冲的字符串通道</span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>在代码清单6-17中，可以看到使用内置函数make创建了两个通道，一个无缓冲的通道，一个有缓冲的通道。make的第一个参数需要是关键字chan，之后跟着允许通道交换的数据的类型。如果创建的是一个有缓冲的通道，之后还需要在第二个参数指定这个通道的缓冲区的大小。</p>
<p>向通道发送值或者指针需要用到<code>&lt;-</code>操作符，如代码清单6-18所示。</p>
<blockquote>
<p>代码清单6-18 向通道发送值</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有缓冲的字符串通道</span></span><br><span class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过通道发送一个字符串</span></span><br><span class="line">buffered &lt;- <span class="string">"Gopher"</span></span><br></pre></td></tr></table></figure>
<p>在代码清单6-18里，我们创建了一个有缓冲的通道，数据类型是字符串，包含一个10个值的缓冲区。之后我们通过通道发送字符串“Gopher”。为了让另一个goroutine可以从该通道里接收到这个字符串，我们依旧使用<code>&lt;-</code>操作符，但这次是一元运算符，如代码清单6-19所示。</p>
<blockquote>
<p>代码清单6-19 从通道里接收值</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从通道接收一个字符串</span></span><br><span class="line">value := &lt;-buffered</span><br></pre></td></tr></table></figure>
<p>当从通道里接收一个值或者指针时，<code>&lt;-</code>运算符在要操作的通道变量的左侧，如代码清单6-19所示。</p>
<p>通道是否带有缓冲，其行为会有一些不同。理解这个差异对决定到底应该使用还是不使用缓冲很有帮助。下面我们分别介绍一下这两种类型。</p>
<h2 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a><span style="color:#00ACC1;">无缓冲的通道</span></h2><p>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的goroutine阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p>
<p>在图6-6里，可以看到一个例子，展示两个goroutine如何利用无缓冲的通道来共享一个值。在第1步，两个goroutine都到达通道，但哪个都没有开始执行发送或者接收。在第2步，左侧的goroutine将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个goroutine会在通道中被锁住，直到交换完成。在第3步，右侧的goroutine将它的手放入通道，这模拟了从通道里接收数据。这个goroutine一样也会在通道中被锁住，直到交换完成。在第4步和第5步，进行交换，并最终，在第6步，两个goroutine都将它们的手从通道里拿出来，这模拟了被锁住的goroutine得到释放。两个goroutine现在都可以去做别的事情了。</p>
<blockquote>
<p>图6-6 使用无缓冲的通道在goroutine之间同步</p>
</blockquote>
<img src="/2021/08/19/第6章-并发/6.jpg">
<p>为了讲得更清楚，让我们来看两个完整的例子。这两个例子都会使用无缓冲的通道在两个goroutine之间同步交换数据。</p>
<p>在网球比赛中，两位选手会把球在两个人之间来回传递。选手总是处在以下两种状态之一：要么在等待接球，要么将球打向对方。可以使用两个goroutine来模拟网球比赛，并使用无缓冲的通道来模拟球的来回，如代码清单6-20所示。</p>
<blockquote>
<p>代码清单6-20 listing20.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何用无缓冲的通道来模拟</span></span><br><span class="line"><span class="comment">// 2个goroutines间的网球比赛</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg用来等待程序结束</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个无缓冲的通道</span></span><br><span class="line">    court := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数加2，表示要等待两个goroutine</span></span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动两个选手</span></span><br><span class="line">    <span class="keyword">go</span> player(<span class="string">"Nadal"</span>, court)</span><br><span class="line">    <span class="keyword">go</span> player(<span class="string">"Djokovic"</span>, court)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发球</span></span><br><span class="line">    court &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待游戏结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// player模拟一个选手在打网球</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">player</span><span class="params">(name <span class="keyword">string</span>, court <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数退出时调用Done来通知main函数工作已经完成</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 等待球被击打过来</span></span><br><span class="line">        ball, ok := &lt;-court</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// 如果通道被关闭，我们就赢了</span></span><br><span class="line">            fmt.Printf(<span class="string">"Player %s Won\n"</span>, name)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选随机数，然后用这个数来判断我们是否丢球</span></span><br><span class="line">        n := rand.Intn(<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">13</span> == <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"Player %s Missed\n"</span>, name)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭通道，表示我们输了</span></span><br><span class="line">            <span class="built_in">close</span>(court)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示击球数，并将击球数加1</span></span><br><span class="line">        fmt.Printf(<span class="string">"Player %s Hit %d\n"</span>, name, ball)</span><br><span class="line">        ball++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将球打向对手</span></span><br><span class="line">        court &lt;- ball</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个程序会得到代码清单6-21所示的输出。</p>
<blockquote>
<p>代码清单6-21 listing20.go的输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Player Djokovic Hit 1</span><br><span class="line">Player Nadal Hit 2</span><br><span class="line">Player Djokovic Hit 3</span><br><span class="line">Player Djokovic Missed</span><br><span class="line">Player Nadal Won</span><br></pre></td></tr></table></figure>
<p>在main函数的第22行，创建了一个int类型的无缓冲的通道，让两个goroutine在击球时能够互相同步。之后在第28行和第29行，创建了参与比赛的两个goroutine，在这个时候，两个goroutine都阻塞住等待击球。在第32行，将球发到通道里，程序开始执行这个比赛，直到某个goroutine输掉比赛。</p>
<p>在player函数里，在第43行可以找到一个无限循环的for语句。在这个循环里，是玩游戏的过程。在第45行，goroutine从通道接收数据，用来表示等待接球。这个接收动作会锁住goroutine，直到有数据发送到通道里。通道的接收动作返回时，第46行会检测ok标志是否为false。如果这个值是false，表示通道已经被关闭，游戏结束。在第53行到第60行，会产生一个随机数，用来决定goroutine是否击中了球。如果击中了球，在第64行bal1的值会递增1，并在第67行，将ball作为球重新放入通道，发送给另一位选手。在这个时刻，两个goroutine都会被锁住，直到交换完成。最终，某个goroutine没有打中球，在第58行关闭通道。之后两个goroutine都会返回，通过defer声明的Done会被执行，程序终止。</p>
<p>另一个例子，用不同的模式，使用无缓冲的通道，在goroutine之间同步数据，来模拟接力比赛。在接力比赛里，4个跑步者围绕赛道轮流跑（如代码清单6-22所示），第二个、第三个和第四个跑步者要接到前一位跑步者的接力棒后才能起跑。比赛中最重要的部分是要传递接力棒要求同步传递。在同步接力棒的时候，参与接力的两个跑步者必须在同一时刻准备好交接。</p>
<blockquote>
<p>代码清单6-22 listing22.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何用无缓冲的通道来模拟</span></span><br><span class="line"><span class="comment">// 4个goroutine间的接力比赛</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg用来等待程序结束</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个无缓冲的通道</span></span><br><span class="line">    baton := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为最后一位跑步者将计数加1</span></span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一位跑步者持有接力棒</span></span><br><span class="line">    <span class="keyword">go</span> Runner(baton)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始比赛</span></span><br><span class="line">    baton &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待比赛结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runner 模拟接力比赛中的一位跑步者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runner</span><span class="params">(baton <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newRunner <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待接力棒</span></span><br><span class="line">    runner := &lt;-baton</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始绕着跑道跑步</span></span><br><span class="line">    fmt.Printf(<span class="string">"Runner %d Running With Baton\n"</span>, runner)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建下一位跑步者</span></span><br><span class="line">    <span class="keyword">if</span> runner != <span class="number">4</span> &#123;</span><br><span class="line">        newRunner = runner + <span class="number">1</span></span><br><span class="line">        fmt.Printf(<span class="string">"Runner %d To The Line\n"</span>, newRunner)</span><br><span class="line">        <span class="keyword">go</span> Runner(baton)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 围绕跑道跑</span></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比赛结束了吗？</span></span><br><span class="line">    <span class="keyword">if</span> runner == <span class="number">4</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Runner %d Finished, Race Over\n"</span>, runner)</span><br><span class="line">        wg.Done()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将接力棒交给下一位跑步者</span></span><br><span class="line">    fmt.Printf(<span class="string">"Runner %d Exchange With Runner %d\n"</span>,</span><br><span class="line">        runner,</span><br><span class="line">        newRunner)</span><br><span class="line"></span><br><span class="line">    baton &lt;- newRunner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个程序会得到代码清单6-23所示的输出。</p>
<blockquote>
<p>代码清单6-23 listing22.go的输出Runner</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Runner 1 Running With Baton</span><br><span class="line">Runner 2 To The Line</span><br><span class="line">Runner 1 Exchange With Runner 2</span><br><span class="line">Runner 2 Running With Baton</span><br><span class="line">Runner 3 To The Line</span><br><span class="line">Runner 2 Exchange With Runner 3</span><br><span class="line">Runner 3 Running With Baton</span><br><span class="line">Runner 4 To The Line</span><br><span class="line">Runner 3 Exchange With Runner 4</span><br><span class="line">Runner 4 Running With Baton</span><br><span class="line">Runner 4 Finished, Race Over</span><br></pre></td></tr></table></figure>
<p>在main函数的第17行，创建了一个无缓冲的int类型的通道baton，用来同步传递接力棒。在第20行，我们给WaitGroup加1，这样main函数就会等最后一位跑步者跑步结束。在第23行创建了一个goroutine，用来表示第一位跑步者来到跑道。之后在第26行，将接力棒交给这个跑步者，比赛开始。最终，在第29行，main函数阻塞在WaitGroup，等候最后一位跑步者完成比赛。</p>
<p>在Runner goroutine里，可以看到接力棒baton是如何在跑步者之间传递的。在第37行，goroutine对baton通道执行接收操作，表示等候接力棒。一旦接力棒传了进来，在第46行就会创建一位新跑步者，准备接力下一棒，直到goroutine是第四个跑步者。在第50行，跑步者围绕跑道跑100ms。在第55行，如果第四个跑步者完成了比赛，就调用Done，将WaitGroup减1，之后goroutine返回。如果这个goroutine不是第四个跑步者，那么在第64行，接力棒会交到下一个已经在等待的跑步者手上。在这个时候，goroutine会被锁住，直到交接完成。</p>
<p>在这两个例子里，我们使用无缓冲的通道同步goroutine，模拟了网球和接力赛。代码的流程与这两个活动在真实世界中的流程完全一样，这样的代码很容易读懂。现在知道了无缓冲的通道是如何工作的，接下来我们会学习有缓冲的通道的工作方法。</p>
<h2 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a><span style="color:#00ACC1;">有缓冲的通道</span></h2><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求goroutine之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的goroutine会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p>
<p>在图6-7中可以看到两个goroutine分别向有缓冲的通道里增加一个值和从有缓冲的通道里移除一个值。在第1步，右侧的goroutine正在从通道接收一个值。在第2步，右侧的这个goroutine独立完成了接收值的动作，而左侧的goroutine正在发送一个新值到通道里。在第3步，左侧的goroutine还在向通道发送新值，而右侧的goroutine正在从通道接收另外一个值。这个步骤里的两个操作既不是同步的，也不会互相阻塞。最后，在第4步，所有的发送和接收都完成，而通道里还有几个值，也有一些空间可以存更多的值。</p>
<blockquote>
<p>图6-7 使用有缓冲的通道在goroutine之间同步数据</p>
</blockquote>
<img src="/2021/08/19/第6章-并发/7.jpg">
<p>让我们看一个使用有缓冲的通道的例子，这个例子管理一组goroutine来接收并完成工作。有缓冲的通道提供了一种清晰而直观的方式来实现这个功能，如代码清单6-24所示。</p>
<blockquote>
<p>代码清单6-24 listing24.go</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个示例程序展示如何使用</span></span><br><span class="line"><span class="comment">// 有缓冲的通道和固定数目的</span></span><br><span class="line"><span class="comment">// goroutine来处理一堆工作</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    numberGoroutines = <span class="number">4</span>  <span class="comment">// 要使用goroutine的数量</span></span><br><span class="line">    taskLoad         = <span class="number">10</span> <span class="comment">// 要处理的工作的数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// wg用来等待程序完成</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// init初始化包，Go语言运行时会在其他代码执行之前</span></span><br><span class="line"><span class="comment">// 优先执行这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化随机数种子</span></span><br><span class="line">    rand.Seed(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main是所有Go程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个有缓冲的通道来管理工作</span></span><br><span class="line">    tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, taskLoad)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动goroutine来处理工作</span></span><br><span class="line">    wg.Add(numberGoroutines)</span><br><span class="line">    <span class="keyword">for</span> gr := <span class="number">1</span>; gr &lt;= numberGoroutines; gr++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(tasks, gr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一组要完成的工作</span></span><br><span class="line">    <span class="keyword">for</span> post := <span class="number">1</span>; post &lt;= taskLoad; post++ &#123;</span><br><span class="line">        tasks &lt;- fmt.Sprintf(<span class="string">"Task : %d"</span>, post)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当所有工作都处理完时关闭通道</span></span><br><span class="line">    <span class="comment">// 以便所有goroutine退出</span></span><br><span class="line">    <span class="built_in">close</span>(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有工作完成</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker作为goroutine启动来处理</span></span><br><span class="line"><span class="comment">// 从有缓冲的通道传入的工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tasks <span class="keyword">chan</span> <span class="keyword">string</span>, worker <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通知函数已经返回</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 等待分配工作</span></span><br><span class="line">        task, ok := &lt;-tasks</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="comment">// 这意味着通道已经开始空了，并且已被关闭</span></span><br><span class="line">            fmt.Printf(<span class="string">"Worker: %d : Shutting Down\n"</span>, worker)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示我们开始工作了</span></span><br><span class="line">        fmt.Printf(<span class="string">"Worker: %d : Started %s\n"</span>, worker, task)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机等一段时间来模拟工作</span></span><br><span class="line">        sleep := rand.Int63n(<span class="number">100</span>)</span><br><span class="line">        time.Sleep(time.Duration(sleep) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示我们完成了工作</span></span><br><span class="line">        fmt.Printf(<span class="string">"Worker: %d : Completed %s\n"</span>, worker, task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个程序会得到代码清单6-25所示的输出。</p>
<blockquote>
<p>代码清单6-25 listing24.go的输出</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Worker: 4 : Started Task : 3</span><br><span class="line">Worker: 3 : Started Task : 2</span><br><span class="line">Worker: 1 : Started Task : 1</span><br><span class="line">Worker: 2 : Started Task : 4</span><br><span class="line">Worker: 2 : Completed Task : 4</span><br><span class="line">Worker: 2 : Started Task : 5</span><br><span class="line">Worker: 1 : Completed Task : 1</span><br><span class="line">Worker: 1 : Started Task : 6</span><br><span class="line">Worker: 4 : Completed Task : 3</span><br><span class="line">Worker: 4 : Started Task : 7</span><br><span class="line">Worker: 3 : Completed Task : 2</span><br><span class="line">Worker: 3 : Started Task : 8</span><br><span class="line">Worker: 1 : Completed Task : 6</span><br><span class="line">Worker: 1 : Started Task : 9</span><br><span class="line">Worker: 2 : Completed Task : 5</span><br><span class="line">Worker: 4 : Completed Task : 7</span><br><span class="line">Worker: 4 : Shutting Down</span><br><span class="line">Worker: 2 : Started Task : 10</span><br><span class="line">Worker: 2 : Completed Task : 10</span><br><span class="line">Worker: 2 : Shutting Down</span><br><span class="line">Worker: 1 : Completed Task : 9</span><br><span class="line">Worker: 1 : Shutting Down</span><br><span class="line">Worker: 3 : Completed Task : 8</span><br><span class="line">Worker: 3 : Shutting Down</span><br></pre></td></tr></table></figure>
<p>由于程序和Go语言的调度器带有随机成分，这个程序每次执行得到的输出会不一样。不过，通过有缓冲的通道，使用所有4个goroutine来完成工作，这个流程不会变。从输出可以看到每个goroutine是如何接收从通道里分发的工作。</p>
<p>在main函数的第31行，创建了一个string类型的有缓冲的通道，缓冲的容量是10，在第34行，给WaitGroup赋值为4，代表创建了4个工作goroutine。之后在第35行到第37行，创建了4个goroutine，并传入用来接收工作的通道。在第40行到第42行，将10个字符串发送到通道，模拟发给goroutine的工作。一旦最后一个字符串发送到通道，通道就会在第46行关闭，而main函数就会在第49行等待所有工作的完成。</p>
<p>第46行中关闭通道的代码非常重要。当通道关闭后，goroutine依旧可以从通道接收数据，但是不能再向通道里发送数据。能够从已经关闭的通道接收数据这一点非常重要，因为这允许通道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标志，就能得到通道的状态信息。</p>
<p>在worker函数里，可以在第58行看到一个无限的for循环。在这个循环里，会处理所有接收到的工作。每个goroutine都会在第60行阻塞，等待从通道里接收新的工作。一旦接收到返回，就会检查ok标志，看通道是否已经清空而且关闭。如果ok的值是false，goroutine就会终止，并调用第56行通过defer声明的Done函数，通知main有工作结束。</p>
<p>如果ok标志是true，表示接收到的值是有效的。第71行和第72行模拟了处理的工作。一旦工作完成，goroutine会再次阻塞在第60行从通道获取数据的语句。一旦通道被关闭，这个从通道获取数据的语句会立刻返回，goroutine也会终止自己。</p>
<p>有缓冲的通道和无缓冲的通道的例子很好地展示了如何编写使用通道的代码。在下一章，我们会介绍真实世界里的一些可能会在工程里用到的并发模式。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><span style="color:#339AFF;">小结</span></h1><ul>
<li>并发是指goroutine运行的时候是相互独立的。</li>
<li>使用关键字go创建goroutine来运行函数。</li>
<li>goroutine在逻辑处理器上执行，而逻辑处理器具有独立的系统线程和运行队列。</li>
<li>竞争状态是指两个或者多个goroutine试图访问同一个资源。</li>
<li>原子函数和互斥锁提供了一种防止出现竞争状态的办法。</li>
<li>通道提供了一种在两个goroutine之间共享数据的简单方法。</li>
<li>无缓冲的通道保证同时交换数据，而有缓冲的通道不做这种保证。</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言实战/" rel="tag"># Go语言实战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/19/第5章-Go语言的类型系统/" rel="next" title="第5章 Go语言的类型系统">
                <i class="fa fa-chevron-left"></i> 第5章 Go语言的类型系统
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/19/第7章-并发模式/" rel="prev" title="第7章 并发模式">
                第7章 并发模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#并发与并行"><span class="nav-number">1.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#goroutine"><span class="nav-number">2.</span> <span class="nav-text">goroutine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#竞争状态"><span class="nav-number">3.</span> <span class="nav-text">竞争状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#锁住共享资源"><span class="nav-number">4.</span> <span class="nav-text">锁住共享资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原子函数"><span class="nav-number">4.1.</span> <span class="nav-text">原子函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥锁"><span class="nav-number">4.2.</span> <span class="nav-text">互斥锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通道"><span class="nav-number">5.</span> <span class="nav-text">通道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#无缓冲的通道"><span class="nav-number">5.1.</span> <span class="nav-text">无缓冲的通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有缓冲的通道"><span class="nav-number">5.2.</span> <span class="nav-text">有缓冲的通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
