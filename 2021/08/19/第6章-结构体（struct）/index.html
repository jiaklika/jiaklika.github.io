<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  如何定义结构体？ 有哪三种方法可以实例化结构体？ 结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。怎么理解？ 匿名结构体是什么？">
<meta name="keywords" content="Go语言从入门到进阶实战">
<meta property="og:type" content="article">
<meta property="og:title" content="第6章 结构体（struct）">
<meta property="og:url" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  如何定义结构体？ 有哪三种方法可以实例化结构体？ 结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。怎么理解？ 匿名结构体是什么？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/2.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/3.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/4.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/5.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/6.jpg">
<meta property="og:updated_time" content="2021-10-18T03:38:36.564Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第6章 结构体（struct）">
<meta name="twitter:description" content="思考并回答以下问题：  如何定义结构体？ 有哪三种方法可以实例化结构体？ 结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。怎么理解？ 匿名结构体是什么？">
<meta name="twitter:image" content="http://yoursite.com/2021/08/19/第6章-结构体（struct）/1.jpg">






  <link rel="canonical" href="http://yoursite.com/2021/08/19/第6章-结构体（struct）/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第6章 结构体（struct） | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/19/第6章-结构体（struct）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第6章 结构体（struct）

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-19 09:13:42" itemprop="dateCreated datePublished" datetime="2021-08-19T09:13:42+08:00">2021-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-10-18 11:38:36" itemprop="dateModified" datetime="2021-10-18T11:38:36+08:00">2021-10-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">33k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">30 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>如何定义结构体？</li>
<li>有哪三种方法可以实例化结构体？</li>
<li>结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。怎么理解？</li>
<li>匿名结构体是什么？</li>
</ul>
<a id="more"></a>
<p>Go语言通过用自定义的方式形成新的类型，结构体是类型中带有成员的复合类型。Go语言使用结构体和结构体成员来描述真实世界的实体和实体对应的各种属性。</p>
<p>Go语言中的类型可以被实例化，使用new或&amp;取地址符所构造的类型实例是类型的指针。</p>
<p>结构体成员是由一系列的成员变量构成，这些成员变量也被称为“字段”。字段有以下特性：</p>
<ul>
<li>字段拥有自己的类型和值。</li>
<li>字段名必须唯一。</li>
<li>字段的类型也可以是结构体，甚至是字段所在结构体的类型。</li>
</ul>
<blockquote>
<p>提示：Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。<br><br>Go语言的结构体与“类”都是复合结构体，但Go语言中结构体的内嵌配合接口比面向对象具有更高的扩展性和灵活性。<br><br>Go语言不仅认为结构体能拥有方法，且每种自定义类型也可以拥有自己的方法。</p>
</blockquote>
<h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a><span style="color:#339AFF;">定义结构体</span></h1><p>Go语言的关键字type可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过type定义为自定义类型后，使结构体更便于使用。</p>
<p>结构体的定义格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>类型名：标识自定义结构体的名称，在同一个包内不能重复。</li>
<li>struct{}：表示结构体类型，type 类型名 struct{}可以理解为将struct{}结构体定义为类型名的类型。</li>
<li>字段1、字段2……：表示结构体字段名。结构体中的字段名必须唯一。</li>
<li>字段1类型、字段2类型……：表示结构体字段的类型。</li>
</ul>
<p>使用结构体可以表示一个包含X和Y整型分量的点结构，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同类型的变量也可以写在一行。颜色的红、绿、蓝3个分量可以使用byte类型表示，定义的颜色结构体如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    R, G, B <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实例化结构体——为结构体分配内存并初始化"><a href="#实例化结构体——为结构体分配内存并初始化" class="headerlink" title="实例化结构体——为结构体分配内存并初始化"></a><span style="color:#339AFF;">实例化结构体——为结构体分配内存并初始化</span></h1><p>结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存。因此必须在定义结构体并实例化后才能使用结构体的字段。</p>
<p>实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。</p>
<p>Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。</p>
<h2 id="基本的实例化形式"><a href="#基本的实例化形式" class="headerlink" title="基本的实例化形式"></a><span style="color:#00ACC1;">基本的实例化形式</span></h2><p>结构体本身是一种类型，可以像整型、字符串等类型一样，以var的方式声明结构体即可完成实例化。</p>
<p>基本实例化格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ins T</span><br></pre></td></tr></table></figure></p>
<ul>
<li>T为结构体类型。</li>
<li>ins为结构体的实例。</li>
</ul>
<p>用结构体表示的点结构（Point）的实例化过程请参见下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = Point</span><br><span class="line">p.X = <span class="number">10</span></span><br><span class="line">p.Y = <span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>在例子中，使用“.”来访问结构体的成员变量，如p.X和p.Y等。结构体成员变量的赋值方法与普通变量一致。</p>
<h2 id="创建指针类型的结构体"><a href="#创建指针类型的结构体" class="headerlink" title="创建指针类型的结构体"></a><span style="color:#00ACC1;">创建指针类型的结构体</span></h2><p>Go语言中，还可以使用new关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。</p>
<p>使用new的格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="built_in">new</span>(T)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>T为类型，可以是结构体、整型、字符串等。</li>
<li>ins：T类型被实例化后保存到ins变量中，ins的类型为*T，属于指针。</li>
</ul>
<p>Go语言让我们可以像访问普通结构体一样使用“.”访问结构体指针的成员。</p>
<p>下面的例子定义了一个玩家（Player）的结构，玩家拥有名字、生命值和魔法值，实例化玩家（Player）结构体后，可对成员进行赋值，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    HealthPoint <span class="keyword">int</span></span><br><span class="line">    MagicPoint <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tank := <span class="built_in">new</span>(Player)</span><br><span class="line">tank.Name = <span class="string">"Canon"</span></span><br><span class="line">tank.HealthPoint = <span class="number">300</span></span><br></pre></td></tr></table></figure></p>
<p>经过new实例化的结构体实例在成员赋值上与基本实例化的写法一致。</p>
<blockquote>
<p>提示：在C/C++语言中，使用new实例化类型后，访问其成员变量时必须使用“-&gt;”操作符。<br><br>在Go语言中，访问结构体指针的成员变量时可以继续使用“.”。这是因为Go语言为了方便开发者访问结构体指针的成员变量，使用了语法糖（Syntactic sugar）技术，将ins.Name形式转换为(*ins).Name。</p>
</blockquote>
<h2 id="取结构体的地址实例化"><a href="#取结构体的地址实例化" class="headerlink" title="取结构体的地址实例化"></a><span style="color:#00ACC1;">取结构体的地址实例化</span></h2><p>在Go语言中，对结构体进行“&amp;”取地址操作时，视为对该类型进行一次new的实例化操作。取地址格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ins := &amp;T&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>T表示结构体类型。</li>
<li>ins为结构体的实例，类型为*T，是指针类型。</li>
</ul>
<p>下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等。对Command进行指针地址的实例化，并完成赋值过程，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Command <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>     <span class="comment">// 指令名称</span></span><br><span class="line">    Var *<span class="keyword">int</span>        <span class="comment">// 指令绑定的变量</span></span><br><span class="line">    Comment <span class="keyword">string</span>  <span class="comment">// 指令的注释</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">cmd := &amp;Command&#123;&#125;</span><br><span class="line">cmd.Name = <span class="string">"version"</span></span><br><span class="line">cmd.Var = &amp;version</span><br><span class="line">cmd.Comment = <span class="string">"show version"</span></span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行，定义Command结构体，表示命令行指令。</li>
<li>第3行，命令绑定的变量，使用整型指针绑定一个指针。指令的值可以与绑定的值随时保持同步。</li>
<li>第7行，命令绑定的目标整型变量：版本号。</li>
<li>第9行，对结构体取地址实例化。</li>
<li>第10～12行，初始化成员字段。</li>
</ul>
<p>取地址实例化是最广泛的一种结构体实例化方式。可以使用函数封装上面的初始化过程，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCommand</span><span class="params">(name <span class="keyword">string</span>, varref *<span class="keyword">int</span>, comment <span class="keyword">string</span>)</span> *<span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Command&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        Var: varref,</span><br><span class="line">        Comment: comment,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd = newCommand (</span><br><span class="line">    <span class="string">"version"</span>,</span><br><span class="line">    &amp;version,</span><br><span class="line">    <span class="string">"show version"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h1 id="初始化结构体的成员变量"><a href="#初始化结构体的成员变量" class="headerlink" title="初始化结构体的成员变量"></a><span style="color:#339AFF;">初始化结构体的成员变量</span></h1><p>结构体在实例化时可以直接对成员变量进行初始化。初始化有两种形式：一种是字段“键值对”形式及多个值的列表形式。键值对形式的初始化适合选择性填充字段较多的结构体；多个值的列表形式适合填充字段较少的结构体。</p>
<h2 id="使用“键值对”初始化结构体"><a href="#使用“键值对”初始化结构体" class="headerlink" title="使用“键值对”初始化结构体"></a><span style="color:#00ACC1;">使用“键值对”初始化结构体</span></h2><p>结构体可以使用“键值对”（Key Value pair）初始化字段，每个“键”（Key）对应结构体中的一个字段。键的“值”（Value）对应字段需要初始化的值。</p>
<p>键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中。</p>
<p>结构体实例化后字段的默认值是字段类型的默认值，例如：数值为0，字符串为空字符串，布尔为false，指针为nil等。</p>
<p><strong>1，键值对初始化结构体的书写格式</strong></p>
<p>键值对初始化的格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名 &#123;</span><br><span class="line">    字段<span class="number">1</span>: 字段<span class="number">1</span>的值,</span><br><span class="line">    字段<span class="number">2</span>: 字段<span class="number">2</span>的值,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>结构体类型名：定义结构体时的类型名称。</li>
<li>字段1、字段2：结构体的成员字段名。结构体类型名的字段初始化列表中，字段名只能出现一次。</li>
<li>字段1的值、字段2的值：结构体成员字段的初始值。</li>
</ul>
<p>键值之间以“:”分隔；键值对之间以“,”分隔。</p>
<p><strong>2，使用键值对填充结构体的例子</strong></p>
<p>下面例子中描述了家里的人物关联。正如儿歌里唱的：“爸爸的爸爸是爷爷”，人物之间可以使用多级的child来描述和建立关联。使用键值对形式填充结构体的代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    child *People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">relation := &amp;People &#123;</span><br><span class="line">    name: <span class="string">"爷爷"</span></span><br><span class="line">    child: &amp;People &#123;</span><br><span class="line">        name: <span class="string">"爸爸"</span>,</span><br><span class="line">        child: &amp;People &#123;</span><br><span class="line">            name: <span class="string">"我"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行，定义People结构体。</li>
<li>第2行，结构体的字符串字段。</li>
<li>第3行，结构体的结构体指针字段，类型是*People。</li>
<li>第6行，relation由People类型取地址后，形成类型为*People的实例。</li>
<li>第8行，child在初始化时，需要*People类型的值。使用取地址初始化一个People。</li>
</ul>
<p>结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。</p>
<h2 id="使用多个值的列表初始化结构体"><a href="#使用多个值的列表初始化结构体" class="headerlink" title="使用多个值的列表初始化结构体"></a><span style="color:#00ACC1;">使用多个值的列表初始化结构体</span></h2><p>Go语言可以在“键值对”初始化的基础上忽略“键”。也就是说，可以使用多个值的列表初始化结构体的字段。</p>
<p><strong>1，多个值列表初始化结构体的书写格式</strong></p>
<p>多个值使用逗号分隔初始化结构体，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := 结构体类型名 &#123;</span><br><span class="line">    字段<span class="number">1</span>的值,</span><br><span class="line">    字段<span class="number">2</span>的值,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这种格式初始化时，需要注意：</p>
<ul>
<li>必须初始化结构体的所有字段。</li>
<li>每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。</li>
<li>键值对与值列表的初始化形式不能混用。</li>
</ul>
<p><strong>2，多个值列表初始化结构体的例子</strong></p>
<p>下面的例子描述了一段地址结构。地址要求具有一定的顺序。例如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City <span class="keyword">string</span></span><br><span class="line">    ZipCode <span class="keyword">int</span></span><br><span class="line">    PhoneNumber <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr := Address &#123;</span><br><span class="line">    <span class="string">"四川"</span>,</span><br><span class="line">    <span class="string">"成都"</span>,</span><br><span class="line">    <span class="number">610000</span>,</span><br><span class="line">    <span class="string">"0"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(addr)</span><br></pre></td></tr></table></figure>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;四川 成都 610000 0&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化匿名结构体"><a href="#初始化匿名结构体" class="headerlink" title="初始化匿名结构体"></a><span style="color:#00ACC1;">初始化匿名结构体</span></h2><p>匿名结构体没有类型名称，无须通过type关键字定义就可以直接使用。</p>
<p><strong>1，匿名结构体定义格式和初始化写法</strong></p>
<p>匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成。结构体定义时没有结构体类型名，只有字段和类型定义。键值对初始化部分由可选的多个键值对组成，如下格式所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 匿名结构体字段定义</span></span><br><span class="line">    字段<span class="number">1</span> 字段类型<span class="number">1</span></span><br><span class="line">    字段<span class="number">2</span> 字段类型<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125; &#123;</span><br><span class="line">    <span class="comment">// 字段值初始化</span></span><br><span class="line">    初始化字段<span class="number">1</span>: 字段<span class="number">1</span>的值，</span><br><span class="line">    初始化字段<span class="number">2</span>: 字段<span class="number">2</span>的值</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>字段1、字段2……：结构体定义的字段名。</li>
<li>初始化字段1、初始化字段2……：结构体初始化时的字段名，可选择性地对字段初始化。</li>
<li>字段类型1、字段类型2……：结构体定义字段的类型。</li>
<li>字段1的值、字段2的值……：结构体初始化字段的初始值。</li>
</ul>
<p>键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ins := <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 字段类型<span class="number">1</span></span><br><span class="line">    字段<span class="number">2</span> 字段类型<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125; &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2、使用匿名结构体的例子</strong></p>
<p>在本例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data）。打印消息内容的printMsg()函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印消息类型，传入匿名结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMsgType</span> <span class="params">(msg *<span class="keyword">struct</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    id <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    data <span class="keyword">string</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用动词%T打印msg的类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">    msg := &amp;<span class="keyword">struct</span> &#123;    <span class="comment">// 定义部分</span></span><br><span class="line">        id <span class="keyword">int</span></span><br><span class="line">        data <span class="keyword">string</span></span><br><span class="line">    &#125; &#123;                 <span class="comment">// 值初始化部分</span></span><br><span class="line">        <span class="number">1024</span>,</span><br><span class="line">        <span class="string">"hello"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMsgType(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，定义printMsgType()函数，参数为msg，类型为*struct {id int data string}。因为类型没有使用type定义，所以需要在用到的地方每次进行定义。</li>
<li>第14行，使用字符串格式化中的“%T”动词，将msg的类型名打印出来。</li>
<li>第20行，对匿名结构体进行实例化，同时初始化成员。</li>
<li>第21和22行，定义匿名结构体的字段。</li>
<li>第24和25行，给匿名结构体字段赋予初始值。</li>
<li>第28行，将msg传入printMsgType()函数中进行函数调用。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*struct &#123;id int; data string&#125;</span><br></pre></td></tr></table></figure></p>
<p>匿名结构体的类型名是结构体包含字段成员的详细描述。匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。</p>
<h1 id="构造函数——结构体和类型的一系列初始化操作的函数封装"><a href="#构造函数——结构体和类型的一系列初始化操作的函数封装" class="headerlink" title="构造函数——结构体和类型的一系列初始化操作的函数封装"></a><span style="color:#339AFF;">构造函数——结构体和类型的一系列初始化操作的函数封装</span></h1><p>Go语言的类型或结构体没有构造函数的功能。结构体的初始化过程可以使用函数封装实现。</p>
<blockquote>
<p>提示：其他编程语言构造函数的一些常见功能及特性如下：</p>
<ul>
<li>每个类可以添加构造函数，多个构造函数使用函数重载实现。</li>
<li>构造函数一般与类名同名，且没有返回值。</li>
<li>构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。</li>
<li>对于C++来说，还有默认构造函数、拷贝构造函数等。</li>
</ul>
</blockquote>
<h2 id="多种方式创建和初始化结构体——模拟构造函数重载"><a href="#多种方式创建和初始化结构体——模拟构造函数重载" class="headerlink" title="多种方式创建和初始化结构体——模拟构造函数重载"></a><span style="color:#00ACC1;">多种方式创建和初始化结构体——模拟构造函数重载</span></h2><p>如果使用结构体描述猫的特性，那么根据猫的颜色和名字可以有不同种类的猫。那么不同的颜色和名字就是结构体的字段，同时可以使用颜色和名字构造不同种类的猫的实例，这个过程可以参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCatByName</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Cat</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cat &#123;</span><br><span class="line">        Name: name,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCatByColor</span> <span class="params">(color <span class="keyword">string</span>)</span> *<span class="title">Cat</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Color &#123;</span><br><span class="line">        Color: color,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行定义Cat结构，包含颜色和名字字段。</li>
<li>第6行定义用名字构造猫结构的函数，返回Cat指针。</li>
<li>第7行取地址实例化猫的结构体。</li>
<li>第8行初始化猫的名字字段，忽略颜色字段。</li>
<li>第12行定义用颜色构造猫结构的函数，返回Cat指针。</li>
</ul>
<p>在这个例子中，颜色和名字两个属性的类型都是字符串。由于Go语言中没有函数重载，为了避免函数名字冲突，使用NewCatByName()和NewCatByColor()两个不同的函数名表示不同的Cat构造过程。</p>
<h2 id="带有父子关系的结构体的构造和初始化——模拟父级构造调用"><a href="#带有父子关系的结构体的构造和初始化——模拟父级构造调用" class="headerlink" title="带有父子关系的结构体的构造和初始化——模拟父级构造调用"></a><span style="color:#00ACC1;">带有父子关系的结构体的构造和初始化——模拟父级构造调用</span></h2><p>黑猫是一种猫，猫是黑猫的一种泛称。同时描述这两种概念时，就是派生，黑猫派生自猫的种类。使用结构体描述猫和黑猫的关系时，将猫（Cat）的结构体嵌入到黑猫（BlackCat）中，表示黑猫拥有猫的特性，然后再使用两个不同的构造函数分别构造出黑猫和猫两个结构体实例，参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Color <span class="keyword">string</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BlackCat <span class="keyword">struct</span> &#123;</span><br><span class="line">    Cat <span class="comment">// 嵌入Cat，类似于派生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造“基类”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCat</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Cat</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Cat &#123;</span><br><span class="line">        Name: name,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造“子类”</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlackCat</span><span class="params">(color <span class="keyword">string</span>)</span> *<span class="title">BlackCat</span></span> &#123;</span><br><span class="line">    cat := &amp;BlackCat&#123;&#125;</span><br><span class="line">    cat.Color = color</span><br><span class="line">    <span class="keyword">return</span> cat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第6行，定义BlackCat结构，并嵌入了Cat结构体。BlackCat拥有Cat的所有成员，实例化后可以自由访问Cat的所有成员。</li>
<li>第11行，NewCat()函数定义了Cat的构造过程，使用名字作为参数，填充Cat结构体。</li>
<li>第18行，NewBlackCat()使用color作为参数，构造返回BlackCat指针。</li>
<li>第19行，实例化BlackCat结构，此时Cat也同时被实例化。</li>
<li>第20行，填充BlackCat中嵌入的Cat颜色属性。BlackCat没有任何成员，所有的成员都来自于Cat。</li>
</ul>
<p>这个例子中，Cat结构体类似于面向对象中的“基类”。BlackCat嵌入Cat结构体，类似于面向对象中的“派生”。实例化时，BlackCat中的Cat也会一并被实例化。</p>
<p>总之，Go语言中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a><span style="color:#339AFF;">方法</span></h1><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收器（Receiver）。</p>
<p>如果将特定类型理解为结构体或“类”时，接收器的概念就类似于其他语言中的this或者self。</p>
<p>在Go语言中，接收器的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。</p>
<blockquote>
<p>提示：在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在Go语言中“方法”的概念与其他语言一致，只是Go语言建立的“接收器”强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。</p>
</blockquote>
<h2 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a><span style="color:#00ACC1;">为结构体添加方法</span></h2><p>本节中，将会使用背包作为“对象”，将物品放入背包的过程作为“方法”，通过面向过程的方式和Go语言中结构体的方式来理解“方法”的概念。</p>
<p><strong>1，面向过程实现方法</strong></p>
<p>面向过程中没有“方法”概念，只能通过结构体和函数，由使用者使用函数参数和调用关系来形成接近“方法”的概念，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个物品放入背包的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span><span class="params">(b *Bag, itemid <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    bag := <span class="built_in">new</span>(Bag)</span><br><span class="line"></span><br><span class="line">    Insert(bag, <span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行，声明Bag结构，这个结构体包含一个整型切片类型的items的成员。</li>
<li>第6行，定义了Insert()函数，这个函数拥有两个参数，第一个是背包指针（*Bag），第二个是物品ID（itemid） 。</li>
<li>第7行，用append()将itemid添加到Bag的items成员中，模拟往背包添加物品的过程。</li>
<li>第12行，创建背包实例bag。</li>
<li>第14行，调用Insert()函数，第一个参数放入背包，第二个参数放入物品ID。</li>
</ul>
<p>Insert()函数将*Bag参数放在第一位，强调Insert会操作*Bag结构体。但实际使用中，并不是每个人都会习惯将操作对象放在首位。一定程度上让代码失去一些范式和描述性。同时，Insert()函数也与Bag没有任何归属概念。随着类似Insert()的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。</p>
<p><strong>2，Go语言的结构体方法</strong></p>
<p>将背包及放入背包的物品中使用Go语言的结构体和方法方式编写：为*Bag创建一个方法，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bag <span class="keyword">struct</span> &#123;</span><br><span class="line">    items []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Bag)</span> <span class="title">Insert</span><span class="params">(itemid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    b.items = <span class="built_in">append</span>(b.items, itemid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    b := <span class="built_in">new</span>(Bag)</span><br><span class="line"></span><br><span class="line">    b.Insert(<span class="number">1001</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第5行中，Insert(itemid int)的写法与函数一致。(b *Bag)表示接收器，即Insert作用的对象实例。</li>
</ul>
<p>每个方法只能有一个接收器，如图6-1所示。</p>
<blockquote>
<p>图6-1 接收器</p>
</blockquote>
<img src="/2021/08/19/第6章-结构体（struct）/1.jpg">
<ul>
<li>第13行中，在Insert()转换为方法后，我们就可以愉快地像其他语言一样，用面向对象的方法来调用b的Insert。</li>
</ul>
<h2 id="接收器——方法作用的目标"><a href="#接收器——方法作用的目标" class="headerlink" title="接收器——方法作用的目标"></a><span style="color:#00ACC1;">接收器——方法作用的目标</span></h2><p>接收器的格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收器变量 接收器类型)</span> 方法名<span class="params">(参数列表)</span> <span class="params">(返回参数)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是self，this之类的命名。例如，Socket类型的接收器变量应该命名为s，Connector类型的接收器变量应该命名为c等。</li>
<li>接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。</li>
<li>方法名、参数列表、返回参数：格式与函数定义一致。</li>
</ul>
<p>接收器根据接收器的类型可以分为指针接收器、非指针接收器。两种接收器在使用时会产生不同的效果。根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。</p>
<p><strong>1，理解指针类型的接收器</strong></p>
<p>指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的this或者self。</p>
<p>由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。</p>
<p>在下面的例子，使用结构体定义一个属性（Property），为属性添加SetValue()方法以封装设置属性的过程，通过属性的Value()方法可以重新获得属性的数值。使用属性时，通过SetValue()方法的调用，可以达成修改属性值的效果。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义属性结构</span></span><br><span class="line"><span class="keyword">type</span> Property <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span>   <span class="comment">// 属性值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">SetValue</span> <span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改p的成员变量</span></span><br><span class="line">    p.value = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取属性值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Property)</span> <span class="title">Value</span> <span class="params">()</span> <span class="title">int</span></span>  &#123;</span><br><span class="line">    <span class="keyword">return</span> p.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化属性</span></span><br><span class="line">    p := <span class="built_in">new</span>(Property)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    p.SetValue(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印值</span></span><br><span class="line">    fmt.Println(p.Value())</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第6行，定义一个属性结构，拥有一个整型的成员变量。</li>
<li>第11行，定义属性值的方法。</li>
<li>第14行，设置属性值方法的接收器类型为指针。因此可以修改成员值，即便退出方法，也有效。</li>
<li>第18行，定义获取值的方法。</li>
<li>第25行，实例化属性结构。</li>
<li>第28行，设置值。此时成员变量变为100。</li>
<li>第31行，获取成员变量。</li>
</ul>
<p>运行程序，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure></p>
<p><strong>2，理解非指针类型的接收器</strong></p>
<p>当方法作用于非指针接收器时，Go语言会在代码运行时将接收器的值复制一份。在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。</p>
<p>点（Point）使用结构体描述时，为点添加Add()方法，这个方法不能修改Point的成员X、Y变量，而是在计算后返回新的Point对象。Point属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义点结构</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="keyword">int</span></span><br><span class="line">    Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非指针接收器的加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Add</span><span class="params">(other Point)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员值与参数相加后返回新的结构</span></span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X + other.X, p.Y + other.Y&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化点</span></span><br><span class="line">    p1 := Point&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">    p2 := Point&#123;<span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与另外一个点相加</span></span><br><span class="line">    result := p1.Add(p2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Println(result)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第8行，定义一个点结构，拥有X和Y两个整型分量。</li>
<li>第14行，为Point结构定义一个Add()方法。传入和返回都是点的结构，可以方便地实现多个点连续相加的效果，例如：</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P4 := P1.Add(P2).Add(P3)</span><br></pre></td></tr></table></figure>
<ul>
<li>第23和24行，初始化两个点p1和p2。</li>
<li>第27行，将p1和p2相加后返回结果。</li>
<li>第30行，打印结果。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;3 3&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于例子中使用了非指针接收器，Add()方法变得类似于只读的方法，Add()方法内部不会对成员进行任何修改。</p>
<p><strong>3，指针和非指针接收器的使用</strong></p>
<p>在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器。大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。</p>
<h2 id="示例：二维矢量模拟玩家移动"><a href="#示例：二维矢量模拟玩家移动" class="headerlink" title="示例：二维矢量模拟玩家移动"></a><span style="color:#00ACC1;">示例：二维矢量模拟玩家移动</span></h2><p>在游戏中，一般使用二维矢量保存玩家的位置。使用矢量运算可以计算出玩家移动的位置。本例子中，首先实现二维矢量对象，接着构造玩家对象，最后使用矢量对象和玩家对象共同模拟玩家移动的过程。</p>
<p><strong>1，实现二维矢量结构</strong></p>
<p>矢量是数学中的概念，二维矢量拥有两个方向的信息，同时可以进行加、减、乘（缩放）、距离、单位化等计算。在计算机中，使用拥有X和Y两个分量的Vec2结构体实现数学中二维向量的概念。详细实现请参考代码6-1。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vec2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vec2)</span> <span class="title">Add</span><span class="params">(other Vec2)</span> <span class="title">Vec2</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Vec2&#123;</span><br><span class="line">        v.X + other.X,</span><br><span class="line">        v.Y + other.Y,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vec2)</span> <span class="title">Sub</span><span class="params">(other Vec2)</span> <span class="title">Vec2</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Vec2&#123;</span><br><span class="line">        v.X - other.X,</span><br><span class="line">        v.Y - other.Y,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vec2)</span> <span class="title">Scale</span><span class="params">(s <span class="keyword">float32</span>)</span> <span class="title">Vec2</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Vec2&#123;v.X * s, v.Y * s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 距离</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vec2)</span> <span class="title">DistanceTo</span><span class="params">(other Vec2)</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    dx := v.X - other.X</span><br><span class="line">    dy := v.Y - other.Y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float32</span>(math.Sqrt(<span class="keyword">float64</span>(dx*dx + dy*dy)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vec2)</span> <span class="title">Normalize</span><span class="params">()</span> <span class="title">Vec2</span></span> &#123;</span><br><span class="line">    mag := v.X*v.X + v.Y*v.Y</span><br><span class="line">    <span class="keyword">if</span> mag &gt; <span class="number">0</span> &#123;</span><br><span class="line">        oneOverMag := <span class="number">1</span> / <span class="keyword">float32</span>(math.Sqrt(<span class="keyword">float64</span>(mag)))</span><br><span class="line">        <span class="keyword">return</span> Vec2&#123;v.X * oneOverMag, v.Y * oneOverMag&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Vec2&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第5行声明了一个Vec2结构体，包含两个方向的单精度浮点数作为成员。</li>
<li>第10～16行定义了Vec2的Add()方法。使用自身Vec2和通过Add()方法传入的Vec2进行相加。相加后，结果以返回值形式返回，不会修改Vec2的成员。</li>
<li>第20行定义了Vec2的减法操作。</li>
<li>第29行，缩放或者叫矢量乘法，是对矢量的每个分量乘上缩放比，Scale()方法传入一个参数同时乘两个分量，表示这个缩放是一个等比缩放。</li>
<li>第35行定义了计算两个矢量的距离。math.Sqrt()是开方函数，参数是float64，在使用时需要转换。返回值也是float64，需要转换回float32。</li>
<li>第43行定义矢量单位化。</li>
</ul>
<p><strong>2，实现玩家对象</strong></p>
<p>玩家对象负责存储玩家的当前位置、目标位置和速度。使用MoveTo()方法为玩家设定移动的目标，使用Update()方法更新玩家位置。在Update()方法中，通过一系列的矢量计算获得玩家移动后的新位置，步骤如下。</p>
<p>（1）使用矢量减法，将目标位置（targetPos）减去当前位置（currPos）即可计算出位于两个位置之间的新矢量，如图6-2所示。</p>
<blockquote>
<p>图6-2 计算玩家方向矢量</p>
</blockquote>
<img src="/2021/08/19/第6章-结构体（struct）/2.jpg">
<p>（2）使用Normalize()方法将方向矢量变为模为1的单位化矢量。这里需要将矢量单位化后才能进行后续计算，如图6-3所示。</p>
<blockquote>
<p>图6-3 单位化方向矢量</p>
</blockquote>
<img src="/2021/08/19/第6章-结构体（struct）/3.jpg">
<p>（3）获得方向后，将单位化方向矢量根据速度进行等比缩放，速度越快，速度数值越大，乘上方向后生成的矢量就越长（模很大），如图6-4所示。</p>
<blockquote>
<p>图6-4 根据速度缩放方向</p>
</blockquote>
<img src="/2021/08/19/第6章-结构体（struct）/4.jpg">
<p>（4）将缩放后的方向添加到当前位置后形成新的位置，如图6-5所示。</p>
<blockquote>
<p>图6-5 缩放后的方向叠加位置形成新位置</p>
</blockquote>
<img src="/2021/08/19/第6章-结构体（struct）/5.jpg">
<blockquote>
<p>代码6-2 玩家对象（具体文件：…/chapter06/playermove/player.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Player <span class="keyword">struct</span> &#123;</span><br><span class="line">    currPos   Vec2    <span class="comment">// 当前位置</span></span><br><span class="line">    targetPos Vec2    <span class="comment">// 目标位置</span></span><br><span class="line">    speed     <span class="keyword">float32</span> <span class="comment">// 移动速度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动到某个点就是设置目标位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">MoveTo</span><span class="params">(v Vec2)</span></span> &#123;</span><br><span class="line">    p.targetPos = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Pos</span><span class="params">()</span> <span class="title">Vec2</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.currPos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否到达</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">IsArrived</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过计算当前玩家位置与目标位置的距离不超过移动的步长，判断已经到达目标点</span></span><br><span class="line">    <span class="keyword">return</span> p.currPos.DistanceTo(p.targetPos) &lt; p.speed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逻辑更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Player)</span> <span class="title">Update</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !p.IsArrived() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出当前位置指向目标的朝向</span></span><br><span class="line">        dir := p.targetPos.Sub(p.currPos).Normalize()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加速度矢量生成新的位置</span></span><br><span class="line">        newPos := p.currPos.Add(dir.Scale(p.speed))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动完成后，更新当前位置</span></span><br><span class="line">        p.currPos = newPos</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新玩家</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPlayer</span><span class="params">(speed <span class="keyword">float32</span>)</span> *<span class="title">Player</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;Player&#123;</span><br><span class="line">        speed: speed,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第3行，结构体Player定义了一个玩家的基本属性和方法。结构体的currPos表示当前位置，speed表示速度。</li>
<li>第10行，定义玩家的移动方法。逻辑层通过这个函数告知玩家要去的目标位置，随后的移动过程由Update()方法负责。</li>
<li>第15行，使用Pos方法实现玩家currPos的属性访问封装。</li>
<li>第20行，判断玩家是否到达目标点。玩家每次移动的半径就是速度（speed），因此，如果与目标点的距离小于速度，表示已经非常靠近目标，可以视为到达目标。</li>
<li>第27行，玩家移动时位置更新的主要实现。</li>
<li>第29行，如果已经到达，则不必再更新。</li>
<li>第32行，数学中，两矢量相减将获得指向被减矢量的新矢量。Sub()方法返回的新矢量使用Normalize()方法单位化。最终返回的dir矢量就是移动方向。</li>
<li>第35行，在当前的位置上叠加根据速度缩放的方向计算出新的位置newPos。</li>
<li>第38行，将新位置更新到currPos，为下一次移动做准备。</li>
<li>第44行，玩家的构造函数，创建一个玩家实例需要传入一个速度值。</li>
</ul>
<p><strong>3，处理移动逻辑</strong></p>
<p>将Player实例化后，设定玩家移动的最终目标点。之后开始进行移动的过程，这是一个不断更新位置的循环过程，每次检测玩家是否靠近目标点附近，如果还没有到达，则不断地更新位置，让玩家朝着目标点不停的修改当前位置，如下代码6-3所示：</p>
<blockquote>
<p>代码6-3 移动逻辑（具体文件：…/chapter06/playermove/main.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化玩家对象，并设速度为0.5</span></span><br><span class="line">    p := NewPlayer(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让玩家移动到3,1点</span></span><br><span class="line">    p.MoveTo(Vec2&#123;<span class="number">3</span>, <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有到达就一直循环</span></span><br><span class="line">    <span class="keyword">for</span> !p.IsArrived() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新玩家位置</span></span><br><span class="line">        p.Update()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印每次移动后的玩家位置</span></span><br><span class="line">        fmt.Println(p.Pos())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第8行，使用NewPlayer()函数构造一个*Player玩家对象，并设移动速度为0.5，速度本身是一种相对的和抽象的概念，在这里没有单位，可以根据实际效果进行调整，达到合适的范围即可。</li>
<li>第11行，设定玩家移动的最终目标为X为3，Y为1。</li>
<li>第14行，构造一个循环，条件是没有到达时一直循环。</li>
<li>第17行，不停地更新玩家位置，如果玩家到达目标，p.ISArrived将会变为true。</li>
<li>第20行，打印每次更新后玩家的位置。</li>
</ul>
<p>本例中使用到了结构体的方法、构造函数、指针和非指针类型方法接收器等，读者通过这个例子可以了解在哪些地方能够使用结构体。</p>
<h2 id="为类型添加方法"><a href="#为类型添加方法" class="headerlink" title="为类型添加方法"></a><span style="color:#00ACC1;">为类型添加方法</span></h2><p>Go语言可以对任何类型添加方法。给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。</p>
<p><strong>1，为基本类型添加方法</strong></p>
<p>在Go语言中，使用type关键字可以定义出新的自定义类型。之后就可以为自定义类型添加各种方法。我们习惯于使用面向过程的方式判断一个值是否为0，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123; </span><br><span class="line">    <span class="comment">// v等于0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将v当做整型对象，那么判断v值就可以增加一个IsZero()方法，通过这个方法就可以判断v值是否为0，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v.IsZero() &#123;</span><br><span class="line">    <span class="comment">// v等于0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详细实现流程请参考代码6-4。</p>
<blockquote>
<p>代码6-4 类型方法（具体文件：…/Chater06/typemethod/typemethod.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将int定义为MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为MyInt定义IsZero方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">IsZero</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为MyInt添加Add方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">Add</span><span class="params">(other <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> other + <span class="keyword">int</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Println(b.IsZero())</span><br><span class="line"></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(b.Add(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第8行，使用type MyInt int将int定义为自定义的MyInt类型。</li>
<li>第11行，为MyInt类型添加IsZero()方法。该方法使用了(m MyInt)的非指针接收器数值类型没有必要使用指针接收器。</li>
<li>第16行，为MyInt类型添加Add()方法。</li>
<li>第17行，由于m的类型是MyInt类型，但其本身是int类型，因此可以将m从Mylnt类型转换为int类型再进行计算。</li>
<li>第24行，调用b的IsZero()方法。由于使用非指针接收器，b的值会被复制进入IsZero()方法进行判断。</li>
<li>第28行，调用b的Add()方法。同样也是非指针接收器，结果直接通过Add()方法返回。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p><strong>2，http包中的类型方法</strong></p>
<p>Go语言提供的http包里也大量使用了类型方法。Go语言使用http包进行HTTP的请求，使用http包的NewRequest()方法可以创建一个HTTP请求，填充请求中的http头（req.Header），再调用http.Client的Do包方法，将传入的HTTP请求发送出去。</p>
<p>下面代码演示创建一个HTTP请求，并且设定HTTP头，请参考代码6-5。</p>
<blockquote>
<p>代码6-5 HTTP请求（具体文件：…/chapter06/httpreq/httpreq.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个http请求</span></span><br><span class="line">    req, err := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://www.163.com/"</span>, strings.NewReader(<span class="string">"key=value"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现错误就打印并退出</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为标头添加信息</span></span><br><span class="line">    req.Header.Add(<span class="string">"User-Agent"</span>, <span class="string">"myClient"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始请求</span></span><br><span class="line">    resp, err := client.Do(req)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求的错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第11行，实例化HTTP的客户端，请求需要通过这个客户端实例发送。</li>
<li>第14行，使用POST方式向网易的服务器创建一个HTTP请求，第三个参数为HTTP的Body部分。Body部分的内容来自字符串，但参数只能接受io.Reader类型，因此使用strings.NewReader()创建一个字符串的读取器，返回的io.Reader接口作为http的Body部分供NewRequest()函数读取。创建请求只是构造一个请求对象，不会连接网络。</li>
<li>第24行，为创建好的HTTP请求的头部添加User-Agent，作用是表明用户的代理特性。</li>
<li>第27行，使用客户端处理请求，此时client将HTTP请求发送到网易服务器。服务器响应请求后，将信息返回并保存到resp变量中。</li>
<li>第37行，读取响应的Body部分并打印。</li>
</ul>
<p>代码执行结果如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>405 Not Allowed<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">"white"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>405 Not Allowed<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>nginx<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>由于我们构造的请求不是网易服务器所支持的类型，所以服务器返回操作不被运行的405号错误。</p>
<p>在本例子第24行中使用的req.Header的类型为http.Header，就是典型的自定义类型，并且拥有自己的方法。http.Header的部分定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Add</span><span class="params">(key, value <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    textproto.MIMEHeader(h).Add(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Set</span><span class="params">(key, value <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    textproto.MIMEHeader(h).Set(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Header)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> textproto.MIMEHeader(h).Get(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行，Header实际是一个以宁符串为键、字符串切片为值的映射。</li>
<li>第3行，Add()为Header的方法，map是一个引用类型，因此即便使用(h Header)的非指针接收器，也可以修改map的值。</li>
</ul>
<p>为类型添加方法的过程是一个语言层特性，使用类型方法的代码经过编译器编译后的代码运行效率与传统的面向过程或面向对象的代码没有任何区别。因此，为了代码便于理解，可以在编码时使用Go语言的类型方法特性。</p>
<p><strong>3，time包中的类型方法</strong></p>
<p>Go语言提供的time包主要用于时间的获取和计算等。在这个包中，也使用了类型方法，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(time.Second.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第9行的time.Second是一个常量，下面代码的加粗部分就是time.Second的定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * time.Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>Second的类型为Duration，而Duration实际是一个int64的类型，定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br></pre></td></tr></table></figure></p>
<p>它拥有一个String的方法，部分定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Duration)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 一系列生成buf的代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(buf[w:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Duration.String可以将Duration的值转为字符串。</p>
<h2 id="示例：使用事件系统实现事件的响应和处理"><a href="#示例：使用事件系统实现事件的响应和处理" class="headerlink" title="示例：使用事件系统实现事件的响应和处理"></a><span style="color:#00ACC1;">示例：使用事件系统实现事件的响应和处理</span></h2><p>Go语言可以将类型的方法与普通函数视为一个概念，从而简化方法和函数混合作为回调类型时的复杂性。这个特性和C#中的代理（delegate）类似，调用者无须关心谁来支持调用，系统会自动处理是否调用普通函数或类型的方法。</p>
<p>本节中，首先将用简单的例子了解Go语言是如何将方法与函数视为一个概念，接着会实现一个事件系统，事件系统能有效地将事件触发与响应两端代码解耦。</p>
<p><strong>1，方法和函数的统一调用</strong></p>
<p>本节的例子将让一个结构体的方法（class.Do）的参数和一个普通函数（funcDo）的参数完全一致，也就是方法与函数的签名一致。然后使用与它们签名一致的函数变量（delegate）分别赋值方法与函数，接着调用它们，观察实际效果。详细实现请参考代码6-6。</p>
<blockquote>
<p>代码6-6 函数代理（具体文件：…/chapter06/delegate/delegate.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个结构体</span></span><br><span class="line"><span class="keyword">type</span> class <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给结构体添加Do方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *class)</span> <span class="title">Do</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"call method do:"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数的Do</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcDo</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"call function do:"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个函数回调</span></span><br><span class="line">    <span class="keyword">var</span> delegate <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 创建结构体实例</span></span><br><span class="line"><span class="function">    <span class="title">c</span> := <span class="title">new</span><span class="params">(class)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 将回调设为<span class="title">c</span>的<span class="title">Do</span>方法</span></span><br><span class="line"><span class="function">    <span class="title">delegate</span> = <span class="title">c</span>.<span class="title">Do</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 调用</span></span><br><span class="line"><span class="function">    <span class="title">delegate</span><span class="params">(100)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 将回调设为普通函数</span></span><br><span class="line"><span class="function">    <span class="title">delegate</span> = <span class="title">funcDo</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 调用</span></span><br><span class="line"><span class="function">    <span class="title">delegate</span><span class="params">(100)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，为结构体添加一个D0()方法，参数为整型。这个方法的功能是打印提示和输入的参数值。</li>
<li>第16行，声明一个普通函数，参数也是整型，功能是打印提示和输入的参数值。</li>
<li>第24行，声明一个delegate的变量，类型为func(int)，与funcDo和class的DoO方法的参数一致。</li>
<li>第30行，将c.Do作为值赋给delegate变量。</li>
<li>第33行，调用delegate()函数，传入100的参数。此时会调用c实例的Do()方法。</li>
<li>第36行，将funcDo赋值给delegate。</li>
<li>第39行，调用delegate()，传入100的参数。此时会调用funcDo()方法。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call method do： 100</span><br><span class="line">call function do： 100</span><br></pre></td></tr></table></figure></p>
<p>这段代码能运行的基础在于：无论是普通函数还是结构体的方法，只要它们的签名一致，与它们签名一致的函数变量就可以保存普通函数或是结构体方法。</p>
<p>了解了Go语言的这一特性后，我们就可以将这个特性用在事件中。</p>
<p><strong>2，事件系统基本原理</strong></p>
<p>事件系统可以将事件派发者与事件处理者解耦。例如，网络底层可以生成各种事件，在网络连接上后，网络底层只需将事件派发出去，而不需要关心到底哪些代码来响应连接上的逻辑。或者再比如，你注册、关注或者订阅某“大V”的社交消息后，“大V”发生的任何事件都会通知你，但他并不用了解粉丝们是如何为她喝彩或者疯狂的。如图6-6所示为事件系统基本原理图。</p>
<blockquote>
<p>图6-6 </p>
</blockquote>
<img src="/2021/08/19/第6章-结构体（struct）/6.jpg">
<p>一个事件系统拥有如下特性：</p>
<ul>
<li>能够实现事件的一方，可以根据事件ID或名字注册对应的事件。</li>
<li>事件发起者，会根据注册信息通知这些注册者。</li>
<li>一个事件可以有多个实现方响应。</li>
</ul>
<p>通过下面的步骤详细了解事件系统的构成及使用。</p>
<p><strong>3，事件注册</strong></p>
<p>事件系统需要为外部提供一个注册入口。这个注册入口传入注册的事件名称和对应事件名称的响应函数，事件注册的过程就是将事件名称和响应函数关联并保存起来，详细实现请参考代码6-7的RegisterEvent()函数。</p>
<blockquote>
<p>代码6-7 注册事件（具体文件：…/chapter06/eventsys/reg.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个通过字符串映射函数切片的map</span></span><br><span class="line"><span class="keyword">var</span> eventByName = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 注册事件，提供事件名和回调函数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">RegisterEvent</span><span class="params">(name <span class="keyword">string</span>, callback <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过名字查找事件列表</span></span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在列表切片中添加函数</span></span><br><span class="line">    list = <span class="built_in">append</span>(list, callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将修改的事件列表切片保存回去</span></span><br><span class="line">    eventByName[name] = list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallEvent</span><span class="params">(name <span class="keyword">string</span>, param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过名字找到事件列表</span></span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这个事件的所有回调</span></span><br><span class="line">    <span class="keyword">for</span> _, callback := <span class="keyword">range</span> list &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入参数调用回调</span></span><br><span class="line">        callback(param)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，创建一个map实例，这个map通过事件名（string）关联回调列表（[func(interface{}），同一个事件名称可能存在多个事件回调，因此使用回调列表保存。回调的函数声明为func（interface{}）。</li>
<li>第5行，提供给外部的通过事件名注册响应函数的入口。</li>
<li>第8行， eventByName通过事件名（name）进行查询，返回回调列表（[func(interface)）。</li>
<li>第11行，为同一个事件名称在已经注册的事件回调的列表中再添加一个回调函数。</li>
<li>第14行，将修改后的函数列表设置到map的对应事件名中。</li>
</ul>
<p>拥有事件名和事件回调函数列表的关联关系后，就需要开始准备事件调用的入口了。</p>
<p><strong>4，事件调用</strong></p>
<p>事件调用方和注册方是事件处理中完全不同的两个角色。事件调用方是事发现场，负责将事件和事件发生的参数通过事件系统派发出去，而不关心事件到底由谁处理；事件注册方通过事件系统注册应该响应哪些事件及如何使用回调函数处理这些事件。事件调用的详细实现请参考代码6-8的CallEvent()函数。</p>
<blockquote>
<p>代码6-8 调用事件（具体文件：…/chapter06/eventsys/reg.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个通过字符串映射函数切片的map</span></span><br><span class="line"><span class="keyword">var</span> eventByName = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 注册事件，提供事件名和回调函数</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">RegisterEvent</span><span class="params">(name <span class="keyword">string</span>, callback <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过名字查找事件列表</span></span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在列表切片中添加函数</span></span><br><span class="line">    list = <span class="built_in">append</span>(list, callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将修改的事件列表切片保存回去</span></span><br><span class="line">    eventByName[name] = list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallEvent</span><span class="params">(name <span class="keyword">string</span>, param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过名字找到事件列表</span></span><br><span class="line">    list := eventByName[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这个事件的所有回调</span></span><br><span class="line">    <span class="keyword">for</span> _, callback := <span class="keyword">range</span> list &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入参数调用回调</span></span><br><span class="line">        callback(param)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，调用事件的入口，提供事件名称name和参数param。事件的参数表示描述事件具体的细节，例如门打开的事件触发时，参数可以传入谁进来了。</li>
<li>第5行，通过注册事件回调的eventByName和事件名字查询处理函数列表listo。</li>
<li>第8行，遍历这个事件列表，如果没有找到对应的事件，list将是一个空切片。</li>
<li>第11行，将每个函数回调传入事件参数并调用，就会触发事件实现方的逻辑处理。事件系统应该具备的事件注册和调用已经实现，下面将会使用事件系统把实际的事发现场和事件处理方联系起来。</li>
</ul>
<p><strong>5，使用事件系统</strong></p>
<p>例子中，在main()函数中调用事件系统的CallEvent生成OnSkill事件，这个事件有两个处理函数，一个是角色的OnEvent()方法，还有一个是函数GlobalEvent()，详细代码实现过程请参考代码6-9。</p>
<blockquote>
<p>代码6-9 使用事件系统（具体文件：…/chapter06/eventsys/main.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明角色的结构体</span></span><br><span class="line"><span class="keyword">type</span> Actor <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为角色添加一个事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Actor)</span> <span class="title">OnEvent</span><span class="params">(param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"actor event:"</span>, param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GlobalEvent</span><span class="params">(param <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"global event:"</span>, param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个角色</span></span><br><span class="line">    a := <span class="built_in">new</span>(Actor)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册名为OnSkill的回调</span></span><br><span class="line">    RegisterEvent(<span class="string">"OnSkill"</span>, a.OnEvent)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次在OnSkill上注册全局事件</span></span><br><span class="line">    RegisterEvent(<span class="string">"OnSkill"</span>, GlobalEvent)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用事件，所有注册的同名函数都会被调用</span></span><br><span class="line">    CallEvent(<span class="string">"OnSkill"</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6行，声明一个角色的结构体。在游戏中，角色是常见的对象，本例中，角色也是Onskill事件的响应处理方。</li>
<li>第10行，为角色结构添加一个OnEvent()方法，这个方法拥有param参数，类型为interface{}，与事件系统的函数（func(interface{f}）签名一致。</li>
<li>第16行为全局事件响应函数。有时需要全局进行侦听或者处理一些事件，这里使用普通函数实现全局事件的处理。</li>
<li>第27行，注册一个Onskill事件，实现代码由a的OnEvent进行处理。也就是Actor的OnEvent()方法。</li>
<li>第30行，注册一个Onskill事件，实现代码由GlobalEvent进行处理，虽然注册的是同一个名字的事件，但前面注册的事件不会被覆盖，而是被添加到事件系统中，关联OnSkill事件的函数列表中。</li>
<li>第33行，模拟处理事件，通过CallEvent()函数传入两个参数，第一个为事件名，第二个为处理函数的参数。</li>
</ul>
<p>整个例子运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actor event: 100</span><br><span class="line">global event: 100</span><br></pre></td></tr></table></figure></p>
<p>结果演示，角色和全局的事件会按注册顺序顺序地触发。</p>
<p>一般来说，事件系统不保证同一个事件实现方多个函数列表中的调用顺序，事件系统认为所有实现函数都是平等的。也就是说，无论例子中的a.OnEvent先注册，还是GlobalEvent()函数先注册，最终谁先被调用，都是无所谓的，开发者不应该去关注和要求保证调用的顺序。</p>
<p>一个完善的事件系统还会提供移除单个和所有事件的方法。</p>
<h1 id="类型内嵌和结构体内嵌"><a href="#类型内嵌和结构体内嵌" class="headerlink" title="类型内嵌和结构体内嵌"></a><span style="color:#339AFF;">类型内嵌和结构体内嵌</span></h1><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种形式的字段被称为类型内嵌或匿名字段。</p>
<p>类型内嵌的写法如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> </span><br><span class="line">    <span class="keyword">float32</span></span><br><span class="line">    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ins := &amp;Data&#123;</span><br><span class="line">    <span class="keyword">int</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="keyword">float32</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="keyword">bool</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2～4行定义结构体中的匿名字段，类型分别是整型、浮点、布尔。</li>
<li>第8～10行将实例化的Data中的字段赋初值。</li>
</ul>
<p>类型内嵌其实仍然拥有自己的字段名，只是字段名就是其类型本身而已，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p>
<p>结构体实例化后，如果匿名的字段类型为结构体，那么可以直接访问匿名结构体里的所有成员，这种方式被称为结构体内嵌。</p>
<h2 id="声明结构体内嵌"><a href="#声明结构体内嵌" class="headerlink" title="声明结构体内嵌"></a><span style="color:#00ACC1;">声明结构体内嵌</span></h2><p>结构体类型内嵌比普通类型内嵌的概念复杂一些，下面通过一个实例来理解。</p>
<p>计算机图形学中的颜色有两种类型，一种是包含红、绿、蓝三原色的基础颜色；另一种是在基础颜色之外增加透明度的颜色。透明度在颜色中叫Alpha，范围为0～1之间。0表示完全透明，1表示不透明。使用传统的结构体字段的方法定义基础颜色和带有透明度颜色的过程代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础颜色</span></span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 红、绿、蓝三种颜色分量</span></span><br><span class="line">    R,G,B <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整颜色定义</span></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基本颜色作为成员</span></span><br><span class="line">    Basic BasicColor</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 透明度</span></span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置基本颜色分量</span></span><br><span class="line">    c.Basic.R = <span class="number">1</span></span><br><span class="line">    c.Basic.G = <span class="number">1</span></span><br><span class="line">    c.Basic.B = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置透明度</span></span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示整个结构体内容</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Basic:&#123;R:1 G:1 B:0&#125; Alpha:1&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第8行定义基础颜色结构，包含3个颜色分量，分别是红、绿、蓝，范围为0～1。</li>
<li>第14行定义了完整颜色结构，包含有基础颜色和透明度。</li>
<li>第25行，实例化一个完整颜色结构。</li>
<li>第28～30行访问基础颜色并赋值。</li>
</ul>
<p>第28～30行的代码需要通过Basic结构才能设置R、G、B分量，虽然合理但是写法很复杂。使用Go语言的结构体内嵌写法重新调整代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BasicColor <span class="keyword">struct</span> &#123;</span><br><span class="line">    R,G,B <span class="keyword">float32</span> <span class="comment">// &lt;-</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">    BasicColor</span><br><span class="line">    Alpha <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> c Color</span><br><span class="line"></span><br><span class="line">    c.R = <span class="number">1</span> <span class="comment">// &lt;-</span></span><br><span class="line">    c.G = <span class="number">1</span> <span class="comment">// &lt;-</span></span><br><span class="line">    c.B = <span class="number">0</span> <span class="comment">// &lt;-</span></span><br><span class="line">    </span><br><span class="line">    c.Alpha = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%+v"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码标记部分是经过调整及修改的代码。代码第12行中，将BasicColor结构体嵌入到Color结构体中，BasicColor没有字段名而只有类型，这种写法就叫做结构体内嵌。</p>
<p>第19～21行中，可以直接对Color的R、G、B成员进行设置，编译器通过Color的定义知道R、G、B成员来自BasicColor内嵌的结构体。</p>
<h2 id="结构内嵌特性"><a href="#结构内嵌特性" class="headerlink" title="结构内嵌特性"></a><span style="color:#00ACC1;">结构内嵌特性</span></h2><p>Go语言的结构体内嵌有如下特性。</p>
<p><strong>1，内嵌的结构体可以直接访问其成员变量</strong></p>
<p>嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。</p>
<p><strong>2，内嵌结构体的字段名是它的类型名</strong></p>
<p>内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c Color</span><br><span class="line">c.BasicColor.R = <span class="number">1</span></span><br><span class="line">c.BasicColor.G = <span class="number">1</span></span><br><span class="line">c.BasicColor.B = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。</p>
<h2 id="使用组合思想描述对象特性"><a href="#使用组合思想描述对象特性" class="headerlink" title="使用组合思想描述对象特性"></a><span style="color:#00ACC1;">使用组合思想描述对象特性</span></h2><p>在面向对象思想中，实现对象关系需要使用“继承”特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。</p>
<p>面向对象的设计原则中也建议对象最好不要使用多重继承，有些面向对象语言从语言层面就禁止了多重继承，如C#和Java语言。鸟类同时继承自可行走类和飞行类，这显然是存在问题的。在面向对象思想中要正确地实现对象的多重特性，只能使用一些精巧的设计来补救。</p>
<p>Go语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。</p>
<p>下面的代码使用Go语言的结构体内嵌实现对象特性组合，请参考代码6-10。</p>
<blockquote>
<p>代码6-10 人和鸟的特性（具体文件：…/chapter06/humanbird/humanbird.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可飞行的</span></span><br><span class="line"><span class="keyword">type</span> Flying <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Flying)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"can fly"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可行走的</span></span><br><span class="line"><span class="keyword">type</span> Walkable <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Walkable)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"can walk"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人类</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 人类能行走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸟类</span></span><br><span class="line"><span class="keyword">type</span> Bird <span class="keyword">struct</span> &#123;</span><br><span class="line">    Walkable <span class="comment">// 鸟类能行走</span></span><br><span class="line">    Flying   <span class="comment">// 鸟类能飞行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化鸟类</span></span><br><span class="line">    b := <span class="built_in">new</span>(Bird)</span><br><span class="line">    fmt.Println(<span class="string">"Bird: "</span>)</span><br><span class="line">    b.Fly()</span><br><span class="line">    b.Walk()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化人类</span></span><br><span class="line">    h := <span class="built_in">new</span>(Human)</span><br><span class="line">    fmt.Println(<span class="string">"Human: "</span>)</span><br><span class="line">    h.Walk()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6行，声明可飞行结构（Flying）。</li>
<li>第8行，为可飞行结构添加飞行方法Fly()。</li>
<li>第13行，声明可行走结构（Walkable）。</li>
<li>第15行，为可行走结构添加行走方法Walk()。</li>
<li>第20行，声明人类结构。这个结构嵌入可行走结构（Walkable），让人类具备“可行走”特性。</li>
<li>第25行，声明鸟类结构。这个结构嵌入可行走结构（Walkable）和可飞行结构（Flying），让鸟类具备既可行走又可飞行的特性。</li>
<li>第33行，实例化鸟类结构。</li>
<li>第35和36行，调用鸟类可以使用的功能，如飞行和行走。</li>
<li>第39行，实例化人类结构。</li>
<li>第41行，调用人类能使用的功能，如行走。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bird:</span><br><span class="line">can fly</span><br><span class="line">can walk</span><br><span class="line">Human:</span><br><span class="line">can walk</span><br></pre></td></tr></table></figure></p>
<p>使用Go语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go语言会在编译时检查能否使用这些特性。</p>
<h2 id="初始化结构体内嵌"><a href="#初始化结构体内嵌" class="headerlink" title="初始化结构体内嵌"></a><span style="color:#00ACC1;">初始化结构体内嵌</span></h2><p>结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考代码6-11。</p>
<blockquote>
<p>代码6-11 车辆结构的组装和初始化（具体文件：…/chapter06/carinit/carinit.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 车轮</span></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引擎</span></span><br><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">    Power <span class="keyword">int</span>    <span class="comment">// 功率</span></span><br><span class="line">    Type  <span class="keyword">string</span> <span class="comment">// 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    Engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c := Car&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化轮子</span></span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: <span class="number">18</span>,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化引擎</span></span><br><span class="line">        Engine: Engine&#123;</span><br><span class="line">            Type:  <span class="string">"1.4T"</span>,</span><br><span class="line">            Power: <span class="number">143</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6行定义车轮结构。</li>
<li>第11行定义引擎结构。</li>
<li>第17行定义车结构，由车轮和引擎结构体嵌入。</li>
<li>第27行，将Car的Wheel字段使用Wheel结构体进行初始化。</li>
<li>第32行，将Car的Engine字段使用Engine结构体进行初始化。</li>
</ul>
<h2 id="初始化内嵌匿名结构体"><a href="#初始化内嵌匿名结构体" class="headerlink" title="初始化内嵌匿名结构体"></a><span style="color:#00ACC1;">初始化内嵌匿名结构体</span></h2><p>在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要再次声明结构才能赋予数据。具体请参考代码6-12。</p>
<blockquote>
<p>代码6-12 内嵌结构体（具体文件：…/chapter06/embedstruct/embedstruct.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 车轮</span></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 车</span></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">    Wheel</span><br><span class="line">    <span class="comment">// 引擎</span></span><br><span class="line">    Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">        Power <span class="keyword">int</span>    <span class="comment">// 功率</span></span><br><span class="line">        Type  <span class="keyword">string</span> <span class="comment">// 类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    c := Car&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化轮子</span></span><br><span class="line">        Wheel: Wheel&#123;</span><br><span class="line">            Size: <span class="number">18</span>,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化引擎</span></span><br><span class="line">        Engine: <span class="keyword">struct</span> &#123;</span><br><span class="line">            Power <span class="keyword">int</span></span><br><span class="line">            Type  <span class="keyword">string</span></span><br><span class="line">        &#125;&#123;</span><br><span class="line">            Type:  <span class="string">"1.4T"</span>,</span><br><span class="line">            Power: <span class="number">143</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第14行中原来的Engine结构体被直接定义在Car的结构体中。这种嵌入的写法就是将原来的结构体类型转换为struct{…}。</li>
<li>第30行，需要对Car的Engine字段进行初始化，由于Engine字段的类型并没有被单独定义，因此在初始化其字段时需要先填写struct{…}声明其类型。</li>
<li>第34行开始填充这个匿名结构体的数据，按“键:值”格式填充。</li>
</ul>
<h2 id="成员名字冲突"><a href="#成员名字冲突" class="headerlink" title="成员名字冲突"></a><span style="color:#00ACC1;">成员名字冲突</span></h2><p>嵌入结构体内部可能拥有相同的成员名，成员重名时会发生什么？下面通过例子来讲解。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := &amp;C&#123;&#125;</span><br><span class="line">    c.A.a = <span class="number">1</span></span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第7行和第11行分别定义了两个拥有a int字段的结构体。</li>
<li>第15行的结构体嵌入了A和B的结构体。</li>
<li>第21行实例化C结构体。</li>
<li>第22行按常规的方法，访问嵌入结构体A中的a字段，并赋值1。</li>
<li>第23行可以正常输出实例化C结构体。</li>
</ul>
<p>接着，将第22行修改为如下代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := &amp;C&#123;&#125;</span><br><span class="line">    с.a = <span class="number">1</span></span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时再编译运行，编译器报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main.go:21:3: ambiguous selector c.a</span><br></pre></td></tr></table></figure></p>
<p>编译器告知C的选择器a引起歧义，也就是说，编译器无法决定将1赋给C中的A还是B里的字段a。</p>
<p>在使用内嵌结构体时，Go语言的编译器会非常智能地提醒我们可能发生的歧义和错误。</p>
<h1 id="示例：使用匿名结构体分离JSON数据"><a href="#示例：使用匿名结构体分离JSON数据" class="headerlink" title="示例：使用匿名结构体分离JSON数据"></a><span style="color:#339AFF;">示例：使用匿名结构体分离JSON数据</span></h1><p>手机拥有屏幕、电池、指纹识别等信息，将这些信息填充为JSON格式的数据。如果需要选择性地分离JSON中的数据则较为麻烦。Go语言中的匿名结构体可以方便地完成这个操作。</p>
<blockquote>
<p>代码6-13 JSON数据分离（具体文件：…/chapter06/splitejson/splitejson.go）</p>
</blockquote>
<p><strong>1，定义数据结构</strong></p>
<p>首先，定义手机的各种数据结构体，如屏幕和电池，参考如下代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义手机屏幕</span></span><br><span class="line"><span class="keyword">type</span> Screen <span class="keyword">struct</span> &#123;</span><br><span class="line">    Size       <span class="keyword">float32</span> <span class="comment">// 屏幕尺寸</span></span><br><span class="line">    ResX, ResY <span class="keyword">int</span>     <span class="comment">// 屏幕水平和垂直分辨率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义电池</span></span><br><span class="line"><span class="keyword">type</span> Battery <span class="keyword">struct</span> &#123;</span><br><span class="line">    Capacity <span class="keyword">int</span>       <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了屏幕结构体和电池结构体，它们分别描述屏幕和电池的各种细节参数。</p>
<p><strong>2，准备JSON数据</strong></p>
<p>准备手机数据结构，填充数据，将数据序列化为JSON格式的字节数组，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成json数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genJsonData</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="comment">// 完整数据结构</span></span><br><span class="line">    raw := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        Screen</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID <span class="keyword">bool</span> <span class="comment">// 序列化时添加的字段：是否有指纹识别</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="comment">// 屏幕参数</span></span><br><span class="line">        Screen: Screen&#123;</span><br><span class="line">            Size: <span class="number">5.5</span>,</span><br><span class="line">            ResX: <span class="number">1920</span>,</span><br><span class="line">            ResY: <span class="number">1080</span>,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 电池参数</span></span><br><span class="line">        Battery: Battery&#123;</span><br><span class="line">            <span class="number">2910</span>,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否有指纹识别</span></span><br><span class="line">        HasTouchID: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据序列化为json</span></span><br><span class="line">    jsonData, _ := json.Marshal(raw)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第4行定义了一个匿名结构体。这个结构体内嵌了Screen和Battery结构体，同时临时加入了HasTouchID字段。</li>
<li>第10行，为刚声明的匿名结构体填充屏幕数据。</li>
<li>第17行，填充电池数据。</li>
<li>第22行，填充指纹识别字段。</li>
<li>第26行，使用json.Marshal进行JSON序列化，将raw变量序列化为[]byte格式的JSON数据。</li>
</ul>
<p><strong>3，分离JSON数据</strong></p>
<p>调用genJsonData获得JSON数据，将需要的字段填充到匿名结构体实例中，通过json.Unmarshal反序列化JSON数据达成分离JSON数据效果。代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一段json数据</span></span><br><span class="line">    jsonData := genJsonData()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(jsonData))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要屏幕和指纹识别信息的结构和实例</span></span><br><span class="line">    screenAndTouch := <span class="keyword">struct</span> &#123;</span><br><span class="line">        Screen</span><br><span class="line">        HasTouchID <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化到screenAndTouch</span></span><br><span class="line">    json.Unmarshal(jsonData, &amp;screenAndTouch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出screenAndTouch的详细结构</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, screenAndTouch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要电池和指纹识别信息的结构和实例</span></span><br><span class="line">    batteryAndTouch := <span class="keyword">struct</span> &#123;</span><br><span class="line">        Battery</span><br><span class="line">        HasTouchID <span class="keyword">bool</span></span><br><span class="line">    &#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化到batteryAndTouch</span></span><br><span class="line">    json.Unmarshal(jsonData, &amp;batteryAndTouch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出screenAndTouch的详细结构</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, batteryAndTouch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第4行，调用genJsonData()函数，获得[]byte类型的JSON数据。</li>
<li>第6行，将jsonData的[]byte类型的JSON数据转换为字符串格式并打印输出。</li>
<li>第9行，构造匿名结构体，填充Screen结构和HasTouchID字段，第12行中的{}表示将结构体实例化。</li>
<li>第15行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第9行定义的结构体格式序列化到screenAndTouch中。</li>
<li>第18行，打印输出screenAndTouch中的详细数据信息。</li>
<li>第21行，构造匿名结构体，填充Battery结构和HasTouchID字段。</li>
<li>第27行，调用json.Unmarshal，输入完整的JSON数据（jsonData），将数据按第21行定义的结构体格式序列化到batteryAndTouch中。</li>
<li>第30行，打印输出batteryAndTouch的详细数据信息。</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言从入门到进阶实战/" rel="tag"># Go语言从入门到进阶实战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/19/第5章-函数（function）/" rel="next" title="第5章 函数（function）">
                <i class="fa fa-chevron-left"></i> 第5章 函数（function）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/19/第7章-接口（interface）/" rel="prev" title="第7章 接口（interface）">
                第7章 接口（interface） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1017</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">72</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/04/04/结束语｜秒杀系统之上的业务协同思考/" title="结束语｜秒杀系统之上的业务协同思考" target="_blank">结束语｜秒杀系统之上的业务协同思考</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/14｜百万级流量秒杀系统的关键总结/" title="14｜百万级流量秒杀系统的关键总结" target="_blank">14｜百万级流量秒杀系统的关键总结</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/13｜优化番外篇：Vertx介绍及快速入门/" title="13｜优化番外篇：Vertx介绍及快速入门" target="_blank">13｜优化番外篇：Vertx介绍及快速入门</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/12｜高性能优化：单机Java极致优化/" title="12｜高性能优化：单机Java极致优化" target="_blank">12｜高性能优化：单机Java极致优化</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/11｜高性能优化：物理机极致优化/" title="11｜高性能优化：物理机极致优化" target="_blank">11｜高性能优化：物理机极致优化</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#定义结构体"><span class="nav-number">1.</span> <span class="nav-text">定义结构体</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例化结构体——为结构体分配内存并初始化"><span class="nav-number">2.</span> <span class="nav-text">实例化结构体——为结构体分配内存并初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的实例化形式"><span class="nav-number">2.1.</span> <span class="nav-text">基本的实例化形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建指针类型的结构体"><span class="nav-number">2.2.</span> <span class="nav-text">创建指针类型的结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#取结构体的地址实例化"><span class="nav-number">2.3.</span> <span class="nav-text">取结构体的地址实例化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化结构体的成员变量"><span class="nav-number">3.</span> <span class="nav-text">初始化结构体的成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用“键值对”初始化结构体"><span class="nav-number">3.1.</span> <span class="nav-text">使用“键值对”初始化结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用多个值的列表初始化结构体"><span class="nav-number">3.2.</span> <span class="nav-text">使用多个值的列表初始化结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化匿名结构体"><span class="nav-number">3.3.</span> <span class="nav-text">初始化匿名结构体</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造函数——结构体和类型的一系列初始化操作的函数封装"><span class="nav-number">4.</span> <span class="nav-text">构造函数——结构体和类型的一系列初始化操作的函数封装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多种方式创建和初始化结构体——模拟构造函数重载"><span class="nav-number">4.1.</span> <span class="nav-text">多种方式创建和初始化结构体——模拟构造函数重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带有父子关系的结构体的构造和初始化——模拟父级构造调用"><span class="nav-number">4.2.</span> <span class="nav-text">带有父子关系的结构体的构造和初始化——模拟父级构造调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法"><span class="nav-number">5.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为结构体添加方法"><span class="nav-number">5.1.</span> <span class="nav-text">为结构体添加方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接收器——方法作用的目标"><span class="nav-number">5.2.</span> <span class="nav-text">接收器——方法作用的目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：二维矢量模拟玩家移动"><span class="nav-number">5.3.</span> <span class="nav-text">示例：二维矢量模拟玩家移动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为类型添加方法"><span class="nav-number">5.4.</span> <span class="nav-text">为类型添加方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：使用事件系统实现事件的响应和处理"><span class="nav-number">5.5.</span> <span class="nav-text">示例：使用事件系统实现事件的响应和处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型内嵌和结构体内嵌"><span class="nav-number">6.</span> <span class="nav-text">类型内嵌和结构体内嵌</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#声明结构体内嵌"><span class="nav-number">6.1.</span> <span class="nav-text">声明结构体内嵌</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构内嵌特性"><span class="nav-number">6.2.</span> <span class="nav-text">结构内嵌特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用组合思想描述对象特性"><span class="nav-number">6.3.</span> <span class="nav-text">使用组合思想描述对象特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化结构体内嵌"><span class="nav-number">6.4.</span> <span class="nav-text">初始化结构体内嵌</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化内嵌匿名结构体"><span class="nav-number">6.5.</span> <span class="nav-text">初始化内嵌匿名结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员名字冲突"><span class="nav-number">6.6.</span> <span class="nav-text">成员名字冲突</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：使用匿名结构体分离JSON数据"><span class="nav-number">7.</span> <span class="nav-text">示例：使用匿名结构体分离JSON数据</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.2m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">124:48</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
