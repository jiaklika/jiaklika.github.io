<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  空接口类型可以保存任何值。怎么定义？怎么使用？">
<meta name="keywords" content="Go语言从入门到进阶实战">
<meta property="og:type" content="article">
<meta property="og:title" content="第7章 接口（interface）">
<meta property="og:url" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  空接口类型可以保存任何值。怎么定义？怎么使用？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/2.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/t-1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/3.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/4.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/t-2.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/5.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/t-3.jpg">
<meta property="og:updated_time" content="2022-08-22T01:33:36.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第7章 接口（interface）">
<meta name="twitter:description" content="思考并回答以下问题：  空接口类型可以保存任何值。怎么定义？怎么使用？">
<meta name="twitter:image" content="http://yoursite.com/2021/08/19/第7章-接口（interface）/1.jpg">






  <link rel="canonical" href="http://yoursite.com/2021/08/19/第7章-接口（interface）/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第7章 接口（interface） | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/19/第7章-接口（interface）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第7章 接口（interface）

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-19 09:13:53" itemprop="dateCreated datePublished" datetime="2021-08-19T09:13:53+08:00">2021-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-08-22 09:33:36" itemprop="dateModified" datetime="2022-08-22T09:33:36+08:00">2022-08-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">43k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">39 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>空接口类型可以保存任何值。怎么定义？怎么使用？</li>
</ul>
<a id="more"></a>
<p>接口本身是调用方和实现方均需要遵守的一种协议，大家按照统一的方法命名参数类型和数量来协调逻辑处理的过程。</p>
<p>Go语言中使用组合实现对象特性的描述。对象的内部使用结构体内嵌组合对象应该具有的特性，对外通过接口暴露能使用的特性。</p>
<p>Go语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现。</p>
<blockquote>
<p>提示：接口是一种较为常见的特性，很多语言都有接口特性。C/C++、C#语言中的接口都可以多重派生实现接口组合；在苹果的Objective C中与接口类似的功能被称为Protocol，这种叫法比接口更形象、具体。<br><br>非侵入式设计是Go语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少。</p>
</blockquote>
<h1 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a><span style="color:#339AFF;">声明接口</span></h1><p>接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。</p>
<h2 id="接口声明的格式"><a href="#接口声明的格式" class="headerlink" title="接口声明的格式"></a><span style="color:#00ACC1;">接口声明的格式</span></h2><p>每个接口类型由数个方法组成。接口的形式代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法名<span class="number">1</span>(参数列表<span class="number">1</span>) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>(参数列表<span class="number">2</span>) 返回值列表<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>接口类型名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer，有关闭功能的接口叫Closer等。</li>
<li>方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略，例如：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span>&#123;</span><br><span class="line">    Write ([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="开发中常见的接口及写法"><a href="#开发中常见的接口及写法" class="headerlink" title="开发中常见的接口及写法"></a><span style="color:#00ACC1;">开发中常见的接口及写法</span></h2><p>Go语言提供的很多包中都有接口，例如io包中提供的Writer接口：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write (p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个接口可以调用Write()方法写入一个字节数组（[]byte），返回值告知写入字节数（n int）和可能发生的错误（err error）。</p>
<p>类似的，还有将一个对象以字符串形式展现的接口，只要实现了这个接口的类型，在调用String()方法时，都可以获得对象对应的字符串。在fmt包中定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Stringer接口在Go语言中的使用频率非常高，功能类似于Java或者C#语言里的ToString的操作。</p>
<p>Go语言的每个接口中的方法数量不会很多。Go语言希望通过一个接口精准描述它自己的功能，而通过多个接口的嵌入和组合的方式将简单的接口扩展为复杂的接口。本章后面的小节中会介绍如何使用组合来扩充接口。</p>
<h1 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a><span style="color:#339AFF;">实现接口的条件</span></h1><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。</p>
<h2 id="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"><a href="#接口被实现的条件一：接口的方法与实现接口的类型方法格式一致" class="headerlink" title="接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"></a><span style="color:#00ACC1;">接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</span></h2><p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p>
<p>为了抽象数据写入的过程，定义DataWriter接口来描述数据写入需要实现的方法，接口中的WriteData()方法表示将数据写入，写入方无须关心写入到哪里。实现接口的类型实现WriteData方法时，会具体编写将数据写入到什么结构中。这里使用file结构体实现DataWriter接口的WriteData方法，方法内部只是打印一个日志，表示有数据写入，详细实现过程请参考代码7-1。</p>
<blockquote>
<p>代码7-1 数据写入器的抽象（具体文件：…/chapter07/datawriter/datawriter.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义文件结构，用于实现DataWriter</span></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现DataWriter接口的WriteData方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span> <span class="title">WriteData</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟写入数据</span></span><br><span class="line">    fmt.Println(<span class="string">"WriteData:"</span>, data)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化file</span></span><br><span class="line">    f := <span class="built_in">new</span>(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个DataWriter的接口</span></span><br><span class="line">    <span class="keyword">var</span> writer DataWriter</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将接口赋值f，也就是*file类型</span></span><br><span class="line">    writer = f</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用DataWriter接口进行数据写入</span></span><br><span class="line">    writer.WriteData(<span class="string">"data"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第8行，定义DataWriter接口。这个接口只有一个方法，即WriteData()，输入一个interface{}类型的data，返回一个error结构表示可能发生的错误。</li>
<li>第17行，file的WriteData()方法使用指针接收器。输入一个interface{}类型的data，返回error。</li>
<li>第27行，实例化file赋值给f，f的类型为*file。</li>
<li>第30行，声明DataWriter类型的writer接口变量。</li>
<li>第33行，将*file类型的f赋值给DataWriter接口的writer，虽然两个变量类型不一致。但是writer是一个接口，且f已经完全实现了DataWriter()的所有方法，因此赋值是成功的。</li>
<li>第36行，DataWriter接口类型的writer使用WriteData()方法写入一个字符串。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeData:data</span><br></pre></td></tr></table></figure></p>
<p>本例中调用及实现关系如图7-1所示。</p>
<blockquote>
<p>图7-1 DataWriter的实现过程</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/1.jpg">
<p>当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。</p>
<p><strong>1，函数名不一致导致的报错</strong></p>
<p>在代码7-1的基础上尝试修改部分代码，造成编译错误，通过编译器的报错理解如何实现接口的方法。首先，修改file结构的WriteData()方法名，将这个方法签名（第17行）修改为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span> <span class="title">WriteDataX</span> <span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>编译代码，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">    *file does not implement DataWriter (missing WriteData method)</span><br></pre></td></tr></table></figure></p>
<p>报错的位置在第33行。报错含义是：不能将f变量（类型*file）视为DataWriter进行赋值。原因：*file类型未实现DataWriter接口（丢失WriteData方法）。</p>
<p>WriteDataX方法的签名本身是合法的。但编译器扫描到第33行代码时，发现尝试将*file类型赋值给DataWriter时，需要检查*file类型是否完全实现了DataWriter接口。显然，编译器因为没有找到DataWriter需要的WriteData()方法而报错。</p>
<p><strong>2，实现接口的方法签名不一致导致的报错</strong></p>
<p>将修改的代码恢复后，再尝试修改WriteData()方法，把data参数的类型从interface{}修改为int类型，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *file)</span> <span class="title">WriteData</span> <span class="params">(data <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p>编译代码，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">    *file does not implement DataWriter (wrong type for WriteData method)</span><br><span class="line">        have WriteData(int) error</span><br><span class="line">        want WriteData(interface &#123;&#125;) error</span><br></pre></td></tr></table></figure></p>
<p>这次未实现DataWriter的理由变为发现WriteData(int)error，期望WriteData(interface{})error（错误的WriteData()方法类型）。</p>
<p>这种方式的报错就是由实现者的方法签名与接口的方法签名不一致导致的。</p>
<h2 id="条件二：接口中所有方法均被实现"><a href="#条件二：接口中所有方法均被实现" class="headerlink" title="条件二：接口中所有方法均被实现"></a><span style="color:#00ACC1;">条件二：接口中所有方法均被实现</span></h2><p>当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。</p>
<p>在代码7-1中，为DataWriter中添加一个方法，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数据写入器</span></span><br><span class="line"><span class="keyword">type</span> DataWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteData(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 能否写入</span></span><br><span class="line">    CanWrite() <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新增CanWrite()方法，返回bool。此时再次编译代码，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cannot use f (type *file) as type DataWriter in assignment:</span><br><span class="line">    *file does not implement DataWriter (missing CanWrite method)</span><br></pre></td></tr></table></figure></p>
<p>需要在file中实现CanWrite()方法才能正常使用DataWriter()。</p>
<p>Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。</p>
<p>实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。</p>
<blockquote>
<p>提示：传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。<br><br>对于Go语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用GO语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么？”，以及“我能实现什么？”。</p>
</blockquote>
<h1 id="理解类型与接口的关系"><a href="#理解类型与接口的关系" class="headerlink" title="理解类型与接口的关系"></a><span style="color:#339AFF;">理解类型与接口的关系</span></h1><p>类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系。</p>
<h2 id="一个类型可以实现多个接口"><a href="#一个类型可以实现多个接口" class="headerlink" title="一个类型可以实现多个接口"></a><span style="color:#00ACC1;">一个类型可以实现多个接口</span></h2><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</p>
<p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个Socket。Socket能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和Socket都具备的读写特性抽象为独立的读写器概念。</p>
<p>Socket和文件一样，在使用完毕后，也需要对资源进行释放。</p>
<p>把Socket能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Socket结构的Write()方法实现了io.Writer接口：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时，Socket结构也实现了io.Closer接口：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Socket实现的Writer接口的代码，无须了解Writer接口的实现者是否具备Closer接口的特性。同样，使用Closer接口的代码也并不知道Socket已经实现了Writer接口，如图7-2所示。</p>
<blockquote>
<p>图7-2 接口的使用和实现过程</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/2.jpg">
<p>在代码中使用Socket结构实现的Writer接口和Closer接口代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用io.Writer的代码，并不知道Socket和io.Closer的存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingWriter</span><span class="params">( writer io.Writer)</span></span>&#123;</span><br><span class="line">    writer.Write(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用io.Closer，并不知道Socket和io.Writer的存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usingCloser</span><span class="params">( closer io.Closer)</span></span>  &#123;</span><br><span class="line">    closer.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化Socket</span></span><br><span class="line">    s := <span class="built_in">new</span>(Socket)</span><br><span class="line"></span><br><span class="line">    usingWriter(s)</span><br><span class="line"></span><br><span class="line">    usingCloser(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>usingWriter()和usingCloser()完全独立，互相不知道对方的存在，也不知道自己使用的接口是Socket实现的。</p>
<h2 id="多个类型可以实现相同的接口"><a href="#多个类型可以实现相同的接口" class="headerlink" title="多个类型可以实现相同的接口"></a><span style="color:#00ACC1;">多个类型可以实现相同的接口</span></h2><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p>
<p>Service接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用GameService结构体来实现Service，GameService自己的结构只能实现Start()方法，而Service接口中的Log()方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行GameService封装，或者重新实现一遍。所以，选择将Logger嵌入到GameService能最大程度地避免代码冗余，简化代码结构。详细实现过程如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个服务需要满足能够开启和写日志的功能</span></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start()     <span class="comment">// 开启服务</span></span><br><span class="line">    Log(<span class="keyword">string</span>) <span class="comment">// 日志输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志器</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Service的Log()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(g *Logger)</span> <span class="title">Log</span><span class="params">(l <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏服务</span></span><br><span class="line"><span class="keyword">type</span> GameService <span class="keyword">struct</span> &#123;</span><br><span class="line">    Logger <span class="comment">// 嵌入日志器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Service的Start()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *GameService)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2行，定义服务接口，一个服务需要实现Start()方法和日志方法。</li>
<li>第8行，定义能输出日志的日志器结构。</li>
<li>第12行，为Logger添加Log()方法，同时实现Service的Log()方法。</li>
<li>第17行，定义GameService结构。</li>
<li>第18行，在GameService中嵌入Logger日志器，以实现日志功能。</li>
<li>第22行，GameService的Start()方法实现了Service的Start()方法。</li>
</ul>
<p>此时，实例化GameService，并将实例赋给Service，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s Service = <span class="built_in">new</span>(GameService)</span><br><span class="line">s.Start()</span><br><span class="line">s.Log(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></p>
<p>s就可以使用Start()方法和Log()方法，其中，Start()由GameService实现，Log()方法由Logger实现。</p>
<h1 id="示例：便于扩展输出方式的日志系统"><a href="#示例：便于扩展输出方式的日志系统" class="headerlink" title="示例：便于扩展输出方式的日志系统"></a><span style="color:#339AFF;">示例：便于扩展输出方式的日志系统</span></h1><p>日志可以用于查看和分析应用程序的运行状态。日志一般可以支持输出多种形式，如命令行、文件、网络等。</p>
<p>本例将搭建一个支持多种写入器的日志系统，可以自由扩展多种日志写入设备。</p>
<p><strong>1，日志对外接口</strong></p>
<p>本例中定义一个日志写入器接口（LogWriter），要求写入设备必须遵守这个接口协议才能被日志器（Logger）注册。日志器有一个写入器的注册方法（Logger的RegisterWriter()方法）.</p>
<p>日志器还有一个Log()方法，进行日志的输出，这个函数会将日志写入到所有已经注册的日志写入器（LogWriter）中，详细代码实现请参考代码7-2的logger文件。</p>
<blockquote>
<p>代码7-2 日志写入器（具体文件：…/chapter07/logger/logger.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明日志写入器接口</span></span><br><span class="line"><span class="keyword">type</span> LogWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(data <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志器</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个日志器用到的日志写入器</span></span><br><span class="line">    writerList []LogWriter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册一个日志写入器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">RegisterWriter</span><span class="params">(writer LogWriter)</span></span> &#123;</span><br><span class="line">    l.writerList = <span class="built_in">append</span>(l.writerList, writer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个data类型的数据写入到日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">Log</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有注册的写入器</span></span><br><span class="line">    <span class="keyword">for</span> _, writer := <span class="keyword">range</span> l.writerList &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将日志输出到每一个写入器</span></span><br><span class="line">        writer.Write(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建日志器的实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">()</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Logger&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，声明日志写入器接口。这个接口可以被外部使用。日志的输出可以有多种设备，这个写入器就是用来实现一个日志的输出设备。</li>
<li>第9行，声明日志器结构。日志器使用writeList记录输出到哪些设备上。</li>
<li>第15行，使用日志器方法RegisterWriter()将一个日志写入器（LogWriter）注册到日志器（Logger）中。注册的意思就是将日志写入器的接口添加到writeList中。</li>
<li>第20行，日志器的Log()方法可以将interface{}类型的data写入到注册过的日志写入器中。</li>
<li>第23行，遍历日志器拥有的所有日志写入器。</li>
<li>第26行，将本次日志的内容写入日志写入器。</li>
<li>第31行，创建日志器的实例。</li>
</ul>
<p>这个例子中，为了最大程度地展示接口的用法，仅仅只是将数据直接写入日志写入器中。复杂一些的日志器还可以将日期、级别等信息合并到数据中一并写入日志。</p>
<p><strong>2，文件写入器</strong></p>
<p>文件写入器（fileWriter）是众多日志写入器（LogWriter）中的一种。文件写入器的功能是根据一个文件名创建日志文件（fileWriter的SetFile方法）。在有日志写入时，将日志写入文件中。</p>
<blockquote>
<p>代码7-2 文件写入器（具体文件：…/chapter07/logger/file.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件写入器</span></span><br><span class="line"><span class="keyword">type</span> fileWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    file *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件写入器写入的文件名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileWriter)</span> <span class="title">SetFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件已经打开，关闭前一个文件</span></span><br><span class="line">    <span class="keyword">if</span> f.file != <span class="literal">nil</span> &#123;</span><br><span class="line">        f.file.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个文件并保存文件句柄</span></span><br><span class="line">    f.file, err = os.Create(filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果创建的过程出现错误，则返回错误</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现LogWriter的Write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileWriter)</span> <span class="title">Write</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志文件可能没有创建成功</span></span><br><span class="line">    <span class="keyword">if</span> f.file == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 日志文件没有准备好</span></span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"file not created"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据序列化为字符串</span></span><br><span class="line">    str := fmt.Sprintf(<span class="string">"%v\n"</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据以字节数组写入到文件</span></span><br><span class="line">    _, err := f.file.Write([]<span class="keyword">byte</span>(str))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件写入器实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFileWriter</span><span class="params">()</span> *<span class="title">fileWriter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;fileWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，声明文件写入器，在结构体中保存一个文件句柄，以方便每次写入时操作。</li>
<li>第15行，文件写入器通过文件名创建文件，这里通过SetFile的参数提供一个文件名，并创建文件。</li>
<li>第18行，考虑到SetFile()方法可以被多次调用（函数可重入性），假设之前已经调用过SetFile()后再次调用，此时的f.file不为空，就需要关闭之前的文件，重新创建新的文件。</li>
<li>第23行，根据文件名创建文件，如果发生错误，通过SetFile的返回值返回。</li>
<li>第30行，fileWriter的Write()方法实现了LogWriter接口的Write()方法。</li>
<li>第33行，如果文件没有准备好，文件句柄为nil，此时使用errors包的New()函数返回一个错误对象，包含一个字符串“file not created”。</li>
<li>第40行，通过Write()方法传入的data参数是interface{}类型，而f.file的Write()方法需要的是[]byte类型。使用fmt.Sprintf将data转换为字符串，这里使用的格式化参数是“%v”，意思是将data按其本来的值转换为字符串。</li>
<li>第43行，通过f.file的Write()方法，将str字符串转换为[]byte字节数组，再写入到文件中。如果发生错误，则返回。</li>
</ul>
<p>在操作文件时，会出现文件无法创建、无法写入等错误。开发中尽量不要忽略这些底层报出的错误，应该处理可能发生的所有错误。</p>
<p>文件使用完后，要注意使用os.File的Close()方法进行及时关闭，否则文件再次访问时会因为其属性出现无法读取、无法写入等错误。</p>
<blockquote>
<p>提示：一个完备的文件写入器会提供多种写入文件的模式，例子中使用的模式是将日志添加到日志文件的尾部。随着文件越来越大，文件的访问效率和查看便利性也会大大降低。此时，就需要另外一种写入模式：滚动写入文件。<br><br>滚动写入文件模式也是将日志添加到文件的尾部，但当文件达到设定的期望大小时，会自动开启一个新的文件继续写入文件，最终将获得多个日志文件。<br><br>日志文件名不仅可以按照文件大小进行分割，还可以按照日期范围进行分割。在到达设定的日期范围，如每天、每小时的周期范围时，日志器会自动创建新的日志文件。这种日志文件创建方法也能方便开发者按日志查看日志。</p>
</blockquote>
<p><strong>3，命令行写入器</strong></p>
<p>在UNIX的思想中，一切皆文件。文件包括内存、磁盘、网络和命令行等。这种抽象方法方便我们访问这些看不见摸不着的虚拟资源。命令行在Go中也是一种文件，os.Stdout对应标准输出，一般表示屏幕，也就是命令行，也可以被重定向为打印机或者磁盘文件；os.Stderr对应标准错误输出，一般将错误输出到日志中，不过大多数情况，os.Stdout会与os.Stderr合并输出；os.Stdin对应标准输入，一般表示键盘。os.Stdout、os.Stderr、os.Stdin都是*os.File类型，和文件一样实现了io.Writer接口的Write()方法。下面的代码展示如何将命令行抽象为日志写入器，如代码7-2中的console.go文件所示。</p>
<blockquote>
<p>代码7-2 命令行写入器（具体文件：…/chapter07/logger/console.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行写入器</span></span><br><span class="line"><span class="keyword">type</span> consoleWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现LogWriter的Write</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *consoleWriter)</span> <span class="title">Write</span><span class="params">(data <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据序列化为字符串</span></span><br><span class="line">    str := fmt.Sprintf(<span class="string">"%v\n"</span>, data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据以字节数组写入到命令行</span></span><br><span class="line">    _, err := os.Stdout.Write([]<span class="keyword">byte</span>(str))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建命令行写入器实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newConsoleWriter</span><span class="params">()</span> *<span class="title">consoleWriter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;consoleWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，声明consoleWriter结构，以实现命令行写入器。</li>
<li>第13行，consoleWriter的Write()方法实现了日志写入接口（LogWriter）的Write()方法。</li>
<li>第16行，与fileWriter类似，这里也将data通过fmt.Sprintf序列化为字符串。</li>
<li>第19行，与fileWriter类似，这里也将str字符串转换为字节数组并写入标准输出os.Stdout。写入后的内容就会显示在命令行中。</li>
<li>第25行，创建命令行写入器的实例。</li>
</ul>
<p>除了命令行写入器（consoleWriter）和文件写入器（fileWriter），读者还可以自行使用net包中的Socket封装实现网络写入器socketWriter，让日志可以写入远程的服务器中或者可以跨进程进行日志保存和分析。</p>
<p><strong>4，使用日志</strong></p>
<p>在程序中使用日志器一般会先通过代码创建日志器（Logger），为日志器添加输出设备（fileWriter、consoleWriter等）。这些设备中有一部分需要一些参数设定，如文件日志写入器需要提供文件名（fileWriter的SetFile()方法）。</p>
<p>下面代码中展示了使用日志器的过程，请参考代码7-2中的main.go文件。</p>
<blockquote>
<p>代码7-2 使用日志（具体文件：…/chapter07/logger/main.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建日志器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createLogger</span><span class="params">()</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建日志器</span></span><br><span class="line">    l := NewLogger()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建命令行写入器</span></span><br><span class="line">    cw := newConsoleWriter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册命令行写入器到日志器</span></span><br><span class="line">    l.RegisterWriter(cw)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件写入器</span></span><br><span class="line">    fw := newFileWriter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件名</span></span><br><span class="line">    <span class="keyword">if</span> err := fw.SetFile(<span class="string">"log.log"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册文件写入器到日志器</span></span><br><span class="line">    l.RegisterWriter(fw)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备日志器</span></span><br><span class="line">    l := createLogger()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个日志</span></span><br><span class="line">    l.Log(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6行，一个创建日志的过程。这个过程一般隐藏在系统初始化中。程序启动时初始化一次。</li>
<li>第9行，创建一个日志器的实例，后面的代码会使用到它。</li>
<li>第12行，创建一个命令行写入器。如果全局有很多日志器，命令行写入器可以被共享，全局只会有一份。</li>
<li>第18行，创建一个文件写入器。一个程序的日志一般只有一个，因此不同的日志器也应该共享一个文件写入器。</li>
<li>第21行，创建好的文件写入器需要初始化写入的文件，通过文件名确定写入的文件。设置的过程可能会发生错误，发生错误时会输出错误信息。</li>
<li>第26行，将文件写入器注册到日志器中。</li>
<li>第34行，在程序一开始创建日志器。</li>
<li>第37行，往创建好的日志器中写入日志。</li>
</ul>
<p>编译整个代码并运行，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>同时，当前目录的log.log文件中也会出现hello字符。</p>
<blockquote>
<p>提示：Go语言的log包实现了一个小型的日志系统。这个日志系统可以在创建日志器时选择输出设备、日志前级及flag，函数定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="keyword">string</span>, flag <span class="keyword">int</span>)</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Logger&#123;out: out, prefix: prefix, flag: flag&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在flag中，还可以定制日志中是否输出日期、日期精度和详细文件名等。<br><br>这个日志器在编写时，也最大程度地保证了输出的效率，如果读者对日志器的编写比较感兴趣，可以在l0g包的基础上进行扩展，形成方便自己使用的日志库。</p>
</blockquote>
<h1 id="示例：使用接口进行数据的排序"><a href="#示例：使用接口进行数据的排序" class="headerlink" title="示例：使用接口进行数据的排序"></a><span style="color:#339AFF;">示例：使用接口进行数据的排序</span></h1><p>排序是常见的算法之一，也是常见的面试题之一，程序员对各种排序算法也是津津乐道。实际使用中，语言的类库会为我们提供健壮、高性能的排序算法库，开发者在了解排序算法基本原理的基础上，应该避免“造轮子”，直接使用已有的排序算法库，以缩短开发周期，提高开发效率。</p>
<p>Go语言中在排序时，需要使用者通过<code>sort.Interface</code>接口提供数据的一些特性和操作方法。接口定义代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 获取元素数量</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小于比较</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换元素</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第3行，排序算法需要实现者提供需要排序的数据元素数量。</li>
<li>第6行，排序需要通过比较元素之间的关系才能做出具体的操作。Less()方法需要提供两个给定索引（i和j）对应元素的小于比较（数值的&lt;操作）的结果。参数的i、j传入的是元素的索引。将传入的i、j索引对应的元素按小于关系进行比较，完成后把结果通过Less()方法的返回值返回。</li>
<li>第9行，排序的过程就是不停地交换元素。Swap()方法需要实现者通过传入i、j索引找到元素，并交换元素的值。</li>
</ul>
<p>这个接口需要实现者实现的方法就是排序的经典操作：数量（Len）、比较（Less）、交换（Swap）。</p>
<h2 id="使用sort-Interface接口进行排序"><a href="#使用sort-Interface接口进行排序" class="headerlink" title="使用sort.Interface接口进行排序"></a><span style="color:#00ACC1;">使用sort.Interface接口进行排序</span></h2><p>对一系列字符串进行排序时，使用字符串切片（[]string）承载多个字符串。使用type关键字，将字符串切片（[]string）定义为自定义类型MyStringList。为了让sort包能识别MyStringList，能够对MyStringList进行排序，就必须让MyStringList实现sort.Interface接口。详细代码实现，请参考代码7-3。</p>
<blockquote>
<p>代码7-3 字符串排序（具体文件：…/chapter07/sortstring/sortstring.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将[]string定义为MyStringList类型</span></span><br><span class="line"><span class="keyword">type</span> MyStringList []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口的获取元素数量方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStringList)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口的比较元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStringList)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m[i] &lt; m[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口的交换元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyStringList)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    m[i], m[j] = m[j], m[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备一个内容被打乱顺序的字符串切片</span></span><br><span class="line">    names := MyStringList&#123;</span><br><span class="line">        <span class="string">"3. Triple Kill"</span>,</span><br><span class="line">        <span class="string">"5. Penta Kill"</span>,</span><br><span class="line">        <span class="string">"2. Double Kill"</span>,</span><br><span class="line">        <span class="string">"4. Quadra Kill"</span>,</span><br><span class="line">        <span class="string">"1. First Blood"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用sort包进行排序</span></span><br><span class="line">    sort.Sort(names)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历打印结果</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> names &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，接口实现不受限于结构体，任何类型都可以实现接口。要排序的字符串切片[]string是系统定制好的类型，无法让这个类型去实现sort.Interface排序接口。因此，需要将[]string定义为自定义的类型。</li>
<li>第12行，实现获取元素数量的Len()方法，返回字符串切片的元素数量。</li>
<li>第17行，实现比较元素的Less()方法，直接取m切片的i和j元素值进行小于比较，并返回比较结果。</li>
<li>第22行，实现交换元素的Swap()方法，这里使用Go语言的多变量赋值特性实现元素交换。</li>
<li>第29行，由于将[]string定义成MyStringList类型，字符串切片初始化的过程等效于下面的写法：</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"3. Triple Kill"</span>,</span><br><span class="line">    <span class="string">"5. Penta Kill"</span>,</span><br><span class="line">    <span class="string">"2. Double Kill"</span>,</span><br><span class="line">    <span class="string">"4. Quadra Kill"</span>,</span><br><span class="line">    <span class="string">"1. First Blood"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第38行，使用sort包的Sort()函数，将names（MyStringList类型）进行排序。排序时，sort包会通过MyStringList实现的Len()、Less()、Swap()这3个方法进行数据获取和修改。</li>
<li>第41行，遍历排序好的字符串切片，并打印结果。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. First Blood</span><br><span class="line">2. Double Kill</span><br><span class="line">3. Triple Kill</span><br><span class="line">4. Quadra Kill</span><br><span class="line">5. Penta Kill</span><br></pre></td></tr></table></figure></p>
<h2 id="常见类型的便捷排序"><a href="#常见类型的便捷排序" class="headerlink" title="常见类型的便捷排序"></a><span style="color:#00ACC1;">常见类型的便捷排序</span></h2><p>通过实现sort.Interface接口的排序过程具有很强的可定制性，可以根据被排序对象比较复杂的特性进行定制。例如，需要多种排序逻辑的需求就适合使用sort.Interface接口进行排序。但大部分情况中，只需要对字符串、整型等进行快速排序。Go语言中提供了一些固定模式的封装以方便开发者迅速对内容进行排序。</p>
<p><strong>1，字符串切片的便捷排序</strong></p>
<p>sort包中有一个StringSlice类型，定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Less</span> <span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p[i] &lt; p[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Swap</span> <span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p[i], p[j] = p[j], p[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort is a convenience method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Sort(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sort包中的StringSlice的代码与MyStringList的实现代码几乎一样。因此，只需要使用sort包的StringSlice就可以更简单快速地进行字符串排序。将代码7-3中的排序代码简化后如下所示。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">names := sort.StringSlice&#123;</span><br><span class="line">    <span class="string">"3. Triple Kill"</span>,</span><br><span class="line">    <span class="string">"5. Penta Kill"</span>,</span><br><span class="line">    <span class="string">"2. Double Kill"</span>,</span><br><span class="line">    <span class="string">"4. Quadra Kill"</span>,</span><br><span class="line">    <span class="string">"1. First Blood"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Sort(names)</span><br></pre></td></tr></table></figure></p>
<p>简化后，只要两句代码就实现了字符串排序的功能。</p>
<p><strong>2，对整型切片进行排序</strong></p>
<p>除了字符串可以使用sort包进行便捷排序外，还可以使用sort.IntSlice进行整型切片的排序。sort.IntSlice的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p[i] &lt; p[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Swap</span><span class="params">(i,j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    p[i], p[j] = p[j], p[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort is a convenience method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Sort(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sort包在sort.Interface对各类型的封装上还有更进一步的简化，下面使用sort.Strings继续对代码7-3进行简化，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"3. Triple Kill"</span>,</span><br><span class="line">    <span class="string">"5. Penta Kill"</span>,</span><br><span class="line">    <span class="string">"2. Double Kill"</span>,</span><br><span class="line">    <span class="string">"4. Quadra Kill"</span>,</span><br><span class="line">    <span class="string">"1. First Blood"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Strings(names)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> names &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行，需要排序的字符串切片。</li>
<li>第9行，使用sort.Strings直接对字符串切片进行排序。</li>
</ul>
<p><strong>3，sort包内建的类型排序接口一览</strong></p>
<p>Go语言中的sort包中定义了一些常见类型的排序方法，如表7-1所示。</p>
<blockquote>
<p>表7-1 sort包中内建的类型排序接</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/t-1.jpg">
<p>编程中经常用到的int32、int64、float32、bool类型并没有由sort包实现，使用时依然需要开发者自己编写。</p>
<h2 id="对结构体数据进行排序"><a href="#对结构体数据进行排序" class="headerlink" title="对结构体数据进行排序"></a><span style="color:#00ACC1;">对结构体数据进行排序</span></h2><p>除了基本类型的排序，也可以对结构体进行排序。结构体比基本类型更为复杂，排序时不能像数值和字符串一样拥有一些固定的单一原则。结构体的多个字段在排序中可能会存在多种排序的规则，例如，结构体中的名字按字母升序排列，数值按从小到大的顺序排序。一般在多种规则同时存在时，需要确定规则的优先度，如先按名字排序，再按年龄排序等。</p>
<p><strong>1，完整实现sort.Interface进行结构体排序</strong></p>
<p>将一批英雄名单使用结构体定义，英雄名单的结构体中定义了英雄的名字和分类。排序时要求按照英雄的分类进行排序，相同分类的情况下按名字进行排序，详细代码实现过程参考代码7-4。</p>
<blockquote>
<p>代码7-4 结构体排序（具体文件：…/chapter07/sortstruct/sortstruct.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明英雄种类类型</span></span><br><span class="line"><span class="keyword">type</span> HeroKind <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroKind常量，类似于枚举</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    None HeroKind = <span class="literal">iota</span></span><br><span class="line">    Tank</span><br><span class="line">    Assassin</span><br><span class="line">    Mage</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义英雄结构的结构</span></span><br><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span>   <span class="comment">// 英雄的名字</span></span><br><span class="line">    Kind HeroKind <span class="comment">// 英雄的种类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将英雄指针的切片定义为Heros类型</span></span><br><span class="line"><span class="keyword">type</span> Heros []*Hero</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口取元素数量方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Heros)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口比较元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Heros)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s[i].Kind != s[j].Kind &#123;</span><br><span class="line">        <span class="keyword">return</span> s[i].Kind &lt; s[j].Kind</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[i].Name &lt; s[j].Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现sort.Interface接口交换元素方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Heros)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备英雄列表</span></span><br><span class="line">    heros := Heros&#123;</span><br><span class="line">        &amp;Hero&#123;<span class="string">"吕布"</span>, Tank&#125;,</span><br><span class="line">        &amp;Hero&#123;<span class="string">"李白"</span>, Assassin&#125;,</span><br><span class="line">        &amp;Hero&#123;<span class="string">"妲己"</span>, Mage&#125;,</span><br><span class="line">        &amp;Hero&#123;<span class="string">"貂蝉"</span>, Assassin&#125;,</span><br><span class="line">        &amp;Hero&#123;<span class="string">"关羽"</span>, Tank&#125;,</span><br><span class="line">        &amp;Hero&#123;<span class="string">"诸葛亮"</span>, Mage&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用sort包进行排序</span></span><br><span class="line">    sort.Sort(heros)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历英雄列表打印排序结果</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> heros &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%+v\n"</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，将int声明为HeroKind英雄类型，后面会将这个类型当做枚举来使用。</li>
<li>第13行，定义一些英雄类型常量，可以理解为枚举的值。</li>
<li>第26行，为了方便实现sort.Interface接口，将[]*Hero定义为Heros类型。</li>
<li>第29行，Heros类型实现了sort.Interface的Len()方法，返回英雄的数量。</li>
<li>第34行，Heros类型实现了sort.Interface的Less()方法，根据英雄字段的比较结果决定如何排序。</li>
<li>第37行，当英雄的分类不一致时，优先按分类的枚举数值从小到大排序。</li>
<li>第42行，英雄分类相等的情况下，默认根据英雄的名字字符升序排序。</li>
<li>第46行， Heros类型实现了sort.Interface的Swap()方法，交换英雄元素的位置。</li>
<li>第53～60行，准备一系列英雄数据。</li>
<li>第63行，使用sort包进行排序。</li>
<li>第66行，遍历所有排序完成的英雄数据。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;&#123;Name:关羽 Kind:1&#125;</span><br><span class="line">&amp;&#123;Name:吕布 Kind:1&#125;</span><br><span class="line">&amp;&#123;Name:李白 Kind:2&#125;</span><br><span class="line">&amp;&#123;Name:貂蝉 Kind:2&#125;</span><br><span class="line">&amp;&#123;Name:妲己 Kind:3&#125;</span><br><span class="line">&amp;&#123;Name:诸葛亮 Kind:3&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2，使用sort.Slice进行切片元素排序</strong></p>
<p>从Go 1.8开始，Go语言在sort包中提供了sort.Slice0）函数进行更为简便的排序方法。sort.Slice()函数只要求传入需要排序的数据，以及一个排序时对元素的回调函数，类型为func（ij int） bool，sort.Slice()函数的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice</span> （<span class="title">slice</span> <span class="title">interface</span>（&#125;， <span class="title">less</span> <span class="title">func</span>（<span class="title">i</span>， <span class="title">j</span> <span class="title">int</span>） <span class="title">bool</span>）</span></span><br></pre></td></tr></table></figure></p>
<p>使用sort.Slice()函数，对代码7-4重新优化的完整代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">package</span> main</span><br></pre></td></tr></table></figure></p>
<p>第33行到第39行加粗部分是新添加的sort.Slice0）及回调函数部分。对比前面的代码，这里去掉了Heros及接口实现部分的代码。</p>
<p>使用sort.Slice()不仅可以完成结构体切片排序，还可以对各种切片类型进行自定义排序。</p>
<h1 id="接口的嵌套组合——将多个接口放在一个接口内"><a href="#接口的嵌套组合——将多个接口放在一个接口内" class="headerlink" title="接口的嵌套组合——将多个接口放在一个接口内"></a><span style="color:#339AFF;">接口的嵌套组合——将多个接口放在一个接口内</span></h1><p>在Go语言中，不仅结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。</p>
<p>接口与接口嵌套组合而成了新接口，只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用。</p>
<p><strong>1，系统包中的接口嵌套组合</strong></p>
<p>Go语言的io包中定义了写入器（Writer）、关闭器（Closer）和写入关闭器（WriteCloser）3个接口，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer</span><br><span class="line">    Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行定义了写入器（Writer），这个接口较为常用，常用于IO设备的数据写入。</li>
<li>第5行定义了关闭器（Closer），如有非托管内存资源的对象，需要用关闭的方法来实现资源释放。</li>
<li>第9行定义了写入关闭器（WriteCloser），这个接口由Writer和Closer两个接口嵌入。也就是说，WriteCloser同时拥有了Writer和Closer的特性。</li>
</ul>
<p><strong>2，在代码中使用接口嵌套组合</strong></p>
<p>在代码中使用io.Writer、io.Closer和io.WriteCloser这3个接口时，只需要按照接口实现的规则实现io.Writer接口和io.Closer接口即可。而io.WriteCloser接口在使用时，编译器会根据接口的实现者确认它们是否同时实现了io.Writer和io.Closer接口，详细实现代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个设备结构</span></span><br><span class="line"><span class="keyword">type</span> device <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现io.Writer的Write()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现io.Closer的Close()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *device)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明写入关闭器，并赋予device的实例</span></span><br><span class="line">    <span class="keyword">var</span> wc io.WriteCloser = <span class="built_in">new</span>(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    wc.Write(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭设备</span></span><br><span class="line">    wc.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明写入器，并赋予device的新实例</span></span><br><span class="line">    <span class="keyword">var</span> writeOnly io.Writer = <span class="built_in">new</span>(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    writeOnly.Write(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行定义了device结构体，用来模拟一个虚拟设备，这个结构会实现前面提到的3种接口。</li>
<li>第12行，实现了io.Writer的Write()方法。</li>
<li>第17行，实现了io.Closer的Close()方法。</li>
<li>第24行，对device实例化，由于device实现了io.WriteCloser的所有嵌入接口，因此device指针就会被隐式转换为io.WriteCloser接口。</li>
<li>第27行，调用了wc（io.WriteCloser接口）的Write()方法，由于wc被赋值*device，因此最终会调用device的Write()方法。</li>
<li>第30行，与27行类似，最终调用device的Close()方法。</li>
<li>第33行，再次创建一个device的实例，writeOnly是一个io.Writer接口，这个接口只有Write()方法。</li>
<li>第36行，writeOnly只能调用Write()方法，没有Close()方法。</li>
</ul>
<p>为了整理思路，将上面的实现、调用关系使用图方式来展现，参见图7-3和图7-4。</p>
<p>（1）io.WriteCloser的实现及调用过程如图7-3所示。</p>
<blockquote>
<p>图7-3 io.WriteCloser的实现及调用过程</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/3.jpg">
<p>（2）io.Writer的实现调用过程如图7-4所示。</p>
<blockquote>
<p>图7-4 io.Writer的实现调用过程</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/4.jpg">
<p>给io.WriteCloser或io.Writer更换不同的实现者，可以动态地切换实现代码。</p>
<h1 id="在接口和类型间转换"><a href="#在接口和类型间转换" class="headerlink" title="在接口和类型间转换"></a><span style="color:#339AFF;">在接口和类型间转换</span></h1><p>Go语言中使用类型断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁。</p>
<h2 id="类型断言的格式"><a href="#类型断言的格式" class="headerlink" title="类型断言的格式"></a><span style="color:#00ACC1;">类型断言的格式</span></h2><p>类型断言的基本格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>i代表接口变量。</li>
<li>T代表转换的目标类型。</li>
<li>t代表转换后的变量。</li>
</ul>
<p>如果i没有完全实现T接口的方法，这个语句将会触发宕机。触发宕机不是很友好，因此上面的语句还有一种写法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure></p>
<p>这种写法下，如果发生接口未实现时，将会把ok置为false，t置为T类型的0值。正常实现时，ok为true。这里ok可以被认为是：i接口是否实现T类型的结果。</p>
<h2 id="将接口转换为其他接口"><a href="#将接口转换为其他接口" class="headerlink" title="将接口转换为其他接口"></a><span style="color:#00ACC1;">将接口转换为其他接口</span></h2><p>实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。</p>
<p>鸟和猪具有不同的特性，鸟可以飞，猪不能飞，但两种动物都可以行走。如果使用结构体实现鸟和猪，让它们具备自己特性的Fly()和Walk()方法就让鸟和猪各自实现了飞行动物接口（Flyer）和行走动物接口（Walker）。</p>
<p>将鸟和猪的实例创建后，被保存到<code>interface{}</code>类型的map中。<code>interface{}</code>类型表示空接口，意思就是这种接口可以保存为任意类型。对保存有鸟或猪的实例的<code>interface{}</code>变量进行断言操作，如果断言对象是断言指定的类型，则返回转换为断言对象类型的接口；如果不是指定的断言类型时，断言的第二个参数将返回false，例如下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj <span class="keyword">interface</span> = <span class="built_in">new</span>(bird)</span><br><span class="line">f, isFlyer := obj.(Flyer)</span><br></pre></td></tr></table></figure></p>
<p>代码中，<code>new(bird)</code>产生*bird类型的bird实例，这个实例被保存在<code>interface{}</code>类型的obj变量中。使用<code>obj.(Flyer)</code>类型断言，将obj转换为Flyer接口。f为转换成功时的Flyer接口类型，isFlyer表示是否转换成功，类型就是bool。详细代码请参考代码7-5。</p>
<blockquote>
<p>代码7-5 鸟和猪（具体文件：…/chapter07/birdpig/birdpig.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Flyer 飞行物接口</span></span><br><span class="line"><span class="keyword">type</span> Flyer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Walker 行走物接口</span></span><br><span class="line"><span class="keyword">type</span> Walker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸟类</span></span><br><span class="line"><span class="keyword">type</span> bird <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fly 实现飞行接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bird)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"bird: fly"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk 实现行走接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bird)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"bird: walk"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猪</span></span><br><span class="line"><span class="keyword">type</span> pig <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Walk 实现行走接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pig)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"pig: walk"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动物的名字到实例的映射</span></span><br><span class="line">    animals := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">"bird"</span>: <span class="built_in">new</span>(bird),</span><br><span class="line">        <span class="string">"pig"</span>:  <span class="built_in">new</span>(pig),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历映射</span></span><br><span class="line">    <span class="keyword">for</span> name, obj := <span class="keyword">range</span> animals &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言对象是否为飞行物</span></span><br><span class="line">        f, isFlyer := obj.(Flyer)</span><br><span class="line">        <span class="comment">// 断言对象是否为行走物</span></span><br><span class="line">        w, isWalker := obj.(Walker)</span><br><span class="line"></span><br><span class="line">        fmt.Printf(<span class="string">"name: %s isFlyer: %v isWalker: %v\n"</span>, name, isFlyer, isWalker)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 飞行物调用飞行接口</span></span><br><span class="line">        <span class="keyword">if</span> isFlyer &#123;</span><br><span class="line">            f.Fly()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 行走物调用行走接口</span></span><br><span class="line">        <span class="keyword">if</span> isWalker &#123;</span><br><span class="line">            w.Walk()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6行定义了飞行动物的接口。</li>
<li>第11行定义了行走动物的接口。</li>
<li>第16和30行分别定义了鸟和猪两个对象，并分别实现了飞行动物和行走动物接口。</li>
<li>第41行是一个map，映射对象名字和对象实例，实例是鸟和猪。</li>
<li>第47行开始遍历map，obj为<code>interface{}</code>接口类型。</li>
<li>第50行中，使用类型断言获得f，类型为Flyer及isFlyer的断言成功的判定。</li>
<li>第52行中，使用类型断言获得w，类型为Walker及isWalker的断言成功的判定。</li>
<li>第57和62行，根据飞行动物和行走动物两者是否断言成功，调用其接口。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name: bird isFlyer: true isWalker: true</span><br><span class="line">bird: fly</span><br><span class="line">bird: walk</span><br><span class="line">name: pig isFlyer: false isWalker: true</span><br><span class="line">pig: walk</span><br></pre></td></tr></table></figure></p>
<h2 id="将接口转换为其他类型"><a href="#将接口转换为其他类型" class="headerlink" title="将接口转换为其他类型"></a><span style="color:#00ACC1;">将接口转换为其他类型</span></h2><p>在代码7-5中，可以实现将接口转换为普通的指针类型。例如将Walker接口转换为*pig类型，请参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(pig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Walker = p1</span><br><span class="line">p2 := a.(*pig)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"p1=%p p2=%p"</span>, p1, p2)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第3行，由于pig实现了Walker接口，因此可以被隐式转换为Walker接口类型保存于a中。</li>
<li>第4行，由于a中保存的本来就是*pig本体，因此可以转换为*pig类型。</li>
<li>第6行，对比发现，p1和p2指针是相同的。</li>
</ul>
<p>如果尝试将上面这段代码中的Walker类型的a转换为*bird类型，将会发出运行时错误，请参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(pig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a Walker = p1</span><br><span class="line">p2 := a.(*bird)</span><br></pre></td></tr></table></figure></p>
<p>运行时报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: main.Walker is *main.pig, not *main.bird</span><br></pre></td></tr></table></figure></p>
<p>报错意思是：接口转换时，<code>main.Walker</code>接口的内部保存的是*main.pig，而不是*main.bird。</p>
<p>因此，接口在转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p>
<blockquote>
<p>总结：接口和其他类型的转换可以在Go语言中自由进行，前提是已经完全实现。<br><br>接口断言类似于流程控制中的if，但大量类型断言出现时，应使用更为高效的类型分支switch特性。</p>
</blockquote>
<h1 id="空接口类型（interface-）——能保存所有值的类型"><a href="#空接口类型（interface-）——能保存所有值的类型" class="headerlink" title="空接口类型（interface{}）——能保存所有值的类型"></a><span style="color:#339AFF;">空接口类型（interface{}）——能保存所有值的类型</span></h1><p>空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。</p>
<blockquote>
<p>提示：空接口类型类似于C#或Java语言中的Object、C语言中的void*、C++中的std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。空接口的内部实现保存了对象的类型和指针。使用空接口保存一个数据的过程会比直接用数据对应类型的变量保存稍慢。因此在开发中，应在需要的地方使用空接口，而不是在所有地方使用空接口。</p>
</blockquote>
<h2 id="将值保存到空接口"><a href="#将值保存到空接口" class="headerlink" title="将值保存到空接口"></a><span style="color:#00ACC1;">将值保存到空接口</span></h2><p>空接口的赋值如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> any <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">any = <span class="number">1</span></span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = <span class="string">"hello"</span></span><br><span class="line">fmt.Println(any)</span><br><span class="line"></span><br><span class="line">any = <span class="literal">false</span></span><br><span class="line">fmt.Println(any)</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">hello</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第1行，声明any为<code>interface{}</code>类型的变量。</li>
<li>第3行，为any赋值一个整型1。</li>
<li>第4行，打印any的值，提供给<code>fmt.Println</code>的类型依然是<code>interface{}</code>。</li>
<li>第6行，为any赋值一个字符串hello。此时any内部保存了一个字符串。但类型依然是<code>interface{}</code>。</li>
<li>第9行，赋值布尔值。</li>
</ul>
<h2 id="从接口获取值"><a href="#从接口获取值" class="headerlink" title="从接口获取值"></a><span style="color:#00ACC1;">从接口获取值</span></h2><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明a变量，类型int，初始值为1</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明i变量，类型为interface&#123;&#125;，初始值为a，此时i的值变为1</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明b变量，尝试赋值i</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = i</span><br></pre></td></tr></table></figure></p>
<p>第8行代码编译报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot use i (type interface &#123;&#125;) as type int in assignment: need type assertion</span><br></pre></td></tr></table></figure></p>
<p>编译器告诉我们，不能将i变量视为int类型赋值给b。</p>
<p>在代码第5行中，将a的值赋值给i时，虽然i在赋值完成后的内部值为int，但i还是一个<code>interface{}</code>类型的变量。类似于无论集装箱装的是茶叶还是烟草，集装箱依然是金属做的，不会因为所装物的类型改变而改变。</p>
<p>为了让第8行的操作能够完成，编译器提示我们得使用type assertion，意思就是类型断言。</p>
<p>使用类型断言修改第8行代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = i.(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<p>修改后，代码可以编译通过，并且b可以获得i变量保存的a变量的值：1。</p>
<h2 id="空接口的值比较"><a href="#空接口的值比较" class="headerlink" title="空接口的值比较"></a><span style="color:#00ACC1;">空接口的值比较</span></h2><p>空接口在保存不同的值后，可以和其他变量值一样使用“==”进行比较操作。空接口的比较有以下几种特性。</p>
<p><strong>1、类型不同的空接口间的比较结果不相同</strong></p>
<p>保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a保存整型</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125; = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b保存字符串</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">interface</span>&#123;&#125; = <span class="string">"hi"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个空接口不相等</span></span><br><span class="line">fmt.Println(a == b)</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure></p>
<p><strong>2，不能比较空接口中的动态值</strong></p>
<p>当接口中保存有动态类型的值时，运行时将触发错误，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">interface</span>&#123;&#125; = []<span class="keyword">int</span>&#123;<span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(c == d)</span><br></pre></td></tr></table></figure></p>
<p>代码运行到第8行时发生崩溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: comparing uncomparable type []int</span><br></pre></td></tr></table></figure></p>
<p>这是一个运行时错误，提示<code>[]int</code>是不可比较的类型。表7-2中列举出了类型及比较的几种情况。</p>
<blockquote>
<p>表7-2 类型的可比较性</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/t-2.jpg">
<h1 id="示例：使用空接口实现可以保存任意值的字典"><a href="#示例：使用空接口实现可以保存任意值的字典" class="headerlink" title="示例：使用空接口实现可以保存任意值的字典"></a><span style="color:#339AFF;">示例：使用空接口实现可以保存任意值的字典</span></h1><p>空接口可以保存任何类型这个特性可以方便地用于容器的设计。下面例子使用map和interface{}实现了一个字典。字典在其他语言中的功能和map类似，可以将任意类型的值做成键值对保存，然后进行找回、遍历操作。详细实现过程请参考代码7-6。</p>
<blockquote>
<p>代码7-6 实现字典（具体文件：…/chapter07/dict/dict.go）</p>
</blockquote>
<p><strong>1，值设置和获取</strong></p>
<p>字典内部拥有一个data字段，其类型为map。这个map的键和值都是interface{}类型，也就是实现任意类型关联任意类型。字典的值设置和获取通过Set()和Get()两个方法来完成，参数都是interface{}。详细实现代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典结构</span></span><br><span class="line"><span class="keyword">type</span> Dictionary <span class="keyword">struct</span> &#123;</span><br><span class="line">    data <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 键值都为interface&#123;&#125;类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据键获取值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dictionary)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> d.data[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dictionary)</span> <span class="title">Set</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    d.data[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第3行，Dictionary的内部实现是一个键值均为interface{}类型的map，map也具备与Dictionary一致的功能。</li>
<li>第8行，通过map直接获取值，如果键不存在，将返回nil。</li>
<li>第13行，通过map设置键值。</li>
</ul>
<p><strong>2，遍历字段的所有键值关联数据</strong></p>
<p>每个容器都有遍历操作。遍历时，需要提供一个回调返回需要遍历的数据。为了方便在必要时终止遍历操作，可以将回调的返回值设置为bool类型，外部逻辑在回调中不需要遍历时直接返回false即可终止遍历。</p>
<p>Dictionary的Visit()方法需要传入回调函数，回调函数的类型为func(k, v interface{})bool。每次遍历时获得的键值关联数据通过回调函数的k和v参数返回。Visit的详细实现请参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的键值，如果回调返回值为false，停止遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dictionary)</span> <span class="title">Visit</span><span class="params">(callback <span class="keyword">func</span>(k, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> callback == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> d.data &#123;</span><br><span class="line">        <span class="keyword">if</span> !callback(k, v) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下</p>
<ul>
<li>第2行，定义回调，类型为func(k, v interface{})bool，意思是返回键值数据(k, v)。bool表示遍历流程控制，返回true时继续遍历，返回false时终止遍历。</li>
<li>第4行，当callback为空时，退出遍历，避免后续代码访问空的callback而导致的崩溃。</li>
<li>第8行，遍历字典结构的data成员，也就是遍历map的所有元素。</li>
<li>第9行，根据callback的返回值，决定是否继续遍历。</li>
</ul>
<p><strong>3，初始化和清除</strong></p>
<p>字典结构包含有map，需要在创建Dictionary实例时初始化map。这个过程通过Dictionary的Clear()方法完成。在NewDictionary中调用Clear()方法避免了map初始化过程的代码重复问题。请参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空所有的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dictionary)</span> <span class="title">Clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d.data = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个字典</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDictionary</span><span class="params">()</span> *<span class="title">Dictionary</span></span> &#123;</span><br><span class="line">    d := &amp;Dictionary&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化map</span></span><br><span class="line">    d.Clear()</span><br><span class="line">    <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第3行，map没有独立的复位内部元素的操作，需要复位元素时，使用make创建新的实例。Go语言的垃圾回收是并行的，不用担心map清除的效率问题。</li>
<li>第7行，实例化一个Dictionary。</li>
<li>第11行，在初始化时调用Clear进行map初始化操作。</li>
</ul>
<p><strong>4，使用字典</strong></p>
<p>字典实现完成后，需要经过一个测试过程，查看这个字典是否存在问题。</p>
<p>将一些字符串和数值组合放入到字典中，然后再从字典中根据键查询出对应的值，接着再遍历一个字典中所有的元素。详细实现过程请参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建字典实例</span></span><br><span class="line">    dict := NewDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加游戏数据</span></span><br><span class="line">    dict.Set(<span class="string">"My Factory"</span>, <span class="number">60</span>)</span><br><span class="line">    dict.Set(<span class="string">"Terra Craft"</span>, <span class="number">36</span>)</span><br><span class="line">    dict.Set(<span class="string">"Don't Hungry"</span>, <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取值及打印值</span></span><br><span class="line">    favorite := dict.Get(<span class="string">"Terra Craft"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"favorite:"</span>, favorite)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的字典元素</span></span><br><span class="line">    dict.Visit(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将值转为int类型，并判断是否大于40</span></span><br><span class="line">        <span class="keyword">if</span> value.(<span class="keyword">int</span>) &gt; <span class="number">40</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输出很贵</span></span><br><span class="line">            fmt.Println(key, <span class="string">"is expensive"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认都是输出很便宜</span></span><br><span class="line">        fmt.Println(key, <span class="string">"is cheap"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第4行创建字典的实例。</li>
<li>第7～9行，将3组键值对通过字典的Set()方法设置到字典中。</li>
<li>第12行，根据字符串键查找值，将结果保存在favorite中。</li>
<li>第13行，打印favorite的值。</li>
<li>第16行，遍历字典的所有键值对。遍历的返回数据通过回调提供，key是键，value是值。</li>
<li>第19行，遍历返回的key和value的类型都是interface，这里确认value只有int类型，所以将value转换为int类型判断是否大于40。</li>
<li>第23和29行，继续遍历，返回true。</li>
<li>第23行，打印键。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favorite: 36</span><br><span class="line">My Factory is expensive</span><br><span class="line">Terra Craft is cheap</span><br><span class="line">Don&apos;t Hungry is cheap</span><br></pre></td></tr></table></figure></p>
<h1 id="类型分支——批量判断空接口中变量的类型"><a href="#类型分支——批量判断空接口中变量的类型" class="headerlink" title="类型分支——批量判断空接口中变量的类型"></a><span style="color:#339AFF;">类型分支——批量判断空接口中变量的类型</span></h1><p>Go语言的switch不仅可以像其他语言一样实现数值、字符串的判断，还有一种特殊的用途——判断一个接口内保存或实现的类型。</p>
<h2 id="类型断言的书写格式"><a href="#类型断言的书写格式" class="headerlink" title="类型断言的书写格式"></a><span style="color:#00ACC1;">类型断言的书写格式</span></h2><p>switch实现类型分支时的写法格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> 接口变量.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 变量是类型1时的处理</span></span><br><span class="line">    <span class="keyword">case</span> 类型<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 变量是类型2时的处理</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 变量不是所有case中列举的类型时的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>接口变量：表示需要判断的接口类型的变量。</li>
<li>类型1、类型2……：表示接口变量可能具有的类型列表，满足时，会指定case对应的分支进行处理。</li>
</ul>
<h2 id="使用类型分支判断基本类型"><a href="#使用类型分支判断基本类型" class="headerlink" title="使用类型分支判断基本类型"></a><span style="color:#00ACC1;">使用类型分支判断基本类型</span></h2><p>下面的例子将一个interface{}类型的参数传给printType()函数，通过switch判断v的类型，然后打印对应类型的提示，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">        fmt.Println(v, <span class="string">"is int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">        fmt.Println(v, <span class="string">"is string"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">        fmt.Println(v, <span class="string">"is bool"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    printType(<span class="number">1024</span>)</span><br><span class="line">    printType(<span class="string">"pig"</span>)</span><br><span class="line">    printType(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1024 is int</span><br><span class="line">pig is string</span><br><span class="line">true is bool</span><br></pre></td></tr></table></figure></p>
<p>代码第9行中，<code>v.(type)</code>就是类型分支的典型写法。通过这个写法，在switch的每个case中写的将是各种类型分支。</p>
<p>代码经过switch时，会判断v这个interface{}的具体类型从而进行类型分支跳转。</p>
<p>switch的default也是可以使用的，功能和其他的switch一致。</p>
<h2 id="使用类型分支判断接口类型"><a href="#使用类型分支判断接口类型" class="headerlink" title="使用类型分支判断接口类型"></a><span style="color:#00ACC1;">使用类型分支判断接口类型</span></h2><p>多个接口进行类型断言时，可以使用类型分支简化判断过程。</p>
<p>现在电子支付逐渐成为人们普遍使用的支付方式，电子支付相比现金支付具备很多优点。例如，电子支付能够刷脸支付，而现金支付容易被偷等。使用类型分支可以方便地判断一种支付方法具备哪些特性，详细代码请参考代码7-7。</p>
<blockquote>
<p>代码7-7 电子支付和现金支付（具体文件：…/chapter07/cashpay/cashandalipay.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电子支付方式</span></span><br><span class="line"><span class="keyword">type</span> Alipay <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Alipay添加CanUseFaceID方法，表示电子支付方式支持刷脸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Alipay)</span> <span class="title">CanUseFaceID</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现金支付方式</span></span><br><span class="line"><span class="keyword">type</span> Cash <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Cash添加Stolen方法，表示现金支付方式会出现偷窃情况</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Cash)</span> <span class="title">Stolen</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CantainCanUseFaceID <span class="keyword">interface</span> &#123;</span><br><span class="line">    CanUseFaceID()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ContainStolen <span class="keyword">interface</span> &#123;</span><br><span class="line">    Stolen()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印支付方式具备的特点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(payMethod <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> payMethod.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> CantainCanUseFaceID: <span class="comment">// 可以刷脸</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T can use faceid\n"</span>, payMethod)</span><br><span class="line">    <span class="keyword">case</span> ContainStolen: <span class="comment">// 可能被偷</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T may be stolen\n"</span>, payMethod)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用电子支付判断</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">new</span>(Alipay))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用现金判断</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">new</span>(Cash))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第6～19行，分别定义Alipay和Cash结构，并为它们添加具备各自特点的方法。</li>
<li>第22～29行，定义两种特性，即刷脸和被偷。</li>
<li>第32行，传入支付方式的口。</li>
<li>第33行，使用类型分支进行支付方法的特性判断。</li>
<li>第34-37行，分别对刷脸和被偷的特性进行打印。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*main.Alipay can use faceid</span><br><span class="line">*main.Cash may be stolen</span><br></pre></td></tr></table></figure></p>
<h1 id="示例：实现有限状态机（FSM）"><a href="#示例：实现有限状态机（FSM）" class="headerlink" title="示例：实现有限状态机（FSM）"></a><span style="color:#339AFF;">示例：实现有限状态机（FSM）</span></h1><p>有限状态机（Finite-State Machine，FSM），表示有限个状态及在这些状态间的转移和动作等行为的数学模型。</p>
<p>本例将实现状态接口、状态管理器及一系列的状态和使用状态的逻辑。</p>
<p><strong>1，状态的概念</strong></p>
<p>状态机中的状态与状态间能够自由转换。但是现实当中的状态却不一定能够自由转换，例如：人可以从站立状态转移到卧倒状态，却不能从卧倒状态直接转移到跑步状态，需要先经过站立状态后再转移到跑步状态。</p>
<p>每个状态可以设置它可以转移到的状态。一些状态机还允许在同一个状态间互相转换，这也需要根据实际情况进行配置。</p>
<p><strong>2，自定义状态需要实现的接口</strong></p>
<p>有限状态机系统需要制定一个状态需具备的属性和功能，由于状态需要由用户自定义，为了统一管理状态，就需要使用接口定义状态。状态机从状态接口查询到用户的自定义状态应该具备的属性有：</p>
<ul>
<li>名称，对应State接口的Name()方法。</li>
<li>状态是否允许在同状态间转移，对应State接口的EnableSameTransit()方法。</li>
<li>能否从当前状态转移到指定的某一个状态，对应State接口的CanTransitTo()方法。</li>
</ul>
<p>除此之外，状态在转移时会发生的事件可以由状态机通过状态接口的方法通知用户自己的状态，对应的是两个方法OnBegin()和OnEnd()，分别代表状态转移前和状态转移后。详细的状态定义过程，请参考代码7-8的state.go文件。</p>
<blockquote>
<p>代码7-8 状态接口（具体文件：…/chapter07/fsm/state.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态接口</span></span><br><span class="line"><span class="keyword">type</span> State <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态名字</span></span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该状态是否允许同状态转移</span></span><br><span class="line">    EnableSameTransit() <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应状态开始时</span></span><br><span class="line">    OnBegin()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应状态结束时</span></span><br><span class="line">    OnEnd()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断能否转移到某状态</span></span><br><span class="line">    CanTransitTo(name <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从状态实例获取状态名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StateName</span><span class="params">(s State)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"none"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射获取状态的名称</span></span><br><span class="line">    <span class="keyword">return</span> reflect.TypeOf(s).Elem().Name()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第8行，声明状态接口。此接口用于状态管理器内部保存和外部实现。</li>
<li>第14行，需要实现是否允许本状态间的互相转换。</li>
<li>第17和20行，需要实现状态的事件，分别是“状态开始”和“状态结束”。当一个状态转移到另外一个状态时，当前状态的OnEnd()方法会被调用，而目标状态的OnBegin()方法也将被调用。</li>
<li>第23行，需要实现本状态能否转移到指定的状态。</li>
<li>第27行，通过给定的状态接口查找状态的名称。</li>
</ul>
<p><strong>3，状态基本信息</strong></p>
<p>State接口中定义的方法，在用户自定义时都是重复的，为了避免重复地编写很多代码，使用StateInfo来协助用户实现一些默认的实现。</p>
<p>StateInfo包含有名称，在状态初始化时被赋值。StateInfo同时实现了OnBegin()、OnEnd()方法。此外，StateInfo的EnableSameTransit()方法还能判断是否允许状态在同类状态中转移，CanTransiTo()方法能判断是否能转移到某个目标状态，详细实现请参考代码7-8的info.go文件。</p>
<blockquote>
<p>代码7-8 状态信息（具体文件：…/chapter07/fsm/info.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态的基础信息和默认实现</span></span><br><span class="line"><span class="keyword">type</span> StateInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 状态名</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateInfo)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供给内部设置名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateInfo)</span> <span class="title">setName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许同状态转移</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateInfo)</span> <span class="title">EnableSameTransit</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认将状态开启时实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateInfo)</span> <span class="title">OnBegin</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认将状态结束时实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateInfo)</span> <span class="title">OnEnd</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认可以转移到任何状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateInfo)</span> <span class="title">CanTransitTo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，声明一个StateInfo的结构体，拥有名称的成员。</li>
<li>第15行，setName()方法的首字母小写，表示这个方法只能在同包内被调用。这里我们希望setName()不能被使用者在状态初始化后随意修改名称，而是通过后面提到的状态管理器自动赋值。</li>
<li>第25和30行，对State接口的OnBegin()和OnEnd()方法进行默认实现。</li>
</ul>
<p><strong>4，状态管理</strong></p>
<p>状态管理器管理和维护状态的生命期。用户根据需要，将需要进行状态转移和控制的状态实现后添加（StateManager的Add()方法）到状态管理器里，状态管理器使用名称对这些状态进行维护，同一个状态只允许一个实例存在。状态管理器可以通过回调函数（StateManager的OnChange成员）提供状态转移的通知。状态管理器对状态的管理和维护代码请参考代码7-8的statemgr.go文件。</p>
<blockquote>
<p>代码7-8 状态管理器（具体文件：…/chapter07/fsm/statemgr.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态没有找到的错误</span></span><br><span class="line"><span class="keyword">var</span> ErrStateNotFound = errors.New(<span class="string">"state not found"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止在同状态间转移</span></span><br><span class="line"><span class="keyword">var</span> ErrForbidSameStateTransit = errors.New(<span class="string">"forbid same state transit"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能转移到指定状态</span></span><br><span class="line"><span class="keyword">var</span> ErrCannotTransitToState = errors.New(<span class="string">"cannot transit to state"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态管理器</span></span><br><span class="line"><span class="keyword">type</span> StateManager <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经添加的状态</span></span><br><span class="line">    stateByName <span class="keyword">map</span>[<span class="keyword">string</span>]State</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态改变时的回调</span></span><br><span class="line">    OnChange <span class="function"><span class="keyword">func</span><span class="params">(from, to State)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // 当前状态</span></span><br><span class="line"><span class="function">    <span class="title">curr</span> <span class="title">State</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 添加一个状态到管理器</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(sm *StateManager)</span> <span class="title">Add</span><span class="params">(s State)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态的名称</span></span><br><span class="line">    name := StateName(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将s转换为能设置名字的接口，然后调用接口</span></span><br><span class="line">    s.(<span class="keyword">interface</span> &#123;</span><br><span class="line">        setName(name <span class="keyword">string</span>)</span><br><span class="line">    &#125;).setName(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据状态名取已经添加的状态，检查是否已经存在</span></span><br><span class="line">    <span class="keyword">if</span> sm.Get(name) != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"duplicate state:"</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名字保存到map中</span></span><br><span class="line">    sm.stateByName[name] = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据名字获取指定状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *StateManager)</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">State</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v, ok := sm.stateByName[name]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *StateManager)</span> <span class="title">CurrState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sm.curr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前状态能否转移到目标状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *StateManager)</span> <span class="title">CanCurrTransitTo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.curr == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相同的不用转换</span></span><br><span class="line">    <span class="keyword">if</span> sm.curr.Name() == name &amp;&amp; !sm.curr.EnableSameTransit() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用当前状态，检查能否转移到指定名字的状态</span></span><br><span class="line">    <span class="keyword">return</span> sm.curr.CanTransitTo(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移到指定状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *StateManager)</span> <span class="title">Transit</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标状态</span></span><br><span class="line">    next := sm.Get(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标不存在</span></span><br><span class="line">    <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrStateNotFound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录转移前的状态</span></span><br><span class="line">    pre := sm.curr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前有状态</span></span><br><span class="line">    <span class="keyword">if</span> sm.curr != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相同的状态不用转换</span></span><br><span class="line">        <span class="keyword">if</span> sm.curr.Name() == name &amp;&amp; !sm.curr.EnableSameTransit() &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrForbidSameStateTransit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能转移到目标状态</span></span><br><span class="line">        <span class="keyword">if</span> !sm.curr.CanTransitTo(name) &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrCannotTransitToState</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束当前状态</span></span><br><span class="line">        sm.curr.OnEnd()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前状态切换为要转移到的目标状态</span></span><br><span class="line">    sm.curr = next</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用新状态的开始</span></span><br><span class="line">    sm.curr.OnBegin()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知回调</span></span><br><span class="line">    <span class="keyword">if</span> sm.OnChange != <span class="literal">nil</span> &#123;</span><br><span class="line">        sm.OnChange(pre, sm.curr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化状态管理器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStateManager</span><span class="params">()</span> *<span class="title">StateManager</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;StateManager&#123;</span><br><span class="line">        stateByName: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]State),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，声明一个以状态名为键，以State接口为值的map。</li>
<li>第12行，状态改变时，状态管理器的成员OnChange()函数回调会被调用。</li>
<li>第15行，记忆当前状态，当状态改变时，当前状态会变化。</li>
<li>第22行，添加状态时，无须提供名称，状态管理器内部会根据State的实例和反射查询出状态的名称。</li>
<li>第25行，将s(State接口)通过类型断言转换为带有setName()方法(name string)的接口。接着调用这个接口的setName()方法设置状态的名称。使用该方法可以快速调用一个接口实现的其他方法。</li>
<li>第30行，根据状态名，在已经添加的状态中检查是否有重名的状态。</li>
<li>第39行，根据名称查找状态实例。</li>
<li>第49行，构造一个状态管理器</li>
</ul>
<p><strong>5，在状态间转移</strong></p>
<p>状态管理器不仅管理状态的实例，还可以控制当前的状态及转移到新的状态。状态管理器从当前状态转移到给定名称的状态过程中，如果发现状态不存在、目标状态不能转移及同类状态不能转移时，将返回error错误对象，这些错误以Er开头，在包（package）里提前定义好。本例一共涉及3种错误，分别是：</p>
<ul>
<li>状态没有找到的错误，对应ErrStateNotFound。</li>
<li>禁止在同状态间转移的错误，对应ErrForbidSameStateTransit。</li>
<li>不能转移到指定状态的错误，对应ErrCannotTransitToState。</li>
</ul>
<p>状态转移时，还会调用状态管理器的OnChange()函数进行外部通知。状态管理器的状态转移实现请参考代码7-8的statemgr.go文件</p>
<blockquote>
<p>代码7-8 状态管理器（具体文件：…/chapter07/fsm/statemgr.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态没有找到的错误</span></span><br><span class="line"><span class="keyword">var</span> ErrStateNotFound = errors.New(<span class="string">"state not found"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止在同状态间转移</span></span><br><span class="line"><span class="keyword">var</span> ErrForbidSameStateTransit = errors.New(<span class="string">"forbid same state transit"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能转移到指定状态</span></span><br><span class="line"><span class="keyword">var</span> ErrCannotTransitToState = errors.New(<span class="string">"cannot transit to state"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *StateManager)</span> <span class="title">CurrState</span><span class="params">()</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sm.curr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前状态能否转移到目标状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *StateManager)</span> <span class="title">CanCurrTransitTo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sm.curr == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相同的不用转换</span></span><br><span class="line">    <span class="keyword">if</span> sm.curr.Name() == name &amp;&amp; !sm.curr.EnableSameTransit() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用当前状态，检查能否转移到指定名字的状态</span></span><br><span class="line">    <span class="keyword">return</span> sm.curr.CanTransitTo(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移到指定状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sm *StateManager)</span> <span class="title">Transit</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标状态</span></span><br><span class="line">    next := sm.Get(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标不存在</span></span><br><span class="line">    <span class="keyword">if</span> next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrStateNotFound</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录转移前的状态</span></span><br><span class="line">    pre := sm.curr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前有状态</span></span><br><span class="line">    <span class="keyword">if</span> sm.curr != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相同的状态不用转换</span></span><br><span class="line">        <span class="keyword">if</span> sm.curr.Name() == name &amp;&amp; !sm.curr.EnableSameTransit() &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrForbidSameStateTransit</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不能转移到目标状态</span></span><br><span class="line">        <span class="keyword">if</span> !sm.curr.CanTransitTo(name) &#123;</span><br><span class="line">            <span class="keyword">return</span> ErrCannotTransitToState</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结束当前状态</span></span><br><span class="line">        sm.curr.OnEnd()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前状态切换为要转移到的目标状态</span></span><br><span class="line">    sm.curr = next</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用新状态的开始</span></span><br><span class="line">    sm.curr.OnBegin()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知回调</span></span><br><span class="line">    <span class="keyword">if</span> sm.OnChange != <span class="literal">nil</span> &#123;</span><br><span class="line">        sm.OnChange(pre, sm.curr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2～5行，分别预定义状态转移可能发生的错误。</li>
<li>第16行，检查当前状态能否转移到指定名称的状态。</li>
<li>第32行，转移到指定状态。</li>
<li>第43行，记录转移前的状态，方便在后面代码中通过函数通知外部。</li>
<li>第46行，状态管理器初始时，当前状态为nil，因此无法结束当前状态，只能开始新的状态。</li>
<li>第49行，对相同状态的情况进行检查，不能转移时，告知具体错误。</li>
<li>第54行，对不能转移的状态，返回具体的错误。</li>
<li>第59行，必须要结束当前状态，才能开始新的状态。</li>
</ul>
<p><strong>6，自定义状态实现状态接口</strong></p>
<p>状态的定义和状态管理器的功能已经编写完成，接下来就开始解决具体问题。在解决问题前需要知道有哪些问题：</p>
<p>（1）有哪些状态需要用户自定义及实现？</p>
<p>在使用状态机时，首先需要定义一些状态，并按照State状态接口进行实现，以方便自定义的状态能够被状态管理器管理和转移。</p>
<p>本代码定义3个状态：闲置（Idle）、移动（Move）、跳跃（Jump）。</p>
<p>（2）这些状态的关系是怎样的？</p>
<p>这3个状态间的关系可以通过图7-5来描述。</p>
<blockquote>
<p>图7-5 3个状态间的转移关系</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/5.jpg">
<p>3个状态可以自由转移，但移动（Move）状态只能单向转移到跳跃（Jump）状态。Move状态可以自我转换，也就是同类状态转移。</p>
<p>状态的转移关系还可以使用表格来描述，如表7-3所示。</p>
<blockquote>
<p>表7-3使用表格表示状态转移关系</p>
</blockquote>
<img src="/2021/08/19/第7章-接口（interface）/t-3.jpg">
<p>（3）如何组织这些状态间的转移？</p>
<p>定义3种状态的结构体并内嵌StateInfo结构以实现State接口中的默认接口。再根据每个状态各自不同的特点，返回状态的转移特点（EnableSameTransit()及CanTransitTo()方法等）及重新实现OnBegin()和OnEnd()方法的事件回调。详细代码实现，请参考代码7-8的main.go文件。</p>
<blockquote>
<p>代码7-8 一系列状态实现（具体文件：…/chapter07/fsm/main.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闲置状态</span></span><br><span class="line"><span class="keyword">type</span> IdleState <span class="keyword">struct</span> &#123;</span><br><span class="line">    StateInfo <span class="comment">// 使用StateInfo实现基础接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新实现状态开始</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *IdleState)</span> <span class="title">OnBegin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"IdleState begin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新实现状态结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *IdleState)</span> <span class="title">OnEnd</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"IdleState end"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动状态</span></span><br><span class="line"><span class="keyword">type</span> MoveState <span class="keyword">struct</span> &#123;</span><br><span class="line">    StateInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MoveState)</span> <span class="title">OnBegin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"MoveState begin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许移动状态互相转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MoveState)</span> <span class="title">EnableSameTransit</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃状态</span></span><br><span class="line"><span class="keyword">type</span> JumpState <span class="keyword">struct</span> &#123;</span><br><span class="line">    StateInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *JumpState)</span> <span class="title">OnBegin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"JumpState begin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃状态不能转移到移动状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *JumpState)</span> <span class="title">CanTransitTo</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="string">"MoveState"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>7，使用状态机</strong></p>
<p>3种自定义状态定义完成后，需要将所有代码整合起来。将自定义状态添加到状态管理器（StateManager）中，同时在状态改变（StateManager的OnChange成员）时，打印状态转移的详细日志。</p>
<p>在状态转移时，获得转移时可能发生的错误，并且打印错误，详细代码实现请参考代码7-8的main.go文件。</p>
<blockquote>
<p>代码7-8 一系列状态实现（具体文件：…/chapter07/fsm/main.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个状态管理器</span></span><br><span class="line">    sm := NewStateManager()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应状态转移的通知</span></span><br><span class="line">    sm.OnChange = <span class="function"><span class="keyword">func</span><span class="params">(from, to State)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印状态转移的流向</span></span><br><span class="line">        fmt.Printf(<span class="string">"%s ---&gt; %s\n\n"</span>, StateName(from), StateName(to))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加3个状态</span></span><br><span class="line">    sm.Add(<span class="built_in">new</span>(IdleState))</span><br><span class="line">    sm.Add(<span class="built_in">new</span>(MoveState))</span><br><span class="line">    sm.Add(<span class="built_in">new</span>(JumpState))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在不同状态间转移</span></span><br><span class="line">    transitAndReport(sm, <span class="string">"IdleState"</span>)</span><br><span class="line"></span><br><span class="line">    transitAndReport(sm, <span class="string">"MoveState"</span>)</span><br><span class="line"></span><br><span class="line">    transitAndReport(sm, <span class="string">"MoveState"</span>)</span><br><span class="line"></span><br><span class="line">    transitAndReport(sm, <span class="string">"JumpState"</span>)</span><br><span class="line"></span><br><span class="line">    transitAndReport(sm, <span class="string">"JumpState"</span>)</span><br><span class="line"></span><br><span class="line">    transitAndReport(sm, <span class="string">"IdleState"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装转移状态和输出日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transitAndReport</span><span class="params">(sm *StateManager, target <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := sm.Transit(target); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"FAILED! %s --&gt; %s, %s\n\n"</span>, sm.CurrState().Name(), target, err.Error())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，创建状态管理器实例。</li>
<li>第12行，使用匿名函数响应状态转移的通知。</li>
<li>第19～21行，实例化3个状态并且添加到管理器。</li>
<li>第24行，调用transitAndReport()函数，在各种状态间转移。</li>
<li>第38行，封装状态转移的过程，并且打印可能发生的错误。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IdleState begin</span><br><span class="line">none ---&gt; Idlestate IdleState end</span><br><span class="line"></span><br><span class="line">MoveState begin</span><br><span class="line">IdleState ---&gt; MoveState</span><br><span class="line"></span><br><span class="line">MoveState begin</span><br><span class="line">MoveState ---&gt; MoveState</span><br><span class="line"></span><br><span class="line">JumpState begin</span><br><span class="line">MoveState ---&gt; JumpState</span><br><span class="line"></span><br><span class="line">FAILED! JumpState --&gt; JumpState, forbid same state </span><br><span class="line">transit </span><br><span class="line"></span><br><span class="line">IdleState begin</span><br><span class="line">JumpState ---&gt; IdleState</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言从入门到进阶实战/" rel="tag"># Go语言从入门到进阶实战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/19/第6章-结构体（struct）/" rel="next" title="第6章 结构体（struct）">
                <i class="fa fa-chevron-left"></i> 第6章 结构体（struct）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/19/第8章-包（package）/" rel="prev" title="第8章 包（package）">
                第8章 包（package） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1017</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">72</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/04/04/结束语｜秒杀系统之上的业务协同思考/" title="结束语｜秒杀系统之上的业务协同思考" target="_blank">结束语｜秒杀系统之上的业务协同思考</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/14｜百万级流量秒杀系统的关键总结/" title="14｜百万级流量秒杀系统的关键总结" target="_blank">14｜百万级流量秒杀系统的关键总结</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/13｜优化番外篇：Vertx介绍及快速入门/" title="13｜优化番外篇：Vertx介绍及快速入门" target="_blank">13｜优化番外篇：Vertx介绍及快速入门</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/12｜高性能优化：单机Java极致优化/" title="12｜高性能优化：单机Java极致优化" target="_blank">12｜高性能优化：单机Java极致优化</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/11｜高性能优化：物理机极致优化/" title="11｜高性能优化：物理机极致优化" target="_blank">11｜高性能优化：物理机极致优化</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#声明接口"><span class="nav-number">1.</span> <span class="nav-text">声明接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口声明的格式"><span class="nav-number">1.1.</span> <span class="nav-text">接口声明的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发中常见的接口及写法"><span class="nav-number">1.2.</span> <span class="nav-text">开发中常见的接口及写法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现接口的条件"><span class="nav-number">2.</span> <span class="nav-text">实现接口的条件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接口被实现的条件一：接口的方法与实现接口的类型方法格式一致"><span class="nav-number">2.1.</span> <span class="nav-text">接口被实现的条件一：接口的方法与实现接口的类型方法格式一致</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件二：接口中所有方法均被实现"><span class="nav-number">2.2.</span> <span class="nav-text">条件二：接口中所有方法均被实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理解类型与接口的关系"><span class="nav-number">3.</span> <span class="nav-text">理解类型与接口的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个类型可以实现多个接口"><span class="nav-number">3.1.</span> <span class="nav-text">一个类型可以实现多个接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多个类型可以实现相同的接口"><span class="nav-number">3.2.</span> <span class="nav-text">多个类型可以实现相同的接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：便于扩展输出方式的日志系统"><span class="nav-number">4.</span> <span class="nav-text">示例：便于扩展输出方式的日志系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：使用接口进行数据的排序"><span class="nav-number">5.</span> <span class="nav-text">示例：使用接口进行数据的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用sort-Interface接口进行排序"><span class="nav-number">5.1.</span> <span class="nav-text">使用sort.Interface接口进行排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见类型的便捷排序"><span class="nav-number">5.2.</span> <span class="nav-text">常见类型的便捷排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对结构体数据进行排序"><span class="nav-number">5.3.</span> <span class="nav-text">对结构体数据进行排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#接口的嵌套组合——将多个接口放在一个接口内"><span class="nav-number">6.</span> <span class="nav-text">接口的嵌套组合——将多个接口放在一个接口内</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在接口和类型间转换"><span class="nav-number">7.</span> <span class="nav-text">在接口和类型间转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类型断言的格式"><span class="nav-number">7.1.</span> <span class="nav-text">类型断言的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将接口转换为其他接口"><span class="nav-number">7.2.</span> <span class="nav-text">将接口转换为其他接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将接口转换为其他类型"><span class="nav-number">7.3.</span> <span class="nav-text">将接口转换为其他类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#空接口类型（interface-）——能保存所有值的类型"><span class="nav-number">8.</span> <span class="nav-text">空接口类型（interface{}）——能保存所有值的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#将值保存到空接口"><span class="nav-number">8.1.</span> <span class="nav-text">将值保存到空接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从接口获取值"><span class="nav-number">8.2.</span> <span class="nav-text">从接口获取值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#空接口的值比较"><span class="nav-number">8.3.</span> <span class="nav-text">空接口的值比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：使用空接口实现可以保存任意值的字典"><span class="nav-number">9.</span> <span class="nav-text">示例：使用空接口实现可以保存任意值的字典</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型分支——批量判断空接口中变量的类型"><span class="nav-number">10.</span> <span class="nav-text">类型分支——批量判断空接口中变量的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类型断言的书写格式"><span class="nav-number">10.1.</span> <span class="nav-text">类型断言的书写格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用类型分支判断基本类型"><span class="nav-number">10.2.</span> <span class="nav-text">使用类型分支判断基本类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用类型分支判断接口类型"><span class="nav-number">10.3.</span> <span class="nav-text">使用类型分支判断接口类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：实现有限状态机（FSM）"><span class="nav-number">11.</span> <span class="nav-text">示例：实现有限状态机（FSM）</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.2m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">124:48</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
