<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Go语言从入门到进阶实战">
<meta property="og:type" content="article">
<meta property="og:title" content="第5章 函数（function）">
<meta property="og:url" content="http://yoursite.com/2021/08/19/第5章-函数（function）/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第5章-函数（function）/1.jpg">
<meta property="og:updated_time" content="2022-04-26T01:13:36.646Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第5章 函数（function）">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://yoursite.com/2021/08/19/第5章-函数（function）/1.jpg">






  <link rel="canonical" href="http://yoursite.com/2021/08/19/第5章-函数（function）/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第5章 函数（function） | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/19/第5章-函数（function）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第5章 函数（function）

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-19 09:13:19" itemprop="dateCreated datePublished" datetime="2021-08-19T09:13:19+08:00">2021-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-04-26 09:13:36" itemprop="dateModified" datetime="2022-04-26T09:13:36+08:00">2022-04-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">33k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">30 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>函数是组织好的、可重复使用的、用来实现单一或相关联功能的代码段，其可以提高应用的模块性和代码的重复利用率。</p>
<p>Go语言支持普通函数、匿名函数和闭包，从设计上对函数进行了优化和改进，让函数使用起来更加方便。</p>
<p>Go语言的函数属于“一等公民”（first-class），也就是说：</p>
<ul>
<li>函数本身可以作为值进行传递。</li>
<li>支持匿名函数和闭包（closure）。</li>
<li>函数可以满足接口。</li>
</ul>
<h1 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a><span style="color:#339AFF;">声明函数</span></h1><p>普通函数需要先声明才能调用。一个函数的声明包括参数和函数名等，编译器通过声明才能了解函数应该怎样在调用代码和函数体之间传递参数和返回参数。</p>
<h2 id="普通函数的声明形式"><a href="#普通函数的声明形式" class="headerlink" title="普通函数的声明形式"></a><span style="color:#00ACC1;">普通函数的声明形式</span></h2><p>Go语言的函数声明以func标识，后面紧接着函数名、参数列表、返回参数列表及函数体，具体形式如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名 <span class="params">(参数列表)</span> <span class="params">(返回参数列表)</span></span> &#123;</span><br><span class="line">    函数体 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数名：由字母、数字、下划线组成。其中，函数名的第一个字母不能为数字。在同一个包内，函数名称不能重名。</li>
</ul>
<blockquote>
<p>提示：包（package）是Go源码的一种组织方式，一个包可以认为是一个文件夹，在第8章中将会详细讲解包的概念。</p>
</blockquote>
<ul>
<li>参数列表：一个参数由参数变量和参数类型组成，例如：</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>其中，参数列表中的变量作为函数的局部变量而存在。</p>
<ul>
<li>返回参数列表：可以是返回值类型列表，也可以是类似参数列表中变量名和类型名的组合。函数在声明有返回值时，必须在函数体中使用return语句提供返回值列表。</li>
<li>函数体：能够被重复调用的代码片段。</li>
</ul>
<h2 id="参数类型的简写"><a href="#参数类型的简写" class="headerlink" title="参数类型的简写"></a><span style="color:#00ACC1;">参数类型的简写</span></h2><p>在参数列表中，如有多个参数变量，则以逗号分隔；如果相邻变量是同类型，则可以将类型省略。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中，a和b的参数均为int类型，因此可以省略a的类型，在b后面有类型说明，这个类型也是a的类型。</p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a><span style="color:#00ACC1;">函数的返回值</span></h2><p>Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误。示例代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn, err := connectToNetwork()</span><br></pre></td></tr></table></figure></p>
<p>在这段代码中，connectToNetwork返回两个参数，conn表示连接对象，err返回错误。</p>
<blockquote>
<p>提示：</p>
<ul>
<li>C/C++语言中只支持一个返回值，在需要返回多个数值时，则需要使用结构体返回结果，或者在参数中使用指针变量，然后在函数内部修改外部传入的变量值，实现返回计算结果。C++语言中为了安全性，建议在参数返回数据时使用“引用”替代指针。</li>
<li>C#语言也没有多返回值特性。C#语言后期加入的ref和out关键字能够通过函数的调用参数获得函数体中修改的数据。</li>
<li>lua语言没有指针，但支持多返回值，在大块数据使用时方便很多。</li>
</ul>
</blockquote>
<p>Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。</p>
<p><strong>1，同一种类型返回值</strong></p>
<p>如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。</p>
<p>使用return语句返回时，值列表的顺序需要与函数声明的返回值类型一致。示例代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typedTwovalues</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>，<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, b := typedTwoValues()</span><br><span class="line">fmt.Println(a, b)</span><br></pre></td></tr></table></figure>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure></p>
<p>纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。</p>
<p><strong>2，带有变量名的返回值</strong></p>
<p>Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。</p>
<p>命名的返回值变量的默认值为类型的默认值，即数值为0，字符串为空字符串，布尔为false、指针为nil等。</p>
<p>下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为a和b，因此可以在函数体中直接对函数返回值进行赋值。在命名的返回值方式的函数体中，在函数结束前需要显式地使用return语句进行返回，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行，对两个整型返回值进行命名，分别为a和b。</li>
<li>第3行和第4行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。</li>
<li>第6行，当函数使用命名返回值时，可以在return中不填写返回值列表，如果填写也是可行的。下面代码的执行效果和上面代码的效果一样。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a, <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>提示：<br>同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedRetValues</span><span class="params">()</span> <span class="params">(a, b <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>编译报错提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed named and unnamed function parameters</span><br></pre></td></tr></table></figure></p>
<p>意思是：在函数参数中混合使用了命名和非命名参数。</p>
</blockquote>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><span style="color:#00ACC1;">调用函数</span></h2><p>函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行。调用前的函数局部变量都会被保存起来不会丢失；被调用的函数结束后，恢复到被调用函数的下一行继续执行代码，之前的局部变量也能继续访问。</p>
<p>函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。</p>
<p>Go语言的函数调用格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值变量列表 = 函数名(参数列表)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>函数名：需要调用的函数名。</li>
<li>参数列表：参数变量以逗号分隔，尾部无须以分号结尾。</li>
<li>返回值变量列表：多个返回值使用逗号分隔。</li>
</ul>
<p>例如，加法函数调用样式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result := add(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="示例：将“秒”解析为时间单位"><a href="#示例：将“秒”解析为时间单位" class="headerlink" title="示例：将“秒”解析为时间单位"></a><span style="color:#00ACC1;">示例：将“秒”解析为时间单位</span></h2><p>在本例中，使用一个数值表示时间中的“秒”值，然后使用resolveTime()函数将传入的秒数转换为天、小时和分钟等时间单位。</p>
<blockquote>
<p>代码5-1 将秒解析为时间单位（具体文件：…/chapter05/resolvetime/resolvetime.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 定义每分钟的秒数</span></span><br><span class="line">    SecondsPerMinute = <span class="number">60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义每小时的秒数</span></span><br><span class="line">    SecondsPerHour = SecondsPerMinute * <span class="number">60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义每天的秒数</span></span><br><span class="line">    SecondsPerDay = SecondsPerHour * <span class="number">24</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入的“秒”解析为三种时间单位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveTime</span><span class="params">(seconds <span class="keyword">int</span>)</span> <span class="params">(day <span class="keyword">int</span>, hour <span class="keyword">int</span>, minute <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    day = seconds / SecondsPerDay</span><br><span class="line">    hour = seconds / SecondsPerHour</span><br><span class="line">    minute = seconds / SecondsPerMinute</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将返回值作为打印参数</span></span><br><span class="line">    fmt.Println(resolveTime(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只获取消息和分钟</span></span><br><span class="line">    _, hour, minute := resolveTime(<span class="number">18000</span>)</span><br><span class="line">    fmt.Println(hour, minute)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只获取天</span></span><br><span class="line">    day, _, _ := resolveTime(<span class="number">90000</span>)</span><br><span class="line">    fmt.Println(day)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第7行，定义每分钟的秒数。</li>
<li>第10行，定义每小时的秒数，SecondsPerHour常量值会在编译期间计算出结果。</li>
<li>第13行，定义每天的秒数。</li>
<li>第17行，定义resolveTime()函数，根据输入的秒数，返回3个整型值，含义分别是秒数对应的天数、小时数和分钟数（取整）。</li>
<li>第29行中，给定1000秒，对应是16（16.6667取整）分钟的秒数。resolveTime()函数返回的3个变量会传递给fmt.Println()函数进行打印，因为fmt.Println()使用了可变参数，可以接收不定量的参数。</li>
<li>第32行，将resolveTime()函数中的3个返回值使用变量接收，但是第一个返回参数使用匿名函数接收，表示忽略这个变量。</li>
<li>第36行，忽略后两个返回值，只使用第一个返回值。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 16</span><br><span class="line">5 300</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<h2 id="示例：函数中的参数传递效果测试"><a href="#示例：函数中的参数传递效果测试" class="headerlink" title="示例：函数中的参数传递效果测试"></a><span style="color:#00ACC1;">示例：函数中的参数传递效果测试</span></h2><p>Go语言中传入和返回参数在调用和返回时都使用值传递，这里需要注意的是指针、切片和map等引用型对象指向的内容在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用。</p>
<p>下面通过一个例子来详细了解Go语言的参数值传递。</p>
<blockquote>
<p>代码5-2 参数值传递（具体文件：…/chapter05/passbyvalue/passbyvalue.go）</p>
</blockquote>
<p><strong>1，测试数据类型</strong></p>
<p>为了测试结构体、切片、指针及结构体中嵌套的结构体在值传递中会发生的情况，需要定义一些结构，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于测试值传递效果的结构体</span></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line">    complax []<span class="keyword">int</span> <span class="comment">// 测试切片在参数传递中的效果</span></span><br><span class="line"></span><br><span class="line">    instance InnerData <span class="comment">// 实例分配的innerData</span></span><br><span class="line"></span><br><span class="line">    ptr *InnerData <span class="comment">// 将ptr声明为InnerData的指针类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表各种结构体字段</span></span><br><span class="line"><span class="keyword">type</span> InnerData <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2行，将Data声明为结构体类型，结构体是拥有多个字段的复杂结构。</li>
<li>第3行，complax为整型切片类型，切片是一种动态类型，内部以指针存在。</li>
<li>第5行，instance成员以InnerData类型作为Data的成员。</li>
<li>第7行，将ptr声明为InnerData的指针类型。</li>
<li>第11行，声明一个内嵌的结构InnerData。</li>
</ul>
<p><strong>2，值传递的测试函数</strong></p>
<p>本节中定义的passByValue()函数用于值传递的测试，该函数的参数和返回值都是Data类型。在调用中，Data的内存会被复制后传入函数，当函数返回时，又会将返回值复制一次，赋给函数返回值的接收变量。代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">passByValue</span><span class="params">(inFunc Data)</span> <span class="title">Data</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出参数的成员情况</span></span><br><span class="line">    fmt.Printf(<span class="string">"inFunc value: %+v\n"</span>, inFunc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印inFunc的指针</span></span><br><span class="line">    fmt.Printf(<span class="string">"inFunc ptr: %p\n"</span>, &amp;inFunc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第5行，使用格式化的“%+v”动词输出in变量的详细结构，以便观察Data结构在传递前后的内部数值的变化情况。</li>
<li>第8行，打印传入参数inFunc的指针地址。在计算机中，拥有相同地址且类型相同的变量，表示的是同一块内存区域。</li>
<li>第10行，将传入的变量作为返回值返回，返回的过程将发生值复制。</li>
</ul>
<p><strong>3，测试流程</strong></p>
<p>测试流程会准备一个Data格式的数据结构并填充所有成员，这些成员类型包括切片、结构体成员及指针。通过调用测试函数，传入Data结构数据，并获得返回值，对比输入和输出后的Data结构数值变化，特别是指针变化情况以及输入和输出整块数据是否被复制，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备传入函数的结构</span></span><br><span class="line">in := Data&#123;</span><br><span class="line">    complax: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    instance: InnerData&#123;</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ptr: &amp;InnerData&#123;<span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入结构的成员情况</span></span><br><span class="line">fmt.Printf(<span class="string">"in value: %+v\n"</span>, in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入结构的指针地址</span></span><br><span class="line">fmt.Printf(<span class="string">"in ptr: %p\n"</span>, &amp;in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入结构体，返回同类型的结构体</span></span><br><span class="line">out := passByValue(in)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结构的成员情况</span></span><br><span class="line">fmt.Printf(<span class="string">"out value: %+v\n"</span>, out)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结构的指针地址</span></span><br><span class="line">fmt.Printf(<span class="string">"out ptr: %p\n"</span>, &amp;out)</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，创建一个Data结构的实例in。</li>
<li>第3行，将切片数据赋值到in的complax成员。</li>
<li>第4行，为in的instance成员赋值InnerData结构的数据。</li>
<li>第8行，为in的ptr成员赋值InnerData的指针类型数据。</li>
<li>第12行，打印输入结构的成员情况。</li>
<li>第15行，打印输入结构的指针地址。</li>
<li>第18行，传入in结构，调用passByValue()测试函数获得out返回，此时，passByValue函数会打印in传入后的数据成员情况。</li>
<li>第21行，打印返回值out变量的成员情况。</li>
<li>第24行，打印输出结构的地址。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in value: &#123;complax:[1 2 3] instance:&#123;a:5&#125; ptr:0xc0000b0008&#125;</span><br><span class="line">in ptr: 0xc000098180</span><br><span class="line">inFunc value: &#123;complax:[1 2 3] instance:&#123;a:5&#125; ptr:0xc0000b0008&#125;</span><br><span class="line">inFunc ptr: 0xc000098210</span><br><span class="line">out value: &#123;complax:[1 2 3] instance:&#123;a:5&#125; ptr:0xc0000b0008&#125;</span><br><span class="line">out ptr: 0xc0000981e0</span><br></pre></td></tr></table></figure></p>
<p>从运行结果中发现：</p>
<ul>
<li>所有的Data结构的指针地址发生了变化，意味着所有的结构都是一块新的内存，无论是将Data结构传入函数内部，还是通过函数返回值传回Data都会发生复制行为。</li>
<li>所有的Data结构中的成员值都没有发生变化，原样传递，意味着所有参数都是值传递。</li>
<li>Data结构的ptr成员在传递过程中保持一致，表示指针在函数参数值传递中传递的只是指针值，不会复制指针指向的部分。</li>
</ul>
<h1 id="函数变量——把函数作为值保存到变量中"><a href="#函数变量——把函数作为值保存到变量中" class="headerlink" title="函数变量——把函数作为值保存到变量中"></a><span style="color:#339AFF;">函数变量——把函数作为值保存到变量中</span></h1><p>在Go语言中，函数也是一种类型，可以和其他类型一样被保存在变量中。下面的代码定义了一个函数变量f，并将一个函数名fire()赋给函数变量f，这样调用函数变量f时，实际调用的就是fire()函数，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"fire"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">f</span> = <span class="title">fire</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第7行，定义了一个fire()函数。</li>
<li>第13行，将变量f声明为func()类型，此时f就被俗称为“回调函数”。此时f的值为nil。</li>
<li>第15行，将fire()函数名作为值，赋给f变量，此时f的值为fire()函数。</li>
<li>第17行，使用f变量进行函数调用，实际调用的是fire()函数。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fire</span><br></pre></td></tr></table></figure></p>
<h1 id="示例：字符串的链式处理——操作与数据分离的设计技巧"><a href="#示例：字符串的链式处理——操作与数据分离的设计技巧" class="headerlink" title="示例：字符串的链式处理——操作与数据分离的设计技巧"></a><span style="color:#339AFF;">示例：字符串的链式处理——操作与数据分离的设计技巧</span></h1><p>使用SQL语言从数据库中获取数据时，可以对原始数据进行排序（sort by）、分组（group by）和去重（distinct）等操作。SQL将数据的操作与遍历过程作为两个部分进行隔离，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。</p>
<p>对数据的操作进行多步骤的处理被称为链式处理。本例中使用多个字符串作为数据集合，然后对每个字符串进行一系列的处理，用户可以通过系统函数或者自定义函数对链式处理中的每个环节进行自定义。</p>
<p><strong>1，字符串处理函数</strong></p>
<p>字符串处理函数（StringProccess）需要外部提供数据源：一个字符串切片（list []string），另外还要提供一个链式处理函数的切片（chain []func(string) string），链式处理切片中的一个处理函数的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>这种处理函数能够接受一个字符串输入，处理后输出。</p>
<p>strings包中将字符串变为小写就是一种处理函数的形式，strings.ToLower()函数能够将传入的字符串的每一个字符变为小写，strings.ToLower定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToLower</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>字符串处理函数（StringProccess）内部遍历每一个数据源提供的字符串，每个字符串都需要经过一系列链式处理函数处理后被重新放回切片，参见下面代码：</p>
<blockquote>
<p>代码5-3 字符串的链式处理（具体文件：…/chapter05/strproc/strproc.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串处理函数，传入字符串切片和处理链</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringProccess</span><span class="params">(list []<span class="keyword">string</span>, chain []<span class="keyword">func</span>(<span class="keyword">string</span>)</span> <span class="title">string</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个字符串</span></span><br><span class="line">    <span class="keyword">for</span> index, str := <span class="keyword">range</span> list &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个需要处理的字符串</span></span><br><span class="line">        result := str</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一个处理链</span></span><br><span class="line">        <span class="keyword">for</span> _, proc := <span class="keyword">range</span> chain &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 输入一个字符串进行处理，返回数据作为下一个处理链的输入。</span></span><br><span class="line">            result = proc(result)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果放回切片</span></span><br><span class="line">        list[index] = result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，传入字符串切片list作为数据源，一系列的处理函数作为chain处理链。</li>
<li>第5行，遍历字符串切片的每个字符串，依次对每个字符串进行处理。</li>
<li>第8行，将当前字符串保存到result变量中，作为第一个处理函数的参数。</li>
<li>第11行，遍历每一个处理函数，将字符串按顺序经过这些处理函数处理。</li>
<li>第14行，result变量即是每个处理函数的输入变量，处理后的变量又会重新保存到result变量中。</li>
<li>第18行，将处理完的字符串保存回切片中。</li>
</ul>
<p><strong>2，自定义的处理函数</strong></p>
<p>处理函数可以是系统提供的处理函数，如将字符串变大写或小写，也可以使用自定义函数。本例中的字符串处理的逻辑是使用一个自定义的函数实现移除指定go前缀的过程，参见下面代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的移除前缀的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removePrefix</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strings.TrimPrefix(str，<span class="string">"go"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数使用了strings.TrimPrefix()函数实现移除字符串的指定前缀。处理后，移除前缀的字符串结果将通过removePrefix()函数的返回值返回。</p>
<p><strong>3，字符串处理主流程</strong></p>
<p>字符串处理的主流程包含以下几个步骤：</p>
<ul>
<li>（1）准备要处理的字符串列表。</li>
<li>（2）准备字符串处理链。</li>
<li>（3）处理字符串列表。</li>
<li>（4）打印输出后的字符串列表。</li>
</ul>
<p>详细流程参考下面的代码：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待处理的字符串列表</span></span><br><span class="line">    list := []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"go scanner"</span>,</span><br><span class="line">        <span class="string">"go parser"</span>,</span><br><span class="line">        <span class="string">"go compiler"</span>,</span><br><span class="line">        <span class="string">"go printer"</span>,</span><br><span class="line">        <span class="string">"go formater"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理函数链</span></span><br><span class="line">    chain := []<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">        removePrefix,</span><br><span class="line">        strings.TrimSpace,</span><br><span class="line">        strings.ToUpper,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理字符串</span></span><br><span class="line">    StringProccess(list, chain)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出处理好的字符串</span></span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> list &#123;</span><br><span class="line">        fmt.Println(str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第4行，定义字符串切片，字符串包含go前缀及空格。</li>
<li>第13行，准备处理每个字符串的处理链，处理的顺序与函数在切片中的位置一致。removePrefix()为自定义的函数，功能是移除go前缀；移除前缀的字符串左边有一个空格，使用strings.TrimSpace移除，这个函数的定义刚好符合处理函数的格式：func(string)string；strings.ToUpper用于将字符串转为大写。</li>
<li>第20行，传入字符串切片和字符串处理链，通过StringProcess()函数对字符串进行处理。</li>
<li>第23行，遍历字符串切片的每一个字符串，打印处理好的字符串结果。</li>
</ul>
<blockquote>
<p>提示：链式处理器是一种常见的编程设计。Netty是使用Java语言编写的一款异步事件驱动的网络应用程序框架，支持快速开发可维护的高性能的面向协议的服务器和客户端，Netty中就有类似的链式处理器的设计。<br><br>Netty可以使用类似的处理链对封包进行收发编码及处理。Netty的开发者可以分为3种：第一种是Netty底层开发者，第二种是每个处理环节的开发者，第三种是业务实现者，在实际开发环节中，后两种开发者往往是同一批开发者。链式处理的开发思想将数据和操作拆分、解耦，让开发者可以根据自己的技术优势和需求，进行系统开发，同时将自己的开发成果共享给其他的开发者。</p>
</blockquote>
<h1 id="匿名函数——没有函数名字的函数"><a href="#匿名函数——没有函数名字的函数" class="headerlink" title="匿名函数——没有函数名字的函数"></a><span style="color:#339AFF;">匿名函数——没有函数名字的函数</span></h1><p>Go语言支持匿名函数，即在需要使用函数时，再定义函数，匿名函数没有函数名，只有函数体，函数可以被作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式被传递。</p>
<p>匿名函数经常被用于实现问调函数、闭包等。</p>
<h2 id="定义一个匿名函数"><a href="#定义一个匿名函数" class="headerlink" title="定义一个匿名函数"></a><span style="color:#00ACC1;">定义一个匿名函数</span></h2><p>匿名函数的定义格式如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(参数列表)</span> <span class="params">(返回参数列表)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名函数的定义就是没有名字的普通函数定义。</p>
<p><strong>1，在定义时调用匿名函数</strong></p>
<p>匿名函数可以在声明后调用，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>, data)</span><br><span class="line">&#125; (<span class="number">100</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意第3行“}”后的“（100）”，表示对匿名函数进行调用，传递参数为100</p>
<p><strong>2，将匿名函数赋值给变量</strong></p>
<p>匿名函数体可以被赋值，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将匿名函数体保存到f()中</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用f()调用</span></span><br><span class="line">f(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></p>
<p>匿名函数的用途非常广泛，匿名函数本身是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。</p>
<h2 id="匿名函数用作回调函数"><a href="#匿名函数用作回调函数" class="headerlink" title="匿名函数用作回调函数"></a><span style="color:#00ACC1;">匿名函数用作回调函数</span></h2><p>下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现。用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历切片的每个元素，通过给定函数进行元素访问</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(list []<span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用匿名函数打印切片内容</span></span><br><span class="line">    visit([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，使用visit()函数将整个遍历过程进行封装，当要获取遍历期间的切片值时，只需要给visit()传入一个回调参数即可。</li>
<li>第18行，准备一个整型切片[]int{1，2，3，4}传入visit()函数作为遍历的数据。</li>
<li>第19～20行，定义了一个匿名函数，作用是将遍历的每个值打印出来。</li>
</ul>
<p>匿名函数作为回调函数的设计在Go语言的系统包中也比较常见，strings包中就有如下代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrimFunc</span><span class="params">(s <span class="keyword">string</span>, f <span class="keyword">func</span>(<span class="keyword">rune</span>)</span> <span class="title">bool</span>) <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> TrimRightFunc(TrimLeftFunc(s, f), f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用匿名函数实现操作封装"><a href="#使用匿名函数实现操作封装" class="headerlink" title="使用匿名函数实现操作封装"></a><span style="color:#00ACC1;">使用匿名函数实现操作封装</span></h2><p>下面这段代码将匿名函数作为map的键值，通过命令行参数动态调用匿名函数，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> skillParam = flag.String(<span class="string">"skill"</span>, <span class="string">""</span>, <span class="string">"skill to perform"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> skill = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="string">"fire"</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"chicken fire"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"run"</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"soldier run"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"fly"</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"angel fly"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f, ok := skill[*skillParam]; ok &#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"skill not found"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，定义命令行参数skill，从命令行输入——skill可以将空格后的字符串传入skillParam指针变量。</li>
<li>第12行，解析命令行参数，解析完成后，skillParam指针变量将指向命令行传入的值。</li>
<li>第14行，定义一个从字符串映射到func()的map，然后填充这个map。</li>
<li>第15～23行，初始化map的键值对，值为匿名函数。</li>
<li>在第26行，skillParam是一个*string类型的指针变量，使用*skillParam获取到命令行传过来的值，并在map中查找对应命令行参数指定的字符串的函数。</li>
<li>第29行，如果在map定义中存在这个参数就调用；否则打印“技能没有找到”。</li>
</ul>
<p>运行代码，结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go --skill=fly</span><br><span class="line">angle fly</span><br><span class="line">$ go run main.go --skill=run</span><br><span class="line">soldier run</span><br></pre></td></tr></table></figure></p>
<h1 id="函数类型实现接口——把函数作为接口来调用"><a href="#函数类型实现接口——把函数作为接口来调用" class="headerlink" title="函数类型实现接口——把函数作为接口来调用"></a><span style="color:#339AFF;">函数类型实现接口——把函数作为接口来调用</span></h1><p>函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将分别对比结构体与函数实现接口的过程。</p>
<p>本节例子参考代码5-4。</p>
<blockquote>
<p>代码5-4 函数实现接口（具体文件：…/chapter05/funcimplinterface/funcimplinterface.go）</p>
</blockquote>
<p>有如下一个接口：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用器接口</span></span><br><span class="line"><span class="keyword">type</span> Invoker <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 需要实现一个Call方法</span></span><br><span class="line">    Call(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口需要实现Call()方法，调用时会传入一个interface{}类型的变量，这种类型的变量表示任意类型的值。</p>
<p>接下来，使用结构体进行接口实现。</p>
<h2 id="结构体实现接口"><a href="#结构体实现接口" class="headerlink" title="结构体实现接口"></a><span style="color:#00ACC1;">结构体实现接口</span></h2><p>结构体实现Invoker接口的代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体类型</span></span><br><span class="line"><span class="keyword">type</span> Struct <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Invoker的Call</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Struct)</span> <span class="title">Call</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"from struct"</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2行，定义结构体，该例子中的结构体无须任何成员，主要展示实现Invoker的方法。</li>
<li>第6行，Call()为结构体的方法，该方法的功能是打印from struct和传入的interface{}类型的值。</li>
</ul>
<p>将定义的Struct类型实例化，并传入接口中进行调用，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> invoker Invoker</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化结构体</span></span><br><span class="line">s := <span class="built_in">new</span>(Struct)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将实例化的结构体赋值到接口</span></span><br><span class="line">invoker = s</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口调用实例化结构体的方法Struct.Call</span></span><br><span class="line">invoker.Call(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2行，声明Invoker类型的变量。</li>
<li>第5行，使用new将结构体实例化，此行也可以写为s := &amp;Struct。</li>
<li>第8行，s类型为*Struct，已经实现了Invoker接口类型，因此赋值给invoker时是成功的。</li>
<li>第11行，通过接口的Call()方法，传入hello，此时将调用Struct结构体的Call()方法。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from struct hello</span><br></pre></td></tr></table></figure></p>
<p>接下来，对比下函数体实现接口的差异。</p>
<h2 id="函数体实现接口"><a href="#函数体实现接口" class="headerlink" title="函数体实现接口"></a><span style="color:#00ACC1;">函数体实现接口</span></h2><p>函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体。当类型方法被调用时，还需要调用函数本体。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义为类型</span></span><br><span class="line"><span class="keyword">type</span> FuncCaller <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 实现<span class="title">Invoker</span>的<span class="title">Call</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f FuncCaller)</span> <span class="title">Call</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用f函数本体</span></span><br><span class="line">    f(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2行，将func(interface{})定义为FuncCaller类型。</li>
<li>第5行，FuncCaller的Call()方法将实现Invoker的Call()方法。</li>
<li>第8行，FuncCaller的Call()方法被调用与func(interface{})无关，还需要手动调用函数本体。</li>
</ul>
<p>上面代码只是定义了函数类型，需要函数本身进行逻辑处理。FuncCaller无须被实例化，只需要将函数转换为FuncCaller类型即可，函数来源可以是命名函数、匿名函数或闭包，参见下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明接口变量</span></span><br><span class="line"><span class="keyword">var</span> invoker Invoker</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将匿名函数转为FuncCaller类型，再赋值给接口</span></span><br><span class="line">invoker = FuncCaller(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"from function"</span>, v)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口调用FuncCaller.Call，内部会调用函数本体</span></span><br><span class="line">invoker.Call(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2行，声明接口变量。</li>
<li>第5行，将func(v interface{}){}匿名函数转换为FuncCaller类型（函数签名才能转换），此时FuncCaller类型实现了Invoker的Call()方法，赋值给invoker接口是成功的。</li>
<li>第10行，使用接口方法调用。</li>
</ul>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from function hello</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP包中的例子"><a href="#HTTP包中的例子" class="headerlink" title="HTTP包中的例子"></a><span style="color:#00ACC1;">HTTP包中的例子</span></h2><p>HTTP包中包含有Handler接口定义，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWrite, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Handler用于定义每个HTTP的请求和响应的处理过程。</p>
<p>同时，也可以使用处理函数实现接口，定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要使用闭包实现默认的HTTP请求处理，可以使用http.HandleFunc()函数，函数定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而DefaultServeMux是ServeMux结构，拥有HandleFunc()方法，定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码将外部传入的函数handler()转为HandlerFunc类型，HandlerFunc类型实现了Handler的ServeHTTP方法，底层可以同时使用各种类型来实现Handler接口进行处理。</p>
<h1 id="闭包（Closure）——引用了外部变量的匿名函数"><a href="#闭包（Closure）——引用了外部变量的匿名函数" class="headerlink" title="闭包（Closure）——引用了外部变量的匿名函数"></a><span style="color:#339AFF;">闭包（Closure）——引用了外部变量的匿名函数</span></h1><p>闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。因此，简单的说：</p>
<p>函数+引用环境=闭包</p>
<p>同一个函数与不同引用环境组合，可以形成不同的实例，如图5-1所示。</p>
<blockquote>
<p>图5-1 闭包与引用函数</p>
</blockquote>
<img src="/2021/08/19/第5章-函数（function）/1.jpg">
<p>一个函数类型就像结构体一样，可以被实例化。函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”。函数是编译期静态的概念，而闭包是运行期动态的概念。</p>
<blockquote>
<p>提示：闭包（Closure）在某些编程语言中也被称为Lambda表达式。<br><br>闭包对环境中变量的引用过程，也可以被称为“捕获”，在C++11标准中，捕获有两种类型：引用和复制，可以改变引用的原值叫做”引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。<br><br>在Lua语言中，将被捕获的变量起了一个名字叫做Upvalue，因为捕获过程总是对闭包上方定义过的自由变量进行引用。<br><br>闭包在各种语言中的实现也是不尽相同的。在Lua语言中，无论闭包还是函数都属于Prototype概念，被捕获的变量以Upvalue的形式引用到闭包中。<br><br>C++与C#中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员</p>
</blockquote>
<h2 id="在闭包内部修改引用的变量"><a href="#在闭包内部修改引用的变量" class="headerlink" title="在闭包内部修改引用的变量"></a><span style="color:#00ACC1;">在闭包内部修改引用的变量</span></h2><p>闭包对它作用域上部变量的引用可以进行修改，修改引用的变量就会对变量进行实际修改，通过下面的例子来理解：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备一个字符串</span></span><br><span class="line">str := <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个匿名函数</span></span><br><span class="line">foo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名函数中访问str</span></span><br><span class="line">    str = <span class="string">"hello dude"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用匿名函数</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第2行，准备一个字符串用于修改。</li>
<li>第5行，创建一个匿名函数。</li>
<li>第8行，在匿名函数中并没有定义str，str的定义在匿名函数之前，此时，str就被引用到了匿名函数中形成了闭包。</li>
<li>第12行，执行闭包，此时str发生修改，变为hello dude。</li>
</ul>
<p>代码输出：hello dude。</p>
<h2 id="示例：闭包的记忆效应"><a href="#示例：闭包的记忆效应" class="headerlink" title="示例：闭包的记忆效应"></a><span style="color:#00ACC1;">示例：闭包的记忆效应</span></h2><p>被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。</p>
<blockquote>
<p>代码5-5累加器（具体文件：…/chapter05/accumulator/accumulator.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个值，每次调用函数会指定对值进行累加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Accumulate</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 累加</span></span><br><span class="line">        value++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个累加值</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个累加器，初始值为1</span></span><br><span class="line">    accumulator := Accumulate(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加1并打印</span></span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    fmt.Println(accumulator())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, accumulator)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个累加器，初始值为10</span></span><br><span class="line">    accumulator2 := Accumulate(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加1并打印</span></span><br><span class="line">    fmt.Println(accumulator2())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印累加器的函数地址</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, accumulator2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">0x108b9e0</span><br><span class="line">11</span><br><span class="line">0x108b9c0</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，累加器生成函数，这个函数输出一个初始值，调用时返回一个为初始值创建的闭包函数。</li>
<li>第11行，返回一个闭包函数，每次返回会创建一个新的函数实例。</li>
<li>第14行，对引用的Accumulate参数变量进行累加，注意value不是第11行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。</li>
<li>第17行，将修改后的值通过闭包的返回值返回。</li>
<li>第24行，创建一个累加器，初始值为1，返回的accumulator是类型为func()int的函数变量。</li>
<li>第27行，调用accumulator()时，代码从11行开始执行匿名函数逻辑，直到第17行返回。</li>
<li>第32行，打印累加器的函数地址。</li>
</ul>
<p>对比输出的日志发现accumulator与accumulator2输出的函数地址不同，因此它们是两个不同的闭包实例。</p>
<p>每调用一次accumulator都会自动对引用的变量进行累加。</p>
<h2 id="示例：闭包实现生成器"><a href="#示例：闭包实现生成器" class="headerlink" title="示例：闭包实现生成器"></a><span style="color:#00ACC1;">示例：闭包实现生成器</span></h2><p>闭包的记忆效应进程被用于实现类似于设计模式中工厂模式的生成器。下面的例子展示了创建一个玩家生成器的过程。</p>
<blockquote>
<p>代码5-6 玩家生成器（具体文件：…/chapter05/playergen/playergen.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个玩家生成器，输入名称，输出生成器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">playerGen</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">func</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 血量一直为150</span></span><br><span class="line">    hp := <span class="number">150</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回创建的闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将变量引用到闭包中</span></span><br><span class="line">        <span class="keyword">return</span> name, hp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个玩家生成器</span></span><br><span class="line">    generator := playerGen(<span class="string">"high noon"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回玩家的名字和血量</span></span><br><span class="line">    name, hp := generator()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印值</span></span><br><span class="line">    fmt.Println(name, hp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">high noon 150</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，playerGen()需要提供一个名字来创建一个玩家的生成函数。</li>
<li>第11行，声明并设定hp变量为150。</li>
<li>第14行～18行，将hp和name变量引用到匿名函数中形成闭包。</li>
<li>第24行中，通过playerGen传入参数调用后获得玩家生成器。</li>
<li>第27行，调用这个玩家生成器函数，可以获得玩家的名称和血量。</li>
</ul>
<p>闭包还具有一定的封装性，第11行的变量是playerGen的局部变量，playerGen的外部无法直接访问及修改这个变量，这种特性也与面向对象中强调的封装性类似。</p>
<h1 id="可变参数——参数数量不固定的函数形式"><a href="#可变参数——参数数量不固定的函数形式" class="headerlink" title="可变参数——参数数量不固定的函数形式"></a><span style="color:#339AFF;">可变参数——参数数量不固定的函数形式</span></h1><p>Go语言支持可变参数特性，函数声明和调用时没有固定数量的参数，同时也提供了一套方法进行可变参数的多级传递。Go语言的可变参数格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(固定参数列表, v ...T)</span> <span class="params">(返回参数列表)</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>特性如下：</p>
<ul>
<li>可变参数一般被放置在函数列表的末尾，前面是固定参数列表，当没有固定参数时，所有变量就将是可变参数。</li>
<li>v为可变参数变量，类型为[]T，也就是拥有多个T元素的T类型切片，v和T之间由“…”即3个点组成。</li>
<li>T为可变参数的类型，当T为interface{}时，传入的可以是任意类型。</li>
</ul>
<h2 id="fmt包中的例子"><a href="#fmt包中的例子" class="headerlink" title="fmt包中的例子"></a><span style="color:#00ACC1;">fmt包中的例子</span></h2><p>可变参数有两种形式：所有参数都是可变参数的形式，如fmt.Println，以及部分是可变参数的形式，如fmt.Printf，可变参数只能出现在参数的后半部分，因此不可变的参数只能放在参数的前半部分。</p>
<p><strong>1，所有参数都是可变参数：fmt.Println</strong></p>
<p>fmt.Println的函数声明如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fmt.Println在使用时，传入的值类型不受限制，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">5</span>, <span class="string">"hello"</span>, &amp;<span class="keyword">struct</span>&#123;a <span class="keyword">int</span>&#125;&#123;<span class="number">1</span>&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>2，部分参数是可变参数：fmt.Printf</strong></p>
<p>fmt.Printf的第一个参数为参数列表，后面的参数是可变参数，fmt.Printf函数的格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprint(os.Stdout, format, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fmt.Printf()函数在调用时，第一个函数始终必须传入字符串，对应参数是format，后面的参数数量可以变化，使用时，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"pure string\n"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"value: %v %f\n"</span>, <span class="literal">true</span>, math.Pi)</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历可变参数列表——获取每一个参数的值"><a href="#遍历可变参数列表——获取每一个参数的值" class="headerlink" title="遍历可变参数列表——获取每一个参数的值"></a><span style="color:#00ACC1;">遍历可变参数列表——获取每一个参数的值</span></h2><p>可变参数列表的数量不固定，传入的参数是一个切片。如果需要获得每一个参数的具体值时，可以对可变参数变量进行遍历，参见下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个函数，参数数量为0~n，类型约束为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">joinStrings</span><span class="params">(slist ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个字节缓冲，快速地连接字符串</span></span><br><span class="line">    <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">    <span class="comment">// 遍历可变参数列表slist，类型为[]string</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> slist&#123;</span><br><span class="line">        <span class="comment">// 将遍历出的字符串连续写入字节数组</span></span><br><span class="line">        b.WriteString(s)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将连接好的字节数组转换为字符串并输出</span></span><br><span class="line">    <span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 输入3个字符串，将它们连成一个字符串</span></span><br><span class="line">    fmt.Println(joinStrings(<span class="string">"pig "</span>, <span class="string">"and"</span>, <span class="string">" rat"</span>))</span><br><span class="line">    fmt.Println(joinStrings(<span class="string">"hammer"</span>, <span class="string">" mom"</span>, <span class="string">" and"</span>, <span class="string">" hawk"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pig and rat</span><br><span class="line">hammer mom and hawk</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，定义了一个可变参数的函数，slist的类型为[]string，每一个参数的类型是string，也就是说，该函数只接受字符串类型作为参数。</li>
<li>第11行，bytes.Buffer在这个例子中的作用类似于StringBuilder，可以高效地进行字符串连接操作。</li>
<li>第13行，遍历slist可变参数，s为每个参数的值，类型为string。</li>
<li>第15行，将每一个传入参数放到bytes.Buffer中。</li>
<li>第19行，将bytes.Buffer中的数据转换为字符串作为函数返回值返回。</li>
<li>第24行，输入3个字符串，使用joinStrings()函数将参数连接为字符串输出。</li>
<li>第25行，输入4个字符串，连接后输出。</li>
</ul>
<p>如果要获取可变参数的数量，可以使用len()函数对可变参数变量对应的切片进行求长度操作，以获得可变参数数量。</p>
<h2 id="获得可变参数类型——获得每一个参数的类型"><a href="#获得可变参数类型——获得每一个参数的类型" class="headerlink" title="获得可变参数类型——获得每一个参数的类型"></a><span style="color:#00ACC1;">获得可变参数类型——获得每一个参数的类型</span></h2><p>当可变参数为interface{}类型时，可以传入任何类型的值。此时，如果需要获得变量的类型，可以通过switch类型分支获得变量的类型。下面的代码演示将一系列不同类型的值传入printTypeValue()函数，该函数将分别为不同的参数打印它们的值和类型的详细描述。</p>
<blockquote>
<p>代码5-7 打印类型及值（具体文件：…/chapter05/printtypevalue/printtypevalue.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bytes"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTypeValue</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节缓冲作为快速字符串连接</span></span><br><span class="line">    <span class="keyword">var</span> b bytes.Buffer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历参数</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> slist &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将interface&#123;&#125;类型格式化为字符串</span></span><br><span class="line">        str := fmt.Sprintf(<span class="string">"%v"</span>, s)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类型的字符串描述</span></span><br><span class="line">        <span class="keyword">var</span> typeString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对s进行类型断言</span></span><br><span class="line">        <span class="keyword">switch</span> s.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">bool</span>: <span class="comment">// 当s为布尔类型时</span></span><br><span class="line">            typeString = <span class="string">"bool"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>: <span class="comment">// 当s为字符串类型时</span></span><br><span class="line">            typeString = <span class="string">"string"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">int</span>: <span class="comment">// 当s为整形类型时</span></span><br><span class="line">            typeString = <span class="string">"int"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写值字符串前缀</span></span><br><span class="line">        b.WriteString(<span class="string">"value: "</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入值</span></span><br><span class="line">        b.WriteString(str)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写类型前缀</span></span><br><span class="line">        b.WriteString(<span class="string">" type: "</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写类型字符串</span></span><br><span class="line">        b.WriteString(typeString)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入换行符，一个输入变量一行</span></span><br><span class="line">        b.WriteString(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将不同类型的变量通过printTypeValue打印出来</span></span><br><span class="line">    fmt.Println(printTypeValue(<span class="number">100</span>, <span class="string">"str"</span>, <span class="literal">true</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value: 100 type: int</span><br><span class="line">value: str type: string</span><br><span class="line">value: true type: bool</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，printTypeValue()输入不同类型的值并输出类型和值描述。</li>
<li>第11行，bytes.Buffer字节缓冲作为快速字符串连接。</li>
<li>第14行，遍历slist的每一个元素，类型为interface{}。</li>
<li>第17行，使用fmt.Sprintf配合“%V”动词，可以将interface{}格式的任意值转为字符串。</li>
<li>第20行，声明一个字符串，作为变量的类型名。</li>
<li>第23行，switch s.(type)可以对interface{}类型进行类型断言，也就是判断变量的实际类型。</li>
<li>第24～29行为s变量可能的类型，将每种类型的对应类型字符串赋值到typeString中。</li>
<li>第33～42行为写输出格式的过程。</li>
</ul>
<h2 id="在多个可变参数函数中传递参数"><a href="#在多个可变参数函数中传递参数" class="headerlink" title="在多个可变参数函数中传递参数"></a><span style="color:#00ACC1;">在多个可变参数函数中传递参数</span></h2><p>可变参数变量是一个包含所有参数的切片，如果要在多个可变参数中传递参数，可以在传递时在可变参数变量中默认添加“…”，将切片中的元素进行传递，而不是传递可变参数变量本身。</p>
<p>下面的例子模拟print()函数及实际调用的rawPrint()函数，两个函数都拥有可变参数，需要将参数从print传递到rawPrint中。</p>
<blockquote>
<p>代码5-8 可变参数传递（具体文件：…/chapter05/variadictransfer/variadictransfer.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际打印的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawPrint</span><span class="params">(rawList ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历可变参数切片</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> rawList &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印参数</span></span><br><span class="line">        fmt.Println(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印函数封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(slist ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将slist可变参数切片完整传递给下一个函数</span></span><br><span class="line">    rawPrint(slist...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码输出如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>第9～13行，遍历rawPrint()的参数列表rawList并打印。</li>
<li>第20行，将变量在print的可变参数列表中添加“…”后传递给rawPrint()。</li>
<li>第25行，传入1、2、3这3个整型值进行打印。</li>
</ul>
<p>如果尝试将第20行修改为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rawPrint(<span class="string">"Emt"</span>, slist)</span><br></pre></td></tr></table></figure></p>
<p>再次执行代码，将输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Emt</span><br><span class="line">[1 2 3]</span><br></pre></td></tr></table></figure></p>
<p>此时，slist（类型为[]interface{}）将被作为一个整体传入rawPrint()，rawPrint()函数中遍历的变量也就是slist的切片值。</p>
<p>可变参数使用“…”进行传递与切片间使用append连接是同一个特性。</p>
<h1 id="延迟执行语句（defer）"><a href="#延迟执行语句（defer）" class="headerlink" title="延迟执行语句（defer）"></a><span style="color:#339AFF;">延迟执行语句（defer）</span></h1><p>Go语言的defer语句会将其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer的逆序进行执行，也就是说，先被defer的语句最后被执行，最后被defer的语句，最先被执行。</p>
<h2 id="多个延迟执行语句的处理顺序"><a href="#多个延迟执行语句的处理顺序" class="headerlink" title="多个延迟执行语句的处理顺序"></a><span style="color:#00ACC1;">多个延迟执行语句的处理顺序</span></h2><p>下面的代码是将一系列的数值打印语句按顺序延迟处理，参见演示代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"defer begin"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将defer放入延迟调用栈</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个放入，位于栈顶，最先调用</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"defer end"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer begin</span><br><span class="line">defer end</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>结果分析如下：</p>
<ul>
<li>代码的延迟顺序与最终的执行顺序是反向的。</li>
<li>延迟调用是在defer所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。</li>
</ul>
<h2 id="使用延迟执行语句在函数退出时释放资源"><a href="#使用延迟执行语句在函数退出时释放资源" class="headerlink" title="使用延迟执行语句在函数退出时释放资源"></a><span style="color:#00ACC1;">使用延迟执行语句在函数退出时释放资源</span></h2><p>处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。</p>
<p>defer语句正好是在函数退出时执行的语句，所以使用defer能非常方便地处理资源释放问题。</p>
<p><strong>1，使用延迟并发解锁</strong></p>
<p>在下面的例子中会在函数中并发使用map，为防止竞态问题，使用sync.Mutex进行加锁，参见下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// 一个演示用的映射</span></span><br><span class="line">    valueByKey = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// 保证使用映射时的并发安全的互斥锁</span></span><br><span class="line">    valueByKeyGuard sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据键读取值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对共享资源加锁</span></span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line">    <span class="comment">// 取值</span></span><br><span class="line">    v := valueByKey[key]</span><br><span class="line">    <span class="comment">// 对共享资源解锁</span></span><br><span class="line">    valueByKeyGuard.Unlock()</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第3行，实例化一个map，键是string类型，值为int。</li>
<li>第5行，map默认不是并发安全的，准备一个sync.Mutex互斥量保护map的访问。</li>
<li>第9行，readValue()函数给定一个键，从map中获得值后返回，该函数会在并发环境中使用，需要保证并发安全。</li>
<li>第11行，使用互斥量加锁。</li>
<li>第13行，从map中获取值。</li>
<li>第15行，使用互斥量解锁。</li>
<li>第17行，返回获取到的map值。</li>
</ul>
<p>使用defer语句对上面的语句进行简化，参考下面的代码。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readValue</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    valueByKeyGuard.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer后面的语句不会马上调用，而是延迟到函数结束时调用</span></span><br><span class="line">    <span class="keyword">defer</span> valueByKeyGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valueByKey[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第6行代码为对比前面代码而修改和添加的代码，代码说明如下：</p>
<ul>
<li>第6行在互斥量加锁后，使用defer语句添加解锁，该语句不会马上执行，而是等readValue()返回时才会被执行。</li>
<li>第8行，从map查询值并返回的过程中，与不使用互斥量的写法一样，对比上面的代码，这种写法更简单。</li>
</ul>
<p><strong>2，使用延迟释放文件句柄</strong></p>
<p>文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源。在下面的例子中将实现根据文件名获取文件大小的函数，函数中需要打开文件、获取文件大小和关闭文件等操作。由于每一步系统操作都需要进行错误处理，而每一步处理都会造成一次可能的退出，因此就需要在退出时释放资源，而我们需要密切关注在函数退出处正确地释放文件资源。参考下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据文件名查询其大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileSize</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据文件名打开文件，返回文件句柄和错误</span></span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果打开时发生错误，返回文件大小为0</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取文件状态信息</span></span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果获取信息时发生错误，关闭文件并返回文件大小为0</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取文件大小</span></span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回文件大小</span></span><br><span class="line">    <span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第2行，定义获取文件大小的函数，返回值是64位的文件大小值。</li>
<li>第5行，使用os包提供的函数Open()，根据给定的文件名打开一个文件，并返回操作文件用的句柄和操作错误。</li>
<li>第8行，如果打开的过程中发生错误，如文件没找到、文件被占用等，将返回文件大小为0。</li>
<li>第13行，此时文件句柄f可以正常使用，使用f的方法Stat()来获取文件的信息，获取信息时，可能也会发生错误。</li>
<li>第16～19行对错误进行处理，此时文件是正常打开的，为了释放资源，必须要调用f的Close()方法来关闭文件，否则会发生资源泄露。</li>
<li>第22行，获取文件大小。</li>
<li>第25行，关闭文件、释放资源。</li>
<li>第28行，返回获取到的文件大小。</li>
</ul>
<p>在上面的例子中第17、25行是对文件的关闭操作。下面使用defer对代码进行简化，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fileSize</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟调用Close，此时Close不会被调用</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    info, err := f.Stat()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// defer机制触发，调用Close关闭文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size := info.Size()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer机制触发，调用Close关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第10行代码为对比前面代码而修改的部分，代码说明如下：</p>
<ul>
<li>第10行，在文件正常打开后，使用defer，将f.Close()延迟调用。注意，不能将这一句代码放在第4行空行处，一旦文件打开错误，f将为空，在延迟语句触发时，将触发宕机错误。</li>
<li>第16行和第22行，defer后的语句（<code>f.Close()</code>）将会在函数返回前被调用，自动释放资源。</li>
</ul>
<h1 id="处理运行时发生的错误"><a href="#处理运行时发生的错误" class="headerlink" title="处理运行时发生的错误"></a><span style="color:#339AFF;">处理运行时发生的错误</span></h1><p>Go语言的错误处理思想及设计包含以下特征：</p>
<ul>
<li>一个可能造成错误的函数，需要返回值中返回一个错误接口（error）。如果调用是成功的，错误接口将返回nil，否则返回错误。</li>
<li>在函数调用后需要检查错误，如果发生错误，进行必要的错误处理。</li>
</ul>
<blockquote>
<p>提示：Go语言没有类似Java、或.NET中的异常处理机制，虽然可以使用defer、panic、recover模拟，但官方并不主张这样做。Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源。同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。</p>
</blockquote>
<p>Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数。同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。</p>
<h2 id="net包中的例子"><a href="#net包中的例子" class="headerlink" title="net包中的例子"></a><span style="color:#00ACC1;">net包中的例子</span></h2><p>net.Dial()是Go语言系统包net中的一个函数，一般用于创建一个Socket连接。</p>
<p>net.Dial拥有两个返回值，即Conn和error。这个函数是阻塞的，因此在Socket操作后，会返回Conn连接对象和error；如果发生错误，error会告知错误的类型，Conn会返回空。</p>
<p>根据Go语言的错误处理机制，Conn是其重要的返回值。因此，为这个函数增加一个错误返回，类似为error。参见下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span> <span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d Dialer</span><br><span class="line">    <span class="keyword">return</span> d.Dial(network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在io包中的Writer接口也拥有错误返回，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Writer(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>io包中还有Closer接口，只有一个错误返回，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="错误接口的定义格式"><a href="#错误接口的定义格式" class="headerlink" title="错误接口的定义格式"></a><span style="color:#00ACC1;">错误接口的定义格式</span></h2><p>error是Go系统声明的接口类型，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有符合Error() string格式的方法，都能实现错误接口。</p>
<p>Error()方法返回错误的具体描述，使用者可以通过这个字符串知道发生了什么错误。</p>
<h2 id="自定义一个错误"><a href="#自定义一个错误" class="headerlink" title="自定义一个错误"></a><span style="color:#00ACC1;">自定义一个错误</span></h2><p>返回错误前，需要定义会产生哪些可能的错误。在Go语言中，使用errors包进行错误的定义，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = errors.New(<span class="string">"this is an error"</span>)</span><br></pre></td></tr></table></figure></p>
<p>错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用errors.New返回。</p>
<p><strong>1，errors包</strong></p>
<p>Go语言的errors中对New的定义非常简单，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建错误对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误字符串</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回发生何种错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第2行，将errorString结构体实例化，并赋值错误描述的成员。</li>
<li>第7行，声明errorString结构体，拥有一个成员，描述错误内容。</li>
<li>第12行，实现error接口的Error()方法，该方法返回成员中的错误描述。</li>
</ul>
<p><strong>2，在代码中使用错误定义</strong></p>
<p>下面的代码会定义一个除法函数，当除数为0时，返回一个预定义的除数为0的错误。</p>
<blockquote>
<p>代码5-9 除0错误（具体文件：…/chapter05/diverr/diverr.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"errors"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义除数为0的错误</span></span><br><span class="line"><span class="keyword">var</span> errDivisionByZero = errors.New(<span class="string">"division by zero"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(dividend, divisor <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断除数为0的情况并返回</span></span><br><span class="line">    <span class="keyword">if</span> divisor == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errDivisionByZero</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常计算，返回空错误</span></span><br><span class="line">    <span class="keyword">return</span> dividend / divisor, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(div(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 division by zero</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第9行，预定义除数为0的错误。</li>
<li>第11行，声明除法函数，输入被除数和除数，返回商和错误。</li>
<li>第14行，在除法计算中，如果除数为0，计算结果为无穷大。为了避免这种情况，对除数进行判断，并返回商为0和除数为0的错误对象。</li>
<li>第19行，进行正常的除法计算，没有发生错误时，错误对象返回nil。</li>
</ul>
<h2 id="示例：在解析中使用自定义错误"><a href="#示例：在解析中使用自定义错误" class="headerlink" title="示例：在解析中使用自定义错误"></a><span style="color:#00ACC1;">示例：在解析中使用自定义错误</span></h2><p>使用errors.New定义的错误字符串的错误类型是无法提供丰富的错误信息的。那么，如果需要携带错误信息返回，就需要借助自定义结构体实现错误接口。</p>
<p>下面代码将实现一个解析错误（ParseError），这种错误包含两个内容：文件名和行号。解析错误的结构还实现了error接口的Error()方法，返回错误描述时，就需要将文件名和行号返回。</p>
<blockquote>
<p>代码5-10 自定义错误（具体文件：…/chapter05/parseerr/parseerr.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个解析错误</span></span><br><span class="line"><span class="keyword">type</span> ParseError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Filename <span class="keyword">string</span> <span class="comment">// 文件名</span></span><br><span class="line">    Line     <span class="keyword">int</span>    <span class="comment">// 行号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现error接口，返回错误描述</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ParseError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%s:%d"</span>, e.Filename, e.Line)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一些解析错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newParseError</span><span class="params">(filename <span class="keyword">string</span>, line <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ParseError&#123;filename, line&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> e error</span><br><span class="line">    <span class="comment">// 创建一个错误实例，包含文件名和行号</span></span><br><span class="line">    e = newParseError(<span class="string">"main.go"</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过error接口查看错误描述</span></span><br><span class="line">    fmt.Println(e.Error())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据错误接口具体的类型，获取详细错误信息</span></span><br><span class="line">    <span class="keyword">switch</span> detail := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *ParseError: <span class="comment">// 这是一个解析错误</span></span><br><span class="line">        fmt.Printf(<span class="string">"Filename: %s Line: %d\n"</span>, detail.Filename, detail.Line)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 其他类型的错误</span></span><br><span class="line">        fmt.Println(<span class="string">"other error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.go:1</span><br><span class="line">Filename: main.go Line: 1</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，声明了一个解析错误的结构体，解析错误包含有2个成员：文件名和行号。</li>
<li>第14行，实现了错误接口，将成员的文件名和行号格式化为字符串返回。</li>
<li>第19行，根据给定的文件名和行号创建一个错误实例。</li>
<li>第25行，声明一个错误接口类型。</li>
<li>第27行，创建一个实例，这个错误接口内部是*ParserError类型，携带有文件名main.go和行号1。</li>
<li>第30行，调用Error()方法，通过第15行返回错误的详细信息。</li>
<li>第33行，通过错误断言，取出发生错误的详细类型。</li>
<li>第34行，通过分析这个错误的类型，得知错误类型为*ParserError，此时可以获取到详细的错误信息。</li>
<li>第36行，如果不是我们能够处理的错误类型，会打印出其他错误做出其他的处理。</li>
</ul>
<p>错误对象都要实现error接口的Error()方法，这样，所有的错误都可以获得字符串的描述。如果想进一步知道错误的详细信息，可以通过类型断言，将错误对象转为具体的错误类型进行错误详细信息的获取。</p>
<h1 id="宕机（panic）——程序终止运行"><a href="#宕机（panic）——程序终止运行" class="headerlink" title="宕机（panic）——程序终止运行"></a><span style="color:#339AFF;">宕机（panic）——程序终止运行</span></h1><p>宕机不是一件很好的事情，可能造成体验停止、服务中断，就像没有人希望在取钱时遇到ATM机蓝屏一样。但是，如果在损失发生时，程序没有因为宕机而停止，那么用户将会付出更大的代价，这种代价可以是金钱、时间甚至生命。因此，宕机有时是一种合理的止损方法。</p>
<h2 id="手动触发宕机"><a href="#手动触发宕机" class="headerlink" title="手动触发宕机"></a><span style="color:#00ACC1;">手动触发宕机</span></h2><p>Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。</p>
<p>Go语言程序在宕机时，会将堆栈和goroutine信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置。如果在编译时加入的调试信息甚至连崩溃现场的变量值、运行状态都可以获取，那么如何触发宕机呢？例如下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"crash"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码运行崩溃并输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">panic: crash</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/chebin/goproject/demo/test.go:4 +0x27</span><br></pre></td></tr></table></figure></p>
<p>以上代码中只用了一个内建的函数panic()就可以造成崩溃，panic()的声明如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure></p>
<p>panic()的参数可以是任意类型，后文将提到的recover参数会接收从panic()中发出的内容。</p>
<h2 id="在运行依赖的必备资源缺失时主动触发宕机"><a href="#在运行依赖的必备资源缺失时主动触发宕机" class="headerlink" title="在运行依赖的必备资源缺失时主动触发宕机"></a><span style="color:#00ACC1;">在运行依赖的必备资源缺失时主动触发宕机</span></h2><p>regexp是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。</p>
<p>编译正则表达式函数有两种，具体如下。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Compile</span><span class="params">(expr <span class="keyword">string</span>)</span> <span class="params">(*Regexp, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>编译正则表达式，发生错误时返回编译错误，Regexp为nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span> <span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">Regexp</span></span></span><br></pre></td></tr></table></figure></p>
<p>当编译正则表达式发生错误时，使用panic触发宕机，该函数适用于直接适用正则表达式而无须处理正则表达式错误的情况。</p>
<p>MustCompile的代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MustCompile</span> <span class="params">(str <span class="keyword">string</span>)</span> *<span class="title">Regexp</span></span> &#123;</span><br><span class="line">    regexp, error := Compile(str)</span><br><span class="line">    <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">`regexp: Compile(`</span> + quotr(str) + <span class="string">`): `</span> + error.Error())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regexp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第1行，编译正则表达式函数入口，输入包含正则表达式的字符串，返回正则表达式对象。</li>
<li>第2行，Compile()是编译正则表达式的入口函数，该函数返回编译好的正则表达式对象和错误。</li>
<li>第3和第4行判断如果有错，则使用panic()触发宕机。</li>
<li>第6行，没有错误时返回正则表达式对象。</li>
</ul>
<p>手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生。不过，如果任何错误都使用宕机处理，也不是一种良好的设计。因此应根据需要来决定是否使用宕机进行报错。</p>
<h2 id="在宕机时触发延迟执行语句"><a href="#在宕机时触发延迟执行语句" class="headerlink" title="在宕机时触发延迟执行语句"></a><span style="color:#00ACC1;">在宕机时触发延迟执行语句</span></h2><p>当panic()触发的宕机发生时，panic()后面的代码将不会被运行，但是在panic()函数前面已经运行过的defer语句依然会在宕机发生时发生作用，参考下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"宕机后要做的事情1"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"宕机后要做的事情2"</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"宕机"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">宕机后要做的事情2</span><br><span class="line">宕机后要做的事情1</span><br><span class="line">panic: 宕机</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/chebin/goproject/demo/test.go:8 +0xac</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第6行和第7行使用defer语句延迟了2个语句。</li>
<li>第8行发生宕机。</li>
</ul>
<p>宕机前，defer语句会优先被执行，由于第7行的defer后执行，因此会在宕机前，这个defer会优先处理，随后才是第6行的defer对应的语句。这个特性可以用来在宕机发生前进行宕机信息处理。</p>
<h1 id="宕机恢复（recover）——防止程序崩溃"><a href="#宕机恢复（recover）——防止程序崩溃" class="headerlink" title="宕机恢复（recover）——防止程序崩溃"></a><span style="color:#339AFF;">宕机恢复（recover）——防止程序崩溃</span></h1><p>无论是代码运行错误由Runtime层抛出的panic崩溃，还是主动触发的panic崩溃，都可以配合defer和recover实现错误捕捉和恢复，让代码在发生崩溃后允许继续运行。</p>
<blockquote>
<p>提示：在其他语言里，宕机往往以异常的形式存在。底层抛出异常，上层逻辑通过try/catch机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。<br><br>Go没有异常系统，其使用panic触发宕机类似于其他语言的抛出异常，那么recover的宕机恢复机制就对应try/catch机制。</p>
</blockquote>
<h2 id="让程序在崩溃时继续执行"><a href="#让程序在崩溃时继续执行" class="headerlink" title="让程序在崩溃时继续执行"></a><span style="color:#00ACC1;">让程序在崩溃时继续执行</span></h2><p>下面的代码实现了ProtectRun()函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生panic崩溃后，可以将崩溃发生的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。</p>
<blockquote>
<p>代码5-11 保护运行函数（具体文件：…/chapter05/protectrun/protectrun.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 崩溃时需要传递的上下文信息</span></span><br><span class="line"><span class="keyword">type</span> panicContext <span class="keyword">struct</span> &#123;</span><br><span class="line">    function <span class="keyword">string</span> <span class="comment">// 所在函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保护方式允许一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProtectRun</span><span class="params">(entry <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟处理的函数</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发生宕机时，获取panic传递的上下文并打印</span></span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> runtime.Error: <span class="comment">// 运行时错误</span></span><br><span class="line">            fmt.Println(<span class="string">"runtime error:"</span>, err)</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 非运行时错误</span></span><br><span class="line">            fmt.Println(<span class="string">"error:"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    entry()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"运行前"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许一段手动触发的错误</span></span><br><span class="line">    ProtectRun(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"手动宕机前"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用panic传递上下文</span></span><br><span class="line">        <span class="built_in">panic</span>(&amp;panicContext&#123;</span><br><span class="line">            <span class="string">"手动触发panic"</span>,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"手动宕机后"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 故意造成空指针访问错误</span></span><br><span class="line">    ProtectRun(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"赋值宕机前"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line">        *a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"赋值宕机后"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"运行后"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行前</span><br><span class="line">手动宕机前</span><br><span class="line">error: &amp;&#123;手动触发panic&#125;</span><br><span class="line">赋值宕机前</span><br><span class="line">runtime error: runtime error: invalid memory address or nil pointer dereference</span><br><span class="line">运行后</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第9行声明描述错误的结构体，成员保存错误的执行函数。</li>
<li>第17行使用defer将闭包延迟执行，当panic触发崩溃时，ProtectRun()函数将结束运行，此时defer后的闭包将会发生调用。</li>
<li>第20行，recover()获取到panic传入的参数。</li>
<li>第22行，使用switch对err变量进行类型断言。</li>
<li>第23行，如果错误是有Runtime层抛出的运行时错误，如空指针访问、除数为0等情况，打印运行时错误。</li>
<li>第25行，其他错误，打印传递过来的错误数据。</li>
<li>第44行，使用panic手动触发一个错误，并将一个结构体附带信息传递过去，此时，recover就会获取到这个结构体信息，并打印出来。</li>
<li>第57行，模拟代码中空指针赋值造成的错误，此时会由Runtime层抛出错误，被ProtectRun()函数的recover()函数捕获到。</li>
</ul>
<h2 id="panic和recover的关系"><a href="#panic和recover的关系" class="headerlink" title="panic和recover的关系"></a><span style="color:#00ACC1;">panic和recover的关系</span></h2><p>panic和defer的组合有如下几个特性。</p>
<ul>
<li>有panic没recover，程序宕机。</li>
<li>有panic也有recover捕获，程序不会宕机。执行完对应的defer后，从宕机点退出当前函数后继续执行。</li>
</ul>
<blockquote>
<p>提示：虽然panic/recover能模拟其他语言的异常机制，但并不建议代表编写普通函数也经常性使用这种特性。<br><br>在panic触发的defer函数内，可以继续调用panic，进一步将错误外抛直到程序整体崩溃。<br><br>如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。</p>
</blockquote>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言从入门到进阶实战/" rel="tag"># Go语言从入门到进阶实战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/19/第4章-流程控制/" rel="next" title="第4章 流程控制">
                <i class="fa fa-chevron-left"></i> 第4章 流程控制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/19/第6章-结构体（struct）/" rel="prev" title="第6章 结构体（struct）">
                第6章 结构体（struct） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#声明函数"><span class="nav-number">1.</span> <span class="nav-text">声明函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#普通函数的声明形式"><span class="nav-number">1.1.</span> <span class="nav-text">普通函数的声明形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数类型的简写"><span class="nav-number">1.2.</span> <span class="nav-text">参数类型的简写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的返回值"><span class="nav-number">1.3.</span> <span class="nav-text">函数的返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用函数"><span class="nav-number">1.4.</span> <span class="nav-text">调用函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：将“秒”解析为时间单位"><span class="nav-number">1.5.</span> <span class="nav-text">示例：将“秒”解析为时间单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：函数中的参数传递效果测试"><span class="nav-number">1.6.</span> <span class="nav-text">示例：函数中的参数传递效果测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数变量——把函数作为值保存到变量中"><span class="nav-number">2.</span> <span class="nav-text">函数变量——把函数作为值保存到变量中</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：字符串的链式处理——操作与数据分离的设计技巧"><span class="nav-number">3.</span> <span class="nav-text">示例：字符串的链式处理——操作与数据分离的设计技巧</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#匿名函数——没有函数名字的函数"><span class="nav-number">4.</span> <span class="nav-text">匿名函数——没有函数名字的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义一个匿名函数"><span class="nav-number">4.1.</span> <span class="nav-text">定义一个匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名函数用作回调函数"><span class="nav-number">4.2.</span> <span class="nav-text">匿名函数用作回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用匿名函数实现操作封装"><span class="nav-number">4.3.</span> <span class="nav-text">使用匿名函数实现操作封装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数类型实现接口——把函数作为接口来调用"><span class="nav-number">5.</span> <span class="nav-text">函数类型实现接口——把函数作为接口来调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体实现接口"><span class="nav-number">5.1.</span> <span class="nav-text">结构体实现接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数体实现接口"><span class="nav-number">5.2.</span> <span class="nav-text">函数体实现接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP包中的例子"><span class="nav-number">5.3.</span> <span class="nav-text">HTTP包中的例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包（Closure）——引用了外部变量的匿名函数"><span class="nav-number">6.</span> <span class="nav-text">闭包（Closure）——引用了外部变量的匿名函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在闭包内部修改引用的变量"><span class="nav-number">6.1.</span> <span class="nav-text">在闭包内部修改引用的变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：闭包的记忆效应"><span class="nav-number">6.2.</span> <span class="nav-text">示例：闭包的记忆效应</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：闭包实现生成器"><span class="nav-number">6.3.</span> <span class="nav-text">示例：闭包实现生成器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可变参数——参数数量不固定的函数形式"><span class="nav-number">7.</span> <span class="nav-text">可变参数——参数数量不固定的函数形式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fmt包中的例子"><span class="nav-number">7.1.</span> <span class="nav-text">fmt包中的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历可变参数列表——获取每一个参数的值"><span class="nav-number">7.2.</span> <span class="nav-text">遍历可变参数列表——获取每一个参数的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获得可变参数类型——获得每一个参数的类型"><span class="nav-number">7.3.</span> <span class="nav-text">获得可变参数类型——获得每一个参数的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在多个可变参数函数中传递参数"><span class="nav-number">7.4.</span> <span class="nav-text">在多个可变参数函数中传递参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#延迟执行语句（defer）"><span class="nav-number">8.</span> <span class="nav-text">延迟执行语句（defer）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多个延迟执行语句的处理顺序"><span class="nav-number">8.1.</span> <span class="nav-text">多个延迟执行语句的处理顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用延迟执行语句在函数退出时释放资源"><span class="nav-number">8.2.</span> <span class="nav-text">使用延迟执行语句在函数退出时释放资源</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理运行时发生的错误"><span class="nav-number">9.</span> <span class="nav-text">处理运行时发生的错误</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#net包中的例子"><span class="nav-number">9.1.</span> <span class="nav-text">net包中的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误接口的定义格式"><span class="nav-number">9.2.</span> <span class="nav-text">错误接口的定义格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义一个错误"><span class="nav-number">9.3.</span> <span class="nav-text">自定义一个错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：在解析中使用自定义错误"><span class="nav-number">9.4.</span> <span class="nav-text">示例：在解析中使用自定义错误</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宕机（panic）——程序终止运行"><span class="nav-number">10.</span> <span class="nav-text">宕机（panic）——程序终止运行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#手动触发宕机"><span class="nav-number">10.1.</span> <span class="nav-text">手动触发宕机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在运行依赖的必备资源缺失时主动触发宕机"><span class="nav-number">10.2.</span> <span class="nav-text">在运行依赖的必备资源缺失时主动触发宕机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在宕机时触发延迟执行语句"><span class="nav-number">10.3.</span> <span class="nav-text">在宕机时触发延迟执行语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宕机恢复（recover）——防止程序崩溃"><span class="nav-number">11.</span> <span class="nav-text">宕机恢复（recover）——防止程序崩溃</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#让程序在崩溃时继续执行"><span class="nav-number">11.1.</span> <span class="nav-text">让程序在崩溃时继续执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#panic和recover的关系"><span class="nav-number">11.2.</span> <span class="nav-text">panic和recover的关系</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
