<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go语言从入门到进阶实战">
<meta property="og:type" content="article">
<meta property="og:title" content="第9章 并发">
<meta property="og:url" content="http://yoursite.com/2021/08/19/第9章-并发/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第9章-并发/1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第9章-并发/2.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第9章-并发/t-1.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第9章-并发/3.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第9章-并发/4.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第9章-并发/5.jpg">
<meta property="og:image" content="http://yoursite.com/2021/08/19/第9章-并发/t-2.jpg">
<meta property="og:updated_time" content="2021-08-31T02:57:04.786Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第9章 并发">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="twitter:image" content="http://yoursite.com/2021/08/19/第9章-并发/1.jpg">






  <link rel="canonical" href="http://yoursite.com/2021/08/19/第9章-并发/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第9章 并发 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/19/第9章-并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第9章 并发

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-19 09:14:17" itemprop="dateCreated datePublished" datetime="2021-08-19T09:14:17+08:00">2021-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-08-31 10:57:04" itemprop="dateModified" datetime="2021-08-31T10:57:04+08:00">2021-08-31</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">31k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">29 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>并发指在同一时间内可以执行多个任务。并发编程含义比较广泛，包含多线程编程、多进程编程及分布式程序等。本章讲解的并发含义属于多线程编程。</p>
<p>Go语言通过编译器运行时（runtime），从语言上支持了并发的特性。Go语言的并发通过goroutine特性完成。goroutine类似于线程，但是可以根据需要创建多个goroutine并发工作。goroutine是由Go语言的运行时调度完成，而线程是由操作系统调度完成。</p>
<p>Go语言还提供channel在多个goroutine间进行通信。goroutine和channel是Go语言秉承的CSP（Communicating Sequential Process）并发模式的重要实现基础。本章中，将详细为大家讲解goroutine和channel及相关特性。</p>
<h1 id="轻量级线程（goroutine）——根据需要随时创建的“线程”"><a href="#轻量级线程（goroutine）——根据需要随时创建的“线程”" class="headerlink" title="轻量级线程（goroutine）——根据需要随时创建的“线程”"></a><span style="color:#339AFF;">轻量级线程（goroutine）——根据需要随时创建的“线程”</span></h1><p>在编写Socket网络程序时，需要提前准备一个线程池为每一个Socket的收发包分配一个线程。开发人员需要在线程数量和CPU数量间建立一个对应关系，以保证每个任务能及时地被分配到CPU上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。</p>
<p>虽然，线程池为逻辑编写者提供了线程分配的抽象机制。但是，如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到CPU上，让这些任务尽量并发运作。这种机制在Go语言中被称为goroutine。</p>
<p>goroutine的概念类似于线程，但goroutine由Go程序运行时的调度和管理。Go程序会智能地将goroutine中的任务合理地分配给每个CPU。</p>
<p>Go程序从main包的main()函数开始，在程序启动时，Go程序就会为main()函数创建一个默认的goroutine.</p>
<h2 id="用普通函数创建goroutine"><a href="#用普通函数创建goroutine" class="headerlink" title="用普通函数创建goroutine"></a><span style="color:#00ACC1;">用普通函数创建goroutine</span></h2><p>Go程序中使用go关键字为一个函数创建一个goroutine。一个函数可以被创建多个goroutine，一个goroutine必定对应一个函数。</p>
<p><strong>1，格式</strong></p>
<p>为一个普通函数创建goroutine的写法如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名 (参数列表)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>函数名：要调用的函数名。</li>
<li>参数列表：调用函数需要传入的参数。</li>
</ul>
<p>使用go关键字创建goroutine时，被调用函数的返回值会被忽略。</p>
<blockquote>
<p>提示：如果需要在goroutine中返回数据，请使用9.2节介绍的通道（channel）特性，通过通道把数据从goroutine中作为返回值传出。</p>
</blockquote>
<p><strong>2，例子</strong></p>
<p>使用go关键字，将running()函数并发执行，每隔一秒打印一次计数器，而main的goroutine则等待用户输入，两个行为可以同时进行。请参考下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">running</span> <span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 构建一个无限循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        times++</span><br><span class="line">        fmt.Println(<span class="string">"tick"</span>, times)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延时1秒</span></span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发执行程序</span></span><br><span class="line">    <span class="keyword">go</span> running()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受命令行输入，不做任何事情</span></span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>命令行输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tick 1</span><br><span class="line">tick 2</span><br><span class="line">tick 3</span><br><span class="line">tick 4</span><br><span class="line">tick 5</span><br></pre></td></tr></table></figure></p>
<p>代码执行后，命令行会不断地输出tick，同时可以使用fmt.Scanln()接受用户输入。两个环节可以同时进行。</p>
<p>代码说明如下：</p>
<ul>
<li>第12行，使用for形成一个无限循环。</li>
<li>第13行，times变量在循环中不断自增。</li>
<li>第14行，输出times变量的值。</li>
<li>第17行，使用time.Sleep暂停1秒后继续循环。</li>
<li>第25行，使用go关键字让running()函数并发运行。</li>
<li>第29行，接受用户输入，直到按Enter键时将输入的内容写入input变量中并返回，整个程序终止。</li>
</ul>
<p>这段代码的执行顺序如图9-1所示。</p>
<blockquote>
<p>图9-1 并发运行图</p>
</blockquote>
<img src="/2021/08/19/第9章-并发/1.jpg">
<p>这个例子中，Go程序在启动时，运行时（runtime）会默认为main()函数创建一个goroutine。在main()函数的goroutine中执行到go running语句时，归属于running()函数的goroutine被创建，running()函数开始在自己的goroutine中执行。此时，main()继续执行，两个goroutine通过Go程序的调度机制同时运作。</p>
<h2 id="使用匿名函数创建goroutine"><a href="#使用匿名函数创建goroutine" class="headerlink" title="使用匿名函数创建goroutine"></a><span style="color:#00ACC1;">使用匿名函数创建goroutine</span></h2><p>go关键字后也可以为匿名函数或闭包启动goroutine。</p>
<p><strong>1，使用匿名函数创建goroutine的格式</strong></p>
<p>使用匿名函数或闭包创建goroutine时，除了将函数定义部分写在go的后面之外，还需要加上匿名函数的调用参数，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(参数列表)</span></span> &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125; ( 调用参数列表 )</span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数列表：函数体内的参数变量列表。</li>
<li>函数体：匿名函数的代码。</li>
<li>调用参数列表：启动goroutine时，需要向匿名函数传递的调用参数。</li>
</ul>
<p><strong>2，使用匿名函数创建goroutine的例子</strong></p>
<p>在main()函数中创建一个匿名函数并为匿名函数启动goroutine。匿名函数没有参数。代码将并行执行定时打印计数的效果。参见下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> times <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            times++</span><br><span class="line">            fmt.Println(<span class="string">"tick"</span>, times)</span><br><span class="line"></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> input <span class="keyword">string</span></span><br><span class="line">    fmt.Scanln(&amp;input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第10行，go后面接匿名函数启动goroutine。</li>
<li>第12～19行的逻辑与前面程序的running()函数一致。</li>
<li>第21行的括号的功能是调用匿名函数的参数列表。由于第10行的匿名函数没有参数，因此第21行的参数列表也是空的。</li>
</ul>
<blockquote>
<p>提示：所有goroutine在main()函数结束时会一同结束。<br><br>goroutine虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于Go程序的goroutine调度器的实现和运行环境。<br><br>终止goroutine的最好方法就是自然返回goroutine对应的函数。虽然可以用golang.org/x/net/context包进行goroutine生命期深度控制，但这种方法仍然处于内部试验阶段，并不是官方推荐的特性。<br><br>截止Go 1.9版本，暂时没有标准接口获取goroutine的ID。</p>
</blockquote>
<h2 id="调整并发的运行性能（GOMAXPROCS）"><a href="#调整并发的运行性能（GOMAXPROCS）" class="headerlink" title="调整并发的运行性能（GOMAXPROCS）"></a><span style="color:#00ACC1;">调整并发的运行性能（GOMAXPROCS）</span></h2><p>在Go程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go程序调度器可以高效地将CPU资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与CPU核心数量的对应关系。同样的，Go中也可以通过runtime.GOMAXPROCS()函数做到，格式为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(逻辑CPU数量)</span><br></pre></td></tr></table></figure></p>
<p>这里的逻辑CPU数量可以有如下几种数值：</p>
<ul>
<li>&lt;1：不修改任何数值。</li>
<li>=1：单核心执行。</li>
<li>>1：多核并发执行。</li>
</ul>
<p>一般情况下，可以使用runtime.NumCPU()查询CPU数量，并使用runtime.GOMAXPROCS()函数进行设置，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br></pre></td></tr></table></figure></p>
<p>Go 1.5版本之前，默认使用的是单核心执行。从Go 1.5版本开始，默认执行上面语句以便让代码并发执行，最大效率地利用CPU。</p>
<p>GOMAXPROCS同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。</p>
<h2 id="理解并发和并行"><a href="#理解并发和并行" class="headerlink" title="理解并发和并行"></a><span style="color:#00ACC1;">理解并发和并行</span></h2><p>在讲解并发概念时，总会涉及另外一个概念并行。下面让我们来了解并发和并行之间的区别。</p>
<ul>
<li>并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li>
<li>并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li>
</ul>
<p>两个概念的区别是：任务是否同时执行。举一个生活中的例子：打电话和吃饭。</p>
<p>吃饭时，电话来了，需要停止吃饭去接电话。电话接完后回来继续吃饭，这个过程是并发执行。</p>
<p>吃饭时，电话来了，边吃饭边接电话。这个过程是并行执行。</p>
<p>GO在GOMAXPROCS数量与任务数量相等时，可以做到并行执行，但一般情况下都是并发执行。</p>
<h2 id="Go语言的协作程序（goroutine）和普通的协作程序（coroutine）"><a href="#Go语言的协作程序（goroutine）和普通的协作程序（coroutine）" class="headerlink" title="Go语言的协作程序（goroutine）和普通的协作程序（coroutine）"></a><span style="color:#00ACC1;">Go语言的协作程序（goroutine）和普通的协作程序（coroutine）</span></h2><p>C#、Lua、Python语言都支持coroutine特性。coroutine与goroutine在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：</p>
<ul>
<li>goroutine可能发生并行执行；但coroutine始终顺序执行。</li>
</ul>
<p>狭义地说，goroutine可能发生在多线程环境下，goroutine无法控制自己获取高优先度支持；coroutine始终发生在单线程，coroutine程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他coroutine。</p>
<ul>
<li>goroutine间使用channel通信；coroutine使用yield和resume操作。</li>
</ul>
<p>goroutine和coroutine的概念和运行机制都是脱胎于早期的操作系统。</p>
<p>coroutine的运行机制属于协作式任务处理，早期的操作系统要求每一个应用必须遵守操作系统的任务处理规则，应用程序在不需要使用CPU时，会主动交出CPU使用权。如果开发者无意间或者故意让应用程序长时间占用CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。</p>
<p>goroutine属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对CPU的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用CPU，那么用户有权终止这个任务。</p>
<h1 id="通道（channel）——在多个goroutine间通信的管道"><a href="#通道（channel）——在多个goroutine间通信的管道" class="headerlink" title="通道（channel）——在多个goroutine间通信的管道"></a><span style="color:#339AFF;">通道（channel）——在多个goroutine间通信的管道</span></h1><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p>
<p>Go语言提倡使用通信的方法代替共享内存，这里通信的方法就是使用通道（channel），如图9-2所示。</p>
<blockquote>
<p>图9-2 goroutine与channel的通信</p>
</blockquote>
<img src="/2021/08/19/第9章-并发/2.jpg">
<blockquote>
<p>提示：在地铁站、食堂、洗手间等公共场所人很多的情况下，大家养成了排队的习惯，目的也是避免拥挤、插队导致的低效的资源使用和交换过程，代码与数据也是如此。多个goroutine为了争抢数据，势必造成执行的低效率，使用队列的方式是最高效的，channel就是一种队列一样的结构。</p>
</blockquote>
<h2 id="通道的特性"><a href="#通道的特性" class="headerlink" title="通道的特性"></a><span style="color:#00ACC1;">通道的特性</span></h2><p>Go语言中的通道（channel）是一种特殊的类型。在任何时候，同时只能有一个goroutine访问通道进行发送和获取数据。goroutine间通过通道就可以通信。</p>
<p>通道像一个传送带或者队列，总是遵循先入先出（First In First out）的规则，保证收发数据的顺序。</p>
<h2 id="声明通道类型"><a href="#声明通道类型" class="headerlink" title="声明通道类型"></a><span style="color:#00ACC1;">声明通道类型</span></h2><p>通道本身需要一个类型进行修饰，就像切片类型需要标识元素类型。通道的元素类型就是在其内部传输的数据类型，声明如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 通道变量 <span class="keyword">chan</span> 通道类型</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通道类型：通道内的数据类型。</li>
<li>通道变量：保存通道的变量。</li>
</ul>
<p>chan类型的空值是nil，声明后需要配合make后才能使用。</p>
<h2 id="创建通道"><a href="#创建通道" class="headerlink" title="创建通道"></a><span style="color:#00ACC1;">创建通道</span></h2><p>通道是引用类型，需要使用make进行创建，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通道实例 := <span class="built_in">make</span> (<span class="keyword">chan</span> 数据类型)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>数据类型：通道内传输的元素类型。</li>
<li>通道实例：通过make 创建的通道句柄。</li>
</ul>
<p>例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">int</span>)         <span class="comment">// 创建一个整型类型的通道</span></span><br><span class="line">ch2 := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 创建一个空接口类型的通道，可以存放任意格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Equip <span class="keyword">struct</span>（<span class="comment">/* 一些字段 */</span> &#125;</span><br><span class="line">ch2 := <span class="built_in">make</span> (<span class="keyword">chan</span> *Equip)      <span class="comment">// 创建Equip指针类型的通道，可以存放*Equip</span></span><br></pre></td></tr></table></figure></p>
<h2 id="使用通道发送数据"><a href="#使用通道发送数据" class="headerlink" title="使用通道发送数据"></a><span style="color:#00ACC1;">使用通道发送数据</span></h2><p>通道创建后，就可以使用通道进行发送和接收操作。</p>
<p><strong>1，通道发送数据的格式</strong></p>
<p>通道的发送使用特殊的操作符“&lt;-” ，将数据通过通道发送的格式为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通道变量 &lt;- 值</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通道变量：通过make创建好的通道实例。</li>
<li>值：可以是变量、常量、表达式或者函数返回值等。值的类型必须与ch通道的元素类型一致。</li>
</ul>
<p><strong>2，通过通道发送数据的例子</strong></p>
<p>使用make创建一个通道后，就可以使用“&lt;-”向通道发送数据，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空接口通道</span></span><br><span class="line">ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) </span><br><span class="line"><span class="comment">// 将0放入通道中</span></span><br><span class="line">ch &lt;- <span class="number">0</span></span><br><span class="line"><span class="comment">// 将hello字符串放入通道中</span></span><br><span class="line">ch &lt;- <span class="string">"hello"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3，发送将持续阻塞直到数据被接收</strong></p>
<p>把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go程序运行时能智能地发现一些永远无法发送成功的语句并做出提示，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个整形通道</span></span><br><span class="line">    ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将0通过通道发送</span></span><br><span class="line">    ch &lt;- <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行代码，报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure></p>
<p>报错的意思是：运行时发现所有的goroutine（包括main）都处于等待goroutine。也就是说所有goroutine中的channel并没有形成发送和接收对应的代码。</p>
<h2 id="使用通道接收数据"><a href="#使用通道接收数据" class="headerlink" title="使用通道接收数据"></a><span style="color:#00ACC1;">使用通道接收数据</span></h2><p>通道接收同样使用“&lt;-”操作符，通道接收有如下特性：</p>
<ul>
<li>通道的收发操作在不同的两个goroutine间进行。</li>
</ul>
<p>由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个goroutine中进行。</p>
<ul>
<li>接收将持续阻塞直到发送方发送数据。</li>
</ul>
<p>如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。</p>
<ul>
<li>每次接收一个元素。</li>
</ul>
<p>通道一次只能接收一个数据元素。</p>
<p>通道的数据接收一共有以下4种写法。</p>
<p><strong>1，阻塞接收数据</strong></p>
<p>阻塞模式接收数据时，将接收变量作为“&lt;-”操作符的左值，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data := &lt;-ch</span><br></pre></td></tr></table></figure></p>
<p>执行该语句时将会阻塞，直到接收到数据并赋值给data变量。</p>
<p><strong>2，非阻塞接收数据</strong></p>
<p>使用非阻塞方式从通道接收数据时，语句不会发生阻塞，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data, ok := &lt;-ch</span><br></pre></td></tr></table></figure></p>
<ul>
<li>data：表示接收到的数据。未接收到数据时，data为通道类型的零值。</li>
<li>ok：表示是否接收到数据。</li>
</ul>
<p>非阻塞的通道接收方法可能造成高的CPU占用，因此使用非常少。如果需要实现接收超时检测，可以配合select和计时器channel进行，可以参见后面的内容。</p>
<p><strong>3，接收任意数据，忽略接收的数据</strong></p>
<p>阻塞接收数据后，忽略从通道返回的数据，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;-ch</span><br></pre></td></tr></table></figure></p>
<p>执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在goroutine间阻塞收发实现并发同步。</p>
<p>使用通道做并发同步的写法，可以参考下面的例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个通道</span></span><br><span class="line">    ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启一个并发匿名函数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"start goroutine"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过通道通知main的goroutine</span></span><br><span class="line">        ch &lt;- <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"exit goroutine"</span>)</span><br><span class="line"></span><br><span class="line">    &#125; ()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"wait goroutine"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待匿名goroutine</span></span><br><span class="line">    &lt;-ch</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"all done"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第10行，构建一个同步用的通道。</li>
<li>第13行，开启一个匿名函数的并发。</li>
<li>第18行，匿名goroutine即将结束时，通过通道通知main的goroutine，这一句会直阻塞直到main的goroutine接收为止。</li>
<li>第27行，开启goroutine后，马上通过通道等待匿名goroutine结束。</li>
</ul>
<p>执行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait goroutine</span><br></pre></td></tr></table></figure></p>
<p><strong>4，循环接收</strong></p>
<p>通道的数据接收可以借用for range语句进行多个元素的接收操作，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通道ch是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。通过for遍历获得的变量只有一个，即上面例子中的data。</p>
<p>遍历通道数据的例子请参考代码9-1。</p>
<blockquote>
<p>代码9-1 使用for从通道中接收数据（具体文件：…/chapter09/forchan/forchan.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个通道</span></span><br><span class="line">    ch := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启一个并发匿名函数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从3循环到0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">3</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送3到0之间的数值</span></span><br><span class="line">            ch &lt;- i</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次发送完时等待</span></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; ()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历接收通道数据</span></span><br><span class="line">    <span class="keyword">for</span> data := <span class="keyword">range</span> ch &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印通道数据</span></span><br><span class="line">        fmt.Println(data)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当遇到数据0时，退出接收循环</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第12行，通过make生成一个整型元素的通道。</li>
<li>第15行，将匿名函数并发执行。</li>
<li>第18行，用循环生成3到0之间的数值。</li>
<li>第21行，将3到0之间的数值依次发送到通道ch中。</li>
<li>第24行，每次发送后暂停1秒。</li>
<li>第30行，使用for从通道中接收数据。</li>
<li>第33行，将接收到的数据打印出来。</li>
<li>第36行，当接收到数值0时，停止接收。如果继续发送，由于接收goroutine已经退出，没有goroutine发送到通道，因此运行时将会触发宕机报错。</li>
</ul>
<p>执行代码，输出如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="示例：并发打印"><a href="#示例：并发打印" class="headerlink" title="示例：并发打印"></a><span style="color:#00ACC1;">示例：并发打印</span></h2><p>上面的例子创建的都是无缓冲通道。使用无缓冲通道往里面装入数据时，装入方将被阻塞，直到另外通道在另外一个goroutine中被取出。同样，如果通道中没有放入任何数据，接收方试图从通道中获取数据时，同样也是阻塞。发送和接收的操作是同步完成的。</p>
<p>下面的例子中将goroutine和channel放在一起展示它们的用法。</p>
<blockquote>
<p>代码9-2 并发打印（具体文件：…/chapter09/conprint/conprint.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span> <span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始无限循环等待数据</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从channel中获取一个数据</span></span><br><span class="line">        data := &lt;-c</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将0视为数据结束</span></span><br><span class="line">        <span class="keyword">if</span> data == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印数据</span></span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知main已经结束循环（我搞定了！）</span></span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个channel</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发执行printer，传入channel</span></span><br><span class="line">    <span class="keyword">go</span> printer(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据通过channel投送给printer</span></span><br><span class="line">        c &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过并发的printer结束循环（没数据啦！）</span></span><br><span class="line">    c &lt;- <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待printer结束（搞定喊我！）</span></span><br><span class="line">    &lt;-c</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，创建一个无限循环，只有当第16行获取到的数据为0时才会退出循环。</li>
<li>第13行，从函数参数传入的通道中获取一个整型数值。</li>
<li>第21行，打印整型数值。</li>
<li>第25行，在退出循环时，通过通道通知main()函数已经完成工作。</li>
<li>第32行，创建一个整型通道进行跨goroutine的通信。</li>
<li>第35行，创建一个goroutine，并发执行printer()函数。</li>
<li>第37行，构建一个数值循环，将1～10的数通过通道传送给printer构造出的goroutine。</li>
<li>第44行，给通道传入一个0，表示将前面的数据处理完成后，退出循环。</li>
<li>第47行，在数据发送过去后，因为并发和调度的原因，任务会并发执行。这里需要等待printer的第25行返回数据后，才可以退出main()。</li>
</ul>
<p>运行代码，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>本例的设计模式就是典型的生产者和消费者。生产者是第37行的循环，而消费者是printer()函数。整个例子使用了两个goroutine，一个是main()，一个是通过第35行printer()函数创建的goroutine，两个goroutine通过第32行创建的通道进行通信。这个通道有下面两重功能。</p>
<ul>
<li>数据传送：第40行中发送数据和第13行接收数据。</li>
<li>控制指令：类似于信号量的功能。同步goroutine的操作。功能简单描述为：<ul>
<li>第44行：“没数据啦！”</li>
<li>第25行：“我搞定了！”</li>
<li>第47行：“搞定喊我！”</li>
</ul>
</li>
</ul>
<h2 id="单向通道——通道中的单行道"><a href="#单向通道——通道中的单行道" class="headerlink" title="单向通道——通道中的单行道"></a><span style="color:#00ACC1;">单向通道——通道中的单行道</span></h2><p>Go的通道可以在声明时约束其操作方向，如只发送或是只接收。这种被约束方向的通道被称做单向通道。</p>
<p><strong>1，单向通道的声明格式</strong></p>
<p>只能发送的通道类型为chan&lt;-，只能接收的通道类型为&lt;-chan，格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 通道实例 <span class="keyword">chan</span>&lt;- 元素类型 <span class="comment">// 只能发送通道</span></span><br><span class="line"><span class="keyword">var</span> 通道实例 &lt;-<span class="keyword">chan</span> 元素类型 <span class="comment">// 只能接收通道</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>元素类型：通道包含的元素类型。</li>
<li>通道实例：声明的通道变量。</li>
</ul>
<p><strong>2，单向通道的使用例子</strong></p>
<p>示例代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 声明一个只能发送的通道类型，并赋值为ch</span></span><br><span class="line"><span class="keyword">var</span> chSendonly <span class="keyword">chan</span>&lt;- <span class="keyword">int</span> = ch</span><br><span class="line"><span class="comment">// 声明一个只能接收的通道类型，并赋值为ch</span></span><br><span class="line"><span class="keyword">var</span> chRecvOnly &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = ch</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中，chSendOnly只能发送数据，如果尝试接收数据，将会出现如下报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid operation: &lt;-chSendOnly (receive from send-only type chan&lt;- int)</span><br></pre></td></tr></table></figure></p>
<p>同理，chRecvOnly也是不能发送的。</p>
<p>当然，使用make创建通道时，也可以创建一个只发送或只读取的通道：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chReadonly &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = ch</span><br><span class="line">&lt;-chReadonly</span><br></pre></td></tr></table></figure></p>
<p>上面代码编译正常，运行也是正确的。但是，一个不能填充数据（发送）只能读取的通道是毫无意义的。</p>
<p><strong>3，time包中的单向通道</strong></p>
<p>time包中的计时器会返回一个timer实例，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(time.Second)</span><br></pre></td></tr></table></figure></p>
<p>timer的Timer类型定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    C &lt;-<span class="keyword">chan</span> Time</span><br><span class="line">    r runtimeTimer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第2行中C通道的类型就是一种只能接收的单向通道。如果此处不进行通道方向约束，一旦外部向通道发送数据，将会造成其他使用到计时器的地方逻辑产生混乱。</p>
<p>因此，单向通道有利于代码接口的严谨性。</p>
<h2 id="带缓冲的通道"><a href="#带缓冲的通道" class="headerlink" title="带缓冲的通道"></a><span style="color:#00ACC1;">带缓冲的通道</span></h2><p>在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞。同理，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞。</p>
<blockquote>
<p>提示：无缓冲通道保证收发过程同步。无缓冲收发过程类似于快递员给你电话让你下楼取快递，整个递交快递的过程是同步发生的，你和快递员不见不散。但这样做快递员就必须等待所有人下楼完成操作后才能完成所有投递工作。如果快递员将快递放入快递柜中，并通知用户来取，快递员和用户就成了异步收发过程，效率可以有明显的提升。带缓冲的通道就是这样的一个“快递柜”。</p>
</blockquote>
<p><strong>1，创建带缓冲通道</strong></p>
<p>如何创建带缓冲的通道呢？参见如下代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通道实例 := <span class="built_in">make</span>(<span class="keyword">chan</span>通道类型, 缓冲大小)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。</li>
<li>缓冲大小：决定通道最多可以保存的元素数量。</li>
<li>通道实例：被创建出的通道实例。</li>
</ul>
<p>下面通过一个例子中来理解带缓冲通道的用法，参见下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个3个元素缓冲大小的整型通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看当前通道的大小</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(ch))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送3个整型元素到通道</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看当前通道的大小</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(ch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第8行，创建一个带有3个元素缓冲大小的整型类型的通道。</li>
<li>第11行，查看当前通道的大小。带缓冲的通道在创建完成时，内部的元素是空的，因此使用len()获取到的返回值为0。</li>
<li>第14～16行，发送3个整型元素到通道。因为使用了缓冲通道。即便没有goroutine接收，发送者也不会发生阻塞。</li>
<li>第19行，由于填充了3个通道，此时的通道长度变为3。</li>
</ul>
<p><strong>2，阻塞条件</strong></p>
<p>带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为0的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞：</p>
<p>（1）带缓冲通道被填满时，尝试再次发送数据时发生阻塞。</p>
<p>（2）带缓冲通道为空时，尝试接收数据时发生阻塞。</p>
<blockquote>
<p>提示：为什么Go语言对通道要限制长度而不提供无限长度的通道？<br><br>我们知道通道（channel）是在两个goroutine间通信的桥梁。使用goroutine的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。</p>
</blockquote>
<h2 id="通道的多路复用——同时处理接收和发送多个通道的数据"><a href="#通道的多路复用——同时处理接收和发送多个通道的数据" class="headerlink" title="通道的多路复用——同时处理接收和发送多个通道的数据"></a><span style="color:#00ACC1;">通道的多路复用——同时处理接收和发送多个通道的数据</span></h2><p>多路复用是通信和网络中的一个专业术语。多路复用通常表示在一个信道上传输多路信号或数据流的过程和技术。</p>
<blockquote>
<p>提示：报话机同一时刻只能有一边进行收或者发的单边通信，报话机需要遵守的通信流程如下：<br><br>（1）说话方在完成时需要补上一句“完毕” ，随后放开通话按钮，从发送切换到接收状态，收听对方说话。<br><br>（2）收听方在听到对方说“完毕”时，按下通话按钮，从接收切换到发送状态，开始说话。<br><br>电话可以在说话的同时听到对方说话，所以电话是一种多路复用的设备，一条通信线路上可以同时接收或者发送数据。同样的，网线、光纤也都是基于多路复用模式来设计的，网线、光纤不仅可支持同时收发数据，还支持多个人同时收发数据。</p>
</blockquote>
<p>在使用通道时，想同时接收多个通道的数据是一件困难的事情。通道在接收数据时，如果没有数据可以接收将会发生阻塞。虽然可以使用如下模式进行遍历，但运行性能会非常差。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试接收ch1通道</span></span><br><span class="line">    data, ok := &lt;-ch1</span><br><span class="line">    <span class="comment">// 尝试接收ch2通道</span></span><br><span class="line">    data, ok := &lt;-ch2</span><br><span class="line">    <span class="comment">// 接收后续通道</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Go语言中提供了select关键字，可以同时响应多个通道的操作。select的每个case都会对应一个通道的收发过程。当收发完成时，就会触发case中响应的语句。多个操作在每次select中挑选一个进行响应。格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> 操作<span class="number">1</span>:</span><br><span class="line">        响应操作<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> 操作<span class="number">2</span>:</span><br><span class="line">        响应操作<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        没有操作情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>操作1、操作2：包含通道收发语句，请参考表9-1。</li>
</ul>
<blockquote>
<p>表9-1 select多路复用中可以接收的样式</p>
</blockquote>
<img src="/2021/08/19/第9章-并发/t-1.jpg">
<ul>
<li>响应操作1、响应操作2：当操作发生时，会执行对应case的响应操作。</li>
<li>default：当没有任何操作时，默认执行default中的语句。</li>
</ul>
<p>select的详细使用方法，请参考远程过程调用的示例。</p>
<h2 id="示例：模拟远程过程调用（RPC）"><a href="#示例：模拟远程过程调用（RPC）" class="headerlink" title="示例：模拟远程过程调用（RPC）"></a><span style="color:#00ACC1;">示例：模拟远程过程调用（RPC）</span></h2><p>服务器开发中会使用RPC（Remote Procedure Call，远程过程调用）简化进程间通信的过程。RPC能有效地封装通信过程，让远程的数据收发通信过程看起来就像本地的函数调用一样。</p>
<p>本例中，使用通道代替Socket实现RPC的过程。客户端与服务器运行在同一个进程，服务器和客户端在两个goroutine中运行。</p>
<p><strong>1，客户端请求和接收封装</strong></p>
<p>下面的代码封装了向服务器请求数据，等待服务器返回数据，如果请求方超时，该函数还会处理超时逻辑，详细实现过程请参考代码9-3。</p>
<blockquote>
<p>代码9-3 模拟RPC（具体文件：…/chapter09/rpc/rpc.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟RPC客户端的请求和接收消息封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RPCClient</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>, req <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务器发送请求</span></span><br><span class="line">    ch &lt;- req</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待服务器返回</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ack := &lt;-ch: <span class="comment">// 接收到服务器返回数据</span></span><br><span class="line">        <span class="keyword">return</span> ack, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 超时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Time out"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第5行，模拟socket向服务器发送一个字符串信息。服务器接收后，结束阻塞执行下一行。</li>
<li>第8行，使用select开始做多路复用。注意，select虽然在写法上和switch一样，都可以拥有case和default，但是select关键字后面不接任何语句，而是将要复用的多个通道语句写在每一个case上，如第9行和第11行所示。</li>
<li>第11行，使用了time包提供的函数After()，从字面意思看就是多少时间之后，其参数是time包的一个常量，time.Second表示1秒。time.After返回一个通道，这个通道在指定时间后，通过通道返回当前时间。</li>
<li>第12行，在超时时，返回超时错误。</li>
</ul>
<p>RPCClient()函数中，执行到select语句时，第9行和第11行的通道操作会同时开启。如果第9行的通道先返回，则执行第10行逻辑，表示正常接收到服务器数据；如果第11行的通道先返回，则执行第12行的逻辑，表示请求超时，返回错误。</p>
<p><strong>2，服务器接收和反馈数据</strong></p>
<p>服务器接收到客户端的任意数据后，先打印再通过通道返回给客户端一个固定字符串，表示服务器已经收到请求。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟RPC服务器端接收客户端请求和回应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RPCServer</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 接收客户端请求</span></span><br><span class="line">        data := &lt;-ch</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接收到的数据</span></span><br><span class="line">        fmt.Println(<span class="string">"server received:"</span>, data)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反馈给客户端收到</span></span><br><span class="line">        ch &lt;- <span class="string">"roger"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第3行，构造出一个无限循环。服务器处理完客户端请求后，通过无限循环继续处理下一个客户端请求。</li>
<li>第5行，通过字符串通道接收一个客户端的请求。</li>
<li>第8行，将接收到的数据打印出来。</li>
<li>第11行，给客户端反馈一个字符串。</li>
</ul>
<p>运行整个程序，客户端可以正确收到服务器返回的数据，客户端RPCClient()函数的代码按下面代码中加粗部分的分支执行。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待服务器返回</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ack := &lt;-ch: <span class="comment">// 接收到服务器返回数据</span></span><br><span class="line">    <span class="keyword">return</span> ack, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 超时</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Time out"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server received: hi</span><br><span class="line">client received roger</span><br></pre></td></tr></table></figure></p>
<p><strong>3，模拟超时</strong></p>
<p>上面的例子虽然有客户端超时处理，但是永远不会触发，因为服务器的处理速度很快，也没有真正的网络延时或者“服务器宕机”的情况。因此，为了展示select中超时的处理，在服务器逻辑中增加一条语句，故意让服务器延时处理一段时间，造成客户端请求超时，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟RPC服务器端接收客户端请求和回应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RPCServer</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 接收客户端请求</span></span><br><span class="line">        data := &lt;-ch</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接收到的数据</span></span><br><span class="line">        fmt.Println(<span class="string">"server received:"</span>, data)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反馈给客户端收到</span></span><br><span class="line">        ch &lt;- <span class="string">"roger"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第11行中，time.Sleep()函数会让goroutine执行暂停2秒。使用这种方法模拟服务器延时，造成客户端超时。客户端处理超时1秒时通道就会返回：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待服务器返回</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ack := &lt;-ch: <span class="comment">// 接收到服务器返回数据</span></span><br><span class="line">    <span class="keyword">return</span> ack, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 超时</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>, errors.New(<span class="string">"Time out"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，第5和第6行的代码就会被执行。</p>
<p><strong>4，主流程</strong></p>
<p>主流程中会创建一个无缓冲的字符串格式通道。将通道传给服务器的RPCServer）函数，这个函数并发执行。使用RPCClient()函数通过ch对服务器发出RPC请求，同时接收服务器反馈数据或者等待超时。参考下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个无缓冲字符串通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发执行服务器逻辑</span></span><br><span class="line">    <span class="keyword">go</span> RPCServer(ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端请求数据和接收数据</span></span><br><span class="line">    recv, err := RPCClient(ch, <span class="string">"hi"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 发生错误打印</span></span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常接收到数据</span></span><br><span class="line">        fmt.Println(<span class="string">"client received"</span>, recv)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第4行，创建无缓冲的字符串通道，这个通道用于模拟网络和socket概念，既可以从通道接收数据，也可以发送。</li>
<li>第7行，并发执行服务器逻辑。服务器一般都是独立进程的，这里使用并发将服务器和客户端逻辑同时在一个进程内运行。</li>
<li>第10行，使用RPCClient()函数，发送“hi”给服务器，同步等待服务器返回。</li>
<li>第13行，如果通信过程发生错误，打印错误。</li>
<li>第16行，正常接收时，打印收到的数据。</li>
</ul>
<h2 id="示例：使用通道响应计时器的事件"><a href="#示例：使用通道响应计时器的事件" class="headerlink" title="示例：使用通道响应计时器的事件"></a><span style="color:#00ACC1;">示例：使用通道响应计时器的事件</span></h2><p>Go语言中的time包提供了计时器的封装。由于Go语言中的通道和goroutine的设计，定时任务可以在goroutine中通过同步的方式完成，也可以通过在goroutine中异步回调完成。这里将分两种用法进行例子展示。</p>
<p><strong>1，一段时间之后（time.After）</strong></p>
<blockquote>
<p>代码9-4 延迟回调（具体文件：…/chapter09/delaycal/delaycall.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个退出用的通道</span></span><br><span class="line">    exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印开始</span></span><br><span class="line">    fmt.Println(<span class="string">"start"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过1秒后，调用匿名函数</span></span><br><span class="line">    time.AfterFunc(time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1秒后，打印结果</span></span><br><span class="line">        fmt.Println(<span class="string">"one second after"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知main的goroutine已经结束</span></span><br><span class="line">        exit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待结束</span></span><br><span class="line">    &lt;-exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，声明一个退出用的通道，往这个通道里写数据表示退出。</li>
<li>第16行，调用time.AfterFunc()函数，传入等待的时间和一个回调。回调使用一个匿名函数，在时间到达后，匿名函数会在另外一个goroutine中被调用。</li>
<li>第22行，任务完成后，往退出通道中写入数值表示需要退出。</li>
<li>第26行，运行到此处时持续阻塞，直到1秒后第22行被执行后结束阻塞。</li>
</ul>
<p>time.AfterFunc()函数是在time.After基础上增加了到时的回调，方便使用。</p>
<p>而time.After()函数又是在time.NewTimer()函数上进行的封装，下面的例子展示如何使用timer.NewTimer()和time.NewTicker()。</p>
<p><strong>2，定点计时</strong></p>
<p>计时器（Timer）的原理和倒计时闹钟类似，都是给定多少时间后触发。打点器（Ticker）的原理和钟表类似，钟表每到整点就会触发。这两种方法创建后会返回time.Ticker对象和time.Timer对象，里面通过一个C成员，类型是只能接收的时间通道（&lt;-chan Time） ，使用这个通道就可以获得时间触发的通知。</p>
<p>下面代码创建一个打点器，每500毫秒触发一起；创建一个计时器， 2秒后触发，只触发一次。</p>
<blockquote>
<p>代码9-5 计时器（具体文件：…/chapter09/timer/timer.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个断续器，每500毫秒触发一次</span></span><br><span class="line">    ticker := time.NewTicker(time.Millisecond * <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个计时器，2秒后触发</span></span><br><span class="line">    stopper := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明计数变量</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的检查通道情况</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多路复用通道</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stopper.C: <span class="comment">// 计时器到时了</span></span><br><span class="line"></span><br><span class="line">            fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳出循环</span></span><br><span class="line">            <span class="keyword">goto</span> StopHere</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C: <span class="comment">// 断续器触发了</span></span><br><span class="line">            <span class="comment">// 记录触发了多少次</span></span><br><span class="line">            i++</span><br><span class="line">            fmt.Println(<span class="string">"tick"</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出的标签，使用goto跳转</span></span><br><span class="line">StopHere:</span><br><span class="line">    fmt.Println(<span class="string">"done"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第11行，创建一个打点器，500毫秒触发一次，返回*time.Ticker类型变量。</li>
<li>第14行，创建一个计时器，2秒后返回，返回*time.Timer类型变量。</li>
<li>第17行，声明一个变量，用于累计打点器触发次数。</li>
<li>第20行，每次触发后，select会结束，需要使用循环再次从打点器返回的通道中获取触发通知。</li>
<li>第23行，同时等待多路计时器信号。</li>
<li>第24行，计时器信号到了。</li>
<li>第29行，通过goto跳出循环.</li>
<li>第31行，打点器信号到了，通过i自加记录触发次数并打印。</li>
</ul>
<h2 id="关闭通道后继续使用通道"><a href="#关闭通道后继续使用通道" class="headerlink" title="关闭通道后继续使用通道"></a><span style="color:#00ACC1;">关闭通道后继续使用通道</span></h2><p>通道是一个引用对象，和map类似。map在没有任何外部引用时，Go程序在运行时（runtime）会自动对内存进行垃圾回收（Garbage Collection，GC）。类似的，通道也可以被垃圾回收，但是通道也可以被主动关闭。</p>
<p><strong>1，格式</strong></p>
<p>使用close()来关闭一个通道：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></p>
<p>关闭的通道依然可以被访问，访问被关闭的通道将会发生一些问题。</p>
<p><strong>2，给被关闭通道发送数据将会触发panic</strong></p>
<p>被关闭的通道不会被置为nil，如果尝试对已经关闭的通道进行发送，将会触发宕机，代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 创建一个整型的通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印通道的指针，容量和长度</span></span><br><span class="line">    fmt.Printf(<span class="string">"ptr:%p cap:%d len:%d\n\n"</span>, ch, <span class="built_in">cap</span>(ch), <span class="built_in">len</span>(ch))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给关闭的通道发送数据</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第7行，创建一个整型通道。</li>
<li>第10行，关闭通道，注意ch不会被close设置为nil，依然可以被访问。</li>
<li>第13行，打印已经关闭通道的指针、容量和长度。</li>
<li>第16行，尝试给已经关闭的通道发送数据。</li>
</ul>
<p>代码运行后触发宕机：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: send on closed channel</span><br></pre></td></tr></table></figure></p>
<p>提示触发宕机的原因是给一个已经关闭的通道发送数据。</p>
<p><strong>3，从已关闭的通道接收数据时将不会发生阻塞</strong></p>
<p>从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。</p>
<blockquote>
<p>代码9-6 操作关闭后的通道（具体文件：…/chapter09/closedchannel/closedchannel.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个整形带2个缓冲的通道</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给通道放入两个数据</span></span><br><span class="line">    ch &lt;- <span class="number">0</span></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭缓冲</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历缓冲所有数据，且多遍历1个</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ch)+<span class="number">1</span>; i++ &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从通道中取出数据</span></span><br><span class="line">        v, ok := &lt;-ch</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印取出数据的状态</span></span><br><span class="line">        fmt.Println(v, ok)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第7行，创建一个能保存两个元素的带缓冲的通道，类型为整型。</li>
<li>第10行和第11行，给这个带缓冲的通道放入两个数据。这时，通道装满了。</li>
<li>第14行，关闭通道。此时，带缓冲通道的数据不会被释放，通道也没有消失。</li>
<li>第17行， cap0函数可以获取一个对象的容量，这里获取的是带缓冲通道的容量，也就是这个通道在make时的大小。虽然此时这个通道的元素个数和容量都是相同的，但是cap取出的并不是元素个数。这里多遍历一个元素，故意造成这个通道的超界访问。</li>
<li>第20行，从已关闭的通道中获取数据，取出的数据放在v变量中，类型为into ok变量的结果表示数据是否获取成功。</li>
<li>第23行，将v和ok变量打印出来。</li>
</ul>
<p>代码运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 true</span><br><span class="line">1 true</span><br><span class="line">0 false</span><br></pre></td></tr></table></figure></p>
<p>运行结果前两行正确输出带缓冲通道的数据，表明缓冲通道在关闭后依然可以访问内部的数据。</p>
<p>运行结果第三行的“0 false”表示通道在关闭状态下取出的值。0表示这个通道的默认值，false表示没有获取成功，因为此时通道已经空了。我们发现，在通道关闭后，即便通道没有数据，在获取时也不会发生阻塞，但此时取出数据会失败。</p>
<h1 id="示例：Telnet回音服务器——TCP服务器的基本结构"><a href="#示例：Telnet回音服务器——TCP服务器的基本结构" class="headerlink" title="示例：Telnet回音服务器——TCP服务器的基本结构"></a><span style="color:#339AFF;">示例：Telnet回音服务器——TCP服务器的基本结构</span></h1><p>Telnet协议是TCP/IP协议族中的一种。它允许用户（Telnet客户端）通过一个协商过程与一个远程设备进行通信。本例将使用一部分Telnet协议与服务器进行通信。</p>
<p>服务器的网络库为了完整展示自己的代码实现了完整的收发过程，一般比较倾向于使用发送任意封包返回原数据的逻辑。这个过程类似于对着大山高喊，大山把你的声音原样返回的过程。也就是回音（Echo）。本节使用Go语言中的Socket，goroutine和通道编写一个简单的Telnet协议的回音服务器。</p>
<p>回音服务器的代码分为4个部分，分别是接受连接、会话处理、Telnet命令处理和程序入口。</p>
<p><strong>1，接受连接</strong></p>
<p>回音服务器能同时服务于多个连接。要接受连接就需要先创建侦听器，侦听器需要一个侦听地址和协议类型。就像你想卖东西，需要先确认卖什么东西，卖东西的类型就是协议类型，然后需要一个店面，店面位于街区的某个位置，这就是侦听器的地址。一个服务器可以开启多个侦听器，就像一个街区可以有多个店面。街区上的编号对应的就是地址中的端口号，如图9-3所示。</p>
<blockquote>
<p>图9-3 IP和端口号</p>
</blockquote>
<img src="/2021/08/19/第9章-并发/3.jpg">
<ul>
<li>主机IP：一般为一个IP地址或者域名，127.0.0.1表示本机地址。</li>
<li>端口号：16位无符号整型值，一共有65536个有效端口号。</li>
</ul>
<p>通过地址和协议名创建侦听器后，可以使用侦听器响应客户端连接。响应连接是一个不断循环的过程，就像到银行办理业务时，一般是排队处理，前一个人办理完后，轮到下一个人办理。</p>
<p>我们把每个客户端连接处理业务的过程叫做会话。在会话中处理的操作和接受连接的业务并不冲突可以同时进行。就像银行有3个窗口，喊号器会将用户分配到不同的柜台。这里的喊号器就是Accept操作，窗口的数量就是CPU的处理能力。因此，使用goroutine可以轻松实现会话处理和接受连接的并发执行。</p>
<p>如图9-4清晰地展现了这一过程。</p>
<blockquote>
<p>图9-4 Socket处理过程</p>
</blockquote>
<img src="/2021/08/19/第9章-并发/4.jpg">
<p>Go语言中可以根据实际会话数量创建多个goroutine，并自动的调度它们的处理。</p>
<blockquote>
<p>代码9-7 telnet服务器处理（具体文件：…/chapter09/telnetecho/server.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务逻辑，传入地址和退出的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">(address <span class="keyword">string</span>, exitChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据给定地址进行侦听</span></span><br><span class="line">    l, err := net.Listen(<span class="string">"tcp"</span>, address)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果侦听发生错误，打印错误并退出</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err.Error())</span><br><span class="line">        exitChan &lt;- <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印侦听地址，表示侦听成功</span></span><br><span class="line">    fmt.Println(<span class="string">"listen: "</span> + address)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟关闭侦听器</span></span><br><span class="line">    <span class="keyword">defer</span> l.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 侦听循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新连接没有到来时，Accept是阻塞的</span></span><br><span class="line">        conn, err := l.Accept()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发生任何的侦听错误，打印错误并退出服务器</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err.Error())</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据连接开启会话，这个过程需要在并行执行</span></span><br><span class="line">        <span class="keyword">go</span> handleSession(conn, exitChan)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第9行，接受连接的入口，address为传入的地址，退出服务器使用exiChan的通道控制。往exitChan写入一个整型值时，进程将以整型值作为程序返回值来结束服务器。</li>
<li>第12行，使用net包的Listen()函数进行侦听。这个函数需要提供两个参数，第一个参数为协议类型，本例需要做的是TCP连接，因此填入“tep”；address为地址，格式为“主机:端口号”。</li>
<li>第15行，如果侦听发生错误，通过第17行，往exitChan中写入非0值结束服务器，同时打印侦听错误。</li>
<li>第24行，使用defer，将侦听器的结束延迟调用。</li>
<li>第27行，侦听开始后，开始进行连接接受，每次接受连接后需要继续接受新的连接，周而复始。</li>
<li>第30行，服务器接受了一个连接。在没有连接时，Accept()函数调用后会一直阻塞。连接到来时，返回conn和错误变量，conn的类型是*tcp.Conn。</li>
<li>第33行，某些情况下，连接接受会发生错误，不影响服务器逻辑，这时重新进行新连接接受。</li>
<li>第39行，每个连接会生成一个会话。这个会话的处理与接受逻辑需要并行执行，彼此不干扰。</li>
</ul>
<p><strong>2，会话处理</strong></p>
<p>每个连接的会话就是一个接收数据的循环。当没有数据时，调用reader.ReadString会发生阻塞，等待数据的到来。一旦数据到来，就可以进行各种逻辑处理。</p>
<p>回音服务器的基本逻辑是“收到什么返回什么”，reader.ReadString可以一直读取Socket连接中的数据直到碰到期望的结尾符。这种期望的结尾符也叫定界符，一般用于将TCP封包中的逻辑数据拆分开。下例中使用的定界符是回车换行符（“\r\n”），HTTP协议也是使用同样的定界符。使用reader.ReadString()函数可以将封包简单地拆分开。</p>
<p>如图9-5所示为Telnet数据处理过程。</p>
<blockquote>
<p>图9-5 Telnet数据处理过程</p>
</blockquote>
<img src="/2021/08/19/第9章-并发/5.jpg">
<p>回音服务器需要将收到的有效数据通过Socket发送回去。</p>
<blockquote>
<p>代码9-8 Telnet会话处理（具体文件：…/chapter09/telnetecho/session.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接的会话逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSession</span><span class="params">(conn net.Conn, exitChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Session started:"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个网络连接数据的读取器</span></span><br><span class="line">    reader := bufio.NewReader(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据的循环</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取字符串，直到碰到回车返回</span></span><br><span class="line">        str, err := reader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据读取正确</span></span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 去掉字符串尾部的回车</span></span><br><span class="line">            str = strings.TrimSpace(str)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理telnet指令</span></span><br><span class="line">            <span class="keyword">if</span> !processTelnetCommand(str, exitChan) &#123;</span><br><span class="line">                conn.Close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Echo逻辑，发什么数据，原样返回</span></span><br><span class="line">            conn.Write([]<span class="keyword">byte</span>(str + <span class="string">"\r\n"</span>))</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发生错误</span></span><br><span class="line">            fmt.Println(<span class="string">"Session closed"</span>)</span><br><span class="line">            conn.Close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第11行是会话入口，传入连接和退出用的通道。handleSession()函数被并发执行。</li>
<li>第16行，使用bufio包的NewReader()方法，创建一个网络数据读取器，这个Reader将输入数据的读取过程进行封装，方便我们迅速获取到需要的数据。</li>
<li>第19行，会话处理开始时，从Socket连接，通过reader读取器读取封包，处理封包后需要继续读取从网络发送过来的下一个封包，因此需要一个会话处理循环。</li>
<li>第22行，使用reader.ReadString()方法进行封包读取。内部会自动处理粘包过程，直到下一个回车符到达后返回数据。这里认为封包来自Telnet，每个指令以回车换行符（“\r\n”）结尾。</li>
<li>第25行，数据读取正常时，返回err为nil，如果发生连接断开、接收错误等网络错误时，err就不是nil了。</li>
<li>第28行，reader.ReadString读取返回的字符串尾部带有回车符，使用strings.TrimSpace()函数将尾部带的回车和空白符去掉。</li>
<li>第31行，将str字符串传入Telnet指令处理函数processTelnetCommand()中，同时传入退出控制通道exitChan。当这个函数返回false时，表示需要关闭当前连接。</li>
<li>第32行和第33行，关闭当前连接并退出会话接受循环。</li>
<li>第37行，将有效数据通过conn的Write()方法写入，同时在字符串尾部添加回车换行符（“\r\n”），数据将被Socket发送给连接方。</li>
<li>第41～43行，处理当reader.ReadString()函数返回错误时，打印错误信息并关闭连接，退出会话并接收循环。</li>
</ul>
<p><strong>3，Telnet命令处理</strong></p>
<p>Telnet是一种协议。在操作系统中可以在命令行使用Telnet命令发起TCP连接。我们一般用Telnet来连接TCP服务器，键盘输入一行字符回车后，即被发送到服务器上。</p>
<p>在下例中，定义了以下两个特殊控制指令，用以实现一些功能：</p>
<ul>
<li>输入“@close”退出当前连接会话。</li>
<li>输入“@shutdown”终止服务器运行。</li>
</ul>
<blockquote>
<p>代码9-9 Telnet命令处理（具体文件：…/chapter09/telnetecho/telnet.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processTelnetCommand</span><span class="params">(str <span class="keyword">string</span>, exitChan <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @close指令表示终止本次会话</span></span><br><span class="line">    <span class="keyword">if</span> strings.HasPrefix(str, <span class="string">"@close"</span>) &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"Session closed"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉外部需要断开连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// @shutdown指令表示终止服务进程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> strings.HasPrefix(str, <span class="string">"@shutdown"</span>) &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"Server shutdown"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往通道中写入0，阻塞等待接收方处理</span></span><br><span class="line">        exitChan &lt;- <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 告诉外部需要断开连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输入的字符串</span></span><br><span class="line">    fmt.Println(str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第8行，处理Telnet命令的函数入口，传入有效字符并退出通道。</li>
<li>第11～16行，当输入字符串中包含“@close”前缀时，在第16行返回false，表示需要关闭当前会话。</li>
<li>第19～27行，当输入字符串中包含“@shutdown”前缀时，第24行将0写入exitChan，表示结束服务器。</li>
<li>第31行，没有特殊的控制字符时，打印输入的字符串。</li>
</ul>
<p><strong>4，程序入口</strong></p>
<blockquote>
<p>代码9-10 Telnet回音处理主流程（具体文件：…/chapter09/telnetecho/main.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个程序结束码的通道</span></span><br><span class="line">    exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务器并发运行</span></span><br><span class="line">    <span class="keyword">go</span> server(<span class="string">"127.0.0.1:7001"</span>, exitChan)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通道阻塞，等待接收返回值</span></span><br><span class="line">    code := &lt;-exitChan</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记程序返回值，并退出</span></span><br><span class="line">    os.Exit(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，创建一个整型的无缓冲通道作为退出信号。</li>
<li>第13行，接受连接的过程可以并发操作，使用go将server()函数开启goroutine。</li>
<li>第16行，从exitChan中取出返回值。如果取不到数据就一直阻塞。</li>
<li>第19行，将程序返回值传入os.Exit()函数中并终止程序。</li>
</ul>
<p>编译所有代码并运行，命令行提示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen: 127.0.0.1 7001</span><br></pre></td></tr></table></figure></p>
<p>此时，Socket侦听成功。在操作系统中的命令行中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 7001</span><br></pre></td></tr></table></figure></p>
<p>尝试连接本地的7001端口。接下来进入测试服务器的流程。</p>
<p><strong>5，测试输入字符串</strong></p>
<p>在Telnet连接后，输入字符串hello，Telnet命令行显示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 127.0.0.1 7001</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>服务器显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listen: 127.0.0.1:7001</span><br><span class="line">Session started:</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>客户端输入的字符串会在服务器中显示，同时客户端也会收到自己发给服务器的内容，这就是一次回音。</p>
<p><strong>6，测试关闭会话</strong></p>
<p>当输入@close时，Telnet命令行显示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@close</span><br><span class="line">Connection closed by foreign host</span><br></pre></td></tr></table></figure></p>
<p>服务器显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session closed</span><br></pre></td></tr></table></figure></p>
<p>此时，客户端Telnet与服务器断开连接。</p>
<p><strong>7，测试关闭服务器</strong></p>
<p>当输入@shutdown时，Telnet命令行显示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@shutdown</span><br><span class="line">Connection closed by foreign host</span><br></pre></td></tr></table></figure></p>
<p>服务器显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server shutdown</span><br></pre></td></tr></table></figure></p>
<p>此时服务器会自动关闭。</p>
<h1 id="同步——保证并发环境下数据访问的正确性"><a href="#同步——保证并发环境下数据访问的正确性" class="headerlink" title="同步——保证并发环境下数据访问的正确性"></a><span style="color:#339AFF;">同步——保证并发环境下数据访问的正确性</span></h1><p>Go程序可以使用通道进行多个goroutine间的数据交换，但这仅仅是数据同步中的一种方法。通道内部的实现依然使用了各种锁，因此优雅代码的代价是性能。在某些轻量级的场合，原子访问（atomic包）、互斥锁（sync.Mutex）以及等待组（sync.WaitGroup）能最大程度满足需求。</p>
<h2 id="竞态检测——检测代码在并发环境下可能出现的问题"><a href="#竞态检测——检测代码在并发环境下可能出现的问题" class="headerlink" title="竞态检测——检测代码在并发环境下可能出现的问题"></a><span style="color:#00ACC1;">竞态检测——检测代码在并发环境下可能出现的问题</span></h2><p>当多线程并发运行的程序竞争访问和修改同一块资源时，会发生竞态问题。</p>
<p>下面的代码中有一个ID生成器，每次调用生成器将会生成一个不会重复的顺序序号，使用10个并发生成序号，观察10个并发后的结果。</p>
<blockquote>
<p>代码9-11 竞态检测（具体文件：…/chapter09/racedetect/racedetect.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync/atomic"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    seq <span class="keyword">int64</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列号生成器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenID</span><span class="params">()</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试原子的增加序列号</span></span><br><span class="line">    atomic.AddInt64(&amp;seq, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> seq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10个并发序列号生成</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> GenID()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(GenID())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第10行，序列号生成器中的保存上次序列号的变量。</li>
<li>第17行，使用原子操作函数atomic.AddInt64()对seq()函数加1操作。不过这里故意没有使用atomic.AddInt64()的返回值作为GenID()函数的返回值，因此会造成一个竞态问题。</li>
<li>第25行，循环10次生成10个goroutine调用GenlD()函数，同时忽略GenID()的返回值。</li>
<li>第28行，单独调用一次GenID()函数。</li>
</ul>
<p>在运行程序时，为运行参数加入“-race”参数，开启运行时（runtime）对竞态问题的分析，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -race racedetect.go</span><br></pre></td></tr></table></figure></p>
<p>代码运行发生宕机，输出信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at 0x0000011fd768 by goroutine 8:</span><br><span class="line">  sync/atomic.AddInt64()</span><br><span class="line">      /usr/local/go/src/runtime/race_amd64.s:313 +0xb</span><br><span class="line">  sync/atomic.AddInt64()</span><br><span class="line">      &lt;autogenerated&gt;:1 +0x1b</span><br><span class="line">  main.main·dwrap·1()</span><br><span class="line">      /Users/chebin/goproject/demo/test.go:25 +0x2b</span><br><span class="line"></span><br><span class="line">Previous read at 0x0000011fd768 by goroutine 7:</span><br><span class="line">  main.GenID()</span><br><span class="line">      /Users/chebin/goproject/demo/test.go:18 +0x3a</span><br><span class="line">  main.main·dwrap·1()</span><br><span class="line">      /Users/chebin/goproject/demo/test.go:25 +0x2b</span><br><span class="line"></span><br><span class="line">Goroutine 8 (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/chebin/goproject/demo/test.go:25 +0x3b</span><br><span class="line"></span><br><span class="line">Goroutine 7 (finished) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      /Users/chebin/goproject/demo/test.go:25 +0x3b</span><br><span class="line">==================</span><br><span class="line">10</span><br><span class="line">Found 1 data race(s)</span><br><span class="line">exit status 66</span><br></pre></td></tr></table></figure></p>
<p>根据报错信息，第18行有竞态问题，根据atomic.AddInt64()的参数声明，这个函数会将修改后的值以返回值方式传出。下面代码对加粗部分进行了修改：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>再次运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -race main.go</span><br></pre></td></tr></table></figure></p>
<p>代码输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>没有发生竞态问题，程序运行正常。</p>
<p>本例中只是对变量进行增减操作，虽然可以使用互斥锁（sync.Mutex）解决竞态问题，但是对性能消耗较大。在这种情况下，推荐使用原子操作（atomic）进行变量操作。</p>
<h2 id="互斥锁（sync-Mutex）——保证同时只有一个goroutine可以访问共享资源"><a href="#互斥锁（sync-Mutex）——保证同时只有一个goroutine可以访问共享资源" class="headerlink" title="互斥锁（sync.Mutex）——保证同时只有一个goroutine可以访问共享资源"></a><span style="color:#00ACC1;">互斥锁（sync.Mutex）——保证同时只有一个goroutine可以访问共享资源</span></h2><p>互斥锁是一种常用的控制共享资源访问的方法。在Go程序中的使用非常简单，参见下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// 逻辑中使用的某个变量</span></span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 与变量对应的使用互斥锁</span></span><br><span class="line">    countGuard sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCount</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    countGuard.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数退出时解除锁定</span></span><br><span class="line">    <span class="keyword">defer</span> countGuard.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCount</span><span class="params">(c <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    countGuard.Lock()</span><br><span class="line">    count = c</span><br><span class="line">    countGuard.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以进行并发安全的设置</span></span><br><span class="line">    SetCount(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以进行并发安全的获取</span></span><br><span class="line">    fmt.Println(GetCount())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第10行是某个逻辑步骤中使用到的变量，无论是包级的变量还是结构体成员字段，都可以。</li>
<li>第13行，一般情况下，建议将互斥锁的粒度设置得越小越好，降低因为共享访问时等待的时间。这里笔者习惯性地将互斥锁的变量命名为以下格式：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名+Guard</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以表示这个互斥锁用于保护这个变量。</p>
<ul>
<li>第16行是一个获取count值的函数封装，通过这个函数可以并发安全的访问变量count。</li>
<li>第19行，尝试对countGuard互斥量进行加锁。一旦countGuard发生加锁，如果另外一个goroutine尝试继续加锁时将会发生阻塞，直到这个countGuard被解锁。</li>
<li>第22行使用defer将countGuard的解锁进行延迟调用，解锁操作将会发生在GetCount()函数返回时。</li>
<li>第27行在设置count值时，同样使用countGuard进行加锁、解锁操作，保证修改count值的过程是一个原子过程，不会发生并发访问冲突。</li>
</ul>
<h2 id="读写互斥锁（sync-RWMutex）——在读比写多的环境下比互斥锁更高效"><a href="#读写互斥锁（sync-RWMutex）——在读比写多的环境下比互斥锁更高效" class="headerlink" title="读写互斥锁（sync.RWMutex）——在读比写多的环境下比互斥锁更高效"></a><span style="color:#00ACC1;">读写互斥锁（sync.RWMutex）——在读比写多的环境下比互斥锁更高效</span></h2><p>在读多写少的环境中，可以优先使用读写互斥锁，sync包中的RWMutex提供了读写互斥锁的封装。</p>
<p>我们将互斥锁例子中的一部分代码修改为读写互斥锁，参见下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    <span class="comment">// 逻辑中使用的某个变量</span></span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与变量对应的使用互斥量</span></span><br><span class="line">    countGuard sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCount</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定</span></span><br><span class="line">    countGuard.RLock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数退出时解除锁定</span></span><br><span class="line">    <span class="keyword">defer</span> countGuard.RUnlock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明如下：</p>
<ul>
<li>第6行，在声明countGuard时，从sync.Mutex互斥锁改为sync.RWMutex读写互斥锁。</li>
<li>第12行，获取count的过程是一个读取count数据的过程，适用于读写互斥锁。在这一行，把countGuard.Lock()换做countGuard.RLock()，将读写互斥锁标记为读状态。如果此时另外一个goroutine并发访问了countGuard，同时也调用了countGuard.RLock()时，并不会发生阻塞。</li>
<li>第15行，与读模式加锁对应的，使用读模式解锁。</li>
</ul>
<h2 id="等待组（sync-WaitGroup）——保证在并发环境中完成指定数量的任务"><a href="#等待组（sync-WaitGroup）——保证在并发环境中完成指定数量的任务" class="headerlink" title="等待组（sync.WaitGroup）——保证在并发环境中完成指定数量的任务"></a><span style="color:#00ACC1;">等待组（sync.WaitGroup）——保证在并发环境中完成指定数量的任务</span></h2><p>除了可以使用通道（channel）和互斥锁进行两个并发程序间的同步外，还可以使用等待组进行多个任务的同步。</p>
<p>等待组有下面几个方法可用，如表9-2所示。</p>
<blockquote>
<p>表9-2 等待组的方法</p>
</blockquote>
<img src="/2021/08/19/第9章-并发/t-2.jpg">
<p>等待组内部拥有一个计数器，计数器的值可以通过方法调用实现计数器的增加和减少。当我们添加了N个并发任务进行工作时，就将等待组的计数器值增加N。每个任务完成时，这个值减1。同时，在另外一个goroutine中等待这个等待组的计数器值为0时，表示所有任务已经完成。代码9-12演示了这一过程。</p>
<blockquote>
<p>代码9-12 等待组（具体文件：…/chapter09/waitgroup/waitgroup.go）</p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个等待组</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备一系列的网站地址</span></span><br><span class="line">    <span class="keyword">var</span> urls = []<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"http://www.github.com/"</span>,</span><br><span class="line">        <span class="string">"https://www.qiniu.com/"</span>,</span><br><span class="line">        <span class="string">"https://www.golangtc.com/"</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历这些地址</span></span><br><span class="line">    <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个任务开始时，将等待组增加1</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启一个并发</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用defer，表示函数完成时将等待组值减1</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用http访问提供的地址</span></span><br><span class="line">            _, err := http.Get(url)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 访问完成后，打印地址和可能发生的错误</span></span><br><span class="line">            fmt.Println(url, err)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过参数传递url地址</span></span><br><span class="line">        &#125;(url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有的任务完成</span></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明如下：</p>
<ul>
<li>第12行，声明一个等待组，对一组等待任务只需要一个等待组，而不需要每一个任务都使用一个等待组。</li>
<li>第15行，准备一系列可访问的网站地址的字符串切片。</li>
<li>第22行，遍历这些字符串切片。</li>
<li>第25行，将等待组的计数器加1，也就是每一个任务加1。</li>
<li>第28行，将一个匿名函数开启并发。</li>
<li>第31行，在匿名函数结束时会执行这一句以表示任务完成。wg.Done()方法等效于执行wg.Add(-1)。</li>
<li>第34行，使用http包提供的Get()函数对url进行访问，Get()函数会一直阻塞直到网站响应或者超时。</li>
<li>第37行，在网站响应和超时后，打印这个网站的地址和可能发生的错误。</li>
<li>第40行，这里将url通过goroutine的参数进行传递，是为了避免url变量通过闭包放入匿名函数后又被修改的问题。</li>
<li>第44行，等待所有的网站都响应或者超时后，任务完成，Wait就会停止阻塞。</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言从入门到进阶实战/" rel="tag"># Go语言从入门到进阶实战</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/19/第8章-包（package）/" rel="next" title="第8章 包（package）">
                <i class="fa fa-chevron-left"></i> 第8章 包（package）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/19/第10章-反射/" rel="prev" title="第10章 反射">
                第10章 反射 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#轻量级线程（goroutine）——根据需要随时创建的“线程”"><span class="nav-number">1.</span> <span class="nav-text">轻量级线程（goroutine）——根据需要随时创建的“线程”</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#用普通函数创建goroutine"><span class="nav-number">1.1.</span> <span class="nav-text">用普通函数创建goroutine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用匿名函数创建goroutine"><span class="nav-number">1.2.</span> <span class="nav-text">使用匿名函数创建goroutine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调整并发的运行性能（GOMAXPROCS）"><span class="nav-number">1.3.</span> <span class="nav-text">调整并发的运行性能（GOMAXPROCS）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#理解并发和并行"><span class="nav-number">1.4.</span> <span class="nav-text">理解并发和并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go语言的协作程序（goroutine）和普通的协作程序（coroutine）"><span class="nav-number">1.5.</span> <span class="nav-text">Go语言的协作程序（goroutine）和普通的协作程序（coroutine）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通道（channel）——在多个goroutine间通信的管道"><span class="nav-number">2.</span> <span class="nav-text">通道（channel）——在多个goroutine间通信的管道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通道的特性"><span class="nav-number">2.1.</span> <span class="nav-text">通道的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明通道类型"><span class="nav-number">2.2.</span> <span class="nav-text">声明通道类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建通道"><span class="nav-number">2.3.</span> <span class="nav-text">创建通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用通道发送数据"><span class="nav-number">2.4.</span> <span class="nav-text">使用通道发送数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用通道接收数据"><span class="nav-number">2.5.</span> <span class="nav-text">使用通道接收数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：并发打印"><span class="nav-number">2.6.</span> <span class="nav-text">示例：并发打印</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单向通道——通道中的单行道"><span class="nav-number">2.7.</span> <span class="nav-text">单向通道——通道中的单行道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带缓冲的通道"><span class="nav-number">2.8.</span> <span class="nav-text">带缓冲的通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道的多路复用——同时处理接收和发送多个通道的数据"><span class="nav-number">2.9.</span> <span class="nav-text">通道的多路复用——同时处理接收和发送多个通道的数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：模拟远程过程调用（RPC）"><span class="nav-number">2.10.</span> <span class="nav-text">示例：模拟远程过程调用（RPC）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例：使用通道响应计时器的事件"><span class="nav-number">2.11.</span> <span class="nav-text">示例：使用通道响应计时器的事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关闭通道后继续使用通道"><span class="nav-number">2.12.</span> <span class="nav-text">关闭通道后继续使用通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：Telnet回音服务器——TCP服务器的基本结构"><span class="nav-number">3.</span> <span class="nav-text">示例：Telnet回音服务器——TCP服务器的基本结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#同步——保证并发环境下数据访问的正确性"><span class="nav-number">4.</span> <span class="nav-text">同步——保证并发环境下数据访问的正确性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#竞态检测——检测代码在并发环境下可能出现的问题"><span class="nav-number">4.1.</span> <span class="nav-text">竞态检测——检测代码在并发环境下可能出现的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#互斥锁（sync-Mutex）——保证同时只有一个goroutine可以访问共享资源"><span class="nav-number">4.2.</span> <span class="nav-text">互斥锁（sync.Mutex）——保证同时只有一个goroutine可以访问共享资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写互斥锁（sync-RWMutex）——在读比写多的环境下比互斥锁更高效"><span class="nav-number">4.3.</span> <span class="nav-text">读写互斥锁（sync.RWMutex）——在读比写多的环境下比互斥锁更高效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等待组（sync-WaitGroup）——保证在并发环境中完成指定数量的任务"><span class="nav-number">4.4.</span> <span class="nav-text">等待组（sync.WaitGroup）——保证在并发环境中完成指定数量的任务</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
