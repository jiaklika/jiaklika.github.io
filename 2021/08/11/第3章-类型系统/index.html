<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Go语言核心编程">
<meta property="og:type" content="article">
<meta property="og:title" content="第3章 类型系统">
<meta property="og:url" content="http://yoursite.com/2021/08/11/第3章-类型系统/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/08/11/第3章-类型系统/1.png">
<meta property="og:updated_time" content="2022-02-08T11:27:04.044Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第3章 类型系统">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://yoursite.com/2021/08/11/第3章-类型系统/1.png">






  <link rel="canonical" href="http://yoursite.com/2021/08/11/第3章-类型系统/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第3章 类型系统 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/11/第3章-类型系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第3章 类型系统

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-08-11 10:04:58" itemprop="dateCreated datePublished" datetime="2021-08-11T10:04:58+08:00">2021-08-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-02-08 19:27:04" itemprop="dateModified" datetime="2022-02-08T19:27:04+08:00">2022-02-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">18k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">16 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>类型系统对于一门语言来说至关重要，特别是静态编程语言，类型系统能够在编译阶段发现大部分程序错误。类型是高级语言实现抽象编程的基础，学好类型系统对于掌握一门语言来说至关重要。</p>
<p>第1章已经初步介绍了Go语言数据类型中的简单类型和复合类型。简单类型包括布尔型、整型、浮点型、复数和字符串，复合类型包括数组、切片、字典、结构和指针，第2章介绍的函数类型也属于复合类型。字符类型byte和rune在底层是当作int8和int32处理的，从这个角度来说，可以把字符类型归类到整型里面。</p>
<p>Go语言从设计之初就本着“大道至简”的理念，所以Go语言的类型系统设计得非常精炼，抛弃了大部分传统面向对象语言的类的概念，取而代之的是结构（struct）。结构在内存分布上看起来和C语言的struct没有区别，简单干净，没有像C++那样为了实现多态和多继承而额外添加虚拟函数指针。这种简单的设计实际上蕴藏着一种哲学：把语言的特性设计得尽可能正交，相互之间不要关联，对多态的支持交给接口去处理，类型的存储尽量简单、平坦、直接。</p>
<p>Go语言的类型系统可以分为命名类型、非命名类型、底层类型、动态类型和静态类型等，本章将系统介绍这些知识，使读者对Go语言的类型系统有一个完整的认识。同时，本章在介绍类型的基础上深入介绍自定义类型和类型方法，这些是Go语言面向对象编程的基础。</p>
<h1 id="类型简介"><a href="#类型简介" class="headerlink" title="类型简介"></a><span style="color:#339AFF;">类型简介</span></h1><p>第1章简单介绍了Go语言的数据类型：简单类型和复合类型，本章将系统阐述Go语言的类型系统。首先介绍什么是命名类型和未命名类型，然后讲解两个类型相同的判断条件，最后介绍类型之间的可赋值型。</p>
<h2 id="命名类型和未命名类型"><a href="#命名类型和未命名类型" class="headerlink" title="命名类型和未命名类型"></a><span style="color:#00ACC1;">命名类型和未命名类型</span></h2><p><strong>命名类型（Named Type）</strong></p>
<p>类型可以通过标识符来表示，这种类型称为命名类型。Go语言的基本类型中有20个预声明简单类型都是命名类型，Go语言还有一种命名类型——用户自定义类型，将在3.2节介绍。</p>
<p><strong>未命名类型（Unamed Type）</strong></p>
<p>一个类型由预声明类型、关键字和操作符组合而成，这个类型称为未命名类型。未命名类型又称为类型字面量（Type Literal），本书中的未命名类型和类型字面量二者等价。</p>
<p>Go语言的基本类型中的复合类型：数组（array）、切片（slice）、字典（map）、通道（channel）、指针（pointer）、函数字面量（function）、结构（struct）和接口（interface）都属于类型字面量，也都是未命名类型。</p>
<p>所以*int、[]int、[2]int、map[k]v都是未命名类型。</p>
<p>注意前面所说的结构和接口是未命名类型，这里的结构和接口没有使用type格式定义，具体见下方示例说明。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用type声明的是命名类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用struct字面量声明的是未命名类型</span></span><br><span class="line">    a := <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        age <span class="keyword">int</span></span><br><span class="line">    &#125;&#123;<span class="string">"andes"</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// struct &#123; name string; age int &#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, a) <span class="comment">// &#123;andes 18&#125;</span></span><br><span class="line"></span><br><span class="line">    b := Person&#123;<span class="string">"tom"</span>, <span class="number">21</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// main.Person</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, b) <span class="comment">// &#123;tom 21&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言的命名类型和未命名类型如图3-1所示。</p>
<blockquote>
<p>图3-1 Go类型系统</p>
</blockquote>
<img src="/2021/08/11/第3章-类型系统/1.png">
<p>（1）未命名类型和类型字面量是等价的，我们通常所说的Go语言基本类型中的复合类型就是类型字面量，所以未命名类型、类型字面量和Go语言基本类型中的复合类型三者等价。</p>
<p>（2）通常所说的Go语言基本类型中的简单类型就是这20个预声明类型，它们都属于命名类型。</p>
<p>（3）预声明类型是命名类型的一种，另一类命名类型是自定义类型（参见3.2.1节）。</p>
<h2 id="底层类型"><a href="#底层类型" class="headerlink" title="底层类型"></a><span style="color:#00ACC1;">底层类型</span></h2><p>3.1.1节我们理清了命名类型和未命名类型、预声明类型、类型字面量、自定义类型的关系。 </p>
<p>本节我们继续引入一个概念，那就是底层类型。</p>
<p>所有“类型”都有一个underlying type（底层类型）。底层类型的规则如下：</p>
<p>（1）预声明类型（Pre-declared types）和类型字面量（type literals）的底层类型是它们自身。 </p>
<p>（2）自定义类型<code>type newtype oldtype</code>中newtype的底层类型是逐层递归向下查找的，直到查到的oldtype是预声明类型（Pre-declared types）或类型字面量（type literals）为止。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> T2 T1</span><br><span class="line"><span class="keyword">type</span> T3 []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> T4 T3</span><br><span class="line"><span class="keyword">type</span> T5 []T1</span><br><span class="line"><span class="keyword">type</span> T6 T5</span><br></pre></td></tr></table></figure></p>
<p>T1和T2的底层类型都是string，T3和T4的底层类型都是[]string，T6和T5的底层类型都是[]T1。特别注意这里的T6、T5与T3、T4的底层类型是不一样的，一个是[]T1，另一个是[]string。</p>
<p>底层类型在类型赋值和类型强制转换时会使用，接下来就介绍这两个主题。</p>
<h2 id="类型相同和类型赋值"><a href="#类型相同和类型赋值" class="headerlink" title="类型相同和类型赋值"></a><span style="color:#00ACC1;">类型相同和类型赋值</span></h2><p><strong>类型相同</strong></p>
<p>Go是强类型的语言，编译器在编译时会进行严格的类型校验。两个命名类型是否相同，参考如下：</p>
<p>（1）两个命名类型相同的条件是两个类型声明的语句完全相同。</p>
<p>（2）命名类型和未命名类型永远不相同。</p>
<p>（3）两个未命名类型相同的条件是它们的类型声明字面量的结构相同，并且内部元素的类型相同。</p>
<p>（4）通过类型别名语句声明的两个类型相同。</p>
<p>Go1.9引入了类型别名语法<code>type T1=T2</code>，T1的类型完全和T2一样。引入别名主要有如下原因：</p>
<p>（1）为了解决新旧包的迁移兼容问题，比如context包先前并不在标准库里面，后面迁移到了标准库。</p>
<p>（2）Go的按包进行隔离的机制不太精细，有时我们需要将大包划分为几个小包进行开发，但需要在大包里面暴露全部的类型给使用者。</p>
<p>（3）解决新旧类型的迁移问题，新类型先是旧类型的别名，后续的软件都基于新类型编程，在合适的时间将新类型升级为和旧类型不兼容，常用于软件的柔性升级。</p>
<p><strong>类型可直接赋值</strong></p>
<p>不同类型的变量之间一般是不能直接相互赋值的，除非满足一定的条件。下面探讨类型可赋值的条件。</p>
<p>类型为T1的变量a可以赋值给类型为T2的变量b，称为类型T1可以赋值给类型T2，伪代码表述如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a是类型为T1的变量，或者a本身就是一个字面常量或nil </span></span><br><span class="line"><span class="comment">// 如果如下语句可以执行，则称之为类型T1可以赋值给类型T2</span></span><br><span class="line"><span class="keyword">var</span> b T2 =a</span><br></pre></td></tr></table></figure></p>
<p>a可以赋值给变量b必须要满足如下条件中的一个：</p>
<p>（1）T1和T2的类型相同。</p>
<p>（2）T1和T2具有相同的底层类型，并且T1和T2里面至少有一个是未命名类型。</p>
<p>（3）T2是接口类型，T1是具体类型，T1的方法集是T2方法集的超集（方法集参见第4章）。</p>
<p>（4）T1和T2都是通道类型，它们拥有相同的元素类型，并且T1和T2中至少有一个是未命名类型。</p>
<p>（5）a是预声明标识符nil，T2是pointer、funcition、slice、map、channel、interface类型中的一个。</p>
<p>（6）a是一个字面常量值，可以用来表示类型T的值（参见1.4节）。</p>
<p>示例如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Map)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iMap Map</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要底层类型是slice、map等支持range的类型字面量，新类型仍然可以使用range迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m iMap)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s slice)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    mp[<span class="string">"hi"</span>] = <span class="string">"tata"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mp与ma有相同的底层类型map[string]string，并且mp是未命名类型</span></span><br><span class="line">    <span class="comment">// 所以mp可以直接赋值给ma</span></span><br><span class="line">    <span class="keyword">var</span> ma Map = mp</span><br><span class="line"></span><br><span class="line">    ma.Print() <span class="comment">// tata</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// im与ma虽然有相同的底层类型map[string]string，但它们中没有一个是未命名类型</span></span><br><span class="line">    <span class="comment">// 不能赋值，如下语句不能通过编译</span></span><br><span class="line">    <span class="comment">// var im iMap = ma</span></span><br><span class="line">    <span class="comment">// im.Print()</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Map实现了Print()，所以其可以赋值给接口类型变量</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;</span><br><span class="line">        Print()</span><br><span class="line">    &#125; = ma</span><br><span class="line"></span><br><span class="line">    i.Print() <span class="comment">// tata</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> s2 slice</span><br><span class="line">    s2 = s1 </span><br><span class="line">    s2.Print() <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型强制转换"><a href="#类型强制转换" class="headerlink" title="类型强制转换"></a><span style="color:#00ACC1;">类型强制转换</span></h2><p>由于Go是强类型的语言，如果不满足自动转换的条件，则必须进行强制类型转换。任意两个不相干的类型如果进行强制转换，则必须符合一定的规则。强制类型的语法格式：<code>var a T=(T)(b)</code>，使用括号将类型和要转换的变量或表达式的值括起来。</p>
<p>非常量类型的变量x可以强制转化并传递给类型T，需要满足如下任一条件：</p>
<p>（1）x可以直接赋值给T类型变量。</p>
<p>（2）x的类型和T具有相同的底层类型。</p>
<p>继续使用上一节的示例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m Map)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iMap Map</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要底层类型是slice、map等支持range的类型字面量，新类型仍然可以使用range迭代</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m iMap)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">    mp[<span class="string">"hi"</span>] = <span class="string">"tata"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mp与ma有相同的底层类型map[string]string，并且mp是未命名类型</span></span><br><span class="line">    <span class="keyword">var</span> ma Map = mp</span><br><span class="line"></span><br><span class="line">    <span class="comment">// im与ma虽然有相同的底层类型，但是二者中没有一个是字面量类型，不能直接赋值，可以</span></span><br><span class="line">    <span class="comment">// 强制进行类型转换</span></span><br><span class="line">    <span class="comment">// var im iMap = ma</span></span><br><span class="line">    <span class="keyword">var</span> im iMap = (iMap)(ma)</span><br><span class="line"></span><br><span class="line">    ma.Print() <span class="comment">// tata</span></span><br><span class="line">    im.Print() <span class="comment">// tata</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）x的类型和T都是未命名的指针类型，并且指针指向的类型具有相同的底层类型。 </p>
<p>（4）x的类型和T都是整型，或者都是浮点型。</p>
<p>（5）x的类型和T都是复数类型。</p>
<p>（6）x是整数值或[]byte类型的值，T是string类型。</p>
<p>（7）x是一个字符串，T是[]byte或[]rune。</p>
<p>字符串和字节切片之间的转换最常见，示例如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"hello,世界!"</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">byte</span></span><br><span class="line">a = []<span class="keyword">byte</span>(s)</span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line">b = <span class="keyword">string</span>(a)</span><br><span class="line"><span class="keyword">var</span> c []<span class="keyword">rune</span></span><br><span class="line">c = []<span class="keyword">rune</span>(s)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// []uint8是int8的别名</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// string</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, c) <span class="comment">// []int32 rune是int32的别名</span></span><br></pre></td></tr></table></figure></p>
<p>注意：<br>（1）数值类型和string类型之间的相互转换可能造成值部分丢失；其他的转换仅是类型的转换，不会造成值的改变。string和数字之间的转换可使用标准库strconv。</p>
<p>（2）Go语言没有语言机制支持指针和interger之间的直接转换，可以使用标准库中的unsafe包进行处理。</p>
<h1 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a><span style="color:#339AFF;">类型方法</span></h1><p>花了那么多笔墨介绍各种类型之间的关系，最主要的原因就是为了介绍类型方法。为类型增加方法是Go语言实现面向对象编程的基础。在介绍类型方法之前先介绍自定义类型。</p>
<h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a><span style="color:#00ACC1;">自定义类型</span></h2><p>前面介绍命名类型时提到了自定义类型。用户自定义类型使用关键字type，其语法格式是<code>type newtype oldtype</code>。oldtype可以是自定义类型、预声明类型、未命名类型中的任意一种。newtype是新类型的标识符，与oldtype具有相同的底层类型，并且都继承了底层类型的操作集合（这里的操作不是方法，比如底层类型是map，支持range迭代访问，则新类型也可以使用 range迭代访问）。除此之外，newtype和oldtype是两个完全不同的类型，newtype不会继承oldtype的方法。无论oldtype是什么类型，使用type声明的新类型都是一种命名类型，也就是说，自定义类型都是命名类型。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> INT <span class="keyword">int</span>  <span class="comment">// INT是一个使用预声明类型声明的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// Map是一个使用类型字面量声明的自定义类型</span></span><br><span class="line"><span class="keyword">type</span> myMap Map <span class="comment">// myMap是一个自定义类型Map声明的自定义类型</span></span><br><span class="line"><span class="comment">// INT、Map、myMap都是命名类型</span></span><br></pre></td></tr></table></figure></p>
<p>Go语言内置的类型算不上丰富，但是很容易用现有的类型构造出新类型，进而构造出复杂和多样的数据结构。下面介绍Go语言中常用的自定义类型。</p>
<p><strong>自定义struct类型</strong></p>
<p>1.6节粗略介绍过struct类型，这里继续深入介绍struct。为什么再次介绍？struct类型是Go语言自定义类型的普遍的形式，是Go语言类型扩展的基石，也是Go语言面向对象承载的基础。</p>
<p>前面章节将struct划为未命名类型，那时的struct是使用字面量来表示的，如果使用type语句声明，则这个新类型就是命名类型。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用type自定义的结构类型属于命名类型</span></span><br><span class="line"><span class="keyword">struct</span> XXXname <span class="keyword">struct</span>&#123;</span><br><span class="line">    Field1 type1</span><br><span class="line">    Field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString是一个自定义结构类型，也是命名类型</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构字面量属于未命名类型</span></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    Field1 type1</span><br><span class="line">    Field2 type2</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct&#123;&#125;是非命名类型空结构</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">struct</span> &#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>struct初始化</strong></p>
<p>以Person结构为例来讲一下结构的初始化的方法。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（1）按照字段顺序进行初始化。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意有三种写法</span></span><br><span class="line">a := Person&#123;<span class="string">"andes"</span>, <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">b := Person&#123;</span><br><span class="line">    <span class="string">"andes"</span>,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c:= Person&#123;</span><br><span class="line">    <span class="string">"andes"</span>,</span><br><span class="line">    <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这不是一种推荐的方法，一旦结构增加字段，则不得不修改顺序初始化语句。</p>
<p>（2）指定字段名进行初始化。例如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a := Person&#123; name:<span class="string">"andes"</span>, age:<span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">b := Person&#123;</span><br><span class="line">    name: <span class="string">"andes"</span>, </span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := Person&#123;</span><br><span class="line">    name:<span class="string">"andes"</span>, </span><br><span class="line">    age:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种推荐的方法，一旦结构增加字段，则不用修改初始化语句。</p>
<blockquote>
<p>注意：如果上述两种结构的初始化语句结尾的“}”独占一行，则最后一个字段的后面一定要带上逗号。</p>
</blockquote>
<p>（3）使用new创建内置函数，字段默认初始化为其类型的零值，返回值是指向结构的指针。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(Person)</span><br><span class="line"><span class="comment">// 此时name为""，age是0</span></span><br></pre></td></tr></table></figure></p>
<p>这种方法不常用，一般使用struct都不会将所有字段初始化为零值。</p>
<p>（4）一次初始化一个字段。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p:=Person&#123;&#125;</span><br><span class="line">p.name = <span class="string">"andes"</span></span><br><span class="line">p.age = <span class="number">18</span></span><br></pre></td></tr></table></figure></p>
<p>这种方法不常用，这是一种结构化的编程思维，没有封装，违背了struct本身抽象封装的理念。</p>
<p>（5）使用构造函数进行初始化。</p>
<p>这是推荐的一种方法，当结构发生变化时，构造函数可以屏蔽细节。下面是标准库中errors的New函数示例。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$&#123;GOROOT&#125;/src/errors/errors.go</span></span><br><span class="line"><span class="comment">//New returns an error that formats as the given text. func New(text string) error&#123;</span></span><br><span class="line"><span class="keyword">return</span> &amp;errorstring&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//errorString is a trivial implementation of error. type errorString struct &#123;</span></span><br><span class="line">sstring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结构字段的特点</strong></p>
<p>结构的字段可以是任意的类型，基本类型、接口类型、指针类型、函数类型都可以作为struct的字段。结构字段的类型名必须唯一，struct字段类型可以是普通类型，也可以是指针。另外，结构支持内嵌自身的指针，这也是实现树形和链表等复杂数据结构的基础。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>匿名字段</strong></p>
<p>在定义struct的过程中，如果字段只给出字段类型，没有给出字段名，则称这样的字段为“匿名字段”。被匿名嵌入的字段必须是命名类型或命名类型的指针，类型字面量不能作为匿名字段使用。匿名字段的字段名默认就是类型名，如果匿名字段是指针类型，则默认的字段名就是指针指向的类型名。但一个结构体里面不能同时存在某一类型及其指针类型的匿名字段，原因是二者的字段名相等。如果嵌入的字段来自其他包，则需要加上包名，并且必须是其他包可以导出的类型。示例如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准库$&#123;G0R00T&#125;/src/os/type.go内的一个匿名的指针字段type File struct &#123;</span></span><br><span class="line">*file <span class="comment">// os specific</span></span><br></pre></td></tr></table></figure></p>
<p><strong>自定义接口类型</strong></p>
<p>同理，1.6节介绍的接口类型确切地说应该是接口字面量类型。本节介绍自定义接口类型。接口字面量是非命名类型，但自定义接口类型是命名类型。自定义接口类型同样使用type关键字声明。示例如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface&#123;&#125;是接口字面量类型标识，所以i是非命名类型变量var i interface&#123;&#125;</span></span><br><span class="line"><span class="comment">//Reader是自定义接口类型，属于命名类型type Reader interface &#123;</span></span><br><span class="line">Read(p []<span class="keyword">byte</span>)(nint, err error)</span><br></pre></td></tr></table></figure></p>
<p>关于接口的详细信息就先介绍到这里，有关接口的详细信息请阅读第4章。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><span style="color:#00ACC1;">方法</span></h2><p>前面介绍了Go语言的类型系统和自定义类型，仅使用类型对数据进行抽象和封装还是不够的，本节介绍Go语言的类型方法。Go语言的类型方法是一种对类型行为的封装。Go语言的方法非常纯粹，可以看作特殊类型的函数，其显式地将对象实例或指针作为函数的第一个参数，并且参数名可以自己指定，而不强制要求一定是this或self。这个对象实例或指针称为方法的接收者（reciever）。</p>
<p>为命名类型定义方法的语法格式如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>t是接收者，可以自由指定名称。</li>
<li>TypeName为命名类型的类型名。</li>
<li>MethodName为方法名，是一个自定义标识符。</li>
<li>ParamList是形参列表。</li>
<li>ReturnList是返回值列表。</li>
</ul>
<p>Go语言的类型方法本质上就是一个函数，没有使用隐式的指针，这是Go的优点，简单明了。我们可以将类型的方法改写为常规的函数。示例如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>类型方法有如下特点：<br>（1）可以为命名类型增加方法（除了接口），非命名类型不能自定义方法。</p>
<p>比如不能为[]int类型增加方法，因为[]int是非命名类型。命名接口类型本身就是一个方法的签名集合，所以不能为其增加具体的实现方法。</p>
<p>（2）为类型增加方法有一个限制，就是方法的定义必须和类型的定义在同一个包中。</p>
<p>不能再为intbool等预声明类型增加方法，因为它们是命名类型，但它们是Go语言内置的预声明类型，作用域是全局的，为这些类型新增的方法是在某个包中，这与第2条规则冲突，所以Go编译器拒绝为int增加方法。</p>
<p>（3）方法的命名空间的可见性和变量一样，大写开头的方法可以在包外被访问，否则只能在包内可见。</p>
<p>（4）使用type定义的自定义类型是一个新类型，新类型不能调用原有类型的方法，但是底层类型支持的运算可以被新类型继承。</p>
<h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a><span style="color:#339AFF;">方法调用</span></h1><p>3.2节讨论的类型方法本质上是函数，只是采用了一种特殊的语法书写。类型方法在调用上也很灵活，本节主要讨论类型方法的调用方式、方法集、方法变量和方法表达式。</p>
<h2 id="一般调用"><a href="#一般调用" class="headerlink" title="一般调用"></a><span style="color:#00ACC1;">一般调用</span></h2><p>类型方法的一般调用方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeInstanceName.MethodName(ParamList)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>TypeInstanceName：类型实例名或指向实例的指针变量名； </li>
<li>MethodName：类型方法名；</li>
<li>ParamList：方法实参。</li>
</ul>
<p>示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    t.a = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = &amp;T&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通方法调用</span></span><br><span class="line">t.Set(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通方法调用</span></span><br><span class="line">t.Get()</span><br></pre></td></tr></table></figure></p>
<h2 id="方法值（method-value）"><a href="#方法值（method-value）" class="headerlink" title="方法值（method value）"></a><span style="color:#00ACC1;">方法值（method value）</span></h2><p>变量x的静态类型是T，M是类型T的一个方法，x.M被称为方法值（method value）。x.M是一个函数类型变量，可以赋值给其他变量，并像普通的函数名一样使用。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f := x.M</span><br><span class="line">f(args...)</span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.M(args...)</span><br></pre></td></tr></table></figure></p>
<p>方法值（method value）其实是一个带有闭包的函数变量，其底层实现原理和带有闭包的匿名函数类似，接收值被隐式地绑定到方法值（method value）的闭包环境中。后续调用不需要再显式地传递接收者。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    t.a = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v, %d \n"</span>, &amp;t, t, t.a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = &amp;T&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method value</span></span><br><span class="line">f := t.Set</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法值调用</span></span><br><span class="line">f(<span class="number">2</span>)</span><br><span class="line">t.Print() <span class="comment">// 结果为 0xc0000b0008, &#123;2&#125;, 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法值调用</span></span><br><span class="line">f(<span class="number">3</span>)</span><br><span class="line">t.Print() <span class="comment">// 结果为 0xc0000b0020, &#123;3&#125;, 3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="方法表达式（method-expression）"><a href="#方法表达式（method-expression）" class="headerlink" title="方法表达式（method expression）"></a><span style="color:#00ACC1;">方法表达式（method expression）</span></h2><p>方法表达式相当于提供一种语法将类型方法调用显式地转换为函数调用，接收者（receiver）必须显式地传递进去。下面定义一个类型T，增加两个方法，方法Get的接收者为T，方法Set的接收者类型为*T。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Set</span><span class="params">(i <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    t.a = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Print</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%p, %v, %d \n"</span>, t, t, t.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表达式<code>T.Get</code>和<code>(*T).Set</code>被称为方法表达式（method expression），方法表达式可以看作函数名，只不过这个函数的首个参数是接收者的实例或指针。<code>T.Get</code>的函数签名是<code>func (tT） int</code>，（<code>\*T）.set</code>的函数签名是<code>func（t\*T，iint）</code>。注意：这里的<code>T.Get</code>不能写成<code>（\*T）.Get</code>，<code>（\*T）.Set</code>也不能写成<code>T.Set</code>，在方法表达式中编译器不会做自动转换。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下方法表达式调用都是等价的</span></span><br><span class="line">t := T&#123;a:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通方法调用</span></span><br><span class="line">t.Get()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法表达式调用</span></span><br><span class="line">T.Get(t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法表达式调用</span></span><br><span class="line">f1 := T.Get;f1(t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法表达式调用</span></span><br><span class="line">f2 := T.Get; f2(t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下方法表达式调用都是等价的</span></span><br><span class="line">(*T).Set(&amp;t, <span class="number">1</span>)</span><br><span class="line">f3 := (*T).Set;f3(&amp;t, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>通过方法值和方法表达式可以看到：Go的方法底层是基于函数实现的，只是语法格式不同，本质是一样的。</p>
<h2 id="方法集（method-set）"><a href="#方法集（method-set）" class="headerlink" title="方法集（method set）"></a><span style="color:#00ACC1;">方法集（method set）</span></h2><p>命名类型方法接收者有两种类型，一个是值类型，另一个是指针类型，这个和函数是一样的，前者的形参是值类型，后者的形参是指针类型。无论接收者是什么类型，方法和函数的实参传递都是值拷贝。如果接收者是值类型，则传递的是值的副本；如果接收者是指针类型，则<br>传递的是指针的副本。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上面示例定义了一个新类型Int，新类型的底层类型是int，Int虽然不能继承int的方法，但底层类型支持的操作（算术运算和赋值运算）可以被上层类型继承，这是Go类型系统的一个特点。</p>
<p>接收者是Int类型的方法集合（methodset）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(iInt)</span><span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(a Int)</span> <span class="title">Max</span><span class="params">(b Int)</span><span class="title">Int</span></span></span><br></pre></td></tr></table></figure></p>
<p>接收者是*Int类型的方法集合（methodset）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *Int)</span><span class="title">Set</span><span class="params">(a Int)</span></span></span><br></pre></td></tr></table></figure></p>
<p>为了简化描述，将接收者（receiver）为值类型T的方法的集合记录为S，将接收者（receiver）为指针类型*T的方法的集合统称为*S。类型的方法集总结如下：</p>
<p>（1）T类型的方法集是S。</p>
<p>（2）*T类型的方法集是S和*S。</p>
<p>从上面的示例可以看出，在直接使用类型实例调用类型的方法时，无论值类型变量还是指针类型变量，都可以调用类型的所有方法，原因是编译器在编译期间能够识别出这种调用关系，做了自动的转换。比如a.Set（）使用值类型实例调用指针接收者方法，编译器会自动将其转换为（&amp;a）.Set（），（&amp;a），Print（）使用指针类型实例调用值类型接收者方法，编译器自动将其转化为a.Print()。</p>
<p>前面讲到的另外两种调用方法：“方法的值”和“方法表达式”，编译器对这两种方法的调用处理也不相同，具体见接下来的介绍。</p>
<h2 id="值调用和表达式调用的方法集"><a href="#值调用和表达式调用的方法集" class="headerlink" title="值调用和表达式调用的方法集"></a><span style="color:#00ACC1;">值调用和表达式调用的方法集</span></h2><p>前面介绍方法集时我们知道，具体类型实例变量直接调用其方法时，编译器会所调用方法进行自动转换，即使接收者是指针的方法，仍然可以使用值类型变量进行调用。下面讨论在以下两种情况下编译器是否会进行方法的自动转换。</p>
<p>（1）通过类型字面量显式地进行值调用和表达式调用，可以看到在这种情况下编译器不会做自动转换，会进行严格的方法集检查。例如：</p>
<p>（2）通过类型变量进行值调用和表达式调用，在这种情况下，使用值调用（method value）方式调用时编译器会进行自动转换，使用表达式调用（method expression）方式调用时编译器不会进行转换，会进行严格的方法集检查。例如：</p>
<h1 id="组合和方法集"><a href="#组合和方法集" class="headerlink" title="组合和方法集"></a><span style="color:#339AFF;">组合和方法集</span></h1><p>结构类型（struct）为Go提供了强大的类型扩展，主要体现在两个方面：第一，struct可以嵌入任意其他类型的字段；第二，struct可以嵌套自身的指针类型的字段。这两个特性决定了struct类型有着强大的表达力，几乎可以表示任意的数据结构。同时，结合结构类型的方法，“数据+方法”可以灵活地表达程序逻辑。</p>
<p>Go语言的结构（struct）和C语言的struct一样，内存分配按照字段顺序依次开辟连续的存储空间，没有插入额外的东西（除字段对齐外），不像C++那样为了实现多态在对象内存模型里插入了虚拟函数指针，这种设计的优点使数据和逻辑彻底分离，对象内存区只存放数据，干净简单；类型的方法也是显式带上接收者，没有像C++一样使用隐式的this指针，这是一种优秀的设计方法。Go中的数据就是数据，逻辑就是逻辑，二者是“正交”的，底层实现上没有相关性，在语言使用层又为开发者提供了统一的数据和逻辑抽象视图，这种外部统一、内部隔离的面向对象设计是Go语言优秀设计的体现。</p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a><span style="color:#00ACC1;">组合</span></h2><p>从前面讨论的命名类型的方法可知，使用type定义的新类型不会继承原有类型的方法，有个特例就是命名结构类型，命名结构类型可以嵌套其他的命名类型的字段，外层的结构类型是可以调用嵌入字段类型的方法，这种调用既可以是显式的调用，也可以是隐式的调用。这就是Go的“继承”，准确地说这就是Go的“组合”。因为Go语言没有继承的语义，结构和字段之间是“has a”的关系，而不是“is a”的关系；没有父子的概念，仅仅是整体和局部的概念，所以后续统称这种嵌套的结构和字段的关系为组合。</p>
<p>struct中的组合非常灵活，可以表现为水平的字段扩展，由于struct可以嵌套其他struct字段，所以组合也可以分层次扩展。struct类型中的字段称为“内嵌字段”，内嵌字段的访问和方法调用遵照的规约接下来进行讲解。</p>
<p><strong>内嵌字段的初始化和访问</strong></p>
<p>struct的字段访问使用点操作符“.”，struct的字段可以嵌套很多层，只要内嵌的字段是唯一的即可，不需要使用全路径进行访问。在以下示例中，可以使用z.a代替z.Y.X.a。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Y <span class="keyword">struct</span> &#123;</span><br><span class="line">    X</span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Z <span class="keyword">struct</span> &#123;</span><br><span class="line">    Y</span><br><span class="line">    c <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    x := X&#123;a:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    y := Y &#123;</span><br><span class="line">        X: x,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z := Z&#123;</span><br><span class="line">        Y: y,</span><br><span class="line">        c: <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// z.a、z.Y.a、z.Y.X.a 三者都是等价的，z.a z.Y.a是z.Y.X.a的简写</span></span><br><span class="line">    <span class="built_in">println</span>(z.a, z.Y, z.Y.X.a) <span class="comment">// 1 1 1</span></span><br><span class="line"></span><br><span class="line">    z = Z&#123;&#125;</span><br><span class="line"></span><br><span class="line">    z.a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">println</span>(z.a, z.Y.a, z.Y.X.a) <span class="comment">// 2 2 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在struct的多层嵌套中，不同嵌套层次可以有相同的字段，此时最好使用完全路径进行访问和初始化。在实际数据结构的定义中应该尽量避开相同的字段，以免在使用中出现歧义。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><strong>内嵌字段的方法调用</strong></p>
<p>struct类型方法调用也使用点操作符，不同嵌套层次的字段可以有相同的方法，外层变量调用内嵌字段的方法时也可以像嵌套字段的访问一样使用简化模式。如果外层字段和内层字段有相同的方法，则使用简化模式访问外层的方法会覆盖内层的方法。即在简写模式下，Go编译器优先从外向内逐层查找方法，同名方法中外层的方法能够覆盖内层的方法。这个特性有点类似于面向对象编程中，子类覆盖父类的同名方法。示例如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>不推荐在多层的struct类型中内嵌多个同名的字段；但是并不反对struct定义和内嵌字段同名方法的用法，因为这提供了一种编程技术，使得struct能够重写内嵌字段的方法，提供面向对象编程中子类覆盖父类的同名方法的功能。</p>
<h2 id="组合的方法集"><a href="#组合的方法集" class="headerlink" title="组合的方法集"></a><span style="color:#00ACC1;">组合的方法集</span></h2><p>组合结构的方法集有如下规则：</p>
<p>（1）若类型S包含匿名字段T，则S的方法集包含T的方法集。</p>
<p>（2）若类型S包含匿名字段<em>，则S的方法集包含T和</em>T方法集。</p>
<p>（3）不管类型S中嵌入的匿名字段是T还是<em>T，</em>s方法集总是包含T和方法集。</p>
<p>下面举个例子来验证这个规则的正确性，3.4.1节讲到方法集时提到Go编译器会对方法调用进行自动转换，为了阻止自动转换，本示例使用方法表达式的调用方式，这样能更清楚地理解这个方法集的规约。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>到目前为止还没有发现方法集有多大的用途，而且通过实践发现，Go编译器会进行自动转换，看起来不需要太关注方法集，这种认识是错误的。编译器的自动转换仅适用于直接通过类型实例调用方法时才有效，类型实例传递给接口时，编译器不会进行自动转换，而是会进行严格的方法集校验。</p>
<p>Go函数的调用实参都是值拷贝，方法调用参数传递也是一样的机制，具体类型变量传递给接口时也是值拷贝，如果传递给接口变量的是值类型，但调用方法的接收者是指针类型，则程序运行时虽然能够将接收者转换为指针，但这个指针是副本的指针，并不是我们期望的原变量的指针。所以语言设计者为了杜绝这种非期望的行为，在编译时做了严格的方法集合的检查，不允许产生这种调用；如果传递给接口的变量是指针类型，则接口调用的是值类型的方法，程序运行时能够自动转换为值类型，这种转换不会带来副作用，符合调用者的预期，所以这种转换是允许的，而且这种情况符合方法集的规约。具体类型传递给接口时编译器会进行严格的方法集校验，掌握了方法集的概念在后续章节学习接口时非常有用。</p>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a><span style="color:#339AFF;">函数类型</span></h1><p>在对Go的类型系统做了全面的讲解后，本节对函数类型进行全面深入的介绍。首先介绍“有名函数”和“匿名函数”两个概念。使用<code>func FunctionName()</code>语法格式定义的函数我们称为“有名函数”，这里所谓的有名是指函数在定义时指定了“函数名”；与之对应的是“匿名函数”，所谓的匿名函数就是在定义时使用<code>func()</code>语法格式，没有指定函数名。通常所说的函数就是指“有名函数”。</p>
<p>函数类型也分两种，一种是函数字面量类型（未命名类型），另一种是函数命名类型。</p>
<p><strong>函数字面量类型</strong></p>
<p>函数字面量类型的语法表达格式是<code>func (InputTypeList) OutputTypeList</code>，可以看出“有名函数”和“匿名函数”的类型都属于函数字面量类型。有名函数的定义相当于初始化一个函数字面量类型后将其赋值给一个函数名变量；“匿名函数”的定义也是直接初始化一个函数字面量类型，只是没有绑定到一个具体变量上。从Go类型系统的角度来看，“有名函数”和“匿名函数”都是函数字面量类型的实例。</p>
<p><strong>函数命名类型</strong></p>
<p>从前面章节知道可以使用<code>type NewType OldType</code>语法定义一种新类型，这种类型都是命名类型，同理可以使用该方法定义一种新类型：函数命名类型，简称函数类型。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewFuncType FuncLiteral</span><br></pre></td></tr></table></figure></p>
<p>依据Go语言类型系统的概念，NewFuncType为新定义的函数命名类型，FuncLiteral为函数字面量类型，FuncLiteral为函数类型NewFuncType的底层类型。当然也可以使用type在一个函数类型中再定义一个新的函数类型，这种用法在语法上是允许的，但很少这么使用。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewFuncType OldFuncType</span><br></pre></td></tr></table></figure></p>
<p><strong>函数签名</strong></p>
<p>有了上面的基础，函数签名就比较好理解了，所谓“函数签名”就是“有名函数”或“匿名函数”的字面量类型。所以有名函数和匿名函数的函数签名可以相同，函数签名是函数的“字面量类型”，不包括函数名。</p>
<p><strong>函数声明</strong></p>
<p>Go语言没有C语言中函数声明的语义，准确地说，Go代码调用Go编写的函数不需要声明，可以直接调用，但Go调用汇编语言编写的函数还是要使用函数声明语句，示例如下。这里讨论的函数声明主要是为4.1节中接口的方法声明做铺垫。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明=函数名+函数签名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数签名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(InputTypeList)</span> <span class="title">OutputTypeList</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 函数声明</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">FuncName</span> <span class="params">(InputTypeList)</span> <span class="title">OutputTypeList</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面通过一个具体的示例来说明上述概念。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有名函数定义，函数名是add</span></span><br><span class="line"><span class="comment">// add类型是函数字面量类型func (int, int) int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明语句，用于Go代码调用汇编代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">add</span>函数的签名，实际上就是<span class="title">add</span>的字面量类型</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 匿名函数不能独立存在，常作为函数参数、返回值，或者赋值给某个变量</span></span><br><span class="line"><span class="function">// 匿名函数可以直接显式初始化</span></span><br><span class="line"><span class="function">// 匿名函数的类型也是函数字面量类型 <span class="title">func</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新定义函数类型ADD</span></span><br><span class="line"><span class="comment">// ADD底层类型是函数字面量类型 func (int, int) int</span></span><br><span class="line"><span class="keyword">type</span> ADD <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">add</span>和<span class="title">ADD</span>的底层类型相同，并且<span class="title">add</span>是字面量类型</span></span><br><span class="line"><span class="function">// 所以<span class="title">add</span>可直接赋值给<span class="title">ADD</span>类型的变量<span class="title">g</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">g</span> <span class="title">ADD</span> = <span class="title">add</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    f(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f和add的函数签名相同</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, f) <span class="comment">// func(int, int) int</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, add) <span class="comment">// func(int, int) int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面谈到字面量类型是一种未命名类型（unnamed type），其不能定义自己的方法，所以必须显式地使用type声明一个有名函数类型，然后为其添加方法。通常说的函数类型就是指有名函数类型，“函数签名”是指函数的字面量类型，在很多地方把函数类型和函数签名等价使用，这是不严谨的。由类型转换的规则可知：这两种类型的底层类型相同，并且其中一个是字面量类型，二者是可以相互转换的。下面来看一下经典的http标准库对函数类型的实现，进一步理解这种用法。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/net/http/server. go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义ー个有名函数类型HandlerFunc</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 为有名的函数类型添加方法</span></span><br><span class="line"><span class="function">// 这是一种包装器的程技法</span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span> <span class="params">( w , r )</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">( f HandlerFunc)</span><span class="title">servehttp</span><span class="params">(w ResponseWriter ,   r *Request )</span></span>   &#123;</span><br><span class="line">    f ( w , r )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数类型 Handlerfunc实现了接ロ Handler的方法</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    Servehttp(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 所以<span class="title">HandlerFunc</span>类型的变量可以传递给<span class="title">Handler</span>接口变量</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(mux *ServeMux)</span><span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter *Request)</span></span> &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过http标准库里面对于函数类型的使用，我们可以看到函数类型的如下意义：</p>
<p>（1）函数也是一种类型，可以在函数字面量类型的基础上定义一种命名函数类型。</p>
<p>（2）有名函数和匿名函数的函数签名与命名函数类型的底层类型相同，它们之间可以进行类型转换。</p>
<p>（3）可以为有名函数类型添加方法，这种为一个函数类型添加方法的技法非常有价值，可以方便地为一个函数增加“拦截”或“过滤”等额外功能，这提供了一种装饰设计模式。</p>
<p>（4）为有名函数类型添加方法，使其与接口打通关系，使用接口的地方可以传递函数类型的变量，这为函数到接口的转换开启了大门。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言核心编程/" rel="tag"># Go语言核心编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/11/原油价格跌破认知底线，血流成河的散户，被资本主义的铁拳狠狠教育了/" rel="next" title="原油价格跌破认知底线，血流成河的散户，被资本主义的铁拳狠狠教育了">
                <i class="fa fa-chevron-left"></i> 原油价格跌破认知底线，血流成河的散户，被资本主义的铁拳狠狠教育了
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/14/第5章-函数-1/" rel="prev" title="第5章 函数">
                第5章 函数 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#类型简介"><span class="nav-number">1.</span> <span class="nav-text">类型简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#命名类型和未命名类型"><span class="nav-number">1.1.</span> <span class="nav-text">命名类型和未命名类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#底层类型"><span class="nav-number">1.2.</span> <span class="nav-text">底层类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型相同和类型赋值"><span class="nav-number">1.3.</span> <span class="nav-text">类型相同和类型赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型强制转换"><span class="nav-number">1.4.</span> <span class="nav-text">类型强制转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型方法"><span class="nav-number">2.</span> <span class="nav-text">类型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义类型"><span class="nav-number">2.1.</span> <span class="nav-text">自定义类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">2.2.</span> <span class="nav-text">方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法调用"><span class="nav-number">3.</span> <span class="nav-text">方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一般调用"><span class="nav-number">3.1.</span> <span class="nav-text">一般调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法值（method-value）"><span class="nav-number">3.2.</span> <span class="nav-text">方法值（method value）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法表达式（method-expression）"><span class="nav-number">3.3.</span> <span class="nav-text">方法表达式（method expression）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法集（method-set）"><span class="nav-number">3.4.</span> <span class="nav-text">方法集（method set）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#值调用和表达式调用的方法集"><span class="nav-number">3.5.</span> <span class="nav-text">值调用和表达式调用的方法集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合和方法集"><span class="nav-number">4.</span> <span class="nav-text">组合和方法集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#组合"><span class="nav-number">4.1.</span> <span class="nav-text">组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合的方法集"><span class="nav-number">4.2.</span> <span class="nav-text">组合的方法集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数类型"><span class="nav-number">5.</span> <span class="nav-text">函数类型</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
