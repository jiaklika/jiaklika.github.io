<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  字典树是什么？">
<meta name="keywords" content="手把手带你写一个Web框架">
<meta property="og:type" content="article">
<meta property="og:title" content="03｜路由：如何让请求更快寻找到目标函数？">
<meta property="og:url" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  字典树是什么？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/1.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/2.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/3.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/4.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/4.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/5.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/6.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/7.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/8.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/10.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/11.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/12.webp">
<meta property="og:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/13.webp">
<meta property="og:updated_time" content="2022-05-07T03:17:35.293Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="03｜路由：如何让请求更快寻找到目标函数？">
<meta name="twitter:description" content="思考并回答以下问题：  字典树是什么？">
<meta name="twitter:image" content="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/1.webp">






  <link rel="canonical" href="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>03｜路由：如何让请求更快寻找到目标函数？ | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看书不是为了学习，是为了锻炼意志力">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">03｜路由：如何让请求更快寻找到目标函数？

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-12-20 11:04:47" itemprop="dateCreated datePublished" datetime="2021-12-20T11:04:47+08:00">2021-12-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-05-07 11:17:35" itemprop="dateModified" datetime="2022-05-07T11:17:35+08:00">2022-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">19k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">17 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>字典树是什么？</li>
</ul>
<a id="more"></a>
<p>上一讲，我们封装了框架的Context，将请求结构request和返回结构responseWriter都封装在Context中。利用这个Context，我们将控制器简化为带有一个参数的函数FooControllerHandler，这个控制器函数的输入和输出都是固定的。在框架层面，我们也定义了对应关于控制器的方法结构ControllerHandler来代表这类控制器的函数。</p>
<p>每一个请求逻辑，都有一个控制器ControllerHandler与之对应。那么一个请求，如何查找到指定的控制器呢？这就是今天要研究的内容：路由，我将带你理解路由，并且实现一个高效、易用的路由模块。</p>
<h1 id="路由设计思路"><a href="#路由设计思路" class="headerlink" title="路由设计思路"></a><span style="color:#339AFF;">路由设计思路</span></h1><p>相信你对路由是干啥的已经有大致了解，具体来说就是让Web服务器根据规则，理解HTTP请求中的信息，匹配查找出对应的控制器，再将请求传递给控制器执行业务逻辑，简单来说就是制定匹配规则。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/1.webp">
<p>但是就是这么简单的功能，路由的设计感不同，可用性有天壤之别。为什么这么说呢，我们带着这个问题，先来梳理一下制定路由规则需要的信息。</p>
<p>路由可以使用HTTP请求体中的哪些信息，得回顾我们第一节课讲HTTP的内容。</p>
<p>一个HTTP请求包含请求头和请求体。请求体内一般存放的是请求的业务数据，是基于具体控制业务需要的，所以，我们不会用来做路由。</p>
<p>而请求头中存放的是和请求状态有关的信息，比如User-Agent代表的是请求的浏览器信息，Accept代表的是支持返回的文本类型。以下是一个标准请求头的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /home.html HTTP/1.1</span><br><span class="line">Host: developer.mozilla.org</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 </span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Referer: https://developer.mozilla.org/testpage.html</span><br></pre></td></tr></table></figure></p>
<p>每一行的信息和含义都是非常大的课题，也与今天要讲的内容无关，我们这里要关注的是HTTP请求的第一行，叫做Request Line，由三个部分组成：Method、Request-URI和HTTP-Version（RFC2616）。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/2.webp">
<p>Method是HTTP的方法，标识对服务端资源的操作属性。它包含多个方法，每个方法都代表不同的操作属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Method         = &quot;OPTIONS&quot;                ; Section 9.2</span><br><span class="line">              | &quot;GET&quot;                    ; Section 9.3</span><br><span class="line">              | &quot;HEAD&quot;                   ; Section 9.4</span><br><span class="line">              | &quot;POST&quot;                   ; Section 9.5</span><br><span class="line">              | &quot;PUT&quot;                    ; Section 9.6</span><br><span class="line">              | &quot;DELETE&quot;                 ; Section 9.7</span><br><span class="line">              | &quot;TRACE&quot;                  ; Section 9.8</span><br><span class="line">              | &quot;CONNECT&quot;                ; Section 9.9</span><br><span class="line">              | extension-method</span><br><span class="line">extension-method = token</span><br></pre></td></tr></table></figure></p>
<p>Request-URI是请求路径，也就是浏览器请求地址中域名外的剩余部分。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/3.webp">
<p>HTTP-Version是HTTP的协议版本，目前常见的有1.0、1.1、2.0。</p>
<p>WebService在路由中使用的就是Method和Request-URI这两个部分。了解制定路由规则时，请求体中可以使用的元素之后，我们再回答刚才的问题，什么是路由的设计感。</p>
<p>这里说的设计感指的是：框架设计者希望使用者如何用路由模块。</p>
<p>如果框架支持REST风格的路由设计，那么使用者在写业务代码的时候，就倾向于设计REST风格的接口；如果框架支持前缀匹配，那么使用者在定制URI的时候，也会倾向于把同类型的URI归为一类。</p>
<p>这些设计想法通通会体现在框架的路由规则上，最终影响框架使用者的研发习惯，这个就是设计感。所以其实，设计感和框架设计者偏好的研发风格直接相关，也没有绝对的优劣。</p>
<p>这里你很容易走入误区，我要说明一下。很多同学认为设计感的好坏体现在路由规则的多少上，其实不是。</p>
<p>路由规则，是根据路由来查找控制器的逻辑，它本身就是一个框架需求。我们可以天马行空设想100条路由规则，并且全部实现它，也可以只设计1、2个最简单的路由规则。很多或者很少的路由规则，都不会根本性影响使用者，所以，并不是衡量一个框架好坏的标准。</p>
<h1 id="路由规则的需求"><a href="#路由规则的需求" class="headerlink" title="路由规则的需求"></a><span style="color:#339AFF;">路由规则的需求</span></h1><p>回到我们的框架，开头我们说过希望使用者高效、易用地使用路由模块，那出于这一点考虑，基本需求可以有哪些呢？</p>
<p>按照从简单到复杂排序，路由需求我整理成下面四点：</p>
<ul>
<li>需求1：HTTP方法匹配</li>
</ul>
<p>早期的WebService比较简单，HTTP请求体中的Request Line或许只会使用到Request-URI部分，但是随着REST风格WebService的流行，为了让URI更具可读性，在现在的路由输入中，HTTP Method也是很重要的一部分了，所以，我们框架也需要支持多种HTTP Method，比如GET、POST、PUT、DELETE。</p>
<ul>
<li>需求2：静态路由匹配</li>
</ul>
<p>静态路由匹配是一个路由的基本功能，指的是路由规则中没有可变参数，即路由规则地址是固定的，与Request-URI完全匹配。</p>
<p>我们在第一讲中提到的DefaultServerMux这个路由器，从内部的map中直接根据key寻找value，这种查找路由的方式就是静态路由匹配。</p>
<ul>
<li>需求3：批量通用前缀</li>
</ul>
<p>因为业务模块的划分，我们会同时为某个业务模块注册一批路由，所以在路由注册过程中，为了路由的可读性，一般习惯统一定义这批路由的通用前缀。比如/user/info、/user/login都是以/user开头，很方便使用者了解页面所属模块。</p>
<p>所以如果路由有能力统一定义批量的通用前缀，那么在注册路由的过程中，会带来很大的便利。</p>
<ul>
<li>需求4：动态路由匹配</li>
</ul>
<p>这个需求是针对需求2改进的，因为URL中某个字段或者某些字段并不是固定的，是按照一定规则（比如是数字）变化的。那么，我们希望路由也能够支持这个规则，将这个动态变化的路由URL匹配出来。所以我们需要，使用自己定义的路由来补充，只支持静态匹配的DefaultServerMux默认路由。</p>
<p>现在四个最基本的需求我们已经整理出来了，接下来通过一个例子来解释下，比如我们需要能够支持一个日志网站的这些功能：</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/4.webp">
<p>接下来就是今天的重头戏了，要匹配这样的路由列表，路由规则定义代码怎么写呢？我把最终的使用代码贴在这里，你可以先看看，然后我们一步步实现，分析清楚每行代码背后的方法如何定义、为什么要这么定义。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerRouter</span><span class="params">(core *framework.Core)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需求1+2:HTTP方法+静态路由匹配</span></span><br><span class="line">    core.Post(<span class="string">"/user/login"</span>, UserLoginController)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求3:批量通用前缀</span></span><br><span class="line">    subjectApi := core.Group(<span class="string">"/subject"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subjectApi.Post(<span class="string">"/add"</span>, SubjectAddController)</span><br><span class="line">            <span class="comment">// 需求4:动态路由</span></span><br><span class="line">        subjectApi.Delete(<span class="string">"/:id"</span>, SubjectDelController)</span><br><span class="line">        subjectApi.Put(<span class="string">"/:id"</span>, SubjectUpdateController)</span><br><span class="line">        subjectApi.Get(<span class="string">"/:id"</span>, SubjectGetController)</span><br><span class="line">            subjectApi.Get(<span class="string">"/list/all"</span>, SubjectListController)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（这段代码会在最后补充到上节课中创建的业务目录中的路由文件router.go。）</p>
<h1 id="实现HTTP方法和静态路由匹配"><a href="#实现HTTP方法和静态路由匹配" class="headerlink" title="实现HTTP方法和静态路由匹配"></a><span style="color:#339AFF;">实现HTTP方法和静态路由匹配</span></h1><p>我们首先看第一个需求和第二个需求。由于有两个待匹配的规则，Request-URI和Method，所以自然联想到可以使用两级哈希表来创建映射。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/4.webp">
<p>第一级hash是请求Method，第二级hash是Request-URI。</p>
<p>这个路由map我们会存放在第一讲定义的Core结构里（如下），并且在初始化Core结构的时候，初始化第一层map。所以还是拉出geekbang/03分支，来更新框架文件夹中的core.go文件：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 框架核心结构</span></span><br><span class="line"><span class="keyword">type</span> Core <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化框架核心结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCore</span><span class="params">()</span> *<span class="title">Core</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Core&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架核心结构实现Handler接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">ServeHTTP</span><span class="params">(response http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们按框架使用者使用路由的顺序分成四步来完善这个结构：定义路由map、注册路由、匹配路由、填充ServeHTTP方法。</p>
<p>首先，第一层map的每个key值都代表Method，而且为了避免之后在匹配的时候，要转换一次大小写，我们将每个key都设置为大写。继续在框架文件夹中的core.go文件里写：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 框架核心结构</span></span><br><span class="line"><span class="keyword">type</span> Core <span class="keyword">struct</span> &#123;</span><br><span class="line">    router <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]ControllerHandler <span class="comment">// 二级map</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化框架核心结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCore</span><span class="params">()</span> *<span class="title">Core</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义二级map</span></span><br><span class="line">    getRouter := <span class="keyword">map</span>[<span class="keyword">string</span>]ControllerHandler&#123;&#125;</span><br><span class="line">    postRouter := <span class="keyword">map</span>[<span class="keyword">string</span>]ControllerHandler&#123;&#125;</span><br><span class="line">    putRouter := <span class="keyword">map</span>[<span class="keyword">string</span>]ControllerHandler&#123;&#125;</span><br><span class="line">    deleteRouter := <span class="keyword">map</span>[<span class="keyword">string</span>]ControllerHandler&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将二级map写入一级map</span></span><br><span class="line">    router := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]ControllerHandler&#123;&#125;</span><br><span class="line">    router[<span class="string">"GET"</span>] = getRouter</span><br><span class="line">    router[<span class="string">"POST"</span>] = postRouter</span><br><span class="line">    router[<span class="string">"PUT"</span>] = putRouter</span><br><span class="line">    router[<span class="string">"DELETE"</span>] = deleteRouter</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;Core&#123;router: router&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下一步就是路由注册，我们将路由注册函数按照Method名拆分为4个方法：Get、Post、Put和Delete。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应 Method = Get</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    upperUrl := strings.ToUpper(url)</span><br><span class="line">    c.router[<span class="string">"GET"</span>][upperUrl] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 Method = POST</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Post</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    upperUrl := strings.ToUpper(url)</span><br><span class="line">    c.router[<span class="string">"POST"</span>][upperUrl] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 Method = PUT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Put</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    upperUrl := strings.ToUpper(url)</span><br><span class="line">    c.router[<span class="string">"PUT"</span>][upperUrl] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应 Method = DELETE</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Delete</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    upperUrl := strings.ToUpper(url)</span><br><span class="line">    c.router[<span class="string">"DELETE"</span>][upperUrl] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们这里将URL全部转换为大写了，在后续匹配路由的时候，也要记得把匹配的URL进行大写转换，这样我们的路由就会是“大小写不敏感”的，对使用者的容错性就大大增加了。</p>
<p>注册完路由之后，如何匹配路由就是我们第三步需要做的事情了。首先我们实现匹配路由方法，这个匹配路由的逻辑我用注释写在代码中了。继续在框架文件夹中的core.go文件里写入：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配路由，如果没有匹配到，返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">FindRouteByRequest</span><span class="params">(request *http.Request)</span> <span class="title">ControllerHandler</span></span> &#123;</span><br><span class="line">    <span class="comment">// uri 和 method 全部转换为大写，保证大小写不敏感</span></span><br><span class="line">    uri := request.URL.Path</span><br><span class="line">    method := request.Method</span><br><span class="line">    upperMethod := strings.ToUpper(method)</span><br><span class="line">    upperUri := strings.ToUpper(uri)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一层map</span></span><br><span class="line">    <span class="keyword">if</span> methodHandlers, ok := c.router[upperMethod]; ok &#123;</span><br><span class="line">        <span class="comment">// 查找第二层map</span></span><br><span class="line">        <span class="keyword">if</span> handler, ok := methodHandlers[upperUri]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> handler</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很容易看懂，匹配逻辑就是去二层哈希map中一层层匹配，先查找第一层匹配Method，再查第二层匹配Request-URI。</p>
<p>最后，我们就可以填充未实现的ServeHTTP方法了，所有请求都会进到这个函数中处理。（如果你有点模糊了，可以拿出第一节课中的思维导图，再巩固下net/http的核心逻辑。）继续在框架文件夹中的core.go文件里写：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">ServeHTTP</span><span class="params">(response http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装自定义context</span></span><br><span class="line">    ctx := NewContext(request, response)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找路由</span></span><br><span class="line">    router := c.FindRouteByRequest(request)</span><br><span class="line">    <span class="keyword">if</span> router == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有找到，这里打印日志</span></span><br><span class="line">        ctx.Json(<span class="number">404</span>, <span class="string">"not found"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用路由函数，如果返回err 代表存在内部错误，返回500状态码</span></span><br><span class="line">    <span class="keyword">if</span> err := router(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.Json(<span class="number">500</span>, <span class="string">"inner error"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数就把我们前面三讲的内容都串起来了。先封装第二讲创建的自定义Context，然后使用FindRouteByRequest函数寻找我们需要的路由，如果没有找到路由，返回404状态码；如果找到了路由，就调用路由控制器，另外如果路由控制器出现内部错误，返回500状态码。</p>
<p>到这里，第一个和第二个需求就都完成了。</p>
<h1 id="实现批量通用前缀"><a href="#实现批量通用前缀" class="headerlink" title="实现批量通用前缀"></a><span style="color:#339AFF;">实现批量通用前缀</span></h1><p>对于第三个需求，我们可以通过一个Group方法归拢路由前缀地址。修正在业务文件夹下的route.go文件，使用方法改成这样：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerRouter</span><span class="params">(core *framework.Core)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需求1+2:HTTP方法+静态路由匹配</span></span><br><span class="line">    core.Get(<span class="string">"/user/login"</span>, UserLoginController)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求3:批量通用前缀</span></span><br><span class="line">    subjectApi := core.Group(<span class="string">"/subject"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subjectApi.Get(<span class="string">"/list"</span>, SubjectListController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看下这个Group方法，它的参数是一个前缀字符串，返回值应该是包含Get、Post、Put、Delete方法的一个结构，我们给这个结构命名Group，在其中实现各种方法。</p>
<p>在这里我们暂停一下，看看有没有优化点。</p>
<p>这么设计直接返回Group结构，确实可以实现功能，但试想一下，随着框架发展，如果我们发现Group结构的具体实现并不符合我们的要求了，需要引入实现另一个Group2结构，该怎么办？直接修改Group结构的具体实现么？</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/5.webp">
<p>其实更好的办法是使用接口来替代结构定义。在框架设计之初，我们要保证框架使用者，在最少的改动中，就能流畅迁移到Group2，这个时候，如果返回接口IGroup，而不是直接返回Group结构，就不需要修改core.Group的定义了，只需要修改core.Group的具体实现，返回Group2就可以。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/6.webp">
<p>尽量使用接口来解耦合，是一种比较好的设计思路。</p>
<p>怎么实现呢，这里我们定义IGroup接口来作为Group方法的返回值。在框架文件夹下创建group.go文件来存放分组相关的信息：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IGroup 代表前缀分组</span></span><br><span class="line"><span class="keyword">type</span> IGroup <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(<span class="keyword">string</span>, ControllerHandler)</span><br><span class="line">    Post(<span class="keyword">string</span>, ControllerHandler)</span><br><span class="line">    Put(<span class="keyword">string</span>, ControllerHandler)</span><br><span class="line">    Delete(<span class="keyword">string</span>, ControllerHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且继续搭好Group结构代码来实现这个接口：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGroup</span><span class="params">(core *Core, prefix <span class="keyword">string</span>)</span> *<span class="title">Group</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Group&#123;</span><br><span class="line">        core:   core,</span><br><span class="line">        prefix: prefix,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Get方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Get</span><span class="params">(uri <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    uri = g.prefix + uri</span><br><span class="line">    g.core.Get(uri, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从core中初始化这个Group</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Group</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">IGroup</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> NewGroup(c, prefix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个Group结构包含自身的前缀地址和Core结构的指针。它的Get、Put、Post、Delete方法就是把这个Group结构的前缀地址和目标地址组合起来，作为Core的Request-URI地址。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/7.webp">
<p>讲到这里，有的同学可能不以为然，觉得这不就是个人代码风格的问题吗。其实并不是，希望你能够意识到，这个选择并不仅仅是代码风格，而是关于框架设计、关于代码扩展性。</p>
<p>接口是一种协议，它忽略具体的实现，定义的是两个逻辑结构的交互，因为两个函数之间定义的是一种约定，不依赖具体的实现。</p>
<p>你可以这么判断：如果你觉得这个模块是完整的，而且后续希望有扩展的可能性，那么就应该尽量使用接口来替代实现。在代码中，多大程度使用接口进行逻辑结构的交互，是评价框架代码可扩展性的一个很好的标准。这种思维会贯穿在我们整个框架的设计中，后续我会时不时再提起的。</p>
<p>所以回到我们的路由，使用IGroup接口后，core.Group这个方法返回的是一个约定，而不依赖具体的Group实现。</p>
<h1 id="实现动态路由匹配"><a href="#实现动态路由匹配" class="headerlink" title="实现动态路由匹配"></a><span style="color:#339AFF;">实现动态路由匹配</span></h1><p>现在已经完成了前三个需求，下面我们考虑第四个需求，希望在写业务的时候能支持像下列这种动态路由：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerRouter</span><span class="params">(core *framework.Core)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需求1+2:HTTP方法+静态路由匹配</span></span><br><span class="line">    core.Get(<span class="string">"/user/login"</span>, UserLoginController)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求3:批量通用前缀</span></span><br><span class="line">    subjectApi := core.Group(<span class="string">"/subject"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需求4:动态路由</span></span><br><span class="line">        subjectApi.Delete(<span class="string">"/:id"</span>, SubjectDelController)</span><br><span class="line">        subjectApi.Put(<span class="string">"/:id"</span>, SubjectUpdateController)</span><br><span class="line">        subjectApi.Get(<span class="string">"/:id"</span>, SubjectGetController)</span><br><span class="line">        subjectApi.Get(<span class="string">"/list/all"</span>, SubjectListController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如何实现？我们继续看。</p>
<p>首先，你要知道的是，一旦引入了动态路由匹配的规则，之前使用的哈希规则就无法使用了。因为有通配符，在匹配Request-URI的时候，请求URI的某个字符或者某些字符是动态变化的，无法使用URI做为key来匹配。那么，我们就需要其他的算法来支持路由匹配。</p>
<p>如果你对算法比较熟悉，会联想到这个问题本质是一个字符串匹配，而字符串匹配，比较通用的高效方法就是字典树，也叫trie树。</p>
<p>这里，我们先简单梳理下trie树的数据结构。trie树不同于二叉树，它是多叉的树形结构，根节点一般是空字符串，而叶子节点保存的通常是字符串，一个节点的所有子孙节点都有相同的字符串前缀。</p>
<p>所以根据trie树的特性，我们结合前三条路由规则，可以构建出这样的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 /user/login</span><br><span class="line">2 /user/logout</span><br><span class="line">3 /subject/name</span><br><span class="line">4 /subject/name/age</span><br><span class="line">5 /subject/:id/name</span><br></pre></td></tr></table></figure></p>
<p>画成图更清晰一些：</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/8.webp">
<p>这个trie树是按照路由地址的每个段(segment)来切分的，每个segment在trie树中都能找到对应节点，每个节点保存一个segment。树中，每个叶子节点都代表一个URI，对于中间节点来说，有的中间节点代表一个URI（比如上图中的/subject/name），而有的中间节点并不是一个URI（因为没有路由规则对应这个URI）。</p>
<p>现在分析清楚了，我们开始动手实现trie树。还是照旧先明确下可以分为几步：</p>
<p>1，定义树和节点的数据结构</p>
<p>2，编写函数：“增加路由规则”</p>
<p>3，编写函数：“查找路由”</p>
<p>4，将“增加路由规则”和“查找路由”添加到框架中</p>
<p>步骤非常清晰，好，废话不多说，我们一步一步来，首先定义对应的数据结构（node和tree）。先在框架文件夹下创建tree.go文件，存储trie树相关逻辑<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表树结构</span></span><br><span class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</span><br><span class="line">    root *node <span class="comment">// 根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表节点</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    isLast  <span class="keyword">bool</span>              <span class="comment">// 代表这个节点是否可以成为最终的路由规则。该节点是否能成为一个独立的uri, 是否自身就是一个终极节点</span></span><br><span class="line">    segment <span class="keyword">string</span>            <span class="comment">// uri中的字符串，代表这个节点表示的路由中某个段的字符串</span></span><br><span class="line">    handler ControllerHandler <span class="comment">// 代表这个节点中包含的控制器，用于最终加载调用</span></span><br><span class="line">    childs  []*node           <span class="comment">// 代表这个节点下的子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Tree结构中包含一个根节点，只是这个根节点是一个没有segment的空的根节点。</p>
<p>node的结构定义了四个字段。childs字段让node组成了一个树形结构，handler是具体的业务控制器逻辑存放位置，segment是树中的这个节点存放的内容，isLast用于区别这个树中的节点是否有实际的路由含义。</p>
<p>有了数据结构后，第二步，我们就往Tree这个trie树结构中增加“路由规则”的逻辑。写之前，我们还是暂停一下想一想，会不会出现问题。之前提过会存在通配符，那直接加规则其实是有可能冲突的。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/user/name</span><br><span class="line">/user/:id</span><br></pre></td></tr></table></figure></p>
<p>这两个路由规则实际上就冲突了，如果请求地址是/user/name，那么两个规则都匹配，无法确定哪个规则生效。所以在增加路由之前，我们需要判断这个路由规则是否已经在trie树中存在了。</p>
<p>这里，我们可以用matchNode方法，寻找某个路由在trie树中匹配的节点，如果有匹配节点，返回节点指针，否则返回nil。matchNode方法的参数是一个URI，返回值是指向node的指针，它的实现思路是使用函数递归，我简单说明一下思路：</p>
<p>首先，将需要匹配的URI根据第一个分隔符/进行分割，只需要最多分割成为两个段。</p>
<p>如果只能分割成一个段，说明URI中没有分隔符了，这时候再检查下一级节点中是否有匹配这个段的节点就行。</p>
<p>如果分割成了两个段，我们用第一个段来检查下一个级节点中是否有匹配这个段的节点。</p>
<ul>
<li>如果没有，说明这个路由规则在树中匹配不到。</li>
<li>如果下一级节点中有符合第一个分割段的（这里需要注意可能不止一个符合），我们就将所有符合的节点进行函数递归，重新应用于matchNode函数中，只不过这时候matchNode函数作用于子节点，参数变成了切割后的第二个段。</li>
</ul>
<p>好思路就讲完了，整个流程里，会频繁使用到“过滤下一层满足segment规则的子节点”，所以我们也用一个函数filterChildNodes将它封装起来。这个函数的逻辑就比较简单了：遍历下一层子节点，判断segment是否匹配传入的参数segment。</p>
<p>在框架文件夹中的tree.go中，我们完成matchNode和filterChildNodes完整代码实现，放在这里了，具体逻辑我也加了详细的批注帮你理解。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断路由是否已经在节点的所有子节点树中存在了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *node)</span> <span class="title">matchNode</span><span class="params">(uri <span class="keyword">string</span>)</span> *<span class="title">node</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用分隔符将uri切割为两个部分</span></span><br><span class="line">    segments := strings.SplitN(uri, <span class="string">"/"</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 第一个部分用于匹配下一层子节点</span></span><br><span class="line">    segment := segments[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> !isWildSegment(segment) &#123;</span><br><span class="line">        segment = strings.ToUpper(segment)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配符合的下一层子节点</span></span><br><span class="line">    cnodes := n.filterChildNodes(segment)</span><br><span class="line">    <span class="comment">// 如果当前子节点没有一个符合，那么说明这个uri一定是之前不存在, 直接返回nil</span></span><br><span class="line">    <span class="keyword">if</span> cnodes == <span class="literal">nil</span> || <span class="built_in">len</span>(cnodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只有一个segment，则是最后一个标记</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(segments) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 如果segment已经是最后一个节点，判断这些cnode是否有isLast标志</span></span><br><span class="line">        <span class="keyword">for</span> _, tn := <span class="keyword">range</span> cnodes &#123;</span><br><span class="line">            <span class="keyword">if</span> tn.isLast &#123;</span><br><span class="line">                <span class="keyword">return</span> tn</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 都不是最后一个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有2个segment, 递归每个子节点继续进行查找</span></span><br><span class="line">    <span class="keyword">for</span> _, tn := <span class="keyword">range</span> cnodes &#123;</span><br><span class="line">        tnMatch := tn.matchNode(segments[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> tnMatch != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tnMatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在有了matchNode和filterChildNodes函数，我们就可以开始写第二步里最核心的增加路由的函数逻辑了。</p>
<p>首先，确认路由是否冲突。我们先检查要增加的路由规则是否在树中已经有可以匹配的节点了。如果有的话，代表当前待增加的路由和已有路由存在冲突，这里我们用到了刚刚定义的matchNode。更新刚才框架文件夹中的tree.go文件：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加路由节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *Tree)</span> <span class="title">AddRouter</span><span class="params">(uri <span class="keyword">string</span>, handler ControllerHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    n := tree.root</span><br><span class="line">    <span class="comment">// 确认路由是否冲突</span></span><br><span class="line">    <span class="keyword">if</span> n.matchNode(uri) != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"route exist: "</span> + uri)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后继续增加路由规则。我们增加路由的每个段时，先去树的每一层中匹配查找，如果已经有了符合这个段的节点，就不需要创建节点，继续匹配待增加路由的下个段；否则，需要创建一个新的节点用来代表这个段。这里，我们用到了定义的filterChildNodes。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加路由节点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/book/list</span></span><br><span class="line"><span class="comment">/book/:id (冲突)</span></span><br><span class="line"><span class="comment">/book/:id/name</span></span><br><span class="line"><span class="comment">/book/:student/age</span></span><br><span class="line"><span class="comment">/:user/name</span></span><br><span class="line"><span class="comment">/:user/name/:age(冲突)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *Tree)</span> <span class="title">AddRouter</span><span class="params">(uri <span class="keyword">string</span>, handler ControllerHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    n := tree.root</span><br><span class="line">    <span class="keyword">if</span> n.matchNode(uri) != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">"route exist: "</span> + uri)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    segments := strings.Split(uri, <span class="string">"/"</span>)</span><br><span class="line">    <span class="comment">// 对每个segment</span></span><br><span class="line">    <span class="keyword">for</span> index, segment := <span class="keyword">range</span> segments &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终进入Node segment的字段</span></span><br><span class="line">        <span class="keyword">if</span> !isWildSegment(segment) &#123;</span><br><span class="line">            segment = strings.ToUpper(segment)</span><br><span class="line">        &#125;</span><br><span class="line">        isLast := index == <span class="built_in">len</span>(segments)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> objNode *node <span class="comment">// 标记是否有合适的子节点</span></span><br><span class="line"></span><br><span class="line">        childNodes := n.filterChildNodes(segment)</span><br><span class="line">        <span class="comment">// 如果有匹配的子节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(childNodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 如果有segment相同的子节点，则选择这个子节点</span></span><br><span class="line">            <span class="keyword">for</span> _, cnode := <span class="keyword">range</span> childNodes &#123;</span><br><span class="line">                <span class="keyword">if</span> cnode.segment == segment &#123;</span><br><span class="line">                    objNode = cnode</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> objNode == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个当前node的节点</span></span><br><span class="line">            cnode := newNode()</span><br><span class="line">            cnode.segment = segment</span><br><span class="line">            <span class="keyword">if</span> isLast &#123;</span><br><span class="line">                cnode.isLast = <span class="literal">true</span></span><br><span class="line">                cnode.handler = handler</span><br><span class="line">            &#125;</span><br><span class="line">            n.childs = <span class="built_in">append</span>(n.childs, cnode)</span><br><span class="line">            objNode = cnode</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = objNode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，第二步增加路由的规则逻辑已经有了，我们要开始第三步，编写“查找路由”的逻辑。这里你会发现，由于我们之前已经定义过matchNode（匹配路由节点），所以这里只需要复用这个函数就行了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配uri</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *Tree)</span> <span class="title">FindHandler</span><span class="params">(uri <span class="keyword">string</span>)</span> <span class="title">ControllerHandler</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接复用matchNode函数，uri是不带通配符的地址</span></span><br><span class="line">    matchNode := tree.root.matchNode(uri)</span><br><span class="line">    <span class="keyword">if</span> matchNode == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchNode.handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前三步已经完成了，最后一步，我们把“增加路由规则”和“查找路由”添加到框架中。还记得吗，在静态路由匹配的时候，在Core中使用哈希定义的路由，这里将哈希替换为trie树。还是在框架文件夹中的core.go文件，找到对应位置作修改：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Core <span class="keyword">struct</span> &#123;</span><br><span class="line">    router <span class="keyword">map</span>[<span class="keyword">string</span>]*Tree <span class="comment">// all routers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应路由增加的方法，也从哈希的增加逻辑，替换为trie树的“增加路由规则”逻辑。同样更新core.go文件中的下列方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配GET 方法, 增加路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := c.router[<span class="string">"GET"</span>].AddRouter(url, handler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"add router error: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配POST 方法, 增加路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Post</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := c.router[<span class="string">"POST"</span>].AddRouter(url, handler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"add router error: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配PUT 方法, 增加路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Put</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := c.router[<span class="string">"PUT"</span>].AddRouter(url, handler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"add router error: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配DELETE 方法, 增加路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">Delete</span><span class="params">(url <span class="keyword">string</span>, handler ControllerHandler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := c.router[<span class="string">"DELETE"</span>].AddRouter(url, handler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"add router error: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前在Core中定义的匹配路由函数的实现逻辑，从哈希匹配修改为trie树匹配就可以了。继续更新core.go文件：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配路由，如果没有匹配到，返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span> <span class="title">FindRouteByRequest</span><span class="params">(request *http.Request)</span> <span class="title">ControllerHandler</span></span> &#123;</span><br><span class="line">    <span class="comment">// uri 和 method 全部转换为大写，保证大小写不敏感</span></span><br><span class="line">    uri := request.URL.Path</span><br><span class="line">    method := request.Method</span><br><span class="line">    upperMethod := strings.ToUpper(method)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一层map</span></span><br><span class="line">    <span class="keyword">if</span> methodHandlers, ok := c.router[upperMethod]; ok &#123;</span><br><span class="line">        <span class="keyword">return</span> methodHandlers.FindHandler(uri)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>动态匹配规则就改造完成了。</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a><span style="color:#339AFF;">验证</span></h1><p>现在，四个需求都已经实现了。我们验证一下：定义包含有静态路由、批量通用前缀、动态路由的路由规则，每个控制器我们就直接输出控制器的名字，然后启动服务。</p>
<p>这个时候我们就可以去修改业务文件夹下的路由文件route.go：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerRouter</span><span class="params">(core *framework.Core)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 需求1+2:HTTP方法+静态路由匹配</span></span><br><span class="line">    core.Get(<span class="string">"/user/login"</span>, UserLoginController)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求3:批量通用前缀</span></span><br><span class="line">    subjectApi := core.Group(<span class="string">"/subject"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 需求4:动态路由</span></span><br><span class="line">        subjectApi.Delete(<span class="string">"/:id"</span>, SubjectDelController)</span><br><span class="line">        subjectApi.Put(<span class="string">"/:id"</span>, SubjectUpdateController)</span><br><span class="line">        subjectApi.Get(<span class="string">"/:id"</span>, SubjectGetController)</span><br><span class="line">        subjectApi.Get(<span class="string">"/list/all"</span>, SubjectListController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时在业务文件夹下创建对应的业务控制器user_controller.go和subject_controller.go。具体里面的逻辑代码就是打印出对应的控制器名字，比如<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserLoginController</span><span class="params">(c *framework.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打印控制器名字</span></span><br><span class="line">    c.Json(<span class="number">200</span>, <span class="string">"ok, UserLoginController"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来看服务启动情况：访问地址/user/login匹配路由UserLoginContorller。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/10.webp">
<p>访问地址/subject/list/all匹配路由SubjectListController。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/11.webp">
<p>访问地址/subject/100匹配动态路由SubjectGetController。</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/12.webp">
<p>路由规则符合要求！</p>
<p>今天的文件及代码结构如下，新建的文件夹多一点你可以对照着GitHub再看看，代码地址在geekbang/03分支上：</p>
<img src="/2021/12/20/03｜路由：如何让请求更快寻找到目标函数？/13.webp">
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><span style="color:#339AFF;">小结</span></h1><p>在这一讲，我们一步步实现了满足四个需求的路由：HTTP方法匹配、批量通用前缀、静态路由匹配和动态路由匹配。</p>
<p>我们使用IGroup结构和在Core中定义key为方法的路由，实现了HTTP方法匹配、批量通用前缀这两个需求，并且用哈希来实现静态路由匹配，之后我们使用trie树算法替代哈希算法，实现了动态路由匹配的需求。</p>
<p>所以，你有没有发现，其实所谓的实现功能，写代码只是其中一小部分，如何思考、如何考虑容错性、扩展性和复用性，这个反而是更大的部分。</p>
<p>以今天实现的路由这个功能为例，你是否考虑到了URI的容错性，在Group返回时候是否使用接口增加扩展性，在实现动态匹配的时候是否考虑函数复用性。我们要记住的是，思路比代码实现更重要。</p>
<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a><span style="color:#339AFF;">思考题</span></h1><p>光说不练假把式，毕竟我们是实战课，那针对第三个需求“批量通用前缀”，我们扩展一下变成：需要能多层嵌套通用前缀，这么定义路由：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册路由规则</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerRouter</span><span class="params">(core *framework.Core)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 静态路由+HTTP方法匹配</span></span><br><span class="line">    core.Get(<span class="string">"/user/login"</span>, UserLoginController)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量通用前缀</span></span><br><span class="line">    subjectApi := core.Group(<span class="string">"/subject"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        subjectInnerApi := subjectApi.Group(<span class="string">"/info"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            subjectInnerApi.Get(<span class="string">"/name"</span>, SubjectNameController)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结合刚才说的考虑代码的设计感，你想一想如何实现呢？</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/手把手带你写一个Web框架/" rel="tag"># 手把手带你写一个Web框架</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/12/20/02｜Context：请求控制器，让每个请求都在掌控之中/" rel="next" title="02｜Context：请求控制器，让每个请求都在掌控之中">
                <i class="fa fa-chevron-left"></i> 02｜Context：请求控制器，让每个请求都在掌控之中
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/12/20/04｜中间件：如何提高框架的可拓展性？/" rel="prev" title="04｜中间件：如何提高框架的可拓展性？">
                04｜中间件：如何提高框架的可拓展性？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看书不是为了学习，是为了锻炼意志力</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">896</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/01/27/47｜故障容错：如何在Worker崩溃时进行重新调度？/" title="47｜故障容错：如何在Worker崩溃时进行重新调度？" target="_blank">47｜故障容错：如何在Worker崩溃时进行重新调度？</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/46｜Master任务调度：服务发现与资源管理/" title="46｜Master任务调度：服务发现与资源管理" target="_blank">46｜Master任务调度：服务发现与资源管理</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/45｜Master高可用：怎样借助etcd实现服务选主？/" title="45｜Master高可用：怎样借助etcd实现服务选主？" target="_blank">45｜Master高可用：怎样借助etcd实现服务选主？</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/44｜一个程序多种功能：构建子命令与flags/" title="44｜一个程序多种功能：构建子命令与flags" target="_blank">44｜一个程序多种功能：构建子命令与flags</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/27/43｜分布式协调：etcd读写、MVCC原理与监听机制/" title="43｜分布式协调：etcd读写、MVCC原理与监听机制" target="_blank">43｜分布式协调：etcd读写、MVCC原理与监听机制</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#路由设计思路"><span class="nav-number">1.</span> <span class="nav-text">路由设计思路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路由规则的需求"><span class="nav-number">2.</span> <span class="nav-text">路由规则的需求</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现HTTP方法和静态路由匹配"><span class="nav-number">3.</span> <span class="nav-text">实现HTTP方法和静态路由匹配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现批量通用前缀"><span class="nav-number">4.</span> <span class="nav-text">实现批量通用前缀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现动态路由匹配"><span class="nav-number">5.</span> <span class="nav-text">实现动态路由匹配</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#验证"><span class="nav-number">6.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#思考题"><span class="nav-number">8.</span> <span class="nav-text">思考题</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">7.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">114:14</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
