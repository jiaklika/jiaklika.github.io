<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go程序设计语言">
<meta property="og:type" content="article">
<meta property="og:title" content="第4章 复合数据类型">
<meta property="og:url" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/1.png">
<meta property="og:image" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/2.png">
<meta property="og:image" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/3.png">
<meta property="og:image" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/4.png">
<meta property="og:image" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/5.png">
<meta property="og:image" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/6.png">
<meta property="og:updated_time" content="2023-01-20T07:00:16.726Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第4章 复合数据类型">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="twitter:image" content="http://yoursite.com/2021/07/18/第4章-复合数据类型/1.png">






  <link rel="canonical" href="http://yoursite.com/2021/07/18/第4章-复合数据类型/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第4章 复合数据类型 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/18/第4章-复合数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第4章 复合数据类型

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-07-18 19:27:10" itemprop="dateCreated datePublished" datetime="2021-07-18T19:27:10+08:00">2021-07-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2023-01-20 15:00:16" itemprop="dateModified" datetime="2023-01-20T15:00:16+08:00">2023-01-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">37k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">33 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>第3章讨论了Go程序中的基础数据类型，它们就像宇宙中的原子一样。本章介绍复合数据类型，复合数据类型是由基本数据类型以各种方式组合而构成的，就像分子由原子构成一样。我们将重点讲解四种复合数据类型，分别是数组、slice、map和结构体。另外本章末尾将演示如何将使用这些数据类型构成的结构化数据编码为JSON数据，从JSON数据转换为结构化数据，以及从模板生成HTML页面。</p>
<p>数组和结构体都是聚合类型，它们的值由内存中的一组变量构成。数组的元素具有相同的类型，而结构体中的元素数据类型则可以不同。数组和结构体的长度都是固定的。反之slice和map都是动态数据结构，它们的长度在元素添加到结构中时可以动态增长。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a><span style="color:#339AFF;">数组</span></h1><p>数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。由于数组的长度固定，所以在Go里面很少直接使用。slice的长度可以增长和缩短，在很多场合下使用得更多。然而，在理解slice之前，我们必须先理解数组。</p>
<p>数组中的每个元素是通过索引来访问的，索引从0到数组长度减1。Go内置的函数len可以返回数组中的元素个数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span>             <span class="comment">// 3个整数的数组</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])        <span class="comment">// 输出数组的第一个元素</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>]) <span class="comment">// 输出数组的最后一个元素，即[2]</span></span><br><span class="line"><span class="comment">// 输出索引和元素</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d %d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仅输出元素</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，一个新数组中的元素初始值为元素类型的零值，对于数字来说，就是0。也可以使用数组字面量根据一组值来初始化一个数组。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>在数组字面量中，如果省略号“…”出现在数组长度的位置，那么数组的长度由初始化数组的元素个数决定。以上数组q的定义可以简化为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, q) <span class="comment">// [3]int</span></span><br></pre></td></tr></table></figure></p>
<p>数组的长度是数组类型的一部分，所以[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，也就是说，这个表达式的值在程序编译时就可以确定。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">q = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment">// 编译错误：不可以将[4]int赋值给[3]int</span></span><br></pre></td></tr></table></figure></p>
<p>如我们所见，数组、slice、map和结构体的字面语法都是相似的。上面的例子是按顺序给出一组值；也可以像这样给出一组值，这一组值同样具有索引和索引对应的值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Currency <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    USD Currency = <span class="literal">iota</span></span><br><span class="line">    EUR</span><br><span class="line">    GBP</span><br><span class="line">    RMB</span><br><span class="line">)</span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;USD:<span class="string">"$"</span>,EUR:<span class="string">"€"</span>,GBP:<span class="string">"£"</span>,RMB:<span class="string">"￥"</span>&#125;</span><br><span class="line">fmt.Println(RMB, symbol[RMB]) <span class="comment">// 3 ￥</span></span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，索引可以按照任意顺序出现，并且有的时候还可以省略。和上面一样，没有指定值的索引位置的元素默认被赋予数组元素类型的零值。例如，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>:<span class="number">-1</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义了一个拥有100个元素的数组r，除了最后一个元素值是-1外，该数组中的其他元素值都是0。</p>
<p>如果一个数组的元素类型是可比较的，那么这个数组也是可比较的，这样我们就可以直接使用==操作符来比较两个数组，比较的结果是两边元素的值是否完全相同。使用!=来比较两个数组是否不同。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">c := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a == b,a == c,b == c )<span class="comment">// true false false</span></span><br><span class="line">d := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(a == d) <span class="comment">// 编译错误：无法比较[2]int == [3]int</span></span><br></pre></td></tr></table></figure></p>
<p>举一个更有意义的例子，crypto/sha256包里面的函数Sum256用来为存储在任意字节slice中的消息使用SHA256加密散列算法生成一个摘要。摘要信息是256位，即[32]byte。如果两个摘要信息相同，那么很有可能这两条原始消息就是相同的；如果这两个摘要信息不同，那么这两条原始消息就是不同的。下面的程序输出并比较了“x”和“X”的SHA256散列值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c1 := sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">"x"</span>))</span><br><span class="line">    c2 := sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">"X"</span>))</span><br><span class="line">    fmt.Printf(<span class="string">"%x\n%x\n%t\n%T\n"</span>, c1, c2, c1 == c2, c1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span></span><br><span class="line"><span class="comment">4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">[32]uint8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这两个原始消息仅有一位（bit）之差，但是它们生成的摘要消息有将近一半的位不同。注意，上面的格式化字符串%x表示将一个数组或者slice里面的字节按照十六进制的方式输出，%t表示输出一个布尔值，%T表示输出一个值的类型。</p>
<p>当调用一个函数的时候，每个传入的参数都会创建一个副本，然后赋值给对应的函数变量，所以函数接受的是一个副本，而不是原始的参数。使用这种方式传递大的数组会变得很低效，并且在函数内部对数组的任何修改都仅影响副本，而不是原始数组。这种情况下，Go把数组和其他的类型都看成值传递。而在其他的语言中，数组是隐式地使用引用传递。</p>
<p>当然，也可以显式地传递一个数组的指针给函数，这样在函数内部对数组的任何修改都会反映到原始数组上面。下面的程序演示如何将一个数组[32]byte的元素清零：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> ptr &#123;</span><br><span class="line">        ptr[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组字面量[32]byte{}可以生成一个拥有32个字节元素的数组。数组中每个元素的值都是字节类型的零值，即0。可以利用这一点来写另一个版本的数组清零程序：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(ptr *[32]<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    *ptr = [<span class="number">32</span>]<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用数组指针是高效的，同时允许被调函数修改调用方数组中的元素，但是因为数组长度是固定的，所以数组本身是不可变的。例如上面的zero函数不能接受一个[16]byte这样的数组指针，同样，也无法为数组添加或者删除元素。由于数组的长度不可变的特性，除了在特殊的情况下之外，我们很少使用数组。上面关于SHA256的例子中，摘要的结果拥有固定的长度，我们可以使用数组作为函数参数或结果，但是更多的情况下，我们使用slice。</p>
<p>练习4.1：编写一个函数，用于统计SHA256散列中不同的位数（见2.6.2节的PopCount）。</p>
<p>练习4.2：编写一个程序，用于在默认情况下输出其标准输入的SHA256散列，但也支持一个输出SHA384或SHA512散列的命令行标记。</p>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a><span style="color:#339AFF;">slice</span></h1><p>slice表示一个拥有相同类型元素的可变长度的序列。slice通常写成[]T，其中元素的类型都是T；它看上去像没有长度的数组类型。</p>
<p>数组和slice是紧密关联的。slice是一种轻量级的数据结构，可以用来访问数组的部分或者全部的元素，而这个数组称为slice的底层数组。slice有三个属性：指针、长度和容量。指针指向数组的第一个可以从slice中访问的元素，这个元素并不一定是数组的第一个元素。长度是指slice中的元素个数，它不能超过slice的容量。容量的大小通常是从slice的起始元素到底层数组的最后一个元素间元素的个数。Go的内置函数len和cap用来返回slice的长度和容量。</p>
<p>一个底层数组可以对应多个slice，这些slice可以引用数组的任何位置，彼此之间的元素还可以重叠。图4-1显示了一个月份名称的字符串数组和两个元素存在重叠的slice。数组声明是；<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">months := [...]<span class="keyword">string</span>&#123;<span class="number">1</span>:<span class="string">"January"</span>, <span class="comment">/*...*/</span>, <span class="number">12</span>:<span class="string">"December"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以January就是months[1]，December是months[12]。一般来讲，数组中索引0的位置存放数组的第一个元素，但是由于月份总是从1开始，因此我们可以不设置索引为0的元素，这样它的值就是空字符串。</p>
<blockquote>
<p>图4-1 月份名称字符串数组对应的两个元素重叠的slice</p>
</blockquote>
<img src="/2021/07/18/第4章-复合数据类型/1.png">
<p>slice操作符s[i:j]（其中e≤i≤j≤cap(s)）创建了一个新的slice，这个新的slice引用了序列s中从i到j-1索引位置的所有元素，这里的s既可以是数组或者指向数组的指针，也可以是slice。新slice的元素个数是j-i个。如果上面的表达式中省略了i，那么新slice的起始索引位置就是0，即i=0；如果省略了j，那么新slice的结束索引位置是len(s)-1，即j=len(s)。因此slice months[1:13]引用了所有的有效月份，同样的写法可以是months[1:]。slice months[:]引用了整个数组。接下来，我们定义元素重叠的slice，分别用来表示第二季度的月份和北半球的夏季月份：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q2 := months[<span class="number">4</span>:<span class="number">7</span>]</span><br><span class="line">summer := months[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">fmt.Println(Q2)     <span class="comment">// ["April" "May" "June"]</span></span><br><span class="line">fmt.Println(summer) <span class="comment">// ["June" "July" "August"]</span></span><br></pre></td></tr></table></figure></p>
<p>元素June同时包含在两个slice中。用下面的代码来输出两个slice的共同元素（虽然效率不高）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _,s := <span class="keyword">range</span> summer &#123;</span><br><span class="line">    <span class="keyword">for</span> _, q := <span class="keyword">range</span> Q2 &#123;</span><br><span class="line">        <span class="keyword">if</span> s == q&#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%s appears in both\n"</span>, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果slice的引用超过了被引用对象的容量，即cap(s)，那么会导致程序宕机；但是如果slice的引用超出了被引用对象的长度，即1en(s)，那么最终slice会比原slice长：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(summer[:<span class="number">20</span>])    <span class="comment">// 宕机：超过了被引用对象的边界</span></span><br><span class="line">endlessSummer := summer[:<span class="number">5</span>] <span class="comment">// 在slice容量范围内扩展了slice</span></span><br><span class="line">fmt.Println(endlessSummer)  <span class="comment">// [June July August September October]</span></span><br></pre></td></tr></table></figure></p>
<p>另外，注意求字符串（string）子串操作和对字节slice（[]byte）做slice操作这两者的相似性。它们都写作x[m:n]，并且都返回原始字节的一个子序列，同时它们的底层引用方式也是相同的，所以两个操作都消耗常量时间。区别在于：如果x是字符串，那么x[m:n]返回的是一个字符串；如果x是字节slice，那么返回的结果是字节slice。</p>
<p>因为slice包含了指向数组元素的指针，所以将一个slice传递给函数的时候，可以在函数内部修改底层数组的元素。换言之，创建一个数组的slice等于为数组创建了一个别名（见2.3.2节）。下面的函数reverse就地反转了整型slice中的元素，它适用于任意长度的整型slice。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就地反转一个整型slice中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，反转整个数组a；<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a :=[...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">reverse(a[:])</span><br><span class="line">fmt.Println(a) <span class="comment">// [5 4 3 2 1 0]</span></span><br></pre></td></tr></table></figure></p>
<p>将一个slice左移n个元素的简单方法是连续调用reverse函数三次。第一次反转前n个元素，第二次反转剩下的元素，最后对整个slice再做一次反转（如果将元素右移n个元素，那么先做第三次调用）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 向左移动两个元素</span></span><br><span class="line">reverse(s[:<span class="number">2</span>])</span><br><span class="line">reverse(s[<span class="number">2</span>:])</span><br><span class="line">reverse(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// [2 3 4 5 0 1]</span></span><br></pre></td></tr></table></figure></p>
<p>注意初始化slice s的表达式和初始化数组a的表达式的区别。slice字面量看上去和数组字面量很像，都是用逗号分隔并用花括号括起来的一个元素序列，但是slice没有指定长度。这种隐式区别的结果分别是创建有固定长度的数组和创建指向数组的slice。和数组一样，slice也按照顺序指定元素，也可以通过索引来指定元素，或者两者结合。</p>
<p>和数组不同的是，slice无法做比较，因此不能用==来测试两个slice是否拥有相同的元素。标准库里面提供了高度优化的函数bytes.Equal来比较两个字节slice（[]byte）。但是对于其他类型的slice，我们必须自己写函数来比较。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(x, y []<span class="keyword">string</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="built_in">len</span>(y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> x&#123;</span><br><span class="line">        <span class="keyword">if</span> x[i] != y[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种深度比较看上去很简单，并且运行的时候并不比字符串数组使用==做比较多耗费时间。你或许奇怪为什么slice比较不可以直接使用=操作符做比较。这里有两个原因。首先，和数组元素不同，slice的元素是非直接的，有可能slice可以包含它自身。虽然有办法处理这种特殊的情况，但是没有一种方法是简单、高效、直观的。</p>
<p>其次，因为slice的元素不是直接的，所以如果底层数组元素改变，同一个slice在不同的时间会拥有不同的元素。由于散列表（例如Go的map类型）仅对元素的键做浅拷贝，这就要求散列表里面键在散列表的整个生命周期内必须保持不变。因为slice需要深度比较，所以就不能用slice作为map的键。对于引用类型，例如指针和通道，操作符==检查的是引用相等性，即它们是否指向相同的元素。如果有一个相似的slice相等性比较功能，它或许会比较有用，也能解决slice作为map键的问题，但是如果操作符==对slice和数组的行为不一致，会带来困扰。所以最安全的方法就是不允许直接比较slice。</p>
<p>slice唯一允许的比较操作是和nil做比较，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> summer == <span class="literal">nil</span> &#123;<span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>slice类型的零值是nil。值为nil的slice没有对应的底层数组。值为nil的slice长度和容量都是零，但是也有非nil的slice长度和容量是零，例如[]int{}或make([]int,3)[3:]。对于任何类型，如果它们的值可以是nil，那么这个类型的nil值可以使用一种转换表达式，例如[]int(nil)。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = <span class="literal">nil</span>        <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>(<span class="literal">nil</span>) <span class="comment">// len(s) == 0, s == nil</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125;    <span class="comment">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure></p>
<p>所以，如果想检查一个slice是否是空，那么使用len(s)==0，而不是s==nil，因为s!=nil的情况下，slice也有可能是空。除了可以和nil做比较之外，值为nil的slice表现和其他长度为零的slice一样。例如，reverse函数调用reverse(nil)也是安全的。除非文档上面写明了与此相反，否则无论值是否为nil，Go的函数都应该以相同的方式对待所有长度为零的slice。</p>
<p>内置函数make可以创建一个具有指定元素类型、长度和容量的slice。其中容量参数可以省略，在这种情况下，slice的长度和容量相等。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// 和make([]T, cap)[:len]功能相同</span></span><br></pre></td></tr></table></figure></p>
<p>深入研究下，其实make创建了一个无名数组并返回了它的一个slice；这个数组仅可以通过这个slice来访问。在上面的第一行代码中，所返回的slice引用了整个数组。在第二行代码中，slice只引用了数组的前len个元素，但是它的容量是数组的长度，这为未来的slice元素留出空间。</p>
<h2 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a><span style="color:#00ACC1;">append函数</span></h2><p>内置函数append用来将元素追加到slice的后面。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runes []<span class="keyword">rune</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> <span class="string">"Hello, 世界"</span> &#123;</span><br><span class="line">    runes = <span class="built_in">append</span>(runes, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, runes) <span class="comment">// ['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']</span></span><br></pre></td></tr></table></figure></p>
<p>虽然最方便的用法是[]rune(“Hello, 世界”)，但是上面的循环演示了如何使用append来为一个rune类型的slice添加元素。</p>
<p>append函数对理解slice的工作原理很重要，接下来看一个为[]int数组slice定义的方法appendInt：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="keyword">int</span>, y <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z []<span class="keyword">int</span></span><br><span class="line">    zlen := <span class="built_in">len</span>(x) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> zlen &lt;= <span class="built_in">cap</span>(x) &#123;</span><br><span class="line">        <span class="comment">// slice仍有增长空间，扩展slice内容</span></span><br><span class="line">        z = x[:zlen]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// slice已无空间，为它分配一个新的底层数组</span></span><br><span class="line">        <span class="comment">// 为了达到分摊线性复杂性，容量扩展一倍</span></span><br><span class="line">        zcap := zlen</span><br><span class="line">        <span class="keyword">if</span> zcap &lt; <span class="number">2</span>*<span class="built_in">len</span>(x) &#123;</span><br><span class="line">            zcap = <span class="number">2</span> * <span class="built_in">len</span>(x)</span><br><span class="line">        &#125;</span><br><span class="line">        z = <span class="built_in">make</span>([]<span class="keyword">int</span>, zlen, zcap)</span><br><span class="line">        <span class="built_in">copy</span>(z, x) <span class="comment">// 内置copy函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    z[<span class="built_in">len</span>(x)] = y</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一次appendInt调用都必须检查slice是否仍有足够容量来存储数组中的新元素。如果 slice容量足够，那么它就会定义一个新的slice（仍然引用原始底层数组），然后将新元素y复制到新的位置，并返回这个新的slice。输入参数slicex和函数返回值slice z拥有相同的底层数组。</p>
<p>如果slice的容量不够容纳增长的元素，appendInt函数必须创建一个拥有足够容量的新的底层数组来存储新元素，然后将元素从slicex复制到这个数组，再将新元素y追加到数组后面。返回值slicez将和输人参数slicex引用不同的底层数组。</p>
<p>使用循环语句来复制元素看上去直观一点，但是使用内置函数copy将更简单，copy函数用来为两个拥有相同类型元素的slice复制元素。copy函数的第一个参数是目标slice，第二个参数是源slice，copy数将源slice中的元素复制到目标slice中，这个和一般的元素赋值有点像，比如dest=src。不同的slice可能对应相同的底层数组，甚至可能存在元素重叠。copy函数有返回值，它返回实际上复制的元素个数，这个值是两个slice长度的较小值。所以这里不存在由于元素复制而导致的索引越界问题。</p>
<p>出于效率的考虑，新创建的数组容量会比实际容纳slicex和slicey所需要的最小长度更大一点。在每次数组容量扩展时，通过扩展一倍的容量来减少内存分配的次数，这样也可以保证追加一个元素所消耗的是固定时间。下面的程序演示了这个效果：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> x, y []<span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        y = appendInt(x, i)</span><br><span class="line">        fmt.Printf(<span class="string">"%d cap=%d\t%v\n"</span>, i, <span class="built_in">cap</span>(y), y)</span><br><span class="line">        x = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次slice容量的改变都意味着一次底层数组重新分配和元素复制：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="built_in">cap</span>=<span class="number">1</span> [<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span> <span class="built_in">cap</span>=<span class="number">2</span> [<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">2</span> <span class="built_in">cap</span>=<span class="number">4</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="number">3</span> <span class="built_in">cap</span>=<span class="number">4</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="number">4</span> <span class="built_in">cap</span>=<span class="number">8</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"><span class="number">5</span> <span class="built_in">cap</span>=<span class="number">8</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"><span class="number">6</span> <span class="built_in">cap</span>=<span class="number">8</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"><span class="number">7</span> <span class="built_in">cap</span>=<span class="number">8</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"><span class="number">8</span> <span class="built_in">cap</span>=<span class="number">16</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"><span class="number">9</span> <span class="built_in">cap</span>=<span class="number">16</span> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br></pre></td></tr></table></figure></p>
<p>我们来仔细看一下当i=3时的情况。这个时候slicex拥有三个元素[0 1 2]，但是容量是4，这个时候slice最后还有一个空位置，所以调用appendInt追加元素3的时候，没有发生底层数组重新分配。调用的结果是slice的长度和容量都是4，并且这个结果slice和x一样拥有相同的底层数组，如图4-2所示。</p>
<blockquote>
<p>图4-2 有容量元素的增长</p>
</blockquote>
<img src="/2021/07/18/第4章-复合数据类型/2.png">
<p>在下一次循环中i=4，这个时候原来的slice已经没有空间了，所以appendInt函数分配了一个长度为8的新数组。然后将x中的4个元素[0 1 2 3]都复制到新的数组中，最后再追加新元素i。这样结果slice的长度就是5，而容量是8。多分配的三个位置就留给接下来的循环添加值使用，在接下来的三次循环中，就不需要再重新分配空间。所以y和x是不同数组的slice。这个操作过程如图4-3所示。</p>
<blockquote>
<p>图4-3 无容量元素的增长</p>
</blockquote>
<img src="/2021/07/18/第4章-复合数据类型/3.png">
<p>内置的append函数使用了比这里的appendInt更复杂的增长策略。通常情况下，我们并不清楚一次append调用会不会导致一次新的内存分配，所以我们不能假设原始的slice和调用append后的结果slice指向同一个底层数组，也无法证明它们就指向不同的底层数组。同样，我们也无法假设旧slice上对元素的操作会或者不会影响新的slice元素。所以，通常我们将append的调用结果再次赋值给传入append函数的slice：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runes = <span class="built_in">append</span>(runes, r)</span><br></pre></td></tr></table></figure></p>
<p>不仅仅是在调用append函数的情况下需要更新slice变量。另外，对于任何函数，只要有可能改变slice的长度或者容量，抑或是使得slice指向不同的底层数组，都需要更新slice变量。为了正确地使用slice，必须记住，虽然底层数组的元素是间接引用的，但是slice的指针、长度和容量不是。要更新一个slice的指针，长度或容量必须使用如上所示的显式赋值。从这个角度看，slice并不是纯引用类型，而是像下面这种聚合类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">    ptr      *<span class="keyword">int</span></span><br><span class="line">    <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>appendInt函数只能给slice添加一个元素，但是内置的append函数可以同时给slice添加多个元素，甚至添加另一个slice里的所有元素。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">int</span></span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">1</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,x...) <span class="comment">// 追加x中的所有元素</span></span><br><span class="line">fmt.Println(x)     <span class="comment">// [1 2 3 4 5 6 1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure></p>
<p>可以简单修改一下appendInt函数来匹配append的功能。函数appendInt参数声明中的省略号“…”表示该函数可以接受可变长度参数列表。上面例子中append函数的参数后面的省略号表示如何将一个slice转换为参数列表。5.7节会详细解释这种机制。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendInt</span><span class="params">(x []<span class="keyword">int</span>, y ...<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> z []<span class="keyword">int</span></span><br><span class="line">    zlen := <span class="built_in">len</span>(x) + <span class="built_in">len</span>(y)</span><br><span class="line">    <span class="comment">// ...扩展slice z的长度至少到zlen...</span></span><br><span class="line">    <span class="built_in">copy</span>(z[<span class="built_in">len</span>(x):], y)</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>扩展slicez底层数组的逻辑和上面一样，所以就不重复了。</p>
<h2 id="slice就地修改"><a href="#slice就地修改" class="headerlink" title="slice就地修改"></a><span style="color:#00ACC1;">slice就地修改</span></h2><p>我们多看一些就地使用slice的例子，比如rotate和reverse这种可以就地修改slice元素的函数。下面的函数nonempty可以从给定的一个字符串列表中去除空字符串并返回一个新的slice。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nonempty 演示了slice的就地修改算法</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nonempty 返回一个新的slice，slice中的元素都是非空字符串</span></span><br><span class="line"><span class="comment">// 在函数的调用过程中，底层数组的元素发生了改变</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty</span><span class="params">(strings []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">""</span> &#123;</span><br><span class="line">            strings[i] = s</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings[:i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一点是输入的slice和输出的slice拥有相同的底层数组，这样就避免在函数内部重新分配一个数组。当然，这种情况下，底层数组的元素只是部分被修改，示例如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">""</span>, <span class="string">"three"</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, nonempty(data)) <span class="comment">// ["one" "three"]</span></span><br><span class="line">fmt.Printf(<span class="string">"%q\n"</span>, data)           <span class="comment">// ["one" "three" "three"]</span></span><br></pre></td></tr></table></figure></p>
<p>因此，通常我们会这样来写：data = noempty(data)。</p>
<p>函数nonempty还可以利用append函数来写：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nonempty2</span><span class="params">(strings []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    out := strings[:<span class="number">0</span>] <span class="comment">// 引用原始slice的新的零长度的slice</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">        <span class="keyword">if</span> s != <span class="string">""</span> &#123;</span><br><span class="line">            out = <span class="built_in">append</span>(out, s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>无论使用哪种方式，重用底层数组的结果是每一个输人值的slice最多只有一个输出的结果slice，很多从序列中过滤元素再组合结果的算法都是这样做的。这种精细的slice使用方式只是一个特例，并不是规则，但是偶尔这样做可以让实现更清晰、高效、有用。</p>
<p>slice可以用来实现栈。给定一个空的slice元素stack，可以使用append向slice尾部追加值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = <span class="built_in">append</span>(stack, v)<span class="comment">//pushv</span></span><br></pre></td></tr></table></figure></p>
<p>栈的顶部是最后一个元素：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// 栈顶</span></span><br></pre></td></tr></table></figure></p>
<p>通过弹出最后一个元素来缩减栈：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>] <span class="comment">// pop</span></span><br></pre></td></tr></table></figure></p>
<p>为了从slice的中间移除一个元素，并保留剩余元素的顺序，可以使用函数copy来将高位索引的元素向前移动来覆盖被移除元素所在位置：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>如果不需要维持slice中剩余元素的顺序，可以简单地将slice的最后一个元素赋值给被移除元素所在的索引位置：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(slice []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">slice[i] = slice[<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">s:=[]<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">fmt.Println(remove(s,<span class="number">2</span>))/<span class="number">1</span> <span class="string">"[5 6 9 8]</span></span><br></pre></td></tr></table></figure></p>
<p>练习4.3：重写函数reverse，使用数组指针作为参数而不是slice。</p>
<p>练习4.4：编写一个函数rotate，实现一次遍历就可以完成元素旋转。</p>
<p>练习4.5编写一个就地处理函数，用于去除[]string slice中相邻的重复字符串元素。</p>
<p>练习4.6：编写一个就地处理函数，用于将一个UTF-8编码的字节slice中所有相邻的Unicode空白字符（查看unicode.IsSpace）缩减为一个ASCII空白字符。</p>
<p>练习4.7：修改函数reverse，来翻转一个UTF-8编码的字符串中的字符元素，传入参数是该字符串对应的字节slice类型（[]byte）。你可以做到不需要重新分配内存就实现该功能吗？ </p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a><span style="color:#339AFF;">map</span></h1><p>散列表是设计精妙、用途广泛的数据结构之一。它是一个拥有键值对元素的无序集合。在这个集合中，键的值是唯一的，键对应的值可以通过键来获取、更新或移除。无论这个散列表有多大，这些操作基本上是通过常量时间的键比较就可以完成。</p>
<p>在Go语言中，map是散列表的引用，map的类型是<code>map[K]V</code>，其中K和V是字典的键和值对应的数据类型。map中所有的键都拥有相同的数据类型，同时所有的值也都拥有相同的数据类型，但是键的类型和值的类型不一定相同。键的类型K，必须是可以通过操作符<code>==</code>来进行比较的数据类型，所以map可以检测某一个键是否已经存在。虽然浮点型是可以比较的，但是比较浮点型的相等性不是一个好主意，如第3章所述，尤其是在NaN可以是浮点型值的时候。当然，值类型V没有任何限制。</p>
<p>内置函数make可以用来创建一个map：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">// 创建一个从string到int的map</span></span><br></pre></td></tr></table></figure></p>
<p>也可以使用map的字面量来新建一个带初始化键值对元素的字典：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="string">"alice"</span>: <span class="number">31</span>，</span><br><span class="line">    <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个等价于：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">ages[<span class="string">"alice"</span>] = <span class="number">31</span></span><br><span class="line">ages[<span class="string">"charlie"</span>] = <span class="number">34</span></span><br></pre></td></tr></table></figure></p>
<p>因此，新的空map的另外一种表达式是：<code>map[string]int{}</code>。</p>
<p>map的元素访问也是通过下标的方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"alice"</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">"alice"</span>]) <span class="comment">// 32</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用内置函数delete来从字典中根据键移除一个元素：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>) <span class="comment">// 移除元素ages["alice"]</span></span><br></pre></td></tr></table></figure></p>
<p>即使键不在map中，上面的操作也都是安全的。map使用给定的键来查找元素，如果对应的元素不存在，就返回值类型的零值。例如，下面的代码同样可以工作，尽管“bob”还不是map的键，因为<code>ages[&quot;bob&quot;]</code>的值是0。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"bob"</span>] = ages[<span class="string">"bob"</span>] + <span class="number">1</span> <span class="comment">// 生日快乐</span></span><br></pre></td></tr></table></figure></p>
<p>快捷赋值方式（如<code>x+=y</code>和<code>x++</code>）对map中的元素同样适用，所以上面的代码还可以写成：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"bob"</span>] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>或者更简洁的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"bob"</span>]++</span><br></pre></td></tr></table></figure></p>
<p>但是map元素不是一个变量，不可以获取它的地址，比如这样是不对的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">"bob"</span>] <span class="comment">// 编译错误，无法获取map元素的地址</span></span><br></pre></td></tr></table></figure></p>
<p>我们无法获取map元素的地址的一个原因是map的增长可能会导致已有元素被重新散列到新的存储位置，这样就可能使得获取的地址无效。</p>
<p>可以使用for循环（结合range关键字）来遍历map中所有的键和对应的值，就像上面遍历slice一样。循环语句的连续迭代将会使得变量name和age被赋予map中的下一对键和值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\t%d\n"</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>map中元素的迭代顺序是不固定的，不同的实现方法会使用不同的散列算法，得到不同的元素顺序。实践中，我们认为这种顺序是随机的，从一个元素开始到后一个元素，依次执行。这个是有意为之的，这样可以使得程序在不同的散列算法实现下变得健壮。如果需要按照某种顺序来遍历map中的元素，我们必须显式地来给键排序。例如，如果键是字符串类型，可以使用sort包中的Strings函数来进行键的排序，这是一种常见的模式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">    names = <span class="built_in">append</span>(names, name)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(names)</span><br><span class="line"><span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\t%d\n"</span>, name, ages[name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为我们一开始就知道slice names的长度，所以直接指定一个slice的长度会更加高效。下面的语句创建了一个初始元素为空但是容量足够容纳ages map中所有键的slice：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(ages))</span><br></pre></td></tr></table></figure></p>
<p>在上面的第一个循环中，我们只需要map ages的所有键，所以我们忽略了循环中的第二个变量。在第二个循环中，我们只需要使用slice names中的元素值，所以我们使用空白标识符<code>_</code>来忽略第一个变量，即元素索引。</p>
<p>map类型的零值是nil，也就是说，没有引用任何散列表。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(ages == <span class="literal">nil</span>)   <span class="comment">// "true"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ages)== <span class="number">0</span>) <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure></p>
<p>大多数的map操作都可以安全地在map的零值nil上执行，包括查找元素，删除元素，获取map元素个数（len），执行range循环，因为这和空map的行为一致。但是向零值map中设置元素会导致错误：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"carol"</span>] = <span class="number">21</span> <span class="comment">// 宕机：为零值map中的项赋值</span></span><br></pre></td></tr></table></figure></p>
<p>设置元素之前，必须初始化map。</p>
<p>通过下标的方式访问map中的元素总是会有值。如果键在map中，你将得到键对应的值；如果键不在map中，你将得到map值类型的零值，如同对于<code>ages[&quot;bob&quot;]</code>的操作结果。很多情况下，这个没有问题，但是有时候你需要知道一个元素是否在map中。例如，如果元素类型是数值类型，你需要能够辨别一个不存在的元素或者恰好这个元素的值是0，可以这样做：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age, ok := ages[<span class="string">"bob"</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">/* "bob"不是字典中的键，age == 0 */</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常这两条语句合并成一条语句，如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">"bob"</span>]; !ok &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过这种下标方式访问map中的元素输出两个值，第二个值是一个布尔值，用来报告该元素是否存在。这个布尔变量一般叫作ok，尤其是它立即用在if条件判断中的时候。</p>
<p>和slice一样，map不可比较，唯一合法的比较就是和nil做比较。为了判断两个map是否拥有相同的键和值，必须写一个循环：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(x, y <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="built_in">len</span>(y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, xv := <span class="keyword">range</span> x &#123;</span><br><span class="line">        <span class="keyword">if</span> yv, ok := y[k]; !ok || yv != xv &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意我们如何使用<code>!ok</code>来区分“元素不存在”和“元素存在但值为零”的情况。如果我们简单地写成了<code>xv != y[k]</code>，那么下面的调用将错误地报告两个map是相等的。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果equal函数写法错误，结果为True</span></span><br><span class="line">equal(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"A"</span>: <span class="number">8</span>&#125;, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"B"</span>:<span class="number">42</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>Go没有提供集合类型，但是既然map的键都是唯一的，就可以用map来实现这个功能。为了模拟这个功能，程序dedup读取一系列的行，并且只输出每个不同行一次。这个是1.3节演示过的dup程序的变体。程序dedup使用map的键来存储这些已经出现过的行，来确保接下来出现的相同行不会输出。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch4/dedup</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>) <span class="comment">// 字符串集合</span></span><br><span class="line">    input := bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> input.Scan() &#123;</span><br><span class="line">        line := input.Text()</span><br><span class="line">        <span class="keyword">if</span> !seen[line] &#123;</span><br><span class="line">            seen[line] = <span class="literal">true</span></span><br><span class="line">            fmt.Println(line)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := input.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">"dedup: %v\n"</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Go程序员通常把这种使用map的方式描述成字符串集合，但是请注意，并不是所有的<code>map[string]bool</code>都是简单的集合，有一些map的值会同时包含true和false的情况。</p>
<p>有时候，我们需要一个map并且需求它的键是lice，但是因为map的键必须是可以比较的，所以这个功能无法直接实现。然而，我们可以分两步来做。首先，定义一个帮助函数k将每一个键都映射到字符串，当且仅当x和y相等的时候，我们才认为<code>k(x) == k(y)</code>。然后，就可以创建一个map，map的键是字符串类型，在每个键元素被访问的时候，调用这个帮助函数。</p>
<p>下面的例子通过一个字符串列表使用一个map来记录Add函数被调用的次数。帮助函数使用<code>fmt.Sprintf</code>来将一个字符串slice转换为一个适合做map键的字符串，使用<code>%q</code>来格式化slice并记录每个字符串的边界。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">k</span><span class="params">(list []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">"%q"</span>, list) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(list []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; m[k(list)]++&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(list []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> m[k(list)] &#125;</span><br></pre></td></tr></table></figure>
<p>同样的方法适用于任何不可直接比较的键类型，不仅仅局限于slice。甚至有的时候，你不想让键通过=来比较相等性，而是自定义一种比较方法，例如字符串不区分大小写的比较。同样k(x)的类型不一定是字符串类型，任何能够得到想要的比较结果的可比较类型都可以，例如整数、数组或者结构体。</p>
<p>这里还有一个关于map的例子，一个统计输人中Unicode代码点出现次数的程序。虽然存在着大量可能的字符，但是在一篇文档中仅会有这个巨大字符集的一部分，所以很自然地使用map来追踪每个字符出现的次数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch4/charcount</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"unicode"</span></span><br><span class="line">    <span class="string">"unicode/utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)    <span class="comment">// counts of Unicode characters</span></span><br><span class="line">    <span class="keyword">var</span> utflen [utf8.UTFMax + <span class="number">1</span>]<span class="keyword">int</span> <span class="comment">// count of lengths of UTF-8 encodings</span></span><br><span class="line">    invalid := <span class="number">0</span>                    <span class="comment">// count of invalid UTF-8 characters</span></span><br><span class="line"></span><br><span class="line">    in := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        r, n, err := in.ReadRune() <span class="comment">// returns rune, nbytes, error</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">"charcount: %v\n"</span>, err)</span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> r == unicode.ReplacementChar &amp;&amp; n == <span class="number">1</span> &#123;</span><br><span class="line">            invalid++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        counts[r]++</span><br><span class="line">        utflen[n]++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"rune\tcount\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> c, n := <span class="keyword">range</span> counts &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%q\t%d\n"</span>, c, n)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(<span class="string">"\nlen\tcount\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> i, n := <span class="keyword">range</span> utflen &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"%d\t%d\n"</span>, i, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> invalid &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"\n%d invalid UTF-8 characters\n"</span>, invalid)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数ReadRune解码UTF-8编码，并返回三个值：解码的字符、UTF-8编码中字节的长度和错误值。这里唯一可能出现的错误是文件结束（EOF）。如果输人的不是合法的UTF-8字符，那么返回的字符是code.ReplacementChar并且长度是1。</p>
<p>charcount程序还输出了UTF-8编码长度出现的次数，这个时候map不再是一个合适的数据类型，因为编码的长度是变化的，一个字符对应的字节长度可能值从1到utf8.UTFMax（这里是4）各不相同，所以这个时候使用数组使程序更加精简一点。</p>
<p>作为一个实验，我们对本书运行了一次charcount程序，虽然本书英文版内容大多数是英文，但是也确实包含一些非ASCII字符，这里是最多的10个非ASCII字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">。 27 世 15 界 14 e 13 * 10 s 5 x 5 国 4 0 4 0 3</span><br></pre></td></tr></table></figure></p>
<p>这里是UTF-8编码长度的分布：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">len count</span><br><span class="line">1</span><br><span class="line">765391</span><br><span class="line">2</span><br><span class="line">60</span><br><span class="line">3</span><br><span class="line">70</span><br><span class="line">4</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>map的值类型本身可以是复合数据类型，例如map或slice。在下面的代码中，变量graph的键类型是string类型；值类型是map类型<code>map[string]bool</code>，表示一个字符串集合。</p>
<p>因此，graph建立了一个从字符串到字符串集合的映射。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch4/graph</span></span><br><span class="line"><span class="keyword">var</span> graph = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">bool</span>) <span class="function"><span class="keyword">func</span> <span class="title">addEdge</span><span class="params">(from, to <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">edges := graph[from]</span><br><span class="line"><span class="keyword">if</span> edges == <span class="literal">nil</span>&#123;</span><br><span class="line">edges = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">bool</span>)</span><br><span class="line">graph[from]= edges</span><br><span class="line">edges[to]= <span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasEdge</span><span class="params">(from, to <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> graph[from] [to]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>函数addedge演示了一种符合语言习惯的延迟初始化map的方法，当map中的每个键第一次出现的时候初始化。函数hasEdge演示了在map中值不存在的情况下，也可以直接使用。即使from和to都不存在，<code>graph[from][to]</code>也始终可以给出一个有意义的值。</p>
<p>练习4.8：修改charcount的代码来统计字母、数字和其他在Unicode分类中的字符数量，可以使用函数unicode.IsLetter等。</p>
<p>练习4.9：编写一个程序wordfreq来汇总输人文本文件中每个单词出现的次数。在第一次调用scan之前，需要使用input.split（bufio.scanwords）来将文本行按照单词分割而不是行分割。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a><span style="color:#339AFF;">结构体</span></h1><p>结构体是将零个或者多个任意类型的命名变量组合在一起的聚合数据类型。每个变量都叫作结构体的成员。在数据处理领域，结构体使用的经典实例是员工信息记录，记录中有唯一ID、姓名、地址、出生日期、职位、薪水、直属领导等信息。所有的这些员工信息成员都作为一个整体组合在一个结构体里面，可以复制一个结构体，将它传递给函数，作为函数的返回值，将结构体存储到数组中，等等。</p>
<p>下面的语句定义了一个叫Employee的结构体和一个结构体变量dilbert：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="keyword">int</span></span><br><span class="line">    Name      <span class="keyword">string</span></span><br><span class="line">    Address   <span class="keyword">string</span></span><br><span class="line">    DoB       time.Time</span><br><span class="line">    Position  <span class="keyword">string</span></span><br><span class="line">    Salary    <span class="keyword">int</span></span><br><span class="line">    ManagerID <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dilbert Employee</span><br></pre></td></tr></table></figure></p>
<p>dilbert的每一个成员都通过点号方式来访问，就像dilbert.Name和dilbert.DoB这样。 由于dilbert是一个变量，它的所有成员都是变量，因此可以给结构体的成员赋值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dilbert.Salary -= <span class="number">5000</span> <span class="comment">// 写的代码太少了，降薪</span></span><br></pre></td></tr></table></figure></p>
<p>或者获取成员变量的地址，然后通过指针来访问它：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position := &amp;dilbert.Position</span><br><span class="line">*position = <span class="string">"Senior "</span> + *position <span class="comment">// 工作外包给Elbonia，所以升值</span></span><br></pre></td></tr></table></figure></p>
<p>点号同样可以用在结构体指针上：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbert</span><br><span class="line">employeeOfTheMonth.Position += <span class="string">" (proactive team player)"</span></span><br></pre></td></tr></table></figure></p>
<p>后面一条语句等价于：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*employeeOfTheMonth).Position += <span class="string">" (proactive team player)"</span></span><br></pre></td></tr></table></figure></p>
<p>函数EmployeeID通过给定的参数ID来返回一个指向Employee结构体的指针。可以用点号来访问它的成员变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EmployeeByID</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Employee</span></span> &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(EmployeeByID(dilbert.ManagerID).Position)</span><br><span class="line"></span><br><span class="line">id := dilbert.ID</span><br><span class="line">EmployeeByID(id).Salary = <span class="number">0</span> <span class="comment">// 被开除了...不知道为什么</span></span><br></pre></td></tr></table></figure></p>
<p>最后一条语句更新了函数EmployeeID返回的指针指向的结构体Employee。如果函数EmployeeID的返回值类型变成了Employee而不是*Employee，那么代码将无法通过编译，因为赋值表达式的左侧无法识别出一个变量。</p>
<p>结构体的成员变量通常一行写一个，变量的名称在类型的前面，但是相同类型的连续成员变量可以写在一行上，就像这里的Name和Address：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID            <span class="keyword">int</span></span><br><span class="line">    Name, Address <span class="keyword">string</span></span><br><span class="line">    DoB           time.Time</span><br><span class="line">    Position      <span class="keyword">string</span></span><br><span class="line">    Salary        <span class="keyword">int</span></span><br><span class="line">    ManagerID     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>成员变量的顺序对于结构体同一性很重要。如果我们将也是字符串类型的Position和Name、Address组合在一起或者互换了Name和Address的顺序，那么我们就在定义一个不同的结构体类型。一般来讲，我们只组合相关的成员变量。</p>
<p>如果一个结构体的成员变量名称是首字母大写的，那么这个变量是可导出的，这个是Go最主要的访问控制机制。一个结构体可以同时包含可导出和不可导出的成员变量。</p>
<p>因为结构体类型一个成员变量占据一行，所以通常它的定义比较长。虽然可以在每次需要它的时候写出整个结构体类型定义，即匿名结构体类型，但是重复的工作会比较累，所以通常我们会定义命名结构体类型，比如Employee。</p>
<p>命名结构体类型s不可以定义一个拥有相同结构体类型s的成员变量，也就是一个聚合类型不可以包含它自己（同样的限制对数组也适用）。但是s中可以定义一个s的指针类型即*s，这样我们就可以创建一些递归数据结构，比如链表和树。下面的代码给出了一个利用二叉树来实现插入排序的例子。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tree <span class="keyword">struct</span> &#123;</span><br><span class="line">    value       <span class="keyword">int</span></span><br><span class="line">    left, right *tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort 就地排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(values []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> root *tree</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">        root = add(root, v)</span><br><span class="line">    &#125;</span><br><span class="line">    appendValues(values[:<span class="number">0</span>], root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendValues 将元素按照顺序添加到values里面，然后返回结果slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendValues</span><span class="params">(values []<span class="keyword">int</span>, t *tree)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t != <span class="literal">nil</span> &#123;</span><br><span class="line">        values = appendValues(values, t.left)</span><br><span class="line">        values = <span class="built_in">append</span>(values, t.value)</span><br><span class="line">        values = appendValues(values, t.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(t *tree, value <span class="keyword">int</span>)</span> *<span class="title">tree</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 等价于返回&amp;tree&#123;value: value&#125;</span></span><br><span class="line">        t = <span class="built_in">new</span>(tree)</span><br><span class="line">        t.value = value</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> value &lt; t.value &#123;</span><br><span class="line">        t.left = add(t.left, value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t.right = add(t.right, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构体的零值由结构体成员的零值组成。通常情况下，我们希望零值是一个默认自然的、合理的值。例如，在bytes.Buffer中，结构体的初始值就是一个可以直接使用的空缓存。另外，第9章将讲到的sync.Mutex也是一个可以直接使用且未锁定状态的互斥锁。有时候，这种合理的初始值实现简单，但是有时候也需要类型的设计者花费时间来进行设计。</p>
<p>没有任何成员变量的结构体称为空结构体，写作struct{}。它没有长度，也不携带任何信息，但是有的时候会很有用。有一些Go程序员用它来替代被当作集合使用的map中的布尔值，来强调只有键是有用的，但由于这种方式节约的内存很少并且语法复杂，所以一般尽量避免这样用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 字符串集合</span></span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="keyword">if</span> _, ok := seen[s];!ok &#123;</span><br><span class="line">    seen[s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// ...首次出现s...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="结构体字面量"><a href="#结构体字面量" class="headerlink" title="结构体字面量"></a><span style="color:#00ACC1;">结构体字面量</span></h2><p>结构体类型的值可以通过结构体字面量来设置，即通过设置结构体的成员变量来设置。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123;X, Y <span class="keyword">int</span>&#125;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两种格式的结构体字面量。第一种格式如上，它要求按照正确的顺序，为每个成员变量指定一个值。这会给开发和阅读代码的人增加负担，因为他们必须记住每个成员变量的顺序，另外这也使得未来结构体成员变量扩充或者重新排列的时候代码维护性差。所以，这种格式一般用在定义结构体类型的包中或者一些有明显的成员变量顺序约定的小结构体中，比如image.Point{x,y}或者color.RGBA{red,green,blue,alpha}。</p>
<p>我们用得更多的是第二种格式，通过指定部分或者全部成员变量的名称和值来初始化结构体变量，就像1.4节讲述的Lissajous程序那样：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在这种初始化方式中某个成员变量没有指定，那么它的值就是该成员变量类型的零值。因为指定了成员变量的名字，所以它们的顺序是无所谓的。</p>
<p>这两种初始化方式不可以混合使用，另外也无法使用第一种初始化方式来绕过不可导出变量无法在其他包中使用的规则。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123; a, b <span class="keyword">int</span>&#125; <span class="comment">// a和b都是不可导出的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> q</span><br><span class="line"><span class="keyword">import</span> <span class="string">"p"</span></span><br><span class="line"><span class="keyword">var</span> _ = p.T&#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125; <span class="comment">// 编译错误，无法引用a、b</span></span><br><span class="line"><span class="keyword">var</span> _ = p.T&#123;<span class="number">1</span>, <span class="number">2</span>&#125;     <span class="comment">// 编译错误，无法引用a、b</span></span><br></pre></td></tr></table></figure></p>
<p>虽然上面的最后一行代码没有显式地提到不可导出变量，但是它们被隐式地引用了，所以这也是不允许的。</p>
<p>结构体类型的值可以作为参数传递给函数或者作为函数的返回值。例如，下面的函数将Point缩放了一个比率：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scale</span><span class="params">(p Point, factor <span class="keyword">int</span>)</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Point&#123;p.X * factor, p.Y * factor&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(scale(Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, <span class="number">5</span>)) <span class="comment">// &#123;5, 10&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>出于效率的考虑，大型的结构体通常都使用结构体指针的方式直接传递给函数或者从函数中返回。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bonus</span><span class="params">(e *Employee, percent <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Salary * percent / <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式在函数需要修改结构体内容的时候也是必需的，在Go这种按值调用的语言中，调用的函数接收到的是实参的一个副本，并不是实参的引用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AwardAnnualRaise</span><span class="params">(e *Employee)</span></span> &#123;</span><br><span class="line">    e.Salary = e.Salary * <span class="number">105</span> / <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于通常结构体都通过指针的方式使用，因此可以使用一种简单的方式来创建、初始化一个struct类型的变量并获取它的地址：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp := &amp;Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个等价于：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pp := <span class="built_in">new</span>(Point)</span><br><span class="line">*pp = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是&amp;Point{1，2}这种方式可以直接使用在一个表达式中，例如函数调用。</p>
<h2 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a><span style="color:#00ACC1;">结构体比较</span></h2><p>如果结构体的所有成员变量都可以比较，那么这个结构体就是可比较的。两个结构体的比较可以使用=或者!=。其中==操作符按照顺序比较两个结构体变量的成员变量，所以下面的两个输出语句是等价的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span>&#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class="comment">// false</span></span><br><span class="line">fmt.Println(p==q)                     <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>和其他可比较的类型一样，可比较的结构体类型都可以作为map的键类型。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">    hostname <span class="keyword">string</span></span><br><span class="line">    port     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">hits := <span class="built_in">make</span>(<span class="keyword">map</span>[address]<span class="keyword">int</span>)</span><br><span class="line">hits[address&#123;<span class="string">"golang.org"</span>, <span class="number">443</span>&#125;]++</span><br></pre></td></tr></table></figure></p>
<h2 id="结构体嵌套和匿名成员"><a href="#结构体嵌套和匿名成员" class="headerlink" title="结构体嵌套和匿名成员"></a><span style="color:#00ACC1;">结构体嵌套和匿名成员</span></h2><p>本节将讨论Go中不同寻常的结构体嵌套机制，这个机制可以让我们将一个命名结构体当作另一个结构体类型的匿名成员使用；并提供了一种方便的语法，使用简单的表达式（比如x.f）就可以代表连续的成员（比如x.d.e.f）。</p>
<p>想象一下2D绘图程序中会提供的关于形状的库，比如矩形、椭圆、星形和车轮形。这里定义了其中可能存在的两个类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y, Radius, Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Circle类型定义了圆心的坐标X和Y，另外还有一个半径Radius。Wheel类型拥有Circle类型的所有属性，另外还有一个Spokes属性，即车轮中条辐的数量。创建一个Wheel类型的对象：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X=<span class="number">8</span></span><br><span class="line">w.Y=<span class="number">8</span></span><br><span class="line">w.Radius =<span class="number">5</span></span><br><span class="line">w.Spokes =<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>在需要支持的形状变多之后，我们将意识到它们之间的相似性和重复性。所以，很自然地，我们会重构相同的部分<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Center Point</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle Circle</span><br><span class="line">    Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序看上去变得更清晰了，但是访问Wheel的成员变麻烦了：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.Circle.Center.X = <span class="number">8</span></span><br><span class="line">w.Circle.Center.Y = <span class="number">8</span></span><br><span class="line">w.Circle.Radius = <span class="number">5</span></span><br><span class="line">w.Spokes =<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>Go允许我们定义不带名称的结构体成员，只需要指定类型即可；这种结构体成员称做匿名成员。这个结构体成员的类型必须是一个命名类型或者指向命名类型的指针。下面的Circle和Wheel都拥有一个匿名成员。这里称Point被嵌套到Circle中，Circle被嵌套到Wheel中。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Point</span><br><span class="line">    Radius <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Wheel <span class="keyword">struct</span> &#123;</span><br><span class="line">    Circle</span><br><span class="line">    Spokes <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正因为有了这种结构体嵌套的功能，我们才能直接访问到我们需要的变量而不是指定一大串中间变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w Wheel</span><br><span class="line">w.X = <span class="number">8</span> <span class="comment">// 等价于w.Circle.Point.X = 8</span></span><br><span class="line">w.Y = <span class="number">8</span> <span class="comment">// 等价于W.Circle.Point.Y = 8</span></span><br><span class="line">w.Radius = <span class="number">5</span> <span class="comment">// 等价于w.Circle.Radius = 5</span></span><br><span class="line">w.Spokes =<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>上面注释里面的方式也是正确的，但是使用“匿名成员”的说法或许不合适。上面的结构体成员Circle和Point是有名字的，就是对应类型的名字，只是这些名字在点号访问变量时是可选的。当我们访问最终需要的变量的时候可以省略中间所有的匿名成员。</p>
<p>遗憾的是，结构体字面量并没有什么快捷方式来初始化结构体，所以下面的语句是无法通过编译的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;<span class="number">8</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">20</span>&#125;                   <span class="comment">// 编译错误，未知成员变量</span></span><br><span class="line">w = Wheel&#123;X:<span class="number">8</span>,Y:<span class="number">8</span>,Radius:<span class="number">5</span>,Spokes:<span class="number">20</span>&#125; <span class="comment">// 编译错误，未知成员</span></span><br></pre></td></tr></table></figure></p>
<p>结构体字面量必须遵循形状类型的定义，所以我们使用下面的两种方式来初始化，这两种方式是等价的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">w = Wheel&#123;Circle&#123;Point&#123;<span class="number">8</span>, <span class="number">8</span>&#125;, <span class="number">5</span>&#125;, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">w = Wheel&#123;</span><br><span class="line">    Circle: Circle&#123;</span><br><span class="line">        Point:  Point&#123;X: <span class="number">8</span>, Y: <span class="number">8</span>&#125;,</span><br><span class="line">        Radius: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    Spokes: <span class="number">20</span>, <span class="comment">// 注意：尾部的逗号是必需的（Radius后面的逗号也一样）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, w)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br><span class="line"></span><br><span class="line">w.X = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, w)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>注意副词#如何使得Printf的格式化符号%v以类似Go语法的方式输出对象，这个方式里面包含了成员变量的名字。</p>
<p>因为“匿名成员”拥有隐式的名字，所以你不能在一个结构体里面定义两个相同类型的匿名成员，否则会引起冲突。由于匿名成员的名字是由它们的类型决定的，因此它们的可导出性也是由它们的类型决定的。在上面的例子中，Point和Circle这两个匿名成员是可导出的。即使这两个结构体是不可导出的（point和circle），我们仍然可以使用快捷方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.X = <span class="number">8</span> <span class="comment">// 等价于w.circle.point.X = 8</span></span><br></pre></td></tr></table></figure></p>
<p>但是注释中那种显式指定中间匿名成员的方式在声明circle和point的包之外是不允许的，因为它们是不可导出的。</p>
<p>到目前为止，我们所看到关于结构体嵌套的使用，仅仅是关于点号访问匿名成员内部变量的语法糖。后面我们将了解到匿名成员不一定是结构体类型，任何命名类型或者指向命名类型的指针都可以。不过话说回来，嵌套一个没有子成员的类型有什么用呢？</p>
<p>以快捷方式访问匿名成员的内部变量同样适用于访问匿名成员的内部方法。因此，外围的结构体类型获取的不仅是匿名成员的内部变量，还有相关的方法。这个机制就是从简单类型对象组合成复杂的复合类型的主要方式。在Go中，组合是面向对象编程方式的核心，这将在6.3节进一步讲述。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><span style="color:#339AFF;">JSON</span></h1><p>JavaScript对象表示法（JSON）是一种发送和接收格式化信息的标准。JSON不是唯一的标准，XML（见7.14节）、ASN.1和Google的Protocol Buffer都是相似的标准，各自有适用的场景。但是因为JSON的简单、可读性强并且支持广泛，所以使用得最多。</p>
<p>Go通过标准库encoding/json、encoding.xml、encoding/asn1和其他的库对这些格式的编码和解码提供了非常好的支持，这些库都拥有相同的API。本节对使用最多的encoding/json做一个简要的描述。<br>JSON是JavaScript值的Unicode编码，这些值包括字符串、数字、布尔值、数组和对象。JSON是基本数据类型和复合数据类型的一种高效的、可读性强的表示方法。第3章讲解了基础数据类型，本章讲解了复合数据类型一数组、slice、结构体和map。</p>
<p>JSON最基本的类型是数字（以十进制或者科学计数法表示）、布尔值（true或false）和字符串。字符串是用双引号括起来的Unicode代码点的序列，使用反斜杠作为转义字符，通过和Go类似的方式访问成员。当然，JSON里面的\uhhh数字转义得到的是UTF-16编码，而不是Go里面的字符。</p>
<p>这些基础类型可以通过JSON的数组和对象进行组合。JSON的数组是一个有序的元素序列，每个元素之间用逗号分隔，两边使用方括号括起来。JSON的数组用来编码Go里面的数组和slice。JSON的对象是一个从字符串到值的映射，写成name：value对的序列，每个元素之间用逗号分隔，两边使用花括号括起来。JSON的对象用来编码Go里面的map（键为字符串类型）和结构体。例如<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolear</span><br><span class="line">true</span><br><span class="line">number</span><br><span class="line"><span class="number">-273.15</span></span><br><span class="line">string</span><br><span class="line">She said "Hello，世界"</span><br><span class="line">array</span><br><span class="line">[<span class="string">"gold"</span>,<span class="string">"silver"</span>,<span class="string">"bronze"</span>]</span><br><span class="line">object</span><br><span class="line">&#123;<span class="attr">"year"</span>:<span class="number">1980</span>,</span><br><span class="line"><span class="attr">"event"</span>: <span class="string">"archery"</span>,</span><br><span class="line"><span class="attr">"medals"</span>:[<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>l]&#125;</span><br></pre></td></tr></table></figure></p>
<p>想象一个程序需要收集电影的观看次数并提供推荐。这个程序的Movie类型和典型的元素列表都在下面提供了。（结构体中成员Year和color后面的字符串字面量是成员的标签，稍后会讲解它。）<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch4/movie</span><br><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span></span><br><span class="line">Year <span class="keyword">int</span>、json:<span class="string">"released"</span></span><br><span class="line">Color <span class="keyword">bool</span> json:<span class="string">"color,omitempty"</span></span><br><span class="line">Actors []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> movies = []Movie&#123;</span><br><span class="line">&#123;Title: <span class="string">"Casablanca"</span>, Year: <span class="number">1942</span>, Color:<span class="literal">false</span>,</span><br><span class="line">Actors: []<span class="keyword">string</span>&#123;<span class="string">"Humphrey Bogart"</span>, <span class="string">"Ingrid Bergman"</span>&#125;&#125;, &#123;Title: <span class="string">"Cool Hand Luke"</span>, Year: <span class="number">1967</span>, Color:<span class="literal">true</span>,</span><br><span class="line">Actors: []<span class="keyword">string</span>&#123;<span class="string">"Paul Newman"</span>&#125;&#125;,</span><br><span class="line">&#123;Title: <span class="string">"Bullitt"</span>, Year: <span class="number">1968</span>, color:<span class="literal">true</span>,</span><br><span class="line">Actors: []<span class="keyword">string</span>&#123;<span class="string">"Steve McQueen"</span>, <span class="string">"Jacqueline Bisset"</span>&#125;&#125;, <span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<p>这种类型的数据结构体最适合JSON，无论是从Go对象转为JSON还是从JSON转换为Go对象都很容易。把Go的数据结构（比如movies）转换为JSON称为marshal。marshal是通过json.Marshal来实现的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data, err :=json.Marshal(movies]</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"JSoN marshaling failed:%s"</span>, err)</span><br><span class="line">ht.pntf(<span class="string">"%s\n"</span>, data)</span><br></pre></td></tr></table></figure></p>
<p>Marsha1生成了一个字节slice，其中包含一个不带有任何多余空白字符的很长的字符串。 把生成的结果折叠一下放在这里：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="attr">"Title"</span>:<span class="string">"Casablanca"</span>,<span class="attr">"released"</span>:<span class="number">1942</span>,<span class="attr">"Actors"</span>:[<span class="string">"Humphrey Bogart"</span>,<span class="string">"Ingr</span></span><br><span class="line"><span class="string">id Bergman"</span>]&#125;,&#123;<span class="attr">"Title"</span>:<span class="string">"Cool Hand Luke"</span>,<span class="attr">"released"</span>:<span class="number">1967</span>,<span class="attr">"color"</span>:<span class="literal">true</span>,<span class="attr">"Ac</span></span><br><span class="line"><span class="attr">tors"</span>:[<span class="string">"Paul Newman"</span>]&#125;,&#123;<span class="attr">"Title"</span>:<span class="string">"Bullitt"</span>,<span class="attr">"released"</span>:<span class="number">1968</span>,<span class="attr">"color"</span>:<span class="literal">true</span>,<span class="attr">"</span></span><br><span class="line"><span class="attr">Actors"</span>:[<span class="string">"Steve McQueen"</span>,<span class="string">"Jacqueline Bisset"</span>]&#125;]</span><br></pre></td></tr></table></figure></p>
<p>这种紧凑的表示方法包含了所有的信息但是难以阅读。为了方便阅读，有一个json.</p>
<p>MarshalIndent的变体可以输出整齐格式化过的结果。这个函数有两个参数，一个是定义每行输出的前缀字符串，另外一个是定义缩进的字符串。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">data, err := json.MarshalIndent(movies,<span class="string">""</span>,</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="number">1</span>og. Fatalf(<span class="string">"JSoN marshaling failed: %s"</span>, err)</span><br><span class="line">ht.prinf(<span class="string">"%s\n"</span>, data)</span><br><span class="line">上面的代码输出：</span><br><span class="line">r</span><br><span class="line"><span class="string">"Title"</span>:<span class="string">"Casablanca"</span>,</span><br><span class="line"><span class="string">"released"</span>:<span class="number">1942</span>,</span><br><span class="line"><span class="string">"Actors"</span>:[</span><br><span class="line"><span class="string">"Humphrey Bogart"</span>,</span><br><span class="line"><span class="string">"Ingrid Bergman"</span></span><br><span class="line">]</span><br><span class="line"><span class="string">"Title"</span>:<span class="string">"Cool Hand Luke"</span>, <span class="string">"released"</span>:<span class="number">1967</span>,</span><br><span class="line"><span class="string">"color"</span>:<span class="literal">true</span>;</span><br><span class="line"><span class="string">"Actors"</span>:[</span><br><span class="line"><span class="string">"Paul Newman"</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="string">"Title"</span>: <span class="string">"Bullitt"</span>, <span class="string">"released"</span>:<span class="number">1968</span>,</span><br><span class="line"><span class="string">"color"</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="string">"Actors"</span>: [</span><br><span class="line"><span class="string">"Steve McQueen"</span>, <span class="string">"Jacqueline Bisset"</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>marshal使用Go结构体成员的名称作为JSON对象里面字段的名称（通过反射的方式，这将在12.6节中介绍）。只有可导出的成员可以转换为JSON字段，这就是为什么我们将Go结构体里面的所有成员都定义为首字母大写的。</p>
<p>你或许注意到了，上面的结构体成员Year对应地转换为released，另外color转换为color。这个是通过成员标签定义（field tag）实现的。成员标签定义是结构体成员在编译期间关联的一些元信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Year int ‘json:"released"-</span><br><span class="line">Color bool  json:"color,omitempty"</span><br></pre></td></tr></table></figure></p>
<p>成员标签定义可以是任意字符串，但是按照习惯，是由一串由空格分开的标签键值对key：”value”组成的；因为标签的值使用双引号括起来，所以一般标签都是原生的字符串字面量。键json控制包encoding/json的行为，同样其他的encoding/…包也遵循这个规则。标签值的第一部分指定了Go结构体成员对应JSON中字段的名字。成员的标签通常这样使用，比如total_count对应Go里面的TotalCount。Color的标签还有一个额外的选项，omitempty，它表示如果这个成员的值是零值或者为空，则不输出这个成员到JSON中。所以，对于《Casablanca》这部黑白电影，就没有输出成员color到JSON中。</p>
<p>marshal的逆操作将JSON字符串解码为Go数据结构，这个过程叫作unmarshal，这个是由json.unmarshal实现的。下面的代码将电影的JSON数据转换到结构体slice中，这个结构体唯一的成员就是Title。通过合理地定义Go的数据结构，我们可以选择将哪部分JSON数据解码到结构体对象中，哪些数据可以丢弃。当函数Unmarshal调用完成后，它将填充结构体slice中Title的值，JSON中其他的字段就丢弃了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> titles []<span class="keyword">struct</span>&#123; Title <span class="keyword">string</span> &#125;</span><br><span class="line"><span class="keyword">if</span> err :=json.unmarshal(data, &amp;titles);err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatalf(<span class="string">"JSON unmarshaling failed: %s"</span>, err)</span><br><span class="line">t PrintIn(titles)  <span class="string">"[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]</span></span><br></pre></td></tr></table></figure></p>
<p>很多的Web服务都提供JSON接口，通过发送HTTP请求来获取想要得到的JSON信息。我们通过查询GitHub提供的issue跟踪接口来演示一下。首先，要定义需要的类型和常量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch4/githut</span><br><span class="line"><span class="comment">//包github提供了GitHub issue跟踪接口的GoAPI</span></span><br><span class="line"><span class="comment">//详细查看https://developer.github.com/v3/search/#search-issues.</span></span><br><span class="line"><span class="keyword">package</span> github</span><br><span class="line"><span class="keyword">import</span> <span class="string">"time"</span></span><br><span class="line">constIssuesuRl=<span class="string">"https://api.github.com/search/issues"</span></span><br><span class="line"><span class="keyword">type</span> IssuesSearchResult <span class="keyword">struct</span> &#123;</span><br><span class="line">TotalCount <span class="keyword">int</span> ‘json:<span class="string">"total_count"</span></span><br><span class="line">Items</span><br><span class="line">[]\*Issue</span><br><span class="line"><span class="keyword">type</span> Issue <span class="keyword">struct</span> &#123;</span><br><span class="line">Number</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">HTMLURL</span><br><span class="line"><span class="keyword">string</span> <span class="string">'json:"html_ur1"</span></span><br><span class="line"><span class="string">Title</span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">State</span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">User</span></span><br><span class="line"><span class="string">\*User</span></span><br><span class="line"><span class="string">CreatedAt time.Time '</span>json:<span class="string">"created_at"</span> Body</span><br><span class="line"><span class="keyword">string</span> <span class="comment">// Markdown格式</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Login <span class="keyword">string</span></span><br><span class="line">HTMLURL <span class="keyword">string</span> 、json:<span class="string">"html_ur1"</span></span><br></pre></td></tr></table></figure></p>
<p>和前面一样，即使对应的JSON字段的名称不是首字母大写，结构体的成员名称也必须首字母大写。由于在unmarshal阶段，JSON字段的名称关联到Go结构体成员的名称是忽略大小写的，因此这里只需要在JSON中有下划线而Go里面没有下划线的时候使用一下成员标签定义。同样，这里选择性地对JSON中的字段进行解码，因为相对于这里演示的内容，GitHub的查询回复返回相当多的信息。</p>
<p>函数SearchIssues发送HTTP请求并将回复解析为JSON。由于用户的查询请求参数中可能存在一些字符，这些字符在URL中是特殊字符，比如？或者&amp;，因此使用url.QueryEscape函数来确保它们拥有正确的含义。</p>
<p>前面的例子使用了json.Unmarshal来将整个字节slice解码为单个JSON实体。这里变化一下，使用流式解码器（即json.Decoder），可以利用它来依次从字节流里面解码出多个JSON实体，我们现在还用不到这个功能。你或许猜到了，也有一个叫作json.Encoder的流式编码器。<br>调用Decode方法来填充变量result。有各种方法来将结果格式化得好看一点。最简单的就是使用下面介绍的关于issues命令的方法，使用固定宽度的表格，下一节将讨论一个基于模板的复杂一点的方法。</p>
<p>命令行参数指定搜索的条件，该命令搜索Go项目的issue跟踪接口，查找关于JSON编码的Open状态的bug列表。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build gopl.io/ch4/issues</span><br><span class="line">$ ./issues repo:golang/<span class="keyword">go</span> is:open json decoder</span><br><span class="line"><span class="number">13</span> issues:</span><br><span class="line">#<span class="number">5680</span> eaigner encoding/json: set key converter on en/decoder</span><br><span class="line">#<span class="number">6e5</span>e gopherbot encoding/json: provide tokenizer</span><br><span class="line">#<span class="number">8658</span> gopherbot encoding/json: use bufio</span><br><span class="line">#<span class="number">8462</span> kortschak encoding/json: UnmarshalText confuses json.Unmarshal</span><br><span class="line">#<span class="number">5901</span></span><br><span class="line">rsc encoding/json: allow override <span class="keyword">type</span> marshaling</span><br><span class="line">#<span class="number">9812</span> klauspost encoding/json:<span class="keyword">string</span> tag not symmetric</span><br><span class="line">#<span class="number">7872</span> extempora encoding/json: Encoder internally buffers full output</span><br><span class="line">#<span class="number">9650</span> cespare encoding/json: Decoding gives errPhase when unmarshalin</span><br><span class="line">#<span class="number">6716</span><span class="string">'gopherbot encoding/json:include field name in unmarshal error me</span></span><br><span class="line"><span class="string">#6901 lukescott encoding/json, encoding/xml: option to treat unknown fi</span></span><br><span class="line"><span class="string">#6384joeshaw encoding/json: encode precise floating point integers u</span></span><br><span class="line"><span class="string">#6647 btracey x/tools/cmd/godoc:display type kind of each named type</span></span><br><span class="line"><span class="string">#4237gjemiller encoding/base64:URLEncoding padding is optional</span></span><br></pre></td></tr></table></figure></p>
<p>GitHub的Web服务接口(<a href="https://developer.github.com/v3/" target="_blank" rel="noopener">https://developer.github.com/v3/</a>)有很多的功能，这里就不再赘述了。</p>
<p>练习4.10：修改issues实例，按照时间来输出结果，比如一个月以内，一年以内或者超过一年。</p>
<p>练习4.11：开发一个工具来让用户可以通过命令行创建、读取、更新或者关闭GitHub的issues，当需要额外输人的时候，调用他们喜欢的文本编辑器。</p>
<p>练习4.12:流行的Web漫画xkcd有一个JSON接口。例如，调用<a href="https://xkcd.com/571/info.e.json" target="_blank" rel="noopener">https://xkcd.com/571/info.e.json</a>输出漫画571的详细描述，这个是很多人最喜欢的之一。下载每一个URL并且构建一个离线索引。编写一个工具xkcd来使用这个索引，可以通过命令行指定的搜索条件来查找并输出符合条件的每个漫画的URL和剧本。</p>
<p>练习4,13:基于JSON开发的Web服务，开放电影数据库让你可以在<a href="https://omdbapi.com/" target="_blank" rel="noopener">https://omdbapi.com/</a>上通过名字来搜索电影并下载海报图片。开发一个poster工具以通过命令行指定的电影名称来下载海报。</p>
<h1 id="文本和HTML模板"><a href="#文本和HTML模板" class="headerlink" title="文本和HTML模板"></a><span style="color:#339AFF;">文本和HTML模板</span></h1><p>上面的例子仅仅给出了最简单的格式化，这种情况下，Printf函数足够用了。但是有的情况下格式化会比这个复杂得多，并且要求格式和代码彻底分离。这个可以通过text/template包和html/template包里面的方法来实现，这两个包提供了一种机制，可以将程序变量的值代人到文本或者HTML模板中。</p>
<p>模板是一个字符串或者文件，它包含一个或者多个两边用双大括号包围的单元..}}，这称为操作。大多数的字符串是直接输出的，但是操作可以引发其他的行为。每个操作在模板语言里面都对应一个表达式，提供的简单但强大的功能包括：输出值，选择结构体成员，调用函数和方法，描述控制逻辑（比如if-else语句和range循环），实例化其他的模板等。一个简单的字符串模板如下所示：</p>
<p>这个程序输出一个纯文本，如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build gopl.io/ch4/issuesreport</span><br><span class="line">$ ./issuesreport repo:golang/<span class="keyword">go</span> is:open json decoder <span class="number">13</span> issues:</span><br><span class="line">Number:<span class="number">5680</span></span><br><span class="line">User: eaigner</span><br><span class="line">Title: encoding/json:set key converter on en/decoder Age:</span><br><span class="line"><span class="number">750</span> days</span><br><span class="line">Number:<span class="number">6050</span></span><br><span class="line">User:</span><br><span class="line">gopherbot</span><br><span class="line">Title:</span><br><span class="line">encoding/json: provide tokenizer</span><br><span class="line">Age:</span><br><span class="line"><span class="number">695</span> days</span><br></pre></td></tr></table></figure></p>
<p>我们再来看html/template包。它使用和text/template包里面一样的API和表达式语句，并且额外地对出现在HTML、JavaScript、CSS和URL中的字符串进行自动转义。这些功能可以避免生成的HTML引发长久以来都会有的安全问题，比如注入攻击，对方利用issue的标题来包含不安全的代码，在模板中如果没有合理地进行转义，会让它们能够控制整个页面。</p>
<p>下面的模板将issue输出为HTML的表格，注意导人不同的包：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch4/issueshtml</span><br><span class="line"><span class="keyword">import</span> <span class="string">"html/template"</span></span><br><span class="line"><span class="keyword">var</span> issuelist - template.Must(template.New(<span class="string">"issuelist"</span>).Parse(</span><br><span class="line">&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;/h1&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr style=<span class="string">'text-align:left'</span>&gt;</span><br><span class="line">&lt;th&gt;#&lt;/th&gt;</span><br><span class="line">&lt;th&gt;State&lt;/th&gt;</span><br><span class="line">&lt;th&gt;User&lt;/th&gt;</span><br><span class="line">&lt;th&gt;Title&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&#123;&#123;<span class="keyword">range</span> .Items&#125;&#125;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;a href='&#123;&#123;.HTMLURL&#125;&#125;'&gt;&#123;&#123;.Number&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;a href='&#123;&#123;.User.HTMLURL&#125;&#125;'&gt;&#123;&#123;.User.login&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;a href=\*&#123;&#123;.HTMLURL&#125;&#125;<span class="string">'&gt;&#123;&#123;.Title&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="string">&lt;/tr&gt;</span></span><br><span class="line"><span class="string">&#123;&#123;end&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;/table&gt;</span></span><br><span class="line"><span class="string">^))</span></span><br></pre></td></tr></table></figure></p>
<p>下面的命令对查询的结果执行新的模板，这些结果和上面的稍许不同：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch4/issueshtml</span><br><span class="line">$ ./issueshtml repo:golang/go commenter:gopherbot json encoder &gt;issues.html</span><br></pre></td></tr></table></figure></p>
<p>图4-4显示了生成的HTML表格在Web浏览器中的样子。链接指向GitHub上面对应的页面。</p>
<blockquote>
<p>图4-4 将获取的Go项目的issue列表的JSON数据以HTML表格显示</p>
</blockquote>
<img src="/2021/07/18/第4章-复合数据类型/4.png">
<p>上图中issue的HTML信息显示没有问题，但我们可以通过在issue标题中包含HTML的元字符（比如&amp;和《）来看一下效果。我们选择了两个issue来做演示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./issueshtml repo:golang/go 3133 10535 &gt;issues2.html</span><br></pre></td></tr></table></figure></p>
<p>图4-5显示了查询的结果。注意，html/template包自动将HTML元字符转义，这样标题才能显示正常。如果我们错误地使用了text/template包，那么字符串“&amp;1t；”将会被当做小于号《*，而字符串“《link》”将变成一个link元素，这将改变HTML的文档结构，甚至有可能产生安全问题。</p>
<img src="/2021/07/18/第4章-复合数据类型/5.png">
<p>我们可以通过使用命名的字符串类型</p>
<p>2.hbml</p>
<p>template.HTML类型而不是字符串类型避免模+cnBfile://home/gopher/issues2.html<br>板自动转义受信任的HTML数据。同样的命名类型适用于受信任的JavaScript、CSS和2 issues<br>URL。下面的程序演示了相同数据在不同类型<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">State User Title</span><br><span class="line"><span class="number">3133</span> dlosed ukai htmltemplate; escape xmldesc as&amp;lt:?<span class="number">3</span>xml</span><br></pre></td></tr></table></figure></p>
<p>下的效果，A是字符串类型而B是template.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10535 open dypukoy x/nethtml; yoid clement <span class="tag">&lt;<span class="name">link</span>&gt;</span> has child nodes</span><br></pre></td></tr></table></figure></p>
<p>HTML类型。</p>
<p>图4-6演示了这个模板在浏览器中的输出，我们可以看出来A转义了而B没有。</p>
<blockquote>
<p>图4-6 字符串值被HTML转义了，但是template.HTML值没有</p>
</blockquote>
<img src="/2021/07/18/第4章-复合数据类型/6.png">
<p>这里仅仅演示了模板系统最基本的功能。如果你希望获取更多的信息，可以查询相关包的文档。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go doc text/template</span><br><span class="line">$ go doc html/template</span><br></pre></td></tr></table></figure></p>
<p>练习4.14：创建一个Web服务器，可以通过查询GitHub并缓存信息，然后可以浏览bug列表、里程碑信息以及参与用户的信息。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go程序设计语言/" rel="tag"># Go程序设计语言</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/16/第3章-基本数据/" rel="next" title="第3章 基本数据">
                <i class="fa fa-chevron-left"></i> 第3章 基本数据
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/第1章-基础知识/" rel="prev" title="第1章 基础知识">
                第1章 基础知识 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1017</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">72</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/04/04/结束语｜秒杀系统之上的业务协同思考/" title="结束语｜秒杀系统之上的业务协同思考" target="_blank">结束语｜秒杀系统之上的业务协同思考</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/14｜百万级流量秒杀系统的关键总结/" title="14｜百万级流量秒杀系统的关键总结" target="_blank">14｜百万级流量秒杀系统的关键总结</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/13｜优化番外篇：Vertx介绍及快速入门/" title="13｜优化番外篇：Vertx介绍及快速入门" target="_blank">13｜优化番外篇：Vertx介绍及快速入门</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/12｜高性能优化：单机Java极致优化/" title="12｜高性能优化：单机Java极致优化" target="_blank">12｜高性能优化：单机Java极致优化</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/11｜高性能优化：物理机极致优化/" title="11｜高性能优化：物理机极致优化" target="_blank">11｜高性能优化：物理机极致优化</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数组"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#slice"><span class="nav-number">2.</span> <span class="nav-text">slice</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#append函数"><span class="nav-number">2.1.</span> <span class="nav-text">append函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice就地修改"><span class="nav-number">2.2.</span> <span class="nav-text">slice就地修改</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#map"><span class="nav-number">3.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体"><span class="nav-number">4.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体字面量"><span class="nav-number">4.1.</span> <span class="nav-text">结构体字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体比较"><span class="nav-number">4.2.</span> <span class="nav-text">结构体比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体嵌套和匿名成员"><span class="nav-number">4.3.</span> <span class="nav-text">结构体嵌套和匿名成员</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSON"><span class="nav-number">5.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文本和HTML模板"><span class="nav-number">6.</span> <span class="nav-text">文本和HTML模板</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.2m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">124:48</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
