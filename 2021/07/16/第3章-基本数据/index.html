<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go程序设计语言">
<meta property="og:type" content="article">
<meta property="og:title" content="第3章 基本数据">
<meta property="og:url" content="http://yoursite.com/2021/07/16/第3章-基本数据/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/07/16/第3章-基本数据/2.png">
<meta property="og:image" content="http://yoursite.com/2021/07/16/第3章-基本数据/3.png">
<meta property="og:image" content="http://yoursite.com/2021/07/16/第3章-基本数据/4.png">
<meta property="og:image" content="http://yoursite.com/2021/07/16/第3章-基本数据/5.png">
<meta property="og:updated_time" content="2021-10-04T00:23:20.882Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第3章 基本数据">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="twitter:image" content="http://yoursite.com/2021/07/16/第3章-基本数据/2.png">






  <link rel="canonical" href="http://yoursite.com/2021/07/16/第3章-基本数据/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第3章 基本数据 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/16/第3章-基本数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="放弃会成为一种习惯">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第3章 基本数据

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-07-16 19:27:00" itemprop="dateCreated datePublished" datetime="2021-07-16T19:27:00+08:00">2021-07-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-10-04 08:23:20" itemprop="dateModified" datetime="2021-10-04T08:23:20+08:00">2021-10-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">24k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">22 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>毫无疑问，计算机底层全是位，而实际操作则是基于大小固定的单元中的数值，称为字（word），这些值可解释为整数、浮点数、位集（bitset）或内存地址等，进而构成更大的聚合体，以表示数据包、像素、文件、诗集，以及其他种种。Go的数据类型宽泛，并有多种组织方式，向下匹配硬件特性，向上满足程序员所需，从而可以方便地表示复杂数据结构。</p>
<p>Go的数据类型分四大类：基础类型（basic type）、聚合类型（aggregate type）、引用类型（reference type）和接口类型（interface type）。本章的主题是基础类型，包括数字（number）.字符串（string）和布尔型（boolean）。聚合类型-数组（array，见4.1节）和结构体（struct，见4.4节）一是通过组合各种简单类型得到的更复杂的数据类型。引用是一大分类，其中包含多种不同类型，如指针（pointer，见2.3.2节），slice（见4.2节），map（见4.3节），函数（function，见第5章），以及通道（channel，见第8章）。它们的共同点是全都间接指向程序变量或状态，于是操作所引用数据的效果就会遍及该数据的全部引用。接口类型将在第7章讨论。</p>
<h1 id="整数"><a href="#整数" class="headerlink" title="整数"></a><span style="color:#339AFF;">整数</span></h1><p>Go的数值类型包括了几种不同大小的整数、浮点数和复数。各种数值类型分别有自己的大小，对正负号支持也各异。我们从整数开始。</p>
<p>Go同时具备有符号整数和无符号整数。有符号整数分四种大小：8位、16位、32位、64 位，用int8、int16、int32、int64表示，对应的无符号整数是uint8、uint16、unint32、uint64。</p>
<p>此外还有两种类型int和uint。在特定平台上，其大小与原生的有符号整数\无符号整数相同，或等于该平台上的运算效率最高的值。int是目前使用最广泛的数值类型。这两种类型大小相等，都是32位或64位，但不能认为它们一定就是32位，或一定就是64位；即使在同样的硬件平台上，不同的编译器可能选用不同的大小。</p>
<p>rune类型是int32类型的同义词，常常用于指明一个值是Unicode码点（code point）。这两个名称可互换使用。同样，byte类型是uint8类型的同义词，强调一个值是原始数据，而非量值。</p>
<p>最后，还有一种无符号整数uintptr，其大小并不明确，但足以完整存放指针。uintptr类型仅仅用于底层编程，例如在Go程序与C程序库或操作系统的接口界面。第13章介绍unsafe包，将会结合uintptr举例。</p>
<p>int、uint和uintptr都有别于其大小明确的相似类型的类型。就是说，int和int32是不同类型，尽管int天然的大小就是32位，并且int值若要当作int32使用，必须显式转换；反之亦然。</p>
<p>有符号整数以补码表示，保留最高位作为符号位，n位数字的取值范围是-2~ 2（n-1）-1。无符号整数由全部位构成其非负值，范围是0~2”-1。例如，int8可以从-128到127取值，而unit8从0到255取值。</p>
<p>Go的二元操作符涵盖了算术、逻辑和比较等运算。按优先级的降序排列如下：<br>% &amp;’ == != ts &amp;&amp;</p>
<p>二元运算符分五大优先级。同级别的运算符满足左结合律，为求清晰，可能需要圆括号，或为使表达式内的运算符按指定次序计算，如mask&amp;（1《《28）。</p>
<p>上述列表中前两行的运算符（如加法运算+）都有对应的赋值运算符（如+=），用于简写赋值语句。</p>
<p>算术运算符+、-、 *、/可应用于整数、浮点数和复数，而取模运算符%仅能用于整数。取模运算符%的行为因编程语言而异。就Go而言，取模余数的正负号总是与被除数一致，于是-5%3和-5%-3都得-2。除法运算（1）的行为取决于操作数是否都为整型，整数相除，商会舍弃小数部分，于是5.0/4.0得到1.25，而5/4结果是1。</p>
<p>不论是有符号数还是无符号数，若表示算术运算结果所需的位超出该类型的范围，就称为溢出。溢出的高位部分会无提示地丢弃。假如原本的计算结果是有符号类型，且最左侧位是1，则会形成负值，以int8为例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u <span class="keyword">uint8</span>=<span class="number">255</span></span><br><span class="line">fmt.Println(u,u+<span class="number">1</span>,u*u)<span class="number">1</span>“<span class="number">25501</span><span class="string">"</span></span><br><span class="line"><span class="string">var i int8 = 127</span></span><br><span class="line"><span class="string">fmt. Println(i,i+1,i*i)11“127 -1281*</span></span><br></pre></td></tr></table></figure></p>
<p>下列二元比较运算符用于比较两个类型相同的整数；比较表达式本身的类型是布尔型。等于<br>!=<br>不等于<br>。<br>小于<br>&lt;=<br>小于或等于<br>大于<br>>= 大于等于</p>
<p>实际上，全部基本类型的值（布尔值、数值、字符串）都可以比较，这意味着两个相同类型的值可用==和！=运算符比较。整数、浮点数和字符串还能根据比较运算符排序。许多其他类型的值是不可比较的，也无法排序。后面介绍每种类型时，我们将分别说明比较规则。</p>
<p>另外，还有一元加法和一元减法运算符：<br>一元取正（无实际影响）<br>一元取负</p>
<p>对于整数，+x是0+x的简写，而-x则为0-x的简写。对于浮点数和复数，+x就是x，-x为x的负数。</p>
<p>Go也具备下列位运算符，前四个对操作数的运算逐位独立进行，不涉及算术进位或正负号：</p>
<p>如果作为二元运算符，运算符^表示按位“异或”（XOR）；若作为一元前缀运算符，则它表示按位取反或按位取补，运算结果就是操作数逐位取反。运算符&amp;^是按位清除（ANDNOT）：表达式z=x&amp;^y中，若y的某位是1，则z的对应位等于0；否则，它就等于x的对应位。</p>
<p>下面的代码说明了如何用位运算将一个uint8值作为位集（bitset）处理，其含有8个独立的位，高效且紧凑。Printf用谓词%以二进制形式输出数值，副词8在这个输出结果前被零，补够8位。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">uint8</span>=<span class="number">1</span>&lt;&lt;<span class="number">1</span>|<span class="number">1</span>&lt;&lt;<span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">uint8</span>=<span class="number">1</span>&lt;&lt;<span class="number">1i</span>1&lt;&lt;<span class="number">2</span></span><br><span class="line">fmt.Printf（<span class="string">"%08b\n"</span>，x）<span class="number">11</span><span class="string">"00100010"</span>，集合&#123;<span class="number">1</span>，<span class="number">5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%08b\n"</span>,y) <span class="number">11</span>“<span class="number">00000110</span>*，集合&#123;<span class="number">1</span>，<span class="number">2</span>&#125;</span><br><span class="line">fmt.Printf（<span class="string">"%08b\n"</span>，x&amp;y）<span class="number">1</span><span class="string">"00000018"</span>，交集&#123;<span class="number">1</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%08b\n"</span>,x|y) /<span class="number">1</span> <span class="string">"00100110*，并集&#123;1，2，5&#125;</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%<span class="number">08</span>b\n<span class="string">",x^y)11"</span><span class="number">00100100</span><span class="string">" "</span>，对称差&#123;<span class="number">2</span>，<span class="number">5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%08b\n"</span>,x&amp;^y)/<span class="number">1</span> <span class="string">"00100000"</span>，差集&#123;<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i :=<span class="keyword">uint</span>(<span class="number">0</span>);i&lt;<span class="number">8</span>;i++&#123;</span><br><span class="line"><span class="keyword">if</span> x&amp;（<span class="number">1</span>《《i）！=<span class="number">0</span>&#123;<span class="comment">//元素判定</span></span><br><span class="line">fmt.Println(i)<span class="number">1</span>/“<span class="number">1</span><span class="string">"，“5"</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf（<span class="string">"%08b\n"</span>，x《《<span class="number">1</span>）<span class="comment">//"01000108*，集合&#123;2，6&#125;</span></span><br><span class="line">fmt.Printf（<span class="string">"%08b\n"</span>，x》》<span class="number">1</span>）<span class="comment">//"00010001*，集合&#123;e，4&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>（6.5节会介绍比单字节大得多的整数位集的实现。）</p>
<p>在移位运算x《《n和x》》n中，操作数n决定位移量，而且n必须为无符号型；操作数x可以是有符号型也可以是无符号型。算术上，左移运算x《《n等价于x乘以2^n；而右移运算x》》n等价于x除以2^n，向下取整。</p>
<p>左移以0填补右边空位，无符号整数右移同样以0填补左边空位，但有符号数的右移操作是按符号位的值填补空位。因此，请注意，如果将整数以位模式处理，须使用无符号整型。</p>
<p>尽管Go具备无符号整型数和相关算术运算，也尽管某些量值不可能为负，但是我们往往还采用有符号整型数，如数组的长度（即便直观上明显更应该选用uint）。下例从后向前输出奖牌名称，循环里用到了内置的len函数，它返回有符号整数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">medals :=[]<span class="keyword">string</span>&#123;<span class="string">"gold"</span>,<span class="string">"silver"</span>,<span class="string">"bronze"</span><span class="string">"</span></span><br><span class="line"><span class="string">for i := len(medals)-1;i&gt;=0;i--</span></span><br><span class="line"><span class="string">fmt.Println(medalsi\Imbrorae"</span>.<span class="string">"silver"</span>. <span class="string">"eold</span></span><br></pre></td></tr></table></figure></p>
<p>相反，假若len返回的结果是无符号整数，就会导致严重错误，因为i随之也成为uint型，根据定义，条件i》=将恒成立。第3轮迭代后，有i==0，语句i-使得i变为uint型的最大值（例如，可能为24-1），而非-1，导致medals[i]试图越界访问元素，超出slice范围，引发运行失败或宕机（见5.9节）。</p>
<p>因此，无符号整数往往只用于位运算符和特定算术运算符，如实现位集时，解析二进制格式的文件，或散列和加密。一般而言，无符号整数极少用于表示非负值。</p>
<p>通常，将某种类型的值转换成另一种，需要显式转换。对于算术和逻辑（不含移位）的二元运算符，其操作数的类型必须相同。虽然这有时会导致表达式相对冗长，但是一整类错误得以避免，程序也更容易理解。<br>考虑下面的语句，它与某些其他场景类似：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>尝试编译这三个声明将产生错误消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">非法操作：apples + oranges （int32与int16类型不匹配）</span><br></pre></td></tr></table></figure></p>
<p>类型不匹配（+的问题）有几种方法改正，最直接地，将全部操作数转换成同一类型：var compote = int(apples) +int(oranges)<br>2.5节已经提及，于每种类型T，若允许转换，操作T（x）会将x的值转换成类型T。很多整型-整型转换不会引起值的变化，仅告知编译器应如何解读该值。不过，缩减大小的整型转换，以及整型与浮点型的相互转换，可能改变值或损失精度：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f:=<span class="number">3.141</span><span class="comment">//afloat64</span></span><br><span class="line">i:=<span class="keyword">int</span>(f)</span><br><span class="line">fmt.Println(f, i)<span class="comment">//“3.1413*</span></span><br><span class="line">f=<span class="number">1.99</span></span><br><span class="line">fmt. Print1n(<span class="keyword">int</span>(f))<span class="comment">//"1"</span></span><br></pre></td></tr></table></figure></p>
<p>浮点型转成整型，会舍弃小数部分，趋零截尾（正值向下取整，负值向上取整）。如果有些转换的操作数的值超出了目标类型的取值范围，就应当避免这种转换，因为其行为依赖具体实现：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f:=<span class="number">1e100</span><span class="comment">// a float64</span></span><br><span class="line">i：=<span class="keyword">int</span>（f）<span class="comment">//结果依赖实现</span></span><br></pre></td></tr></table></figure></p>
<p>不论有无大小和符号限制，源码中的整数都能写成常见的十进制数；也能写成八进制数，以日开头，如666；还能写成十六进制数，以x或x开头，如xdeadbeef。十六进制的数字（或字母）大小写皆可。当前，八进制数似乎仅有一种用途表示POSIX文件系统的权限一而十六进制数广泛用于强调其位模式，而非数值大小。</p>
<p>如下例所示，如果使用fmt包输出数字，我们可以用谓词%d、%o和%x指定进位制基数和输出格式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:=<span class="number">0666</span></span><br><span class="line">fmt.Printf(<span class="string">"%d%[1]o %#[1]o\n"</span>, <span class="number">0</span>) <span class="comment">// "438 666 0666"</span></span><br><span class="line">x:=<span class="keyword">int64</span>(<span class="number">0xdeadbeef</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%d%[1]x%#[1]x%#[1]X\n"</span>,x)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="number">1</span>/ <span class="number">3735928559</span> deadbeef exdeadbeef eXDEADBEEF</span><br></pre></td></tr></table></figure></p>
<p>注意fmt的两个技巧。通常Printf的格式化字符串含有多个%谓词，这要求提供相同数目的操作数，而%后的副词[1]告知Printf重复使用第一个操作数。其次，%o、%x或%X之前的副词#告知Printf输出相应的前缀日、8x或ex。</p>
<p>源码中，文字符号（rune literal）的形式是字符写在一对单引号内。最简单的例子就是 ASCII字符，如’a’，但也可以直接使用Unicode码点（codepoint）或码值转义，稍后有介绍。 </p>
<p>用%c输出文字符号，如果希望输出带有单引号则用%q：</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a><span style="color:#339AFF;">浮点数</span></h1><p>Go具有两种大小的浮点数float32和float64。其算术特性遵从IEEE 754标准，所有新式CPU都支持该标准。</p>
<p>这两个类型的值可从极细微到超宏大。math包给出了浮点值的极限。常量math.MaxF1oat32是float32的最大值，大约为3.4e38，而math.MaxFloat64则大约为1.8e308。相应地，最小的正浮点值大约为1.4e-45和4.9e-324。</p>
<p>十进制下，float32的有效数字大约是6位，float64的有效数字大约是15位。绝大多数情况下，应优先选用float64，因为除非格外小心，否则float32的运算会迅速累积误差。另外，float32能精确表示的正整数范围有限：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span>= <span class="number">16777216</span> /<span class="number">1</span> <span class="number">1</span>&lt;<span class="number">24</span></span><br><span class="line">fmt.Println(f==f+<span class="number">1</span>) <span class="comment">// "true"</span></span><br></pre></td></tr></table></figure></p>
<p>在源码中，浮点数可写成小数，如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e = <span class="number">2.71828</span><span class="comment">//（近似值）</span></span><br></pre></td></tr></table></figure></p>
<p>小数点前的数字可以省略（.707），后面的也可省去（1.）。非常小或非常大的数字最好使用科学记数法表示，此方法在数量级指数前写字母e或E：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Avogadro = <span class="number">6.82214129e23</span></span><br><span class="line"><span class="keyword">const</span> Planck = <span class="number">6.62606957e-34</span></span><br></pre></td></tr></table></figure></p>
<p>浮点值能方便地通过Printf的谓词%g输出，该谓词会自动保持足够的精度，并选择最简洁的表示方式，但是对于数据表，%e（有指数）或%f（无指数）的形式可能更合适。这三个谓词都能掌控输出宽度和数值精度。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forx:=;x&lt;<span class="number">8</span>;x++&#123;</span><br><span class="line">fmt.Printf(<span class="string">"x=%d e* = %8.3f\n"</span>, x, math.Exp(<span class="keyword">float64</span>(x)))</span><br></pre></td></tr></table></figure></p>
<p>上面的代码按8个字符的宽度输出自然对数e的各个幂方，结果保留三位小数：<br>x=e<br>e”=<br>1.000<br>X=1<br>ex=<br>2.718<br>x=2<br>ex =<br>7.389<br>X=3<br>e” =<br>20.086<br>X=4<br>e” =<br>54.598<br>X=5<br>e”=<br>148.413<br>x=6<br>e”=<br>403.429<br>X=7<br>e= 1096.633<br>除了大量常见的数学函数之外，math包还有函数用于创建和判断IEEE754标准定义的特殊值：正无穷大和负无穷大，它表示超出最大许可值的数及除以零的商；以及NaN（Nota Number），它表示数学上无意义的运算结果（如/0或Sqrt（-1））。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z <span class="keyword">float64</span></span><br><span class="line">fmt.Println(z，-z，<span class="number">1</span>/z,<span class="number">-1</span>/z,z/z)<span class="number">1</span>/ <span class="string">"8 - +Inf -Inf NaN"</span></span><br></pre></td></tr></table></figure></p>
<p>math.IsNaN函数判断其参数是否是非数值，math.NaN函数则返回非数值（NaN）。在数字运算中，我们倾向于将NaN当作信号值（sentinel value），但直接判断具体的计算结果是否为NaN可能导致潜在错误，因为与NaN的比较总不成立（除了！=，它总是与==相反）：</p>
<p>一个函数的返回值是浮点型且它有可能出错，那么最好单独报错，如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">()</span><span class="params">(value <span class="keyword">float64</span>,ok <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> failed &#123;</span><br><span class="line"><span class="keyword">return</span> o, <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>下一个程序以浮点绘图运算为例。它根据传人两个参数的函数z=f（x，y），绘出三维的网线状曲面，绘制过程中运用了可缩放矢量图形（Scalable Vector Graphics，SVG），绘制线条的一种标准XML格式。图3-1是函数sin（r）/r的图形输出样例，其中r为sqrt（x<em>x+y</em>y）。</p>
<p>注意，corner函数返回两个值，构成网格单元其中一角的坐标。</p>
<p>理解这段程序只需基本的几何知识，但略过也无妨，因为本例旨在说明浮点运算。这段程序本质上是三套不同坐标系的相互映射，见图3-2。首先是个包含100x100个单元的二维网格，每个网格单元用整数坐标（i，j）标记，从最远处靠后的角落（0，0）开始。我们从后向前绘制，因而后方的多边形可能被前方的遮住。</p>
<blockquote>
<p>图3-2 三套不同坐标系</p>
</blockquote>
<img src="/2021/07/16/第3章-基本数据/2.png">
<p>第二个坐标系内，网格由三维浮点数（x，y，z）决定，其中x和y由i和j的线性函数决定，经过坐标转换，原点处于中央，并且坐标系按照xyrange进行缩放。高度值z由曲面函数f（x，y）决定。</p>
<p>第三个坐标系是二维成像绘图平面（image canvas），原点在左上角。这个平面中点的坐标记作（sx，sy）。我们用等角投影（isometric projection）将三维坐标点（x，y，z）映射到二维绘图平面上。若一个点的x值越大，y值越小，则其在绘图平面上看起来就越接近右方。而若一个点的x值或y值越大，且z值越小，则其在绘图平面上看起来就越接近下方。纵向（x）与横向（y）的缩放系数是由30°角的正弦值和余弦值推导而得。z方向的缩放系数为0.4，是个随意选定的参数值。<br>二维网格中的单元由main函数处理，它算出多边形ABCD在绘图平面上四个顶点的坐标，其中B对应（i，j），A、C、D则为其他三个顶点，然后再输出一条SVG指令将其绘出。</p>
<p>练习3.1：假如函数f返回一个float64型的无穷大值，就会导致SVG文件含有无效的《polygon》元素（尽管很多SVG绘图程序对此处理得当）。修改本程序以避免无效多边形。</p>
<p>练习3.2：用math包的其他函数试验可视化效果。你能否生成各种曲面，分别呈鸡蛋盒状、雪坡状或马鞍状？</p>
<p>练习3.3按高度给每个多边形上色，使得峰顶呈红色（f0000），谷底呈蓝色（000ff）。练习3.4：仿照1.7节的示例Lissajous的方法，构建一个Web服务器，计算并生成曲面，同时将SVG数据写人客户端。服务器必须如下设置Content-Type报头。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"image/svg+xml"</span>)</span><br></pre></td></tr></table></figure></p>
<p>（在Lissajous示例中，这一步并不强制要求，因为该服务器使用标准的启发式规则，根据响应内容最前面的512字节来识别常见的格式（如PNG），并生成正确的HTTP报头。）允许客户端通过HTTP请求参数的形式指定各种值，如高度、宽度和颜色。</p>
<h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a><span style="color:#339AFF;">复数</span></h1><p>Go具备两种大小的复数complex64和complex128，二者分别由float32和float64构成。内置的complex函数根据给定的实部和虚部创建复数，而内置的real函数和imag函数则分别提取复数的实部和虚部：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//1+2i</span></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">3</span>,<span class="number">4</span>)<span class="number">113</span>+<span class="number">41</span></span><br><span class="line">fmt.Println(x*y)</span><br><span class="line"><span class="string">"(-5+10i)"</span></span><br><span class="line">fmt Println(<span class="built_in">real</span>(x*y))</span><br><span class="line"><span class="string">".5'</span></span><br><span class="line"><span class="string">fmt.Println(imag(x*y))</span></span><br><span class="line"><span class="string">11 "</span><span class="number">10</span><span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>源码中，如果在浮点数或十进制整数后面紧接着写字母i，如3.1415921或2i，它就变成一个虚数，表示一个实部为0的复数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="number">1i</span>*<span class="number">1i</span>)<span class="comment">//"(-1+01)",1--1</span></span><br></pre></td></tr></table></figure></p>
<p>根据常量运算规则，复数常量可以和其他常量相加（整型或浮点型，实数和虚数皆可），这让我们可以自然地写出复数，如1+2i，或等价地，2i+1。前面x和y的声明可以简写为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x:=<span class="number">1</span>+<span class="number">2i</span></span><br><span class="line">y:=<span class="number">3</span>+<span class="number">4i</span></span><br></pre></td></tr></table></figure></p>
<p>可以用=或！=判断复数是否等值。若两个复数的实部和虚部都相等，则它们相等。 math/cmp1x包提供了复数运算所需的库函数，例如复数的平方根函数和复数的幂函数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(cmplx.sqrt(<span class="number">-1</span>))/<span class="string">"(0+1i)'</span></span><br></pre></td></tr></table></figure></p>
<p>下面的程序用complex128运算生成一个Mandelbrot集。</p>
<p>两个嵌套循环在1024x1024的灰度图上逐行扫描每个点，这个图表示复平面上-2~+2的区域，每个点都对应一个复数。该程序针对各个点反复迭代计算其平方与自身的和，判断其最终能否“超出”半径为2的圆。若然，就根据超出圆边界所需的迭代次数设定该点的灰度。否则，该点属于Mandelbrot集，颜色留黑。最后，程序将标准输出的数据写人PNG图，得到一个标志性的分形，见图3-3。</p>
<p>练习3.5：用image.NewRGBA函数和color.RGBA类型或color.ycbcr类型实现一个Mandelbrot集的全彩图。</p>
<blockquote>
<p>图3-3 Mandelbrot集</p>
</blockquote>
<img src="/2021/07/16/第3章-基本数据/3.png">
<p>练习3.6：超采样（supersampling）通过对几个临近像素颜色值取样并取均值，是一种减少锯齿化的方法。最简单的做法是将每个像素分成4个“子像素”。给出实现方式。</p>
<p>练习3.7：另一种简单的分形是运用牛顿法求某个函数的复数解，比如z*-1=0。以平面上各点作为牛顿法的起始，根据逼近其中一个根（共有4个根）所需的迭代次数对该点设定灰度。再根据求得的根对每个点进行全彩上色。</p>
<p>练习3.8：生成高度放大的分形需要极高的数学精度。分别用以下4种类型（complex64、 complex128、big.Float和big.Rat）表示数据实现同一个分形（后面两种类型由math/big包给出。big.Float类型随意选用float32/float64浮点数，但精度有限；big.Rat类型使用无限精度的有理数。）它们在计算性能和内存消耗上相比如何？放大到什么程度，渲染的失真变得可见？</p>
<p>练习3.9：编写一个Web服务器，它生成分形并将图像数据写人客户端。要让客户端得以通过HTTP请求的参数指定x、y值和放大系数。</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a><span style="color:#339AFF;">布尔值</span></h1><p>bool型的值或布尔值（boolean）只有两种可能：真（true）和假（false）。if和for语句里的条件就是布尔值，比较操作符（如==和《）也能得出布尔值结果。一元操作符（！）表示逻辑取反，因此！true就是false，或者可以说（！true-=false）==true。比如，考虑到代码风格，布尔表达式x==true相对冗长，我们总是简化为x。</p>
<p>布尔值可以由运算符&amp;&amp;（AND）以及|1（0R）组合运算，这可能引起短路行为：如果运算符左边的操作数已经能直接确定总体结果，则右边的操作数不会计算在内，所以下面的表达式是安全的：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s!=<span class="string">""</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">'x'</span></span><br></pre></td></tr></table></figure>
<p>其中，如果作用于空字符串，s[]会触发宕机异常。<br>因为&amp;较11优先级更高（助记窍门：&amp;&amp;表示逻辑乘法，11表示逻辑加法），所以如下形式的条件无须加圆括号：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'a'</span> &lt;=c&amp;&amp;c&lt;=<span class="string">'z'</span></span><br><span class="line"><span class="string">'A'</span>&lt;=c&amp;&amp;c&lt;=<span class="string">'z'</span>il</span><br><span class="line"><span class="string">'e'</span> &lt;=c&amp;&amp;c&lt;=<span class="string">"9"</span><span class="number">1</span></span><br><span class="line"><span class="comment">//...ASCII字母或数字</span></span><br></pre></td></tr></table></figure></p>
<p>布尔值无法隐式转换成数值（如0或1），反之也不行。如下状况下就有必要使用显式if：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i:=<span class="number">0</span></span><br><span class="line">ifb&#123;</span><br><span class="line">i=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>假如转换操作常常用到，就值得专门为此写个函数：//如果b为真，btoi返回1；如果b为假，则返回日<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">btoi</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">ifb&#123;</span><br><span class="line">return1</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>反向转换操作过于简单，无须专门撰写函数，但为了与btoi对应，这里还是给出其代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//itob报告i是否为非零值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itob</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> i !=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span style="color:#339AFF;">字符串</span></h1><p>字符串是不可变的字节序列，它可以包含任意数据，包括0值字节，但主要是人类可读的文本。习惯上，文本字符串被解读成按UTF-8编码的Unicode码点（文字符号）序列，稍后将细究相关内容。</p>
<p>内置的len函数返回字符串的字节数（并非文字符号的数目），下标访问操作s[i]则取得第i个字符，其中日《i《len（s）。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s:=<span class="string">"hello, world"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">//"12*</span></span><br><span class="line">fmt. Println(s[e],s[<span class="number">7</span>])<span class="comment">//"104 119" &lt;'h' and 'w')</span></span><br></pre></td></tr></table></figure>
<p>试图访问许可范围以外的字节会触发宕机异常：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c：=s[<span class="built_in">len</span>（s）]<span class="comment">//宕机：下标越界</span></span><br></pre></td></tr></table></figure></p>
<p>字符串的第i个字节不一定就是第i个字符，因为非ASCII字符的UTF-8码点需要两个字节或多个字节。稍后将讨论如何使用字符子串生成操作s[i：j]产生一个新字符串，内容取自原字符串的字节，下标从i（含边界值）开始，直到j（不含边界值）。结果的大小是j-i个字节。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt. Println(s[<span class="number">0</span>:<span class="number">5</span>])/<span class="number">1</span>/<span class="string">"hello"</span></span><br></pre></td></tr></table></figure></p>
<p>再次强调，若下标越界，或者j的值小于i，将触发宕机异常。</p>
<p>操作数i与j的默认值分别是e（字符串起始位置）和1en（s）（字符串终止位置），若省略i或j，或两者，则取默认值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s[:<span class="number">5</span>])<span class="comment">//"hello"</span></span><br><span class="line">fmt. Println(s[<span class="number">7</span>:])<span class="comment">//"world*</span></span><br><span class="line">fmt.Println(s[:])<span class="comment">//"hello, world"</span></span><br></pre></td></tr></table></figure></p>
<p>加号（+）运算符连接两个字符串而生成一个新字符串：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"goodbye"</span> + s[<span class="number">5</span>:])<span class="comment">//"goodbye, world"</span></span><br></pre></td></tr></table></figure></p>
<p>字符串可以通过比较运算符做比较，如==和《；比较运算按字节进行，结果服从本身的字典排序。</p>
<p>尽管肯定可以将新值赋予字符串变量，但是字符串值无法改变：字符串值本身所包含的字节序列永不可变。要在一个字符串后面添加另一个字符串，可以这样编写代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="string">"left foot'</span></span><br><span class="line"><span class="string">t:=s</span></span><br><span class="line"><span class="string">s+= "</span>, right foot<span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p>这并不改变s原有的字符串值，只是将+=语句生成的新字符串赋予s。同时，t仍然持有旧的字符串值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s)<span class="comment">// “left foot, right foot"</span></span><br><span class="line">fmt.Println(t)<span class="comment">// "left foot'</span></span><br></pre></td></tr></table></figure></p>
<p>因为字符串不可改变，所以字符串内部的数据不允许修改：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>]=<span class="string">'L'</span><span class="comment">//编译错误：s[]无法赋值</span></span><br></pre></td></tr></table></figure></p>
<p>不可变意味着两个字符串能安全地共用同一段底层内存，使得复制任何长度字符串的开销都低廉。类似地，字符串s及其子串（如s[7：]）可以安全地共用数据，因此子串生成操作的开销低廉。这两种情况下都没有分配新内存。图3-4展示了一个字符串及其两个子字符串的内存布局，它们共用底层字节数组。</p>
<blockquote>
<p>图3-4 字符串”hello，world”及其两个子字符串</p>
</blockquote>
<img src="/2021/07/16/第3章-基本数据/4.png">
<h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a><span style="color:#00ACC1;">字符串字面量</span></h2><p>字符串的值可以直接写成字符串字面量（string literal），形式上就是带双引号的字节序列：”Hello，世界”<br>因为Go的源文件总是按UTF-8编码，并且习惯上Go的字符串会按UTF-8解读，所以在源码中我们可以将Unicode码点写人字符串字面量。</p>
<p>在带双引号的字符串字面量中，转义序列以反斜杠（\）开始，可以将任意值的字节插人字符串中。下面是一组转义符，表示ASCII控制码，如换行符、回车符和制表符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\a “警告”或响铃</span><br><span class="line">\b 退格符</span><br><span class="line">\f 换页符</span><br><span class="line">\n换行符（指直接跳到下一行的同一位置）</span><br><span class="line">\r</span><br><span class="line">回车符（指返回行首）</span><br><span class="line">\t</span><br><span class="line">制表符</span><br><span class="line">\v</span><br><span class="line">垂直制表符</span><br><span class="line">\&apos;单引号（仅用于文字字符字面量八&quot;&quot;）</span><br><span class="line">\&quot; 双引号（仅用于“..”字面量内部，</span><br><span class="line">\\ 反斜杠</span><br></pre></td></tr></table></figure></p>
<p>源码中的字符串也可以包含十六进制或八进制的任意字节。十六进制的转义字符写成 \xhh的形式，h是十六进制数字（大小写皆可），且必须是两位。八进制的转义字符写成\ooo的形式，必须使用三位八进制数字（0~7），且不能超过\377。这两者都表示单个字节，内容是给定值。后面，我们将看到如何将数值形式的Unicode码点嵌人字符串字面量。</p>
<p>原生的字符串字面量的书写形式是..，使用反引号而不是双引号。原生的字符串字面量内，转义序列不起作用；实质内容与字面写法严格一致，包括反斜杠和换行符，因此，在程序源码中，原生的字符串字面量可以展开多行。唯一的特殊处理是回车符会被删除（换行符会保留），使得同一字符串在所有平台上的值都有相同，包括习惯在文本文件存人换行符的系统。</p>
<p>正则表达式往往含有大量反斜杠，可以方便地写成原生的字符串字面量。原生的字面量也适用于HTML模板、JSON字面量、命令行提示信息，以及需要多行文本表达的场景。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GoUsage = ‘Go is a tool <span class="keyword">for</span> managing Go source code.</span><br><span class="line">Usage:</span><br><span class="line"><span class="keyword">go</span> command [arguments]</span><br></pre></td></tr></table></figure></p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a><span style="color:#00ACC1;">Unicode</span></h2><p>从前，事情简单明晰，至少，狭隘地看，软件只须处理一个字符集：ASCII（美国信息交换标准码）。ASCII（或更确切地说，US-ASCII）码使用7位表示128个“字符”：大小写英文字母、数字、各种标点和设备控制符。这对早期的计算机行业已经足够了，但是让世界上众多使用其他语言的人无法在计算机上使用自己的文书体系。随着互联网的兴起，包含纷繁语言的数据屡见不鲜。到底怎样才能应付语言的繁杂多样，还能兼顾高效率？</p>
<p>答案是Unicode（unicode.org），它囊括了世界上所有文书体系的全部字符，还有重音符和其他变音符，控制码（如制表符和回车符），以及许多特有文字，对它们各自赋予一个叫Unicode码点的标准数字。在Go的术语中，这些字符记号称为文字符号（rune）。</p>
<p>Unicode第8版定义了超过一百种语言文字的12万个字符的码点。它们在计算机程序和数据中如何表示？天然适合保存单个文字符号的数据类型就是int32，为Go所采用；正因如此，rune类型作为int32类型的别名。</p>
<p>我们可以将文字符号的序列表示成int32值序列，这种表示方式称作UTF-32或UCS-4，每个Unicode码点的编码长度相同，都是32位。这种编码简单划一，可是因为大多数面向计算机的可读文本是ASCII码，每个字符只需8位，也就是1字节，导致了不必要的存储空间消耗。而使用广泛的字符的数目也少于65556个，字符用16位就能容纳。我们能作改进吗？</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><span style="color:#00ACC1;">UTF-8</span></h2><p>UTF-8以字节为单位对Unicode码点作变长编码。UTF-8是现行的一种Unicode标准，由Go的两位创建者Ken Thompson和Rob Pike发明。每个文字符号用1~4个字节表示，ASCII字符的编码仅占1个字节，而其他常用的文书字符的编码只是2或3个字节。一个文字符号编码的首字节的高位指明了后面还有多少字节。若最高位为0，则标示着它是7位的ASCII码，其文字符号的编码仅占1字节，这样就与传统的ASCII码一致。若最高几位是110，则文字符号的编码占用2个字节，第二个字节以10开始。更长的编码以此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxXx</span><br><span class="line">文字符号日~127</span><br><span class="line">(ASCII)</span><br><span class="line">110xxxxx10xxxxxx</span><br><span class="line">128~2047</span><br><span class="line">少于128个未使用的值</span><br><span class="line">1110XXXX10XXXXXX 10xxxxxx</span><br><span class="line">2048 ~65535</span><br><span class="line">少于2048个未使用的值</span><br><span class="line">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536 ~ 0x10ffff</span><br><span class="line">其他未使用的值</span><br></pre></td></tr></table></figure></p>
<p>变长编码的字符串无法按下标直接访问第n个字符，然而有失有得，UTF-8换来许多有用的特性。UTF-8编码紧凑，兼容ASCII，并且自同步：最多追溯3字节，就能定位一个字符的起始位置。UTF-8还是前缀编码，因此它能从左向右解码而不产生歧义，也无须超前预读。于是查找文字符号仅须搜索它自身的字节，不必考虑前文内容。文字符号的字典字节顺序与Unicode码点顺序一致（Unicode设计如此），因此按UTF-8编码排序自然就是对文字符号排序。UTF-8编码本身不会嵌人NUL字节（0值），这便于某些程序语言用NUL标记字符串结尾。</p>
<p>Go的源文件总是以UTF-8编码，同时，需要用Go程序操作的文本字符串也优先采用 UTF-8编码。unicode包具备针对单个文字符号的函数（例如区分字母和数字，转换大小写），而unicode/utf8包则提供了按UTF-8编码和解码文字符号的函数。</p>
<p>许多Unicode字符难以直接从键盘输入；有的看起来十分相似几乎无法分辨；有些甚至不可见。Go语言中，字符串字面量的转义让我们得以用码点的值来指明Unicode字符。有两种形式，\uhhhh表示16位码点值，\Uhhhhhhh表示32位码点值，其中每个h代表一个十六进制数字；32位形式的码点值几乎不需要用到。这两种形式都以UTF-8编码表示出给定的码点。因此，下面几个字符串字面量都表示长度为6字节的相同串：</p>
<p>后面三行的转义序列用不同形式表示第一行的字符串，但实质上它们的字符串值都一样。</p>
<p>Unicode转义符也能用于文字符号。下列字符是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;世’‘\u4e16&apos; &apos;\U00004e16&apos;</span><br></pre></td></tr></table></figure></p>
<p>码点值小于256的文字符号可以写成单个十六进制数转义的形式，如‘A’写成，\x41’；而更高的码点值则必须使用\u或\u转义。这就导致，”\xe4\xb8\x96’不是合法的文字符号，虽然这三个字节构成某个有效的UTF-8编码码点。</p>
<p>由于UTF-8的优良特性，许多字符串操作都无须解码。我们可以直接判断某个字符串是否为另一个的前缀：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)&gt;= <span class="built_in">len</span>(prefix)&amp;&amp; s[:<span class="built_in">len</span>(prefix)]== prefix</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>或者它是否为另一个字符串的后缀：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HasSuffix</span><span class="params">(s, suffix <span class="keyword">string</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)&gt;= <span class="built_in">len</span>(suffix)&amp;&amp; s[ien(s)-<span class="built_in">len</span>(suffix):]=suffix</span><br></pre></td></tr></table></figure></p>
<p>或者它是否为另一个的子字符串：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=;i&lt;<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line"><span class="keyword">if</span> HasPrefix(s[i:], substr)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按UTF-8编码的文本的逻辑同样也适用原生字节序列，但其他编码则无法如此。（上面的函数取自strings包，其实contains函数的具体实现使用了散列方法让搜索更高效。）</p>
<p>另一方面，如果我们真的要逐个逐个处理Unicode字符，则必须使用其他编码机制。考虑我们第一个例子的字符串（见3.5.1节），它包含两个东亚字符。图3-5说明了该字符串的内存布局。它含有13个字节，而按作UTF-8解读，本质是9个码点或文字符号的编码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"unicode/utf8'</span></span><br><span class="line"><span class="string">s：="</span>Hello，世界<span class="string">"</span></span><br><span class="line"><span class="string">fmt.Println(len(s))</span></span><br><span class="line"><span class="string">//"</span><span class="number">13</span><span class="string">" fmt. Println(utf8.RuneountInString(s))1/“9"</span></span><br></pre></td></tr></table></figure></p>
<p>我们需要UTF-8解码器来处理这些字符，unicode/utf8包就具备一个：</p>
<p>每次DecodeRuneInstring的调用都返回r（文字符号本身）和一个值（表示r按UTF-8编码所占用的字节数）。这个值用来更新下标i，定位字符串内的下一个文字符号。可是按此方法，我们总是需要使用上例中的循环形式。所幸，Go的range循环也适用于字符串，按UTF-8隐式解码。图3-5也展示了以下循环的输出。注意，对于非ASCII文字符号，下标增量大于1。</p>
<blockquote>
<p>图3-5 一个按UTF-8编码的字符串在range循环内解码</p>
</blockquote>
<img src="/2021/07/16/第3章-基本数据/5.png">
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i，r ：=<span class="keyword">range</span> <span class="string">"Hello，世界”&#123;</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%d\t%q\t%d\n<span class="string">",i,r,r)</span></span><br></pre></td></tr></table></figure>
<p>我们可用简单的range循环统计字符串中的文字符号数目，如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n:=<span class="number">0</span></span><br><span class="line">for_，</span><br><span class="line">= <span class="keyword">range</span> s &#123;</span><br><span class="line">n++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与其他形式的range循环一样，可以忽略没用的变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n:=e</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">n++</span><br></pre></td></tr></table></figure></p>
<p>或者，直截了当地调用utf8.RuneCountInString（s）。</p>
<p>之前提到过，文本字符串作为按UTF-8编码的Unicode码点序列解读，很大程度是出于习惯，但为了确保使用range循环能正确处理字符串，则必须要求而不仅仅是按照习惯。如果字符串含有任意二进制数，也就是说，UTF-8数据出错，而我们对它做range循环，会发生什么？</p>
<p>每次UTF-8解码器读人一个不合理的字节，无论是显式调用utf8.DecodeRuneInstring，还是在range循环内隐式读取，都会产生一个专门的Unicode字符’\FFFD’替换它，其输出通常是个黑色六角形或类似钻石的形状，里面有个白色问号。如果程序碰到这个文字符号值，通常意味着，生成字符串数据的系统上游部分在处理文本编码方面存在瑕疵。</p>
<p>UTF-8是一种分外便捷的交互格式，而在程序内部使用文字字符类型可能更加方便，因为它们大小一致，便于在数组和slice中用下标访问。</p>
<p>当[]rune转换作用于UTF-8编码的字符串时，返回该字符串的Unicode码点序列：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日语片假名"程序"</span></span><br><span class="line">s：=“行L<span class="string">"</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%x\n<span class="string">",s)// "</span>e3 <span class="number">83</span> <span class="number">97</span> e3 <span class="number">83</span> ad e3 <span class="number">82</span> b0 e3 <span class="number">83</span> a9 e3 <span class="number">83</span> a0<span class="string">"</span></span><br><span class="line"><span class="string">r:=[]rune(s)</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%x\n<span class="string">",r)//"</span>[<span class="number">30d</span>7 <span class="number">30</span>ed <span class="number">30</span>b0 <span class="number">30e9</span> <span class="number">30e0</span>]<span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>（第一个Printf里的谓词%x（注意，%和x之间有空格）以十六进制数形式输出，并在每两个数位间插人空格。）</p>
<p>如果把文字符号类型的slice转换成一个字符串，它会输出各个文字符号的UTF-8编码拼接结果：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（<span class="keyword">string</span>（r））<span class="number">11</span><span class="string">"J加少么"</span></span><br></pre></td></tr></table></figure></p>
<p>若将一个整数值转换成字符串，其值按文字符号类型解读，并且产生代表该文字符号值的UTF-8码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println（<span class="keyword">string</span>（ex4eac））/“京<span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>如果文字符号值非法，将被专门的替换字符取代（见前面的”\uFFFD’）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="keyword">string</span>(<span class="number">1234567</span>))<span class="number">11</span> “@</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串和字节slice"><a href="#字符串和字节slice" class="headerlink" title="字符串和字节slice"></a><span style="color:#00ACC1;">字符串和字节slice</span></h2><p>4个标准包对字符串操作特别重要：bytes、strings、strconv和unicode。</p>
<p>strings包提供了许多函数，用于搜索、替换、比较、修整、切分与连接字符串。</p>
<p>bytes包也有类似的函数，用于操作字节slice（[]byte类型，其某些属性和字符串相同）。由于字符串不可变，因此按增量方式构建字符串会导致多次内存分配和复制。这种情况下使用bytes.Buffer类型会更高效，范例见后。</p>
<p>strconv包具备的函数，主要用于转换布尔值、整数、浮点数为与之对应的字符串形式，或者把字符串转换为布尔值、整数、浮点数，另外还有为字符串添加/去除引号的函数。</p>
<p>unicode包备有判别文字符号值特性的函数，如IsDigit、IsLetter、IsUpper和IsLower。每个函数以单个文字符号值作为参数，并返回布尔值。若文字符号值是英文字母，转换函数（如Toupper和Tolower）将其转换成指定的大小写。上面所有函数都遵循Unicode标准对字母数字等的分类原则。strings包也有类似的函数，函数名也是ToUpper和Tolower，它们对原字符串的每个字符做指定变换，生成并返回一个新字符串。</p>
<p>下例中，basename函数模仿UNIX shell中的同名实用程序。只要s的前缀看起来像是文件系统路径（各部分由斜杠分隔），该版本的basename（s）就将其移除，貌似文件类型的后缀也被移除：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(basename(<span class="string">"a/b/c.go"</span>))<span class="comment">//"c"</span></span><br><span class="line">fmt.Println(basename(<span class="string">"c.d.go"</span>)) <span class="comment">// "c.d"</span></span><br><span class="line">fmt.Println(basename(<span class="string">"abc"</span>))</span><br><span class="line"><span class="comment">// "abc'</span></span><br></pre></td></tr></table></figure></p>
<p>初版的basename独自完成全部工作，并不依赖任何库：</p>
<p>path包和path/filapath包提供了一组更加普遍适用的函数，用来操作文件路径等具有层次结构的名字。path包处理以斜杠分段的路径字符串，不分平台。它不适合用于处理文件名，却适合其他领域，像URL地址的路径部分。相反地，path/filepath包根据宿主平台 （host platform）的规则处理文件名，例如POSIX系统使用/foo/bar，而Microsoft Windows 系统使用c：\foo\bar。</p>
<p>我们继续看另一个例子，它涉及子字符串操作。任务是接受一个表示整数的字符串，如”12345”，从右侧开始每三位数字后面就插人一个逗号，形如”12，345”。这个版本仅对整数有效。对浮点数的处理方式留作练习。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch3/comma</span><br><span class="line"><span class="comment">//函数向表示十进制非负整数的字符串中插入逗号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">comma</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">n :=<span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> n &lt;=<span class="number">3</span>&#123;</span><br><span class="line">returns</span><br><span class="line"><span class="keyword">return</span> comma(s[:n<span class="number">-3</span>])+<span class="string">","</span>+s[n<span class="number">-3</span>:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>comma函数的参数是一个字符串。若字符串长度小于等于3，则不插人逗号。否则，comma以仅包含字符串最后三个字符的子字符串作为参数，递归调用自己，最后在递归调用的结果后面添加一个逗号和最后三个字符。</p>
<p>若字符串包含一个字节数组，创建后它就无法改变。相反地，字节slice的元素允许随意修改。</p>
<p>字符串可以和字节slice相互转换：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s:=<span class="string">"abc</span></span><br><span class="line"><span class="string">b:=[]byte(s)</span></span><br><span class="line"><span class="string">s2 :=string(b)</span></span><br></pre></td></tr></table></figure></p>
<p>概念上，[]byte（s）转换操作会分配新的字节数组，拷贝填人s含有的字节，并生成一个slice引用，指向整个数组。具备优化功能的编译器在某些情况下可能会避免分配内存和复制内容，但一般而言，复制有必要确保s的字节维持不变（即使b的字节在转换后发生改变）。反之，用string（b）将字节slice转换成字符串也会产生一份副本，保证s2也不可变。</p>
<p>为了避免转换和不必要的内存分配，bytes包和strings包都预备了许多对应的实用函数（utility function），它们两两相对应。例如，strings包具备下面6个函数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(s, substr <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Count</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Fields</span><span class="params">(s <span class="keyword">string</span>)</span>[]<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Index</span><span class="params">(s,sep <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Join</span><span class="params">(a []<span class="keyword">string</span>, sep <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>bytes包里面的对应函数为：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Contains</span><span class="params">(b, subslice []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Count</span><span class="params">(s,sep[]<span class="keyword">byte</span>)</span><span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Fields</span><span class="params">(s[]<span class="keyword">byte</span>)</span> [] [] <span class="title">byte</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Join</span><span class="params">(s [][]<span class="keyword">byte</span>, sep [] <span class="keyword">byte</span>)</span> [] <span class="title">byte</span></span></span><br></pre></td></tr></table></figure></p>
<p>唯一的不同是，操作对象由字符串变为字节slice。</p>
<p>bytes包为高效处理字节slice提供了Buffer类型。Buffer起初为空，其大小随着各种类型数据的写人而增长，如string、byte和[]byte。如下例所示，bytes.Buffer变量无须初始化，原因是零值本来就有效：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch3/printints</span><br><span class="line"><span class="comment">// intsToString与fmt.Sprint（values）类似，但插入了逗号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intsToString</span><span class="params">(values []<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">buf WriteByte(<span class="string">'['</span>)</span><br><span class="line"><span class="keyword">for</span> i, v:=<span class="keyword">range</span> values &#123;</span><br><span class="line">ifi&gt;<span class="number">0</span>&#123;</span><br><span class="line">buf. Writestring(<span class="string">","</span>)</span><br><span class="line">fmt.Fprintf(&amp;buf,<span class="string">"%d"</span>，v)</span><br><span class="line">buf.WriteByte(<span class="string">']'</span>)</span><br><span class="line"><span class="keyword">return</span> buf.String()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt. Println(intsToString([]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;))<span class="number">1</span>/<span class="string">"[1，2,3]"</span></span><br></pre></td></tr></table></figure></p>
<p>若要在bytes.Buffer变量后面添加任意文字符号的UTF-8编码，最好使用bytes.Buffer的WriteRune方法，而追加ASCII字符，如’[‘和’]’，则使用WriteByte亦可。</p>
<p>bytes.Buffer类型用途极广，在第7章讨论接口的时候，假若I/O函数需要一个字节接收器（io.writer）或字节发生器（io.Reader），我们将看到能如何用其来代替文件，其中接收器的作用就如上例中的Fprintf一样。</p>
<p>练习3.10：编写一个非递归的comma函数，运用bytes.Buffer，而不是简单的字符串拼接。</p>
<p>练习3.11：增强comma函数的功能，让其正确处理浮点数，以及带有可选正负号的数字。</p>
<p>练习3.12：编写一个函数判断两个字符串是否同文异构，也就是，它们都含有相同的字符但排列顺序不同。</p>
<h2 id="字符串和数字的相互转换"><a href="#字符串和数字的相互转换" class="headerlink" title="字符串和数字的相互转换"></a><span style="color:#00ACC1;">字符串和数字的相互转换</span></h2><p>除了字符串、文字符号和字节之间的转换，我们常常也需要相互转换数值及其字符串表示形式。这由strconv包的函数完成。</p>
<p>要将整数转换成字符串，一种选择是使用fmt.Sprintf，另一种做法是用函数<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strconv.Itoa (“integer to ASCIl”):</span><br><span class="line">X:=<span class="number">123</span></span><br><span class="line">y :=fmt.Sprintf(<span class="string">"%d"</span>，x)</span><br><span class="line">fmt.Printin(y, strconv.Itoa(x))<span class="number">11</span><span class="string">"123 123'</span></span><br><span class="line"><span class="string">FormatInt和Formatuint可以按不同的进位制格式化数字：</span></span><br><span class="line"><span class="string">fmt.println(strconv.FormatInt(int64(x)，2))//“1111011</span></span><br></pre></td></tr></table></figure></p>
<p>fmt.Printf里的谓词%b、%d、%o和%x往往比Format函数方便，若要包含数字以外的附加信息，它就尤其有用：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=fmt.Sprintf(<span class="string">"x=%b"</span>,x)<span class="number">1</span>/ <span class="string">"x=1111011*</span></span><br></pre></td></tr></table></figure></p>
<p>strconv包内的Atoi函数或ParseInt函数用于解释表示整数的字符串，而ParseUint用于无符号整数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, err :=strconv.Atoi(<span class="string">"123"</span>)</span><br><span class="line"><span class="comment">//x是整型</span></span><br><span class="line">y，err ：=strconv.ParseInt（<span class="string">"123"</span>，<span class="number">10</span>，<span class="number">64</span>）<span class="comment">//十进制，最长为64位</span></span><br></pre></td></tr></table></figure></p>
<p>ParseInt的第三个参数指定结果必须匹配何种大小的整型例如，16表示int16，而0作为特殊值表示int。任何情况下，结果y的类型总是int64，可将他另外转换成较小的类型。</p>
<p>有时候，单行输人由字符串和数字依次混合构成，需要用fmt.Scanf解释，可惜fmt.Scanf也许不够灵活，处理不完整或不规则输入时尤甚。</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a><span style="color:#339AFF;">常量</span></h1><p>常量是一种表达式，其可以保证在编译阶段就计算出表达式的值，并不需要等到运行时，从而使编译器得以知晓其值。所有常量本质上都属于基本类型：布尔型、字符串或数字。</p>
<p>常量的声明定义了具名的值，它看起来在语法上与变量类似，但该值恒定，这防止了程序运行过程中的意外（或恶意）修改。例如，要表示数学常量，像圆周率，在Go程序中用常量比变量更适合，因其值恒定不变：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159</span><span class="comment">//近似数；math.Pi是更精准的近似</span></span><br></pre></td></tr></table></figure></p>
<p>与变量类似，同一个声明可以定义一系列常量，这适用于一组相关的值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">e= <span class="number">2.71828182845904523536028747135266249775724709369995957496696763</span> pi = <span class="number">3.14159265358979323846264338327950288419716939937510582097494459</span></span><br></pre></td></tr></table></figure></p>
<p>许多针对常量的计算完全可以在编译时就完成，以减免运行时的工作量并让其他编译器优化得以实现。某些错误通常要在运行时才能检测到，但如果操作数是常量，编译时就会报错，例如整数除以0，字符串下标越界，以及任何产生无限大值的浮点数运算。</p>
<p>对于常量操作数，所有数学运算、逻辑运算和比较运算的结果依然是常量，常量的类型转换结果和某些内置函数的返回值，例如len、cap、real、imag、complex和unsafe.sizeof，同样是常量。</p>
<p>因为编译器知晓其值，常量表达式可以出现在涉及类型的声明中，具体而言就是数组类型的长度：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> IPv4Len=<span class="number">4</span></span><br><span class="line"><span class="comment">// parseIPv4函数解释-个IPv4地址（d.d.d.d）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parselPv4</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">IP</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> p [IPv4Len]<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">了</span><br></pre></td></tr></table></figure></p>
<p>常量声明可以同时指定类型和值，如果没有显式指定类型，则类型根据右边的表达式推断。下例中，time.Duration是一种具名类型，其基本类型是int64，time.Minute也是基于int64的常量。下面声明的两个常量都属于time.Duration类型，通过%T展示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> noDelay time.Duration = o</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">5</span> * time.Minute</span><br><span class="line">fmt. Printf(<span class="string">"%T%[1]v\n"</span>, noDelay) <span class="comment">// "time.Duration 0"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T%[1]v\n"</span>, timeout) <span class="comment">// "time. Duration 5mes"</span></span><br><span class="line">fmt. Printf(<span class="string">"%T%[1]v\n"</span>, time.Minute) <span class="comment">// "time.Duration 1mes"</span></span><br></pre></td></tr></table></figure></p>
<p>若同时声明一组常量，除了第一项之外，其他项在等号右侧的表达式都可以省略，这意味着会复用前面一项的表达式及其类型。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b</span><br><span class="line">c=<span class="number">2</span></span><br><span class="line">d</span><br><span class="line">fmt.Println(a,b,c,d)/“<span class="number">1122</span></span><br></pre></td></tr></table></figure></p>
<p>如果复用右侧表达式导致计算结果总是相同，这就并不太实用。假若该结果可变该怎么办呢？我们来看看iota。</p>
<h2 id="常量生成器iota"><a href="#常量生成器iota" class="headerlink" title="常量生成器iota"></a><span style="color:#00ACC1;">常量生成器iota</span></h2><p>常量的声明可以使用常量生成器iota，它创建一系列相关值，而不是逐个值显式写出。常量声明中，iota从0开始取值，逐项加1。</p>
<p>下例取自time包，它定义了Weekday的具名类型，并声明每周的7天为该类型的常量，从Sunday开始，其值为0。这种类型通常称为枚举型（enumeration，或缩写成enum）。</p>
<p>上面的声明中，Sunday的值为0，Monday的值为1，以此类推。</p>
<p>更复杂的表达式也可使用iota，借用net包的代码举例如下，无符号整数最低5位数中的每一个都逐一命名，并解释为布尔值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags <span class="keyword">uint</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">FlagUp Flags = <span class="number">1</span> 《《 iota1/向上</span><br><span class="line">FlagBroadcast</span><br><span class="line"><span class="comment">//支持广播访问</span></span><br><span class="line">FlagLoopback</span><br><span class="line"><span class="comment">//是环回接口</span></span><br><span class="line">FlagPointToPoint</span><br><span class="line"><span class="comment">//属于点对点链路</span></span><br><span class="line">FlagMulticast</span><br><span class="line"><span class="comment">//支持多路广播访问</span></span><br></pre></td></tr></table></figure></p>
<p>随着iota递增，每个常量都按1《《iota赋值，这等价于2的连续次幂，它们分别与单个位对应。若某些函数要针对相应的位执行判定、设置或清除操作，就会用到这些常量。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch3/netflag</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsUp</span><span class="params">(v Flags)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> v&amp;FlagUp = FlagUp &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TurnDown</span><span class="params">(v*Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;*v&amp;^= FlagUp&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetBroadcast</span><span class="params">(v *lags)</span></span>&#123;*vl= FlagBroadcast &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsCast</span><span class="params">(v Flags)</span> <span class="title">bool</span>' <span class="title">i</span> <span class="title">return</span> <span class="title">v</span>&amp;<span class="params">(FlagBroadcast|FlagMulticast)</span>!=0&#125;</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> v Flags = FlagMulticast I Flagup</span><br><span class="line">fmt.Printf(<span class="string">"%b%t\n"</span>,v,IsUp(v))<span class="comment">//"10001 true"</span></span><br><span class="line">TurnDown(&amp;v)</span><br><span class="line">fmt.Printf(<span class="string">"%b%t\n"</span>,v,IsUp(v))<span class="number">11</span>“<span class="number">10000</span> <span class="literal">false</span><span class="string">"</span></span><br><span class="line"><span class="string">SetBroadcast(&amp;v)</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%b%t\n<span class="string">",v, IsUp(v))11"</span><span class="number">10010</span> <span class="literal">false</span><span class="string">"</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%b%t\n<span class="string">", v, IsCast(v))//"</span><span class="number">1</span>ee1e <span class="literal">true</span><span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>下例更复杂，声明的常量表示1024的幂。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>*<span class="literal">iota</span>)</span><br><span class="line">KiB <span class="comment">// 1024</span></span><br><span class="line">MiB <span class="comment">// 1048576</span></span><br><span class="line">GiB<span class="comment">// 1073741824</span></span><br><span class="line">TiB <span class="comment">// 1099511627776</span></span><br><span class="line">（超过<span class="number">1</span>《《<span class="number">32</span>）</span><br><span class="line">PiB <span class="number">1</span>/ <span class="number">1125899906842624</span></span><br><span class="line">EiB<span class="comment">// 1152921504606846976</span></span><br><span class="line">ZiB1/<span class="number">1180591620717411303424</span></span><br><span class="line">（超过<span class="number">1</span>《《<span class="number">64</span>）</span><br><span class="line">YiB <span class="number">1</span>/ <span class="number">1208925819614629174706176</span></span><br></pre></td></tr></table></figure></p>
<p>const(</p>
<p>然而，iota机制存在局限。比如，因为不存在指数运算符，所以无从生成更为人熟知的1000的幂（KB、MB等）。</p>
<p>练习3.13：用尽可能简洁的方法声明从KB、MB直到YB的常量。</p>
<h2 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a><span style="color:#00ACC1;">无类型常量</span></h2><p>Go的常量自有特别之处。虽然常量可以是任何基本数据类型，如int或float64，也包括具名的基本类型（如time.Duration），但是许多常量并不从属某一具体类型。编译器将这些从属类型待定的常量表示成某些值，这些值比基本类型的数字精度更高，且算术精度高于原生的机器精度。可以认为它们的精度至少达到256位。从属类型待定的常量共有6种，分别是无类型布尔、无类型整数、无类型文字符号、无类型浮点数、无类型复数、无类型字符串。</p>
<p>借助推迟确定从属类型，无类型常量不仅能暂时维持更高的精度，与类型已确定的常量相比，它们还能写进更多表达式而无需转换类型。比如，上例中ZiB和YiB的值过大，用哪种整型都无法存储，但它们都是合法常量并且可以用在下面的表达式中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt. Println(YiB/ZiB)<span class="comment">//"1024"</span></span><br></pre></td></tr></table></figure></p>
<p>再例如，浮点型常量math.Pi可用于任何需要浮点值或复数的地方：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xfloat32=math.Pi</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span>= math.Pi</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span>= math.Pi</span><br></pre></td></tr></table></figure></p>
<p>若常量math.Pi一开始就确定从属于某具体类型，如float64，就会导致结果的精度下降。另外，假使最终需要float32值或complex128值，则可能需要转换类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi64float64 =math.Pi</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">float32</span> = <span class="keyword">float32</span>(Pi64)</span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">float64</span> = Pi64</span><br><span class="line"><span class="keyword">var</span> z <span class="keyword">complex128</span>= <span class="keyword">complex128</span>(Pi64)</span><br></pre></td></tr></table></figure></p>
<p>字面量的类型由语法决定。0、0.0、0i和’\u800e’全都表示相同的常量值，但类型相异，分别是：无类型整数、无类型浮点数、无类型复数和无类型文字符号。类似地，true和false是无类型布尔值，而字符串字面量则是无类型字符串。</p>
<p>根据除法运算中操作数的类型，除法运算的结果可能是整型或浮点型。所以，常量除法表达式中，操作数选择不同的字面写法会影响结果：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> =<span class="number">212</span></span><br><span class="line">fmt.Println((f<span class="number">-32</span>)* <span class="number">5</span> <span class="number">1</span> <span class="number">9</span>)</span><br><span class="line"><span class="comment">//"100"；（f-32）*5的结果是float64型</span></span><br><span class="line">fmt.Println(<span class="number">5</span>/<span class="number">9</span>*(f<span class="number">-32</span>))</span><br><span class="line"><span class="comment">//"8"；5/9的结果是无类型整数，8</span></span><br><span class="line">fmt.Println（<span class="number">5.8</span>/<span class="number">9.0</span>* （f<span class="number">-32</span>））<span class="comment">// "100"；5.0/9.0的结果是无类型浮点数</span></span><br></pre></td></tr></table></figure></p>
<p>只有常量才可以是无类型的。若将无类型常量声明为变量（如下面的第一条语句所示），或在类型明确的变量赋值的右方出现无类型常量（如下面的其他三条语句所示），则常量会被隐式转换成该变量的类型。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span>=<span class="number">3</span>+<span class="number">0i</span><span class="comment">//无类型复数-》float64</span></span><br><span class="line">f=<span class="number">2</span></span><br><span class="line"><span class="comment">//无类型整数-》float64</span></span><br><span class="line">f=<span class="number">1e123</span></span><br><span class="line"><span class="comment">//无类型浮点数-》float64</span></span><br><span class="line">f=<span class="string">'a'</span></span><br><span class="line"><span class="comment">//无类型-》float64</span></span><br></pre></td></tr></table></figure></p>
<p>上述语句与下面的语句等价：</p>
<p>不论隐式或显式，常量从一种类型转换成另一种，都要求目标类型能够表示原值。实数和复数允许舍人取整：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">deadbeef = exdeadbeef <span class="comment">//无类型整数，值为3735928559</span></span><br><span class="line">a = <span class="keyword">uint32</span>（deadbeef）<span class="comment">//uint32，值为3735928559</span></span><br><span class="line">b =<span class="keyword">float32</span>（deadbeef） <span class="comment">// float32，值为3735928576（向上取整，</span></span><br><span class="line">c= <span class="keyword">float64</span>（deadbeef）<span class="comment">// float64，值为3735928559（精确值）</span></span><br><span class="line">d = <span class="keyword">int32</span>（deadbeef）<span class="comment">//编译错误：溢出，int32无法容纳常量值</span></span><br><span class="line">e= <span class="keyword">float64</span>（<span class="number">1e309</span>）<span class="comment">//编译错误溢出，float64无法容纳常量值</span></span><br><span class="line">f=<span class="keyword">uint</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">//编译错误：溢出，uint无法容纳常量值</span></span><br></pre></td></tr></table></figure></p>
<p>变量声明（包括短变量声明）中，假如没有显式指定类型，无类型常量会隐式转换成该变量的默认类型，如下例所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i:=<span class="number">0</span></span><br><span class="line"><span class="comment">//无类型整数；隐式int（e）</span></span><br><span class="line">r:。<span class="string">"000'// 无类型文字字符；隐式rune（'\800'）</span></span><br><span class="line"><span class="string">f:=0.0</span></span><br><span class="line"><span class="string">//无类型浮点数；隐式float64（0.0）</span></span><br><span class="line"><span class="string">c:=0i</span></span><br><span class="line"><span class="string">//无类型整数；隐式complex128（0i）</span></span><br></pre></td></tr></table></figure></p>
<p>注意各类型的不对称性无类型整数可以转换成int，其大小不确定，但无类型浮点数和无类型复数被转换成大小明确的float64和complex128。Go语言中，只有大小不明确的int类型，却不存在大小不确定的float类型和complex类型，原因是，如果浮点型数据的大小不明，就很难写出正确的数值算法。</p>
<p>要将变量转换成不同的类型，我们必须将无类型常量显式转换为期望的类型，或在声明变量时指明想要的类型，如下例所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="keyword">int8</span>(<span class="number">0</span>)</span><br><span class="line">vari <span class="keyword">int8</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>在将无类型常量转换为接口值时（见第7章），这些默认类型就分外重要，因为它们决定了接口值的动态类型。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// "int'</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>，<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// "float64'</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,<span class="number">8i</span>)</span><br><span class="line"><span class="comment">// "complex128"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,<span class="string">'\000'</span>) <span class="number">1</span>/ <span class="string">"int32"</span> (<span class="keyword">rune</span>)</span><br></pre></td></tr></table></figure></p>
<p>至此，我们已经概述了Go的基本数据类型。下一步就是要说明如何将它们构建成为更大的聚合体，如数组和结构体，更进一步组成数据结构以解决实际的编程问题。第4章以此为主题。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go程序设计语言/" rel="tag"># Go程序设计语言</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/15/第2章-程序结构-1/" rel="next" title="第2章 程序结构">
                <i class="fa fa-chevron-left"></i> 第2章 程序结构
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/18/第4章-复合数据类型/" rel="prev" title="第4章 复合数据类型">
                第4章 复合数据类型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">放弃会成为一种习惯</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">439</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2021/12/21/34｜业务开发（下）：问答业务开发/" title="34｜业务开发（下）：问答业务开发" target="_blank">34｜业务开发（下）：问答业务开发</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/21/33｜业务开发（上）：问答业务开发/" title="33｜业务开发（上）：问答业务开发" target="_blank">33｜业务开发（上）：问答业务开发</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/21/32｜通用模块（下）：用户模块开发/" title="32｜通用模块（下）：用户模块开发" target="_blank">32｜通用模块（下）：用户模块开发</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/21/31｜通用模块（上）：用户模块开发/" title="31｜通用模块（上）：用户模块开发" target="_blank">31｜通用模块（上）：用户模块开发</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/21/30｜设计先于实战：需求设计和框架搭建/" title="30｜设计先于实战：需求设计和框架搭建" target="_blank">30｜设计先于实战：需求设计和框架搭建</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#整数"><span class="nav-number">1.</span> <span class="nav-text">整数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#浮点数"><span class="nav-number">2.</span> <span class="nav-text">浮点数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#复数"><span class="nav-number">3.</span> <span class="nav-text">复数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#布尔值"><span class="nav-number">4.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串字面量"><span class="nav-number">5.1.</span> <span class="nav-text">字符串字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicode"><span class="nav-number">5.2.</span> <span class="nav-text">Unicode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UTF-8"><span class="nav-number">5.3.</span> <span class="nav-text">UTF-8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和字节slice"><span class="nav-number">5.4.</span> <span class="nav-text">字符串和字节slice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和数字的相互转换"><span class="nav-number">5.5.</span> <span class="nav-text">字符串和数字的相互转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常量"><span class="nav-number">6.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常量生成器iota"><span class="nav-number">6.1.</span> <span class="nav-text">常量生成器iota</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无类型常量"><span class="nav-number">6.2.</span> <span class="nav-text">无类型常量</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">4.1m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">61:25</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
