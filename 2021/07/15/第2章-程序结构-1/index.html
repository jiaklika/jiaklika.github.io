<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go程序设计语言">
<meta property="og:type" content="article">
<meta property="og:title" content="第2章 程序结构">
<meta property="og:url" content="http://yoursite.com/2021/07/15/第2章-程序结构-1/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/07/15/第2章-程序结构-1/0-1.png">
<meta property="og:image" content="http://yoursite.com/2021/07/15/第2章-程序结构-1/0-2.png">
<meta property="og:updated_time" content="2021-09-24T06:41:16.488Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第2章 程序结构">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="twitter:image" content="http://yoursite.com/2021/07/15/第2章-程序结构-1/0-1.png">






  <link rel="canonical" href="http://yoursite.com/2021/07/15/第2章-程序结构-1/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第2章 程序结构 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">坚持就是胜利</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/15/第2章-程序结构-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="学如逆水行舟，不进则退">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第2章 程序结构

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-07-15 19:26:48" itemprop="dateCreated datePublished" datetime="2021-07-15T19:26:48+08:00">2021-07-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-09-24 14:41:16" itemprop="dateModified" datetime="2021-09-24T14:41:16+08:00">2021-09-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">21k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">19 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>与其他编程语言一样，Go语言中的大程序都从小的基本组件构建而来：变量存储值；简单表达式通过加和减等操作合并成大的；基本类型通过数组和结构体进行聚合；表达式通过if和for等控制语句来决定执行顺序；语句被组织成函数用于隔离和复用；函数被组织成源文件和包。</p>
<p>上面这些内容中的大部分已在前一章介绍过，本章将更细致地讨论Go程序中的基本结构元素。示例程序有意进行了简化，这有助于聚焦于语言本身而不是复杂的算法和数据结构。</p>
<h1 id="名称"><a href="#名称" class="headerlink" title="名称"></a><span style="color:#339AFF;">名称</span></h1><p>Go中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母（Unicode中的字符即可）或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。如heapSort和Heapsort是不同的名称。</p>
<p>Go有25个像if和switch这样的关键字，只能用在语法允许的地方，它们不能作为名称：</p>
<img src="/2021/07/15/第2章-程序结构-1/0-1.png">
<p>另外，还有三十几个内置的预声明的常量、类型和函数：</p>
<img src="/2021/07/15/第2章-程序结构-1/0-2.png">
<p>这些名称不是预留的，可以在声明中使用它们。我们将在很多地方看到对其中的名称进行重声明，但是要知道这有冲突的风险。</p>
<p>如果一个实体在函数中声明，它只在函数局部有效。如果声明在函数外，它将对包里面的所有源文件可见。实体第一个字母的大小写决定其可见性是否跨包。如果名称以大写字母的开头，它是导出的，意味着它对包外是可见和可访问的，可以被自己包之外的其他程序所引用，像fmt包中的Printf。包名本身总是由小写字母组成。</p>
<p>名称本身没有长度限制，但是习惯以及Go的编程风格倾向于使用短名称，特别是作用域较小的局部变量，你更喜欢看到一个变量叫i而不是theLoopIndex。通常，名称的作用域越大，就使用越长且更有意义的名称。</p>
<p>风格上，当遇到由单词组合的名称时，Go程序员使用“驼峰式”的风格——更喜欢使用大写字母而不是下划线。所以标准库中的函数名采用QuoteRuneToASCII和parseRequestLine的形式，而不会采用quote_rune_to_ASCII或parse_request_line这样的形式。像ASCII和HTML这样的首字母缩写词通常使用相同的大小写，所以一个函数可以叫作htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a><span style="color:#339AFF;">声明</span></h1><p>声明给一个程序实体命名，并且设定其部分或全部属性。有4个主要的声明：变量（var）、常量（const）、类型（type）和函数（func）。本章讨论变量和类型，常量放在第3章讨论，函数放在第5章讨论。</p>
<p>Go程序存储在一个或多个以.go为后缀的文件里。每一个文件以package声明开头，表明文件属于哪个包。package声明后面是import声明，然后是包级别的类型、变量、常量、函数的声明，不区分顺序。例如，下面的程序声明一个常量、一个函数和一对变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boiling输出水的沸点</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boilingF = <span class="number">212.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> f = boilingF</span><br><span class="line">    <span class="keyword">var</span> c = (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">    fmt.Printf(<span class="string">"boiling point = %g°F or %g°C\n"</span>, f, c)</span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// boiling point = 212°F or 100°C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>常量boilingF是一个包级别的声明（main包），f和c是属于main函数的局部变量。包级别的实体名字不仅对于包含其声明的源文件可见，而且对于同一个包里面的所有源文件都可见。另一方面，局部声明仅仅是在声明所在的函数内部可见，并且可能对于函数中的一小块区域可见。</p>
<p>函数的声明包含一个名字、一个参数列表（由函数的调用者提供的变量）、一个可选的返回值列表，以及函数体（其中包含具体逻辑语句）。如果函数不返回任何内容，返回值列表可以省略。函数的执行从第一个语句开始，直到遇到一个返回语句，或者执行到无返回结果的函数的结尾。然后程序控制和返回值（如果有的话）都返回给调用者。</p>
<p>我们已经看过许多函数，将来还会遇见更多，在第5章有更广泛的讨论，因此这里仅仅是一个概括。下面的函数fToC封装了温度转换的逻辑，这样它可以只定义一次而在多个地方使用。这里main调用了它两次，使用两个不同的局部常量的值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ftoc输出两个华式温度—摄氏温度的转换</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> freezingF, boilingF = <span class="number">32.0</span>, <span class="number">212.0</span></span><br><span class="line">    fmt.Printf(<span class="string">"%g°F = %g°C\n"</span>, freezingF, fToC(freezingF)) <span class="comment">// "32°F = 0°C"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%g°F = %g°C\n"</span>, boilingF, fToC(boilingF))   <span class="comment">// "212°F = 100°C"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fToC</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a><span style="color:#339AFF;">变量</span></h1><p>var声明创建一个具体类型的变量，然后给它附加一个名字，设置它的初始值。每一个声明有一个通用的形式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> = expression</span><br></pre></td></tr></table></figure></p>
<p>类型和表达式部分可以省略一个，但是不能都省略。如果类型省略，它的类型将由初始化表达式决定；如果表达式省略，其初始值对应于类型的零值——对于数字是0，对于布尔值是false，对于字符串是“”，对于接口和引用类型（slice、指针、map、通道、函数）是nil。对于一个像数组或结构体这样的复合类型，零值是其所有元素或成员的零值。</p>
<p>零值机制保障所有的变量是良好定义的，Go里面不存在未初始化变量。这种机制简化了代码，并且不需要额外工作就能感知边界条件的行为。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Println(s) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure></p>
<p>输出空字符串，而不是一些错误或不可预料的行为。Go程序员经常花费精力来使复杂类型的零值有意义，以便变量一开始就处于一个可用状态。</p>
<p>可以声明一个变量列表，并选择使用对应的表达式列表对其初始化。忽略类型允许声明多个不同类型的变量。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="keyword">int</span>                 <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">"four"</span> <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure></p>
<p>初始值设定可以是字面量值或者任意的表达式。包级别的初始化在main开始之前进行（参考2.6.2节），局部变量初始化和声明一样在函数执行期间进行。</p>
<p>变量可以通过调用返回多个值的函数进行初始化：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f, err = os.Open(name) <span class="comment">// os.Open返回一个文件和一个错误</span></span><br></pre></td></tr></table></figure></p>
<h2 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a><span style="color:#00ACC1;">短变量声明</span></h2><p>在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量。它使用name:=expression的形式，name的类型由expression的类型决定。这里是lissajous函数（参考1.4节）中的三个短变量声明：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class="line">freq := rand.Float64() * <span class="number">3.0</span></span><br><span class="line">t := <span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>因其短小、灵活，故而在局部变量的声明和初始化中主要使用短声明。var声明通常是为那些跟初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">100</span>                   <span class="comment">// 一个int类型的变量</span></span><br><span class="line"><span class="keyword">var</span> boiling <span class="keyword">float64</span> = <span class="number">100</span>  <span class="comment">// 一个float64类型的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> p Point</span><br></pre></td></tr></table></figure></p>
<p>与var声明一样，多个变量可以以短变量声明的方式声明和初始化：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>只有当它们对于可读性有帮助的时候才使用多个初始化表达式来进行变量声明，例如短小且天然一组的for循环的初始化。</p>
<p>记住，:=表示声明，而=表示赋值。一个多变量的声明不能和多重赋值（参考2.4.1节）搞混，后者将右边的值赋给左边的对应变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, j = j, i <span class="comment">// 交换i和j的值</span></span><br></pre></td></tr></table></figure></p>
<p>与普通的var声明类似，短变量声明也可以用来调用像os.Open那样返回两个或多个值的函数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...使用f...</span></span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure></p>
<p>一个容易被忽略但重要的地方是：短变量声明不需要声明所有在左边的变量。如果一些变量在同一个词法块中声明（参考2.7节），那么对于那些变量，短声明的行为等同于赋值。</p>
<p>在如下代码中，第一条语句声明了in和err。第二条语句仅声明了out，但向已有的err变量赋了值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">out, err := os.Create(outfile)</span><br></pre></td></tr></table></figure></p>
<p>短变量声明最少声明一个新变量，否则，代码编译将无法通过：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err_:= os.Open(infile)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">f, err := os.Create(outfile) <span class="comment">// 编译错误：没有新的变量</span></span><br></pre></td></tr></table></figure></p>
<p>第二个语句使用普通的赋值语句来修复这个错误。</p>
<p>只有在同一个词法块中已经存在变量的情况下，短声明的行为才和赋值操作一样，外层的声明将被忽略。我们在本章结尾的例子中将看到。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a><span style="color:#00ACC1;">指针</span></h2><p>变量是存储值的地方。借助声明创建的变量使用名字来区分，例如x，但是许多变量仅仅使用像x[i]或者x.f这样的表达式来区分。所有这些表达式读取一个变量的值，除非它们出现在赋值操作符的左边，这个时候是给变量赋值。</p>
<p>指针的值是一个变量的地址。一个指针指示值所保存的位置。不是所有的值都有地址，但是所有的变量都有。使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值。</p>
<p>如果一个变量声明为var x int，表达式&amp;x（x的地址）获取一个指向整型变量的指针，它的类型是整型指针（*int）。如果值叫作p，我们说p指向x，或者p包含x的地址。p指向的变量写成*p。表达式*p获取变量的值，一个整型，因为*p代表一个变量，所以它也可以出现在赋值操作符左边，用于更新变量的值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x         <span class="comment">// p是整型指针，指向x</span></span><br><span class="line">fmt.Println(*p) <span class="comment">// "1"</span></span><br><span class="line">*p = <span class="number">2</span>          <span class="comment">// 等于x=2</span></span><br><span class="line">fmt.Println(x)  <span class="comment">// 结果"2"</span></span><br></pre></td></tr></table></figure></p>
<p>每一个聚合类型变量的组成（结构体的成员或数组中的元素）都是变量，所以也有一个地址。</p>
<p>变量有时候使用一个地址化的值。代表变量的表达式，是唯一可以应用取地址操作符&amp;的表达式。</p>
<p>指针类型的零值是nil。测试p!=nil，结果是true说明p指向一个变量。指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是nil的情况下才相等。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line">fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="literal">nil</span>) <span class="comment">// "true false false"</span></span><br></pre></td></tr></table></figure></p>
<p>函数返回局部变量的地址是非常安全的。例如下面的代码中，通过调用f产生的局部变量v即使在调用返回后依然存在，指针p依然引用它：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = f()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    v := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次调用f都会返回一个不同的值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(f()==f()) <span class="comment">// "false"</span></span><br></pre></td></tr></table></figure></p>
<p>因为一个指针包含变量的地址，所以传递一个指针参数给函数，能够让函数更新间接传递的变量值。例如，这个函数递增一个指针参数所指向的变量，然后返回此变量的新值，于是它可以在表达式中使用：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    *p++ <span class="comment">// 递增p所指向的值；p自身保持不变</span></span><br><span class="line">    <span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line">v := <span class="number">1</span></span><br><span class="line">incr(&amp;v)</span><br><span class="line"><span class="comment">//副作用：v现在等于2</span></span><br><span class="line">fmt.Println(incr(&amp;v) <span class="comment">// "3"（v现在是3）</span></span><br></pre></td></tr></table></figure></p>
<p>每次使用变量的地址或者复制一个指针，我们就创建了新的别名或者方式来标记同一变量。例如，*p是v的别名。指针别名允许我们不用变量的名字来访问变量，这一点是非常有用的，但是它是双刃剑：为了找到所有访问变量的语句，需要知道所有的别名。不仅指针产生别名，当复制其他引用类型（像slice、map、通道，甚至包含这里引用类型的结构体、数组和接口）的值的时候，也会产生别名。</p>
<p>指针对于flag包是很关键的，它使用程序的命令行参数来设置整个程序内某些变量的值。为了说明，下面这个变种的echo命令使用两个可选的标识参数：-n使echo忽略正常输出时结尾的换行符，-s sep使用sep替换默认参数输出时使用的空格分隔符。因为这是第4版，所以包名字叫作gopl.io/ch2/echo4。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch2/echo4</span></span><br><span class="line"><span class="comment">// echo4输出其命令行参数</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = flag.Bool(<span class="string">"n"</span>, <span class="literal">false</span>, <span class="string">"omit trailing newline"</span>)</span><br><span class="line"><span class="keyword">var</span> sep = flag.String(<span class="string">"s"</span>, <span class="string">" "</span>, <span class="string">"separator"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Print(strings.Join(flag.Args(), *sep))</span><br><span class="line">    <span class="keyword">if</span> !*n &#123;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flag.Bool函数创建一个新的布尔标识变量。它有三个参数：标识的名字（”n”），变量的默认值（false），以及当用户提供非法标识、非法参数抑或-h或-help参数时输出的消息。同样地，flag.string也使用名字、默认值和消息来创建一个字符串变量。变量sep和n是指向标识变量的指针，它们必须通过*sep和*n来访问。</p>
<p>当程序运行时，在使用标识前，必须调用flag.Parse来更新标识变量的默认值。非标识参数也可以从flag.Args()返回的字符串slice来访问。如果flag.Parse遇到错误，它输出一条帮助消息，然后调用os.Exit(2)来结束程序。</p>
<p>让我们运行一些echo测试用例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch2/echo4</span><br><span class="line">$ ./echo4 a bc def</span><br><span class="line">a bc def</span><br><span class="line">$ ./echo4 -s / a bc def</span><br><span class="line">a/bc/def</span><br><span class="line">$ ./echo4 -n a bc def</span><br><span class="line">a bc def$</span><br><span class="line">$ ./echo4 -<span class="built_in">help</span></span><br><span class="line">Usage of ./echo4:</span><br><span class="line">    -n omit trailing newline</span><br><span class="line">    -s string</span><br><span class="line">        separator(default <span class="string">" "</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a><span style="color:#00ACC1;">new函数</span></h2><p>另外一种创建变量的方式是使用内置的new函数。表达式new(T)创建一个未命名的T类型变量，初始化为T类型的零值，并返回其地址（地址类型为*奸）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p：=<span class="built_in">new</span>（<span class="keyword">int</span>）<span class="comment">//*int类型的p，指向未命名的int变量</span></span><br><span class="line">fmt.Println（*p）<span class="comment">//输出"8"</span></span><br><span class="line">*p=<span class="number">2</span></span><br><span class="line"><span class="comment">//把未命名的int设置为2</span></span><br><span class="line">fmt.Println（*p）<span class="comment">//输出“2’</span></span><br></pre></td></tr></table></figure></p>
<p>使用new创建的变量和取其地址的普通局部变量没有什么不同，只是不需要引人（和声明）一个虚拟的名字，通过new（T）就可以直接在表达式中使用。因此new只是语法上的便利，不是一个基础概念。</p>
<p>下面两个newInt函数有同样的行为。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span> *<span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> dummy <span class="keyword">int</span></span><br><span class="line"><span class="keyword">return</span> &amp;dummy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一次调用new返回一个具有唯一地址的不同变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p:=<span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">q :=<span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(p==q)<span class="number">11</span> <span class="string">"false"</span></span><br></pre></td></tr></table></figure></p>
<p>这个规则有一个例外：两个变量的类型不携带任何信息且是零值，例如struct{}或[e]int，当前的实现里面，它们有相同的地址。</p>
<p>因为最常见的未命名变量都是结构体类型，它的语法（参考4.4.1节）比较复杂，所以new函数使用得相对较少，new是一个预声明的函数，不是一个关键字，所以它可以重定义为另外的其他类型，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delta</span><span class="params">(old, newint)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>-old&#125;</span><br></pre></td></tr></table></figure></p>
<p>自然，在delta函数内，内置的new函数是不可用的。</p>
<h2 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a><span style="color:#00ACC1;">变量的生命周期</span></h2><p>生命周期指在程序执行过程中变量存在的时间段。包级别变量的生命周期是整个程序的执行时间。相反，局部变量有一个动态的生命周期：每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。函数的参数和返回值也是局部变量，它们在其闭包函数被调用的时候创建。</p>
<p>例如，在1.4节中的lissajous示例程序中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t:= <span class="number">0.</span>e;t&lt;cycles*<span class="number">2</span>*math.Pi;t+= res&#123;</span><br><span class="line">x :=math.Sin(t)</span><br><span class="line">y :=math.sin(t*freq + phase)</span><br><span class="line">img.setcolorIndex(size+<span class="keyword">int</span>(x*size+e<span class="number">.5</span>),size+<span class="keyword">int</span>(y*size+<span class="number">0.5</span>),</span><br><span class="line">blackIndex)</span><br></pre></td></tr></table></figure></p>
<p>变量t在每次for循环的开始创建，变量x和y在循环的每次迭代中创建。</p>
<p>那么垃圾回收器如何知道一个变量是否应该被回收？说来话长，基本思路是每一个包级别的变量，以及每一个当前执行函数的局部变量，可以作为追溯该变量的路径的源头，通过指针和其他方式的引用可以找到变量。如果变量的路径不存在，那么变量变得不可访问，因此它不会影响任何其他的计算过程。</p>
<p>因为变量的生命周期是通过它是否可达来确定的，所以局部变量可在包含它的循环的一次迭代之外继续存活。即使包含它的循环已经返回，它的存在还可能延续。</p>
<p>编译器可以选择使用堆或栈上的空间来分配，令人惊奇的是，这个选择不是基于使用var或new关键字来声明变量。</p>
<p>这里，x一定使用堆空间，因为它在f函数返回以后还可以从global变量访问，尽管它被声明为一个局部变量。这种情况我们说x从f中逃逸。相反，当g函数返回时，变量<em>y变得不可访问，可回收。因为</em>y没有从g中逃逸，所以编译器可以安全地在栈上分配*y，即便使用new函数创建它。任何情况下，逃逸的概念使你不需要额外费心来写正确的代码，但要记住它在性能优化的时候是有好处的，因为每一次变量逃逸都需要一次额外的内存分配过程。</p>
<p>垃圾回收对于写出正确的程序有巨大的帮助，但是免不了考虑内存的负担。不需要显式分配和释放内存，但是变量的生命周期是写出高效程序所必需清楚的。例如，在长生命周期对象中保持短生命周期对象不必要的指针，特别是在全局变量中，会阻止垃圾回收器回收短生命周期的对象空间。</p>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a><span style="color:#339AFF;">赋值</span></h1><p>赋值语句用来更新变量所指的值，它最简单的形式由赋值符=，以及符号左边的变量和右边的表达式组成。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X=<span class="number">1</span></span><br><span class="line"><span class="comment">//有名称的变量</span></span><br><span class="line">*p= <span class="literal">true</span></span><br><span class="line"><span class="comment">//间接变量</span></span><br><span class="line">person.name = <span class="string">"bob"</span></span><br><span class="line"><span class="comment">//结构体成员</span></span><br><span class="line">count[x] = count[x] * scale<span class="comment">//数组或slice或map的元素</span></span><br></pre></td></tr></table></figure></p>
<p>每一个算术和二进制位操作符有一个对应的赋值操作符，例如，最后的那个语句可以重写成：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count[x]*= scale</span><br></pre></td></tr></table></figure></p>
<p>它避免了在表达式中重复变量本身。</p>
<p>数字变量也可以通过++和一语句进行递增和递减：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v:=<span class="number">1</span></span><br><span class="line">V++</span><br><span class="line"><span class="comment">//等同于v=V+1；v变成2</span></span><br><span class="line">v.</span><br><span class="line"><span class="comment">//等同于v=v-1；v变成1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="多重赋值"><a href="#多重赋值" class="headerlink" title="多重赋值"></a><span style="color:#00ACC1;">多重赋值</span></h2><p>另一种形式的赋值是多重赋值，它允许几个变量一次性被赋值。在实际更新变量前，右边所有的表达式被推演，当变量同时出现在赋值符两侧的时候这种形式特别有用，例如，当交换两个变量的值时：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X,y=y,X</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure></p>
<p>或者计算两个整数的最大公约数：</p>
<p>或者计算斐波那契数列的第n个数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(nint)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">x,y:=<span class="number">0</span>，<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123; x,y=y,x+y</span><br><span class="line">returnx</span><br></pre></td></tr></table></figure></p>
<p>多重赋值也可以使一个普通的赋值序列变得紧凑：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i，j，k=<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>从风格上考虑，如果表达式比较复杂，则避免使用多重赋值形式；一系列独立的语句更易读。</p>
<p>这类表达式（例如一个有多个返回值的函数调用）产生多个值。当在一个赋值语句中使用这样的调用时，左边的变量个数需要和函数的返回值一样多。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f，err = os.open（<span class="string">"foo.txt"</span>）<span class="comment">//函数调用返回两个值</span></span><br></pre></td></tr></table></figure></p>
<p>通常函数使用额外的返回值来指示一些错误情况，例如通过os.open返回的error类型或者一个通常叫ok的boo1类型变量。我们会在后面的章节中看到，这里有三个操作符也有类似的行为。如果map查询（参考4.3节）、类型断言（参考7.10节）或者通道接收动作（参考8.4.2节）出现在两个结果的赋值语句中，都会产生一个额外的布尔型结果：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v,ok=m[key]</span><br><span class="line"><span class="comment">//map查询</span></span><br><span class="line">v,ok=x.(T)</span><br><span class="line"><span class="comment">//类型断言</span></span><br><span class="line">v,ok -&lt;-ch</span><br><span class="line"><span class="comment">//通道接收</span></span><br><span class="line">像变量声明一样，可以将不需要的值赋给空标识符：</span><br><span class="line">_，err = io.<span class="built_in">copy</span>（dst，src）<span class="comment">//丢弃字节个数</span></span><br><span class="line">_,ok=x.(T)</span><br><span class="line"><span class="comment">//检查类型但丢弃结果</span></span><br></pre></td></tr></table></figure></p>
<h2 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a><span style="color:#00ACC1;">可赋值性</span></h2><p>赋值语句是显式形式的赋值，但是程序中很多地方的赋值是隐式的：一个函数调用隐式地将参数的值赋给对应参数的变量；一个return语句隐式地将return操作数赋值给结果变量。复合类型的字面量表达式，例如slice（参考4.2节）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medals :=[]<span class="keyword">string</span>&#123;<span class="string">"gold"</span>,<span class="string">"silver"</span>,<span class="string">"bronze"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>隐式地给每一个元素赋值，它可以写成下面这样：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">medals[<span class="number">0</span>]= <span class="string">"gold"</span></span><br><span class="line">medals[<span class="number">1</span>]= <span class="string">"silver'</span></span><br><span class="line"><span class="string">medals[2]= "</span>bronze<span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p>map和通道的元素尽管不是普通变量，但它们也遵循相似的隐式赋值。<br>不管隐式还是显式赋值，如果左边的（变量）和右边的（值）类型相同，它就是合法的。通俗地说，赋值只有在值对于变量类型是可赋值的时才合法。</p>
<p>可赋值性根据类型不同有着不同的规则，我们将会在引人新类型的时候解释相应的规则。对已经讨论过的类型，规则很简单：类型必须精准匹配，nil可以被赋给任何接口变量或引用类型。常量（参考3.6节）有更灵活的可赋值性规则来规避显式的转换。</p>
<p>两个值使用==和！=进行比较与可赋值性相关：任何比较中，第一个操作数相对于第二个操作数的类型必须是可赋值的，或者可以反过来赋值。与可赋值性一样，我们也将解释新类型的可比较性的相关规则。</p>
<h1 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a><span style="color:#339AFF;">类型声明</span></h1><p>变量或表达式的类型定义这些值应有的特性，例如大小（多少位或多少个元素等）、在内部如何表达、可以对其进行何种操作以及它们所关联的方法。</p>
<p>任何程序中，都有一些变量使用相同的表示方式，但是含义相差非常大。例如，int类型可以用于表示循环的索引、时间戳、文件描述符或月份；float64类型可以表示每秒多少米的速度或精确到几位小数的温度；string类型可以表示密码或者颜色的名字。</p>
<p>type声明定义一个新的命名类型，它和某个已有类型使用同样的底层类型。命名类型提供了一种方式来区分底层类型的不同或者不兼容使用，这样它们就不会在无意中混用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name underlying-<span class="keyword">type</span></span><br></pre></td></tr></table></figure></p>
<p>类型的声明通常出现在包级别，这里命名的类型在整个包中可见，如果名字是导出的（开头使用大写字母），其他的包也可以访问它。</p>
<p>为了说明类型声明，我们把不同计量单位的温度值转换为不同的类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch2/tempconve</span><br><span class="line"><span class="comment">//包tempconv进行摄氏温度和华氏温度的转换计算</span></span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt'</span></span><br><span class="line"><span class="string">type Celsius float64</span></span><br><span class="line"><span class="string">type Fahrenheit float64</span></span><br><span class="line"><span class="string">const(</span></span><br><span class="line"><span class="string">AbsoluteZeroC Celsius = -273.15</span></span><br><span class="line"><span class="string">FreezingC</span></span><br><span class="line"><span class="string">Celsius =0</span></span><br><span class="line"><span class="string">BoilingC</span></span><br><span class="line"><span class="string">Celsius=100</span></span><br><span class="line"><span class="string">func CToF(c Celsius) Fahrenheit &#123; return Fahrenheit(c*9/5+32) &#125;</span></span><br><span class="line"><span class="string">func FToC(f Fahrenheit) Celsius &#123; return Celsius((f-32)*51 9) &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这个包定义了两个类型Celsius（摄氏温度）和Fahrenheit（华氏温度），它们分别对应两种温度计量单位。即使使用相同的底层类型float64，它们也不是相同的类型，所以它们不能使用算术表达式进行比较和合并。区分这些类型可以防止无意间合并不同计量单位的温度值；从float64转换为Celsius（t）或Fahrenheit（t）需要显式类型转换。Celsius（t）和Fahrenheit（t）是类型转换，而不是函数调用。它们不会改变值和表达方式，但改变了显式意义。另一方面，函数CToF和FToC用来在两种温度计量单位之间转换，返回不同的数值。</p>
<p>对于每个类型T，都有一个对应的类型转换操作T（x）将值x转换为类型T。如果两个类型具有相同的底层类型或二者都是指向相同底层类型变量的未命名指针类型，则二者是可以相互转换的。类型转换不改变类型值的表达方式，仅改变类型。如果x对于类型T是可赋值的，类型转换也是允许的，但是通常是不必要的。</p>
<p>数字类型间的转换，字符串和一些slice类型间的转换是允许的，我们将在下一章详细讨论。这些转换会改变值的表达方式。例如，从浮点型转化为整型会丢失小数部分，从字符串转换成字节（[]byte） slice会分配一份字符串数据副本。任何情况下，运行时的转换不会失败。</p>
<p>命名类型的底层类型决定了它的结构和表达方式，以及它支持的内部操作集合，这些内部操作与直接使用底层类型的情况相同。正如你所预期的，它意味着对于celsius和Fahrenheit类型可以使用与float64相同的算术操作符。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%g\n"</span>, BoilingC-FreezingC)/<span class="string">"100"</span>。C</span><br><span class="line">boilingF := CToF(BoilingC)</span><br><span class="line">fmt.Printf(<span class="string">"%g\n"</span>, boilingF-CToF(FreezingC))<span class="number">11</span><span class="string">"188"</span>。F</span><br><span class="line">fmt.Printf(<span class="string">"%g\n"</span>, boilingF-Freezingc)</span><br><span class="line"><span class="comment">//编译错误：类型不匹配</span></span><br></pre></td></tr></table></figure></p>
<p>通过=和《之类的比较操作符，命名类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较。但是不同命名类型的值不能直接比较：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">varcCelsius</span><br><span class="line"><span class="keyword">var</span> f Fahrenheit</span><br><span class="line">fmt.Println(c==<span class="number">0</span>)</span><br><span class="line"><span class="comment">// "true"</span></span><br><span class="line">fmt.Println(f&gt;=<span class="number">0</span>)</span><br><span class="line"><span class="string">"true'</span></span><br><span class="line"><span class="string">fmt.Println(c==f)</span></span><br><span class="line"><span class="string">编译错误类型不匹配</span></span><br><span class="line"><span class="string">（驽：ntint（  e5sus（5））/ "</span><span class="literal">true</span><span class="string">"!</span></span><br></pre></td></tr></table></figure></p>
<p>注意最后一种情况。无论名字如何，类型转换Celsius（f）没有改变参数的值，只改变其类型。测试结果是真，因为c和f的值都是0。</p>
<p>命名类型提供了概念上的便利，避免一遍遍地重复写复杂的类型。当底层类型是像float64这样简单的类型时，好处就不大了，但是对于我们将讨论到的复杂结构体类型，好处就很大，在讨论结构体时将介绍这一点。</p>
<p>下面的声明中，Celsius参数c出现在函数名字前面，名字叫string的方法关联到Celsius类型，返回c变量的数字值，后面跟着摄氏温度的符号C。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.sprintf(<span class="string">"%g"</span>c<span class="string">",c)&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>很多类型都声明这样一个string方法，在变量通过fmt包作为字符串输出时，它可以控制类型值的显示方式，我们将在7.1节中看到。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c:=FToC(<span class="number">212.0</span>)</span><br><span class="line">fmt.printin(c.<span class="keyword">string</span>())<span class="number">1</span>/“<span class="number">1000</span>c<span class="string">"</span></span><br><span class="line"><span class="string">fmt. Printf("</span>%v\n<span class="string">",c) // "</span><span class="number">100</span>*C<span class="string">"；不需要显式调用字符串</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%s\n<span class="string">",c) //"</span><span class="number">1000</span>C<span class="string">'</span></span><br><span class="line"><span class="string">fmt.Println(c)</span></span><br><span class="line"><span class="string">// "1000C"</span></span><br><span class="line"><span class="string">fmt.Printf（"%g\n"，c）//"100"；不调用字符串</span></span><br><span class="line"><span class="string">fmt.Println（f1oat64（c））//“100"；不调用字符串</span></span><br></pre></td></tr></table></figure></p>
<h1 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a><span style="color:#339AFF;">包和文件</span></h1><p>在Go语言中包的作用和其他语言中的库或模块作用类似，用于支持模块化、封装、编译隔离和重用。一个包的源代码保存在一个或多个以.go结尾的文件中，它所在目录名的尾部就是包的导入路径，例如，gopl.io/ch1/helloworld包的文件存储在目录$GOPATH/src/gopl.io/ch1/helloworld中。</p>
<p>每一个包给它的声明提供独立的命名空间。例如，在image包中，Decode标识符和unicode/utf16包中的标识符一样，但是关联了不同的函数。为了从包外部引用一个函数，我们必须明确修饰标识符来指明所指的是image.Decode或utf16.Decode。</p>
<p>包让我们可以通过控制变量在包外面的可见性或导出情况来隐藏信息。在Go里，通过一条简单的规则来管理标识符是否对外可见：导出的标识符以大写字母开头。</p>
<p>为了说明基本原理，假设温度转换软件很受欢迎，我们想把它作为新包贡献给Go社区，将要怎么做呢？</p>
<p>我们创建一个叫作gopl.io/ch2/tempconv的包，这是前面例子的变种（这里我们没有照惯例对例子进行顺序编号，目的是让包路径更实际一些）。包自己保存在两个文件里，以展示如何访问一个包里面多个独立文件中的声明。现实中，像这样的小包可能只需要一个文件。</p>
<p>将类型、它们的常量及方法的声明放在tempconv.go中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch2/tempconv</span><br><span class="line"><span class="comment">//tempconv包负责摄氏温度与华氏温度的转换</span></span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt'</span></span><br><span class="line"><span class="string">type Celsius float64</span></span><br><span class="line"><span class="string">type Fahrenheit float64</span></span><br><span class="line"><span class="string">const(</span></span><br><span class="line"><span class="string">AbsoluteZeroC Celsius = -273.15</span></span><br><span class="line"><span class="string">FreezingC</span></span><br><span class="line"><span class="string">Celsius =0</span></span><br><span class="line"><span class="string">BoilingC</span></span><br><span class="line"><span class="string">Celsius =100</span></span><br><span class="line"><span class="string">func(c Celsius) String() string &#123; return fmt.sprintf("</span>%g<span class="string">"c"</span>,c)</span><br><span class="line">f&#125;&#125; <span class="function"><span class="keyword">func</span> <span class="params">(f Fahrenheit)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.sprintf(<span class="string">"%gF"</span>,</span><br><span class="line">将转换函数放在conv.<span class="keyword">go</span>中：</span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"><span class="comment">//CToF把摄氏温度转换为华氏温度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span>+ <span class="number">32</span>) &#125;</span><br><span class="line"><span class="comment">//FToC把华氏温度转换为摄氏温度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f<span class="number">-32</span>)*<span class="number">519</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个文件的开头用package声明定义包的名称。当导入包时，它的成员通过诸如tempconv.CToF等方式被引用。如果包级别的名字（像类型和常量）在包的一个文件中声明，就像所有的源代码在同一个文件中一样，它们对于同一个包中的其他文件可见。注意，tempconv.go导入fmt包，但是conv.go没有，因为它本身没有用到fmt包。</p>
<p>因为包级别的常量名字以大写字母开头，所以它们也可以使用修饰过的名称（如tempconv.AbsoluteZeroc）来访问：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"Brrrr!%v\n"</span>, tempconv.AbsoluteZeroC) <span class="comment">// "Brrrr!-273.15*C"</span></span><br></pre></td></tr></table></figure></p>
<p>为了在某个包里将摄氏温度转换为华氏温度，导入包gopl.io/ch2/tempconv，然后编写下面的代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt. Println(tempconv.cTof(tempconv.Boilingc))<span class="number">1</span>/“<span class="number">212</span>F<span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>package声明前面紧挨着的文档注释（参考10.7.4节）对整个包进行描述。习惯上，应该在开头用一句话对包进行总结性的描述。每一个包里只有一个文件应该包含该包的文档注释。扩展的文档注释通常放在一个文件中，按惯例名字叫作doc.go。</p>
<p>练习2.1：添加类型、常量和函数到tempconv包中，处理以开尔文为单位（K）的温度值，0K=-273.15C，变化1K和变化1C是等价的。</p>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a><span style="color:#00ACC1;">导入</span></h2><p>在Go程序里，每一个包通过称为导入路径（import path）的唯一字符串来标识。它们出现在诸如”gopl.io/ch2/tempconv”之类的import声明中。语言的规范没有定义哪些字符串从哪来以及它们的含义，这依赖于工具来解释。当使用go工具（参考第10章）时，一个导入路径标注一个目录，目录中包含构成包的一个或多个Go源文件。除了导入路径之外，每个包还有一个包名，它以短名字的形式（且不必是唯一的）出现在包的声明中。按约定，包名匹配导入路径的最后一段，这样可以方便地预测gopl.io/ch2/tempconv的包名是tempconv。为了使用gopl.io/ch2/tempconv，必须导入它：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch2/cf</span><br><span class="line"><span class="comment">//cf把它的数值参数转换为摄氏温度和华氏温度</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt'</span></span><br><span class="line"><span class="string">"</span>os<span class="string">'</span></span><br><span class="line"><span class="string">"strconv'</span></span><br><span class="line"><span class="string">"gopl.io/ch2/tempconv'</span></span><br><span class="line"><span class="string">func main()&#123;</span></span><br><span class="line"><span class="string">for_, arg := range os.Args[1:]&#123;</span></span><br><span class="line"><span class="string">t, err :=strconv.ParseFloat(arg, 64) if err != nil&#123;</span></span><br><span class="line"><span class="string">fmt.Fprintf(os.stderr,"</span>cf:%v\n<span class="string">",err) os.Exit(1)</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">f:=tempconv.Fahrenheit(t)</span></span><br><span class="line"><span class="string">c:=tempconv.celsius(t)</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%s=%s,%s=%s\n<span class="string">",</span></span><br><span class="line"><span class="string">f, tempconv.FToc(f),c, tempconv.cToF(c))</span></span><br></pre></td></tr></table></figure></p>
<p>导入声明可以给导入的包绑定一个短名字，用来在整个文件中引用包的内容。上面的 import可以使用修饰标识符来引用gopl.io/ch2/tempconv包里的变量名，如tempconv.CToF。默认这个短名字是包名，在本例中是tempconv，但是导入声明可以设定一个可选的名字来避免冲突（参考10.4节）。</p>
<p>cf程序将一个数字型的命令行参数分别转换成摄氏温度和华氏温度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch2/cf</span><br><span class="line">$ ./cf32</span><br><span class="line">32<span class="string">"F=e"</span>C，32C=89.60F</span><br><span class="line">$ ./cf212</span><br><span class="line">2120F = 100*C,2120C=413.606</span><br><span class="line">$ ./cf-40</span><br><span class="line">-400F=-400C，-40*C--40</span><br></pre></td></tr></table></figure></p>
<p>如果导入一个没有被引用的包，就会触发一个错误。这个检查帮助消除代码演进过程中不再需要的依赖（尽管它在调试过程中会带来一些麻烦），因为注释掉一条诸如1og. Print（”got here！”）之类的代码，可能去除了对于log包唯一的一个引用，导致编译器报错。 </p>
<p>这种情况下，需要注释掉或者删掉不必要的import。</p>
<p>练习2.2：写一个类似于cf的通用的单位转换程序，从命令行参数或者标准输人（如果没有参数）获取数字，然后将每一个数字转换为以摄氏温度和华氏温度表示的温度，以英寸和米表示的长度单位，以磅和千克表示的重量，等等。</p>
<h2 id="包初始化"><a href="#包初始化" class="headerlink" title="包初始化"></a><span style="color:#00ACC1;">包初始化</span></h2><p>包的初始化从初始化包级别的变量开始，这些变量按照声明顺序初始化，在依赖已解析完毕的情况下，根据依赖的顺序进行。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vara =b+c</span><br><span class="line"><span class="comment">//最后把a初始化为3</span></span><br><span class="line">varb= f()</span><br><span class="line"><span class="comment">//通过调用f接着把b初始化为2</span></span><br><span class="line">varc<span class="number">-1</span></span><br><span class="line"><span class="comment">//首先初始化为1</span></span><br><span class="line">funcf()<span class="keyword">int</span>&#123;<span class="keyword">return</span> c+<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果包由多个.go文件组成，初始化按照编译器收到文件的顺序进行：go工具会在调用编译器前将.go文件进行排序。</p>
<p>对于包级别的每一个变量，生命周期从其值被初始化开始，但是对于其他一些变量，比如数据表，初始化表达式不是简单地设置它的初始化值。这种情况下，init函数的机制会比较简单。任何文件可以包含任意数量的声明如下的函数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个init函数不能被调用和被引用，另一方面，它也是普通的函数。在每一个文件里，当程序启动的时候，init函数按照它们声明的顺序自动执行。</p>
<p>包的初始化按照在程序中导入的顺序来进行，依赖顺序优先，每次初始化一个包。因此，如果包p导入了包q，可以确保q在p之前已完全初始化。初始化过程是自下向上的，main包最后初始化。在这种方式下，在程序的main函数开始执行前，所有的包已初始化完毕。</p>
<p>下面的包定义了一个Popcount函数，它返回一个数字中被置位的个数，即在一个uint64的值中，值为1的位的个数，这称为种群统计。它使用init函数来针对每一个可能的8位值预计算一个结果表pc，这样PopCount只需要将8个快查表的结果相加而不用进行64步的计算。（这个不是最快的统计位算法，只是方便用来说明init函数，用来展示如何预计算一个数值表，它是一种很有用的编程技术。）<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch2/popcount</span><br><span class="line"><span class="keyword">package</span> popcount</span><br><span class="line"><span class="comment">//pc[i]是i的种群统计</span></span><br><span class="line">    <span class="keyword">var</span> pc [<span class="number">256</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i :=<span class="keyword">range</span> pc&#123;</span><br><span class="line">pc[i]= pc[i/<span class="number">2</span>] + <span class="keyword">byte</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PopCount返回x的种群统计（置位的个数） func PopCount(xuint64)int&#123;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(pc[<span class="keyword">byte</span>(x&gt;&gt;(e*<span class="number">8</span>))]+ pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">1</span>*<span class="number">8</span>))]+</span><br><span class="line">    pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">2</span>*<span class="number">8</span>))]+</span><br><span class="line">    pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">3</span>*<span class="number">8</span>))]+</span><br><span class="line">    pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">4</span>*<span class="number">8</span>))]+</span><br><span class="line">    pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">5</span>*<span class="number">8</span>))]</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">6</span>*<span class="number">8</span>))]</span><br><span class="line">pc[<span class="keyword">byte</span>(x&gt;&gt;(<span class="number">7</span>*<span class="number">8</span>))])</span><br></pre></td></tr></table></figure></p>
<p>注意，init中的range循环只使用索引值不是必需的，所以没必要包含进来。循环可以重写为下面的形式：</p>
<p>我们将在下一节和10.5节看到init函数的其他用途。</p>
<p>练习2.3：使用循环重写PopCount来代替单个表达式。对比两个版本的效率。（11.4节会展示如何系统性地对比不同实现的性能。）</p>
<p>练习2.4：写一个用于统计位的PopCount，它在其实际参数的64位上执行移位操作，每次判断最右边的位，进而实现统计功能。把它与快查表版本的性能进行对比。</p>
<p>练习2.5：使用x&amp;（x-1）可以清除x最右边的非零位，利用该特点写一个PopCount，然后评价它的性能。</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><span style="color:#339AFF;">作用域</span></h1><p>声明将名字和程序实体关联起来，如一个函数或一个变量。声明的作用域是指用到声明时所声明名字的源代码段。</p>
<p>不要将作用域和生命周期混淆。声明的作用域是声明在程序文本中出现的区域，它是一个编译时属性。变量的生命周期是变量在程序执行期间能被程序的其他部分所引用的起止时间，它是一个运行时属性。</p>
<p>语法块（block）是由大括号围起来的一个语句序列，比如一个循环体或函数体。在语法块内部声明的变量对块外部不可见。块把声明包围起来，并且决定了它的可见性。我们可以把块的概念推广到其他没有显式包含在大括号中的声明代码，将其统称为词法块。包含了全部源代码的词法块，叫作全局块。每一个包，每一个文件，每一个for、if和switch语句，以及switch和select语句中的每一个条件，都是写在一个词法块里的。当然，显式写在大括号语法里的代码块也算是一个词法块。</p>
<p>一个声明的词法块决定声明的作用域大小。像int、len和true等内置类型、函数或常量在全局块中声明并且对于整个程序可见。在包级别（就是在任何函数外）的声明，可以被同一个包里的任何文件引用。导入的包（比如在tempconv例子中的fmt）是文件级别的，所以它们可以在同一个文件内引用，但是不能在没有另一个import语句的前提下被同一个包中其他文件中的东西引用。许多声明（像tempconv.CToF函数中变量c的声明）是局部的，仅可在同一个函数中或者仅仅是函数的一部分所引用。</p>
<p>控制流标签（如break、continue和goto语句使用的标签）的作用域是整个外层的函数（enclosing function）。</p>
<p>一个程序可以包含多个同名的声明，前提是它们在不同词法块中。例如可以声明一个和包级别变量同名的局部变量。或者像2.3.3节展示的，可以声明一个叫作new的参数，即使它是一个全局块中预声明的函数。然而，不要滥用，重声明所涉及的作用域越广，越可能影响其他的代码。</p>
<p>当编译器遇到一个名字的引用时，将从最内层的封闭词法块到全局块寻找其声明。如果没有找到，它会报“undeclared name”错误；如果在内层和外层块都存在这个声明，内层的将先被找到。这种情况下，内层声明将覆盖外部声明，使它不可访问：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="string">"g"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := <span class="string">"f"</span></span><br><span class="line">    fmt.Println(f) <span class="comment">// "f"; 局部变量f覆盖了包级函数f</span></span><br><span class="line">    fmt.Println(g) <span class="comment">// "g"; 包级变量</span></span><br><span class="line">    fmt.Println(h) <span class="comment">// 编译错误：未定义h</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在函数里面，词法块可能嵌套很深，所以一个局部变量声明可能覆盖另一个。很多词法块使用if语句和for循环这类控制流结构构建。下面的程序有三个称为x的不同的变量声明，因为每个声明出现在不同的词法块。（这个例子只是用来说明作用域的规则，风格并不完美！）<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"hello!"</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(x);i++&#123;</span><br><span class="line">        x := x[i]</span><br><span class="line">        <span class="keyword">if</span> x != <span class="string">'!'</span> &#123;</span><br><span class="line">            x := x + <span class="string">'A'</span> - <span class="string">'a'</span></span><br><span class="line">            fmt.Printf(<span class="string">"%c"</span>, x) <span class="comment">// "HELLO"（每次迭代一个字母）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表达式x[i]和x+’A’-‘a’都引用了在外层声明的x，稍后我们会解释它。（注意，后面的表达式不同于unicode.ToUpper函数。）</p>
<p>如上所述，不是所有的词法块都对应于显式大括号包围的语句序列，有一些词法块是隐式的。for循环创建了两个词法块：一个是循环体本身的显式块，以及一个隐式块，它包含了一个闭合结构，其中就有初始化语句中声明的变量，如变量i。隐式块中声明的变量的作用域包括条件、后置语句（i++），以及for语句体本身。</p>
<p>下面的例子也有三个名字为x的变量，每一个都在不同的词法块中声明：一个在函数体中，一个在for语句块中，一个在循环体中。但只有两个块是显式的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">for</span> _, x := <span class="keyword">range</span> x &#123;</span><br><span class="line">        x := x + <span class="string">'A'</span> - <span class="string">'a'</span></span><br><span class="line">        fmt.Printf(<span class="string">"%c"</span>, x) <span class="comment">// “HELLO"（每次迭代一个字母）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>像for循环一样，除了本身的主体块之外，if和switch语句还会创建隐式的词法块。下面的if-else链展示x和y的作用域：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x := f(); x == <span class="number">0</span>&#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> y := g(x); x == y&#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(x, y) <span class="comment">//编译错误：x与y在这里不可见</span></span><br></pre></td></tr></table></figure></p>
<p>第二个if语句嵌套在第一个中，所以第一个语句的初始化部分声明的变量在第二个语句中是可见的。同样的规则可以应用于switch语句：条件对应一个块，每个case语句体对应一个块。</p>
<p>在包级别，声明的顺序和它们的作用域没有关系，所以一个声明可以引用它自己或者跟在它后面的其他声明，使我们可以声明递归或相互递归的类型和函数。如果常量或变量声明引用它自己，则编译器会报错。</p>
<p>在以下程序中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f,err := os.Open(fname); err != <span class="literal">nil</span> &#123; <span class="comment">// 编译错误：未使用f</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.Stat()  <span class="comment">// 编译错误：未定义f</span></span><br><span class="line">f.Close() <span class="comment">// 编译错误：未定义f</span></span><br></pre></td></tr></table></figure></p>
<p>f变量的作用域是if语句，所以f不能被接下来的语句访问，编译器会报错。根据编译器的不同，也可能收到其他报错：局部变量f没有使用。</p>
<p>所以通常需要在条件判断之前声明f，使其在if语句后面可以访问：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(fname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">f.Stat()</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure></p>
<p>你可能希望避免在外部块中声明f和err，方法是将Stat和Close的调用放到else块中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> f, err := os.Open(fname); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// f与err在这里可见</span></span><br><span class="line">    f.Stat()</span><br><span class="line">    f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常Go中的做法是在if块中处理错误然后返回，这样成功执行的路径不会被变得支离破碎。</p>
<p>短变量声明依赖一个明确的作用域。考虑下面的程序，它获取当前的工作目录然后把它保存在一个包级别的变量里。这通过在main函数中调用os.Getwd来完成，但是最好可以从主逻辑中分离，特别是在获取目录失败是致命错误的情况下。函数log.Fatalf输出一条消息，然后调用os.Exit(1)退出。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cwd, err := os.Getwd() <span class="comment">// 编译错误：未使用cwd</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"os.Getwd failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为cwd和err在init函数块的内部都尚未声明，所以:=语句将它们都声明为局部变量。内层cwd的声明让外部的声明不可见，所以这个语句没有按预期更新包级别的cwd变量。</p>
<p>当前Go编译器检测到局部的cwd变量没有被使用，然后报错，但是不必严格执行这种检查。进一步做一个小的修改，比如增加引用局部cwd变量的日志语句就可以让检查失效。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cwd, err = os.Getwd() <span class="comment">// 注意：错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"os.Getwd failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Working directory = %s"</span>, cwd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>全局的cwd变量依然未初始化，看起来一个普通的日志输出让bug变得不明显。</p>
<p>处理这种潜在的问题有许多方法。最直接的方法是在另一个var声明中声明err，避免使用:=。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cwd <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    cwd, err = os.Getwd()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">"os.Getwd failed: %v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们已经看到包、文件、声明以及语句是如何来构成程序的。接下来的两章将要讨论数据的结构。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go程序设计语言/" rel="tag"># Go程序设计语言</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/15/第1章-起步/" rel="next" title="第1章 起步">
                <i class="fa fa-chevron-left"></i> 第1章 起步
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/16/第3章-基本数据/" rel="prev" title="第3章 基本数据">
                第3章 基本数据 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">学如逆水行舟，不进则退</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">815</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">62</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2022/11/22/19｜从正则表达式到CSS选择器：4种网页文本处理手段/" title="19 ｜ 从正则表达式到CSS选择器：4种网页文本处理手段" target="_blank">19 ｜ 从正则表达式到CSS选择器：4种网页文本处理手段</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/19/18｜依赖管理：Go-Module-用法与原理/" title="18 ｜ 依赖管理：GoModule用法与原理" target="_blank">18 ｜ 依赖管理：GoModule用法与原理</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/19/17｜巨人的肩膀：HTTP协议与Go标准库原理/" title="17 ｜ 巨人的肩膀：HTTP协议与Go标准库原理" target="_blank">17 ｜ 巨人的肩膀：HTTP协议与Go标准库原理</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/19/16｜网络爬虫：一次HTTP请求的魔幻旅途/" title="16 ｜ 网络爬虫：一次HTTP请求的魔幻旅途" target="_blank">16 ｜ 网络爬虫：一次HTTP请求的魔幻旅途</a>
                  </li>
                
                  <li>
                    <a href="/2022/11/13/07｜冰川之下：深入Go高并发网络模型/" title="07 ｜ 冰川之下：深入Go高并发网络模型" target="_blank">07 ｜ 冰川之下：深入Go高并发网络模型</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#名称"><span class="nav-number">1.</span> <span class="nav-text">名称</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#声明"><span class="nav-number">2.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量"><span class="nav-number">3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#短变量声明"><span class="nav-number">3.1.</span> <span class="nav-text">短变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针"><span class="nav-number">3.2.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new函数"><span class="nav-number">3.3.</span> <span class="nav-text">new函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量的生命周期"><span class="nav-number">3.4.</span> <span class="nav-text">变量的生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#赋值"><span class="nav-number">4.</span> <span class="nav-text">赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多重赋值"><span class="nav-number">4.1.</span> <span class="nav-text">多重赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可赋值性"><span class="nav-number">4.2.</span> <span class="nav-text">可赋值性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型声明"><span class="nav-number">5.</span> <span class="nav-text">类型声明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#包和文件"><span class="nav-number">6.</span> <span class="nav-text">包和文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#导入"><span class="nav-number">6.1.</span> <span class="nav-text">导入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包初始化"><span class="nav-number">6.2.</span> <span class="nav-text">包初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作用域"><span class="nav-number">7.</span> <span class="nav-text">作用域</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">7m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">106:28</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
