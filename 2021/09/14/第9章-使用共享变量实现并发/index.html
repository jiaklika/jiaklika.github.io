<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  当一个程序有两个或者多个goroutine时，每个goroutine内部的各个步骤也是顺序执行的，但我们无法知道一个goroutine中的事件x和另外一个goroutine中的事件y的先后顺序。如果我们无法自信地说一个事件肯定先于另外一个事件，那么这两个事件就是并发的。怎么理解？ 有三种方法来避免数据竞态。第一种方法是不要修改变量。第二种避免数据竞态的方法是避免从多个gor">
<meta name="keywords" content="Go程序设计语言">
<meta property="og:type" content="article">
<meta property="og:title" content="第9章 使用共享变量实现并发">
<meta property="og:url" content="http://yoursite.com/2021/09/14/第9章-使用共享变量实现并发/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  当一个程序有两个或者多个goroutine时，每个goroutine内部的各个步骤也是顺序执行的，但我们无法知道一个goroutine中的事件x和另外一个goroutine中的事件y的先后顺序。如果我们无法自信地说一个事件肯定先于另外一个事件，那么这两个事件就是并发的。怎么理解？ 有三种方法来避免数据竞态。第一种方法是不要修改变量。第二种避免数据竞态的方法是避免从多个gor">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/09/14/第9章-使用共享变量实现并发/t-1.png">
<meta property="og:image" content="http://yoursite.com/2021/09/14/第9章-使用共享变量实现并发/t-2.png">
<meta property="og:updated_time" content="2023-04-11T03:29:27.564Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第9章 使用共享变量实现并发">
<meta name="twitter:description" content="思考并回答以下问题：  当一个程序有两个或者多个goroutine时，每个goroutine内部的各个步骤也是顺序执行的，但我们无法知道一个goroutine中的事件x和另外一个goroutine中的事件y的先后顺序。如果我们无法自信地说一个事件肯定先于另外一个事件，那么这两个事件就是并发的。怎么理解？ 有三种方法来避免数据竞态。第一种方法是不要修改变量。第二种避免数据竞态的方法是避免从多个gor">
<meta name="twitter:image" content="http://yoursite.com/2021/09/14/第9章-使用共享变量实现并发/t-1.png">






  <link rel="canonical" href="http://yoursite.com/2021/09/14/第9章-使用共享变量实现并发/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第9章 使用共享变量实现并发 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/14/第9章-使用共享变量实现并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第9章 使用共享变量实现并发

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-14 10:50:41" itemprop="dateCreated datePublished" datetime="2021-09-14T10:50:41+08:00">2021-09-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2023-04-11 11:29:27" itemprop="dateModified" datetime="2023-04-11T11:29:27+08:00">2023-04-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">25k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">23 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>当一个程序有两个或者多个goroutine时，每个goroutine内部的各个步骤也是顺序执行的，但我们无法知道一个goroutine中的事件x和另外一个goroutine中的事件y的先后顺序。如果我们无法自信地说一个事件肯定先于另外一个事件，那么这两个事件就是并发的。怎么理解？</li>
<li>有三种方法来避免数据竞态。第一种方法是不要修改变量。第二种避免数据竞态的方法是避免从多个goroutine访问同一个变量。由于其他goroutine无法直接访问相关变量，因此它们就必须使用通道来向受限goroutine发送查询请求或者更新变量。第三种避免数据竞态的办法是允许多个goroutine访问同一个变量，但在同一时间只有一个goroutine可以访问。这种方法称为互斥机制。怎么理解？</li>
</ul>
<a id="more"></a>
<p>上一章用几个程序来演示了如何使用goroutine和通道来实现一种直接和自然的并发方式。当然，我们避开了一些微妙的要点，这些点是写并发代码时必须铭记在心的。</p>
<p>本章将深入到并发机制内部，特别是与多个goroutine共享变量相关的问题，以及识别这些问题的分析技术，还有解决这些问题的模式。最后将解释一下goroutine和操作系统线程的差别。</p>
<h1 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a><span style="color:#339AFF;">竞态</span></h1><p>在串行程序中（即一个程序只有一个goroutine），程序中各个步骤的执行顺序由程序逻辑来决定。比如，在一系列语句中，第一句在第二句之前执行，以此类推。当一个程序有两个或者多个goroutine时，每个goroutine内部的各个步骤也是顺序执行的，但我们无法知道一个goroutine中的事件x和另外一个goroutine中的事件y的先后顺序。如果我们无法自信地说一个事件肯定先于另外一个事件，那么这两个事件就是<strong>并发</strong>的。</p>
<p>考虑一个能在串行程序中正确工作的函数。如果这个函数在并发调用时仍然能正确工作，那么这个函数是<strong>并发安全</strong>（concurrency-safe）的，在这里并发调用是指，在没有额外同步机制的情况下，从两个或者多个goroutine同时调用这个函数。这个概念也可以推广到其他函数，比如方法或者作用于特定类型的一些操作。如果一个类型的所有可访问方法和操作都是并发安全时，则它可称为并发安全的类型。</p>
<p>让一个程序并发安全并不需要其中的每一个具体类型都是并发安全的。实际上，并发安全的类型其实是特例而不是普遍存在的，所以仅在文档指出类型是安全的情况下，才可以并发地访问一个变量。对于绝大部分变量，如要回避并发访问，要么限制变量只存在于一个goroutine内，要么维护一个更高层的<strong>互斥不变量</strong>。本章将详细解释这些概念。</p>
<p>与之对应的是，导出的包级别函数通常可以认为是并发安全的。因为包级别的变量无法限制在一个goroutine内，所以那些修改这些变量的函数就必须采用互斥机制。</p>
<p>函数并发调用时不工作的原因有很多，包括死锁、活锁（livelock）（比如多个线程在尝试绕开死锁，却由于过分同步导致反复冲突）以及资源耗尽。我们没有足够的时间来讨论所有的情形，因此接下来会重点讨论最重要的一种情形，即竞态。</p>
<p>竞态是指在多个goroutine按某些交错顺序执行时程序无法给出正确的结果。竞态对于程序是致命的，因为它们可能会潜伏在程序中，出现频率也很低，有可能仅在高负载环境或者在使用特定的编译器、平台和架构时才出现。这些都让竞态很难再现和分析。</p>
<p>我们常用一个经济损失的隐喻来解释竞态的严重性，在这里也先考虑一个简单的银行账户程序：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bank包实现了一个只有一个账户的银行</span></span><br><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123; balance = balance + amount&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> balance &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于一个如此简单的程序，我们一眼就可以看出，任意串行地调用Deposit和Balance都可以得到正确的结果。即Balance会输出之前存入的金额总数。但如果这些函数的调用顺序不是串行而是并行，Balance就不保证输出正确结果了。考虑如下两个goroutine，它们代表对一个共享账户的两笔交易：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alice:</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bank.Deposit(<span class="number">200</span>)                <span class="comment">// A1</span></span><br><span class="line">    fmt.Println(<span class="string">"="</span>, bank.Balance()) <span class="comment">// A2</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bob:</span></span><br><span class="line"><span class="keyword">go</span> bank.Deposit(<span class="number">100</span>) <span class="comment">// B</span></span><br></pre></td></tr></table></figure></p>
<p>Alice存入200美元，然后查询她的余额，与此同时Bob存入了100美元。A1、A2两步与B是并发进行的，我们无法预测实际的执行顺序。直觉来看，可能存在三种不同的顺序，分别称为“Alice先”、“Bob先”和“Alice/Bob/Alice”。下面的表格显示了每个步骤之后balance变量的值。带引号的字符串代表输出的账户余额。</p>
<img src="/2021/09/14/第9章-使用共享变量实现并发/t-1.png">
<p>在所有情况下最终的账户余额都是300美元。唯一不同的是Alice看到的账户余额是否包含了Bob的交易，但客户对所有情况都不会有不满。</p>
<p>但这种直觉是错的。这里还有第四种可能，Bob的存款在Alice的存款操作中间执行，晚于账户余额读取（<code>balance+amount</code>），但早于余额更新（<code>balance=...</code>），这会导致Bob存的钱消失了。这是因为Alice的存款操作A1实际上是串行的两个操作，读部分和写部分，我们称之为A1r和A1w。下面就是有问题的执行顺序：</p>
<img src="/2021/09/14/第9章-使用共享变量实现并发/t-2.png">
<p>在A1r之后，表达式<code>balance+amount</code>求值结果为200，这个值在A1w步骤中用于写入，完全没理会中间的存款操作。最终的余额为仅有200美元，银行从Bob手上挣了100美元。</p>
<p>程序中的这种状况是竞态中的一种，称为数据竞态（data race）。数据竞态发生于两个goroutine并发读写同一个变量并且至少其中一个是写入时。</p>
<p>当发生数据竞态的变量类型是大于一个机器字长的类型（比如接口、字符串或slice）时，事情就更复杂了。下面的代码并发把x更新为两个不同长度的slice。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; x = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>) &#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; x = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1000000</span>) &#125;()</span><br><span class="line">x[<span class="number">999999</span>] = <span class="number">1</span> <span class="comment">// 注意：未定义行为，可能造成内存异常</span></span><br></pre></td></tr></table></figure></p>
<p>最后一个表达式中x的值是未定义的，它可能是nil、一个长度为10的slice或者一个长度为100000的slice。回想一下slice的三个部分：指针、长度和容量。如果指针来自于第一个make调用而长度来自第二个make调用，那么x会变成一个嵌合体，它名义上长度为1000000但底层的数组只有10个元素。在这种情况下，尝试存储到第999999个元素会伤及很遥远的一段内存，其恶果无法预测，问题也很难调试和定位。这种语义上的雷区称为未定义行为，C程序员应当对此很熟悉了。幸运的是，相比之下Go语言很少有这种问题。</p>
<p>并行程序是几个串行程序交错执行这个观念也是一个错觉。在9.4节中可以看到，数据竞态可能由更奇怪的原因来引发。很多程序员（甚至是非常聪明的程序员）偶尔也会为自己程序中的数据竞态找借口：比如“互斥机制的成本太高了”“这段逻辑只用于输出日志”“我不在意丢掉一些消息”等。在给定的编译器和平台下不存在问题也给了他们盲目的自信。一个好的习惯是<strong>根本就没有什么温和的数据竞态</strong>。所以如何在程序中避免数据竞态呢？</p>
<p>再回顾一下定义（因为定义非常重要）：数据竞态发生于两个goroutine并发读写同一个变量并且至少其中一个是写入时。从定义不难看出，有三种方法来避免数据竞态。</p>
<p>第一种方法是不要修改变量。考虑如下的map，它进行了延迟初始化，对于每个键，在第一次访问时才触发加载。如果Icon的调用是串行的，那么程序能正常工作，但如果Icon的调用是并发的，在访问map时就存在数据竞态。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 注意并发不安全</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    icon, ok := icons[name]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        icon = loadIcon(name)</span><br><span class="line">        icons[name] = icon</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在创建其他goroutine之前就用完整的数据来初始化map，并且不再修改。那么无论多少goroutine也可以安全地并发调用Icon，因为每个goroutine都只读取这个map。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">    <span class="string">"spades.png"</span>: loadIcon(<span class="string">"spades.png"</span>),</span><br><span class="line">    <span class="string">"hearts.png"</span>: loadIcon(<span class="string">"hearts.png"</span>),</span><br><span class="line">    <span class="string">"diamonds.png"</span>: loadIcon(<span class="string">"diamonds.png"</span>),</span><br><span class="line">    <span class="string">"clubs.png"</span>: loadIcon(<span class="string">"clubs.png"</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123; <span class="keyword">return</span> icons[name]&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，icons变量的赋值发生在包初始化时，也就是在程序的main函数开始运行之前。一旦初始化完成后，icons就不再修改。那些从不修改的数据结构以及不可变数据结构本质上是并发安全的，也不需要做任何同步。但显然我们不能把这个方法用在必然会有更新的场景，比如一个银行账号。</p>
<p>第二种避免数据竞态的方法是避免从多个goroutine访问同一个变量。上一章的很多程序都采用了这个方法。比如，并发的Web爬虫（见8.6节）中主goroutine是唯一个能访问seen map的goroutine；聊天服务器（见8.10节）中的broadcaster goroutine是唯一个能访问clients map的goroutine。这些变量都限制在单个goroutine内部。</p>
<p>由于其他goroutine无法直接访问相关变量，因此它们就必须使用通道来向受限goroutine发送查询请求或者更新变量。这也是这句Go箴言的含义“不要通过共享内存来通信，而应该通过通信来共享内存”。使用通道请求来代理一个受限变量的所有访问的goroutine称为该变量的监控goroutine（monitor goroutine）。比如，broadcaster goroutine监控了对clients map的访问。</p>
<p>下面就是重写的银行案例，用一个叫teller的监控goroutine限制balance变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch9/bank1</span></span><br><span class="line"><span class="comment">// bank包提供了一个只有一个账户的并发安全银行</span></span><br><span class="line"><span class="keyword">package</span> bank</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deposits = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 发送存款额</span></span><br><span class="line"><span class="keyword">var</span> balances = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 接收余额</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123; deposits &lt;- amount &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span>       &#123; <span class="keyword">return</span> &lt;-balances &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">teller</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> balance <span class="keyword">int</span> <span class="comment">// balance被限制在teller goroutine中</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> amount := &lt;-deposits:</span><br><span class="line">            balance += amount</span><br><span class="line">        <span class="keyword">case</span> balances &lt;- balance:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> teller() <span class="comment">// 启动监控goroutine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使一个变量无法在整个生命周期受限于单个goroutine，加以限制仍然可以是解决并发访问的好方法。比如一个常见的场景，可以通过借助通道来把共享变量的地址从上一步传到下一步，从而在流水线上的多个goroutine之间共享该变量。在流水线中的每一步，在把变量地址传给下一步后就不再访问该变量了，这样所有对这个变量的访问都是串行的。换个说法，这个变量先受限于流水线的一步，再受限于下一步，以此类推。这种受限有时也称为<strong>串行受限</strong>。</p>
<p>在下面的例子中，Cakes是串行受限的，首先受限于baker goroutine，然后受限于icer goroutine。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cake <span class="keyword">struct</span>&#123; state <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">baker</span><span class="params">(cooked <span class="keyword">chan</span>&lt;- *Cake)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        cake := <span class="built_in">new</span>(Cake)</span><br><span class="line">        cake.state = <span class="string">"cooked"</span></span><br><span class="line">        cooked &lt;- cake <span class="comment">// baker不再访问cake变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">icer</span><span class="params">(iced <span class="keyword">chan</span>&lt;- *Cake, cooked &lt;-<span class="keyword">chan</span> *Cake)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> cake := <span class="keyword">range</span> cooked &#123;</span><br><span class="line">        cake.state = <span class="string">"iced"</span></span><br><span class="line">        iced &lt;- cake <span class="comment">// icer不再访问cake变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三种避免数据竞态的办法是允许多个goroutine访问同一个变量，但在同一时间只有一个goroutine可以访问。这种方法称为<strong>互斥机制</strong>，这是下一节的主题。</p>
<blockquote>
<p>练习9.1：向gopl.io/ch9/bank1程序添加一个函数<code>Withdraw(amount int)bool</code>。结果应当反映交易成功还是由于余额不足而失败。函数发送到监控goroutine的消息应当包含取款金额和一个新的通道，这个通道用于监控goroutine把布尔型的结果发送回Withdraw函数。</p>
</blockquote>
<h1 id="互斥锁：sync-Mutex"><a href="#互斥锁：sync-Mutex" class="headerlink" title="互斥锁：sync.Mutex"></a><span style="color:#339AFF;">互斥锁：sync.Mutex</span></h1><p>在8.6节，使用一个缓冲通道实现了一个计数信号量，用于确认同时发起HTTP请求的goroutine数量不超过20。使用同样的理念，也可以用一个容量为1的通道来保证同一时间最多有一个goroutine能访问共享变量。一个计数上限为1的信号量称为二进制信号量(binary semaphore)。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch9/bank2</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    sema    = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>) <span class="comment">// 用来保护balance的二进制信号量</span></span><br><span class="line">    balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取令牌</span></span><br><span class="line">    balance = balance + amount</span><br><span class="line">    &lt;-sema <span class="comment">// 释放令牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sema &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 获取令牌</span></span><br><span class="line">    b := balance</span><br><span class="line">    &lt;-sema <span class="comment">// 释放令牌</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>互斥锁模式应用非常广泛，所以sync包有一个单独的Mutex类型来支持这种模式。它的Lock方法用于获取令牌（token，此过程也称为上锁），Unlock方法用于释放令牌：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch9/bank3</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mu      sync.Mutex <span class="comment">// 保护balance</span></span><br><span class="line">    balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个goroutine在每次访问银行的变量（此处仅有balance）之前，它都必须先调用互斥量的Lock方法来获取一个互斥锁。如果其他goroutine已经取走了互斥锁，那么操作会一直阻塞到其他goroutine调用unlock之后（此时互斥锁再度可用）。互斥量保护共享变量。按照惯例，被互斥量保护的变量声明应当紧接在互斥量的声明之后。如果实际情况不是如此，请确认已加了注释来说明此事。</p>
<p>在Lock和unlock之间的代码，可以自由地读取和修改共享变量，这一部分称为临界区域。在锁的持有人调用unlock之前，其他goroutine不能获取锁。所以很重要的一点是，goroutine在使用完成后就应当释放锁，另外，需要包括函数的所有分支，特别是错误分支。</p>
<p>上面的银行程序展现了一个典型的并发模式。几个导出函数封装了一个或多个变量，于是只能通过这些函数来访问这些变量（对于一个对象的变量，则用方法来封装）。每个函数在开始时申请一个互斥锁，在结束时再释放掉，通过这种方式来确保共享变量不会被并发访问。这种函数、互斥锁、变量的组合方式称为监控（monitor）模式。（之前在监控goroutine中也使用了监控（monitor）这个词，都代表使用一个代理人（broker）来确保变量按顺序访问。）</p>
<p>因为Deposit和Balance函数中的临界区域都很短（只有一行，也没有分支），所以直接在函数结束时调用unlock也很方便。在更复杂的临界场景中，特别是必须通过提前返回来处理错误的场景，很难确定在所有的分支中Lock和unlock都成对执行了。Go语言的defer语句就可以解决这个问题：通过延迟执行unlock就可以把临界区域隐式扩展到当前函数的结尾，避免了必须在一个或者多个远离Lock的位置插入一条Unlock语句。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，Unlock在return语句已经读完balance变量之后执行，所以Balance函数就是并发安全的。另外，我们也不需要使用局部变量b了。</p>
<p>而且，在临界区域崩溃时延迟执行的Unlock也会正确执行，这在使用recover（参考5.10节）的情况下尤其重要。当然，defer的执行成本比显式调用unlock略大一些，但不足以成为代码不清晰的理由。在处理并发程序时，永远应当优先考虑清晰度，并且拒绝过早优化。在可以使用的地方，就尽量使用defer来让临界区域扩展到函数结尾处。</p>
<p>考虑如下Withdraw函数。当成功时，余额减少了指定的数量，并且返回true，但如果余额不足，无法完成交易，Withdraw恢复余额并且返回false。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：不是原子操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">    Deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> (Balance()&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        Deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//余额不足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数最终能给出正确的结果，但它有一个不良的副作用。在尝试进行超额提款时，在某个瞬间余额会降到0以下。这有可能会导致一个小额的取款会不合逻辑地被拒绝掉。所以当Bob尝试购买一辆跑车时，却会导致Alice无法支付早上的咖啡。Withdraw的问题在于不是原子操作：它包含三个串行的操作，每个操作都申请并释放了互斥锁，但对于整个序列没有上锁。</p>
<p>理想情况下，Withdraw应当为整个操作申请一次互斥锁。但如下尝试是正确的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：不正确的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    Deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> Balance() &lt; <span class="number">0</span> &#123;</span><br><span class="line">        Deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//余额不足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Deposit会通过调用mu.lock()来尝试再次获取互斥锁，但由于互斥锁是不能再入的（无法对一个已经上锁的互斥量再上锁），因此这会导致死锁，Withdraw会一直被卡住。</p>
<p>Go语言的互斥量是不可再入的，具体理由见后。互斥量的目的是在程序执行过程中维持基于共享变量的特定不变量（invariant）。其中一个不变量是“没有goroutine正在访问这个共享变量”，但有可能互斥量也保护针对数据结构的其他不变量。当goroutine获取一个互斥锁的时候，它可能会假定这些不变量是满足的。当它获取到互斥锁之后，它可能会更新共享变量的值，这样可能会临时不满足之前的不变量。当它释放互斥锁时，它必须保证之前的不变量已经还原且又能重新满足。尽管一个可重入的互斥量可以确保没有其他goroutine可以访问共享变量，但是无法保护这些变量的其他不变量。</p>
<p>一个常见的解决方案是把Deposit这样的函数拆分为两部分一个不导出的函数 deposit，它假定已经获得互斥锁，并完成实际的业务逻辑；以及一个导出的函数Deposit，它用来获取锁并调用deposit。这样我们就可以用deposit来实现Withdraw：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Withdraw</span><span class="params">(amount <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    deposit(-amount)</span><br><span class="line">    <span class="keyword">if</span> balance &lt;O&#123;</span><br><span class="line">        deposit(amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span><span class="comment">//余额不足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    deposit(amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数要求已获取互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span>&#123; balance += amount &#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，这里的deposit函数代码太少了，所以实际上Withdraw函数可以不用调用这个函数，但无论如何通过这个例子我们很好地演示了这个规则。</p>
<p>封装（参考6.6节）即通过在程序中减少对数据结构的非预期交互，来帮助我们保证数据结构中的不变量。因为类似的原因，封装也可以用来保持并发中的不变性。所以无论是为了保护包级别的变量，还是结构中的字段，当你使用一个互斥量时，都请确保互斥量本身以及被保护的变量都没有导出。</p>
<h1 id="读写互斥锁：sync-RWMutex"><a href="#读写互斥锁：sync-RWMutex" class="headerlink" title="读写互斥锁：sync.RWMutex"></a><span style="color:#339AFF;">读写互斥锁：sync.RWMutex</span></h1><p>Bob的100美元存款消失了，没留下任何线索，Bob感到很焦虑，为了解决这个问题，Bob写了一个程序，每秒钟查询数百次他的账户余额。这个程序同时在他家里、公司里和他的手机上运行。银行注意到快速增长的业务请求正在拖慢存款和取款操作，因为所有的Balance请求都是串行运行的，持有互斥锁并暂时妨碍了其他goroutine运行。</p>
<p>因为Balance函数只须读取变量的状态，所以多个Balance请求其实可以安全地并发运行，只要Deposit和Withdraw请求没有同时运行即可。在这种场景下，我们需要一种特殊类型的锁，它允许只读操作可以并发执行，但写操作需要获得完全独享的访问权限。这种锁称为多读单写锁，Go语言中的sync.RWMutex可以提供这种功能：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"><span class="keyword">var</span> balance <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.RLock() <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">defer</span> mu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> balance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Balance函数现在可以调用RLock和RUnlock方法来分别获取和释放一个读锁（也称为共享锁）。Deposit函数无须更改，它通过调用mu.lock和mu.unlock来分别获取和释放一个写锁（也称为互斥锁）。</p>
<p>经过上面的修改之后，Bob的绝大部分Balance请求可以并行运行且能更快完成。因此，锁可用的时间比例会更大，Deposit请求也能得到更及时的响应。</p>
<p>RLock仅可用于在临界区域内对共享变量无写操作的情形。一般来讲，我们不应当假定那些逻辑上只读的函数和方法不会更新一些变量。比如，一个看起来只是简单访问器的方法可能会递增内部使用的计数器，或者更新一个缓存来让重复的调用更快。如果你有疑问，那么久应当使用独享版本的Lock。</p>
<p>仅在绝大部分goroutine都在获取读锁并且锁竞争比较激烈时（即，goroutine一般都需要等待后才能获到锁），RWMutex才有优势。因为RWMutex需要更复杂的内部簿记工作，所以在竞争不激烈时它比普通的互斥锁慢。</p>
<h1 id="内存同步"><a href="#内存同步" class="headerlink" title="内存同步"></a><span style="color:#339AFF;">内存同步</span></h1><p>你可能会对Balance方法也需要互斥锁（不管是基于通道的锁还是基于互斥量的锁）感到奇怪。毕竟，与Deposit不一样，它只包含单个操作，所以并不存在另外一个goroutine插在中间执行的风险。其实需要互斥锁的原因有两个。第一个是防止Balance插到其他操作中间也是很重要的，比如Withdraw。第二个原因更微妙，因为同步不仅涉及多个goroutine的执行顺序问题，同步还会影响到内存。</p>
<p>现代的计算机一般都会有多个处理器，每个处理器都有内存的本地缓存。为了提高效率，对内存的写入是缓存在每个处理器中的，只在必要时才刷回内存。甚至刷回内存的顺序都可能与goroutine的写入顺序不一致。像通道通信或者互斥锁操作这样的同步原语都会导致处理器把累积的写操作刷回内存并提交，所以这个时刻之前goroutine的执行结果就保证了对运行在其他处理器的goroutine可见。</p>
<p>考虑如下代码片段的可能输出：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x = <span class="number">1</span>                       <span class="comment">// A1</span></span><br><span class="line">    fmt.Print(<span class="string">"y:"</span>, y, <span class="string">" "</span>) <span class="comment">// A2</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y = <span class="number">1</span>                       <span class="comment">// B1</span></span><br><span class="line">    fmt.Print(<span class="string">"x:"</span>, x, <span class="string">" "</span>) <span class="comment">// B2</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p>
<p>由于这两个goroutine并发运行且在没使用互斥锁的情况下访问共享变量，所以这里会有数据竞态。于是我们对程序每次的输出不一样不应该感到奇怪。根据对程序中标注语句不同的交错模式，我们可能会期望能看到如下四个结果中的一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y:0 x:1</span><br><span class="line">x:0 y:1</span><br><span class="line">x:1 y:1</span><br><span class="line">y:1 x:1</span><br></pre></td></tr></table></figure></p>
<p>第四行可以由A1，B1，A2，B2或B1，A1，A2，B2这样的执行顺序来产生。但是，程序产生的如下两个两个输出就在我们的意料之外了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x:0 y:0</span><br><span class="line">y:0 x:0</span><br></pre></td></tr></table></figure></p>
<p>但在某些特定的编译器、CPU或者其他情况下，这些确实可能发生。上面四个语句以什么样的顺序交错执行才能解释这个结果呢？</p>
<p>在单个goroutine内，每个语句的效果保证按照执行的顺序发生，也就是说，goroutine是串行一致的（sequentially consistent）。但在缺乏使用通道或者互斥量来显式同步的情况下，并不能保证所有的goroutine看到的事件顺序都是一致的。尽管goroutine A肯定能在读取y之前能观察到x=1的效果，但它并不一定能观察到goroutine B对y写入的效果，所以A可能会输出y的一个过期值。</p>
<p>尽管很容易把并发简单理解为多个goroutine中语句的某种交错执行方式，但正如上面的例子所显示的，这并不是一个现代编译器和CPU的工作方式。因为赋值和Print对应不同的变量，所以编译器就可能会认为两个语句的执行顺序不会影响结果，然后就交换了这两个语句的执行顺序。CPU也有类似的问题，如果两个goroutine在不同的CPU上执行，每个CPU都有自己的缓存，那么一个goroutine的写入操作在同步到内存之前对另外一个goroutine的Print语句是不可见的。</p>
<p>这些并发问题都可以通过采用简单、成熟的模式来避免，即在可能的情况下，把变量限制到单个goroutine中，对于其他变量，使用互斥锁。</p>
<h1 id="延迟初始化：sync-0nce"><a href="#延迟初始化：sync-0nce" class="headerlink" title="延迟初始化：sync.0nce"></a><span style="color:#339AFF;">延迟初始化：sync.0nce</span></h1><p>延迟一个昂贵的初始化步骤到有实际需求的时刻是一个很好的实践。预先初始化一个变量会增加程序的启动延时，并且如果实际执行时有可能根本用不上这个变量，那么初始化也不是必需的。回到本章之前提到的icons变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br></pre></td></tr></table></figure></p>
<p>这个版本的Icon使用了延迟初始化：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image&#123;</span><br><span class="line">        <span class="string">"spades.png"</span>:   loadIcon(<span class="string">"spades.png"</span>),</span><br><span class="line">        <span class="string">"hearts.png"</span>:   loadIcon(<span class="string">"hearts.png"</span>),</span><br><span class="line">        <span class="string">"diamonds.png"</span>: loadIcon(<span class="string">"diamonds.png"</span>),</span><br><span class="line">        <span class="string">"clubs.png"</span>:    loadIcon(<span class="string">"clubs.png"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：并发不安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123;</span><br><span class="line">        loadIcons() <span class="comment">//一次性地初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于那些只被一个goroutine访问的变量，上面的模式是没有问题的，但对于这个例子，在并发调用Icon时这个模式就是不安全的。类似于银行例子中最早版本的Deposit函数，Icon也包含多个步骤：检测icons是否为空，再加载图标，最后更新icons为一个非ni1值。直觉可能会告诉你，竞态带来的最严重问题可能就是loadIcons函数会被调用多遍。当第一个goroutine 正忙于加载图标时，其他goroutine进入Icon函数，会发现icons仍然是nil，所以仍然会调用1oadIcons。</p>
<p>但这个直觉仍然是错的（我希望你现在已经有一个关于并发的新直觉，那就是关于并发的直觉都不可靠）。回想一下9.4节关于内存的讨论，在缺乏显式同步的情况下，编译器和CPU在能保证每个goroutine都满足串行一致性的基础上可以自由地重排访问内存的顺序。1oadIcons一个可能的语句重排结果如下所示。它在填充数据之前把一个空map赋给icons:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIcons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    icons = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]image.Image)</span><br><span class="line">    icons[<span class="string">"spades.png"</span>] = loadIcon(<span class="string">"spades.png"</span>)</span><br><span class="line">    icons[<span class="string">"hearts.png"</span>] = loadIcon(<span class="string">"hearts.png"</span>)</span><br><span class="line">    icons[<span class="string">"diamonds.png"</span>] = loadIcon(<span class="string">"diamonds.png"</span>)</span><br><span class="line">    icons[<span class="string">"clubs.png"</span>] = loadIcon(<span class="string">"clubs.png"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，一个goroutine发现icons不是nil并不意味着变量的初始化肯定已经完成。</p>
<p>保证所有goroutine都能观察到loadIcons效果最简单的正确方法就是用一个互斥锁来做同步：</p>
<p>采用互斥锁访问icons的额外代价是两个goroutine不能并发访问这个变量，即使在变量已经安全完成初始化且不再更改的情况下，也会造成这个后果。使用一个可以并发读的锁就可以改善这个问题：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex <span class="comment">// 保护icons</span></span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">if</span> icons !=<span class="literal">nil</span> &#123;</span><br><span class="line">        icon := icons[name]</span><br><span class="line">        mu.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> icon</span><br><span class="line">    &#125;</span><br><span class="line">    mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取互斥锁</span></span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> icons == <span class="literal">nil</span> &#123; <span class="comment">// 注意：必须重新检查nil值</span></span><br><span class="line">        loadIcons()</span><br><span class="line">    &#125;</span><br><span class="line">    icon := icons[name]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> icon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有两个临界区域。goroutine首先获取一个读锁，查阅map，然后释放这个读锁。如果条目能找到（常见情况），就返回它。如果条目没找到，goroutine再获取一个写锁。由于不先释放一个共享锁就无法直接把它升级到互斥锁，为了避免在过渡期其他goroutine已经初始化了icons，所以我们必须重新检查nil值。</p>
<p>上面的模式具有更好的并发性，但它更复杂并且更容易出错。幸运的是，sync包提供了针对一次性初始化问题的特化解决方案sync.once。从概念上来讲，once包含一个布尔变量和一个互斥量，布尔变量记录初始化是否已经完成，互斥量则负责保护这个布尔变量和客户端的数据结构。0nce的唯一方法Do以初始化函数作为它的参数。让我们看一下0nce简化后的Icon函数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="keyword">string</span>]image.Image</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">image</span>.<span class="title">Image</span></span> &#123;</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次调用Do（loadIcons）时会先锁定互斥量并检查里边的布尔变量。在第一次调用时，这个布尔变量为假，Do会调用loadIcons然后把变量设置为真。后续的调用相当于空操作，只是通过互斥量的同步来保证loadIcons对内存产生的效果（在这里就是icons变量）对所有的goroutine可见。以这种方式来使用sync.once，可以避免变量在正确构造之前就被其他goroutine分享。</p>
<p>练习9.2：重写2.6.2节的PopCount示例，使用sync.once来把查找表的初始化延迟到第一次使用时。（从实际效果来看，像PopCount这种既小又经高度优化的函数无法承担同步的成本。）</p>
<h1 id="竞态检测器"><a href="#竞态检测器" class="headerlink" title="竞态检测器"></a><span style="color:#339AFF;">竞态检测器</span></h1><p>即使以最大努力的仔细，仍然很容易在并发上犯错误。幸运的是，Go语言运行时和工具链装备了一个精致并易于使用的动态分析工具：竞态检测器（race detector）。</p>
<p>简单地把<code>-race</code>命令行参数加到<code>go build</code>、<code>go run</code>、<code>go test</code>命令里边即可使用该功能。它会让编译器为你的应用或测试构建一个修改后的版本，这个版本有额外的手法用于高效记录在执行时对共享变量的所有访问，以及读写这些变量的goroutine标识。除此之外，修改后的版本还会记录所有的同步事件，包括go语句、通道操作、<code>(*sync.Mutex).Lock</code>调用、<code>(*sync.WaitGroup).Wait</code>调用等。（完整的同步事件集合可以在语言规范中的“The Go Memory Model”文档中找到。）</p>
<p>竞态检测器会研究事件流，找到那些有问题的案例，即一个goroutine写入一个变量后，中间没有任何同步的操作，就有另外一个goroutine读写了该变量。这种案例表明有对共享变量的并发访问，即数据竞态。这个工具会输出一份报告，包括变量的标识以及读写goroutine当时的调用栈。通常情况下这些信息足以定位问题了。在9.7节就有一个竞态检测器的示例。</p>
<p>竞态检测器报告所有实际运行了的数据竞态。然而，它只能检测到那些在运行时发生的竞态，无法用来保证肯定不会发生竞态。为了获得最佳效果，请确保你的测试包含了并发使用包的场景。</p>
<p>由于存在额外的簿记工作，带竞态检测功能的程序在执行时需要更长的时间和更多的内存，但即使对于很多生产环境的任务，这种额外开支也是可以接受的。对于那些不常发生的竞态，使用竞态检测器可以帮你节省数小时甚至数天的调试时间。</p>
<h1 id="示例：并发非阻塞缓存"><a href="#示例：并发非阻塞缓存" class="headerlink" title="示例：并发非阻塞缓存"></a><span style="color:#339AFF;">示例：并发非阻塞缓存</span></h1><p>在本节中，我们会创建一个并发非阻塞的缓存系统，它能解决在并发实战很常见但已有的库也不能很好地解决的一个问题：函数记忆（memoizing）问题，即缓存函数的结果，达到多次调用但只须计算一次的效果。我们的解决方案将是并发安全的，并且要避免简单地对整个缓存使用单个锁而带来的锁争夺问题。</p>
<p>我们将使用下面的httpGetBody函数作为示例来演示函数记忆。它会发起一个HTTP GET请求并读取响应体。调用这个函数相当昂贵，所以我们希望避免不必要的重复调用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后一行略有一些微妙，ReadAll返回两个结果，一个[]byte和一个error，因为它们分别可以直接赋给httpGetBody声明的结果类型interface{}和一个error，所以我们可以直接返回这个结果而不用做额外的处理。httpGetBody选择这样的结果类型是为了满足我们要做的缓存系统的设计。</p>
<p>下面是缓存的初始版本：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gopl.io/ch9/memo1</span></span><br><span class="line"><span class="comment">// memo包提供了一个对类型Func并发不安全的函数记忆功能</span></span><br><span class="line"><span class="keyword">package</span> memo</span><br><span class="line"></span><br><span class="line"><span class="comment">// Memo缓存了调用Func的结果</span></span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">    f     Func</span><br><span class="line">    cache <span class="keyword">map</span>[<span class="keyword">string</span>]result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Func是用于记忆的函数类型</span></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">result</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(f Func)</span> *<span class="title">Memo</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]result)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：非并发安全</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">    res, ok := memo.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        res.value, res.err = memo.f(key)</span><br><span class="line">        memo.cache[key] = res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个Memo实例包含了被记忆的函数f（类型为Func），以及缓存，类型为从字符串到result的一个映射表。每个result都是调用f产生的结果对：一个值和一个错误。在设计的推进过程中我们会展示Memo的几种变体，但所有变体都会遵守这些基本概念。</p>
<p>下面的例子展示如何使用Memo。对于一串请求URL中的每个元素，首先调用Get，记录延时和它返回的数据长度：</p>
<p>我们可以使用testing包（这是第11章的主题）来系统地调查一下记忆的效果。从下面的测试结果来看，我们可以看到URL流有重复项，尽管每个URL第一次调用（*Memo）.Get都会消耗数百毫秒的时间，但对这个URL的第二次请求在1us内就返回了同样的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> -vgopl.io/ch9/memo1</span><br><span class="line">=== RUNTest</span><br><span class="line">https://golang.org，175.026418ms，7537bytes</span><br><span class="line">https://godoc.org，172.686825ms,6878bytes</span><br><span class="line">https://play.golang.org，115.762377ms,5767bytes</span><br><span class="line">http://gopl.io，749.887242ms,2856bytes</span><br><span class="line">https://golang.org，721ns，7537bytes</span><br><span class="line">https://godoc.org，152ns，6878bytes</span><br><span class="line">https://play.golang.org，205ns，5767bytes</span><br><span class="line">http://gopl.io,326ns，2856bytes</span><br><span class="line">PASS:Test(1.21s)</span><br><span class="line">PASS</span><br><span class="line">okgopl.io/ch9/memo1 1.257s</span><br></pre></td></tr></table></figure></p>
<p>这次测试中所有的Get都是串行运行的。</p>
<p>因为HTTP请求用并发来改善的空间很大，所以我们修改测试来让所有请求并发进行。这个测试使用sync.WaitGroup来做到等最后一个请求完成后再返回的效果。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m := memo.New(httpGetBody)</span><br><span class="line"><span class="keyword">var</span> n sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> url := <span class="keyword">range</span> incomingURLs() &#123;</span><br><span class="line">    n.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(url <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">        start := time.Now()</span><br><span class="line">        value, err :=m.Get(url)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Print(err)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">"%s, %s, %d bytes\n"</span>, </span><br><span class="line">            url, time.Since(start),<span class="built_in">len</span>(value.([]<span class="keyword">byte</span>)))</span><br><span class="line">        n.Done()</span><br><span class="line">    &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line">n.Wait()</span><br></pre></td></tr></table></figure></p>
<p>这次的测试运行起来快很多，但是它并不是每一次都能正常运行。我们可能能注意到意料之外的缓存无效，以及缓存命中后返回错误的结果，甚至崩溃。</p>
<p>更糟糕的是，有的时候它能正常运行，所以我们可能甚至都没有注意到它会有问题。但如果我们加上-race标志后再运行，那么竞态检测器（参考9.6节）经常会输出与下面类似的一份报告：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上面提到的memo.go：32告诉我们两个goroutine在没使用同步的情况下更新了cachemap。整个Get函数其实不是并发安全的：它存在数据竞态。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">28</span> <span class="function"><span class="keyword">func</span><span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span>&#123;</span><br><span class="line"><span class="number">29</span></span><br><span class="line">res, ok := memo.cache[key]</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="keyword">if</span>!ok&#123;</span><br><span class="line"><span class="number">31</span></span><br><span class="line">res.value, res.err = memo.f(key)</span><br><span class="line"><span class="number">32</span></span><br><span class="line">memo.cache[key]=res</span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="keyword">return</span> res.value, res.err</span><br><span class="line"><span class="number">35</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>让缓存并发安全最简单的方法就是用一个基于监控的同步机制。我们需要的是给Memo加一个互斥量，并在Get函数的开头获取互斥锁，在返回前释放互斥锁，这个样两个cache相关的操作就发生在临界区域了：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch9/memo2</span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">f</span><br><span class="line">Func</span><br><span class="line">mu sync.Mutex<span class="comment">//保护cache</span></span><br><span class="line">cache <span class="keyword">map</span>[<span class="keyword">string</span>]result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Get是并发安全的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, err error)</span></span>&#123;</span><br><span class="line">memo.mu.Lock()</span><br><span class="line">res, ok :- memo.cache[key]</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">res.value, res.err = memo.f(key)</span><br><span class="line">memo.cache[key]=res</span><br><span class="line">memo.mu. Unlock()</span><br><span class="line"><span class="keyword">return</span> res.value, res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在即使并发运行测试，竞态检测器也没有报警。但是这次对Memo的修改让我们之前对性能的优化失效了。由于每次调用f时都上锁，因此Get把我们希望并行的I/O操作串行化了。我们需要的是一个非阻塞的缓存，一个不会把他需要记忆的函数串行运行的缓存。</p>
<p>在下面一个版本的Get实现中，主调goroutine会分两次获取锁：第一次用于查询，第二次用于在查询无返回结果时进行更新。在两次之间，其他goroutine也可以使用缓存。</p>
<p>性能再度得到提升，但我们注意到某些URL被获取了两次。在两个或者多个goroutine几乎同时调用Get来获取同一个URL时就会出现这个问题。两个goroutine都首先查询缓存，发现缓存中没有需要的数据，然后调用那个慢函数f，最后又都用获得的结果来更新map，其中一个结果会被另外一个覆盖。</p>
<p>在理想情况下我们应该避免这种额外的处理。这个功能有时称为重复抑制（duplicatesuppression）。在下面的Memo版本中，map的每个元素是一个指向entry结构的指针。除了与之前一样包含一个已经记住的函数f调用结果之外，每个entry还新加了一个通道ready。在设置entry的result字段后，通道会关闭，正在等待的goroutine会收到广播（参考8.9节），然后就可以从entry读取结果了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch9/memo4</span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">res result</span><br><span class="line">ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;<span class="comment">//res准备好后会被关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(fFunc)</span>*<span class="title">Memo</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Memo&#123;f: f, cache:<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*entry)&#125;</span><br><span class="line"><span class="keyword">type</span> Memo <span class="keyword">struct</span> &#123;</span><br><span class="line">f</span><br><span class="line">Func</span><br><span class="line">mu</span><br><span class="line">sync.Mutex<span class="comment">//保护cache</span></span><br><span class="line">cache <span class="keyword">map</span>[<span class="keyword">string</span>]*entry</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(value <span class="keyword">interface</span>&#123;l&#125;, err error)</span></span>&#123;</span><br><span class="line">memo.mu.Lock()</span><br><span class="line">e :=memo.cache[key]</span><br><span class="line"><span class="keyword">if</span> e= <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//对key的第一次访问，这个goroutine负责计算数据和广播数据</span></span><br><span class="line"><span class="comment">//已准备完毕的消息</span></span><br><span class="line">e= &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">memo.cache[key]=e</span><br><span class="line">memo.mu.Unlock()</span><br><span class="line">e.res.value, e.res.err = memo.f(key)</span><br><span class="line"><span class="built_in">close</span>（e.ready）<span class="comment">//广播数据已准备完毕的消息</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="number">1</span><span class="comment">//对这个key的重复访问</span></span><br><span class="line">memo.mu. Unlock()</span><br><span class="line">《-e.ready<span class="comment">//等待数据准备完毕</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e.res.value,e.res.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在调用Get回会先获取保护cache map的互斥锁，再从map中查询一个指向已有entry的指针，如果没有查找到，就分配并插入一个新的entry，最后释放锁。如果要查询的entry存在，那么它的值可能还没准备好（另外一个goroutine有可能还在调用慢函数f），所以主调goroutine就需要等待entry准备好才能读取entry中的result数据，具体的实现方法就是从ready通道读取数据，这个操作会一直阻塞到通道关闭。</p>
<p>如果要查询的entry不存在，那么当前的goroutine就需要新插人一个没有准备好的entry到map里，并负责调用慢函数f，更新entry，最后向其他正在等待的goroutine广播数据已准备完毕的消息。</p>
<p>注意，entry中的变量e.res.value和e.res.err被多个goroutine共享。创建entry的goroutine设置了这两个变量的值，其他goroutine在收到数据准备完毕的广播后开始读这两个变量。尽管变量被多个goroutine访问，但此处不需要加上互斥锁。ready通道的关闭先于其他goroutine收到广播事件，所以第一个goroutine的变量写入事件也先于后续多个goroutine的读取事件。在这个情况下数据竞态不存在。</p>
<p>这里的并发、重复抑制、非阻塞缓存就完成了。</p>
<p>上面的Memo代码使用一个互斥量来保护被多个调用Get的goroutine访问的map变量。接下来会对比另外一种设计，在新的设计中，map变量限制在一个监控goroutine中，而Get的调用者则不得不改为发送消息。</p>
<p>func、 result、entry的声明与之前一致：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func是用于记忆的函数类型</span></span><br><span class="line"><span class="keyword">type</span> Func <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"><span class="function">// <span class="title">result</span>是调用<span class="title">Func</span>的返回结果</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">result</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">value <span class="keyword">interface</span>&#123;]</span><br><span class="line">err error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">res result</span><br><span class="line">ready <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;<span class="comment">//当res准备好后关闭该通道</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>尽管Get的调用者通过这个通道来与监控goroutine通信，但是Memo类型现在包含一个通道requests。该通道的元素类型是request。通过这种数据结构，Get的调用者向监控goroutine发送被记忆函数的参数（key），以及一个通道response，结果在准备好后就通过response通道发回。这个通道仅会传输一个值。</p>
<p>上面的Get方法创建了一个响应（response）通道，放在了请求里边，然后把它发送给监控goroutine，再马上从响应通道中读取。</p>
<p>如下所示，cache变量被限制在监控goroutine （即（*Memo）.server）中。监控goroutine从request通道中循环读取，直到该通道被Close方法关闭。对于每个请求，它先查询缓存，如果没找到则创建并插入一个新的entry。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(memo *Memo)</span> <span class="title">server</span><span class="params">(f Func)</span></span>&#123;</span><br><span class="line">cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*entry)</span><br><span class="line"><span class="keyword">for</span> req :=<span class="keyword">range</span> memo.requests &#123;</span><br><span class="line">e:=cache[req.key]</span><br><span class="line"><span class="keyword">if</span> e == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="comment">//对这个key的第一次请求</span></span><br><span class="line">e = &amp;entry&#123;ready: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">cache[req.key]=e</span><br><span class="line"><span class="keyword">go</span> e.call（f，req.key）<span class="comment">//调用f（key）</span></span><br><span class="line"><span class="keyword">go</span> e.deliver(req.response)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e*entry)</span> <span class="title">call</span><span class="params">(f Func,key <span class="keyword">string</span>)</span></span>&#123; <span class="comment">//执行函数</span></span><br><span class="line">e.res.value, e.res.err = f(key)</span><br><span class="line"><span class="comment">//通知数据已准备完毕</span></span><br><span class="line"><span class="built_in">close</span>(e.ready)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e*entry)</span> <span class="title">deliver</span><span class="params">(response <span class="keyword">chan</span>&lt;- result)</span></span> &#123; <span class="comment">//等该数据准备完毕</span></span><br><span class="line">&lt;-e.ready</span><br><span class="line"><span class="comment">//向客户端发送结果</span></span><br><span class="line">response &lt;-e.res</span><br></pre></td></tr></table></figure></p>
<p>与基于互斥锁的版本类似，对于指定键的一次请求负责在该键上调用函数f，保存结果到entry中，最后通过关闭ready通道来广播准备完毕状态。这个流程通过（*entry）.call来实现。</p>
<p>对同一个键的后续请求会在map中找到已有的entry，然后等待结果准备好，最后通过响应通道把结果发回给调用Get的客户端goroutine。其中call和deliver方法都需要在独立的goroutine中运行，以确保监控goroutine能持续处理新请求。</p>
<p>上面的例子展示了可以使用两种方案来构建并发结构：共享变量并上锁，或者通信顺序进程（communicating sequential process），这两者也都不复杂。</p>
<p>在给定的情况下也许很难判定哪种方案更好，但了解这两种方案的对照关系是很有价值的。有时候从一种方案切换到另外一种能够让代码更简单。</p>
<p>练习9.3：扩展Func类型和（*Memo）.Get方法，让调用者可选择性地提供一个done通道，方便取消操作（参考8.9节）。不要缓存被取消的Func调用结果。</p>
<h1 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a><span style="color:#339AFF;">goroutine与线程</span></h1><p>上一章提到可以先忽略goroutine与操作系统（OS）线程的差异。尽管它们之间的差异本质上是属于量变，但一个足够大的量变会变成质变。下面讨论如何区分它们。</p>
<h2 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a><span style="color:#339AFF;">可增长的栈</span></h2><p>每个OS线程都有一个固定大小的栈内存（通常为2MB），栈内存区域用于保存在其他函数调用期间那些正在执行或临时暂停的函数中的局部变量。这个固定的栈大小既太大又太小。对于一个小的goroutine，2MB的栈是一个巨大的浪费，比如有的goroutine仅仅等待一个WaitGroup再关闭一个通道。在Go程序中，一次创建十万左右的goroutine也不罕见，对于这种情况，栈就太大了。另外，对于最复杂和深度递归的函数，固定大小的栈始终不够大。改变这个固定大小可以提高空间效率并允许创建更多的线程，或者也可以容许更深的递归函数，但无法同时做到上面的两点。</p>
<p>作为对比，一个goroutine在生命周期开始时只有一个很小的栈，典型情况下为2KB。与OS线程类似，goroutine的栈也用于存放那些正在执行或临时暂停的函数中的局部变量。但与OS线程不同的是，goroutine的栈不是固定大小的，它可以按需增大和缩小。goroutine的栈大小限制可以达到1GB，比线程典型的固定大小栈高几个数量级。当然，只有极少的goroutine会使用这么大的栈。</p>
<p>练习9.4：使用通道构造一个把任意多个goroutine串联在一起的流水线程序。在内存耗尽之前你能创建的最大流水线级数是多少？一个值穿过整个流水线需要多久？</p>
<h2 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a><span style="color:#339AFF;">goroutine调度</span></h2><p>OS线程由OS内核来调度。每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个叫调度器的内核函数。这个函数暂停当前正在运行的线程，把它的寄存器信息保存到内存，查看线程列表并决定接下来运行哪一个线程，再从内存恢复线程的注册表信息，最后继续执行选中的线程。因为OS线程由内核来调度，所以控制权限从一个线程到另外一个线程需要一个完整的上下文切换（context switch）：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。考虑这个操作涉及的内存局域性以及涉及的内存访问数量，还有访问内存所需的CPU周期数量的增加，这个操作其实是很慢的。</p>
<p>Go运行时包含一个自己的调度器，这个调度器使用一个称为m：n调度的技术（因为它可以复用/调度m个goroutine到n个OS线程）。Go调度器与内核调度器的工作类似，但Go调度器只需关心单个Go程序的goroutine调度问题。</p>
<p>与操作系统的线程调度器不同的是，Go调度器不是由硬件时钟来定期触发的，而是由特定的Go语言结构来触发的。比如当一个goroutine调用time.Sleep或被通道阻塞或对互斥量操作时，调度器就会将这个goroutine设为休眠模式，并运行其他goroutine直到前一个可重新唤醒为止。因为它不需要切换到内核语境，所以调用一个goroutine比调度一个线程成本低很多。</p>
<p>练习9.5：写一个程序，两个goroutine通过两个无缓冲通道来互相转发消息。这个程序能维持每秒多少次通信？</p>
<h2 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><span style="color:#339AFF;">GOMAXPROCS</span></h2><p>Go调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU数量，所以在一个有8个CPU的机器上，调度器会把Go代码同时调度到8各OS线程上。（GOMAXPROCS是m：n调度中的n。）正在休眠或者正被通道通信阻塞的goroutine不需要占用线程。阻塞在I/0和其他系统调用中或调用非Go语言写的函数的</p>
<p>goroutine需要一个独立的OS线程，但这个线程不计算在GOMAXPROCS内。</p>
<p>可以用GOMAXPROCS环境变量或者runtime.GoMAXPROCS函数来显式控制这个参数。可以用一个小程序来看看GOMAXPROCS的效果，这个程序无止境地输出0和1：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">go</span> fmt.Print(<span class="number">0</span>)</span><br><span class="line">fmt.Print(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">$ G0MAXPROCS=<span class="number">1</span> <span class="keyword">go</span> run hacker-cliche.<span class="keyword">go</span></span><br><span class="line"><span class="number">111111111111111111110000000000000000000011111.</span>.</span><br><span class="line">$ G0MAXPROCS=<span class="number">2</span> <span class="keyword">go</span> run hacker-cliche.<span class="keyword">go</span></span><br><span class="line"><span class="number">010101010101010101011001100101011010010100110.</span>.</span><br></pre></td></tr></table></figure></p>
<p>在第一次运行时，每次最多只能有一个goroutine运行。最开始是主goroutine，它输出 1。在一段时间以后，Go调度器让主goroutine休眠，并且唤醒另一个输出0的goroutine，让它有机会执行。在第二次运行时，这里有两个可用的OS线程，所以两个goroutine可以同时运行，以一个差不多的速率输出两个数字。我们必须强调影响goroutine调度的因素很多，运行时也在不断演化，所以你的结果可能与上面展示的结果会有所不同。</p>
<p>练习9.6：测量计算密集型并行程序（见练习8.5）在GOMAXPROCS参数变化时的性能变化。在你的计算机上最优值是多少？你的计算机有多少个CPU？</p>
<h2 id="goroutine没有标识"><a href="#goroutine没有标识" class="headerlink" title="goroutine没有标识"></a><span style="color:#339AFF;">goroutine没有标识</span></h2><p>在大部分支持多线程的操作系统和编程语言里，当前线程都有一个独特的标识，它通常可以取一个整数或者指针。这个特性让我们可以轻松构建一个线程的局部存储，它本质上就是一个全局的map，以线程的标识作为键，这样每个线程都可以独立地用这个map存储和获取值，而不受其他线程干扰。</p>
<p>goroutine没有可供程序员访问的标识。这个是由设计来决定的，因为线程局部存储有一种被滥用的倾向。比如，当一个Web服务器用一个支持线程局部存储的语言来实现时，很多函数都会通过访问这个存储来查找关于HTTP请求的信息。但就像那些过度依赖于全局变量的程序一样，这也会导致一种不健康的“超距作用”，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。因此，在线程的标识需要改变的场景（比如需要使用工作线程时），这些函数的行为就会变得诡异莫测。</p>
<p>Go语言鼓励一种更简单的编程风格，其中，能影响一个函数行为的参数应当是显式指定的。这不仅让程序更易阅读，还让我们能自由地把一个函数的子任务分发到多个不同的goroutine而无需担心这些goroutine的标识。</p>
<p>你现在已经学习了写Go程序所需的所有语言特性。在接下来的两章中，我们将回退一步，从一个更大的尺度去了解支撑编程的一些实践和工具比如如何把一个项目分为多个包，如何获取、编译、测试、归档、分享这些包，以及对这些包进行基准测试、性能分析。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go程序设计语言/" rel="tag"># Go程序设计语言</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/13/第4章-使用函数/" rel="next" title="第4章 使用函数">
                <i class="fa fa-chevron-left"></i> 第4章 使用函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/14/第10章-包和go工具/" rel="prev" title="第10章 包和go工具">
                第10章 包和go工具 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#竞态"><span class="nav-number">1.</span> <span class="nav-text">竞态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#互斥锁：sync-Mutex"><span class="nav-number">2.</span> <span class="nav-text">互斥锁：sync.Mutex</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#读写互斥锁：sync-RWMutex"><span class="nav-number">3.</span> <span class="nav-text">读写互斥锁：sync.RWMutex</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存同步"><span class="nav-number">4.</span> <span class="nav-text">内存同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#延迟初始化：sync-0nce"><span class="nav-number">5.</span> <span class="nav-text">延迟初始化：sync.0nce</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#竞态检测器"><span class="nav-number">6.</span> <span class="nav-text">竞态检测器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：并发非阻塞缓存"><span class="nav-number">7.</span> <span class="nav-text">示例：并发非阻塞缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#goroutine与线程"><span class="nav-number">8.</span> <span class="nav-text">goroutine与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可增长的栈"><span class="nav-number">8.1.</span> <span class="nav-text">可增长的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutine调度"><span class="nav-number">8.2.</span> <span class="nav-text">goroutine调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GOMAXPROCS"><span class="nav-number">8.3.</span> <span class="nav-text">GOMAXPROCS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutine没有标识"><span class="nav-number">8.4.</span> <span class="nav-text">goroutine没有标识</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
