<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go程序设计语言">
<meta property="og:type" content="article">
<meta property="og:title" content="第12章 反射">
<meta property="og:url" content="http://yoursite.com/2021/09/14/第12章-反射/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-01-20T09:54:31.228Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第12章 反射">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">






  <link rel="canonical" href="http://yoursite.com/2021/09/14/第12章-反射/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第12章 反射 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/14/第12章-反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第12章 反射

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-14 10:51:13" itemprop="dateCreated datePublished" datetime="2021-09-14T10:51:13+08:00">2021-09-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-01-20 17:54:31" itemprop="dateModified" datetime="2022-01-20T17:54:31+08:00">2022-01-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">21k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">19 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>Go语言提供了一种机制，在编译时不知道类型的情况下，可更新变量、在运行时查看值、调用方法以及直接对它们的布局进行操作，这种机制称为反射（reflection）。反射也让我们可以把类型当做头等值。</p>
<p>本章将探讨Go语言的反射功能以及它如何增强语言的表达能力，特别是它在实现两个重要API中的关键作用。这两个API分别是fmt包提供的字符串格式化功能，以及 encoding/json和encoding/xml这种包提供的协议编码功能。反射在text/template和html/template包提供的模板机制（参见4.6节）中也很重要。另外，反射的推导比较复杂，也不是为了随意使用设计的，因此尽管这些包使用反射来实现，但它们并没有在自己的API中暴露反射。</p>
<h1 id="为什么使用反射"><a href="#为什么使用反射" class="headerlink" title="为什么使用反射"></a>为什么使用反射</h1><p>有时我们需要写一个函数有能力统一处理各种值类型的函数，而这些类型可能无法共享同一个接口，也可能布局未知，也有可能这个类型在我们设计函数时还不存在，甚至这个类型会同时存在上面三种问题。</p>
<p>一个熟悉的例子是fmt.printf中的格式化逻辑，它可以输出任意类型的任意值，甚至是用户自定义的一个类型。让我们先尝试用我们已学到的知识来实现一个类似的函数。为了简化起见，该函数只接受一个参数，并且与fmt.sprint一样返回一个字符串，所以我们称这个函数为Sprint。</p>
<p>我们先用一个类型分支来判断这个参数是否定义了一个string方法，如果已定义则直接调用它。然后添加一些switch分支来判断参数的动态类型是否是基本类型（比如string、int、bool等），再对每种类型采用不同的格式化操作。</p>
<p>但我们如何处理类似[]float64、map[string][]string的其他类型呢？可以添加更多的分支，但这样的类型有无限种。更何况还有自己命名的类型，比如url.values？因为即使我们有一个分支来处理map[string][]string （ur1.vallues的底层类型），这个分支仍然不会处理url.values，因为这两个类型不是完全一致的。更何况根本不可能引人url.Values的处理分支？因为这会导致库依赖于库的客户（即循环引用）。</p>
<p>当我们无法透视一个未知类型的布局时，这段代码就无法继续，这时我们就需要反射了。</p>
<h1 id="reflect-Type和reflect-value"><a href="#reflect-Type和reflect-value" class="headerlink" title="reflect.Type和reflect.value"></a>reflect.Type和reflect.value</h1><p>反射功能由reflect包提供，它定义了两个重要的类型：Type和Value。Type表示Go语言的一个类型，它是一个有很多方法的接口，这些方法可以用来识别类型以及透视类型的组成部分，比如一个结构的各个字段或者一个函数的各个参数。reflect.Type接口只有一个实现，即类型描述符（见7.5节），接口值中的动态类型也是类型描述符。</p>
<p>reflect.Type0f函数接受任何的interface{}参数，并且把接口中的动态类型以reflect. Type形式返回。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t ：=reflect.Type0f（<span class="number">3</span>）<span class="number">11</span>-个reflect.Type</span><br><span class="line">fmt.Println(t.String())<span class="comment">//“int"</span></span><br><span class="line">fmt. Println(t)</span><br><span class="line"><span class="comment">//"int'</span></span><br></pre></td></tr></table></figure></p>
<p>上面的Type0f（3）调用把数值3赋给interface{}参数。回想一下7.5节的内容，把一个具体值赋给一个接口类型时会发生一个隐式类型转换，转换会生成一个包含两部分内容的接口值：动态类型部分是操作数的类型（int），动态值部分是操作数的值（3）。<br>因为reflect.Type0f返回一个接口值对应的动态类型，所以它返回总是具体类型（而不是接口类型）。比如下面的代码输出的是<code>**0s.File</code>而不是”io.writer”。后面我们会看到如何让reflect.Type也表示一个接口类型。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = os.stdout</span><br><span class="line">fmt Println(reflect.Type0f(w))<span class="number">1</span>/<span class="string">"*os.File"</span></span><br></pre></td></tr></table></figure></p>
<p>注意，reflect.Type满足fmt.stringer。因为输出一个接口值的动态类型在调试和日志中很常用，所以fmt.Printf提供了一个简写方式%T，内部实现就使用了reflect.Type0f：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%T\n"</span>，<span class="number">3</span>)<span class="comment">//"int"</span></span><br></pre></td></tr></table></figure></p>
<p>reflect包的另一个重要类型就是Value。reflect.value可以包含一个任意类型的值。reflect.Value0f函数接受任意的interface{}并将接口的动态值以reflect.value的形式返回。与reflect.Type0f类似，reflect.value0f的返回值也都是具体值，不过reflect.value也可以包含一个接口值。</p>
<p>另一个与reflect.Type类似的是，reflect.Value也满足fmt.stringer，但除非Value包含的是一个字符串，否则string方法的结果仅仅暴露了类型。通常，你需要使用fmt包的%v功能，它对reflect.value会进行特殊处理。</p>
<p>调用Value的Type方法会把它的类型以reflect.Type方式返回：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t:=v.Type()</span><br><span class="line"><span class="comment">//一个reflect.Type</span></span><br><span class="line">fmt.<span class="built_in">println</span>(t.<span class="keyword">string</span>())<span class="comment">//"int"</span></span><br></pre></td></tr></table></figure></p>
<p>reflect.valueof的逆操作是reflect.value.Interface方法。它返回一个interface{}接口值，与reflct.Value包含同一个具体值。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v :=reflect.value0f(<span class="number">3</span>) <span class="comment">// a reflect.value</span></span><br><span class="line">x:=v.Interface()</span><br><span class="line">an <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">i :=x.(<span class="keyword">int</span>)</span><br><span class="line">an <span class="keyword">int</span></span><br><span class="line">| fmt.Printf(<span class="string">"%d\n"</span>，i) <span class="string">"3"</span></span><br></pre></td></tr></table></figure></p>
<p>reflect.Value和interface{}都可以包含任意的值。二者的区别是空接口（interface{}）隐藏了值的布局信息、内置操作和相关方法，所以除非我们知道它的动态类型，并用一个类型断言来渗透进去（上面的代码就用了类型断言），否则我们对所包含值能做的事情很少。作为对比，Value有很多方法可以用来分析所包含的值，而不用知道它的类型。使用这些技术，我们可以第二次尝试写一个通用的格式化函数，它称为format.Any。</p>
<p>不用类型分支，我们用reflect.value的Kind方法来区分不同的类型。尽管有无限种类型，但类型的分类（kind）只有少数几种：基础类型Bool、String以及各种数字类型；聚合类型Array和Struct；引用类型chan、Func、Ptr、Slice和Map、接口类型Interface；最后还有Invalid类型，表示它们还没有任何值。（reflect.Value的零值就属于Invalid类型。）</p>
<p>到现在为止，该函数把每个值当做一个没有内部结构且不可分割的物体（所以才叫formatAtom）。对于聚合类型（结构体和数组）以及接口，它只输出了值的类型；对于引用类型（通道、函数、指针、slice和map），它输出了类型和以十六进制表示的引用地址。这个结果仍然不够理想，但确实是一个很大的进步。因为Kind只关心底层实现，所以format.Any对命名类型的效果也很好。比如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">varxint64=<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d.time.Duration = <span class="number">1</span> * time.Nanosecond</span><br><span class="line">fmt.Println(format.Any(x))</span><br><span class="line"><span class="comment">//"1"</span></span><br><span class="line">fmt.Println(format.Any(d))</span><br><span class="line"><span class="comment">// "1"</span></span><br><span class="line">fmt. Println(format.Any([]<span class="keyword">int64</span>&#123;x&#125;))</span><br><span class="line"><span class="comment">// "[]int64 0x8202b87b0"</span></span><br><span class="line">fmt.Println(format.Any([jtime.Duration&#123;d&#125;))<span class="number">1</span>/ <span class="string">"[]time.Duration ex8202b87ee"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Display：一个递归的值显示器"><a href="#Display：一个递归的值显示器" class="headerlink" title="Display：一个递归的值显示器"></a>Display：一个递归的值显示器</h1><p>接下来我们看一下如何改善组合类型的显示。这次，我们不再实现一个fmt.sprint，而是实现一个称为Display的调试工具函数，这个函数对给定的任意一个复杂值x，输出这个复杂值的完整结构，并对找到的每个元素标上这个元素的路径。下面先看一个例子。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e,_ :=eval.Parse(<span class="string">"sqrt(A/pi)"</span>)</span><br><span class="line">Display(<span class="string">"e"</span>, e)</span><br></pre></td></tr></table></figure></p>
<p>在上面的调用中，Display的参数是一个从表达式求值器生成的语法树（参考7.9节）。Display的输出如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Display e (eval.call):</span><br><span class="line">e.fn = <span class="string">"sqrt'</span></span><br><span class="line"><span class="string">e.args[0].type = eval.binary</span></span><br><span class="line"><span class="string">e.args[0].value.op=47</span></span><br><span class="line"><span class="string">e.args[0].value.x.type=eval.Var</span></span><br><span class="line"><span class="string">e.args[0].value.x.value="</span>A<span class="string">"</span></span><br><span class="line"><span class="string">e.args[0].value.y.type = eval.Var</span></span><br><span class="line"><span class="string">e.args[e].value.y.value =“pi'</span></span><br></pre></td></tr></table></figure></p>
<p>我们应当尽可能避免在包的API里边暴露反射相关的内容。我们将定义一个未导出的函数display来做真正的递归处理，再暴露Display，而Display则只是一个简单的封装，并且接受一个interface{}参数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch12/display</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Display</span><span class="params">(name <span class="keyword">string</span>, x <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"Display %s(%T):\n"</span>,name,x)</span><br><span class="line">display(name, reflect.Value0f(x))</span><br></pre></td></tr></table></figure></p>
<p>在display中，我们使用之前定义的formatAtom函数来输出基础值（基础类型、函数和通道），使用reflect.value的一些方法来递归展示复杂类型的每个组成部分。当递归深入时，path字符串（之前用来表示起始值，比如“e”）会增长，以表示如何找到当前值（比如”e.args[0].value”)。</p>
<p>接下来将对这些分支逐一讲解。</p>
<p>slice与数组：两者的逻辑一致。Len方法会返回slice或者数组中元素的个数，Index（i）会返回第1个元素，返回的元素类型为reflect.value（如果i越界会崩溃）。这两个方法与内置的len（a）和a[i]序列操作类似。在每个序列元素上递归调用了display函数，只是在路径后边加上了”[i]”。<br>尽管reflect.value有很多方法，但对于每个值，只有少量的方法可以安全调用。比如，Index方法可以在s1ice、Array、string类型的值上安全调用，但对于其他类型则会崩溃。</p>
<p>结构体：NumField方法可以报告结果中的字段数，Field（i）会返回第i个字段，返回的字段类型为reflect.value。字段列表包括了从匿名字段中做了类型提升的字段。要追加一个类似”.f”的字段选择标记到路径中，我们必须先获得结构体的reflect.Type才能获到第i个字段的名称。</p>
<p>map：MapKeys方法返回一个元素类型为reflect.value的slice，每个元素都是一个map的键。与平常遍历map的结果类似，顺序是不固定的。MapIndex（key）返回key对应的值。我们追加下标记号“[key]”到路径中。（此处忽略了一些情形。map的键类型有可能超出formatAtom能处理好的类型，比如数组、结构体、接口都可以是合法的字典键。在练习12.1 中会有输出完整键的内容。）</p>
<p>指针：Elem方法返回指针指向的变量，同样也是以reflect.Value类型返回。这个方法在指针是nil时也能正确处理，但返回的结果属于Invalid类型，所以我们用IsNil来显式检测空指针，方便输出一条更合适的消息。为了避免二义性，在路径前加了一个**，外边再加上一对圆括号。<br>接口：我们再次使用IsNil来判断接口是否为空，如果非空，我们通过v.Elem（）来获取动态值，进一步输出它的类型和值。<br>既然Display函数完成了，接下来我们就实际使用一下。下面的Movie类型引自4.5节，但略有修改：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title, Subtitle <span class="keyword">string</span></span><br><span class="line">Year</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">Color</span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">Actor</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">Oscars</span><br><span class="line">[]<span class="keyword">string</span></span><br><span class="line">Sequel</span><br><span class="line">*<span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面声明这个类型的一个值，并查看Display如何处理这个值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">strangelove := Movie&#123;</span><br><span class="line">Title: <span class="string">"Dr. Strangelove"</span>,</span><br><span class="line">Subtitle: <span class="string">"How I Learned to stop Worrying and Love the Bomb"</span>,</span><br><span class="line">Year:</span><br><span class="line"><span class="number">1964</span>，</span><br><span class="line">Color: <span class="literal">false</span>,</span><br><span class="line">Actor: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Dr. Strangelove"</span>:</span><br><span class="line"><span class="string">"Peter Sellers"</span>,</span><br><span class="line"><span class="string">"Grp. Capt. Lionel Mandrake"</span>: <span class="string">"Peter Sellers"</span></span><br><span class="line"><span class="string">"Pres. Merkin Muffley"</span>:</span><br><span class="line"><span class="string">"Peter Sellers"</span>,</span><br><span class="line"><span class="string">"Gen. Buck Turgidson"</span>:</span><br><span class="line"><span class="string">"George c. Scott"</span>,</span><br><span class="line"><span class="string">"Brig. Gen. Jack D. Ripper"</span>: <span class="string">"Sterling Hayden"</span>,</span><br><span class="line">^Maj. T.J. <span class="string">"King"</span> Kong:</span><br><span class="line"><span class="string">"Slim Pickens"</span>,</span><br><span class="line">&#125;，</span><br><span class="line">Oscars:[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"Best Actor (Nomin.)"</span>,</span><br><span class="line"><span class="string">"Best Adapted Screenplay (Nomin.)"</span>,</span><br><span class="line"><span class="string">"Best Director (Nomin.)"</span>,</span><br><span class="line"><span class="string">"Best Picture (Nomin.)"</span>,</span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure></p>
<p>调用Display（”strangelove”，strangelove）会输出：</p>
<p>我们可以使用Display来显示标准库类型的内部结构，比如<code>*os.File</code>：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Display(<span class="string">"os.Stderr"</span>, os.Stderr)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">/显示os.stderr （*os.File）：</span><br><span class="line"><span class="comment">// (*(*os.Stderr).file).fd=2</span></span><br><span class="line"><span class="comment">//(*(*os.Stderr).file).name ="/dev/stderr"</span></span><br><span class="line"><span class="comment">// (*(*0s.Stderr).file).nepipe=e</span></span><br></pre></td></tr></table></figure></p>
<p>注意，即使非导出字段在反射下也是可见的。当然，这个例子的输出在各个平台上可能会有差异，也可能随着库的演进而改变。（毕竟把字段设为私有是由原因的！）<br>我们还可以把Display作用在reflect.value上，并且观察它如何遍历<code>*os.File</code>的类型描述符的内部结构。调用<code>Display（&quot;rv&quot;，reflect.value0f（os.stderr））</code>的输出如下所示，当然，每人得到的结果可能会有不同：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Display rV (reflect.value):</span><br><span class="line">(*rV.typ).size=<span class="number">8</span></span><br><span class="line">(*rV.typ).hash = <span class="number">871609668</span></span><br><span class="line">(*rV.typ).align↵<span class="number">8</span></span><br><span class="line">(*rv.typ).fieldAlign=<span class="number">8</span></span><br><span class="line">(*rV.typ).kind<span class="number">-22</span></span><br><span class="line">(*(*rV.typ).<span class="keyword">string</span>)=<span class="string">"*os.File"</span></span><br><span class="line">(*(*(*rv.typ).uncommonType).methods[e].name)=<span class="string">"Chdir"</span></span><br><span class="line">(*&lt;*&lt;*(*/.typ).uncommonType).methods[e.mtyp).<span class="keyword">string</span>)=<span class="string">"func() error'</span></span><br><span class="line"><span class="string">(*(*(*&lt;*4.typ).uncommonType).methods[e].typ).string). "</span><span class="function"><span class="keyword">func</span><span class="params">(*os.File)</span><span class="title">error</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>注意如下两个例子的差异：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;=<span class="number">3</span></span><br><span class="line">Display(<span class="string">"i"</span>，i)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//显示i（int）：</span></span><br><span class="line"><span class="comment">//i=3</span></span><br><span class="line">Display(<span class="string">"&amp;i"</span>，&amp;i)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//显示&amp;i（*interface &#123;&#125;）：</span></span><br><span class="line"><span class="comment">//(*&amp;i).type=int</span></span><br><span class="line"><span class="comment">//(*&amp;i).value=3</span></span><br></pre></td></tr></table></figure></p>
<p>在第一个例子中，Display调用reflect.Value0f（i），返回值的类型为Int。正如12.2节提到的，因为reflect.value0f从接口值中提取值部分，所以它永远返回一个具体类型的Value.<br>在第二个例子中，Display调用reflect.Valuef（&amp;i），其返回值的类型为Ptr，并且是一个指向i的指针。在Display函数的Ptr分支中，会调用这个值的Elem方法，返回一个代表变量1的Value，其类型为Interface。类似这种间接获得的Value可以代表任何值，包括接口。这时display函数递归调用自己，输出接口的动态类型和动态值。<br>在当前的实现中，Display在对象图中存在循环引用时不会自行终止，比如处理一个首尾相接的链表时：</p>
<p>Display输出了一个持续增长的展开式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Display c (display.cycle):</span><br><span class="line">c.Value =<span class="number">42</span></span><br><span class="line">(*c.Tail).Value =<span class="number">42</span></span><br><span class="line">(*(*c.Tail).Tail).Value =<span class="number">42</span></span><br><span class="line">(*(*(*c.Tail).Tail).Tail).Value=<span class="number">42</span></span><br><span class="line">..无穷无尽..</span><br></pre></td></tr></table></figure></p>
<p>很多Go程序都至少包含一些循环引用的数据。让Display能鲁棒地处理这些循环引用要一些小技巧，需要记录所有曾经被访问过的引用，当然成本也不低。一个通用的解决方案需要unsafe语言特性，13.3节将介绍这个特性。</p>
<p>循环引用在fmt.sprinf中不构成一个大问题，因为它很少尝试输出整个结构体。比如，当它遇到一个指针时，它会输出指针的数字值，这样就打破了循环引用。但如果遇到一个slice或者map包含自身，它还是会卡住，只是不值得为了这种罕见的案例而去承担处理循环引用的成本。<br>练习12.1：扩展Display，让它可以处理map中键为结构体或者数组的情形。</p>
<p>练习12.2：通过限制递归的层数，让Display能安全处理循环引用的数据结构。（在13.3节中，我们可以看到另外一个检测循环引用的方法。）</p>
<h1 id="示例：编码S表达式"><a href="#示例：编码S表达式" class="headerlink" title="示例：编码S表达式"></a>示例：编码S表达式</h1><p>Display是一个用于显示数据结构的调试例程，但是只要对它稍加修改，就可以用它来对任意Go对象进行编码或编排，使之成为适用于进程间通信的可移植记法中的消息。<br>正如我们在4.5节见到的，Go的标准库支持各种格式，包括JSON、XML和ASN.1。另一种广泛使用的格式是Lisp语言中的S表达式。与其他格式不同的是，S表达式还没被Go标准库支持，这是因为尽管有几次标准化的尝试并存在很多实现，但它们仍然没有被广泛接受的严格定义。<br>在本节中，我们会定义一个包，它使用S表达式来编码任意的Go对象，这个S表达式需要支持下面的表达式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span></span><br><span class="line">integer</span><br><span class="line"><span class="string">"hello"</span></span><br><span class="line"><span class="keyword">string</span>（转义方法与Go一致）</span><br><span class="line">foc</span><br><span class="line">symbol （直接使用名字，不加引号）</span><br><span class="line">(<span class="number">123</span>)</span><br><span class="line">list （用括号括起来的零个及以上元素）</span><br></pre></td></tr></table></figure></p>
<p>布尔值一般用符号t表示真，用空列表（）或者符号nil表示假，但为了简化起见，这个实现直接忽略布尔值。通道和函数也被忽略了，因为它们的状态对于反射来说是不透明的。这个实现还忽略了实数、复数和接口，在练习12.3中我们会加上这些支持。</p>
<p>我们将按如下思路来把Go语言的值编码为S表达式。整数和字符串的编码方式是显而易见的。空值直接编码为符号nil，数组和slice则用列表记法来编码。</p>
<p>结构被编码为一个关于字段绑定（field binding）的列表，每个字段绑定都是一个两个元素的列表，其中第一个元素（使用符号）是字段名，第二个元素是字段值。map也编码为元素对的列表，每个元素对都是map中一项的键和值。按照传统，S表达式使用形式为（key.value）的单个构造单元（cons cell）来表示键值对，而不是用双元素的列表，但为了简化解码过程，我们将忽略带“.”的列表表示法。</p>
<p>编码用如下的单个递归调用函数encode来实现。它的结构与上一节的Display在本质上</p>
<p>下面是12.3节的strangelove应用Marshal后的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((Title &quot;Dr. Strangelove&quot;) (Subtitle &quot;How I Learned to stop Worrying and Lo</span><br><span class="line">ve the Bomb&quot;) (Year 1964) (Actor ((&quot;Grp.Capt. Lionel Mandrake&quot; &quot;Peter Sell</span><br><span class="line">ers&quot;)(&quot;Pres. Merkin Muffley&quot; &quot;Peter Sellers&quot;)(&quot;Gen. Buck Turgidson&quot; &quot;Geor</span><br><span class="line">ge c. Scott&quot;)(&quot;Brig. Gen. Jack D. Ripper&quot; &quot;Sterling Hayden&quot;) (&quot;Maj.T.J.\</span><br><span class="line">&quot;King\&quot; Kong&quot;“Slim Pickens&quot;)(&quot;Dr. Strangelove&quot; &quot;Peter Sellers&quot;))) (Oscars</span><br><span class="line">(&quot;Best Actor (Nomin.)&quot; &quot;Best Adapted Screenplay (Nomin.)&quot;&quot;Best Director (N</span><br><span class="line">omin.)&quot; &quot;Best Picture (Nomin.)&quot;))(Sequel nil))</span><br></pre></td></tr></table></figure></p>
<p>整个输出都在一行且使用了最少的空格数，导致读起来很困难。根据S表达式的习惯手动格式化后的结果如下所示。把编写S表达式的美化打印器留作练习（有点挑战），从gopl.io上可以下载一个简单的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">((Title &quot;Dr. Strangelove&quot;)</span><br><span class="line">(subtitle &quot;How I Learned to Stop Worrying and Love the Bomb&quot;)</span><br><span class="line">(Year 1964)</span><br><span class="line">(Actor ((&quot;Grp. capt. Lionel Mandrake&quot; &quot;Peter Sellers&quot;)</span><br><span class="line">(&quot;Pres. Merkin Muffley&quot; &quot;Peter Sellers&quot;)</span><br><span class="line">(&quot;Gen. Buck Turgidson&quot; &quot;George c. Scott&quot;)</span><br><span class="line">(&quot;Brig. Gen. Jack D. Ripper&quot; &quot;Sterling Hayden&quot;)</span><br><span class="line">(&quot;Maj.T.J.\&quot;King\&quot;Kong&quot; &quot;Slim Pickens&quot;)</span><br><span class="line">(&quot;Dr. Strangelove&quot; &quot;Peter Sellers&quot;)))</span><br><span class="line">(Oscars (&quot;Best Actor (Nomin.)&quot;</span><br><span class="line">&quot;Best Adapted Screenplay (Nomin.)&quot;</span><br><span class="line">&quot;Best Director (Nomin.)&quot;</span><br><span class="line">&quot;Best Picture (Nomin.)&quot;))</span><br><span class="line">(Sequel nil))</span><br></pre></td></tr></table></figure></p>
<p>与fmt.print、json.Marshal、Display这些函数类似，sexpr.Marshal在遇到循环应用的数据时也会无限循环。</p>
<p>12.6节会概述S表达式解码函数的实现，但在那之前，我们需要先了解一下如何用反射来更新程序中的变量。</p>
<p>练习12.3：实现encode函数缺失的功能。把布尔值编码为t和nil，浮点数则用Go语言的表示法，像1+2i这种复数则编码为#C（1.02.8）。接口编码为成对的类型名和值，比如（”[]int”（123）），但要注意这个方法是有二义性的，因为reflect.Type.string方法可能会对不同的类型生成同样的字符串。</p>
<p>练习12.4：修改encode函数，输出如上所示的美化后的S表达式。</p>
<p>练习12.5：改写encode函数，从输出S表达式改为输出JSON。使用标准库的解码器json.Unmarshal来测试编码器。</p>
<p>练习12.6：改写encode函数，优化输出，如果字段值是其类型的零值则不须编码。练习12.7：参考json.encoder（参见4.5节）的风格，创建一个S表达式编码器的流式API。</p>
<h1 id="使用reflect-value来设置值"><a href="#使用reflect-value来设置值" class="headerlink" title="使用reflect.value来设置值"></a>使用reflect.value来设置值</h1><p>到现在为止，在程序中反射还只用来解析变量值。而本节的重点则是如何改变值。</p>
<p>回想一下Go语言的表达式，比如x、x.f[1]、<code>*p</code>这样的表达式表示一个变量，而x+1、 f（2）之类的表达式则不表示变量。一个变量是一个可寻址的存储区域，其中包含了一个值，并且它的值可以通过这个地址来更新。</p>
<p>对reflect.Value也有一个类似的区分，某些是可寻址的，而其他的并非如此。比如如下的变量声明：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x:=<span class="number">2</span></span><br><span class="line"><span class="comment">//值类型变量？</span></span><br><span class="line">a :=reflect.Value0f(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">no</span><br><span class="line">b :=reflect.Value0f(x)</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">no</span><br><span class="line">c:=reflect.Value0f(&amp;x)</span><br><span class="line"><span class="comment">//&amp;x</span></span><br><span class="line">*<span class="keyword">int</span></span><br><span class="line">no</span><br><span class="line">d:=c.Elem()</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">yes(x)</span><br></pre></td></tr></table></figure></p>
<p>a里边的值是不可寻址的，它包含的仅仅是整数2的一个副本。b也是如此。c里边的值也是不可寻址的，它包含的是指针&amp;x的一个副本。事实上，通过reflect.valueof（x）返回的 reflect.value都是不可寻址的。但d是通过对c中的指针提领得来的，所以它是可寻址的。可以通过这个方法，调用reflect.valueOf（&amp;x）.Elem（）来获得任意变量x可寻址的Value值。可以通过变量的CanAddr方法来询问reflect.Value变量是否可寻址：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(a.canAddr())<span class="comment">//"false"</span></span><br><span class="line">fmt.Println(b.canAddr())<span class="comment">// "false"</span></span><br><span class="line">fmt.Println(c.canAddr())<span class="number">1</span>/<span class="string">"false'</span></span><br><span class="line"><span class="string">fmt. Println(d.canAddr())//"</span><span class="literal">true</span><span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以通过一个指针来间接获取一个可寻址的reflect.value，即使这个指针是不可寻址的。可寻址的常见规则都在反射包里边有对应项。比如，slice的脚标表达式e[i]隐式地做了指针去引用，所以即使e是不可寻址的，这个表达式仍然是可寻址的。类似地，reflect.value0f（e）.Index（i）代表一个变量，尽管reflect.Value0f（e）不是可寻址的，这个变量也是可寻址的。</p>
<p>从一个可寻址的reflect.value（）获取变量需要三步。首先，调用Addr（），返回一个Value，其中包含一个指向变量的指针，接下来，在这个Value上调用Interface（），会返回一个包含这个指针的interface{}值。最后，如果我们知道变量的类型，我们可以使用类型断言来把接口内容转换为一个普通指针。之后就可以通过这个指针来更新变量了：</p>
<p>还可以直接通过可寻址的reflect.value来更新变量，不用通过指针，而是直接调用reflect.value.Set方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.set(reflect.Value0f(<span class="number">4</span>))</span><br><span class="line">fmt.Println(x)<span class="comment">//"4"</span></span><br></pre></td></tr></table></figure></p>
<p>平常由编译器来检查的那些可赋值性条件，在这种情况下则是在运行时由set方法来检查。上面的变量和值都是int类型，但如果变量类型是int64，这个程序就会崩溃。所以确保这个值对于变量类型是可赋值的是很重要的一件事。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.Set（reflect.value0f（<span class="keyword">int64</span>（<span class="number">5</span>）））<span class="comment">//崩溃：int64不可赋值给int</span></span><br></pre></td></tr></table></figure></p>
<p>当然，在一个不可寻址的reflect.value上调用set方法也会崩溃：<br>x:=2<br>b :=reflect.Value0f(x)<br>b.Set（reflect.Value0f（3））//崩溃：在不可寻址的值上使用Set<br>我们还有为一些基本类型特化的Set变种：SetInt、SetUint、 Setstring、 SetFloat等：d :=reflect.Value0f(&amp;x).Elem()<br>d.SetInt(3)<br>fmt.Print1n(x)//“3’<br>这些方法还有一定程度的容错性。只要变量类型是某种带符号的整数，比如SetInt，甚至可以是底层类型为带符号整数的命名类型，都可以成功。如果值太大了还会无提示地截断它。但需要注意的是，在指向interface{}变量的reflect.value上调用setInt会奔溃（尽管使用Set就没有问题）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">x:=<span class="number">1</span></span><br><span class="line">rx:=reflect.value0f(&amp;x).Elem()</span><br><span class="line">rx.SetInt(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//0K,x=2</span></span><br><span class="line">rx.Set(reflect.Value0f(<span class="number">3</span>))</span><br><span class="line"><span class="comment">//0K,x=3</span></span><br><span class="line">rx.SetString(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">//崩溃：字符串不能赋给整数</span></span><br><span class="line">rx.Set（reflect.Value0f（<span class="string">"hello"</span>））<span class="comment">//崩溃：字符串不能赋给整数</span></span><br><span class="line"><span class="keyword">var</span> y <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">ry := reflect.value0f(&amp;y).Elem()</span><br><span class="line">ry.SetInt(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//崩溃：在指向接口的Value上调用SetInt</span></span><br><span class="line">ry.Set(reflect.Value0f(<span class="number">3</span>))</span><br><span class="line"><span class="comment">// oK,y = int(3)</span></span><br><span class="line">ry.SetString(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">//崩溃：在指向接口的Value上调用SetString</span></span><br><span class="line">ry.Set(reflect.value0f(<span class="string">"hello"</span>)) <span class="comment">//oK,y="hello'</span></span><br></pre></td></tr></table></figure></p>
<p>在把Display作用于os.stdout时，我们发现反射可以读取到未导出结构字段的值，通过Go语言的常规方法这些值是无法读取的。比如os.File结构在类UNIX平台上的fd int字段。但反射不能更新这些值：<br>stdout ：=reflect.value0f（os.stdout）.Elem（）//*os.stdout，-个os.File变量<br>fmt. Println(stdout.Type())<br>//“os.File”<br>fd :=stdout.FieldByName(“fd”)<br>fmt.Print1n(fd.Int())//“1”<br>fd.SetInt(2)<br>//崩溃：未导出字段<br>一个可寻址的reflect.value会记录它是否是通过遍历一个未导出字段来获得的，如果是这样，则不允许修改。所以，在更新变量前用CanAddr来检查并不能保证正确。CanSet方法才能正确地报告一个reflect.value是否可寻址且可更改：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(fd.CanAddr(),fd.CanSet())<span class="comment">//"true false"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="示例：解码S表达式"><a href="#示例：解码S表达式" class="headerlink" title="示例：解码S表达式"></a>示例：解码S表达式</h1><p>对于标准库encoding/…提供的每一个Marshal函数，都有一个对应的Unmarshal函数来做解码。正如在4.5节中所见到的，对于一个包含编码的JSON数据的字节slice，我们可以按下面的方法解码为Movie类型（参见12.3节）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data :=[]<span class="keyword">byte</span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="keyword">var</span> movie Movie</span><br><span class="line">err :=json.Unmarshal(data, &amp;movie)</span><br></pre></td></tr></table></figure></p>
<p>Unmarshal函数使用反射来修改已存在的movie变量的字段，根据Movie类型和输人数据来创建新的map、结构和slice.</p>
<p>现在为S表达式实现一个简单的Unmarshal函数，这个函数与上面使用过的标准json.Unmarshal函数类似，与之前的sexpr.Marshal则正好相反。我必须先提醒你，一个鲁棒且通用的实现需要的代码量远超这个示例能容纳的量（尽管这个示例已经很长了），所以我们必须走一些捷径。我们仅支持了S表达式一个有限的子集，并且没有优雅地处理错误。代码的目的是阐释反射，而不是语法分析。</p>
<p>词法分析程序使用text/scanner包提供的扫描器scanner类型来把输入流分解成一系列的标记（token），包括注释、标识符、字符串字面量和数字字面量。扫描器的Scan方法向前推进扫描位置并且返回下一个标记（类型为rune）。大部分标记（比如）都只包含单个rune，但text/scanner包则用rune类型的小负数区域来表示那些多字符的标记，比如Ident.String、Int。调用Scan会返回标记的类型，调用TokenText则会返回标记对应的文本。</p>
<p>因为一个典型的分析器需要多次分析当前的标记，但Scan方法会一直推进扫描位置，所以我们把扫描器封装到一个lexer辅助类型中，其中保存了scan最近返回的标记。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch12/sexpr</span><br><span class="line"><span class="keyword">type</span> lexer <span class="keyword">struct</span> &#123;</span><br><span class="line">scan scanner.Scanner</span><br><span class="line">token <span class="keyword">rune</span> <span class="comment">//当前标记</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lex*lexer)</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; lex.token = lex.scan.Scan()&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lex*lexer)</span> <span class="title">text</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> lex.scan.TokenText()&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lex*lexer)</span> <span class="title">consume</span><span class="params">(want <span class="keyword">rune</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> lex.token ！=want&#123;<span class="comment">//注意：这不是一个好的错误处理示例</span></span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"got %q, want %q"</span>, lex.text(), want))</span><br><span class="line">lex.next()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>让我们先看一下分析器。它有两个主要的函数，第一个是read，它读取从当前标记开始的S表达式，并更新由可寻址的reflect.value v指向的变量。</p>
<p>S表达式为两个不同的目的使用标识符结构体的字段名和指针的nil值。read函数只处理后一种情形。当它遇到scanner.Ident”nil”时，通过reflect.zero函数把v设置为其类型的零值。对于其他标识符，则产生一个错误。readlist函数（接下来马上要看到）则把标识符处理为结构字段名。</p>
<p>一个’（’标记代表一个列表的开始。第二个函数readlist可把列表解码为多种类型：map、结构体、slice或者数组，主要根据当前正在处理的Go变量类型。对于每种情形，都会循环解析内容直到遇到匹配的右括号，这个是由endlist函数来检测的。</p>
<p>比较有趣的地方是递归。最简单的例子是一个数组。在遇到儿之前，我们使用Index方法来获得数组的一个元素，再递归调用read来填充数据。与其他错误处理类似，如果输人数据导致解码器的下标超过了数组的大小，解码器崩溃。slice的流程与数组比较类似，不同之处是先创建每一个元素变量，再填充，最后追加到slice中。</p>
<p>结构体和map在循环的每一轮中都必须解析一个关于（key value）的子列表。对于结构体，key是用来定位字段的符号。与数组的情形类似，我们通过FieldByName函数来获得结构体字段的现有变量，再递归调用read来填充。对于map，key可以是任何类型。与slice类似，先创建新变量，递归地填充，最后再把新的键值对插入映射表中。</p>
<p>最后，把解析器封装成如下所示的一个导出函数Unmarshal，隐藏了实现中很多不完美之处。比如在解析过程中遇到错误会崩溃，因此unmarshal使用一个延迟调用来从崩溃中恢复（见5.10节），并且返回一条错误消息。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unmarshal解析S表达式数据并且填充到非nil指针out指向的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, out <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(err error)</span></span>&#123;</span><br><span class="line">lex :=&amp;lexer&#123;scan:scanner.scanner&#123;Mode:scanner.GoTokens&#125;&#125;</span><br><span class="line">lex.scan.Init(bytes.NewReader(data))</span><br><span class="line">lex.next（）<span class="comment">//获取第一个标记</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//注意：这不是一个好的错误处理示例</span></span><br><span class="line"><span class="keyword">if</span> x :=<span class="built_in">recover</span>();x!=<span class="literal">nil</span>&#123;.</span><br><span class="line">err = fmt.Errorf(<span class="string">"error at %s:%v"</span>, lex.scan.Position,x)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">read(lex, reflect.Value0f(out).Elem())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个具备用于生产环境的质量的实现对任何的输人都不应当崩溃，而且应当对每次错误详细报告信息，可能的话，应当包含行号或者偏移量。无论如何，我们希望这个示例有助于了解encoding/json这类包的底层机制，以及如何使用反射来填充数据结构。</p>
<p>练习12.8：类似于json.UnMarshal函数，sexpr.Unmarshal函数在解码之前就需要完整的字节slice。仿照json.Decoder，定义一个sexpr.Decoder类型，允许从一个io.Reader接口解码一系列的值。使用这个新类型来重新实现sexpr.Unmarshal。</p>
<p>练习12.9：仿照xm1.Decoder（参考7.14节），写一个基于标记的S表达式解码API。你需要5个类型的标记：Symbol、string、Int、Startlist和Endlist。</p>
<p>练习12.10：扩展sexpr.Unmarshal，以处理练习12.3中按你的答案编码的布尔值、浮点数和接口。（提示：为了解码接口，你需要一个map，其中包含每个支持类型从名字到reflect.Type的映射。）</p>
<h1 id="访问结构体字段标签"><a href="#访问结构体字段标签" class="headerlink" title="访问结构体字段标签"></a>访问结构体字段标签</h1><p>在4.5节我们用结构体字段标签来修改Go结构值的JSON编码方式。json字段标签让我们可以选择其他的字段名以及忽略输出的空字段。本节将讨论如何用反射来获取字段标签。</p>
<p>在一个Web服务器中，绝大部分HTTP处理函数的第一件事就是提取请求参数到局部变量中。我们将定义一个工具函数params.Unpack，使用结构体字段标签来简化HTTP处理程序（参考7.7节）的编写。</p>
<p>首先，展示如何使用这个方法。下面的search函数就是一个HTTP处理函数，它定义一个变量data，data的类型是一个字段与HTTP请求参数对应的匿名结构。结构体的字段标签指定参数名称，这些名称一般比较短，含义也比较模糊，毕竟URL长度有限，不能随便浪费。Unpack函数从请求中提取数据来填充这个结构体，这样不仅可以更方便地访问，还避免了手动转换类型。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gop1.io/ch12/search</span><br><span class="line"><span class="keyword">import</span> <span class="string">"gopl.io/ch12/params'</span></span><br><span class="line"><span class="string">// search用于处理/search URL endpoint.</span></span><br><span class="line"><span class="string">func search(resp http.ResponseWriter, req *http.Request)&#123;</span></span><br><span class="line"><span class="string">var data struct &#123;</span></span><br><span class="line"><span class="string">Labels</span></span><br><span class="line"><span class="string">[]string 'http:"</span><span class="number">1</span><span class="string">"</span></span><br><span class="line"><span class="string">MaxResults int</span></span><br><span class="line"><span class="string">'http:"</span>max</span><br><span class="line">Exact</span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line">http:<span class="string">"x"</span></span><br><span class="line">data.MaxResults=<span class="number">10</span><span class="comment">//设置默认值</span></span><br><span class="line"><span class="keyword">if</span> err := params.Unpack(req, &amp;data);err!=<span class="literal">nil</span>&#123;</span><br><span class="line">http.Error(resp, err.Error(),http.statusBadRequest) <span class="number">1</span>/ <span class="number">4</span>ee</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">//...其他处理代码..</span></span><br><span class="line">fmt.Fprintf(resp,<span class="string">"Search:%+v\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的Unpack函数做了三件事情。首先，调用req.ParseForm（）来解析请求。在这之后，req.Form就有了所有的请求参数，这个方法对HTTPGET和POST请求都适用。</p>
<p>接着，Unpack函数构造了一个从每个有效字段名到对应字段变量的映射。在字段有标签时有效字段名与实际字段名可能会有差别。reflect.Type的Field方法会返回一个reflect.StructField类型，这个类型提供了每个字段的名称、类型以及一个可选的标签。它的Tag字</p>
<p>段类型为reflect.structTag，底层类型为字符串，提供了一个Get方法用于解析和提取对于一个特定键的子串，比如这个例子中用到的http：”<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">gopl.io/ch12/params</span><br><span class="line"><span class="comment">// Unpack从HTTP请求req的参数中提取数据填充到ptr指向结构体的各个字段</span></span><br><span class="line"><span class="comment">// from the HTTP request parameters in req</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unpack</span><span class="params">(req *http.Request, ptr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err :=req.ParseForm();err!=<span class="literal">nil</span>&#123;</span><br><span class="line">returnerr</span><br><span class="line">]</span><br><span class="line"><span class="comment">//创建字段映射表，键为有效名称</span></span><br><span class="line">fields :=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]reflect.value)</span><br><span class="line">v：=reflect.Value0f（ptr）.Elem（）<span class="comment">//结构变量</span></span><br><span class="line">fori:=<span class="number">8</span>;i&lt;v.NumField();i+&#123;</span><br><span class="line">fieldInfo :=v.Type().Field(i)<span class="number">11</span>a reflect.structField</span><br><span class="line">tag :=fieldInfo.Tag</span><br><span class="line"><span class="comment">//areflect.structTag</span></span><br><span class="line">name :=tag.Get(<span class="string">"http"</span>)</span><br><span class="line"><span class="keyword">if</span> name =<span class="string">""</span>&#123;</span><br><span class="line">name = strings.Tolower(fieldlnfo. Name)</span><br><span class="line">fields[name]= v.Field(i)</span><br><span class="line"><span class="comment">//对请求中的每个参数更新结构体中对应的字段</span></span><br><span class="line"><span class="keyword">for</span> name, values :- <span class="keyword">range</span> req.Form &#123;</span><br><span class="line">f :=fields[name<span class="string">'</span></span><br><span class="line"><span class="string">if !f.IsValid()&#123;</span></span><br><span class="line"><span class="string">continue//忽略不能识别的HTTP参数</span></span><br><span class="line"><span class="string">1]</span></span><br><span class="line"><span class="string">for , value := range values &#123;</span></span><br><span class="line"><span class="string">if f.Kind() -- reflect.slice &#123;</span></span><br><span class="line"><span class="string">elem :=reflect.New(f.Type().Elem()).Elem() if err :=populate(elem, value);err!=nil&#123;</span></span><br><span class="line"><span class="string">return fmt.Errorf("%s:%v", name, err) f.Set(reflect.Append(f, elem))</span></span><br><span class="line"><span class="string">&#125;else &#123;</span></span><br><span class="line"><span class="string">if err := populate(f, value);err!=nil&#123;</span></span><br><span class="line"><span class="string">return fmt.Errorf("%s:%v", name,err) &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">return nil</span></span><br></pre></td></tr></table></figure></p>
<p>最后，Unpack遍历HTTP参数中的所有键值对，并且更新对应的结构体字段。注意，同一个参数可能会出现多次。如果有这种情况并且字段是slice类型，则这个参数的所有值都会追加到slice里。如果不是，则这个字段会被多次覆盖，仅有最后一个值才是有效的。<br>populate函数负责从单个HTTP请求参数值填充单个字段v（或者slice字段中的单个元素）。现在，它仅支持字符串、有符号整数和布尔值。支持其他类型则留作练习。</p>
<p>接着把server处理程序添加到一个Web服务器中。下面就是一个典型的交互过程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ go build gopl.io/ch12/search</span><br><span class="line">$ ./search &amp;</span><br><span class="line">$./fetch<span class="string">'http://localhost:12345/search'</span></span><br><span class="line">Search: &#123;Labels:[]MaxResults:1e Exact:<span class="literal">false</span>&#125;</span><br><span class="line">$./fetch<span class="string">'http://localhost:12345/search?l=golang&amp;l=programming</span></span><br><span class="line"><span class="string">Search: &#123;Labels:[golang programming] MaxResults:1e Exact:false&#125;</span></span><br><span class="line"><span class="string">$./fetch'</span>http://localhost:12345/search?l=golang&amp;l=programming&amp;max=100*</span><br><span class="line">Search: &#123;Labels:[golang programming] MaxResults:1e0 Exact:<span class="literal">false</span>&#125;</span><br><span class="line">$./fetch<span class="string">'http://localhost:12345/search?x=true&amp;l=golang&amp;l=programming'</span></span><br><span class="line">Search: &#123;Labels:[golang programming] MaxResults:1e Exact:<span class="literal">true</span>&#125;</span><br><span class="line">$./fetch<span class="string">'http://localhost:12345/search?q=hello&amp;x=123'</span></span><br><span class="line">x:strconv.ParseBool: parsing <span class="string">"123"</span>:invalid syntax</span><br><span class="line">$./fetch<span class="string">'http://localhost:12345/search?q=hello&amp;max=lots'</span></span><br><span class="line">max: strconv.ParseInt: parsing <span class="string">"lots"</span>: invalid syntax</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>练习12.11：写一个与Unpack对应的Pack函数。给定一个结构体的值，Pack应当返回一个URL，这个URL的参数与输人的结构体对应。</p>
<p>练习12.12：扩展字段标签语法来支持参数有效性检验。比如，一个字符串应当是一个有效的email地址或者有效的信用卡号码，一个整数应当是一个有效的美国邮编。修改Unpack函数来支持这些功能。</p>
<p>练习12.13：修改S表达式编码器（参考12.4节）和解码器（参考12.6节），支持 sexpr:”.. ..”形式的字段标签，标签含义同encoding/json包（参考4.5节）。</p>
<h1 id="显示类型的方法"><a href="#显示类型的方法" class="headerlink" title="显示类型的方法"></a>显示类型的方法</h1><p>最后一个反射示例使用reflect.Type来显示一个任意值的类型并枚举它的方法：</p>
<p>reflect.Type和reflect.value都有一个叫作Method的方法。每个t.Method（i）（从reflect.Type调用）都会返回一个reflect.Method类型的实例，这个结构类型描述了这个方法的名称和类型。而每个v.Method（i）（从reflect.value调用）都会返回一个reflect.value，代表一个方法值（6.4节），即一个已绑定接收者的方法。使用reflect.value.ca1l方法可以调用Func类型的Value（为节省版面，这里就不演示了），但这个程序只需要它的类型。下面就是两个类型time.Duration和*strings.Replacer的方法列表：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods. Print(time.Hour)</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">// type time.Duration</span></span><br><span class="line"><span class="comment">// func (time.Duration) Hours() float64</span></span><br><span class="line"><span class="comment">// func (time.Duration) Minutes() float64</span></span><br><span class="line"><span class="comment">// func (time.Duration) Nanoseconds() int64</span></span><br><span class="line"><span class="comment">// func (time.Duration) Seconds() float64</span></span><br><span class="line">II <span class="function"><span class="keyword">func</span> <span class="params">(time.Duration)</span> <span class="title">string</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">methods</span>. <span class="title">Print</span><span class="params">(<span class="built_in">new</span>(strings.Replacer)</span>)</span></span><br><span class="line"><span class="function">//输出：</span></span><br><span class="line"><span class="function">// <span class="title">type</span> *<span class="title">strings</span>.<span class="title">Replacer</span></span></span><br><span class="line"><span class="function">// <span class="title">func</span> <span class="params">(*strings.Replacer)</span> <span class="title">Replace</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">// <span class="title">func</span> <span class="params">(*strings.Replacer)</span> <span class="title">Writestring</span><span class="params">(io.writer, <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>还有很多反射API，但限于篇幅原因，这里不再展示，但之前的示例揭示了反射能做哪些事情。反射是一个功能和表达能力都很强大的工具，但应该谨慎使用它，具体有三个原因。</p>
<p>第一个原因是基于反射的代码是很脆弱的。能导致编译器报告类型错误的每种写法，在反射中都有一个对应的误用方法。编译器在编译时就能向你报告这个错误，而反射错误则要等到执行时才以崩溃的方式来报告，而这可能是代码写好很久以后，甚至是代码开始执行很久以后才会发生的事。</p>
<p>比如，如果readlist函数（参考12.6节）尝试从输人读取一个字符串然后填充一个int类型的变量，那么调用reflect.value.setstring就会崩溃。很多使用反射的程序都有类似的风险，所以对每一个reflect.value都需要仔细注意它的类型、是否可寻址、是否可设置。</p>
<p>回避这种缺陷的最好办法是确保反射的使用完整地封装在包里边，并且如果可能，在包的API中避免使用reflect.value，尽量使用特定的类型来确保输人是合法的值。如果做不到这点，那就需要在每个危险操作前都做额外的动态检查。作为标准库中的一个示例，当fmt.printf遇到操作数类型不合适时，它不会莫名奇妙地崩溃，而是输出一条描述性的错误消息。尽管程序仍然有bug，但定位起来就简单多了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%d%s\n"</span>,<span class="string">"hello"</span>,<span class="number">42</span>)<span class="comment">// "%!d(string=hello) %!s(int=42)"</span></span><br></pre></td></tr></table></figure></p>
<p>反射还降低了自动重构和分析工具的安全性与准确度，因为它们无法检测到类型信息。</p>
<p>避免使用反射的第二个原因是类型其实也算是某种形式的文档，而反射的相关操作则无法做静态类型检查，所以大量使用反射的代码是很难理解的。对于接受interface{}或者reflect.value的函数，一定要写清楚期望的参数类型和其他限制条件（即不变量）。</p>
<p>第三个原因是基于反射的函数会比为特定类型优化的函数慢一两个数量级。在一个典型的程序中，大部分函数与整体性能无关，所以为了让程序更清晰可以使用反射。测试就很合适使用反射，因为大部分测试都使用小数据集。但对于关键路径上的函数，则最好避免使用反射。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go程序设计语言/" rel="tag"># Go程序设计语言</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/14/第11章-测试/" rel="next" title="第11章 测试">
                <i class="fa fa-chevron-left"></i> 第11章 测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/14/第13章-低级编程/" rel="prev" title="第13章 低级编程">
                第13章 低级编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么使用反射"><span class="nav-number">1.</span> <span class="nav-text">为什么使用反射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reflect-Type和reflect-value"><span class="nav-number">2.</span> <span class="nav-text">reflect.Type和reflect.value</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Display：一个递归的值显示器"><span class="nav-number">3.</span> <span class="nav-text">Display：一个递归的值显示器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：编码S表达式"><span class="nav-number">4.</span> <span class="nav-text">示例：编码S表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用reflect-value来设置值"><span class="nav-number">5.</span> <span class="nav-text">使用reflect.value来设置值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#示例：解码S表达式"><span class="nav-number">6.</span> <span class="nav-text">示例：解码S表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问结构体字段标签"><span class="nav-number">7.</span> <span class="nav-text">访问结构体字段标签</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#显示类型的方法"><span class="nav-number">8.</span> <span class="nav-text">显示类型的方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注意事项"><span class="nav-number">9.</span> <span class="nav-text">注意事项</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
