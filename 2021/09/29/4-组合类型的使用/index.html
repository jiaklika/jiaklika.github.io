<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Mastering Go">
<meta property="og:type" content="article">
<meta property="og:title" content="4-组合类型的使用">
<meta property="og:url" content="http://yoursite.com/2021/09/29/4-组合类型的使用/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-11-18T08:15:56.222Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="4-组合类型的使用">
<meta name="twitter:description" content="思考并回答以下问题：">






  <link rel="canonical" href="http://yoursite.com/2021/09/29/4-组合类型的使用/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>4-组合类型的使用 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/29/4-组合类型的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">4-组合类型的使用

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-29 13:43:33" itemprop="dateCreated datePublished" datetime="2021-09-29T13:43:33+08:00">2021-09-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-11-18 16:15:56" itemprop="dateModified" datetime="2021-11-18T16:15:56+08:00">2021-11-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">30k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">27 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>上一章我们讨论了数组、切片、映射、指针、常量、for循环、range关键字的使用，以及处理始建于日期的技巧。这一章我们将探索更加高级的Go特性，比如元组和字符串，标准库strings，switch语句，以及使用struct关键字创建结构体。另外一部分比较重要的内容使用Go实现正则表达式以及模式匹配。完成上面的章节后，我们将实现一个简单的K-V存储。</p>
<p>下面是本章的内容概览：</p>
<ul>
<li>Go结构体和struct关键字</li>
<li>Go元组</li>
<li>Go字符串，runes，字节切片，以及字符串字面量</li>
<li>Go的正则表达式</li>
<li>Go的模式匹配</li>
<li>switch语句</li>
<li>关于标准库strings的使用</li>
<li>计算高精度的PI值</li>
<li>实现一个K-V存储</li>
</ul>
<h1 id="关于组合类型"><a href="#关于组合类型" class="headerlink" title="关于组合类型"></a><span style="color:#339AFF;">关于组合类型</span></h1><p>尽管Go提供的类型是非常方便，快速和灵活的，但是不可能满足开发者所有的需求。Go通过提供结构体来解决此问题，开发者可以实现自定义类型。另外，Go还支持元组操作，意思是允许函数返回多个值，这些值并不需要提前声明结构体存放。</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a><span style="color:#339AFF;">结构体</span></h1><p>数组，切片，映射这类数据结构的确很有用，但是它们不能将多个值聚合到同一个地方。如果你想要将不同类型的不同变量聚合到一个地方以创建一个新的类型，那么结构体会满足你的需要。结构体中的不同元素叫做<strong>结构体的字段</strong>。</p>
<p>本章我们以一个简单的结构体为例来讲解，上一章的sortSlice.go中我们定义过一个结构体：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> aStructure <span class="keyword">struct</span>&#123; </span><br><span class="line">    person <span class="keyword">string</span></span><br><span class="line">    height <span class="keyword">int</span>    </span><br><span class="line">    weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实结构体的字段通常是大写字母开头，这个原因我们将在第六章中具体说明，这个习惯会贯穿本书接下来的内容。</p>
<p>这个结构体有三个字段，分别是<code>person,height,weight</code>。现在，你可以创建一个类型为aStructure的变量了：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 aStructure</span><br></pre></td></tr></table></figure></p>
<p>另外，我们使用<code>.</code>操作符来访问结构体中的字段，例如我们可以使用s1.person来获取person字段的值。</p>
<p>一个结构体字面量可以这样定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 := aStructure&#123;<span class="string">"fmt"</span>,<span class="number">12</span>,<span class="number">-2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而你可能觉得记住结构体中字段的声明顺序实在是太难了，莫慌，我们有另外一种定义结构体字面量的方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1 := aStructure&#123;weight:<span class="number">12</span>, height:<span class="number">-2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式你无须初始化结构体中的所有字段。</p>
<p>现在你已经了解了结构体的基本操作，让我们尝试一些实战性更强的代码吧，这部分代码保存在structures.go中，分为三部分。</p>
<p>第一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> XYZ <span class="keyword">struct</span> &#123;</span><br><span class="line">        X <span class="keyword">int</span></span><br><span class="line">        Y <span class="keyword">int</span></span><br><span class="line">        Z <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s1 XYZ</span><br><span class="line"></span><br><span class="line">    fmt.Println(s1.Y, s1.Z)</span><br></pre></td></tr></table></figure></p>
<p>Go结构体通常来说是定义在main()函数外面的，这样在整个Go package中可以拥有全局的属性，除非你不想让你的结构体在任何地方都被访问到，这种情况下你可以定义局部的结构体。</p>
<p>第二部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 := XYZ&#123;<span class="number">23</span>,<span class="number">12</span>,<span class="number">-2</span>&#125;</span><br><span class="line">p2 := XYZ&#123;Z:<span class="number">12</span>, Y:<span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(p1)</span><br><span class="line">fmt.Println(p2)</span><br></pre></td></tr></table></figure></p>
<p>我们使用两种定义结构体字面量的方式定义了p1与p2，并且打印出来。</p>
<p>最后一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    pSlice := [<span class="number">4</span>]XYZ&#123;&#125;</span><br><span class="line">    pSlice[<span class="number">2</span>] = p1</span><br><span class="line">    pSlice[<span class="number">0</span>] = p2</span><br><span class="line">    fmt.Println(pSlice)</span><br><span class="line">    p2 = XYZ&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(pSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一部分代码中，我们创建了一个结构体数组pSlice，当你将一个结构体分配给结构体数组，那么这个结构体就会被深拷贝至这个数组，这意味着改变原结构体是对数组中的结构体没有影响的，从下面的打印输出中我们能够看出来：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run structures.go</span><br><span class="line">0 0</span><br><span class="line">&#123;23 12 -2&#125;</span><br><span class="line">&#123;0 13 12&#125;</span><br><span class="line">[&#123;0 13 12&#125; &#123;0 0 0&#125; &#123;23 12 -2&#125; &#123;0 0 0&#125;]</span><br><span class="line">[&#123;0 13 12&#125; &#123;0 0 0&#125; &#123;23 12 -2&#125; &#123;0 0 0&#125;]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，结构体中字段的定义顺序是有意义的，简单来说，就算两个结构体拥有相同的字段，但是字段的声明顺序不同，那么这两个结构体也是不相等的。</p>
</blockquote>
<p>从程序输出中我们能够知道，结构体中的变量是初始化为其类型的零值。</p>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a><span style="color:#00ACC1;">结构体指针</span></h2><p>之前的章节我们已经讨论过指针，本节我们会继续指针的讨论并且提供一个与<strong>结构体指针</strong>的示例，pointerStruct.go。</p>
<p>第一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myStructure <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Surname <span class="keyword">string</span></span><br><span class="line">    Height  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createStructure</span><span class="params">(n, s <span class="keyword">string</span>, h <span class="keyword">int32</span>)</span> *<span class="title">myStructure</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">300</span> &#123;</span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;myStructure&#123;n, s, h&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相对于直接初始化一个结构体变量，createStructure()提供了一种更加优雅的方法，不仅能够检查赋予结构体字段的值的正确性和有效性，而且当出问题之后，能够很快找到问题所在。注意一下该函数的命名，命名为NewStructure()是比较妥当的。</p>
<blockquote>
<p>对于有C/C++背景的开发者来说，Go函数返回局部变量的内存地址是很容易理解的，所以Go的这种设计皆大欢喜！</p>
</blockquote>
<p>第二部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retStructure</span><span class="params">(n, s <span class="keyword">string</span>, h <span class="keyword">int32</span>)</span> <span class="title">myStructure</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> h &gt; <span class="number">300</span> &#123;</span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myStructure&#123;n, s, h&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这部分实现了createStructure()的无指针版本，两个函数的效果都是一样的，所以选择哪一种就看开发者的喜好了。其实这两个函数命名为NewStructurePointer()和NewStructure()是比较规范的。</p>
<p>最后一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s1 := createStructure(<span class="string">"Mihalis"</span>,<span class="string">"Tsoukalos"</span>,<span class="number">123</span>)</span><br><span class="line">    s2 := retStructure(<span class="string">"Mihalis"</span>,<span class="string">"Tsoukalos"</span>,<span class="number">123</span>)</span><br><span class="line">    fmt.Println((*s1).Name)</span><br><span class="line">    fmt.Println(s2.Name)</span><br><span class="line">    fmt.Println(s1)</span><br><span class="line">    fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行pointerStruct.go我们得到下面的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run pointerStruct.go</span><br><span class="line">Mihalis</span><br><span class="line">Mihalis</span><br><span class="line">&amp;&#123;Mihalis Tsoukalos 123&#125;</span><br><span class="line">&#123;Mihalis Tsoukalos 123&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过输出你能够发现createStructure()和retStructure()的主要区别，就是前者返回指向结构体的指针，这意味着你在想获取结构体内字段值的时候，就必须先解引用，有些人会觉得这种操作不太优雅。</p>
<p>结构体是一个非常重要的概念，在实战中会经常用到，它能够帮你把很多不同类型的变量聚合到一起，然后依次处理。</p>
<h2 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a><span style="color:#00ACC1;">使用new关键字</span></h2><p>Go支持使用new关键创建新的对象，必须要注意的是，这种方式返回的是对象的指针！</p>
<p>你可以创建一个aStructure类型的变量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pS := <span class="built_in">new</span>(aStructure)</span><br></pre></td></tr></table></figure></p>
<p>执行上述代码后，你得到的是值为nil的对象，并没有初始化。</p>
<blockquote>
<p>new和make最大的区别就是：new返回的是空的内存地址，即没有做初始化。另外，make仅可以用来创建映射，切片和通道，而且并不是返回指针。</p>
</blockquote>
<p>下面的代码将会创建一个指向切片的指针，并且值为nil：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sP := <span class="built_in">new</span>([]aStructure)</span><br></pre></td></tr></table></figure></p>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a><span style="color:#339AFF;">元组</span></h1><p>严格来讲，元组是由多个部分组成的有序列表，最重要的是Go本身不支持元组类型，虽然Go官方并不关心元组，但实际上它提供了元组的某些操作。</p>
<p>有趣的是我们在第一章已经接触过Go的元组操作，像下面的这种操作，使用一条语句获取两个返回值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min, _ := strconv.ParseFloat(arguments[<span class="number">1</span>],<span class="number">64</span>)</span><br></pre></td></tr></table></figure></p>
<p>tuples.go中的代码将会分成三部分来解释Go的元组，请注意下面代码中的函数将返回值以元组的形式返回。</p>
<p>第一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retThree</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x, x*x, -x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>retThree()函数返回了包含三个整数元素的元组，这种能力使得函数能够返回一组数据，而无需将它们聚合到结构体重或者返回一个结构体变量。</p>
<p>在第六章你将会学习到如何给函数的返回值命名，这是一个非常方便的特性。</p>
<p>第二部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(retThree(<span class="number">10</span>))</span><br><span class="line">    n1, n2, n3 := retThree(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(n1, n2, n3)</span><br></pre></td></tr></table></figure></p>
<p>这里我们使用了两次retThree()函数。第一次我没让你并没有将其返回值保存，第二次使用三个变量保存返回值，在Go的术语中这叫做元组赋值，看到这里，你是不是有了一种Go支持元组！的错觉。如果有些返回值你并不关心，可以使用操作符忽略掉它们。要知道，在Go的代码里声明了但是未使用的代码是会导致编译错误的。</p>
<p>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    n1, n2 = n2, n1</span><br><span class="line">    fmt.Println(n1, n2, n3)</span><br><span class="line">    x1,x2,x3 := n1*<span class="number">2</span>, n1*n1, -n1</span><br><span class="line"></span><br><span class="line">    fmt.Println(x1, x2, x3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，依靠这种元组操作，我们无需借助temp变量就可以实现两个数字的交换。</p>
<p>执行tuples.go可得到如下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run tuples.go</span><br><span class="line">20 100 -10</span><br><span class="line">40 400 -20</span><br><span class="line">400 40 -20</span><br><span class="line">800 160000 -400</span><br></pre></td></tr></table></figure></p>
<h1 id="正则表达式与模式匹配"><a href="#正则表达式与模式匹配" class="headerlink" title="正则表达式与模式匹配"></a><span style="color:#339AFF;">正则表达式与模式匹配</span></h1><p>模式匹配在Go中占有重要的地位，是能够根据正则表达式查询出特定的字符集的技术。模式匹配成功后你就可以提取出你想要的字符串，并对其进行替换、删除等进一步操作。</p>
<p>Go标准库中已经帮你设计好了用于正则表达式的包——<code>regexp</code>，我们将会在下面深入讨论。</p>
<blockquote>
<p>当你在代码中使用正则表达式时，定义符合条件的正则表达式是重中之重。</p>
</blockquote>
<h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a><span style="color:#00ACC1;">理论知识</span></h2><p>每一个正则表达式都通过一种叫做有限自动机的状态转换图表，被编译成识别器。一个有限自动机可以使确定性的也可以是不确定性的。不确定性的意思是一种输入可能会产生多种输出状态。识别器是一种程序，它接收一个字符串x并且能够分辨出x是何种语言写的。</p>
<p>语法能够以一种格式化的语言为字符串生成一系列产生式规则，产生式规则描述了根据词法生成有效字符串的方法。语法器只能描述字符串的结构，不能描述一个字符串的含义或者描述该字符串能在什么上下文中用来做什么。要注意，语法是定义或者使用正则表达式的核心。</p>
<blockquote>
<p>尽管正则表达式可以用来解决棘手的问题，但是不要任何问题都使用正则表达式，一定要在正确的地方选择正确的工具！</p>
</blockquote>
<p>接下来的这一小节将会展示三个正则表达式和模式匹配的例子。</p>
<h2 id="简单的正则表达式示例"><a href="#简单的正则表达式示例" class="headerlink" title="简单的正则表达式示例"></a><span style="color:#00ACC1;">简单的正则表达式示例</span></h2><p>本节你将学习从一行文本中选择特定列的技巧。为了让这事儿更有趣，我还会教你如何逐行地读取文本，文本I/O是第8章的内容，你可以参考一下。</p>
<p>本节代码示例selectcolumn.go将会分为4部分阐述，需要至少两个命令行参数进行操作，第一个是你想选择的第几列，第二个是你要处理的文本所在路径。当然，你可以处理多个文件，selectcolumn.go将会帮你一个一个处理。</p>
<p>第一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arguments := os.Args</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arguments) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"usage: use selectColumn column [file1] [file2] [...]\n"</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    temp, err := strconv.Atoi(arguments[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"column value is not an integer"</span>, temp)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    column := temp</span><br><span class="line">    <span class="keyword">if</span> column &lt;<span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Invalid column value"</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断输入的参数数量是否满足要求（<code>len(arguments)&lt;2</code>），然后需要判断输入的column值是否是合法的，即&gt;0。</p>
<p>第二部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, fileName := <span class="keyword">range</span> arguments[<span class="number">2</span>:] &#123;</span><br><span class="line">    fmt.Println(<span class="string">"\t\t"</span>, fileName)</span><br><span class="line">    f, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error opening file %s\n"</span>, err)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.Close()</span><br></pre></td></tr></table></figure></p>
<p>这部分代码判断所给的文件是否存在并且可读，os.Open()用来读取文本文件的。记住，UNIX系统的文件有些你是没有读权限的。</p>
<p>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r := bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    line, err := r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error reading file %s\n"</span>, err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>你将在第8章中学习到<code>bufio.ReadString()</code>函数的机制是读取到参数中的字符就停止，所以<code>bufio.ReadString(&#39;\n&#39;)</code>的意思就是逐行读取文本文件，因为\n在UNIX系统中是换行符。<code>bufio.ReadString()</code>函数返回的是字节切片。</p>
<p>最后一部分代码是：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data := strings.Fields(line)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt; column &#123;</span><br><span class="line">                fmt.Println(data[column<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个程序背后的逻辑是很简单的：逐行读取文本并选择你想要的列。然而，由于你不能确定当前行是否拥有你想要的列，所以你会在输出之前检查一下。其实这是一个非常简单的模式匹配，因为空格天然地充当了每一行中的分隔符。</p>
<p>如果你想要探究更多切分一行文本的技巧，可以查看strings.Fields()的源码，你就会发现该函数基于空白分隔符将一行文本分割成一个字符串切片，空白分隔符是由unicode.IsSpace()定义的。</p>
<p>执行selectcolumn.go的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run selectColumn.go</span><br><span class="line">15/tmp/swtag.log/tmp/adobegc.log </span><br><span class="line">AdobeDjkdgj</span><br><span class="line">Successfully</span><br><span class="line">Initializing</span><br><span class="line">Stream</span><br><span class="line">*AdobeGC</span><br></pre></td></tr></table></figure></p>
<h2 id="高级的正则表达式示例"><a href="#高级的正则表达式示例" class="headerlink" title="高级的正则表达式示例"></a><span style="color:#00ACC1;">高级的正则表达式示例</span></h2><p>本节你将学习到如何在Apache web服务器的日志文件中匹配特定格式的时间与日期字符串。同时，你也会了解到将不同格式的时间与日期写入日志文件中。与上一节一样，我们需要逐行读取Apache日志文件。</p>
<p>本节的代码changeDT.go将分为4部分展示，可以发现changeDT.go是第三章中timeDate.go的升级版本，只不过是使用两个正则表达式匹配不同的时间与日期。</p>
<p>要注意的是不要试图在程序的第一个版本就达到尽善尽美，最好的方法就是小版本快速迭代。</p>
<p>第一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os'</span></span><br><span class="line"><span class="string">"</span>regexp<span class="string">" "</span>strings<span class="string">' "time'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">arguments := os.Args</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arguments)==<span class="number">1</span>&#123;</span><br><span class="line">fmt. Println(<span class="string">"Please provide one text file to process' os.Exit(1)</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">fileName := arguments[1]</span></span><br><span class="line"><span class="string">f, err :=os.open(fileName)</span></span><br><span class="line"><span class="string">if err !=nil&#123;</span></span><br><span class="line"><span class="string">fmt.Printf("</span>error opening file %s <span class="string">",err)</span></span><br><span class="line"><span class="string">0s.Exit(1;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">defer f.Close()</span></span><br><span class="line"><span class="string">notAmatch:=0</span></span><br><span class="line"><span class="string">r :=bufio. NewReader(f)</span></span><br><span class="line"><span class="string">for&#123;</span></span><br><span class="line"><span class="string">line, err :=r ReadString('\n')</span></span><br><span class="line"><span class="string">if err ==io.E0F&#123;</span></span><br><span class="line"><span class="string">break</span></span><br><span class="line"><span class="string">&#125;else if err !=nil&#123;</span></span><br><span class="line"><span class="string">fmt.Printf("</span>error reading file %s,<span class="string">",err)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>首先我们要打开要读取的文件，并逐行读取其内容。变量notAmatch存储输入文件中不匹配两个正则表达式的条目。<br>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r1:=regexp.MustCompile(~.*\[(\d\d\/\W+/\d\d\d\d:\d\d:\d\d <span class="keyword">if</span> r1.MatchString(line)&#123;</span><br><span class="line">match :=r1.FindstringSubmatch(line)</span><br><span class="line">d1,err :=time.Parse(<span class="string">"02/Jan/2006:15:04:05-0700"</span>,matc <span class="keyword">if</span> err ==<span class="literal">nil</span>&#123;</span><br><span class="line">newFormat := d1.Format(time.Stamp)</span><br><span class="line">fmt. Printf(strings.Replace(line,match[<span class="number">1</span>],newFormat,<span class="number">1</span>) &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">notAmatch++</span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出只要代码执行到if中，就会执行continue，这意味着程序会继续执行本代码块中的逻辑。第一个正则表达式会匹配格式为21/Nov/2017:19：28:09+0200的时间与日期字符串函数regexp.MustCompile()与regex.compile()作用相同，只不过在解析失败时会触发panic。这种情况下你只能实现一种匹配，所以就要使用regexp.FindstringSubmatch()。</p>
<p>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r2 :=regexp.MustCompile(~.*\[(\w+\-\d\d-\d\d:\d\d:\d\d:\d\ <span class="keyword">if</span> r2.MatchString(line)&#123;</span><br><span class="line">match := r2.FindstringSubmatch(line)</span><br><span class="line">d1,err :=time.Parse(<span class="string">"Jan-02-06:15:04:05-0700"</span>,mat <span class="keyword">if</span> err == <span class="literal">nil</span>&#123;</span><br><span class="line">newFormat := d1.Format(time.Stamp)</span><br><span class="line">fmt.Print(strings.Replace(line,match[<span class="number">1</span>],newForma &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">notAmatch++</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p>
<p>匹配的第二种时间格式是Jun-21-17:19：28:09+0200，尽管本程序实现了两种格式的匹配，但当你掌握正则表达式之后，你可以实现任意形式的匹配。</p>
<p>最后一部分代码将会打印出日志中没有匹配的条目数量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt. Println(notAmatch, <span class="string">"lines did not match!"</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>执行ChangDT.go后得到下面的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gorun changDT.go</span><br></pre></td></tr></table></figure></p>
<h2 id="正则匹配IPv4地址"><a href="#正则匹配IPv4地址" class="headerlink" title="正则匹配IPv4地址"></a><span style="color:#00ACC1;">正则匹配IPv4地址</span></h2><p>一个IPv4地址被，号分成了四部分，每一部分都由8位二进制组成，十进制范围是0-255，即二进制的范围是00000000-11111111.<br>IPv6的格式更加复杂，本节的代码不适用于IPv6。 </p>
<p>本节的代码findIPv4.go将分为4个部分，第一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"bufio'</span></span><br><span class="line"><span class="string">"</span>fmt<span class="string">""</span></span><br><span class="line"><span class="string">"io'</span></span><br><span class="line"><span class="string">"</span>net<span class="string">"</span></span><br><span class="line"><span class="string">"</span>os</span><br><span class="line"><span class="string">"path/filepath' "</span>regexp<span class="string">'</span></span><br><span class="line"><span class="string">func findIp(input string) string &#123;</span></span><br><span class="line"><span class="string">partIp := "(25[0-5]|2[0-4][8-9]|1[0-9][8-9]1[1-9]?[0-9]) grammer := partIp+"\\."+partIp+"\\."+partIp+"\\."+partIp matchMe := regexp.MustCompile(grammer)</span></span><br><span class="line"><span class="string">return matchMe.Findstring(input)</span></span><br></pre></td></tr></table></figure></p>
<p>findIPv4.go的代码相对之前的复杂一些，所以需要使用的包比较多。</p>
<p>这部分代码定义的正则表达式，能够匹配IPv4地址，是整个程序的核心，如果你定义的正则表达式不正确，将永远找不到你想要的IPv4地址！</p>
<p>代码中的正则表达式稍后我会解释，在此之前必须了解IPv4地址的结构，比如IPv4的点分十进制表示方法以及每一部分都不能超过255，只有这样你能写出恰当的正则表达式。<br>正则表达式partIp定义了在一个IPv4地址中，每一部分可能出现的情况，比如可能是250-255的三位数，也可能是200-249，100-199，或者10-99两位数，0-9的个位数，以上的情况必须都考虑在内。</p>
<p>grammer变量定义了IPv4地址的四个部分，每一部分必须匹配partIpfindIPv4.go可以在任意文本文件中帮助你找到IPv4地址。</p>
<p>如果你有特殊需求，比如要搜索特定的IP地址，直接修改findIPv4.go的正则表达式即可。</p>
<p>第二部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">arguments := os.Args</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arguments)&lt;<span class="number">2</span>&#123;</span><br><span class="line">fmt. Printf(<span class="string">"usage:%s logfile\n"</span>,filepath.Base(argume os.Exit(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">for_, filename := <span class="keyword">range</span> arguments[<span class="number">1</span>:]&#123;</span><br><span class="line">f,err:=os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"error openning file %s\n"</span>,err)</span><br><span class="line"><span class="number">0s</span>.Exit(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br></pre></td></tr></table></figure></p>
<p>首先通过os.Args获取搜索的文件，然后检查命令行参数的长度是否符合要求。接下来通过一个for’循环迭代处理。</p>
<p>第四部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r :=bufio.NewReader(f)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">line,err :=r.ReadString(<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">if</span> err =e io.EoF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">fmt.Printf(<span class="string">"error openning file %s\n"</span>,err) <span class="keyword">break</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>类似于selectcolumn.go的代码，我们使用bufio.ReadString*()逐行读取文本。</p>
<p>最后一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ip := findIp(line)</span><br><span class="line">trail := net.ParseIP(ip) <span class="keyword">if</span> trail.To4() == <span class="literal">nil</span>&#123; <span class="keyword">continue</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(ip)</span><br><span class="line">d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对逐行读取的文本执行findIp()函数，netParseIP()会再次确保获取的是有效的IPv4地址。</p>
<p>执行findIPv4.go得到下面的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gorunfindlPv4.goauth.log</span><br><span class="line">116.112.10.1151.1.51.5192.168.1.1</span><br></pre></td></tr></table></figure></p>
<p>其实findIPv4.go会打印出很多重复的行（如果文件中有很多重复的IPv4地址）。我们可以配合UNIX命令对输出进一步处理，可以获得更加清晰直观的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run findlPv4.go auth.log| sort -mn|uniq -c|sort-rn 38 191.168.1.1</span><br><span class="line">22 182.12.5.1</span><br><span class="line">910.18.2.64</span><br></pre></td></tr></table></figure></p>
<p>sort -rn将findIPv4.go的输出作为输入，排序后倒序输出，uniq-c计算重复ip的出现次数，最后sort-rn按照重复ip的出现次数倒叙输出。</p>
<p>再次强调，findIPv4.go的核心是正则表达四的实现。如果正则表达式定义错误了，就会匹配不到你想要的数据，或者匹配到错误的数据。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><span style="color:#339AFF;">字符串</span></h1><p>严格来说，Go字符串并不是组合类型，但是Go提供了很多直接操作字符串的函数，第3章提到过Go字符串是值类型，并非像C字符串需要靠指针实现。另外，Go默认支持UTF-8字符串，处理Unicode编码的字符就会非常方便。下面的小节也会讲到字符、rune、字节之间的区别，以及字符串与字符串字面量的不同。</p>
<p>Go字符串实际上是一个字节切片，可以存储任意类型、任意长度的字节。</p>
<p>可以像下面一样定义一个字符串：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sliteral =<span class="string">"\x99\x42\x32"</span></span><br></pre></td></tr></table></figure></p>
<p>也可以使用字符串字面量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2:=<span class="string">"rfsdf</span></span><br></pre></td></tr></table></figure></p>
<p>可以使用len()得到字符串的长度。</p>
<p>strings.go将会分4部分展示一些Go字符串的标准操作。 第一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> sLiteral= <span class="string">"\x99\x42\x32\x55\x50\x35\x23\x50\x29\x9 fmt. Println(sLiteral)</span></span><br><span class="line"><span class="string">fmt.Printf("</span>x:%x\n<span class="string">", sLiteral)</span></span><br><span class="line"><span class="string">fmt. Printf("</span>sLiteral length:%d\n<span class="string">", len(sLiteral))</span></span><br></pre></td></tr></table></figure></p>
<p>每一个\xAB都代表sLiteral的一个字符，所以调用len()就会得到sLiteral的字符数量。%x会得到\xAB中的AB部分。</p>
<p>第二部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i :=<span class="number">8</span>;i&lt;<span class="built_in">len</span>(sLiteral);i++&#123;</span><br><span class="line">fmt. Printf(<span class="string">"%x"</span>, sLiteral[i]) fmt.Println()</span><br><span class="line">fmt.Printf(<span class="string">"q:%q\n"</span>,sLiteral) fmt.Printf(<span class="string">"+q:%+q\n"</span>,sLiteral) fmt.Printf(<span class="string">"x:%x\n"</span>,sLiteral)</span><br><span class="line">fmt.Printf(<span class="string">"s:As a string:%s\n"</span>, sLiteral)</span><br></pre></td></tr></table></figure></p>
<p>如代码所示，你可以像操作一个切片那样去操作字符串。使用%q作为字符串格式化参数，可以安全地打印出带双引号的字符串，%+q可以保证输出是ASCII格式。</p>
<p>最后，%x（注意%与x之间的空格）将会在输出的字符之间加上空格，如果你想打印字符串格式，就要使用%s。</p>
<p>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s2:=“££<span class="number">31</span></span><br><span class="line"><span class="keyword">for</span> x, y :=<span class="keyword">range</span> s2&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>,y,x)</span><br><span class="line">fmt.Printf(<span class="string">"s2 length:%d\n"</span>,<span class="built_in">len</span>(s2))</span><br></pre></td></tr></table></figure></p>
<p>在这里定义了字符串s2，内容是3个unicode字符。使用%#U可以打印出U+0058格式的字符，range关键字能够迭代包含Unicode字符的字符串，这样就可以逐个处理Unicode字符。</p>
<p>len（s2）的输出可能会令你困惑，解释一下，s2包含的是Unicode字符，Unicode字符的字节数量是大于该字符串中的元素数量的，而len()函数计算的是字节数量，所以len（s2）的值是7而不是3。</p>
<p>最后一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">consts3=<span class="string">"ab12AB"</span></span><br><span class="line">fmt. Println(<span class="string">"s3:"</span>，s3)</span><br><span class="line">fmt.Printf(<span class="string">"x:%x\n"</span>，s3)</span><br><span class="line">fmt.Printf(<span class="string">"s3 length:%d\n"</span>,<span class="built_in">len</span>(s3))</span><br><span class="line"><span class="keyword">for</span> i:=e;i&lt;<span class="built_in">len</span>(s3);i++&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%x"</span>，s3[i]) ]</span><br><span class="line">fmt.Println()</span><br></pre></td></tr></table></figure></p>
<p>执行strings.go的输出是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go run strings.go</span><br><span class="line">◆B2UP5<span class="comment">#P)@</span></span><br><span class="line">x:99423255503523502990 sLiteral length:10</span><br><span class="line">99 42 32 55 50 35 23 50 29 9c q:<span class="string">"\x99B2UP5#P)\x9c"</span></span><br><span class="line">+q:<span class="string">"x99B2UP5#P)\x9c"</span></span><br><span class="line">Xx:99 42 32 55 50 35 23 50 29 9c s:As a string:@B2UP5<span class="comment">#P)</span></span><br><span class="line">U+20AC<span class="string">'E'</span> starts at byte position O U+00A3 <span class="string">'£'</span>starts at byte position 3 U+00B3<span class="string">'3 starts at byte position 5 s2 length:7</span></span><br><span class="line"><span class="string">s3:ab12AB</span></span><br><span class="line"><span class="string">x:616231324142</span></span><br><span class="line"><span class="string">s3 length:6</span></span><br><span class="line"><span class="string">616231324142</span></span><br></pre></td></tr></table></figure></p>
<p>在不清楚Unicode和UTF-8机制的情况下，你可能会对本节的输出干到困惑，不必恐慌，因为这些在平时的开发中很少使用，基本的fmt.Printf()和fmt.Println()就能满足你的需求。</p>
<h2 id="rune是什么？"><a href="#rune是什么？" class="headerlink" title="rune是什么？"></a><span style="color:#00ACC1;">rune是什么？</span></h2><p>rune是一个类型为int32的值，因此他主要用来代表一个Unicode码点。 </p>
<p>Unicode码点是一个代表Unicode字符的数值。</p>
<p>NOTE：你可以认为字符串是一系列rune的集合<br>rune字面量实际上是一个用单引号括起来的字符，并且与与Unicode码点的概念相关联。</p>
<p>rune.go将分两部分阐述rune的使用，第一部分是：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> r1<span class="string">'↵</span></span><br><span class="line"><span class="string">fmt.Println("(int32) r1:",r1)</span></span><br><span class="line"><span class="string">fmt.Printf("(HEX)r1:%x\n"，r1)</span></span><br><span class="line"><span class="string">fmt.Printf("(as a String)r1:%s\n"，r1) fmt. Printf("(as a character)r1:%c\n",r1)</span></span><br></pre></td></tr></table></figure></p>
<p>首先定义了一个rune字面量r1，然后使用不同的方式去打印，分别是int32、十六进制、字符串、字符，最终你会发现使用字符格式打印出的与定义r1的值相同。</p>
<p>第二部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"A string is a collection of runes:"</span>, []<span class="keyword">byte</span>(<span class="string">"M aString := []byte("</span>Mihalis<span class="string">")</span></span><br><span class="line"><span class="string">for x,y :=range astring &#123;</span></span><br><span class="line"><span class="string">fmt. Println(x，y)</span></span><br><span class="line"><span class="string">fmt. Printf("</span>Char:%c\n<span class="string">",aString[x]</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">fmt.Printf("</span>%s\n<span class="string">", aString)</span></span><br><span class="line"><span class="string">1</span></span><br></pre></td></tr></table></figure></p>
<p>显而易见，字节切片实际上就是一系列runes的集合，并且如果你使用fmt.Println()打印字节切片，结果很可能不会符合你的预期。fmt.Printf()语句结合%c可以将runes转换为字符输出；如果想要以字符串的形式输出字节数组，应使用fmt.Printf()结合%s。</p>
<p>执行runes.go得到下面的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gorun runes.go</span><br><span class="line">(int32) r1:8364</span><br><span class="line">(HEX)r1:20ac</span><br><span class="line">(as a String)r1:%!s(int32=8364)</span><br><span class="line">(as a character)r1:E</span><br><span class="line">A string is a collection of runes: [77 105 104 97 108 105 1 077</span><br><span class="line">Char:M</span><br><span class="line">1105</span><br><span class="line">Char:i</span><br><span class="line">2184</span><br><span class="line">Char:h</span><br><span class="line">397</span><br><span class="line">Char:a</span><br><span class="line">4108</span><br><span class="line">Char:1</span><br><span class="line">5105</span><br><span class="line">Char:i</span><br><span class="line">6115</span><br><span class="line">Char:s</span><br><span class="line">Mihalis</span><br></pre></td></tr></table></figure></p>
<p>最后，举一个产生illegal rune literal错误的例子在导包的时候使用单引号。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cata.<span class="keyword">go</span> <span class="keyword">package</span> main <span class="keyword">import</span>(</span><br><span class="line"><span class="string">'fmt'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">]</span><br><span class="line">$ <span class="keyword">go</span> run a.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main:a.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">2</span>:illegal <span class="keyword">rune</span> literal</span><br></pre></td></tr></table></figure></p>
<h2 id="关于Unicode的包"><a href="#关于Unicode的包" class="headerlink" title="关于Unicode的包"></a><span style="color:#00ACC1;">关于Unicode的包</span></h2><p>Go提供的unicode标准库提供了很多便捷的函数，其中unicode.IsPrint()能帮助你判断字符串的某一部分是否能够以rune的类型打印出来。接下来将会在代码unicode.go中分两部分展示该函数的用法。</p>
<p>第一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"unicode"</span> )</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">constsL= <span class="string">"\x99\x00ab\x50\x00\x23\x50\x29\x9c'</span></span><br></pre></td></tr></table></figure></p>
<p>第二部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i :=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(sl);i++&#123;</span><br><span class="line"><span class="keyword">if</span> unicode.IsPrint(<span class="keyword">rune</span>(sL[i]))&#123; fmt.Printf(<span class="string">"%c\n"</span>，sL[i])</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Not printable!"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>unicode.IsPrint()函数将检查字符串sL的每个元素是否是rune类型，如果是的话将返回true否则返回false。如果你需要更多操作Unicode字符的方法，可以参考官方unicode包的介绍。</p>
<p>执行unicode.go将会打印：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ go run unicode.go</span><br><span class="line">Not printable! Not printable! a</span><br><span class="line">b</span><br><span class="line">P</span><br><span class="line">Not printable! <span class="comment">#</span></span><br><span class="line">P</span><br><span class="line">)</span><br><span class="line">Not printable!</span><br></pre></td></tr></table></figure></p>
<h2 id="关于字符串处理的包"><a href="#关于字符串处理的包" class="headerlink" title="关于字符串处理的包"></a><span style="color:#00ACC1;">关于字符串处理的包</span></h2><p>Go在strings包里面提供了很多操作UTF-8字符串的强大工具，大部分的工具将会在usestrings.go介绍，与文件10相关的操作将会在第8章详细介绍。</p>
<p>useStrings.go的第一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt'</span></span><br><span class="line"><span class="string">s"</span>strings<span class="string">' "unicode'</span></span><br><span class="line">varffmt.Printf</span><br></pre></td></tr></table></figure></p>
<p>s “strings”的导包方式是非常推荐的，意味着我们给strings包起了一个简短的包名，这样就可以使用s.FunctionName()而不必使用strings.FunctionName()。</p>
<p>当你频繁使用某个包中的函数的时候，也可以将该函数赋值给一个变量，像上面的代码一样，varf=fmt.Printf，接下来就可以用↵代替fmt.Printf()。要注意的是不要过度使用该特性，不然你的代码可读性会变得很差。</p>
<p>第二部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unc main()&#123;</span><br><span class="line">upper :=s.ToUpper(<span class="string">"Hello there!"</span>)</span><br><span class="line">f(<span class="string">"To Upper:%s\n"</span>, upper)</span><br><span class="line">f(<span class="string">"To Lower: %s\n"</span>,s.ToLower(<span class="string">"Hello THERE"</span>))</span><br><span class="line">f(<span class="string">"%s\n"</span>, s.Title(<span class="string">"tHis will be A title!"</span>))</span><br><span class="line">f(<span class="string">"EqualFold: %v\n"</span>, s.EqualFold(<span class="string">"Mihalis"</span>,<span class="string">"MIHAlis"</span>)) f(<span class="string">"EqualFold:%v\n"</span>,s.EqualFold(<span class="string">"Mihalis"</span>,“MIHAli<span class="string">"))</span></span><br></pre></td></tr></table></figure></p>
<p>这段代码提供了很多玩转字符串的例子，strings.EqualFold()函数能够判断两个字符串是否相同。</p>
<p>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="string">"Prefix:%v\n"</span>,s.HasPrefix(<span class="string">"Mihalis"</span>，“Mi<span class="string">")) f("</span>Prefix:%v\n<span class="string">",s.HasPrefix("</span>Mihalis<span class="string">", "</span>mi<span class="string">")) f("</span>Suffix:%v\n<span class="string">",s.HasSuffix("</span>Mihalis<span class="string">","</span>is<span class="string">")) f("</span>Suffix:%v\n<span class="string">",s.HasSuffix("</span>Mihalis<span class="string">","</span>IS<span class="string">"))</span></span><br><span class="line"><span class="string">f("</span>Index:%v\n<span class="string">",s.Index("</span>Mihalis<span class="string">","</span>ha<span class="string">")) f("</span>Index:%v\n<span class="string">",s.Index("</span>Mihalis<span class="string">","</span>Ha<span class="string">")) f("</span>Count:%v\n<span class="string">"，s.Count("</span>Mihalis<span class="string">"，"</span>i<span class="string">")) f("</span>Count:%v\n<span class="string">",s.Count("</span>Mihalis<span class="string">","</span>I<span class="string">")) f("</span>Repeat:%s\n<span class="string">",s.Repeat("</span>ab<span class="string">"，5))</span></span><br><span class="line"><span class="string">f("</span>TrimSpace:%s\n<span class="string">",s.TrimSpace("</span> \tThis is a line.\n<span class="string">")) f("</span>Trimleft:%s<span class="string">",s.TrimLeft("</span> \tThis is a\t line.\n<span class="string">","</span>\n f(<span class="string">"TrimRight:%s\n"</span>,s.TrimRight(<span class="string">"\tThis is alt line.\n"</span>,</span><br></pre></td></tr></table></figure></p>
<p>strings.count()函数能够计算第二个参数（字符串类型），在第一个参数（字符串类型）中出现的次数；strings.HasPrefix()函数判断字符串是否是以某字符串开头，如果是的话便返回true；同样，strings.HasSuffix()判断字符串是否以某字符串结尾。</p>
<p>第四部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="string">"Compare:%v\n"</span>，s.Compare(<span class="string">"Mihalis"</span>,<span class="string">"MIHALIS"</span>)) f(<span class="string">"Compare:%v\n"</span>,s.Compare(<span class="string">"Mihalis"</span>,<span class="string">"Mihalis"</span>)) f(<span class="string">"Compare:%v\n"</span>,s.Compare(<span class="string">"MIHALIS"</span>,<span class="string">"MIHalis"</span>))</span><br><span class="line">f(<span class="string">"Fields:%v\n"</span>,s.Fields(<span class="string">"This is a string!"</span>)) f(<span class="string">"Fields:%v\n"</span>, s.Fields(<span class="string">"Thisis\na\tstring!"</span>))</span><br><span class="line">f(<span class="string">"%s\n"</span>,s.Split(<span class="string">"abcd efg"</span>,<span class="string">""</span>))</span><br><span class="line">f(<span class="string">"%s\n"</span>, s.Replace(<span class="string">"abcdefg"</span>,<span class="string">""</span>，</span><br><span class="line"><span class="number">1</span>))</span><br><span class="line">f(<span class="string">"%s\n"</span>,s.Replace(<span class="string">"abcdefg"</span>，<span class="string">""</span>，</span><br><span class="line">，，<span class="number">23</span>) f(<span class="string">"%s\n"</span>, s.Replace(<span class="string">"abcd efg"</span>,<span class="string">""</span>,</span><br></pre></td></tr></table></figure></p>
<p>这部分展示了strings比较高级的一些函数。strings.Split()能够以特定字符分割字符串，并返回一个字符串切片。</p>
<p>strings.compare()函数用于比较两个字符串是否相等，相等返回true，否则返回1或者-1（strings.Compare（a，b），如果ab，意思是出现在字母表中的顺序，译者加）。</p>
<p>strings.Fields()按照空格将字符串分割。</p>
<p>strings.Split()非常有用，你迟早会在自己的程序中用到它！</p>
<p>最后一部分代码<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lines := []<span class="keyword">string</span>&#123;<span class="string">"Line 1"</span>,<span class="string">"Line 2"</span>,<span class="string">"Line 3"</span>&#125;</span><br><span class="line">f(<span class="string">"Join:%s\n"</span>, s.Join(lines,“+++<span class="string">"))</span></span><br><span class="line"><span class="string">f("</span>SplitAfter:%s\n<span class="string">",s.SplitAfter("</span><span class="number">123</span>++<span class="number">432</span>++<span class="string">".*++*))</span></span><br><span class="line"><span class="string">trimFunction := func(c rune) bool &#123; return lunicode. IsLetter(c)</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">f("</span>TrimFunc:%s\n<span class="string">",s.TrimFunc("</span><span class="number">123</span> abc ABC\t.<span class="string">"，trimF</span></span><br></pre></td></tr></table></figure></p>
<p>最后一部分代码提供的方法非常好理解，而且功能强大：<br>strings.Replace()函数需要4个参数，第一个是你要处理的字符串，第二个是你准备替换的字符，第三个是你要用该字符去替换，第四个参数是你要替换的数量，如果是-1就意味着你会替换所有要替换的字符。</p>
<p>strings.TrimFunc()函数可按照自定义函数获取你感兴趣的内容；<br>strings.SplitAfter()函数基于指定分隔符将字符串分割。 执行usestrings.go的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ go run useStrings.go</span><br><span class="line">To Upper: HELLOTHERE!</span><br><span class="line">To Lower: hello there</span><br><span class="line">THis Will Be A Title!</span><br><span class="line">EqualFold:<span class="literal">true</span></span><br><span class="line">EqualFold:<span class="literal">false</span></span><br><span class="line">Prefix:<span class="literal">true</span></span><br><span class="line">Prefix: <span class="literal">false</span></span><br><span class="line">Suffix:<span class="literal">true</span></span><br><span class="line">Suffix:<span class="literal">false</span></span><br><span class="line">Index:2</span><br><span class="line">Index:-1</span><br><span class="line">Count:2</span><br><span class="line">Count:0</span><br><span class="line">Repeat: ababababab</span><br><span class="line">TrimSpace:This is a line. TrimLeft:This is a</span><br><span class="line">line.</span><br><span class="line">TrimRight:</span><br><span class="line">Thisisa</span><br><span class="line">Compare:1</span><br><span class="line">Compare:0</span><br><span class="line">Compare:-1</span><br><span class="line">Fields:[This is a string!] Fields:[Thisis a string!] [a bcdefg]</span><br><span class="line">_a_b_c_d__e_f_g_</span><br><span class="line">_a_b_c_defg</span><br><span class="line">_a_bcdefg</span><br><span class="line">Join:Line1+++Line2+++Line3 SplitAfter: [123++432++]</span><br><span class="line">TrimFunc:abc ABC</span><br><span class="line">line.</span><br></pre></td></tr></table></figure></p>
<p>官方strings包中的方法远比useStrings.go中所展示的多，如果你正在写的代码是关于文本处理的，那么你应该阅读】strings的官方文档以了解更多。</p>
<h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><span style="color:#339AFF;">switch语句</span></h1><p>在本节介绍switch语句主要是因为switch可以用于正则表达式！首先看一段switch代码块：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> asString &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"1"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"One"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"0"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Zero"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Do not care!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码能够区分不同的asString值所对应的不同操作。</p>
<blockquote>
<p>switch代码块设置default子句是非常棒的实践。由于switch的case语句是依赖顺序的，所以default子句总是在最后声明。</p>
</blockquote>
<p>switch的使用还可以更加灵活：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> number &lt; <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Less than zero"</span>)</span><br><span class="line">    <span class="keyword">case</span> number &gt; <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Bigger than zero"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"zero"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码块能够在某个数字正数、负数、以及0的情况下执行不同的任务。如你所见，switch的分支语句可以是条件语句，那么其分支语句同样也可以是正则表达式！</p>
<p>关于switch的用法将在switch.go中分5部分展示。</p>
<p>第一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"regexp"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arguments := os.Args</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arguments) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Usage: switch number"</span>)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>regex包用于生成正则表达。 第二部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">number, err := strconv.Atoi(arguments[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"The value is not an integer"</span>, number)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> number &lt; <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Less than zero"</span>)</span><br><span class="line">    <span class="keyword">case</span> number &gt; <span class="number">0</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Bigger than zero"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Zero"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">asString := arguments[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">switch</span> asString &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"5"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"Five"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"0"</span>:</span><br><span class="line">    fmt.Println(<span class="string">"Zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"Do not care"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这部分代码说明case子句可以包含硬编码的变量，这种情况通常是switch’后跟有一个变量。</p>
<p>第四部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> negative = regexp.MustCompile(<span class="string">`-`</span>)</span><br><span class="line"><span class="keyword">var</span> floatingPoint = regexp.MustCompile(<span class="string">`\d?\.\d`</span>)</span><br><span class="line"><span class="keyword">var</span> mail = regexp.MustCompile(<span class="string">`^[^@]+@[^@.]+\.[^@.]+`</span>)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> negative.MatchString(asString):</span><br><span class="line">    fmt.Println(<span class="string">"Negative number"</span>)</span><br><span class="line"><span class="keyword">case</span> floatingPoint.MatchString(asString):</span><br><span class="line">    fmt.Println(<span class="string">"Floating Point"</span>)</span><br><span class="line"><span class="keyword">case</span> mail.MatchString(asString):</span><br><span class="line">    fmt.Println(<span class="string">"It is an email"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"Something else"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这部分代码十分有趣。首先，我们定义了3个正则表达negative，floatingPoint，以及mail。然后使用regexp.Matchstring()在switch中匹配不同的情况。</p>
<p>最后，fallthrough关键字告诉Go执行接下来的分支，即default分支。这意味着无论mail.Matchstring（asString）是否成功匹配，default子句都会执行。</p>
<p>最后一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aType error = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aType.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    fmt.Println(<span class="string">"It is a nil interface"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"It it not a nil interface"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码说明switch能够区分不同类型，你将在第7章中了解到接口的知识。执行switch.go将会产生如下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ go run switch.go</span><br><span class="line">Usage: switch number</span><br><span class="line"><span class="built_in">exit</span> status 1</span><br><span class="line">hanshanjiedeMacBook-Pro:chapter4 hanshanjie$ go run switch. The value is not an <span class="built_in">integer</span> e</span><br><span class="line">Do not care</span><br><span class="line">It is an email</span><br><span class="line">Something <span class="keyword">else</span></span><br><span class="line">It is a nil interface</span><br><span class="line">hanshanjiedeMacBook-Pro:chapter4 hanshanjies go run switch. Bigger than zero</span><br><span class="line">Five</span><br><span class="line">Something <span class="keyword">else</span></span><br><span class="line">It is a nil interface</span><br><span class="line">hanshanjiedeMacBook-Pro:chapter4 hanshanjie$ go run switch. Zero</span><br><span class="line">Zero</span><br><span class="line">Something <span class="keyword">else</span></span><br><span class="line">It is a nil interface</span><br><span class="line">hanshanjiedeMacBook-Pro:chapter4 hanshanjie$ go run switch. The value is not an <span class="built_in">integer</span> e</span><br><span class="line">Do not care</span><br><span class="line">Floating Point</span><br><span class="line">It is a nil interface</span><br><span class="line">hanshanjiedeMacBook-Pro:chapter4 hanshanjie$ go run switch. The value is not an <span class="built_in">integer</span> e</span><br><span class="line">Do not care</span><br><span class="line">Negative number</span><br><span class="line">It is a nil interface</span><br></pre></td></tr></table></figure></p>
<h1 id="计算Pi的精确值"><a href="#计算Pi的精确值" class="headerlink" title="计算Pi的精确值"></a><span style="color:#339AFF;">计算Pi的精确值</span></h1><p>在本小节中你将学习到如何使用Go标准库math/big以及其提供的特殊类型，并计算高精度的Pi值。<br>本节的代码是我所见过的最丑陋的Go代码，甚至用Java写看起来都会好一些。</p>
<p>calculatepi.go使用Bellard规则计算Pi值，代码将分4部分展示。 第一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span> <span class="string">"math'</span></span><br><span class="line"><span class="string">"</span>math/big<span class="string">" "</span>os</span><br><span class="line"><span class="string">"strconv' 了</span></span><br><span class="line"><span class="string">var precision uint -e</span></span><br></pre></td></tr></table></figure></p>
<p>precision变量代表你想得到的Pi值精度，其声明为全局变量保证在整个程序中都可以被访问到。</p>
<p>第二部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pi</span><span class="params">(accuracy <span class="keyword">uint</span>)</span>*<span class="title">big</span>.<span class="title">Float</span></span>&#123;</span><br><span class="line">k:=C</span><br><span class="line">pi :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(e) k1k2k3 :=<span class="built_in">new</span>(big.Float).setPrec(precision).SetFloat64(e k4k5k6 :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(e temp :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(<span class="number">0</span>) minusOne :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64 total := <span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(<span class="number">8</span>)</span><br><span class="line">two2Six:=math.Pow(<span class="number">2</span>，<span class="number">6</span>)</span><br><span class="line">two2SixBig :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat</span><br></pre></td></tr></table></figure></p>
<p>new（big.Float）创建一个big.Float类型的变量，并调用SetPrec()函数将精度设置为参数precision 。</p>
<p>第三部分是贝拉算法计算精确Pi值的函数Pi()实现（关于贝拉算法可查看文末简介）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">if</span> k&gt; <span class="keyword">int</span>(accuracy)&#123; <span class="keyword">break</span></span><br><span class="line">t1 :=<span class="keyword">float64</span>(<span class="keyword">float64</span>(<span class="number">1</span>) / <span class="keyword">float64</span>(<span class="number">10</span>*k+<span class="number">9</span>))</span><br><span class="line">k1 :=<span class="built_in">new</span>(big.Float).setPrec(precision).setFloat64(t1 t2:=<span class="keyword">float64</span>(<span class="keyword">float64</span>(<span class="number">64</span>) / <span class="keyword">float64</span>(<span class="number">10</span>*k+<span class="number">3</span>))</span><br><span class="line">k2 :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(t2 t3:=<span class="keyword">float64</span>(<span class="keyword">float64</span>(<span class="number">32</span>) / <span class="keyword">float64</span>(<span class="number">4</span>*k+<span class="number">1</span>))</span><br><span class="line">k3 :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(t3 k1k2k3.Sub(k1，k2)</span><br><span class="line">k1k2k3.Sub(k1k2k3，k3)</span><br><span class="line">t4 :=<span class="keyword">float64</span>(<span class="keyword">float64</span>(<span class="number">4</span>) / <span class="keyword">float64</span>(<span class="number">10</span>*k+<span class="number">5</span>))</span><br><span class="line">k4 :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(t4 t5 :=<span class="keyword">float64</span>(<span class="keyword">float64</span>(<span class="number">4</span>) / <span class="keyword">float64</span>(<span class="number">10</span>*k+<span class="number">7</span>))</span><br><span class="line">k5 :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(ts t6 := <span class="keyword">float64</span>(<span class="keyword">float64</span>(<span class="number">1</span>) / <span class="keyword">float64</span>(<span class="number">4</span>*k+<span class="number">3</span>))</span><br><span class="line">k6 :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(t6 k4k5k6.Add(k4,k5)</span><br><span class="line">k4k5k6.Add(k4k5k6,k6)</span><br><span class="line">k4k5k6 = k4k5k6.Mul(k4k5k6,minusOne)</span><br><span class="line">temp.Add(k1k2k3，k4k5k6)</span><br><span class="line">k7temp :=<span class="built_in">new</span>(big.Int).Exp(big.NewInt(<span class="number">-1</span>),big.NewInt k8temp :=<span class="built_in">new</span>(big.Int).Exp(big.NewInt(<span class="number">1024</span>)，big.NewI</span><br><span class="line">k7 :=<span class="built_in">new</span>(big.Float).setprec(precision).setFloat64(e) k7.SetInt(k7temp)</span><br><span class="line">k8 :=<span class="built_in">new</span>(big.Float).setPrec(precision).setFloat64(e) k8.SetInt(k8temp)</span><br><span class="line">t9 := <span class="keyword">float64</span>(<span class="number">256</span>) / <span class="keyword">float64</span>(<span class="number">10</span>*k+<span class="number">1</span>)</span><br><span class="line">k9 :=<span class="built_in">new</span>(big.Float).SetPrec(precision).SetFloat64(t9 k9.Add(k9，temp)</span><br><span class="line">total.Mul(k9,k7)</span><br><span class="line">total.Quo(total, k8)</span><br><span class="line">pi.Add(pi, total)</span><br><span class="line">k=k+<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">pi.Quo(pi，two2SixBig) <span class="keyword">return</span> pi</span><br></pre></td></tr></table></figure></p>
<p>这部分代码是贝拉算法的Go实现，你必须借助于math/big包中特定的函数进行计算，因为这些函数能够实现你想要达到的数字精度，可以说如果不使用big.Float、big.Int变量以及math/big中的函数，高精度的Pi值根本无法计算。</p>
<p>最后一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">arguments :=os.Args</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(arguments)==<span class="number">1</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Please provide one numeric argument!"</span>) os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">temp,_:=strconv.ParseUint(arguments[<span class="number">1</span>]，<span class="number">10</span>，<span class="number">32</span>) precision = <span class="keyword">uint</span>(temp)*<span class="number">3</span></span><br><span class="line">PI := Pi(precision) fmt.Println(PI)</span><br></pre></td></tr></table></figure></p>
<p>执行calculatePi.go得到如下输出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gorun calculatePi.go</span><br><span class="line">Please provide one numeric argument! <span class="built_in">exit</span> status 1</span><br><span class="line">$ go run calculatePi.go 20</span><br><span class="line">3.141592653589793258</span><br><span class="line">$ go run calculatePi.go 200</span><br><span class="line">3.1415926535897932569603993617387624040191831562485732 43493179283571046450248913467118511784317615354282017 92941629280905081393787528343561058631336354860243676 8047706489838924381929</span><br></pre></td></tr></table></figure></p>
<p>本节的代码需要使用很多不同的数据类型，务必保证数据类型的正确使用！</p>
<p>课外阅读</p>
<p>文中提到的贝拉算法简介：<br>Fabrice Bellard在圆周率算法方面也有着惊人的成就，1997年 FabriceBellard提出最快圆周率算法公式。在计算圆周率的过程中，Fabrice Bellard使用改良后的查德诺夫斯基方程算法来进行圆周率的计算，并使用贝科波温-劳夫算法来验证计算的结果。为了纪念他对圆周率算法所作出的杰出贡献，Fabrice Bellard所使用的改良型算法被命名为Fabrice Bellard算法，这种算法是目前所有圆周率算法中最快的一种，这个计算N位PI的公式比传统的BBQ算法要快47%。<br>2009年的最后一天，Fabrice Bellard宣布另一重大突破他用桌面电脑打破了由超级计算机保持的圆周率运算记录。这是一个壮举，他将P|计算到了小数点后2.7万亿位！更令人惊讶的是，他使用的不过是价格不到2000欧元的个人PC，仅用了116天，就计算出 JPI的小数点后第2.7万亿位，超过了排名世界第47位的T2KOpen超级计算机于2009年8月17日创造的世界纪录。新纪录比原纪录多出1200亿位，然而，他使用的这台桌面电脑的配置仅为：2.93GHzCore i7CPU，6GB内存，7.5TB硬盘！不过这次为了加快计算完成的速度保住排名第一的位置，Fabrice Bellard使用了9台联网的电脑来对数据进行验证，若使用一台电脑来验证计算结果的话，则需要额外增加13天的计算时间。Fabrice Bellard在圆周率方面的辉煌成就，使他创造多次圆周率单一位计算的世界纪录（计算10的整次幂位），也曾因此而登上《科学美国人》法文版。</p>
<h1 id="实现简单的K-V存储"><a href="#实现简单的K-V存储" class="headerlink" title="实现简单的K-V存储"></a><span style="color:#339AFF;">实现简单的K-V存储</span></h1><p>本节你将学习使用Go实现K-V存储的简单实现，其背后的思想是易于理解的：尽可能快速地发出请求并给出响应，并将其转化成对应的数据结构。</p>
<p>本节代码将实现K-V存储的四个基本功能：</p>
<ul>
<li>1、添加新元素</li>
<li>2、基于key删除已有的元素 </li>
<li>3、给定key查找对应value </li>
<li>4、修改key对应的value</li>
</ul>
<p>我们将这四个功能命名为ADD，DELETE，LOOKUP，CHANGE，完成这四个基本功能，你将会对K-V存储的实现有一个全面的了解。另外，当你输入STOP时整个程序就会停止，输入PRINT命令就会打印出当前K-V存储的内容。</p>
<p>本节的keyValue.go将分为5个代码段解释。</p>
<p>第一部分：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myElement <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    SurName <span class="keyword">string</span></span><br><span class="line">    Id <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DATA = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]myElement)</span><br></pre></td></tr></table></figure></p>
<p>我们使用原生的Gomap来实现K-V存储，因为内置的数据结构往往执行效率更高。map变量被声明为全局变量，其k为string类型，v为myElement类型，myElement是自定义的结构体。</p>
<p>第二部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ADD</span><span class="params">(k <span class="keyword">string</span>, n myElement)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> LOOKUP(k) == <span class="literal">nil</span> &#123;</span><br><span class="line">        DATA[k] = n</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DELETE</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> LOOKUP(k) != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">delete</span>(DATA, k)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这部分代码实现了命令行ADD和DELETE，用户在执行ADD命令时，如果没有携带足够的参数，我们要保证该操作不会失败，意味着myElement中对应的字段为空字符串。然而如果你要添加的key已经存在了，就会报错（K-V存储不允许重复key出现）而不是修改对应的值。</p>
<p>第三部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LOOKUP</span><span class="params">(k <span class="keyword">string</span>)</span> *<span class="title">myElement</span></span> &#123;</span><br><span class="line">    _, ok := DATA[k]</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        n := DATA[k]</span><br><span class="line">        <span class="keyword">return</span> &amp;n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CHANGE</span><span class="params">(k <span class="keyword">string</span>, n myElement)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    DATA[k] = n</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PRINT</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> DATA &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"key: %s value: %v"</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该代码段实现了LOOKUP与CHANGE功能，如果你要修改的key不存储，程序会自动将其存储。</p>
<p>PRINT命令能够打印出目前所有K-V存储的内容。</p>
<p>第四部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        text := scanner.Text()</span><br><span class="line">        text = strings.TrimSpace(text)</span><br><span class="line">        tokens := strings.Fields(text)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> <span class="built_in">len</span>(tokens) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            tokens = <span class="built_in">append</span>(tokens, <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>该部分代码读取用户的输入。首先，for循环将保证程序一直等待用户的输入，接下来使用tokens切片保证至少有5个元素的输入，即使只有ADD命令需要5个参数。如果用户不想在使用ADD命令时出现空字符串值，就需要这样输入：<code>ADD aKey Field1 Field2 Field3</code>。</p>
<p>最后一部分代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> tokens[<span class="number">0</span>] &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"PRINT"</span>:</span><br><span class="line">            PRINT()</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"STOP"</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"DELETE"</span>:</span><br><span class="line">            <span class="keyword">if</span> DELETE(tokens[<span class="number">1</span>]) &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Delete operations failed"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ADD"</span>:</span><br><span class="line">            n := myElement&#123;tokens[<span class="number">2</span>], tokens[<span class="number">3</span>], tokens[<span class="number">4</span>]&#125;</span><br><span class="line">            <span class="keyword">if</span> !ADD(tokens[<span class="number">1</span>], n) &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Add operation failed"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"LOOKUP"</span>:</span><br><span class="line">            n := LOOKUP(tokens[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> n != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"%v\n"</span>, n)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"CHANGE"</span>:</span><br><span class="line">            n := myElement&#123;tokens[<span class="number">2</span>], tokens[<span class="number">3</span>], tokens[<span class="number">4</span>]&#125;</span><br><span class="line">            <span class="keyword">if</span> !CHANGE(tokens[<span class="number">1</span>], n) &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Update operation failed"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"Unknown command - please try again!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这部分代码处理用户的输入。switch的使用使得程序的逻辑设计看上去十分清晰，能够将程序员从冗余的if…else中拯救出来。</p>
<p>执行keyValue.go得到如下输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ go run keyValue.go</span><br><span class="line">UNKNOWN</span><br><span class="line">Unknown <span class="built_in">command</span> - please try again!</span><br><span class="line">ADD123 123</span><br><span class="line">ADD234234</span><br><span class="line">ADD234</span><br><span class="line">Add operation failed</span><br><span class="line">ADD345</span><br><span class="line">PRINT</span><br><span class="line">key:123 value:&#123;1 2 3&#125;key:234 value:&#123;2 3 4&#125;key:345 valu CHANGE 345345</span><br><span class="line">PRINT</span><br><span class="line">key:345 value:&#123;3 4 5&#125;key:123 value:&#123;1 2 3&#125;key:234 valu DELETE 345</span><br><span class="line">PRINT</span><br><span class="line">key:123 value:&#123;1 2 3&#125;key:234 value:&#123;234&#125;</span><br><span class="line">ADD 567-5-6-7</span><br><span class="line">PRINT</span><br><span class="line">key:123 value:&#123;12 3&#125;key:234 value:&#123;23 4&#125;key:567 valu CHANGE 567</span><br><span class="line">PRINT</span><br><span class="line">key:567 value:&#123;&#125;key:123 value:&#123;12 3&#125;key:234 value: STOP</span><br></pre></td></tr></table></figure></p>
<p>学习第8章后你将学会如何支持K-V存储的数据持久化功能。然而，在单用户应用使用goroutines和channel是没有任何实际意义的，但是如果你是通过TCP/IP实现K-V存储，那么使用goroutines和channel会帮助你实现多连接、服务多用户功能。你将在第9、10章学习goroutines和channel的知识，并且在12、13章学习网络编程的相关知识，尽情期待吧！</p>
<h1 id="延展阅读"><a href="#延展阅读" class="headerlink" title="延展阅读"></a><span style="color:#339AFF;">延展阅读</span></h1><ul>
<li>regexp标准库的详细讲解——<a href="http://golang.org/pkg/regexp" target="_blank" rel="noopener">http://golang.org/pkg/regexp</a>。</li>
<li>阅读grep工具的使用说明。</li>
<li>使用Go开发一个程序，能够找出log文件中所有的IPv4地址。</li>
<li>关于math/ big包的详细讲解——<a href="http://golang.org/pkg/math/big" target="_blank" rel="noopener">http://golang.org/pkg/math/big</a> 。</li>
<li>unicode标准库的官方文档——<a href="https://golang.org/pkg/unicode" target="_blank" rel="noopener">https://golang.org/pkg/unicode</a> 。</li>
<li>开始阅读官方的Go语言规范吧——<a href="http://golang.org/ref/spec" target="_blank" rel="noopener">http://golang.org/ref/spec</a>。</li>
</ul>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a><span style="color:#339AFF;">练习</span></h1><ul>
<li>写一个Go程序，识别无效的IPv4地址。</li>
<li>说说make和new的区别。</li>
<li>说说字符、字节和rune之间的区别。</li>
<li>在不使用UNIX工具的前提下，修改findIPv4.go使之能够打印出出现次数最多的IPv4地址。</li>
<li>写一个Go程序，能够识别出log文件中产生404错误的IPv4地址。</li>
<li>使用math/big包计算高精度平方根，算法自选。</li>
<li>写一个Go程序，从给定时间与日期中寻找特定格式的时间。</li>
<li>写一个正则表达式匹配200-400之间的整数。</li>
<li>为keyValue.go添加日志打印。</li>
<li>修改findIPv4.go中的findIP()函数，保证findIP()多次调用时正则表达式只编译一次。</li>
</ul>
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a><span style="color:#339AFF;">本章小结</span></h1><p>在本章中，你学到了Go的很多实用特性，包括创建与使用结构体，元组，字符串，runes以及Unicode标准库。另外，你也掌握了模式匹配与正则表达式，switch语句，strings标准库；并且，你实现了Go版本的K-V存储，使用math/big包计算出高精度的Pi值。</p>
<p>在下一章中，你将学习使用更加高级的数据结构来操作数据，比如二叉树，链表，双向链表，队列，栈，哈希表以及container标准库中的数据结构。下一章最后的主题将是随机数，我们将生成难以破解的密码字符串。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Mastering-Go/" rel="tag"># Mastering Go</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/29/3-Go基本数据类型/" rel="next" title="3-Go基本数据类型">
                <i class="fa fa-chevron-left"></i> 3-Go基本数据类型
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/30/5-数据结构/" rel="prev" title="5-数据结构">
                5-数据结构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1017</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">72</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/04/04/结束语｜秒杀系统之上的业务协同思考/" title="结束语｜秒杀系统之上的业务协同思考" target="_blank">结束语｜秒杀系统之上的业务协同思考</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/14｜百万级流量秒杀系统的关键总结/" title="14｜百万级流量秒杀系统的关键总结" target="_blank">14｜百万级流量秒杀系统的关键总结</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/13｜优化番外篇：Vertx介绍及快速入门/" title="13｜优化番外篇：Vertx介绍及快速入门" target="_blank">13｜优化番外篇：Vertx介绍及快速入门</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/12｜高性能优化：单机Java极致优化/" title="12｜高性能优化：单机Java极致优化" target="_blank">12｜高性能优化：单机Java极致优化</a>
                  </li>
                
                  <li>
                    <a href="/2023/04/04/11｜高性能优化：物理机极致优化/" title="11｜高性能优化：物理机极致优化" target="_blank">11｜高性能优化：物理机极致优化</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#关于组合类型"><span class="nav-number">1.</span> <span class="nav-text">关于组合类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结构体"><span class="nav-number">2.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体指针"><span class="nav-number">2.1.</span> <span class="nav-text">结构体指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用new关键字"><span class="nav-number">2.2.</span> <span class="nav-text">使用new关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元组"><span class="nav-number">3.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正则表达式与模式匹配"><span class="nav-number">4.</span> <span class="nav-text">正则表达式与模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#理论知识"><span class="nav-number">4.1.</span> <span class="nav-text">理论知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的正则表达式示例"><span class="nav-number">4.2.</span> <span class="nav-text">简单的正则表达式示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级的正则表达式示例"><span class="nav-number">4.3.</span> <span class="nav-text">高级的正则表达式示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则匹配IPv4地址"><span class="nav-number">4.4.</span> <span class="nav-text">正则匹配IPv4地址</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rune是什么？"><span class="nav-number">5.1.</span> <span class="nav-text">rune是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Unicode的包"><span class="nav-number">5.2.</span> <span class="nav-text">关于Unicode的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于字符串处理的包"><span class="nav-number">5.3.</span> <span class="nav-text">关于字符串处理的包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#switch语句"><span class="nav-number">6.</span> <span class="nav-text">switch语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#计算Pi的精确值"><span class="nav-number">7.</span> <span class="nav-text">计算Pi的精确值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现简单的K-V存储"><span class="nav-number">8.</span> <span class="nav-text">实现简单的K-V存储</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#延展阅读"><span class="nav-number">9.</span> <span class="nav-text">延展阅读</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习"><span class="nav-number">10.</span> <span class="nav-text">练习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小结"><span class="nav-number">11.</span> <span class="nav-text">本章小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.2m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">124:48</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
