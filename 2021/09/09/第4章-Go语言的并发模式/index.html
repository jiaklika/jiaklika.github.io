<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go语言并发之道">
<meta property="og:type" content="article">
<meta property="og:title" content="第4章 Go语言的并发模式">
<meta property="og:url" content="http://yoursite.com/2021/09/09/第4章-Go语言的并发模式/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-11-01T09:30:14.914Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第4章 Go语言的并发模式">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">






  <link rel="canonical" href="http://yoursite.com/2021/09/09/第4章-Go语言的并发模式/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第4章 Go语言的并发模式 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">坚持就是胜利</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/09/第4章-Go语言的并发模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="学如逆水行舟，不进则退">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第4章 Go语言的并发模式

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-09 14:47:48" itemprop="dateCreated datePublished" datetime="2021-09-09T14:47:48+08:00">2021-09-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-11-01 17:30:14" itemprop="dateModified" datetime="2021-11-01T17:30:14+08:00">2021-11-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">38k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">35 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>我们已经探索了Go语言的并发原语的基本原理，并讨论了如何正确使用这些原语。在本章中，我们将深人探讨如何将这些基元组合成模式，以帮助保持系统的可扩展性和可维护性。</p>
<p>但是，在我们开始之前，我们需要谈谈本章所包含的一些模式的格式。在很多示例中，我们将使用传递空接口（interface{}）的channel。在Go语言中使用空接口（interface{}）是有争议的，不过，我们出于以下几个原因选择使用了空接口。首先，它使得在书的其余部分编写简洁的例子变得更容易。其次，在某些情况下，我认为这更能代表该模式正在努力达成的目标。我们将在本章后面的“pipeline”直接讨论这一点。</p>
<p>如果这对你来说过于难以接受，请记住你始终可以为此代码创建Go语言生成器，并生成模式以利用你感兴趣的类型。</p>
<p>所以，让我们深入了解Go语言的一些并发模式吧！</p>
<p>约束</p>
<p>在编写并发代码的时候，有以下几种不同的保证操作安全的方法。我们已经介绍了其中两个：</p>
<p>。用于共享内存的同步原语（如sync.Mutex） 通过通信共享内存来进行同步（如channel）。</p>
<p>但是，在并发处理中还有其他儿种情况也是隐式并发安全的：<br>不会发生改变的数据。受到保护的数据。</p>
<p>从某种意义上讲，不可变数据是理想的，因为它是隐式地并行安全的。每个并发进程可能对相同的数据进行操作，但不能对其进行修改。如果要创建新数据，则必须创建具有所需修改的数据的新副本。这不仅可以减轻开发人员的认知负担，并且可以使程序运行得更快，这将使程序的临界区减少（或者完全消除临界区）。在Go语言中，可以通过编写利用值的副本而不是指向内存值的指针的代码来实现此目的。有些语言支持使用明确不变的值的指针，然而，Go语言不在其中。“约束”还可以使开发人员减少临界区的长度以及承担更小的认知负担。约束并发值的技术比简单传递值的副本要复杂一点，所以本章我们将深入介绍这些约束技术。</p>
<p>“约束”是一种确保了信息只能从一个并发过程中获取到的简单且强大的方法。达到此目的时，并发程序隐式安全，不需要同步。有两种可能的约束：特定约束和词法约束。特定约束是指通过公约实现约束时，无论是由语言社区、你所在的团队，还是你的代码库设置。在我看来，坚持约束很难在任何规模的项目上进行协调，除非你有工具在每次有人提交代码时对你的代码进行静态分析。下面是一个特定约束的例子，它说明了原因：</p>
<p>我们可以看到，loopData函数和handleData channel上的循环都可以使用整数的数据切片。然而，按照惯例，我们只能从loopData函数访问它。但是，随着代码被更多人所触及，deadline缩短，就可能会出错，并且约束可能会被打破并导致问题。正如我所提到的，一个静态分析工具可能会遇到这类问题，但对Go语言代码库进行静态分析表明一个成熟度水平并不是很多团队达到的。这就是为什么我更喜欢约束这个词，它使用编译器来执行约束。</p>
<p>词法约束涉及使用词法作用域仅公开用于多个并发进程的正确数据和并发原语。这使得做错事是不可能的。实际上我们已经在第3章中谈到了这个主题。回想一下channel部分，它讨论的只是将channel的读或写处理暴露给需要它们的并发进程。我们再来看看这个例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ha gtigt cnononts, <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> <span class="built_in">close</span>(results)</span><br><span class="line"><span class="keyword">for</span> i:<span class="number">-0</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">resultsc-i</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line">consumer :- <span class="function"><span class="keyword">func</span><span class="params">(results&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;<span class="number">0</span> <span class="keyword">for</span> result :u <span class="keyword">range</span> results[</span><br><span class="line">fmt.Printf(<span class="string">"Received:xdin"</span>, result) fmt.Println(<span class="string">"Done receiving!"</span>)</span><br><span class="line">]</span><br><span class="line">results :- chan0wner()<span class="number">0</span></span><br><span class="line">consumer(results)</span><br></pre></td></tr></table></figure></p>
<p>0在chan0wner函数的词法范围内实例化channel。这将结果写入channel的处理的范围约束在它下面定义的闭包中。换句话说，它包含了这个channel的写人处理，以防止其他goroutine写入它。</p>
<p>日收到了channel的读处理，能够将它传递给消费者，消费者只能从中读取信息。这又一次将main goroutine约束在channel的只读视图中。</p>
<p>收到一个int channel的只读副本。通过声明我们要求的唯一用法是读取访问，我们将channel内的使用约束为只读。</p>
<p>这样设置，在这个小例子中就不可能利用这些channel。这是一个很好的读取的方案，但可能不是一个非常有趣的例子，因为channel是并发安全的。让我们来看一个使用不是并发安全的数据结构的约束的例子，它是一个bytes.Buffer的实例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printData : <span class="function"><span class="keyword">func</span><span class="params">(wg*sync.WaitGroup, data []<span class="keyword">byte</span>)</span></span> &#123; <span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">var</span> buff bytes.Buffer</span><br><span class="line"><span class="keyword">for</span> _,b:-<span class="keyword">range</span> data&#123;</span><br><span class="line">fmt.Fprintf(&amp;buff,<span class="string">"%c"</span>,b) +tgf(fuff.sting&lt;)&gt;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line">data :- []<span class="keyword">byte</span>(<span class="string">"golang"</span>)</span><br><span class="line"><span class="keyword">go</span> printData(<span class="number">8</span>wg, data[:<span class="number">3</span>])o</span><br><span class="line"><span class="keyword">go</span> printData（<span class="number">8</span>wg，data【<span class="number">3</span>：】）日</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>0这里我们传入包含数据结构中前三个字节的切片。</p>
<p>这里我们传入一个包含数据结构中最后三个字节的切片。</p>
<p>在这个例子中，你可以看到，因为printData没有在数据切片周围关闭，所以它不能访问它，并且需要占用一部分字节才能操作。我们传递切片的不同子集，因此约束了我们开始的goroutine，只是我们传人切片的一部分。由于词法范围的原因，我们已经不可能执行错误的操作，所以我们不需要通过通信完成内存访问同步或共享数据注1。</p>
<p>那么有什么意义呢？如果我们有同步功能，为什么要约束？答案是提高了性能并降低了开发人员的认知负担。同步带来了成本，如果你可以避免它，你将不会有任何临界区，因此你不必为同步它们付出任何成本。你也可以通过同步回避所有可能的问题，开发人员根本不必担心这些问题。利用词法约束的并发代码通常比不具有词法约束变量的并发代码更易于理解。这是因为在你的词法范围内，你可以编写同步代码。</p>
<p>注1：我忽略了通过不安全的软件包手动操作内存的可能性。这是不安全的原因！</p>
<p>话虽如此，建立约束可能很困难，所以有时我们必须回到我们美妙的Go语言并发原语。</p>
<p>for-select循环<br>在Go语言程序中你会一遍又一遍地看到for-select循环。它不过是这样的：<br>for {11要不就无限循环，要不就使用range语句着环select{<br>//使用 channel进行作业<br>}<br>有以下几种情况你可以见到这种模式。<br>向channel发送迭代变量<br>通常情况下，你需要将可迭代的内容转换为channel上的值。这不是什么幻想，通常看起来像这样：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for_, s :=<span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>&#125; &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> stringStream &lt;- s:</span><br></pre></td></tr></table></figure></p>
<p>循环等待停止</p>
<p>创建循环，无限循环直到停止的goroutine很常见。这个有一些变化。你选择哪一个纯粹是一种个人爱好。</p>
<p>第一种变体保持select语句尽可能短：</p>
<p>如果已经完成的channel未关闭，我们将退出select语句并继续执行for循环的其余部分。<br>第二种变体将工作嵌入到选择语句的默认子句中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//进行非抢占式任务</span></span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们输入select语句时，如果完成的channel尚未关闭，我们将执行default子句。</p>
<p>这种模式没有什么别的了，但它在任何地方都会被用到，所以值得一提。</p>
<p>防止goroutine泄漏</p>
<p>正如我们在第3章“goroutine”介绍的那样，我们知道goroutine廉价且易于创建，这是让Go语言这么富有成效的原因之一。运行时将多个goroutine复用到任意数量的操作系统线程，以便我们不必担心该抽象级别。但是goroutine还是需要消耗资源，而且goroutine不会被运行时垃圾回收，所以无论goroutine所占用的内存有多么的少，我们都不希望我们的进程对此没有感知。那么我们如何去确保他们被清理干净？</p>
<p>让我们从头开始，逐步思考这个问题：为什么一个goroutine需要存在呢？在第2章中，我们确定goroutine代表可能或不可能相互平行运转的工作单位。goroutine有以下几种方式被终止：<br>当它完成了它的工作。<br>，因为不可恢复的错误，它不能继续工作。 ，当它被告知需要终止工作。</p>
<p>我们可以很简单地使用前两种方法，因为这两种方法就隐含在你的算法中，但是“取消工作”又是怎样工作的呢？由于网络的影响，事实证明这是最重要的一点：如果你开始了一个goroutine，最有可能以某种有组织的方式与其他几个goroutine合作。我们甚至可以将这种相互连接表现为一个图表：子goroutine是否应该继续执行可能是以许多其他goroutine状态的认知为基础的。</p>
<p>goroutine （通常是main goroutine）具有这种完整的语境知识应该能够告诉其子goroutine终止。我们将在下一章继续研究大规模的goroutine的相互依赖关系，但现在让我们考虑如何确保一个子goroutine被清理。让我们从一个简单的goroutine泄漏开始：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dolork :- <span class="function"><span class="keyword">func</span><span class="params">(strings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;&#123; completed :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> fnt.Println(<span class="string">"doWork exited."</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(completed)</span><br><span class="line"><span class="keyword">for</span> s :u <span class="keyword">range</span> strings &#123;</span><br><span class="line"><span class="comment">//做些有趣的操作</span></span><br><span class="line">fat,Println(s)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> completed</span><br><span class="line">]</span><br><span class="line">doWork(<span class="literal">nil</span>)</span><br><span class="line"><span class="number">11</span>也许这里有其他的操作需要进行</span><br><span class="line">fot.Println(<span class="string">"Done."</span>)</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们看到main goroutine将一个空的channel传递给了doWork。因此，字符串channel永远不会写入任何字符串，并且包含doWork的goroutine将在此过程的整个生命周期中保留在内存中（如果我们在doWork和maingoroutine 中加入了goroutine，甚至会死锁）。</p>
<p>在这个例子中，这个过程的生命周期很短，但是在一个真正的程序中，goroutine可以很容易地在一个长期生命的程序开始时启动。在最糟糕的情况下，main goroutine可能会在其生命周期内持续的将其他的goroutine设置为自旋，这会导致内存利用率的下降。</p>
<p>成功减轻这种情况的方法是在父goroutine和其子goroutine之间建立一个信号，让父goroutine向其子goroutine发出信号通知。按照惯例，这个信号通常是一个名为done的只读channel。父goroutine将该channel传递给子goroutine，然后在想要取消子goroutine时关闭该channel。例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">doWork :-<span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>(&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">strings &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>&lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;&#123;<span class="number">0</span></span><br><span class="line">terminated :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> fmt.Println(<span class="string">"doWork exited."</span>) <span class="keyword">defer</span> <span class="built_in">close</span>(terminated)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s :u&lt;-strings:</span><br><span class="line"><span class="number">11</span>做一些有意思的操作</span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">case</span> &lt;-done:o</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">]</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> terminated</span><br><span class="line">done :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;))</span><br><span class="line">terminated : dolork(done, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="number">0</span></span><br><span class="line"><span class="comment">//在1秒钟之后取消本操作</span></span><br><span class="line">time.sleep(<span class="number">1</span>* time.Second)</span><br><span class="line">fmt. Println(<span class="string">"Canceling dolork goroutine..."</span>) <span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line">&lt;-terminated O</span><br><span class="line">fmt.,Println(<span class="string">"Done."</span>)</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们将完成的channel传递给doWork函数。作为惯例，这个channel是第一个参数。</p>
<p>在这一行上，我们看到了在实际编程中无处不在的select模式。我们的一个案例陈述是检查我们的done channel是否已经发出信号。如果有的话，我们从goroutine返回。</p>
<p>在这里我们创建另一个goroutine，如果超过1s就会取消doWork中产生的goroutine.<br>0这就是我们加入从main goroutine的doWork中产生的goroutine的地方。</p>
<p>然后，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Canceling dolork goroutine... doWork exited.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure></p>
<p>你可以看到，尽管我们给我们的字符串channel中传递了nil，我们的goroutine仍然成功退出。与之前的例子不同，在这个例子中，我们加入了两个goroutine，但没有造成死锁。这是因为在我们加入两个goroutine之前，我们创建了第三个goroutine来在doWork执行1s之后取消doWork中的goroutine。我们已经成功消除了我们的goroutine泄漏！</p>
<p>前面的例子很好地处理了在channel上接收goroutine的情况，但是如果我们正在处理相反的情况：一个goroutine阻塞了向channel进行写人的请求？以下是演示此问题的简单示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">newRandstream :- <span class="function"><span class="keyword">func</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123;</span><br><span class="line">randstrean :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"newRandstream closure exited."</span>)<span class="number">0</span> <span class="keyword">defer</span> <span class="built_in">close</span>(randStrean)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">randStrean &lt;- rand.Int()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> randstrean</span><br><span class="line">]</span><br><span class="line">randstream :- newRandstrean()</span><br><span class="line">fmt.Println(<span class="string">"3 random ints:"</span>)</span><br><span class="line">forl:<span class="number">1</span>;icn3;i++&#123;</span><br><span class="line">fmt.Printf(<span class="string">"xd:xd\n"</span>,i,&lt;-randStrean)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们在goroutine成功终止时打印出一条消息。</p>
<p>运行此代码会产生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 random ints:</span><br><span class="line">1:5577006791947779410 2:8674665223082153551 3:6129484611666145821</span><br></pre></td></tr></table></figure></p>
<p>你可以从输出中看到defer语句中的fmt.Println语句永远不会运行。在循环的第三次迭代之后，我们的goroutine试图将下一个随机整数发送到不再被读取的channel。我们无法告诉生产者它可以停止。解决方案就像接收案例一样，为生产者goroutine提供一个通知它退出的channel：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">newRandStream := <span class="function"><span class="keyword">func</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span>&lt;-<span class="title">chan</span> <span class="title">int</span></span>&#123; randStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> fmt.Println(<span class="string">"newRandstrean closure exited."</span>) <span class="keyword">defer</span> <span class="built_in">close</span>(randstream)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> randStrean c- rand.Int():</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> randStream</span><br><span class="line">done :-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>(J)</span><br><span class="line">randstream :- newRandstream(done)</span><br><span class="line">fmt.Println(<span class="string">"3 random ints:"</span>)</span><br><span class="line"><span class="keyword">for</span> i:m1;ic=<span class="number">3</span>;i++&#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d:%d\n"</span>,i,&lt;-randstream) loseconi</span><br><span class="line"><span class="comment">//模拟正在进行的工作</span></span><br><span class="line">time.Sleep(<span class="number">1</span>* time.Second)</span><br></pre></td></tr></table></figure></p>
<p>代码输出：</p>
<p>我们发现现在goroutine已经被正确地清理了。</p>
<p>现在我们知道如何确保goroutine不泄漏，我们可以规定一个约定：如果goroutine负责创建goroutine，它也负责确保它可以停止goroutine。</p>
<p>这个约定有助于确保你的程序在组合和扩展时可以扩展。我们将在本章后面的“channel”和“context包”中重新讨论这种技术和规则。我们如何确保goroutine能够被停止，可以根据goroutine的类型和用途而有所不同，但是它们所有这些都是建立在完成channel传递的基础上的。</p>
<p>or-channel</p>
<p>有时你可能会发现自己希望将一个或多个完成的channel合并到一个完成的channel中，该channel在任何组件channel关闭时关闭。编写一个执行这种耦合的选择语句是完全可以接受的，尽管很冗长。但是，有时你无法知道你在运行时使用的已完成的channel的数量。在这种情况下，或者如果你只喜欢单线程，你可以使用or-channel模式将这些channel组合在一起。</p>
<p>这种模式通过递归和goroutine创建一个复合done channel。我们来看一下：<br>■⑧⑧⑧⑧⑧⑧</p>
<p>0在这里，我们有我们的函数，或者，它采用可变的channel切片并返回单个channel。<br>日由于这是一个递归函数，我们必须设置终止标准。首先，如果可变切片是空的，我们只返回一个空channel。这是由于不传递channel的观点所产生的，我们不希望复合的channel做任何事情。</p>
<p>我们的第二个终止标准是如果我们的变量切片只包含一个元素，我们只返回该元素。</p>
<p>这是函数的主体，以及递归发生的地方。我们创建了一个goroutine，以便我们可以不受阻塞地等待我们channel上的消息。</p>
<p>基于我们进行迭代的方式，每一次迭代调用都将至少有两个channel。在这里我们为需要两个channel的情况采用了约束goroutine数目的优化方法。</p>
<p>在这里，我们在循环到我们存放所有channel的slice的第三个索引的时候</p>
<p>我们创建了一个or-channel并从这个channel中选择了一个。这将形成一个由现有slice的剩余部分组成的树并且返回第一个信号量。为了使在建立这个树的goroutine退出的时候在树下的goroutine也可以跟着退出，我们将这个orDone channel也传递到了调用中。</p>
<p>这是一个相当简洁的函数，使你可以将任意数量的channel组合到单个channel中，只要任何组件channel关闭或写人，该channel就会关闭。我们来看看如何使用这个功能。下面是一个简短的例子，它将经过一段时间后关闭的channel，并将这些channel合并到一个关闭的单个channel中：</p>
<p>此功能只是创建一个channel，当后续时间中指定的时间结束时将关闭该channel。</p>
<p>日在这里，我们大致追踪来自or函数的channel何时开始阻塞。<br>在这里，我们打印读取发生的时间。<br>如果你运行这个程序，你会得到：<br>done after 1.000216772s<br>请注意，尽管在我们的调用中放置了多个channel或需要不同时间才能关闭，但我们在1s后关闭的channel会导致由该调用创建的整个channel关闭。这是因为尽管它位于树或函数构建的树中，它将始终关闭，因此依赖于其关闭的channel也将关闭。<br>我们以附加的goroutine为代价来实现这个简洁性，f（x）=Lx/27，其中x是goroutine的数量，但要记住Go语言的一个优点是能够快速创建，调度和运行goroutine，并且该语言积极鼓励使用goroutine来正确建模问题。担心在这里创建的goroutine的数量可能是一个不成熟的优化。此外，如果在编译时你不知道你正在使用多少个“done channel”，则将会没有其他方式可以合并“donechannel”。</p>
<p>这种模式在你的系统中的模块交汇处非常有用。在这些交汇处，你的调用堆中应该有复数种的用来取消goroutine的决策树。使用or函数，你可以简单地将它们组合在一起并将其传递给堆栈。我们将在本章后面“context包”中看到另一种做法，这也很好，也许更具描述性。</p>
<p>我们还将了解如何使用此模式的变体在第5章“复制请求”中形成更复杂的模式。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>在并发程序中，错误处理可能难以正确进行。有时候，我们花了很多时间思考我们的各种stage如何共享信息和进行协调，我们忘记考虑它们如何优雅地处理错误的状态。当Go语言避开了流行的错误异常模型时，它声明错误处理非常重要，并且在开发我们的程序时，我们应该给出我们的错误路径给予我们的算法同样的关注。本着这种精神，让我们来看看在处理多个并发进程时我们如何做到这一点。</p>
<p>思考错误处理时最根本的问题是，“谁应该负责处理错误？”在某些时候，程序需要停止将错误输出来，并且实际上对它做了些什么。这么做的目的是什么？</p>
<p>在并发进程中，这个问题变得更复杂一些。因为并发进程独立于其父进程或兄弟进程运行，所以它可能很难推断出错是正确的。查看下面的代码以查看此问题的示例：</p>
<p>在这里，我们看到goroutine在尽最大努力表示出现错误。它还能做什么？它无法传回！有多少错误才是太多？它是否继续提出要求？<br>运行这个代码产生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Response:2000K</span><br><span class="line">Gethttps://badhost:dialtcp:lookupbadhoston127.0.1.1:53:nosuchhost</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们看到在这个问题上goroutine没有选择。它不能简单地吞下错误，因此它只能做出明智的事情：它会打印错误并希望某些内容被关注。不要把你的goroutine放在这个尴尬的位置。我建议你分开你的顾虑：一般来说，你的并发进程应该把他们的错误发送到你的程序的另一部分，它有你的程序状态的完整信息，并可以做出更明智的决定做什么。以下示例演示了此问题的正确解决方案：</p>
<p>在这里，我们创建一个包含*http.Response和从我们的gorouine 中的循环迭代中可能出现的错误的类型。<br>日该行返回一个可读取的channel，以检索循环迭代的结果。<br>·在这里，我们创建一个Result实例，并设置错误和响应字段。<br>0这是我们将结果写入我们的channel的地方。</p>
<p>在这里，在我们的main goroutine中，我们能够智能地处理由 checkStatus启动的goroutine中出现的错误，以及更大程序的完整背景。<br>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Response: 2000K</span><br><span class="line">error:Gethttps://badhost:dialtcp:lookupbadhoston127.0.1.1:53: no such host</span><br></pre></td></tr></table></figure></p>
<p>这里要注意的关键是我们如何将潜在的结果与潜在的错误结合起来。这表示从goroutine checkStatus创建的完整可能结果集，并且允许我们的主要常规关于发生错误时做什么的决定。从更广泛的角度来说，我们已经成功地将错误处理的担忧从我们的生产者goroutine中分离出来。这是可取的，因为生成</p>
<p>goroutine的goroutine （在这种情况下是我们的main goroutine）具有更多关于正在运行的程序的上下文，并且可以做出关于如何处理错误的更明智的决定。</p>
<p>在前面的例子中，我们只是将错误写入stdio（标准输入输出），但我们可以做其他的事情。让我们稍微修改我们的程序，以便在出现三个或更多错误时停止尝试检查状态：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">done :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">errCount :<span class="number">-0</span></span><br><span class="line">urls:=[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>,<span class="string">"https://www.google.com"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125; <span class="keyword">for</span> resuit : <span class="keyword">range</span> checkstatus(done, urls...)&#123;</span><br><span class="line"><span class="keyword">if</span> result.Error !unil&#123;</span><br><span class="line">fmt.Printf(<span class="string">"error:vn"</span>, result.Error)</span><br><span class="line">errCount++</span><br><span class="line"><span class="keyword">if</span> errCount &gt; <span class="number">3</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">"Too many errors, breaking!"</span>) <span class="keyword">break</span></span><br><span class="line">(ontitne</span><br><span class="line">Ft.Printf(<span class="string">'"Response:%vn",result.Response.status'</span></span><br></pre></td></tr></table></figure></p>
<p>代码产生如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: Get a: unsupported protocol scheme --</span><br><span class="line">Response:2000K</span><br><span class="line">error: Get b:unsupported protocol scheme --</span><br><span class="line">error: Get c: unsupported protocol schene&quot;</span><br><span class="line">Too many errors, breaking!</span><br></pre></td></tr></table></figure></p>
<p>你可以看到，因为错误是从checkStatus返回的而不是在goroutine内部处理的，错误处理遵循熟悉的Go语言模式。这是一个简单的例子，但不难想象，main goroutine 正在协调多个goroutine的结果，并制定更复杂的规则来继续或取消子goroutine。此外，这里的主要内容是，在构建从goroutine返回值时，应将错误视为一等公民。如果你的goroutine可能产生错误，那么这些错误应该与你的结果类型紧密结合，并且通过相同的通信线传递，就像常规的同步函数一样。</p>
<h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><p>当你编写一个程序时，你可能不会坐下来写一个长函数，至少我希望你不要！你以函数、结构体、方法等形式构造抽象。为什么要这样做？部分是为了抽象出与大流量无关的细节，另一部分是为了能够在不影响其他区域的情况下处理一个代码区域。你有没有必要对系统进行更改并发现你必须触及多个领域才能做出一个合乎逻辑的改变？这可能是因为该系统有糟糕的抽象。</p>
<p>pipeline是你可以用来在系统中形成抽象的另一种工具。特别是，当你的程序需要流式处理或批处理数据时，它是一个非常强大的工具。pipeline这个词据称是在1856年首次使用的，可能是指将液体从一个地方输送到另一个地方的一系列管道。我们在计算机科学中借用了这个术语，因为我们也在从一个地方向另一个地方传输某些东西：数据。pipeline只不过是一系列将数据输入，执行操作并将结果数据传回的系统。我们称这些操作都是pipeline的一个stage.</p>
<p>通过使用pipeline，你可以分离每个stage的关注点，这提供了许多好处。你可以相互独立地修改各个stage，你可以混合搭配stage的组合方式，而无需修改stage，你可以将每个stage同时处理到上游或下游stage，并且可以扇出或限制部分你的pipeline。我们将在本章后面的“扇出，扇人”中介绍fan- out，我们将在第5章介绍速率限制。你不必担心这些术语现在意味着什么，让我们从简单的开始，尝试构建一个pipeline的stage.</p>
<p>如前所述，一个stage只是将数据输人，对其进行转换并将数据发回。这是一个可以被视为pipeline stage的函数：</p>
<p>这个函数用一个乘法器取一部分整数，随着它的增加循环遍历它们，并返回一个新的变换切片。看起来像一个无聊的函数，是吧？我们来创建另一个stage：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add :=<span class="function"><span class="keyword">func</span><span class="params">(values []<span class="keyword">int</span>, additive <span class="keyword">int</span>)</span>[]<span class="title">int</span></span>&#123;</span><br><span class="line">addedvalues :e nake([]<span class="keyword">int</span>, <span class="built_in">len</span>(values))</span><br><span class="line">fori,v:=<span class="keyword">range</span> values &#123;</span><br><span class="line">addedvalues[i]-v+additive</span><br><span class="line"><span class="keyword">return</span> addedValues</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个无聊透顶的函数！这个函数是创建一个新的切片，并为每个元素添加一个值。在这一点上，你可能想知道是什么使这两个函数成为了pipeline的stage，而不仅仅是函数。让我们尝试将它们合并：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ints :[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>，<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v :mrange add(multiply(ints,<span class="number">2</span>)，<span class="number">1</span>)&#123; fmt.Print1n(v)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>代码产生的输出：<br>5_1<br>0<br>看看我们如何在range子句中结合添加和乘法。这些函数就像你每天工作的函数一样，但是因为我们将它们构建为具有pipeline stage的属性，所以我们可以将它们组合起来形成一个pipeline。那很有意思，pipeline stage的属性是什么？<br>一个stage消耗并返回相同的类型。</p>
<p>一个stage必须用语言来表达，以便它可以被传递2。Go语言中的功能已被证实，并很好地适用于此目的。</p>
<p>注2：<br>在语言环境中，具体化意味着语言向开发人员展示了一个概念，以便他们可以直接使用它。据说Go语言中的函數是通用的，因为你可以定义具有函數签名奧型的变量。这也意味着你可以在你的程序中传递函数。</p>
<p>那些熟悉函数式编程的人可能会点头，并思考像高阶函数和monad这样的术语。事实上，pipeline stage与函数式编程密切相关，可以被认为是monad的一个子集。我不会在这里明确地讨论monad或函数式编程，但它们本身就是一个有趣的主题，并且在尝试理解pipeline时，对这两个主题的工作知识虽然不必要，但是有用。</p>
<p>在这里，我们的add和multiply stage满足pipeline stage的所有属性它们都消耗一个int切片并返回一个int切片，并且因为Go语言具有函数化功能，所以我们可以传递add和multiply。这些属性引起了我们前而提到的 pipeline stage的有趣特性，即在不改变stage本身的情况下，将我们的stage 结合到更高层次变得非常容易。’<br>‘<br>例如，如果我们现在想要为pipeline添加一个额外的stage来乘以2，我们只需将我们以前的pipeline包装在一个新的乘法stage，如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ints :=[]<span class="keyword">int</span>&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, vi-<span class="keyword">range</span> multiply(add(multiply(ints,<span class="number">2</span>)，<span class="number">1</span>)，<span class="number">2</span>)&#123; fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行这个代码将会产生如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br><span class="line">1B</span><br></pre></td></tr></table></figure></p>
<p>注意我们如何在不编写新函数的前提下修改现有函数或修改我们pipeline的结果。也许你已经开始看到使用pipeline模式的好处了。当然，我们也可以在程序上编写这个代码：</p>
<p>最初，这看起来简单得多，但正如我们看到的那样，程序代码在处理数据流时不会提供与pipeline相同的好处。</p>
<p>请注意每个stage是如何获取切片数据并返回切片数据的？这些stage正在执行我们称作批处理的操作。这意味着它们仅对大块数据进行一次操作，而不是一次一个离散值。还有另一种类型的pipeline stage执行流处理。这意味着这个stage一次只接收和处理一个元素。</p>
<p>批处理和流处理有优点和缺点，我们将稍微讨论一下。现在，请注意，为使原始数据保持不变，每个stage都必须创建一个等长的新片段来存储其计算结果。这意味着我们程序在任何时候的内存占用量都是我们发送到我们pipeline开始处的片大小的两倍。让我们将我们的stage转换为以流为导向，看起来如下所示：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multiply :-<span class="function"><span class="keyword">func</span><span class="params">(value, multiplier <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123; <span class="keyword">return</span> value * multiplier</span><br><span class="line">add :- <span class="function"><span class="keyword">func</span><span class="params">(value, additive <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> value + additive</span><br><span class="line">tss ( (nt1,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> _,v:<span class="keyword">range</span> ints&#123;</span><br><span class="line">fmt.Println(multiply(add(multiply(v,<span class="number">2</span>)，<span class="number">1</span>),<span class="number">2</span>)) &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码产生如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">10</span><br><span class="line">HB</span><br></pre></td></tr></table></figure></p>
<p>每个stage都接收并发出一个离散值，我们的程序的内存占用空间将回落到只有pipeline输入的大小。但是我们不得不将pipeline写人到for循环的体内，并让range语句为我们的pipeline进行繁重的提升。这不仅限制了我们供应pipeline的重复使用，而且将在本章后面介绍，这也限制了我们的扩展能力。</p>
<p>还有其他问题。实际上，我们正在为循环的每次迭代实例化我们的pipeline。尽管进行函数调用代价很低，但我们为循环的每次迭代进行三次函数调用。并发性又如何？我前面说过，使用pipeline的好处之一是能够同时处理各个stage，并且我提到了一些关于扇出（fan-out）的内容。所有进来的地方在哪里？</p>
<p>我可能会扩展我们的乘法和增加一些功能来介绍这些概念，但已经完成了介绍流水线概念的工作。现在是时候开始学习在Go语言中构建pipeline的最佳实践了，它始于Go语言的channel基元。</p>
<p>构建pipeline的最佳实践</p>
<p>channel非常适合在Go语言中构建pipeline，因为它们满足了我们所有的基本要求。它们可以接受和产生值，可以安全地同时使用，还可以被放弃，它们被语言所证实。让我们花点时间转换一下前面的例子来改用channel：</p>
<p>看起来我们已经复制了期望的输出，但代价是更多的代码。我们究竟得到了什么？首先，我们来看看我们写的是什么。我们现在有三个函数，而不是两个。它们都看起来像是在他们的函数体内开始了一个goroutine，并使用了我们在本章前面“防止goroutine泄漏”中建立的模式，通过一个channel表示该goroutine应该退出。它们看起来都像是返回channel，其中一些看起来像是在另外一个channel中。很有趣！让我们开始进一步分解：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br></pre></td></tr></table></figure></p>
<p>我们的程序所做的第一件事是创建一个done channel，并在defer语句中关闭它。正如前面所讨论的那样，这可以确保我们的程序干净地离开，不会泄漏goroutine。没啥新东西。接下来，我们来看看函数generator：</p>
<p>generator函数接受一个可变的整数切片，构造一个缓存长度等于输人整数片段的整数channel，启动一个goroutine并返回构造的channel。然后，在创建的goroutine 上，generator函数使用range语句遍历传入的可变切片，并在其创建的channel上发送切片的值。</p>
<p>请注意，channel上的发送与完成channel上的选择共享一条select语句。再一次，这是我们在本章前面“防止goroutine泄漏”中建立的模式，以防止泄漏goroutines。</p>
<p>简而言之，generator函数将一组离散值转换为一个channel上的数据流。适当地说，这种类型的功能称为生成器。在使用流水线时，你会经常看到这一点，因为在流水线开始时，你总是会有一些需要转换为channel的数据。我们将稍微介绍一些有趣的生成器的例子，但我们先来完成对这个程序的分析。接下来，构建我们的pipeline：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline :=multiply(done, add(done, multiply(done,intstream,<span class="number">2</span>)，<span class="number">1</span>)，<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>这与我们一直在努力的流水线相同：对于一串数字，我们将它们乘以2，加1，然后将结果乘以2。这个channel与我们前面例子中使用函数的channel，但它在很重要的方面有所不同。</p>
<p>首先，我们正在使用pipeline。这是显而易见的，因为它允许两件事情：在我们的pipeline的末尾，我们可以使用范围语句来提取值，并且在每个stage我们可以安全地同时执行，因为我们的输入和输出在并发上下文中是安全的。</p>
<p>这给我们带来了第二个不同之处：pipeline的每个stage都在执行控制。这意味着任何stage只需要等待其输人，并且能够发送其输出。事实证明，这会产生巨大的影响，我们将在本章后面“扇出，扇人”中发现，但现在可以简单地注意到它允许我们的stage相互独立地执行某个片段时间。</p>
<p>最后，在我们的例子中，我们对这个pipeline进行了排序，并且通过系统获取了值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v : <span class="keyword">range</span> pipeline &#123; fmt. Println(v)</span><br></pre></td></tr></table></figure></p>
<p>下面是一个表格，演示系统中的每个值如何进入每个channel，以及channel何时关闭。迭代是我们所在的for循环迭代的基数为零的计数，每列的值是pipeline stage的值：</p>
<p>让我们更仔细地研究下我们使用这种模式是如何通知goroutine退出的。当我们处理多个相互依赖的goroutine时，这种模式如何最终起作用？如果我们在程序完成执行之前在完成的channel上调用close，会发生什么情况？</p>
<p>为了回答这些问题，我们需要再来看看我们是如何创建pipeline的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline : multiply(done, add(done, multiply(done, intstream,<span class="number">2</span>)，<span class="number">1</span>),<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>这些stage通过两种方式相互关联：通过通用的done channel，以及通往pipeline后续stage的channel。换句话说，multiply函数创建的channel被传递给add函数等。让我们重新审视前面的表格，并在允许完成之前，关闭完成的channel，看看会发生什么：</p>
<p>知道如何通过pipeline的传递来关闭done channel了吗？这是有pipeline的每个stage中的两件事来使之变为可能：<br>，对传入的channel进行迭代，当传人的channel已经关闭了，range语句也将会退出。</p>
<p>。发送与完成channel共享select语句。<br>无论pipeline stage所处的是什么（在等待传入的channel的状态还是等待发送完成），关闭done channel都将会迫使pipeline stage被终止。<br>这里有一个复发关系。在pipeline开始时，我们已经确定我们必须将离散值转换为channel。在这个过程中有两点必须是可抢占的：<br>。创建几乎不是瞬时的离散值。 。在其channel上发送离散值。<br>首先取决于你。在我们的例子中，在生成器函数中，离散值是通过遍历可变切片生成的，它足够瞬时，不需要被抢占。第二个是通过我们的select语句和done channel处理的，它确保发生器即使被阻塞试图写人intStream也是可抢占的。</p>
<p>在pipeline的另一端，通过感应确保最终stage的可抢占性。这是可抢占的，因为我们正在覆盖的channel在抢占时会被关闭，因此当这种情况发生时，我们的频道将会中断。最后stage是可抢占的，因为我们依赖的流是可抢占的。</p>
<p>在pipeline开始和结束之间，代码总是在使用range语句中遍历channel，并且在一个包含一个done channel的select语句中向其他的channel发送消息。</p>
<p>如果某个stage在从传入channel检索到值时被阻止，则该channel关闭时它将变为未阻止状态。我们通过归纳知道渠道将被关闭，因为它或者是一个stage，就像我们所处的stage一样，或者我们已经建立的pipeline的初始stage是可抢占的。如果某个stage在发送值时被阻塞，则由于select语句而可抢占。</p>
<p>因此，我们的整个pipeline始终可以通过关闭完成channel来抢占。很酷，对吧？<br>一些便利的生成器<br>我早些时候承诺我会谈论一些可能广泛使用的有趣的生成器。提醒一下，pipeline的生成器是将一组离散值转换为channel上的值流的任何函数。我们来看看一个名为repeat的生成器：</p>
<p>这个函数会重复你传给它的值，直到你告诉它停止。让我们来看看另一个通用pipeline stage，这个pipeline stage在重复使用时很有用，请参考：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">take := <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">valuestream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, num <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>&lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">takeStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> Close(takeStream)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;num;i++&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> takeStream &lt;- valuestream:</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> takeStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个pipeline stage只会从其传人的valueStream中取出第一个num项目，然后退出。两者结合在一起可以非常强大：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">done :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"><span class="keyword">for</span> num :- <span class="keyword">range</span> take(done, repeat(done, <span class="number">1</span>),<span class="number">10</span>)&#123; fmt.Printf(<span class="string">"%v"</span>,num) ]</span><br></pre></td></tr></table></figure></p>
<p>运行这个代码将产生：<br>1111111111<br>在这个基本的例子中，我们创建了一个重复生成器来生成无限数量的数字1，但是只取前10个。由于重复生成器的发送块在接收stage的接收，重复生成器非常有效。尽管我们有能力生成无限数量的流，但我们只生成N↵1个实例，其中N是我们传递到take stage的数量。</p>
<p>我们可以扩展这一点。让我们创建另一个重复的生成器，但是这次我们创建一个重复调用函数的生成器。我们称之为repeatFn：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repeatFn :- <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">fn <span class="keyword">func</span>()</span><span class="title">interface</span></span>&#123;&#125;,</span><br><span class="line">)&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>(&#125;&#123;</span><br><span class="line">valueStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) gofunc()&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(valueStrean) <span class="keyword">for</span>&#123; <span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> valueStream&lt;- fn():</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> valueStrean</span><br></pre></td></tr></table></figure></p>
<p>我们用它来生成10个随机数字：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">done :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">rand :- <span class="function"><span class="keyword">func</span><span class="params">()</span><span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> rand.Int()]</span><br><span class="line"><span class="keyword">for</span> num :- <span class="keyword">range</span> take(done, repeatFn(done, rand)，<span class="number">10</span>)&#123; fnt.Printin(num) &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下：</p>
<p>这非常酷，一个根据需要生成随机整数的无限channel！</p>
<p>你可能想知道为什么所有这些发生器和stage都在interface{}的channel上接收和发送数据。我们可以很容易地将这些函数写成特定的类型，或者可以编写Go语言生成器。</p>
<p>Go语言中的空接口有点不太好，但对于pipeline stage，我认为可以处理interface {}的channel，以便使用标准的pipeline模式库。正如我们前面所讨论的，许多pipeline的效用来自可重用的stage.当stage以适合自身的特异性水平进行操作时，这是最好的。在repeat和repeatFn生成器中，关心的是通过在列表或运算符上循环来生成数据流。随着take stage，担忧正在限制我们的pipeline。这些操作都不需要关于它们正在处理的类型的信息，而只需要知道参数的类型。</p>
<p>当你需要处理特定的类型时，你可以放置一个为你执行类型断言的stage。有一个额外的pipeline stage（因此goroutine）和类型断言的性能开销可以忽略不计，正如我们稍后会看到的。下面是一个介绍tostring pipeline stage的小例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">toString :- <span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">valueStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, )</span>&lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">stringStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stringstrean)</span><br><span class="line"><span class="keyword">for</span> v :<span class="keyword">range</span> valueStream &#123; <span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> 《-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">strintrere- v.(<span class="keyword">string</span>): &#125;()</span><br><span class="line"><span class="keyword">return</span> stringStream</span><br></pre></td></tr></table></figure></p>
<p>以及如何使用它的一个例子：</p>
<p>输出如下：<br>nessage:Iam.Iam.I.<br>因此，让我们向自己证明，将通用部分pipeline的性能成本忽略不计。我们将编写两个基准测试函数：一个测试通用stage，一个测试类型特定stage：</p>
<p>运行这段代码的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGeneric-4 BenchmarkTyped-4 PASS</span><br><span class="line">ok</span><br><span class="line">1000000 1000000</span><br><span class="line">command-line-arguments</span><br><span class="line">2266</span><br><span class="line">1181</span><br><span class="line">3.486s</span><br><span class="line">ns/op</span><br><span class="line">ns/op</span><br></pre></td></tr></table></figure></p>
<p>你可以看到，类型相关的stage运行速度是非类型相关的两倍，但速度只有极快。一般来说，pipeline上的限制因素将是你的生成器，或者是计算密集型的一个stage。如果生成器不像repeat和repeatFn生成器那样从内存中创建流，则可能会受I/O限制。从磁盘或网络中读取数据可能会使测试结果显示在此处。</p>
<p>如果你的一个stage在计算上花费很大，那么这肯定会使这种性能开销消失。如果这种技术在你的嘴里仍然留下不好的味道，你总是可以编写一个Go语言生成器来创建你的发生器stage。说到一个stage计算成本很高，我们该如何帮助缓解这个问题呢？它不会限制整个pipeline的速度吗？</p>
<p>为了缓解这种情况，让我们来讨论扇出扇入（fan-out，fan-in）技术。</p>
<p>扇入，扇出</p>
<p>假设你已经建立了一条pipeline。数据流畅地流过你的系统，在你连接在一起的各个stage进行转换。它就像一条美丽的溪流（stream），一个美丽的，缓慢的溪流，哦，上帝啊！为什么这需要这么久？</p>
<p>有时候，pipeline中的各个stage可能在计算上特别昂贵。发生这种情况时，你的pipeline中的上游stage可能会被阻塞，同时等待昂贵的stage来完成。不仅如此，pipeline本身可能需要很长时间才能全部执行。我们如何解决这个问题？<br>pipeline的一个有趣属性是它们能够让你使用独立的，并且可以常常重新排序的stage的组合来操作数据流。你甚至可以多次重复使用pipeline的各个stage。在多个goroutine上重用我们的pipeline的单个stage以试图并行化来自上游stage的pull是不是很有趣？也许这将有助于提高pipeline的性能。</p>
<p>事实上，事实证明它可以，而这种模式有一个名字：扇入，扇出。</p>
<p>扇出是一个术语，用于描述启动多个goroutines以处理来自pipeline的输入的过程，并且扇入是描述将多个结果组合到一个channel的过程中的术语。</p>
<p>那么什么时候一个pipeline的stage适合利用这种模式呢？如果以下两种情况适用，你可以考虑在某个stage使用：<br>它不依赖于之前stage计算的值。。运行需要很长时间。</p>
<p>循序独立性很重要，因为你无法保证你的stage的并发副本以何种顺序运行，也无法保证其返回的顺序</p>
<p>我们来看一个例子。在下面的例子中，我构建了一个用来找到素数的非常低效的函数。我们将使用在本章前面“pipeline”中创建的许多stage：</p>
<p>这些代码的输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Primes:</span><br><span class="line">24941317</span><br><span class="line">36122539</span><br><span class="line">6410693</span><br><span class="line">10128161</span><br><span class="line">25511527</span><br><span class="line">2107939</span><br><span class="line">14004383</span><br><span class="line">7190363</span><br><span class="line">45931967</span><br><span class="line">2393161</span><br><span class="line">Search took:23.4375116475</span><br></pre></td></tr></table></figure></p>
<p>我们生成一串随机数，最高为50000000，将数据流转换为整数流，然后将其传入我们的primeFinder stage。 primeFinder天真地开始试图将输入流上的数字除以它的每个数字。如果不成功，它会将该值传递到下一个stage。当然，这是尝试找到素数的可怕方法，但它符合我们pipeline将花费很长时间的要求。</p>
<p>在我们的循环中，我们搜索找到的素数，在它们进入时将其打印出来，并感谢我们的stage，在找到10个素数后关闭pipeline。然后，我们打印出搜索花了多长时间，并通过defer语句关闭了完成的channel，并且将pipeline关闭。</p>
<p>为了避免重复结果出现在我们的结果集中，我们可以在pipeline中引入另一个stage来缓存已在集合中找到的素数，但为了简单起见，我们将忽略这些。</p>
<p>你可以看到大概需要23s才能找到10个素数。不是很好。通常我们首先看一下算法本身，也许拿出一本算法手册，看看我们是否可以在每个stage进行改进。但是，由于这里的stage本身的目的就是缓慢的，我们将看看我们如何能够展开一个或多个stage，以便更快地熬过慢速操作。</p>
<p>这是一个相对简单的例子，而我们只有两个stage：随机数生成和素数筛选。在一个更大的程序中，你的pipeline可能由更多的stage组成，我们怎么知道哪一个扇出？请记住我们之前的标准：独立性和持续时间。我们的随机整数发生器肯定是顺序无关的，但运行起来并不需要很长时间。primefinder stage也是顺序无关的，数字不是主要的，因为我们的朴素算法，它肯定需要很长时间才能运行。它看起来是一个很好的候选。</p>
<p>幸运的是，在pipeline中分散stage的过程非常容易。我们所要做的就是启动该stage的多个版本。所以不是这样的：<br>primeStrean :- primeFinder(done, randIntstream) 我们可以做这样的事情：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numFinders :-runtime.NunCPU()</span><br><span class="line">finders :- <span class="built_in">make</span>([]&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, numFinders)</span><br><span class="line"><span class="keyword">for</span> i :mo;i&lt;numFinders;i++&#123;</span><br><span class="line">finders[i] - primeFinder(done, randIntStream) &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里我们启动了这个stage的许多副本，因为我们有多个CPU核心。在我的计算机上，runtime.NumCPU（）返回8，所以我们将继续在我们的讨论中使用这个数字。在生产中，我们可能会做一些经验性的测试来确定CPU的最佳数量，但在这里我们将保持简单，并且假设只有一个findPrimes stage的CPU会被占用。</p>
<p>就是这样！我们现在有8个goroutine从随机数发生器中拉出并试图确定数字是否为素数。生成随机数不应该花费太多时间，因此findPrimes stage的每个goroutine应该能够确定它的数字是否为素数，然后立即有另一个随机数可用。</p>
<p>但是我们仍然有一个问题：既然我们有4个goroutine，还有4个channel，但是我们的素数范围仅等于一个channel。这将是我们使用扇入（fan-in）模式的绝佳实例。</p>
<p>正如我们前面所讨论的，扇人意味着将多个数据流复用或合并成一个流。这样做的算法相对简单：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fanIn :<span class="function"><span class="keyword">func</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">done &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">channels...-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;)</span>,</span></span><br><span class="line"><span class="function">)&lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;&#123;<span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> wg sync. WaitGroup e</span><br><span class="line">multiplexedStream := nake(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) multiplex :- <span class="function"><span class="keyword">func</span><span class="params">(c&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;<span class="number">0</span> <span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> i :- <span class="keyword">range</span> c&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">casec-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> multiplexedstrean &lt;-i: &#125; &#125;</span><br><span class="line"><span class="number">11</span>从所有的channel里取值</span><br><span class="line">wg.Add(<span class="built_in">len</span>(channels))<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, c :<span class="keyword">range</span> channels &#123; <span class="keyword">go</span> multiplex(c) &#125;</span><br><span class="line"><span class="comment">//等待所有的读操作结束</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;<span class="number">0</span></span><br><span class="line">ng.Nait()</span><br><span class="line"><span class="built_in">close</span>(multiplexedstrean)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> multiplexedstream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>0在这里，我们采用我们的标准done channel来允许我们的goroutine被拆除，然后是一个可变的interface{}channel用来扇入。</p>
<p>@在这一行中，我们创建了一个sync.WaitGroup，以便我们可以等待知道所有channel都已耗尽。</p>
<p>在这里，我们创建一个函数multiplex，它在传递时将从channel中读取，并将读取的值传递到multiplexedStream channel。</p>
<p>0此行将sync.WaitGroup增加我们多重channel的数量。<br>在这里，我们创建一个goroutine来等待我们多路复用的所有channel被耗尽，这样我们可以关闭multiplexedStream channel.</p>
<p>简而言之，扇人涉及创建用户将读取的多路复用channel，然后为每个传入 channel启动一个goroutine，以及在传入channel全部关闭时关闭复用channel的goroutine。由于我们要创建一个等待N个其他分区完成的goroutine，创建一个sync.WaitGroup来协调是很有意义的。多路复用功能还通知WaitGroup它已完成。</p>
<p>额外的提醒</p>
<p>如果结果到达的顺序不重要，那么对于扇入，扇出算法的幼稚实现将起作用。我们没有做任何事情来保证从randIntstream中读取项目的顺序在筛选过程中保留下来。稍后，我们将看一个保持运行顺序的例子。</p>
<p>让我们把所有这些放在一起，看看我们在运行时是否有所减少：</p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spinning up 8 prime finders. Primes:</span><br><span class="line">6410693</span><br><span class="line">24941317</span><br><span class="line">10128161</span><br><span class="line">36122539</span><br><span class="line">25511527</span><br><span class="line">2107939</span><br><span class="line">14004383</span><br><span class="line">7190363</span><br><span class="line">2393161</span><br><span class="line">45931967</span><br><span class="line">Search took:5.438491216s</span><br></pre></td></tr></table></figure></p>
<p>所以从大概23秒降到大概5秒，还不错！这清楚地表明了扇入，扁出模式的好处，它重新定义了管道的用途。我们将执行时间缩短了大约78%，也不会大幅改变程序的结构。</p>
<p>or-done-channel</p>
<p>有时候，你需要处理来自系统各个分散部分的channel。与pipeline所不同的是，你不能对一个被done channel所取消的channel将会进行什么行为做任何的断言。也就是说，你不知道你的goroutine是否被取消，这意味着你正在读取的channel将被取消。出于这个原因，正如在本章前面“防止goroutine泄漏”中所阐述的那样，我们需要用channel中的selct语句来包装我们的读操作，并从已完成的channel中进行选择。这非常好，但是这样做需要的代码很容易读取，如下所示：</p>
<p>如下操作可能会使goroutine激增：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">break</span> loop</span><br><span class="line"><span class="keyword">case</span> maybeVal, ok :-&lt;-myChan: <span class="keyword">if</span> ok u <span class="literal">false</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">//或许从for循环中退出//用val执行某些操作 &#125; J</span></span><br></pre></td></tr></table></figure></p>
<p>这可能会很快就繁忙起来，特别是如果你有嵌套循环。继续使用goroutine编写更清晰的并发代码，而不是过早优化，我们可以用一个goroutine来解决这个问题。我们封装了详细信息，以便于其他的函数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">orDone :- <span class="function"><span class="keyword">func</span><span class="params">(done,c&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;&#125;&#123; valStream :u <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> <span class="built_in">close</span>(valStream)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> v, ok :wcc</span><br><span class="line"><span class="keyword">if</span> ok u <span class="literal">false</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> vaistream &lt;- v: <span class="keyword">case</span> c-done:</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> valstrean</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>这样做可以让我们回到简单的循环，就像这样：</p>
<p>你可能会在你的代码中发现需要使用一系列select语句的紧密循环的边界案例，但我会鼓励你先尝试编写具有可读性的代码，并避免过早优化。</p>
<p>tee-channel<br>有时候你可能想分割一个来自channel的值，以便将它们发送到你的代码的两个独立区域中。设想一下，一个传递用户指令的channel：你可能想要在一个channel上接收一系列用户指令，将它们发送给相应的执行器，并将它们发送给记录命令以供日后审计的东西。<br>从类UNIX系统中的tee命令中获得它的名字，tee-channel就是这样做的。你可以将它传递给一个读channel，并且它会返回两个单独的channel，以获得相同的值：</p>
<p>0 我们将要使用out1和out2的本地版本，所以我们会隐藏这些变量。<br>我们将使用一条select语句，以便不阻塞的写入out1和out2。为确保两者都写人，我们将执行select语句的两次迭代：每个出站一个channel。日一旦我们写人了channel，我们将其影副本设置为nil，以便进一步阻塞写人，而另一个channel可以继续。<br>注意写入out1和out2是紧密耦合的。直到out1和out2都被写入，迭代才能继续。通常来说这并不是一个问题，因为处理来自每个channel的吞吐量都应该是一个确定的某个之外而不是像tee命令那样，但这并没有任何的价值。下面是一个快速示例：<br>done :- make(chan interface({<br>defer close(done)<br>out1, out2 :-tee(done, take(done, repeat(done,1,2)，4))<br>for val1 : range out1{<br>fmt.Printf(“out1:v,outz:vn”,val1, &lt;-outz) }<br>通过这种模式，对于你的系统来说，继续使用channel作为“join点”将会是易如反掌的事。<br>桥接channel模式<br>在某些情况下，你可能会发现自己希望从一系列的channel中消费产生的值：<br>&lt;-chan &lt;-chan interface{}<br>这与将channel切片合并到单个channel中稍有不同，如我们在本章前面“Theor-channel”或“扇出，扇人”中所看到的。一系列的channel需要有序地写人，</p>
<p>即使是不同的来源。其中一个例子是一个整个生命周期都是间歇的pipelinestage。如果按照我们在本章前面“约束”中建立的方式并确保channel都被写入它们的goroutine拥有，在每一个新的goroutine 中的pipeline stage重启的时候，都会创建一个新的channel。这也就意味着我们很有效地拥有了一个channel系列。我们将在第5章“治愈不健康的goroutine”中详细探讨这种情况。<br>作为消费者，代码可能不关心其值来自于一系列的channel的事实。在这种情况下，处理一个充满channel的channel的可能会很多。如果我们定义一个功能，可以将充满channel的channe1拆解为一个简单的channel（一种称为桥接channe的技术），这将使消费者更容易关注手头的问题。以下是我们如何实现这一目标的一个例子：</p>
<p>0这是将返回bridge中的所有值的channel。<br>@这个循环负责从chanStream中提取channel并将其提供给嵌套循环来使用。<br>该循环负责读取已经给出的channel中的值，并将这些值重复到 valStream中。当我们当前正在循环的流关闭时，我们从执行从此channel读取的循环中跳出，并继续循环的下一次迭代，选择要读取的channel。这为我们提供了一个不间断的结果值的流。<br>这是非常简单的代码。现在我们可以使用桥接来实现一个在一个包含多个 channel的channel上实现一个单channel的门面（facade）。下面是一个例子，它创建了10个channel，每个channel都写人一个元素，并将这些channel传递给桥接函数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">genVals :- <span class="function"><span class="keyword">func</span><span class="params">()</span>&lt;-<span class="title">chan</span> &lt;-<span class="title">chan</span> <span class="title">interface</span></span>&#123;)&#123;</span><br><span class="line">chanStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;))) <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> <span class="built_in">close</span>(chanStream)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">stream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;,<span class="number">1</span>) stream &lt;-i</span><br><span class="line"><span class="built_in">close</span>(stream)</span><br><span class="line">chanStrean d- strean</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> chanStrean</span><br><span class="line">-ar w :e <span class="keyword">range</span> bridge(ni1.genvals0) fmt,Printf(<span class="string">"%v"</span>,v)</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行这将产生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p>
<p>通过桥接，我们可以在单个range语句中使用处理channel的channel，并专注于我们的循环逻辑。解构处理channel的channel留给特定于这个问题的代码。</p>
<p>队列排队</p>
<p>有时，在你的队列尚未准备好的时候就开始接受请求是很有用的。这个过程被称作队列。</p>
<p>这也就意味着只要你的stage完成了某些工作，它就会把结果存储在一个稍后其他stage可以获取到结果的临时存储位置，而且你的stage不需要保存一份指向结果的引用。在第3章“channel”中，我们讨论了带缓存的channel，那其实就是一种队列，而且我们当时有足够的理由不去过多讨论使用它。<br>虽然在系统中引人队列功能非常有用，但它通常是优化程序时希望采用的最后一种技术之一。预先添加队列可以隐藏同步问题，例如死锁和活锁，并且，随着程序向正确性收敛，你可能会发现需要更多或更少的队列。<br>那么队列有什么好处呢？让我们开始回答这个问题，通过解决人们在调整系统性能时犯的一个常见错误：引入队列来尝试解决性能问题。队列几乎不会加速程序的总运行时间，它只会让程序的行为有所不同。<br>为了理解它的原因，我们来看看一个简单的pipeline：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">zeros :=take(done,<span class="number">3</span>,repeat(done,o)) short :- sleep(done, i*time.Second, zeros) long :=sleep(done, <span class="number">4</span>*time.Second, short) pipeline := long</span><br></pre></td></tr></table></figure></p>
<p>该管道将4个stage连在一起：<br>1，一个重复的stage，会产生层出不穷的0。<br>2.当pipeline中有3个元素的时候会取消上一个stage，即取消产生“无限个0” 的stage.</p>
<p>3.暂停1s的“短”stage。<br>4.一个长的，暂停4s的stage.<br>对于这个例子来说，我们假设stage 1和stage2是即时完成的，让我们关注休眼stage如何影响pipeline的运行时间。<br>下面的这个表格是用来展示时间（t），迭代变量（i），以及“长”“短”stage运行到取下一个值所需要的时间。</p>
<p>你可以看到这个pipeline需要大约13s的时间来运行。短暂的stage大约需要9s才能完成。<br>如果我们修改管道以包含缓冲区会发生什么？让我们来看看在长期和短期之间引入2的缓冲区的相同管道：<br>done :-make(chan interface{}) defer close(done)</p>
<p>这是运行时间：</p>
<p>整个管道仍然需要13s！但看看短期的运行时间。它仅在3s后完成，而不是之前的9s。我们已经将这个stage的运行时间减少了三分之二！但是如果整个管道仍然需要13s来执行，这对我们有什么帮助？<br>让我们来看下面这个pipeline：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:=processRequest(done, acceptConnection(done, httpHandler))</span><br></pre></td></tr></table></figure></p>
<p>这里pipeline在取消之前不会退出，并且接收连接的stage不会停止接收连接，直到取消channel。在这种情况下，你不希望到你程序的链接超时，因为你的processRequest stage阻止了你的acceptConnection stage。你希望尽可能地解除你的acceptconnection stage。否则，你的程序的用户可能会开始发现他们的请求完全被拒绝。</p>
<p>因此，对于引人队列的效用问题的答案并不是一个stage的运行时间已经减少，而是它处于阻塞状态的时间减少了。这可以让这个stage继续工作。在这个例子中，用户可能会在他们的请求中经历滞后，但他们不会被拒绝服务。</p>
<p>通过这种方式，队列的真正用途是将stage分离，以便一个stage的运行时间不会影响另一个stage的运行时间。以这种方式解耦stage，然后级联以改变整个系统的运行时行为，这取决于你的系统，可以是好的也可以是不好的。</p>
<p>然后我们来讨论调整你的排队问题。队列应该放在哪里？缓冲区大小应该是多少？这些问题的答案取决于你的管道的性质。<br>首先分析排队可以提高系统整体性能的情况。唯一适用的情况是：<br>。如果在一个stage批处理请求节省时间。<br>。如果stage中的延迟产生反馈回路进入系统。第一种情况的一个例子是将<br>输入缓冲到比被设计为发送给（例如，盘）更快的事物（例如，存储器）的stage.<br>很显然，这就是Go语言的bufio包的目的。下面是一个示例，演示了缓冲写人队列与未缓冲写入的简单比较：</p>
<p>以下是运行此基准的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkUnbufferedWrite-8 BenchmarkBufferedWrite-8 PASS</span><br><span class="line">ok</span><br><span class="line">500000</span><br><span class="line">3969</span><br><span class="line">1000000</span><br><span class="line">1356</span><br><span class="line">connand-line-arguments 3.398s</span><br><span class="line">ns/op</span><br><span class="line">ns/op</span><br></pre></td></tr></table></figure></p>
<p>如预期的那样，缓冲写入比未缓冲写人更快。这是因为在bufio.Writer中，写入在内部排队到缓冲区中，直到已经积累了足够的块为止，然后块被写出。这个过程通常称为分块，原因很明显。</p>
<p>分块速度更快，因为bytes.Buffer必须增加其分配的内存以容纳它必须存储的字节。出于各种原因，增长的内存消耗是昂贵的。所以，我们需要增长的时间越少，整个系统的整体效率就越高。因此，排队提高了整个系统的性能。</p>
<p>这只是一个简单的内存分块示例，但是你可能会在该领域频繁地进行分块。通常，任何时候执行操作都需要开销，分块可能会提高系统性能。这方面的一些例子是打开数据库事务，计算消息校验和以及分配连续空间。</p>
<p>除了分块之外，如果你的算法可以通过支持向后看或排序进行优化，排队也可以起到帮助作用。</p>
<p>第二种情况是，一个stage的延迟导致管道中接收到了更多的输入，这更难以发现，但也更重要，因为它可能导致上游系统的崩溃。<br>这个想法通常被称为负反馈循环，向下螺旋，甚至是死亡螺旋。这是因为管道与上游系统之间存在经常性关系，上游stage或系统提交新请求的速度在某种程度上与管道的有效性有关。</p>
<p>如果管道的效率降低到某个临界阈值以下，管道上游的系统开始增加它们对管道的输入，这导致管道损失更多效率，并且死亡螺旋开始。如果没有某种安全防护，使用管道的系统将永远不能恢复。</p>
<p>通过在管道入口处引入队列，你可以用创建请求滞后为代价来打破反馈循环。从调用者进人管道的角度来看，请求似乎正在处理中，但需要很长时间。只要调用者不超时，你的管道将保持稳定。如果主叫方超时，则需要确保你在出列时支持某种检查准备情况。如果你不这样做，你可能会无意中通过处理死亡请求来创建反馈循环，从而降低管道的效率。</p>
<p>你有没有见过死亡螺旋？</p>
<p>如果你曾尝试访问一些热门的新系统（例如，新游戏服务器，用于产品发布的网站等），并且尽管开发人员尽了最大的努力，但该网站一直处于弹跳状态，恭喜！你可能目睹了一个负面反馈的循环。<br>开发团队开始尝试不同的修复方法，直到有人意识到他们需要一个队列，并且开始匆忙实施。</p>
<p>然后客户开始抱怨排队时间！</p>
<p>所以从我们的例子中，我们可以看到一种模式的出现，需要实现排队模式：，在你的管道入口处。</p>
<p>。在这个stage，批量操作将会带来更高的效率。<br>你可能会尝试在其他的地方增加队列。例如，在一个重度计算stage之后。但是，请避免那样的尝试！就像我们所学到的，只有在很少的情况下队列可以减少你管道的运行时间。而且，在队列中胡乱操作可能会导致灾难性的后果。或许，在最初这并不会显得很明显，我们需要讨论管道的吞吐量来了解为什么会导致这个情况的原因。别担心，这并不难。而且他会帮我们回答对于如何决定需要用多大的队列的问题。<br>在“队列”理论中，有这样的一条法则，通过足够的取样，可以预测管道的需求率。这被称作利特尔法则。我们首先定义利特尔法则的共识。它一般被表达为：L=》W，其中：<br>L=系统中平均负载数。<br>，入=负载的平均到达率。<br>，W=负载在系统中花费的平均时间。<br>这个等式只可以应用在所谓的稳定的系统。在管道中，一个稳定的系统是指工作负载进入管道，或者说人口的速率与负载退出系统的速率相等。如果入口的速率超过了出口的速率，你的系统就是不稳定的，而且已经进入了一个死循环。如果你的人口速率没有超过出口速率，你仍旧造成了一个不稳定的系统，但这所导致的也仅仅是你的系统资源并没有被完全使用而已。那并不是这个世界上最糟糕的情况，但是，你可能会在大规模系统（例如，集群或者数据中心）中关心这个问题。<br>所以，让我们先认为我们的管道是稳定的，如果想要将W（也就是一个负载）在我们系统中所花费的平均时间减少一个系数n。而且我们在增加系统出口的速率的时候，只能减少系统中存在的平均负载的数量。需要注意的是，如果在我们的stage中增加了队列，我们其实是在增加，也就是说，或是增加了</p>
<p>负载到达的速率（nl=n<em>W），或是增加了一个负载在系统中花费的平均时间（nL=\</em>nW）。通过利特尔法则，我们已经证明了队列不会有助于减少在系统中所花费的时间。<br>同时请注意，由于我们正在观察整个管道，因此将W减少n倍将分布在我们管道的所有stage。在我们的案例中，小法的定义应该是这样的：<br>L=入EW；<br>这是另一种说法，你的管道只会和最慢的stage一样快。不分青红皂白地优化！<br>所以利特尔法则很整洁！这个简单的等式打开了各种分析我们管道的方法。让我们用它来问一些有趣的问题。在我们的分析中，假设我们的管道有三个stage。<br>让我们尝试确定我们的管道每秒可以处理多少个请求。假设我们在我们的流水线上启用采样，并发现1个请求（r）需要大约1s才能通过流水线。让我们插人这些数字！<br>3r=Xr/s*1s 3r/s■Xr/s 入r/s=3r/s<br>我们将L设置为3，因为我们管道中的每个stage都在处理请求。然后我们将W设置为1s，做一个小代数，然后瞧！在这个管道中，我们每秒可以处理三个请求。<br>如何确定我们的队列需要多大才能处理所需数量的请求。利特尔法则能帮助我们回答这个问题吗？</p>
<p>假设我们的采样表明请求需要1ms来处理。我们的队列需要处理每秒100000次请求的大小是多少？让我们再一次插人数字！<br>Lr-3r=1oo000r/sx0.0001s Lr-3r=10r<br>Lr=7r<br>同样，我们的pipeline有三个stage，所以我们将L递减3，入设置为100000r/s，并且发现如果我们想要处理很多请求，我们的队列应该有7个容量。请记住，你增加队列的大小，它需要更长的时间才能通过系统！你实际上在延迟交易系统利用率。<br>利特尔法则无法预知的情况是处理请求的失败。请记住，如果由于某种原因你的管道发生混乱，你将丢失队列中的所有请求。这可能使重新创建请求变得很困难或者不会发生，这是需要防范的。为了缓解这种情况，你可以坚持队列大小为零，或者可以转移到一个持久队列，这只是一个队列，可以在需要时随时读取的地方保存。<br>队列在你的系统中可能很有用，但由于它的复杂性，它通常是我建议实现的最后的一个优化手段。<br>context包<br>正如我们所看到的，在并发程序中，由于超时，取消或系统其他部分的故障往往需要抢占操作。我们已经看过了创建donechannel的习惯用法，该channel在你的程序中流动并取消所有阻塞的并发操作。这很好，但它也是有限的。<br>如果我们可以在简单的通知上附加传递额外的信息以取消：为什么取消发生，或者我们的函数是否有需要完成的最后期限（超时），这将非常有用。</p>
<p>事实证明，对于任何规模的系统来说，使用这些信息来包装已完成的频道是非常常见的，因此Go语言的作者们决定为此创建一个标准模式。它起源于一个在标准库之外的实验功能，但是在Go1.7中，context包被引入标准库中，这使得它成为考虑并发问题时的一个标准的风格。<br>如果看一下上下文包，我们看到它非常简单：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled - errors.New(<span class="string">"context canceled"</span>)</span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded error . deadlineExceededError&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> CancelFunc</span><br><span class="line"><span class="keyword">type</span> Context</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span></span><br><span class="line"><span class="function"><span class="title">funcTOD0</span><span class="params">()</span><span class="title">Context</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Withcancel</span><span class="params">(parent Context)</span><span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline tine.Time)</span><span class="params">(Context, CancelFunc)</span> <span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, tineout time.Duration)</span><span class="params">(Context, CancelFunc)</span> <span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span><span class="title">Context</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们稍后会重新讨论这些类型和函数，但现在让我们关注context类型。这是通过系统流动的类型，就像done channel一样。如果使用上下文包，那么位于顶级并发调用下游的每个函数都会将context作为其第一个参数。类型如下所示：</p>
<p>这看起来也很简单。有一个Done方法返回当我们的函数被抢占时关闭的channel。还有一些新的但易于理解的方法：一个Deadline函数，用于指示在一定时间之后goroutine是否会被取消，以及一个Err方法，如果goroutine被取消，将返回非零。但Value方法看起来似乎有点不合适。这是为了什么呢？<br>Go语言作者们注意到，goroutine的主要用途之一是为请求提供服务的程序。通常在这些程序中，除了抢占信息之外，还需要传递特定于请求的信息。这是Value函数的目的。我们稍后会进一步讨论这个问题，但现在我们只需要知道上下文包有两个主要目的：<br>。提供一个可以取消你的调用图中分支的API。 。提供用于通过呼叫传输请求范围数据的数据包。<br>让我们关注第一个方面：取消。<br>正如我们在本章前面“防止goroutine泄漏”中所学到的，函数中的取消有三个方面：<br>goroutine 的父goroutine可能想要取消它。<br>一个goroutine可能想要取消它的子goroutine。<br>goroutine中的任何阻塞操作都必须是可抢占的，以便它可以被取消。<br>context包帮助管理所有这三个东西。<br>正如我们所提到的，context类型将是你的函数的第一个参数。如果你看看 context接口上的方法，你会发现没有任何东西可以改变底层结构的状态。 此外，接收context的函数并不能取消它。这保护了调用堆栈上的函数被子</p>
<p>函数取消上下文的情况。结合done channel提供的完成函数，这允许上下文类型安全地管理其前件的取消。<br>这就产生了一个问题：如果context是不可变的，那么我们如何影响调用堆栈中当前函数下面的函数中的取消行为？<br>这是context包中的功能变得重要的地方。让我们再看看其中的几个，来刷新我们的印象：<br>func WithCancel(parent Context)(ctxContext, cancel cancelFunc)<br>func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)请注意，所有这些函数都接受一个context参数，并且返回一个context。其中一些还有其他的参数，如截止时间和超时参数。这些函数都使用与这些函数相关的选项来生成Context的新实例。<br>WithCancel返回一个新的Context，它在调用返回的canel函数时关闭其done channel。 WithDeadline返回一个新的Context，当机器的时钟超过给定的最后期限时，它关闭完成的channel。WithTimeout返回一个新的Context，它在给定的超时时间后关闭其完成的channel。<br>如果你的函数需要以某种方式在调用图中取消它后面的函数，它将调用其中一个函数并传递给它的上下文，然后将返回的上下文传递给它的子元素。如果你的函数不需要修改取消行为，那么函数只传递给定的上下文<br>通过这种方式，调用图的连续图层可以创建符合其需求的上下文，而不会影响其父母节点。这为如何管理调用图的分支提供了一个非常可组合的优雅解决方案。<br>context包就是本着这种精神来串联起你程序的调用图的。在面向对象的范例中，通常将对经常使用的数据的引用存储为成员变量，但重要的是不要使</p>
<p>用context.context的实例来执行此操作。context.context的实例可能与外部看起来相同，但在内部它们可能会在每个栈帧更改。出于这个原因，总是将context的实例传递给你的函数是很重要的。通过这种方式，函数具有用于它的上下文，而不是用于堆栈N的上下文。<br>在异步调用图的顶部，你的代码可能不会传递上下文。要启动链，上下文包提供了两个函数来创建上下文的空实例：<br>func Background()context func TOD0()Context<br>Background（）只是返回一个空的上下文。TODO（）不是用于生产，而是返回一个空的上下文。TOD0（）的预期目的是作为一个占位符，当你不知道使用哪个上下文，或者你希望你的代码被提供一个上下文，但上游代码还没有提供。<br>所以让我们把所有这些用于使用。我们来看一个使用完成channel模式的例子，并且看看我们可以从切换到使用context包获得什么好处。这是一个同时打印问候和告别的程序：</p>
<p>运行此代码会产生：<br>goodbye world! hello world!<br>忽略竞争条件（我们可以在收到问好之前接收到我们的告别！），我们可以看到我们的程序有两个分支同时运行。我们通过创建完成通道并将其传递给我们的调用图来设置标准抢占方法。如果我们在main的任何一点关闭完成的频道，那么两个分支都将被取消。<br>通过引入goroutine，我们已经开辟了以几种不同且有趣的方式来控制该程序的可能性。我们可能希望genGreeting在耗时过长的时候发生超时。也许我们不希望genFarewell调用locale，如果我们知道其父函数将很快被取消。在每个堆栈框架中，一个函数可以影响其下的整个调用堆栈。<br>使用done channel模式，我们可以通过将传入的done channel包装到其他done channel中，然后在其中任何一个通道启动时返回，但我们不会获得关于Context给我们的最后期限和错误的额外信息。<br>为了比较done channel模式和使用context包谁更容易，让我们用树来表示这个程序。树中的每个节点代表一个函数的调用。</p>
<p>让我们修改我们的程序，使用context包而不是done channel。因为我们现在具有context.context的灵活性，所以我们可以引入一个有趣的场景。<br>假设genGreeting只想在放弃调用locale之前等待1s，超时时间为1s。我们也想要在main函数中建立一些智能逻辑。如果printGreeting不成功，我们也想取消我们对printFarewall的调用。毕竟，如果我们不打声招呼，说再见就没有意义了！<br>使用context包实现这一点很简单：</p>
<p>D这里main用context.Background（）创建一个Context并用context. WithCancel包装它以允许取消。<br>日在这一行上，如果从打印问候语返回错误，main将取消上下文。<br>这里genGreeting用context.WithTimeout包装它的Context。这将在1秒后自动取消返回的上下文，从而取消它传递上下文的任何子函数，即语言环境。<br>这一行返回为什么Context被取消的原因。这个错误会一直冒泡到main，这会导致取消。<br>以下是运行此代码的结果：<br>cannot print greeting: context deadline exceeded cannot print fareweli: context canceled<br>Go语言的并发模式|159<br>版权所有，严禁以任何方式传播本PDF，违者自负法律责任！<br>让我们使用我们的调用图了解发生了什么。这里的数字对应于前面例子中的代码标注。</p>
<p>我们可以从我们的输出中看到该系统运行的很完美。由于我们确保local至少需要一分钟来运行，因此我们在genGreeting中的调用将始终超时，这意味着main会始终取消printFarewell下面的调用图。<br>请注意，genGreeting是如何构建自定义的Context.context以满足其需求，而不必影响父级的context。如果genGreeting成功返回，并且printGreeting需要再次调用，则可以在不泄漏有关genGreeting如何操作的信息的情况下进行。这种可组合性使你能够编写大型系统，而无需在整个调用图中混淆问题。<br>我们可以对这个程序进行另一个改进：因为我们知道1ocale需要大约一分钟的时间来运行，所以我们可以检查是否给了我们最后期限，如果是的话，我们是否会遇到它。这个例子演示了如何使用context.context的Deadline方法；</p>
<p>在这里我们检查我们的上下文是否提供了截止。如果确实如此，并且我们的系统时钟已超过截止时间，那么我们只会返回上下文包中定义的特定错误，即DeadlineExceeded。<br>虽然这个迭代程序的差异很小，但它允许locale函数快速失败。在调用下一个函数的成本很高的程序中，这可能会节省大量的时间，但至少它也允许该函数立即失败，而不必等待实际的超时发生。唯一的问题是，你必须知道你的下级调用图需要多长时间，这个实践起来可能非常困难。<br>这将我们带到了上下文包提供的另一半功能：用于存储和检索请求范围数据的Context的数据包。请记住，当一个函数创建一个goroutine和Context时，它通常会启动一个将为请求提供服务的goroutine，并且进一步向下的函数可能需要有关请求的信息。以下是如何在上下文中存储数据以及如何检索数据的示例：</p>
<p>输出如下：<br>handling response for jane (abc123)<br>很简单的东西。唯一的限制条件是：<br>。你使用的键值必须满足Go语言的可比性概念，也就是运算符==和！=在使用时需要返回正确的结果。<br>。返回值必须安全，才能从多个goroutine 访问。<br>由于Context的键和值都被定义为interface{}，所以当试图检索值时，我们会失去Go语言的类型安全性。key可以是不同的类型，或者与我们提供的key略有不同。值可能与我们预期的不同。出于这些原因，Go语言作者建议你在从Context中存储和检索值时遵循一些规则。<br>首先，他们建议你在软件包中定义一个自定义键类型。只要其他软件包执行相同的操作，则可以防止上下文中的冲突。作为一个提醒，为什么让我们看看一个简短的程序，试图将键存储在具有不同类型的映射中，但具有相同的基础值：</p>
<p>输出如下：<br>map[1:11:2]<br>你可以看到，虽然基础值是相同的，但不同的类型信息在map中区分它们。由于你为软件包key定义的类型未导出，因此其他软件包不能与你在软件包中生成的key冲突。<br>由于我们不导出用于存储数据的key，因此我们必须导出为我们检索数据的函数。这能很好地工作，因为它允许这些数据的使用者使用静态的、类型安全的函数。<br>当你把所有这些放在一起时，你会得到类似下面的这个例子：</p>
<p>运行此代码会产生：<br>handling response for jane (auth:abc123)<br>我们现在有一种类型安全的函数来从context获取值，如果消费者在不同的包中，他们不会知道或关心用于存储信息的key。但是，这种技术确实会造成问题。<br>在前面的例子中，我们假设HandleResponse确实存在于另一个名为 response的包中，我们假设ProcessRequest包位于名为pross的包中。 process包必须导入响应包才能调用HandleResponse，但HandleResponse无法访问process包中定义的访问器函数，因为导人过程会形成循环依赖关系。由于用于在Context中存储key的类型对于process包来说是私有的，所以responce包无法检索这些数据！<br>这迫使体系结构创建以从多个位置导人的数据类型为中心的包。这当然不是一件坏事，但有些事情得注意。<br>context包非常整洁，但尚未被整个Go语言社区所赞美。在Go语言社区中，context包一直存在争议。建议取消context包的提议已经相当受欢迎，而且在context中存储任意数据的能力以及存储数据的类型不安全的方式造成了一些分歧。虽然已经减少了部分访问函数缺乏类型安全性，但是仍然可以</p>
<p>通过存储不正确的类型来引人错误。然而，更大的问题肯定是开发人员应该在context的实例中存储什么的问题。<br>关于什么是适当的、最普遍的指导，下面是上下文包中的下面有点含糊的注释：<br>仅将上下文值用于传输进程和请求的请求范围数据，API边界，而不是将可选参数传递给函数。<br>很清楚什么是可选参数（你不应该使用context来满足你对Go语言支持可选参数的秘密愿望），但什么是“请求范围数据”？据说它“转换进程和API边界”，但它可以描述很多东西。我发现定义它的最好方法是与团队一起提出一些启发式方法，并在代码评审中评估它们。这是我的启发式：<br>1.数据应该通过进程或API边界。<br>如果你在进程的内存中生成数据，那么除非你通过API边界传递数据，否则可能不是一个很好的选择。<br>2.数据应该是不可变的。<br>如果不是，那么根据定义，你存储的内容不是来自请求的内容。<br>3.数据应趋向简单类型。<br>如果请求范围数据是为了传递进进程和API边界，那么如果另一方不需要导人一个复杂的包的图，那么将这些数据拉出就容易得多。<br>4.数据应该是数据，而不是类型与方法。<br>操作是逻辑的，属于消耗这些数据的东西。<br>5.数据应该有助于修饰操作，而不是驱动它们。<br>如果你的算法根据context中包含或不包含的内容而有所不同，你可能会跨越可选参数的范围。<br>这些不是硬性规定，它们是启发式的。但是，如果你发现存储在上下文中的数据违反了上述所有五条准则，你可能需要仔细观察下你正在选择去做的是什么。</p>
<p>需要考虑的另一个方面是该数据在使用之前可能需要经过多少层。如果在接收数据的地方和使用地点之间有几个框架和几十个函数，你是否想要倾向于冗长的自解释的参数名，并将数据作为参数添加？或者你更愿意将它放在context中，从而创建一个不可见的依赖关系？每种方法都有优点，最终这是你和你的团队必须做出的决定。<br>即使采用这些启发式方法，值是否是请求范围数据仍然是一个难以回答的问题。看看下面的表格。它列出了我对每种数据是否满足我列出的五种启发式的看法。你同意吗？<br>数据<br>Request ID<br>UserlD<br>URL<br>API Server Connection Authorization Token Request Token<br>v/<br>」<br>v/<br>↵<br>↵<br>v<br>y/<br>有时很明显，某些内容不应该存储在上下文中，因为它与API服务器连接有关，但有时不太清楚。什么是授权令牌？它是不可变的，它可能是一部分字节，但是这些数据的接收者不会使用它来确定是否要求字段？这些数据是否属于上下文？为了进一步浑浊水域，一个团队可以接受的是另一个团队可能不会接受的。</p>
<p>总而言之，这个问题并没有一个一概而就的答案。该软件包已被纳人标准库，因此你必须对其使用形成一些意见，但该意见可能（也可能应该）根据你所触及的项目而改变。我留给你的最后建议是context提供的取消功能非常有用，你对数据包的感受不应该阻止你使用它。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章介绍了很多内容。我们结合了Go语言的并发原语来形成模式，以帮助编写可维护的并发代码。既然你熟悉了这些模式，我们可以讨论如何将这些模式合并到其他模式中，以帮助你编写大型系统。下一章将会给你一个关于这样做的技术的概述。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言并发之道/" rel="tag"># Go语言并发之道</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/09/第3章-Go语言并发组件/" rel="next" title="第3章 Go语言并发组件">
                <i class="fa fa-chevron-left"></i> 第3章 Go语言并发组件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/09/第5章-大规模并发/" rel="prev" title="第5章 大规模并发">
                第5章 大规模并发 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">学如逆水行舟，不进则退</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">858</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/01/02/38｜成果优化：怎么实现一个TCP服务器？（下）/" title="38｜成果优化：怎么实现一个TCP服务器？（下）" target="_blank">38｜成果优化：怎么实现一个TCP服务器？（下）</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/02/37｜代码操练：怎么实现一个TCP服务器？（中）/" title="37｜代码操练：怎么实现一个TCP服务器？（中）" target="_blank">37｜代码操练：怎么实现一个TCP服务器？（中）</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/02/36｜打稳根基：怎么实现一个TCP服务器？（上）/" title="36｜打稳根基：怎么实现一个TCP服务器？（上）" target="_blank">36｜打稳根基：怎么实现一个TCP服务器？（上）</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/02/35｜即学即练：如何实现一个轻量级线程池？/" title="35｜即学即练：如何实现一个轻量级线程池？" target="_blank">35｜即学即练：如何实现一个轻量级线程池？</a>
                  </li>
                
                  <li>
                    <a href="/2023/01/02/34｜并发：如何使用共享变量？/" title="34｜并发：如何使用共享变量？" target="_blank">34｜并发：如何使用共享变量？</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理"><span class="nav-number">1.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pipeline"><span class="nav-number">2.</span> <span class="nav-text">pipeline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">3.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">7.5m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">112:57</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
