<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Go语言并发之道">
<meta property="og:type" content="article">
<meta property="og:title" content="第3章 Go语言并发组件">
<meta property="og:url" content="http://yoursite.com/2021/09/09/第3章-Go语言并发组件/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/09/09/第3章-Go语言并发组件/0.png">
<meta property="og:image" content="http://yoursite.com/2021/09/09/第3章-Go语言并发组件/t-1.png">
<meta property="og:updated_time" content="2021-11-01T07:30:48.821Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第3章 Go语言并发组件">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://yoursite.com/2021/09/09/第3章-Go语言并发组件/0.png">






  <link rel="canonical" href="http://yoursite.com/2021/09/09/第3章-Go语言并发组件/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第3章 Go语言并发组件 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/09/第3章-Go语言并发组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="放弃会成为一种习惯">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第3章 Go语言并发组件

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-09 14:47:36" itemprop="dateCreated datePublished" datetime="2021-09-09T14:47:36+08:00">2021-09-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-11-01 15:30:48" itemprop="dateModified" datetime="2021-11-01T15:30:48+08:00">2021-11-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">32k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">29 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>在本章中，我们将讨论Go语言的丰富特性，以及它如何支持并发。在本章结束时，你应该对语法、函数和包，以及它们的功能有一个很好的理解。</p>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a><span style="color:#339AFF;">goroutine</span></h1><p>goroutine是Go语言程序中最基本的组织单位之一，所以我们要了解它们是什么以及如何工作。事实上每个Go语言程序都至少有一个goroutine：main goroutine，它在进程开始时自动创建并启动。几乎在所有的项目中，你迟早会使用goroutine来解决Go语言编程遇到的问题。所以，它们是什么？</p>
<p>简单地说，goroutine是一个并发的函数（记住：不一定是并行的），与其他代码一起运行。你可以简单地在一个函数之前添加go关键字来触发：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> sayHello()</span><br><span class="line">    <span class="comment">//继续执行自己的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样可以作为匿名函数使用！这里有一个例子和前面的例子一样。然而，我们不是创建一个基于函数的goroutine，而是创建一个基于匿名函数goroutine:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>) </span><br><span class="line">&#125;() <span class="comment">// ①</span></span><br><span class="line"><span class="comment">// 继续执行自己的逻辑</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>①请注意，我们必须立即在go关键字后面调用匿名函数来使用。</li>
</ul>
<p>或者，你可以将该函数赋给一个变量，并将其命名为这样的匿名函数：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayHello := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sayHello()</span><br><span class="line"><span class="comment">// 继续执行自己的逻辑</span></span><br></pre></td></tr></table></figure></p>
<p>这个够酷！我们可以创建一个具有函数和单个关键字的并发逻辑块！信不信由你，你需要知道的就是创建goroutine。关于如何正确地使用、同步，并组织它们，有很多需要说的，但了解这些知识需要你开始使用goroutine。这一章的其余部分要深入分析goroutine是什么以及它们是如何工作的。如果你只对编写一些正确使用goroutine的代码感兴趣，你可以考虑跳到下一节。</p>
<p>那么让我们来看看这里发生了什么，goroutine是如何工作的？它们是OS线程吗？绿色线程？我们能创造多少个goroutine？</p>
<p>Go语言中的goroutine是独一无二的（尽管其他的一些语言有类似的并发原语）。它们不是OS线程，也不是绿色线程（由语言运行时管理的线程），它们是一个更高级别的抽象，称为协程。协程是一种非抢占式的简单并发子goroutine（函数、闭包或方法），也就是说，它们不能被中断。取而代之的是，协程有多个点，允许暂停或重新进入。</p>
<p>goroutine的独特之处在于它们与Go语言的运行时的深度集成。goroutine没有定义自己的暂停方法或再运行点。Go语言的运行时会观察goroutine的运行时行为，并在它们阻塞时自动挂起它们，然后在它们不被阻塞时恢复它们。在某种程度上，这使它们成为可抢占的，但只是在goroutine被阻塞的情况。在运行时和goroutine的逻辑之间，是一种优雅的伙伴关系。因此，goroutine可以被认为是一种特殊类型的协程。</p>
<p>协程和goroutine都是隐式并发结构，但并发并不是协程的属性：必须同时托管多个协程，并给每个协程一个执行的机会。否则，它们就不会并发！请注意，这并不意味着协程是隐式并行的。当然有可能有几个协程按顺序并行执行的假象，事实上，这种情况一直在发生。</p>
<p>Go语言的主机托管机制是一个名为<code>M:N</code>调度器的实现，这意味着它将M个绿色线程映射到N个OS线程。然后将goroutine安排在绿色线程上。当我们的goroutine数量超过可用的绿色线程时，调度程序将处理分布在可用线程上的goroutine，并确保当这些goroutine被阻塞时，其他的goroutine可以运行。我们将在第6章讨论这些细节，但是在这里我们将介绍Go语言的并发模型。</p>
<p>Go语言遵循一个称为<code>fork-join</code>的并发模型（熟悉C的人可能正在将这个模型和fork函数进行比较。<code>fork-join</code>模型是控制执行并发性的逻辑模型。在逻辑级别上，它确实描述了一个调用fork的C程序，然后<code>wait.fork-join</code>模型没有提到内存是如何管理的）。fork这个词指的是在程序中的任意一点，它可以将执行的子分支与其父节点同时运行。join这个词指的是，在将来某个时候，这些并发的执行分支将会合并在一起。这里有一个示意图，帮助你描绘它：</p>
<img src="/2021/09/09/第3章-Go语言并发组件/0.png">
<p>Go语言是如何执行fork的，执行的子线程是goroutine。让我们回到简单的goroutine例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayHello := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> sayHello()</span><br><span class="line"><span class="comment">// 继续执行自己的逻辑</span></span><br></pre></td></tr></table></figure></p>
<p>在这里，sayHello函数将在goroutine上运行，而程序的其余部分将继续执行。在本例中，没有join点。执行sayHello的goroutine将在未来的某个不确定的时间退出，而程序的其余部分将会继续执行。</p>
<p>但是，这个例子有一个问题：正如上面所写的程序，它不确定sayHello函数是否会运行。goroutine将会被创建，并计划在Go语言运行时执行，但是它实际上可能没有机会在main goroutine退出之前运行。</p>
<p>实际上，因为我们省略了main函数的其余部分，为了简单起见，当运行这个小示例时，几乎可以肯定的是，程序将在goroutine被系统调用之前完成执行。因此，你不会看到“hello”这个词被打印到stdout。你可以在创建goroutine之后执行time.Sleep，但是要记住，这实际上并没有创建一个join点，只有一个竞争条件。如果回顾第1章，你增加了goroutine在程序退出前执行的概率，但你并不能保证一定会执行。join点是保证程序正确性和消除竞争条件的关键。</p>
<p>为了创建一个join点，你必须同步main goroutine和sayHello goroutine。这可以通过多种方式实现，但我将使用一个将在本章后面的“sync包”中讨论的内容：sync.Waitgroup。现在，理解这个示例如何创建连接点并不重要，它只是在两个goroutine之间创建了一个连接点。下面是一个正确的例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup </span><br><span class="line">sayHello := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>) </span><br><span class="line">&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> sayHello()</span><br><span class="line">wg.Wait() <span class="comment">// ①</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>①这就是连接点的使用方式。</li>
</ul>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>这个例子将决定main goroutine，直到goroutine托管sayHello函数为止。你将在本章后面的“sync包”中了解sync.Waitroup的工作原理，但是为了使我们的示例正常运行，我将开始使用它创建join点。</p>
<p>我们在示例中使用了许多匿名函数来创建快速goroutine样例。让我们把注意力转移到闭包上。闭包可以从创建它们的作用域中获取变量。如果你在goroutine中运行一个闭包，那么闭包是在这些变量的副本上运行，还是原值的引用上运行？让我们试试看：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">salutation := <span class="string">"hello"</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">gofunc()&#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    salutation = <span class="string">"welcome"</span> <span class="comment">// ①</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(salutation)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>①在这里，我们看到goroutine修改了变量的salutation值。</li>
</ul>
<p>你认为变量的salutation值是什么？“hello”还是“welcome”？让我们运行它并把它找出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcome</span><br></pre></td></tr></table></figure></p>
<p>有意思！事实证明，goroutine在它们所创建的相同地址空间内执行，因此我们的程序打印出“welcome”这个词。让我们再看一个例子。你认为这个程序会输出什么？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitCroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>&#125;&#123; </span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(salutation) <span class="comment">// ①</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>①在这里，我们引用了字符串类型的切片作为创建循环变量的salutation值。</li>
</ul>
<p>答案比大多数人想象的要复杂得多，而且是为数不多的令人惊讶的事情之一。大多数人直觉上认为这将会不确定顺序地打印出“hello”“greetings”和“goodday”，但看看它做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">good day</span><br><span class="line">good day</span><br><span class="line">good day</span><br></pre></td></tr></table></figure></p>
<p>令人意想不到！我们来看看这里发生了什么。在这个示例中，goroutine 正在运行一个闭包，该闭包使用变量salutation时，字符串的迭代已经结束。当我们循环迭代时，salutation被分配到slice literal中的下一个字符串值。因为计划中的goroutine可能在未来的任何时间点运行，它不确定在goroutine中会打印出什么值。在我的机器上，在goroutine开始之前循环有很高的概率会退出。这意味着变量的salutation值不在范围之内。然后会发生什么呢？goroutine还能引用一些已经超出范围的东西吗？goroutine不会访问那些可能被垃圾回收的内存吗？</p>
<p>这是一个关于如何管理内存的有趣的点。Go语言运行时会足够小心地将对变量salutation值的引用仍然保留，由内存转移到堆，以便goroutine可以继续访问它。</p>
<p>通常在我的计算机上，在任何goroutine开始运行之前，循环就会退出，所以salutation会被转移到堆中，在我的字符串切片中引用最后一个值“good day”。所以我通常会看到三次“goodday”。编写这个循环的正确方法是将salutation的副本传递到闭包中，这样当goroutine运行时，它将从循环的迭代中操作数据：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>&#125; &#123; </span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(salutation <span class="keyword">string</span>)</span></span> &#123; <span class="comment">// ①</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(salutation)</span><br><span class="line">    &#125;(salutation) <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>①声明一个参数，就像其他函数一样。把原来变量的salutation显式的映射到闭包中。</li>
<li>②我们将当前迭代的变量传递给闭包。创建了一个字符串结构的副本，从而确保当goroutine运行时，我们可以引用适当的字符串。</li>
</ul>
<p>如你所见，我们得到了正确的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">good day</span><br><span class="line">hello</span><br><span class="line">greetings</span><br></pre></td></tr></table></figure></p>
<p>这个示例的行为与我们期望的一样，只是稍微有点烦琐。</p>
<p>因为这些goroutine在相同的地址空间中运行，并且只有简单的宿主函数，所有使用goroutine编写非并发代码是非常自然的。Go语言的编译器很好地处理了内存中的变量，这样goroutine就不会意外地访问被释放的内存，这使得开发人员可以专注于他们的问题空间而不是内存管理。然而，这不是一张空白支票。</p>
<p>由于多个goroutine可以在同一个地址空间上运行，所以我们仍然需要担心同步问题。正如我们已经讨论过的，我们可以选择同步访问goroutine 访问的共享内存，或者可以使用CSP原语通过通信来共享内存。我们稍后将在本章后面的“Channel”和“sync包”中讨论这些技术。</p>
<p>goroutine的另一个好处是它们非常轻。下面是“Go语言FAQ”的摘录：</p>
<blockquote>
<p>一个新创建的goroutine被赋予了几千字节，这在大部分情况都是足够的。当它不运行时，Go语言运行时就会自动增长（缩小）存储堆栈的内存，允许许多goroutine存在适当的内存中。每个函数调用CPU的开销平均为3个廉价指令。在同一个地址空间中创建成千上万的goroutine是可行的。如果goroutine只是线程，系统的资源消耗会更小。</p>
</blockquote>
<p>每个goroutine几千字节，这并没有什么问题！让我们来验证一下。但是在我们开始之前，我们必须讨论一个关于goroutine有趣的事情：GC并没有回收被丢弃的goroutine。如果我写如下代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//将永远阻塞的操作</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 开始工作</span></span><br></pre></td></tr></table></figure></p>
<p>这里的goroutine将一直存在直到进程退出。我们将在第4章的“防止goroutine泄漏”中讨论如何解决这一问题。在下一个例子中，我们将利用这一点来实际测算goroutine的大小。</p>
<p>在下面的例子中，我们将goroutine不被GC的事实与运行时的自省能力结合起来，并测算在goroutine创建之前和之后分配的内存数量：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">memConsumed := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    runtime.GC()</span><br><span class="line">    <span class="keyword">var</span> s runtime.MemStats</span><br><span class="line">    runtime.ReadMemStats(&amp;s)</span><br><span class="line">    <span class="keyword">return</span> s.Sys</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">noop := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; wg.Done(); &lt;-c &#125; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numGoroutines = <span class="number">1e4</span> <span class="comment">// ②</span></span><br><span class="line">wg.Add(numGoroutines)</span><br><span class="line">before := memConsumed() <span class="comment">// ③</span></span><br><span class="line"><span class="keyword">for</span> i := numGoroutines; i&gt;<span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="keyword">go</span> noop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">after := memConsumed() <span class="comment">// ④</span></span><br><span class="line">fmt.Printf(<span class="string">"%.3fkb"</span>, <span class="keyword">float64</span>(after-before)/numGoroutines/<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>①我们需要一个永远不会退出的goroutine，这样就可以在内存中保留一段时间用于测算。不要担心我们是如何实现这个目标的，只要了解这个goroutine不会退出，直到进程结束。</li>
<li>②定义了要创建的goroutine的数量。我们将用大数定律，渐渐地接近一个goroutine的大小。</li>
<li>③测算在创建goroutine之前消耗的内存总量。</li>
<li>④测算在创建goroutine之后消耗的内存总量。</li>
</ul>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.817KB</span><br></pre></td></tr></table></figure></p>
<p>看起来文档是正确的！这些都是空的goroutine，什么都不做，但它仍然让我们知道可能创造的goroutine的数量。表3-1给出了一些粗略的估计，在不使用交换空间的情况下你可以使用64位CPU创建多少goroutine.</p>
<blockquote>
<p>表3-1：在给定的内存中，对可能出现的goroutine的数量进行分析内存（GB）</p>
</blockquote>
<img src="/2021/09/09/第3章-Go语言并发组件/t-1.png">
<p>这些数字相当大！在我的笔记本计算机上有8GB的内存，这意味着理论上可以在不使用交换空间的情况下启动数百万的goroutine。当然，忽略了在我的计算机上运行的其他东西，以及goroutine的实际内容，但是这个快速的计算表明了goroutine是多么的轻量级！</p>
<p>可能会影响性能的是上下文切换，即当一个被托管的并发进程必须保存它的状态以切换到一个不同的运行并发进程时。如果我们有太多的并发进程，可能会将所有的CPU时间消耗在它们之间的上下文切换上，而没有资源完成任何真正需要CPU的工作。在操作系统级别，使用线程可能非常昂贵。OS线程必须保存如寄存器值、查找表和内存映射之类的东西，以便能够在有限的时间内成功地切换回当前线程。然后，它必须为传入的线程加载相同的信息。</p>
<p>软件中的上下文切换相对来说要廉价得多。在一个软件定义的调度器下，运行时可以更有选择性地保存数据用于检索，如何持久化，以及何时需要持久化。让我们来看看在OS线程和goroutine之间切换的上下文的相对性能。首先，我们将利用Linux的内置基准测试套件来度量在相同核心的两个线程之间发送消息需要多长时间：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">taskset -c o perf bench <span class="built_in">sched</span> pipe -T </span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Running &apos;sched/pipe&apos; benchmark:</span><br><span class="line"># Executed 1o00000 pipe operations between two threads Total time:2.935[sec]</span><br><span class="line">2.935784 usecs/op</span><br><span class="line">340624 0ps/sec</span><br></pre></td></tr></table></figure></p>
<p>这个基准实际上度量了在线程上发送和接收消息所需的时间，因此我们将计算结果并将其除以2。我们用了1.467us来进行上下文切换。这看起来不算太糟，但还是保留判断，直到我们检查goroutine之间的上下文切换。</p>
<p>我们将使用Go语言构建一个类似的基准。我已经用到了一些我们还没有讨论过的东西，所以如果有什么让人困惑的东西，标注一下，把注意力集中在结果上。下面的示例将创建两个goroutine并在它们之间发送一条消息：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkContextSwitch</span><span class="params">(b *testing.B)</span></span>&#123; <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">begin :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">c:umake(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> token <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">sender := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&lt;-begin <span class="number">0</span></span><br><span class="line">fori:=o;icb.N;i++&#123;</span><br></pre></td></tr></table></figure></p>
<p>0我们在这里等待，直到被告知开始执行。我们对上下文切换度量的时候，不需要考虑设置和启动每个goroutine的成本。<br>我们将消息发送到接收器goroutine。一个struct{}{}被称为一个空结构，它没有内存占用，因此，我们只是在发出信号的时候记录时间。<br>目收到一条信息，但什么也不做。<br>0开始计时。<br>6告诉两个goroutine开始运行。<br>运行基准测试，假设我们只希望使用一个CPU，以便它对Linux基准测试是一个类似的测试。让我们来看看结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench=.-cpu=1\</span><br><span class="line">src/gos-concurrency-building-blocks/goroutines/<span class="built_in">fg</span>-ctx-sitch_test.go BenchmarkContextSwitch 5000000</span><br><span class="line">225</span><br><span class="line">ns/op</span><br><span class="line">PASS</span><br><span class="line">ok</span><br><span class="line">conmand-line-argunents</span><br><span class="line">1.3935</span><br></pre></td></tr></table></figure></p>
<p>每个上下文切换需要225ns，哇！如果你还记得1.467us，0.225us或92%的速度提升比我的计算机一个操作系统上下文切换还要快。很难断言有多少goroutine会导致上下文切换过于频繁，但是可以很轻松地说，上限很可能不会成为使用goroutine的任何障碍。</p>
<p>读了这一节之后，你现在应该了解了如何开始使用goroutine，并了解了它们是如何工作的。你也应该有信心，只要有需求场景，你就可以安全地创建一个goroutine。正如我们在第2章的“并发与并行的差异”中所讨论的那样，你创建的goroutine越多，如果你的问题空间中每个并发代码段都不受任一Amdahl定律的约束，那么你的程序就会使用多个处理器进行扩展。创建goroutine非常廉价，只有当你已经证明了它们是性能问题的根本原因后，你才应该讨论它们的成本。</p>
<h1 id="sync包"><a href="#sync包" class="headerlink" title="sync包"></a>sync包</h1><p>sync包包含对低级别内存访问同步最有用的并发原语。如果你使用的语言主要通过内存访问同步来处理并发，那么你可能已经熟悉了这些类型。Go语言和这些语言之间的区别在于，Go语言已经在内存访问同步原语之上构建了一组新的并发原语，以向你提供一组扩展的工作。正如我们在第2章“Go语言的并发哲学”中所讨论的，这些操作都有它们的用途，主要是在诸如struct这样的小范围内。由你决定何时进行内存访问同步。说到这里，让我们开始看一下sync包公开的各种原语。</p>
<h1 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h1><p>当你不关心并发操作的结果，或者你有其他方法来收集它们的结果时，WaitGroup是等待一组并发操作完成的好方法。如果这两个条件都不满足，我建议你使用channel和select语句。WaitGroup非常有用，我首先介绍它，以便在后续部分使用它。下面是一个使用WaitGroup等待goroutine完成的基本例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync. WaitGroup wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()<span class="number">6</span></span><br><span class="line">fmt.Println(<span class="string">"1st goroutine sleeping..."</span>) time.Sleep(<span class="number">1</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt. Println(<span class="string">"2nd goroutine sleeping..."</span>) time sleep(<span class="number">2</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()<span class="number">0</span></span><br><span class="line">fmt.Println(<span class="string">"All goroutines complete."</span>)</span><br></pre></td></tr></table></figure></p>
<p>D调用Add，参数为1，表示一个goroutine开始了。<br>使用defer关键字来确保在goroutine退出之前执行Done操作，我们向WaitGroup表明我们已经退出了。<br>执行Wait操作，这将阻塞main goroutine，直到所有goroutine表明它们已经退出。<br>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2nd goroutine sleeping... 1st goroutine sleeping.. All goroutines complete.</span><br></pre></td></tr></table></figure></p>
<p>你可以将WaitGroup视为一个并发-安全的计数器：调用通过传人的整数执行add方法增加计数器的增量，并调用Done方法对计数器进行递减。Wait阻塞，直到计数器为零。</p>
<p>注意，添加的调用是在他们帮助跟踪的goroutine之外完成的。如果我们不这样做，我们就会引人一种竞争条件，因为在本章前面“goroutines”中，我们不能保证goroutine何时会被调度，可以在goroutine开始调度前调用Wait方法。如果将调用Add的方法添加到goroutine的闭包中，那么Wait调用可能会直接返回，而且不会阻塞，因为Add调用不会发生。</p>
<p>通常情况下，都要尽可能地向它们正在帮助追踪的goroutine中添加尽可能多的信息，但有时你会发现只调用一次Add来追踪一组goroutine。我通常在这样的循环之前执行这种操作：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello:=<span class="function"><span class="keyword">func</span><span class="params">(wg*sync.WaitGroup,idint)</span></span>&#123; <span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Printf(<span class="string">"Hello from %v!\n"</span>,id)</span><br><span class="line"><span class="keyword">const</span> numGreeters - <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(numCreeters)</span><br><span class="line"><span class="keyword">for</span> i :-o;i&lt; numGreeters; i++&#123; <span class="keyword">go</span> hello(<span class="number">8</span>wg，<span class="number">1</span>+<span class="number">1</span>)</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello from 5! Hello from 4I Hello from 3! Hello from 2! Hello from 1!</span><br></pre></td></tr></table></figure></p>
<h1 id="互斥锁和读写锁"><a href="#互斥锁和读写锁" class="headerlink" title="互斥锁和读写锁"></a>互斥锁和读写锁</h1><p>如果你已经熟悉通过内存访问同步处理并发的语言，那么你可能会立即识别 Mutex互斥锁。如果你不把自己算在内，别担心，Mutex很容易理解。Mutex是“互斥”的意思，是保护程序中临界区的一种方式。如果你还记得第1章，临界区是你程序中需要独占访问共享资源的区域。Mutex提供了一种安全的方式来表示对这些共享资源的独占访问。为了使用一个资源，channel通过通信共享内存，而Mutex通过开发人员的约定同步访问共享内存。你可以通过使用Mutex对内存进行保护来协调对内存的访问。这里有一个简单的例子，两个goroutine试图增加和减少一个共同的值，它们使用Mutex互斥锁来同步访问：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br></pre></td></tr></table></figure></p>
<p>我们请求对临界区的独占（这个例子里的计数器）使用互斥锁来解决。我们指出已经完成了对临界区锁定的保护。<br>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>你会注意到，我们总是在defer语句中调用Unlock。这是一个十分常见的习惯用法，它使用Mutex互斥锁来确保即使出现了panic，调用也总是发生。如果不这样做，可能会导致程序陷入死锁。</p>
<p>关键部分之所以如此命名，是因为它们反映了程序中的瓶颈。进入和退出一个临界区是有消耗的，所以一般人会尽量减少在临界区的时间。<br>这样做的一个策略是减少临界区的范围。可能存在需要在多个并发进程之间共享内存的情况，但可能这些进程不是都需要读写此内存。如果是这样，你可以利用不同类型的互斥对象：sync.RWMutex。</p>
<p>sync.RWMutex在概念上和互斥是一样的它守卫着对内存的访问，然而，RWMutex让你对内存有了更多控制。你可以请求一个锁用于读处理，在这种情况下你将被授予访问权限，除非该锁被用于写处理。这意味着，任意数量的读消费者可以持有一个读锁，只要没有其他事物持有一个写锁。这里有一个例子，它演示了一个生产者，它不像代码中创建的众多消费者那样活跃：</p>
<p>producer函数的第二个参数是sync.Locker类型。这个接口有两个方法Lock和Unlock，分别对应Mutex和RWMutex类型。<br>我们让producer等待1s，使它比观察者的goroutines更不活跃。<br>输出如下：</p>
<p>可以看到，在这个特殊的例子中减少了我们的临界区的横截面，实际上只给开始的2”个读消费者的返回信息。这将取决于你的临界区在做什么，但是通常建议使用RWMutex，而不是Mutex，因为它在逻辑上更加合理。<br>cond<br>对于cond类型的注释确实很好地描述了它的用途：<br>个goroutine的集合点，等待或发布一个event。<br>在这个定义中，一个“event”是两个或两个以上的goroutine之间的任意信号，除了它已经发生的事实外，没有任何信息。通常情况下，在goroutine继续执行之前，你需要等待其中一个信号。如果我们要研究如何在没有Cond类型的情况下实现这一目标，一个简单的方法就是使用无限循环：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> conditionTrue() <span class="literal">false</span> &#123;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>然而，这将消耗一个CPU核心的所有周期。为了解决这个问题，我们可以引入一个time.Sleep.<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> conditionTrue()==<span class="literal">false</span> &#123; time.Sleep(<span class="number">1</span>*time.Millisecond) &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样更好，但它仍然是低效的，而且你必须弄清楚要等待多久：太长，会人为地降低性能，太短，会不必要地消耗太多的CPU时间。如果有一种方法可以让goroutine有效地等待，直到它发出信号并检查它的状态，那就更好了。这正是Cond类型为我们所做的。使用Cond，我们可以这样编写前面例子的代码：</p>
<p>我们实例化一个新的cond。NewCond函数创建一个类型，满足sync.locker接口。这使得cond类型能够以一种并发安全的方式与其他goroutine 协调。</p>
<p>我们锁定了这个条件。这是必要的，因为在进人Locker的时候，执行Wait会自动执行Unlock.</p>
<p>目等待通知，条件已经发生。这是一个阻塞通信，goroutine将被暂停。</p>
<p>0我们为这个条件Locker执行解锁操作。这是必要的，因为当执行Wait退出操作的时候，它会在Locker上调用Lock方法。</p>
<p>这种方法效率更高。注意，调用Wait不只是阻塞，它挂起了当前的goroutine，允许其他goroutine在OS线程上运行。当你调用Wait时，会发生一些其他事情：进人Wait后，在Cond变量的Locker上调用Unlock方法，在退出Wait时，在Cond变量的Locker上执行Lock方法。在我看来，这需要慢慢习惯，它实际上是方法的一个隐藏的副作用。看起来我们在等待条件发生的时候一直持有这个锁，但事实并非如此。当你浏览代码时，你需要留意这个模式。</p>
<p>让我们扩展这个例子，并显示等式的两边：等待信号的goroutine和发送信号的goroutine。假设我们有一个固定长度为2的队列，还有10个我们想要推送到队列中的项目。我们想要在有房间的情况下尽快排队，所以就希望在队列中有空间时能立即得到通知。让我们尝试使用Cond来管理这种调度：</p>
<p>首先，我们使用标准的sync.Mutex作为锁。</p>
<p>接下来，我们创建一个长度为0的切片。因为我们最终会添加10个项目，所以用10的容量实例化它。</p>
<p>我们通过在条件的锁存器上调用锁来进入临界区。</p>
<p>检查一个循环中队列的长度。这很重要，因为在这种情况下的信号并不一定意味着是你所等待的信号，也可能只是发生了什么。</p>
<p>调用Wait，这将暂停main goroutine直到一个信号的条件已经发送。创建了一个新的goroutine，它将在一秒钟后删除一个元素。</p>
<p>退出条件的临界区，因为我们已经成功地进入了一个项目。</p>
<p>再次进入临界区，以便我们可以修改与条件相关的数据。</p>
<p>通过将切片的头部重新分配到第二个项目来模拟对一个项目的排队。退出条件的临界区，因为我们已经成功地删除了一个项目。</p>
<p>D我们让一个正在等待的goroutine知道发生了什么事情。</p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>如你所见，该程序成功地将所有10个项目添加到队列中（并且在它有机会将前两项删除之前退出）。它也总是等待，直到至少有一个项目被排人队列，然后再进行另一个项目。</p>
<p>在这个例子中，我们还有一个新方法，Signal。这是Cond类型提供的两种方法中的一种，它提供通知goroutine阻塞的调用Wait，条件已经被触发。另一种方法叫做Broadcast。运行时内部维护一个FIFO列表，等待接收信号；Signal发现等待最长时间的goroutine并通知它，而Broadcast向所有等待的goroutine发送信号。Broadcast可以说是这两种方法中比较有趣的一种，因为它提供了一种同时与多个goroutine通信的方法。我们可以通过channel（在本章后面“Channels”中介绍）对信号进行简单的复制，但是重复调用Broadcast的行为将会更加困难。此外，与利用channel相比，Cond类型的性能要高很多。</p>
<p>为了了解使用Broadcast的方法，让我们假设正在创建一个带有按钮的GUI应用程序。我们想注册任意数量的函数，当该按钮被单击时，它将运行。Cond可以完美胜任，因为我们可以使用它的Broadcast方法通知所有注册的处理程序。让我们看看它的例子：</p>
<p>0定义了一个Button类型，它包含一个条件，Clicked。<br>日定义了一个便利构造函数，它允许我们注册函数处理来自条件的信号。</p>
<p>每个处理程序都在自己的goroutine上运行，并且订阅不会退出，直到goroutine被确认运行为止。</p>
<p>我们为鼠标按键事件设置了一个处理程序。它反过来调用cond上的Broadcast，让所有的处理程序都知道鼠标按键已经被单击了（更健壮的实现将首先检查它是否已经被抑制）。</p>
<p>创建一个WaitGroup。这只是为了确保我们的程序在写人stdout之前不会退出。</p>
<p>目注册一个处理程序，当单击按键时，它将模拟最大化按钮的窗口。<br>注册一个处理程序，该处理程序在单击鼠标时模拟显示对话框。<br>日接下来，我们模拟一个用户通过单击应用程序的按钮来单击鼠标按键。</p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>你可以看到，在Clicked Cond上调用Broadcast，所有三个处理程序都将运行。如果不是clickRegistered的WaitGroup，我们可以调用button.Clicked.Broadcast（）多次，并且每次都调用三个处理程序。这是channel不太容易做到的，因此是利用Cond类型的主要原因之一。</p>
<p>与sync包中所包含的大多数其他东西一样，Cond的使用最好被限制在一个紧凑的范围中，或者是通过封装它的类型来暴露在更大范围内。<br>once<br>你认为这段代码会输出什么？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">increment :- <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">count++</span><br><span class="line"><span class="keyword">var</span> once sync<span class="number">.0</span>nce</span><br><span class="line"><span class="keyword">var</span> increnents sync.WaitGroup increments.Add(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i:<span class="number">-0</span>;i&lt;<span class="number">100</span>;<span class="number">1</span>++&#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> increments.Done() once.Do(increment)</span><br><span class="line">&#125;() &#125;</span><br><span class="line">increments.Wait()</span><br><span class="line">fat.Printf(<span class="string">"Count is xd\n"</span>, count)</span><br></pre></td></tr></table></figure></p>
<p>很容易认为结果将是Count is100，但我肯定你已经注意到了sync.0nce变量，在某种程度上通过Do方法把调用增加了一次。事实上，这段代码将打印以下内容：</p>
<p>顾名思义，sync.0nce是一种类型，它在内部使用一些sync原语，以确保即使在不同的goroutine上，也只会调用一次Do方法处理传递进来的函数。这确实是因为我们将调用sync.0nce方式执行Do方法。<br>把这种函数只能调用一次的功能放人标准包中似乎是件很奇怪的事情，但事实证明，这种需求经常出现。为了好玩，让我们检查Go语言的标准库，看看它自己使用这个原语的频率。下面是一个grep命令，它将执行搜索：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -ir sync.0nce s(go env COROOT)/src|wc-1</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure></p>
<p>使用sync.0nce有几件事需要注意。让我们看另一个例子，你认为它会打印什么？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">sec tng gect.t <span class="keyword">var</span> once sync<span class="number">.0</span>nce</span><br><span class="line">once.Do(increment)</span><br><span class="line">once.Do(decrement)</span><br><span class="line">fmt.Printf(<span class="string">"Count:%d\n"</span>, count)</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count:1</span><br></pre></td></tr></table></figure></p>
<p>令人惊讶的是，输出显示的是1，而不是0？这是因为sync.0nce只计算调用Do方法的次数，而不是多少次唯一调用Do方法。这样，sync.0nce的副本与所要调用的函数紧密耦合，我们再次看到如何在一个严格的范围内合理使用sync包中的类型以发挥最佳效果。我建议你通过将sync.0nce包装在一个小的语法块中来形式化这种耦合：要么是一个小函数，要么是将两者包装在一个结构体中。这个例子你认为会发生什么？<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> onceA, onceB sync.Once </span><br><span class="line"><span class="keyword">var</span> initB <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>0这个调用在日返回之前不能进行。<br>这个程序将会死锁，因为在0调用的Do直到日调用Do并退出后才会继续，这是死锁的典型例子。对一些人来说，这可能有点违反直觉，因为它看起来好像我们使用的sync.0nce是为了防止多重初始化，但sync.0nce唯一能保证的是你的函数只被调用一次。有时，这是通过死锁程序和暴露逻辑中的缺陷来完成的，在这个例子中是一个循环引用。</p>
<h1 id="池"><a href="#池" class="headerlink" title="池"></a>池</h1><p>池（Pool）是Pool模式的并发安全实现。关于Pool模式的完整解释最好参考设计模式注2的文献。不过，由于Pool在sync软件包中，我们将简要讨论为什么你可能有兴趣使用它。</p>
<p>在较高的层次上，Pool模式是一种创建和提供可供使用的固定数量实例或Pool实例的方法。它通常用于约束创建昂贵的场景（如数据库连接），以便只创建固定数量的实例，但不确定数量的操作仍然可以请求访问这些场景。对于Go语言的sync.Pool，这种数据类型可以被多个goroutine安全地使用。</p>
<p>Pool的主接口是它的Get方法。当调用时，Get将首先检查池中是否有可用的实例返回给调用者，如果没有，调用它的new方法来创建一个新实例。当完成时，调用者调用Put方法把工作的实例归还到池中，以供其他进程使用。这里有一个简单的例子来说明：</p>
<p>0在这里调用Pool的get方法。这些调用将执行Pool中定义的new函数，因为实例还没有实例化。</p>
<p>我们将先前检索到的实例放在池中，这就增加了实例的可用数量。</p>
<p>在执行此调用时，我们将重用以前分配的实例并将其放回池中。New将不会被调用。</p>
<p>我们只看到两个对New函数的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating new instance. Creating new instance.</span><br></pre></td></tr></table></figure></p>
<p>那么，为什么要使用Pool，而不只是在运行时实例化对象呢？Go语言是有GC的，因此实例化的对象将被自动清理。有什么意义？考虑下面这个例子：</p>
<p>注意，我们正在存储bytes切片的地址。<br>日我们断言类型是一个指向bytes切片的指针。<br>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 calculators were created.</span><br></pre></td></tr></table></figure></p>
<p>如果我没有用sync.Pool运行这个例子，尽管结果是不确定的，在最坏的情况下，我可能尝试分配一个十亿字节的内存，但是正如你从输出看到的，我只分配了4KB。</p>
<p>另一种常见的情况是，用Pool来尽可能快地将预先分配的对象缓存加载启动。在这种情况下，我们不是试图通过限制创建的对象的数量来节省主机的内存，而是通过提前加载获取引用到另一个对象所需的时间，来节省消费者的时间。这在编写高吞吐量网络服务器时十分常见，服务器试图快速响应请求。让我们来看看这样的场景。</p>
<p>首先，让我们创建一个模拟创建到服务的连接的函数。我们会让这次连接花很长时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func connectToService() interface&#123;&#125;&#123; time.Sleep(1*tine.Second)</span><br><span class="line">return struct&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，让我们了解一下，如果服务为每个请求都启动一个新的连接，那么网络服务的性能如何。我们将编写一个网络处理程序，为每个请求都打开一个新的连接。为了使基准测试简单，我们只允许一次连接：</p>
<p>我们获得如下结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkNetworkRequest-8 PASS</span><br><span class="line">ok</span><br><span class="line">5000</span><br><span class="line">2904307ns/op</span><br><span class="line">comnand-line-arguments 32.647s</span><br></pre></td></tr></table></figure></p>
<p>2.9E6ns/op，可以快三个数量级！你可以看到在处理代价昂贵的事务时使用这种模式可以极大地提高响应时间。</p>
<p>正如我们所看到的，你的并发进程需要请求一个对象，但是在实例化之后很快地处理它们时，或者在这些对象的构造可能会对内存产生负面影响，这时最好使用Pool设计模式。</p>
<p>然而，有些情况下要谨慎决定你是否应该使用Pool：如果你使用Pool代码所需要的东西不是大概同质的，那么从Pool中转化检索到所需要的内容的时间可能比重新实例化内容要花费的时间更多。例如，如果你的程序需要随机和可变长度的切片，那么Pool将不会对你有多大帮助。你直接从Pool中获得一个正确的切片的概率是很低的。</p>
<p>所以当你使用Pool工作时，记住以下几点：<br>，当实例化sync.Pool，使用new方法创建一个成员变量，在调用时是线程安全的。<br>当你收到一个来自Get的实例时，不要对所接收的对象的状态做出任何假设。<br>当你用完了一个从Pool中取出来的对象时，一定要调用Put，否则，Pool就无法复用这个实例了。通常情况下，这是用defer完成的。<br>Pool内的分布必须大致均匀。</p>
<h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><p>channel是由Hoare的CSP派生的同步原语之一。虽然它们可以用来同步内存访问，但它们最好用于在goroutine之间传递信息。正如我们在第2章“Go语言的并发哲学”中所讨论的，在任何大小的程序中，channel都非常有用，因为它们可以组合在一起。在我介绍channel这一节之后，我们将在本章后面”select语句”中探索该组合。</p>
<p>就像河流一样，一个channel充当着信息传送的管道，值可以沿着channel传递，然后在下游读出。出于这个原因，我通常用“Stream”来做chan变量名的后缀。当你使用channel时，你会将一个值传递给一个chan变量，然后你程序中的某个地方将它从channel中读出。程序中不同的部分不需要相互了解，只需要在channel所在的内存中引用相同的位置即可。这可以通过对程序上下游的channel引用来完成。<br>创建一个channel非常简单。这里有一个例子，它将一个channel的创建扩展到它的声明和后续的实例化中，这样你就可以看到它们到底是怎样的。与Go语言中的其他值一样，你可以使用：=操作符在一个语句中创建channel，但因为你需要经常声明channel，因此将这两步操作拆分为单个语句是很有用的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStrean <span class="keyword">chan</span> <span class="keyword">interface</span>(&#125;o</span><br><span class="line">dataStrean - nake(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)e</span><br></pre></td></tr></table></figure></p>
<p>）声明一个channel。因为我们声明的类型是空接口，所以说它的类型是interface{}。<br>使用内置的make函数实例化channel。<br>这个例子定义了一个channel （dataStream），任何值都可以写人或读取（因为我们使用了空接口）。channel也可以声明为只支持单向的数据流，也就是说，可以定义一个channel只支持发送或接收信息。我将在后面解释为什么这一点很重要。<br>要声明一个单向channel，只需包含《-操作符。要声明和实例化一个只能读取的channel，将《-操作符放在左侧，就像这样：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; dataStream :- nake(&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>要声明并创建一个只能发送的channel，将《-操作符放在右侧，就像这样：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStream <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;]&#125;</span><br><span class="line">dataStream :- <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>你通常不会看到单向channel实例化，但是会经常看到它们用作函数参数和返回类型，和我们看到的一样，这是非常有用的。因为当需要时，Go语言会隐式地将双向channel转换为单向channel。这里有一个例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiveChan &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; <span class="keyword">var</span> sendChan chanc- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">dataStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//有效的语法：</span></span><br><span class="line">receiveChan - datastrean</span><br><span class="line">sendChan - dataStream</span><br></pre></td></tr></table></figure></p>
<p>请记住channel已经被赋予了类型。在这个例子中，我们创建了一个interface{}类型chan变量，这意味着我们可以将任何类型的数据传递给它，但是我们也可以给它一个更严格的类型来约束它可以传递的数据类型。这是一个整数channel的例子，我会用之前已经介绍过的更规范的方式来实例化channel：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intstream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<p>为了使用channel，我们将再次使用《-操作符。通过将《-操作符放到channel的右边实现发送操作，通过将《-操作符放到channel的左边实现接收操作。另一种思考方式是数据流向箭头所指方向的变量。让我们看一个简单的例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stringStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;() stringstrean &lt;- <span class="string">"Hello channels!"</span> o</span><br><span class="line">fmt Println(&lt;-stringStream)<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>0我们将字符串文本传递到stringStream channel.<br>我们读取channel的字符串字面量并将其打印到stdout。</p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello channels!</span><br></pre></td></tr></table></figure></p>
<p>很简单，对吧？你所需要的只是一个channel变量，你可以将数据传递给它并读取它的数据，但是，尝试将一个值写入只读的channel是错误的，并且从只可以写的channel读取值也是错误的。如果我们尝试编译下面的例子，Go语言的编译器会告诉我们操作是非法的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writeStream := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;) readStream :- <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) &lt;-writeStream</span><br><span class="line">readstream &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;)&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会输出一个异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">invalid operation: &lt;-writeStream (receive from send-only type</span><br><span class="line">chanc- interface &#123;&#125;)</span><br><span class="line">invalid operation: readstream &lt;- struct &#123;&#125; literal (send to receive-only</span><br><span class="line">type &lt;-chan interface &#123;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这是Go语言的类型系统的一部分，它允许我们在处理并发原语时使用type-safety。正如我们稍后将在本节中看到的，这是一种强大的方法，可以声明我们的API并构建可组合的、易于推理的逻辑程序。</p>
<p>回想一下，在本章前面的部分中我们强调了一个事实，那就是goroutine是被动调度的，没有办法保证它会在程序退出之前运行。但是前面的示例是完整的，没有省略任何代码。你可能想知道为什么匿名的goroutine在main goroutine之前就完成运行了，是我运气好吗？让我们简短地讨论一下这个问题。</p>
<p>这个例子起作用了，因为Go语言中的channel是阻塞的。这意味着只有 channel内的数据被消费后，新的数据才能写人，而任何试图从空channel读取数据的goroutine将等待至少一条数据被写入channel后才能读到。在这个例子中，fmt.Println会从stringStream这个channel中消费一条数据，它会等channel中有数据后才开始消费。同样，匿名goroutine试图往 stringStream里写入一条字符串，所以在写人成功之前goroutine将不会退出。 因此，main goroutine和匿名goroutine一定是阻塞住的。</p>
<p>如果不正确地构造程序，这会导致死锁。请看下面的示例，它引入了一个无意义的条件，以防止匿名goroutine往channel里写入值：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stringstream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) gofunc()&#123;</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span>!=<span class="number">1</span>&#123;o</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">ttfns t tnelo chon n  i &#125;()</span><br><span class="line">fmt Print1n(&lt;-stringstream)</span><br></pre></td></tr></table></figure></p>
<p>O stringStream channel并没有值被写入成功。<br>这里会抛出 panic：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line">goroutine 1 [chan receive]:</span><br><span class="line">main.main()</span><br><span class="line">/tmp/babel-23079IVB/go-src-230795Jc.go:15+0x97</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure></p>
<p>main goroutine正在等待一个值被写人stringstream channel，但是由于我们的逻辑，这将永远不会发生。当匿名的goroutine退出时，检测到所有goroutines都没有运行，并报了一个死锁。在本章的后面将讲解如何构造程序才能做到简单的防止这种死锁，在下一章中会讲解如何完全避免这些问题。在此期间，让我们回到channel消费问题上。</p>
<p>通过《-操作符的接受形式也可以选择返回两个值，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stringStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; stringStream &lt;- <span class="string">"Hello channels!-</span></span><br><span class="line"><span class="string">&#125;()</span></span><br><span class="line"><span class="string">salutation, ok := &lt;-stringStream O</span></span><br><span class="line"><span class="string">fut.Printf("</span>(%v):%v<span class="string">",ok, salutation)</span></span><br></pre></td></tr></table></figure></p>
<p>0在这里会返回一个string类型的salutation值，一个布尔类型的值，ok。</p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(true):Hello channels!</span><br></pre></td></tr></table></figure></p>
<p>很好奇！布尔值表示什么？第二个返回值是读取操作的一种方式，用于表示该channel上有新数据写人，或者是由closed channel生成的默认值。稍等，closed channel，那是什么？<br>在程序中，能够提示channel中是否会有新的值写人是非常有用的。这有助于下游的程序知道什么时候消费、退出、给新的channel重新建立连接等。我们可以给每个这样的类型一个特殊标记，但这将覆盖大多数开发人员的代码，channe1只是一个简单的数据传输channel，而不是数据类型的函数，所以关闭channel是一个比较普通的操作，就好比哨兵说，“嘿，上游不会写人任何有价值的数据了，想干什么就千什么吧。”我们使用close关键字关闭一个channel，例如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">valueStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="built_in">close</span>(valueStrean)</span><br></pre></td></tr></table></figure></p>
<p>有趣的是，我们也可以从一个已关闭的channel读取数据。看这个例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intStream :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">close</span>(intStream)</span><br><span class="line">integer, ok :&lt;- intstrean o</span><br><span class="line">fmt.Printf(<span class="string">"(%v):%v"</span>,ok, integer) <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>从已经关闭的数据流中读取了数据。<br>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(false):0</span><br></pre></td></tr></table></figure></p>
<p>注意，我们从来没有把任何数据推送到channel上，立即关闭它。我们仍然能够执行读取操作，事实上，尽管channel已经关闭，我们仍然可以继续在这个channel上执行读取操作。这是为了支持一个channel有单个上游写人，有多个下游读取（在第4章中，我们将看到这是一个常见的场景）。第二个返回值（也就是变量ok的值）是false，这表示我们收到的值是int或是0，而不是推到stream上的值。</p>
<p>这为我们提供了一些新的模式。第一个是从channel中获取。通过range关键作为参数遍历（与for语句一起使用），并且在channel关闭时自动中断循环。这允许对channel上的值进行简洁的迭代。让我们看一个例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intstream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="keyword">defer</span> <span class="built_in">close</span>(intstream)<span class="number">0</span></span><br><span class="line">fori:=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++&#123;</span><br><span class="line">intstream &lt;-i</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> integer := <span class="keyword">range</span> intstrean&#123;o</span><br><span class="line">fmt.Printf(<span class="string">"%v "</span>，integer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>0我们确保在goroutine退出之前channel是关闭的。这是一个很常见的模式。 日遍历了intStream.<br>如你所见，所有的值都打印出来了，然后程序退出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345</span><br></pre></td></tr></table></figure></p>
<p>注意该循环不需要退出条件，并且range方法不返回第二个布尔值。处理一个已关闭的channel的细节可以让你保持循环简洁。<br>关闭channel也是一种同时给多个goroutine发信号的方法。如果有n个goroutine在一个channel上等待，而不是在channel上写n次来打开每个goroutine，你可以简单地关闭channel。由于一个被关闭的channel可以被无数次读取，所以不管有多少goroutine在等待它，关闭channel都比执行n次更适合，也更快。这里有一个例子，可以同时打开多个goroutine：</p>
<p>0 goroutine会一直等待，直到它被告知可以继续。 日关闭channel，从而同时打开所有的goroutine。<br>你可以看到，在我们关闭开始channel之前，所有的goroutine都没有开始运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unblocking goroutines...</span><br><span class="line">4 has begun</span><br><span class="line">2 has begun</span><br><span class="line">3 has begun</span><br><span class="line">o has begun</span><br><span class="line">I has begun</span><br></pre></td></tr></table></figure></p>
<p>请记住在本章前面“sync包”中，我们讨论了使用sync.cond类型执行相同的行为。你当然可以使用它，但是正如我们已经讨论过的，channel是可组合的，这是我最喜欢的一种在同一时间打开多个goroutine的方法。<br>我们还可以创建buffered channel，它是在实例化时提供容量的channel。这意味着即使没有在channel上执行读取操作，goroutine仍然可以执行n写入，其中n是缓冲channel的容量。下面是如何声明和实例化一个：<br>var dataStream chan interface{}<br>dataStream - make(chan interface{}, 4) 0<br>创建一个有4个容量的缓冲channel。这意味着我们可以把4个东西放到channel上，不管它是否被读取。<br>再一次，我将实例化分解成两行，这样就可以看到一个缓冲的channel的声明与一个没有缓冲的channel没有什么不同。这有点意思，因为它意味着goroutine可以控制实例化一个channel时否需要缓冲。这表明，创建一个</p>
<p>channel应该与goroutines紧密耦合，而goroutines将会在它上面执行写操作，这样我们就可以更容易地推断它的行为和性能。我们稍后将讨论这个问题。<br>没有缓冲的channel也被定义为缓冲channel，一个无缓冲channel只是一个以0的容量创建的缓冲channel。下面是两个具有等效功能的channel示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a :- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) b :-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, o)</span><br></pre></td></tr></table></figure></p>
<p>这两个channel都是具有零容量的int channel。请记住，当我们讨论阻塞时，如果说channel是满的，那么写人channel阻塞，如果channel是空的，则从channels读取的是什么？“Full”和“empty”是容量或缓冲区大小的函数。无缓冲channel的容量为零，因此在任何写人之前channel已经满了。一个没有下游接受的容量为4的缓冲channel在被写4次之后就满了，并且在写第5次的时候阻塞，因为它没有其他地方放置第五个元素。与未缓冲的channel一样，缓冲channel仍然阻塞channel为空或满的前提条件是不同的。通过这种方式，缓冲channel是一个内存中的FIFO队列，用于并发进程进行通信。<br>为了帮助理解这一点，让我们用例子来解释一个具有4个容量的缓冲channel的情况。首先，让我们来初始化：<br>c:=make(chan rune, 4)<br>从逻辑上讲，这创建了一个带有四个槽的缓冲区，比如：<br>现在让我们往channel里写数据：<br>c&lt;-‘A’<br>当这个channel没有下游读取时，一个数据将被放置在channel缓冲区的第一个槽中，就像这样：</p>
<p>每个后续的值写人到缓冲channel（假设没有下游读取）会在缓冲channel填充剩余的槽，比如：<br>c&lt;- R<br>c&lt;-‘C’<br>c&lt;-‘D”<br>经过4次写人，我们的缓冲channel容量为4。如果我们试图再次写入channel会发生什么？<br>c&lt;-‘E”<br>长E<br>执行操作的goroutine被阻塞了！goroutine将会被阻塞，直到有一些goroutine执行读取了在缓冲区的数据。让我们看看这是什么情况：</p>
<p>如你所见，下游去读取会依次接收位于channel上的第一个数据A，数据写人是阻塞的操作，E被放置在缓冲区的末尾。<br>它还提到，如果一个缓冲channel是空的，并且有一个下游接收，那么缓冲区将被忽略，并且该值将直接从发送方传递到接收方。在实践中这是透明的，但是对了解缓冲channel的配置是值得的。<br>缓冲channel在某些情况下是有用的，但是应该小心地创建它们。在下一章中，我们将看到，缓冲channel很容易成为一个不成熟的优化，并且使隐藏的死锁更不容易发生。这听起来像是一件好事，但我猜你宁愿在第一次写代码的时候发现死锁，而不是在生产系统崩溃的时候才发现。<br>让我们来看看另一个更完整的代码示例，它使用了缓冲channel，这样就可以更好地了解它们的工作原理：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stdoutBuff bytes.Buffero</span><br><span class="line"><span class="keyword">defer</span> stdoutBuff.WriteTo(os.stdout)o</span><br><span class="line">intstream :- <span class="built_in">make</span>(chanint,<span class="number">4</span>)<span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(intStream)</span><br><span class="line"><span class="keyword">defer</span> fmt.Fprintln(&amp;stdoutBuff,<span class="string">"Producer Done."</span>) <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">fmt.Fprintf(&amp;stdoutBuff,<span class="string">"Sending:%d\n"</span>，i) intstream &lt;.i</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> integer :- <span class="keyword">range</span> intstream &#123;</span><br><span class="line">fmt.Fprintf(&amp;stdoutBuff, <span class="string">"Received %v.\n"</span>, integer)</span><br></pre></td></tr></table></figure></p>
<p>0创建一个内存缓冲区，以帮助减少输出的不确定性。它没有给我们任何保证，但它比直接写stdout要快一点。<br>确保在进程退出之前缓冲区内容需要被写人到stdout。<br>创建了具有一个容量的缓冲channel。<br>在本例中，输出到stdout的顺序是不确定的，但仍然可以大致了解匿名goroutine是如何工作的。如果看一下输出，你就会发现我们的匿名goroutine<br>86|第3章<br>是如何把它的5个结果都写到intStream上的，然后在main goroutine将每个结果都推送出去之前就退出：</p>
<p>Keceveo 4.<br>这是一个适合某些条件的优化例子：如果goroutine写入一个channel的时候会知道它需要写多少条数据，它可以创建一个容量是写数量缓冲channel的，然后尽快往channel里写数据。当然，我们将会在下一章中讨论这么做的注意事项。<br>我们讨论了无缓冲channel、缓冲channel、双向channel和单向channel。我们没有覆盖的channel的唯一方面是channel的默认值nil。程序如何与值为nil的channel交互？首先，让我们试着从nilchannel中读取数据：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStream <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; &lt;-dataStream</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive (nil chan)]:</span><br><span class="line">main.main() /tmp/babel-23079IVB/go-src-2307904q.go:g+0x3f exit status 2</span><br></pre></td></tr></table></figure></p>
<p>死锁！这表明从nil channel读取数据将阻塞（尽管不一定是死锁）程序。那如果写人会发生什么呢？</p>
<p>它看起来像即使写到nil channel也会阻塞。只有一个操作可用，关闭。如果我们试图关闭nil channel会发生什么？<br>var dataStream chan interface{} close(dataStream)<br>输出如下：<br>panic: close of nil channel<br>goroutine 1 [running]:<br>panic(0x45boco, 0xc42000a160)<br>/usr/local/ib/go/src/runtine/panic.go:5oo+0x1a1 main.main()<br>/tmp/babel-23079IVB/go-src-230794uu.go:9 +0x2a exit status 2<br>这可能是在nil channel上执行的所有操作中最糟糕的结果panic。确保你所使用的channel都会被初始化。<br>我们已经讨论了很多如何与channel交互的规则。现在你已经了解在channel上执行操作的方式和原因，让我们为使用channel的创建一个可参考方式。表3-2列举了channel上的操作，以及在使用channel状态下会发生什么。<br>表3-2：channel操作的结果给出了channel的状态</p>
<p>如果检查这张表，我们会看到一些可能导致麻烦的数据。我们有三种操作可以导致goroutine阻塞，三种操作会导致程序panic！乍一看，似乎channel可能会有问题，但在研究了具体执行结果并确定了channel的使用方式之后，它就变得不那么可怕了，并且开始变得有意义了。让我们看看如何组织不同类型的channel来构建健壮和稳定的东西。<br>我们应该做的第一件事是在正确的环境中配置channel，即分配channel所有权。我将把所有权定义为实例化、写人和关闭channel的goroutine。就像没有GC的语言的内存一样，重要的是要弄清楚哪个goroutine拥有channel，以便从逻辑上推演我们的程序。单向channel声明的是一种工具，它将允许我们区分channel的拥有者和channel的使用者：channel所有者对channel （chan或chan《-）有一个写访问视图，而channel使用者只对channel有一个只读视图（《-chan）。一旦我们将channel所有者和非channel所有者区分开来，前面的表的结果自然就会很清晰，我们可以开始将责任分配给那些拥有channel的goroutine和不拥有channel的goroutine。<br>让我们从channel的所有者开始。拥有channel的goroutine应该具备如下：<br>1、实例化channel。<br>2.执行写操作，或将所有权传递给另一个goroutine.</p>
<p>3.关闭channel。</p>
<ol>
<li>Ecapsulate在此列表中的前三件事，并通过一个只读channel将它们暴露出来。<br>通过将这些责任分配给channel所有者，一些事情发生了：<br>因为我们初始化了channel，所以我们将死锁的风险转移到nil channel上。。因为我们初始化了channel，所以我们通过关闭一个nil channel来消除panic的风险。<br>因为我们决定了channel何时关闭，所以我们通过写人一个关闭的channel来消除panic。<br>因为我们决定了channel何时关闭，所以我们不止一次关闭channel，从而消除了panic的风险。<br>我们在编译时使用类型检查器，以防止写入channel异常。<br>现在让我们看看在读取channel时可能发生的阻塞操作。作为一个channel的消费者，我只需要担心两件事：<br>知道channel是何时关闭的。正确的处理阻塞。<br>为了解决第一个问题，我们只需像之前说的那样从read操作中检查第二个返回值。第二点更难定义，因为它取决于你的算法，可能想要超时，可能想要停止消费，或者可能只是对阻塞进程的生命周期有需求。重要的是，作为一个消费者，应该知道读取是阻塞的事实。我们将在接下来的章节中研究如何优雅的实现channel消费。<br>现在，让我们看一个例子来帮助阐明这些概念。让我们创建一个拥有channel的goroutine，以及一个处理channel阻塞和关闭的消费者：<br>chanOwner := func()&lt;-chan int {</li>
</ol>
<p>0实例化一个缓冲channel。因为知道将产生6个结果，我们创建一个有5 个缓冲的channel，这样goroutine就能尽快完成。<br>@启动一个匿名的goroutine，它在resultstream上执行写操作。注意，我们已经颠倒了如何创建goroutine。它现在被封装在外围函数中。<br>我们确保一旦执行完成resultstream就会关闭。作为channel所有者，这是我们必须做的。<br>在这里我们返回channel。由于返回值被声明为一个只读channel，因此resultStream将隐式地转换为只读消费者。<br>6遍历resultStream。作为消费者，我们只关心阻塞和channel的关闭。<br>输出如下：</p>
<p>注意，resultStream channel的生命周期是如何封装在chan所有者函数中的。很明显，写人不会在nil或已关闭的channel上发生，而且关闭总是只会发生一次。这从我们的程序中消除了大量的风险。我强烈建议在你的程序中，尽量保持channel所有权的范围很小，这样事情就变得显而易见了。如果有一<br>Go语言并发组件|91<br>版权所有，严禁以任何方式传播本PDF，违者自负法律责任！<br>个channel作为结构体的成员变量，并且有许多方法，它将很快变得不清楚该channel的行为方式。<br>消费者函数只能执行channel的读取方法，因此只需要知道它应该如何处理阻塞读取和channel的关闭。在这个小示例中，我们已经采取了这样的操作：在channel关闭之前，阻塞程序是完全可以运行的。<br>如果你设计让你的代码遵循这一原则，那么你的系统就会变得更容易梳理，并且它也更有可能按照你的期望来执行。我不能保证你永远不会引人死锁或panic，但当你这么做的时候，我想你会发现你的channel所有权的范围已经变得太大了，或者所有权已经变得不清晰了。<br>channel是吸引人们使用Go语言的原因之一。结合了goroutine和闭包的简单性，我很清楚地知道编写干净、正确的并发代码是多么容易。在很多方面，channel是将goroutine黏合在一起的黏合剂。本章应该给了你一个关于什么是channel以及如何使用它们的很好的概述。真正的乐趣始于我们开始编写channel以形成高阶并发设计模式。我们会在下一章讲到。<br>select语句<br>select语句是将channel绑定在一起的黏合剂，这就是我们如何在一个程序中组合channel以形成更大的抽象事务的方式。如果channel是将goroutine连接在一起的黏合剂，那么声明select的语句是做什么的呢？声明select语句是一个具有并发性的Go语言程序中最重要的事情之一，这并不是夸大其词。在一个系统中两个或多个组件的交集中，可以在本地、单个函数或类型以及全局范围内找到select语句绑定在一起的channel。除了连接组件之外，在程序中的这些关键节点上，select语句可以帮助安全地将channel与诸如取消、超时、等待和默认值之类的概念结合在一起。<br>相反，如果select语句是程序的通用语言，它们只处理channel，那么程序的组件应该如何协调？我们将在第5章中专门研究这个问题（提示，更推荐使用channel），</p>
<p>那么这些强大的select语句是什么呢？我们如何使用它们，它们是如何工作的？让我们先把它放出来。这里有一个很简单的例子：<br>var c1, c2&lt;-chan interface{} var c3 chan&lt;- interface{} select{<br>casec-c1:<br>11执行某些逻辑<br>casec-c2:<br>case c3&lt;-struct{(){}: /1执行某些逻辑<br>//执行某些逻辑<br>它看起来有点像一个选择模块，不是吗？就像一个选择模块，一个select模块包含一系列的case语句，这些语句可以保护一系列语句。然而，这就是相似之处。与switch块不同，select块中的case语句没有测试顺序，如果没有满足任何条件，执行也不会失败。<br>相反，所有的channel读取和写人都需要查看是否有任何一个已准备就绪可以用的数据注3，在读取的情况下关闭channel，以及写人不具备下游消费能力的channel。如果所有channel都没有准备好，则执行整个select语句模块。当一个channel准备好了，这个操作就会继续，它相应的语句就会执行。让我们来看一个简单的例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start :-time.Now()</span><br><span class="line">c:- <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; time, Sieep(<span class="number">5</span>*time.second)</span><br><span class="line"><span class="built_in">close</span>(c)<span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">"Blocking on read..."</span>)</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-C:<span class="number">0</span></span><br><span class="line">fmt.Printf(<span class="string">"Unblocked Ev later.\n"</span>, time.since(start))</span><br></pre></td></tr></table></figure></p>
<p>在等待5s后关闭channel。<br>注3：实际运行的状况要更复杂一些，我们会在第6章提及。</p>
<p>尝试在channel上读取数据。注意，在编写这段代码时，我们不需要select语句。可以简单地使用《-c，但是我们将在这个示例中进行扩展。<br>输出如下：<br>Blocking on read…<br>Unblocked 5.000170047s later.<br>如你所见，在进入select模块后大约5秒，我们就会解锁。这是一种简单而有效的方法来阻止我们等待某事的发生，但如果我们思考一下，我们可以提出一些问题：<br>，当多个channel有数据可供给下游读取的时候会发生什么？ ，如果没有任何可用的channel怎么办？<br>，如果我们想要做一些事情，但是没有可用的channels怎么办？<br>多个channel同时是可用的这个问题似乎很有趣。让我们试试，看看会发生什么！<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c1 :-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;);<span class="built_in">close</span>(c1)</span><br><span class="line">c2 :-<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;);<span class="built_in">close</span>(c2)</span><br><span class="line"><span class="keyword">var</span> c1count, c2Count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i:<span class="number">1000</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line">c1Count++</span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line">c2Count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">fmt. Printf(<span class="string">"c1Count:d\nc2Count:d\n"</span>, c1Count, c2Count)</span><br></pre></td></tr></table></figure></p>
<p>输出如下：</p>
<p>如你所见，在一千次迭代中，大约有一半的时间从c1读取select语句，大约一半的时间从c2读取。这看起来很有趣，也许有点太巧了。事实如此！Go语言运行时将在一组case语句中执行伪随机选择。这就意味着，在你的case语句集合中，每一个都有一个被执行的机会。<br>乍一看，这似乎并不重要，但背后的原因却非常有趣。让我们先做一个很明显的阐述：Go语言运行时无法解析select语句的意图，也就是说，它不能推断出问题空间，或者说为什么将一组channel组合到一个select语句中。正因为如此，运行时所能做的最好的事情就是在平均情况下运行良好。一种很好的方法是将一个随机变量引人到等式中（在这种情况下，select后续的channel）。通过加权平均每个channel被使用的机会，所有使用select语句的程序将在平均情况下表现良好。<br>关于第二个问题：如果没有任何channel可用，会发生什么？如果所有的channel都被阻塞了，如果没有可用的，但是你可能不希望永远阻塞，可能需要超时机制。Go语言的time包提供了一种优雅的方式，可以在select语句中很好地使用channel。这里有一个例子：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">cases-c:</span><br><span class="line">ct1tg91fe.e1m.secoc:</span><br><span class="line">fmt,Println(<span class="string">"Tined out."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>0这个case语句永远不会被解锁，因为我们是从nil channel读取的。 输出如下：<br>Timed out.<br>time.After函数通过传人time.Duration参数返回一个数值并写入channel，该channel会返回执行后的时间。这为select语句提供了一种简明</p>
<p>的方法。我们将在第4章重新讨论这个模式，在这里我们将讨论一个更健壮的解决方案。<br>最后一个问题：当没有可用channel时，我们需要做些什么？像case语句一样，select语句也允许默认的语句。就像“case”语句一样，当“select”语句中的所有channel都被阻塞的时候，“select”语句也允许你调用默认语句。以下是一个实例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start :=time.Now()</span><br><span class="line"><span class="keyword">var</span> c1, c2&lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c1:</span><br><span class="line"><span class="keyword">case</span> &lt;-c2:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fnt.Printf(<span class="string">"In default after vnn"</span>, time.Since(start)) ]</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In default after 1.421us</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它几乎是瞬间运行了默认语句。这允许在不阻塞的情况下退出 select模块。通常，你将看到一个默认的子句，它与for-select循环一起使用。这允许goroutine在等待另一个goroutine上报结果的同时，可以继续执行自己的操作。这里有一个例子：</p>
<p>输出如下：<br>Achieved s cycles of work before signalled to stop.<br>在这种情况下，我们有一个循环，它在执行某种操作，偶尔检查它是否应该被停止。<br>最后，对于空的select语句有一个特殊的情况：选择没有case子句的语句。看起来像这样：<br>select {}<br>这个语句将永远阻塞。<br>在第6章中，我们将深人研究select语句是如何工作的。从更高层次的角度来看，它应该是显而易见的，它可以帮助你安全高效地组合各种概念和子系统。</p>
<p>GOMAXPROCS控制<br>在runtime包中，有一个函数称为GOMAXPROCS。在我看来，这个名称是有误导性的：人们通常认为这个函数与主机上的逻辑处理器的数量有关（而且与它调度方式有关），但实际上这个函数控制的OS线程的数量将承载所谓的“工作队列”。有关这个函数的更多信息以及它的工作原理，请参见第6章。<br>在Go语言1.5之前，GOMAXPROCS总是被设置为1，通常你会在大多数Go语言程序中找到这段代码：</p>
<p>几乎大部分开发人员希望当他们的程序正在运行时，可以充分利用机器上的所有CPU核心。因此，在随后的Go语言版本中，它自动设置为主机上逻辑CPU的数量。<br>那么为什么要调整这个值呢？大部分时间你都不太想去调节它。Go语言的调度算法在大多数情况下已经足够好了，在增加或减少工作队列和线程数量的情况下，可能会造成更多的问题，但是仍然有一些情况会改变这个值。</p>
<p>例如，我在一个项目上调试，这个项目有一个测试组件，它被竞争环境困扰。不管怎么说，这个团队有几个包，有时候测试失败。我们运行测试的主机有四个逻辑CPU，因此在任何一个点上，我们都有四个goroutines同时执行。通过增加GOMAXPROCS以超过我们拥有的逻辑CPU数量，我们能够更频繁地触发竞争条件，从而更快地修复它们。</p>
<p>其他人可能通过实验发现，他们的程序在一定数量的工作队列和线程上运行得更好，但我更主张谨慎些。如果你通过调整这个方法来压缩性能，那么在每次提交之后，当你使用不同的硬件，以及使用不同版本的Go语言时，一定要这样做。调整这个值会使你的程序更接近它所运行的硬件，但以抽象和长期性能稳定为代价。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在本章中，我们已经介绍了所有的基本并发原语。如果你已经阅读并理解了这一点，那么恭喜你！你可以很好地在编写具有可读性和逻辑正确的程序。你知道在何时使用sync包中的同步原语访问内存，比使用channel和select语句“通过通信来共享内存”更合适。</p>
<p>在编写并发Go语言代码时，需要理解的是如何将这些原语以结构化的方式组合起来，并且易于理解。在这本书的下半部分，我们将讨论如何做到这一点。下一章是关于如何使用社区已经发现的模式组合这些原语。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言并发之道/" rel="tag"># Go语言并发之道</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/09/第2章-对你的代码建模：通信顺序进程/" rel="next" title="第2章 对你的代码建模：通信顺序进程">
                <i class="fa fa-chevron-left"></i> 第2章 对你的代码建模：通信顺序进程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/09/第4章-Go语言的并发模式/" rel="prev" title="第4章 Go语言的并发模式">
                第4章 Go语言的并发模式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">放弃会成为一种习惯</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">413</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2021/12/05/08-自研or借力（上）：集成Gin替换已有核心/" title="08|自研or借力（上）：集成Gin替换已有核心" target="_blank">08|自研or借力（上）：集成Gin替换已有核心</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/07-目标：站在巨人肩膀，你的理想框架到底长什么样？/" title="07|目标：站在巨人肩膀，你的理想框架到底长什么样？" target="_blank">07|目标：站在巨人肩膀，你的理想框架到底长什么样？</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/06-重启：如何进行优雅关闭？/" title="06|重启：如何进行优雅关闭？" target="_blank">06|重启：如何进行优雅关闭？</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/05-封装：如何让你的框架更好用？/" title="05|封装：如何让你的框架更好用？" target="_blank">05|封装：如何让你的框架更好用？</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/04-中间件：如何提高框架的可拓展性？/" title="04|中间件：如何提高框架的可拓展性？" target="_blank">04|中间件：如何提高框架的可拓展性？</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#goroutine"><span class="nav-number">1.</span> <span class="nav-text">goroutine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sync包"><span class="nav-number">2.</span> <span class="nav-text">sync包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WaitGroup"><span class="nav-number">3.</span> <span class="nav-text">WaitGroup</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#互斥锁和读写锁"><span class="nav-number">4.</span> <span class="nav-text">互斥锁和读写锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#池"><span class="nav-number">5.</span> <span class="nav-text">池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#channel"><span class="nav-number">6.</span> <span class="nav-text">channel</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">3.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">58:31</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
