<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go语言并发之道">
<meta property="og:type" content="article">
<meta property="og:title" content="第5章 大规模并发">
<meta property="og:url" content="http://yoursite.com/2021/09/09/第5章-大规模并发/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-11-01T09:20:19.578Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第5章 大规模并发">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">






  <link rel="canonical" href="http://yoursite.com/2021/09/09/第5章-大规模并发/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第5章 大规模并发 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/09/第5章-大规模并发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第5章 大规模并发

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-09 14:48:05" itemprop="dateCreated datePublished" datetime="2021-09-09T14:48:05+08:00">2021-09-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-11-01 17:20:19" itemprop="dateModified" datetime="2021-11-01T17:20:19+08:00">2021-11-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">25k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">23 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>之前的章节中，你已经学习了一些Go语言中使用并发的常见模式。现在让我们将重点转移到这些模式的使用上，我们会利用这些模式构建一系列的并发系统，这些实践可以帮助你写出规模化、组件化的系统。<br>在这一章，我们将研究如何使用单进程进行大规模并发操作，并开始探寻多进程处理时并发是如何发挥作用的。<br>异常传递<br>编写并发代码，特别是在分布式系统中，你的系统中非常容易出现一些奇怪问题，并且难以理解为什么会发生这种情况。为了将你自己、你的团队、你的用户从众多的痛苦中拯救出来，你需要仔细考虑异常（error）是如何通过分布式系统传递的，以及问题最终将如何呈现给使用者。在第4章“异常处理”中，我们研究了如何将goroutine中的异常传递出来，但是并未过多探讨这些异常应当是什么样的，或者异常应当如何经过一个庞大而复杂的系统传递出来。以下是用于处理并发系统中异常的一个示意框架，让我们用这个框架来对异常传递的哲学进行一些研究。<br>许多开发人员有个误解，认为在系统流程中异常的传递并不是那么重要。他们通常会谨慎的考虑数据会如何经过系统，但是却轻易的容忍异常，未经过思考就将异常从栈中抛出，最终导致异常直接展示在了用户面前。Go语言试</p>
<p>图纠正这种不良习惯，强制开发人员处理调用栈上的每个关键点的异常，但是在系统控制流中将异常视为不太重要仍然是一种常见的行为。其实只需要一点计划和非常小的代价，你就可以将异常控制在系统范围内，优化你的用户体验。<br>首先让我们来明确异常是什么，什么时候发生，提供了那些好处。<br>出现异常表示着你的系统进入了一个无法满足用户操作的状态，这个操作可能是显式的，也可能是隐式的。这时系统需要传达几个关键的信息：<br>发生了什么<br>这部分异常信息包含了对异常事件的描述。例如：“磁盘已满”，“连接被重置”，“证书过期”。这些信息可能是被一些代码隐式的表达出来的，你可以用一些上下文来修饰这些信息来帮助用户理解发生了什么问题。发生在什么时间、什么位置<br>异常应当总是包含完整的栈轨迹信息，从调用的启动方式开始，以异常的实例结尾。栈轨迹信息不应该包含在异常消息中（这一点尤为重要），但当需要处理栈中的异常时应该很容易被找到。<br>更进一步讲，异常应当包含有关其内部运行的上下文信息。例如，在分布式系统中，异常应该有一些字段用来识别发生异常的机器。发生异常后，这些信息会对你诊断系统故障原因非常有价值。<br>此外，异常还应包含对应机器上的时间，并且最好是UTC时间。<br>对用户友好的信息<br>应当对展现给用户的异常信息进行自定义，以适应你的系统和用户。这些信息应该只包含前两点的概述以及相关信息。对用户友好的信息是从用户的角度考虑，给出一些信息，说明这些问题是否是暂时的，并且最好是一行以内的文本。<br>告诉用户如何获得更多的信息<br>在某些情况下，用户希望知道当异常发生时，具体发生了哪些故障。展现给用户的异常信息应当提供一个ID，利用这个ID可以查询到对应的详细</p>
<p>日志。这个详细日志应显示异常的完整信息：发生异常的时间（而不是异常记录的时间），异常创建时完整的堆栈调用。包含一个堆栈轨迹的hash也有助于聚合这些异常，就像bug追踪器那样跟踪问题。<br>默认状态下，如果你不介人，异常信息不会包含上述所有的信息。因此，你应当保持这样一种观念，任何展现给用户的异常信息如果没包含这些信息，不是出错了就是有bug。这引出了一个可以用来处理异常的通用模型。所有的异常都几乎都能归为以下两种分类之一：<br>Bug。<br>。已知信息（例如网络连接断开，磁盘写人失败等）。<br>Bug是一些你未在你的系统中定义的异常，或者一些“原生”的异常，就是那些极少遇到的情况。有时这是有意为之的，在你系统最初的几次迭代中，一些罕见问题展现给用户是可以接受的。还有些时候这是意外发生的。总之，如果你同意我所提出的方法，即“原生”异常总是bug。在确定如何传播异常时，在系统随着时间的推移如何增长以及最终向用户展示什么时，这种区别被证明是非常有用的。<br>想象一个多模块的大型系统<br>命令行组件<br>中层组件<br>底层组件<br>我们假设在“底层组件”中产生了一个结构良好的异常，它正在等待上传到栈中。在“底层组件”的背景中，这个异常的结构可能是良好的，但是在我们的系统中，它可能并非如此。让我们以每个组件的边界为例，所有传入的异常信息都必须使用我们的代码重新格式化。例如，我们在“中层组件”调用“底层组件”中可能会出错函数时，我们可以这样写；</p>
<p>在这里，我们检查一下接收到的异常信息，以确保它的结构是良好的。如果不是，我们就简单地将异常推到栈上，以显示出这个bug。<br>在这里，我们使用一个假设的函数将传入的异常和模块相关的信息封装起来，并赋予它一个新的类型。请注意，包装异常可能会隐藏一些底层的细节，这些细节对于用户来说可能并不重要。<br>当异常被最初实例化时，异常信息中包含了太多的底层细节，这些细节与异常产生的根源（例如，goroutine，机器，栈轨迹等）息息相关。不过我们的体系规定了，我们应当在模块的边界处将这些底层异常转换成我们这一层模块的异常结构，并将底层细节改写成与我们模块相关的信息。现在，如果出现了一些异常，并且并非我们模块的异常结构，便可以认为是格式异常，或者是一个bug。请注意，只在必要时才用这种方式包装异常，比如你自己的模块边界（公共函数1方法）或者你的代码要添加有意义的上下文。这可以防止在大量的代码中重新包装异常信息。<br>采用这一机制，可以使我们的系统有机的增长。我们可以确定的是，传入的异常是完整的。反过来说，我们可以保证我们正在考虑异常如何传出我们的模块。异常的正确性成为了我们系统的一个关键属性。我们也从一开始就尽可能完美、明确地处理不规范的异常，这样我们构建出一个处理异常的框架，随着时间的推移不断的纠正异常。再通过呈现给用户的类型划分，可以更清晰的划分异常。<br>正如我们上面说的，所有的异常都应该尽可能的记录下来。但是，当向用户显示异常时，bug和已知罕见问题还是有一定区别的。</p>
<p>当我们面向用户部分的代码收到一个格式良好的异常信息时，我们知道在代码的各个层面上，我们都小心的处理了异常，我们可以将其记录下来并打印出来供用户查看。确保异常类型的准确有效是非常重要的。<br>当不规范的异常或bug传递给用户时，我们也应该记录异常，但是应该向用户显示一条友好的消息，指出发生了意外的事情。如果我们在系统中支持自动的异常报告，则应该将这些问题报告为bug。如果我们不这样做，我们应该建议用户提交一个bug反馈。请注意，不规范的异常实际上也可能包含有用的信息，但我们不能保证这一点，我们唯一能确认的是异常没有经过我们格式化。因此我们应该直截了当地展示一段人类可解读的信息，来展示刚刚发生的事情。<br>请记住，在这两种情况下，如果出现格式不规范的异常，我们将在消息中包含一个日志ID，以便用户在需要更多信息时可以查询到相关的内容。因此，如果bug确实包含了有用的信息，有需要的用户仍然有可追踪的线索。<br>我们来看一个完整的例子。这个例子并不是非常健壮（例如，异常类型可能很简单），调用顺序也是线性的，这使我们只需要在模块边界处包装异常。而且，在一本书中很难用不同的包来表示函数，所以我们会假定这些函数是存在的。<br>首先，我们来创建一个异常类型，它包含了一个格式良好的异常应有的内容：</p>
<p>在这里，我们存储了我们正在包装的异常。通常我们会希望能够找到最底层的异常，以便在需要时可以调查发生的异常。<br>这行代码在创建异常时记录堆栈轨迹。过于复杂的错误类型经过wrapError包装后可能会省略一些栈帧。<br>在这里，我们创建一个可以存储各种杂项的变量。我们可以将并发ID，<br>堆栈轨迹的hash或可能有助于诊断异常的其他上下文信息存储在这里。<br>接下来，我们来创建一个底层模块：<br>// lowLevel模块<br>type LowlevelErr struct {<br>error<br>}<br>func isGloballyExec(path string) (bool, error){<br>info, err :- os.Stat(path)<br>if err !. nil{<br>return false, LowlevelErr{(wrapError(err, err.Error()))}0 return info.Mode().Perm()&amp;0100- o1o0, nil<br>}<br>0在这里，我们用自定义的异常来调用os.stat中的原始异常。在这种情况下，我们可以用这个异常传递信息，而不用对它做任何修饰。<br>然后，让我们创建一个中间模块，用来调用底层模块的package：</p>
<p>这里我们传递来自底层模块的异常。因为我们的体系结构决定，我们需要考虑从其他模块传递来的错误，而不是将它们用我们自己的错误类型包装，这里会存在一些问题，后面会提到。<br>最后，让我们创建一个外层的main函数来调用中间层。这是我们程序面向用户的部分：<br>func handleError(key int, err error, message string) {<br>log.SetPrefx(fmt.Sprintf(“[1ogID:%v]:”,key))<br>log.Printf(“%#v”,err)0<br>fmt.Printf(“[%v]%v”, key, message) ]<br>func nain(){<br>log.Setoutput(os.stdout)<br>log.setFlags(log.ltime|iog.LUTc)<br>err :=runJob(“1”)<br>if err !nil{<br>msg :=”There was an unexpected issue; please report this as a bug.” if_, ok :=err.(IntermediateErr);ok{0<br>msg = err.Error()<br>ldrer1 errms<br>} }<br>0在这里，我们检查一下异常是否是预期的类型。如果是，那么可以确定这<br>是一个结构完整的异常，我们只要简单地将其中的消息传递给用户即可。在这一行，我们将日志和异常消息与一个ID绑定在一起。我们可以使用一个自增ID，或者用GUID来保证ID的唯一性。</p>
<p>在这里，我们记录下异常的所有内容，以备有人需要深入了解发生的事情。运行上面的程序，我们会得到一条日志信息，内容如下：<br>[1ogID:1]:21:46:07main.LowlevelErr{error:main.MyError{Inner: (*os.PathError)(0xc4200123fo),<br>Message: “stat /bad/job/binary: no such fle or directory”,<br>StackTrace:”goroutine 1 [running]:<br>runtime/debug.stack(0xc420012420,0x2f, 0xc420045d80)<br>/home/kate/.guix-profle/src/runtime/debug/stack.go:24+0x79<br>main.wrapError(0x530200,0xc4200123fo,0xc420012420,0x2f,0xo,0x0, 0x0，0x0，0x0，0x0，…)<br>/tmp/babel-79540aE/go-src-7954NTK.go:22+0x62<br>main.isGloballyExec(ox4d1313,0xf,0xc420045eb8,0x487649,0xc420056050) /tmp/babel-79540aE/go-src-7954NTK.go:37 +oxaa<br>main.runJob(0x4cfada,0x1,0x4d4c35,0x22)<br>/tmp/babel-79540aE/go-src-7954NTK.go:47+0x48<br>main.main()<br>/tmp/babel-79540aE/go-src-7954NTK.go:67+0x63<br>“，Misc:map[string]interface {}{}}}<br>还有一条包含在标准输出里的消息：<br>[1] There was an unexpected issue; please report this as a bug.<br>在日志中我们可以看出，上面某些地方在遇到这些错误路径时处理不当，因为我们不能确定这些异常信息是否适合用户阅读，所以我们在标准输出中打印出一个简单的异常，指出发生了意外情况。现在我们回顾一下中间层，我们回想一下这个问题：我们为什么没有包装来自lowlevel模块的异常。我们来修正一下，看看会发生什么：</p>
<p>在这里，我们使用精心设计的异常信息。在这种情况下，我们想隐藏异常的底层细节，因为我们觉得这对我们模块的调用者来说并不重要。<br>func handleError(key int, err error, message string){<br>log.SetPrefix(fmt.Sprintf(“[logID:%v]:”,key))<br>log.Printf(“%#v”,err)<br>fmt.Printf(“[%v]%v”, key, message)<br>}<br>func main(){<br>log.Setoutput(os.stdout)<br>1og.setFlags(iog.ltime|iog. LUTC)<br>err :=runJob(“1”)<br>if err != nil{<br>msg :=”There was an unexpected issue; please report this as a bug.” if_, ok :uerr.(IntermediateErr);ok{<br>msg u err.Error()<br>handleError(1,err, msg)<br>}<br>现在我们运行更新后的代码，我们得到了下面这样的日志消息：</p>
<p>现在我们的异常信息正是我们希望用户看到的：<br>[1] cannot run job “1”: requisite binaries not available<br>有与我们使用的方法兼容的软件包法1，不过你也可以使用任何异常软件包来实现这种异常处理方式。你可以设计出最高级别的异常处理，并且划分异常和精心设计的异常，然后逐步确认你创建的所有异常都是被精心设计的。<br>超时和取消<br>在并发代码运行时，超时（Timeouts）和取消（Cancellation）会频繁出现。在本节中我们将会看到，超时的处理对于创建一个易于理解的系统是至关重要的，进程被取消是其发生超时的自然反映。我们还将探讨一个并发进程可能被取消的原因。<br>那么，我们为什么希望我们的并发程序支持超时呢？这里有几个原因：<br>系统饱和<br>正如我们在第4章“排队”中所讨论的，如果我们的系统已经饱和（即它<br>注1:我推荐阅读ttp://github.com/pkglerrors.</p>
<p>的处理请求的能力刚好足够处理），我们可能希望超出的请求返回超时，而不是花很长的时间等待响应。你采取的应对方式取决于你的问题空间，下面是一些关于何时应当超时的一般性指导：<br>请求在超时时不太可能重复。<br>没有资源来存储请求（例如，内存队列的内存，持久队列的磁盘空间）。如果对系统的响应或请求发送数据有时效性的要求（我们将在接下来讨论）。如果一个请求可能会重复，超时会额外增加一个请求和超时的消耗。如果开销超过我们系统的容量，这可能会导致系统宕机。不管怎样，如果我们缺少将请求存储在队列中所需的系统资源，那也是没有意义的。即便我们符合这两个指导方针，只要我们能及时处理，让请求进入排队中意义也不大。这给我们带来了下一个支持超时的理由。<br>陈旧的数据<br>数据通常有一个窗口期，一般是在这个窗口中必须先处理更多的相关数据，或者处理数据的需求已经过期。如果一个并发进程处理数据需要的时间比这个窗口期更长，我们会想返回超时并取消并发进程。例如，如果我们的并发进程在长时间的等待之后响应请求，则在排队中的请求或其数据可能已经过时。<br>如果事先知道这个窗口时间，那么将context.WithDeadline或context.WithTimeout创建的context.context传递给我们的并发进程是有意义的。如果事先不知道窗口，我们希望并发进程的父节点能够在请求不再需要时取消并发进程。context.withCancel是达到这个目的的最佳选择。<br>试图防止死锁<br>在大型系统中，尤其是分布式系统中，有时难以理解数据流动的方式，或者可能出现的罕见情况。为了保证系统不会发生死锁，建议在所有并发操作中增加超时处理。超时时间不一定要接近执行并发操作所需的实际时间。</p>
<p>不过超时的目的只是为了防止死锁，所以需要它足够短，使死锁的系统在合理的时间内解除阻塞即可。<br>以上内容使我们知道了，尝试通过设置超时可以将一个死锁系统转变为一个活锁系统。不过，在大型系统中，由于存在更多灵活的组件，在系统死锁后，你的系统更可能会遇到时序配置不同步的情况。因此，最好是在允许的时间内尽可能修复活锁，好过发生死锁后只有通过重新启动才能恢复系统。<br>请注意，这不是如何正确构建系统的建议，而是关于如何建立一个对时间问题有容错能力的系统，这些错误在开发和测试过程中可能不容易遇到。我建议你将超时设置在适当的位置，但是目标应该是在没有触发超时的情况下处理完所有的请求。<br>现在我们已经掌握应当何时使用超时了，让我们把注意力转向取消，以及如何建立一个并发处理来优雅地处理取消。并发进程可能被取消的原因有很多：<br>超时<br>超时是隐式取消。<br>用户干预<br>为了获得良好的用户体验，通常建议维持一个长链接，然后以轮询间隔将状态报告给用户，或允许用户查看他们认为合适的状态。当用户使用并发程序时，有时需要允许用户取消他们已经开始的操作。<br>父进程取消<br>对于这个问题，如果任何一种并发操作的父进程停止，那子进程也将被取消。<br>复制请求<br>我们可能希望将数据发送到多个并发进程，以尝试从其中一个进程获得更快的响应。当第一个回来的时候，我们就会取消其余的进程。我们将在第5章“复制请求”中详细讨论。<br>也可能有其他的原因。然而，“为何”这个问题并不像“如何”这样的问</p>
<p>题那么困难或有趣。在第4章中，我们探讨了两种取消并发进程的方法：channel done和context.context类型。这是相对容易的一部分，在这里我们想要探索更复杂的问题：当一个并发进程被取消时，对于正在执行的算法及其下游消费者意味着什么？在编写可随时终止的并发代码时，需要考虑哪些事项？<br>为了回答这些问题，我们需要探索的第一件事是并发进程的可抢占性。观察下面的代码，并假设它在自己的goroutine中运行：<br>var value interface{} select {<br>case &lt;-done:<br>return<br>case value =&lt;-valueStream<br>result :=reallyLongCalculation(value) select{<br>case&lt;-done:<br>return<br>case resultStream&lt;-result:<br>我们已经可以从valueStream的读取数据然后写人resultstream，并监听channel done，检查goroutine是否被取消了，但是仍然有一些问题。reallyLongCalculation似乎不能抢占，而且根据名字来看，可能需要很长时间！这意味着，如果在长时间计算正在执行的时候，如果有东西试图取消这个goroutine，那么在我们确认取消和停止之前可能需要很长时间。让我们试着让reallyLongCaluclation支持抢占，看看会发生什么：</p>
<p>我们已经取得了一些进展：reallyLongCaluclation现在可以被抢占了，不过我们只将问题减少了一半：我们只能在reallyLongCalculation调用其他函数实现抢占。为了解决这个问题，我们需要编写longCalculation，就像下面这样：<br>reallyLongCalculation :- func(<br>done &lt;-chan interface{},<br>value interface{},<br>) interface{}{<br>intermediateResult := longCalculation(done, value) return longCaluclation(done, intermediateResult) }<br>如果认为这个推理的结论是合乎逻辑的，那就能得出以下两个必要的任务：定义我们的并发进程可抢占的周期，确保运行周期比抢占周期长的功能本身都是可抢占的。一个简单的方法是将你的goroutine代码段分解成小段。你应该注意那些不可抢占的原子操作，确保它们的运行时间小于你认为可以接受的时间。<br>这里还有另外一个潜在的问题：如果我们的goroutine恰好修改了共享状态（例如数据库，文件，内存数据结构），那当goroutine被取消时会发生什么？你的goroutine会试图将这个中间状态回滚吗？回滚过程需要多长时间？goroutine已经接收到了停止的信号，所以它不应该花太长的时间来回滚它之前的工作，对吧？<br>就如何处理这个问题很难给出通用的建议，因为你的算法的性质很大程度上决定了你应当如何解决这个问题。然而，如果你将对共享状态的修改保持在一个很小的范围内，并且确保这些修改很容易回滚，那么你可以很好的处理取消。如果可能的话，将中间结果存储在内存，然后尽可能快的修改状态。下面是一个错误的示范：</p>
<p>这里我们改变了三次状态。如果运行这个代码的goroutine在最后写人之前被取消，我们需要以某种方式回滚前两个调用来修改TallyToState。对比这个方法：<br>result :=add(1,2,3,4,5,6,7,8,9) writeTallyToState(result)<br>这次我们必须回滚范围要小得多。如果在调用writeToState之后取消，我们仍然需要一种方法来撤回我们的修改，但是由于我们只修改了一次状态，发生这种情况的可能性要小得多。<br>你需要关心的另一个问题是重复的消息。假设你有一个管道，它有三个阶段：生成阶段，阶段A和阶段B。生成阶段通过记录上一次channel被读取的时间，来监控阶段A持续的时间。如果当前实例变得不正常，则产生新的实例A2。如果发生这种情况，阶段B可能会收到重复的消息（见图5-1）。<br>你可以从图5-1看到，如果在阶段A已经将阶段B的结果发送到阶段B之后，接收取消的信号，那么阶段B可能会收到重复的消息。<br>有很多种方法可以避免发送重复的消息。最简单的方法（也是我推荐的方法）是让一个父goroutine在子goroutine已经发送完结果之后发送一个取消信号。这需要各阶段之间的双向通信，我们将在本章后面“心跳”中详细介绍。其他方法是：<br>接收到的第一个或最后一个消息<br>如果你的算法允许，或者你的并发进程是幂等的，那么你可以简单地在下游进程中允许可能存在的重复消息，并从接收到的第一个消息或最后一个消息中挑选一个处理。</p>
<p>图5-1：如何发送重复消息的示例<br>向父goroutine确认权限<br>你可以与你的父goroutine使用双向通信来确认你发送消息的权限。这种方法与心跳类似，如图5-2所示。<br>因为我们明确请求允许在B的channel上执行写人操作，这比心跳更安全；然而，在实践中很少这样做，因为它比心跳更加复杂，而心跳更普遍且有效，所以我建议你只使用心跳。<br>心跳<br>心跳是并发进程向外界发出信号的一种方式。这个说法来自人体解剖学，在解剖学中心跳反应了观察者的生命体征。心跳在Go语言之前就已经存在，而且.一直非常有效。</p>
<p>图5-2：轮询父goroutine的示例<br>在设计并发程序时，一定要考虑到超时和取消。如果从一开始就忽略超时和取消，然后在后期尝试加人它们，这有点像在蛋糕烤好后再加鸡蛋。<br>在并发编程中，有几个的原因使心跳变得格外有趣。它允许我们对系统有深人的了解，当系统工作不正常时，它可以对系统进行测试。<br>本节将讨论两种不同类型的心跳：<br>。在一段时间间隔内发出的心跳。 。在工作单元开始时发出的心跳。<br>在一段时间间隔上发出的心跳对并发代码很有用，尤其是当它在处于等待状态。因为你不知道新的事件什么时候会被触发，你的goroutine可能会在等待某件事情发生的时候挂起。心跳是告诉监听程序一切安好的一种方式，而静默状态也是预料之中的。<br>下面的代码演示了一个会发出心跳的goroutine：</p>
<p>0我们建立了一个发送心跳的channel。我们把这个返回给doWork.<br>日我们设定心跳的间隔时间为我们接到的pulseInterval。每隔一个pulseInterval的时长都会有一些东西读取这个channel。<br>186|第5章<br>这是另一个用来模拟滴答声的channel。我们选择的持续时间大于pulseInterval，这样我们就能看到从goroutine中发出的一些心跳。<br>注意，这里我们加入了一个默认语句。我们必须时刻警惕这样一个事实：可能会没有人接收我们的心跳。从goroutine发出的信息是重要的，但心跳却不一定重要。<br>就像done channel一样，当你执行发送或接收时，你也需要包含一个发送心跳的分支。<br>请注意，因为我们可能在等待输入时发出多个心跳，或者在等待发送结果时发出多个心跳，所以所有的select语句都需要在for循环中。目前为止看起来都很好；我们如何利用这个函数并消费它所发出的事件呢？让我们来看看：<br>done :=make(chan interface{})<br>time.AfterFunc(1o<em>time.Second, func(){ close(done)})0 const timeout - 2</em>time.Second @<br>heartbeat, results :- doWork(done, timeout/2)0<br>for{<br>select {<br>case. ,ok ;=&lt;-heartbeat:o<br>if ok u false {<br>return<br>fmt,Println(“pulse”) case r, ok :u &lt;-results:G if ok u false{<br>return<br>fmt.Printf(“results %v\n”,r.Second()) case &lt;-time.After(timeout):0<br>return<br>我们声明了一个标准的done channel，并在10秒后关闭。这给了我们的goroutine做一些工作的时间。<br>这里我们设置了超时时间。我们使用此方法将心跳间隔与超时时间联系起来。</p>
<p>我们在这里timeout/2。这使我们的心跳有额外的响应时间，以便我们的超时不太敏感。<br>在这里，我们处理心跳。当没有消息时，我们至少知道每过timeout/2的时间会从心跳channel发出一条消息。如果我们什么都没有收到，我们便知道是goroutine本身出了问题。<br>在这里，我们处理results channel；这里没什么特别的。<br>如果我们没有收到心跳或其他消息，就会超时。<br>运行此代码得到下面的结果：<br>pulse<br>pulse<br>results52 pulse<br>pulse<br>results54 pulse<br>pulse<br>results56 pulse<br>pulse<br>results58 pulse<br>你可以看到，我们收到的每个消息之间大约有两个心跳。<br>在一个功能正常的系统中，心跳并没什么有趣的。我们可能会用它们来收集关于空闲时间的统计数据，但是当你的goroutine不像预期的那样运行时，基于间隔的心跳的作用就会非常大。<br>思考下面的例子。我们将在两次迭代后停止goroutine，但却不关闭我们的任何一个channel，来模拟一个产生了异常的goroutine。让我们看下代码：</p>
<p>这是我们模拟的问题。所以它不是无限循环的，不需要我们手动停止，就像前面的例子一样，我们只会循环两次。<br>运行此代码得到下面的结果：<br>pulse<br>pulse<br>worker goroutine is not healthy!<br>非常好！在两秒之内，我们的系统意识到我们的goroutine有一些不妥之处，中断了for-select循环。通过使用心跳，我们已经成功地避免了死锁，并且我们不需要依赖更长的超时时间来保持确定性。我们将在本章后面“治愈异常的goroutine”中进一步讨论如何进一步采用这个概念。<br>另外请注意，心跳也会有反作用：虽然它让我们知道，长时间运行的goroutine依然正常工作着，但是这需要一点时间运行，计算出值并发送给channel。<br>现在，让我们暂时放下间隔心跳，来看看在一个工作单元开始时发出的心跳。它对于测试来说非常有效。以下是在每个工作单元开始之前发送的例子：</p>
<p>在这里，我们创建一个缓冲区大小为1的heartbeat channel。这确保了即使没有及时接收发送的消息，至少也会发出一个心跳。<br>在这里，我们为心跳设置了一个单独的select块。我们希望将发送results和心跳分开，因为如果接收者没有准备好接收结果，作为替代它将接收到一个心跳，而代表当前结果的值将会丢失。由于我们有默认逻辑所以这里也没有包含对done channel的处理。<br>在这里，为了防止没人接收我们的心跳，我们增加了默认逻辑。因为我们的heartbeat channel创建时有一个缓冲区那么大，所以如果有人正在监听，但是没有及时收到第一个心跳，接收者仍然可以收到心跳。<br>运行此代码得到下面的结果：</p>
<p>你可以看到，每个结果都如预期一样伴随着一个心跳。<br>这种写法真正的亮点在于测试。基于时间间隔的心跳可以以相同的方式使用，但是如果你只关心goroutine是否开始了它的工作，这有一种很简单的方式。观察下面的代码：</p>
<p>0在这里，我们模拟在goroutine开始工作之前的某种延迟。在实践中，这<br>可能是各种各样的问题，而且无法确定。我曾经见过CPU负载过高、磁盘抢占、网络延迟和goblins造成的延迟。<br>DoWork函数是一个非常简单的生成器，它将我们传入的数字转发到它返回的channel中。让我们为这个函数写个测试。下面是一个不那么好的测试样例：<br>func TestDoWork_GeneratesAllNumbers(t <em>testing.T){<br>done := make(chan interface{})<br>defer close(done)<br>intSlice :=[]int{o,1,2，3，5}<br>_, results :=DoWork(done, intslic—)<br>for i, expected :- range intslice {<br>select {<br>case r:=&lt;-results:<br>if r != expected {<br>t.Errorf( “index %v:expected %v, but received %v,”, i,<br>expected,<br>r,<br>1<br>case &lt;-time.After(1</em> time.Second):0<br>t.Fatal(“test timed out”)<br>]<br>}<br>}<br>0在这里我们设置一个合理的超时时间，避免goroutine陷入死锁。<br>运行此代码得到下面的结果：</p>
<p>这个测试不够好，因为它是非确定性的。虽然在我们的示例函数中，已经确保这个测试总是会失败，但如果我要删除这个time.Sleep的话，情况可能变得更糟：这个测试有时会通过，有时则会失败。<br>我们前面提到过，一些外部的因素会导致goroutine花费更长的时间来进行第一次迭代。无论goroutine在调度中是否是第一位执行的，这都是一个令人担忧的问题。关键是我们无法保证goroutine的第一个迭代是否会在超时时间结束之前执行，我们思考一下这个概率：这个超时有多大可能是有意义的？我们可以增加超时时间，但这意味着将需要很长时间才知道执行失败，从而减慢我们的测试过程。<br>这会产生一些非常可怕的后果。我们慢慢开始不相信测试，然后开始忽略测试，之前的努力将一点点被瓦解。<br>幸运的是，利用心跳可以很轻易的解决这个问题。这是一个确定性的测试：</p>
<p>运行测试将产生以下输出：<br>ok command-line-arguments<br>2.002s<br>由于有了心跳，我们可以安全的编写测试而不需要加人超时机制。除此之外还有一个风险，就是我们的一个迭代要花费大量的时间。如果这对我们很重要，那我们可以利用更安全的间隔心跳，从而实现完美的安全性。<br>下面是一个使用心跳进行测试的例子：</p>
<p>0我们需要两个循环：一个循环遍历数列，内部循环持续执行，直到intstream中的数字成功发送。<br>@使用一个标签来使简化内部循环。<br>③跳回numLoop标签继续执行外部循环。<br>等待第一次心跳到达，来确认goroutine已经进入了循环。<br>目接收心跳，以防止超时。<br>运行此代码得到下面的结果：<br>ok command-line-arguments<br>3.002s<br>你应该注意到了，这个版本的测试不太清晰，我们测试的逻辑有点混乱。因此，如果你确信goroutine的循环一旦执行就不会停止，那么我建议只阻塞第一次心跳，然后进入一个简单的range语句。你可以编写单独的测试，专门测试未能关闭channel，耗时太长的迭代，以及其他与时间有关的问题。</p>
<p>在编写并发代码时，心跳并不是必需的，但这部分展示了一些它的实际效果。对于任何长时间运行或需要被测试的goroutine，我强烈推荐这种模式。<br>复制请求<br>对于某些应用来说，尽可能快地接收响应是重中之重。例如，程序正在处理用户的HTTP请求，或者检索一个数据块。在这些情况下，你可以进行权衡：你可以将请求分发到多个处理程序（无论是goroutine，进程，还是服务器），其中一个将比其他处理程序返回更快，你可以立即返回结果。缺点是为了维持多个实例的运行，你将不得不消耗更多的资源。<br>如果这种复制是在内存中进行的，消耗则没有那么大，但是如果多个处理程序需要多个进程，服务器甚至是数据中心，那可能会变得相当昂贵。所以你需要决定这么做是否值得。<br>我们来看看如何在单个进程中制造复制请求。我们将使用多个goroutine作为处理程序，并且goroutine将随机休眠一段时间以模拟不同的负载，休眠时间在1到6纳秒之间。这将使我们处理程序在不同的时间返回结果，并且我们可以看到复制请求如何更快的返回结果。<br>下面是一个在10个处理程序上复制模拟请求的例子：<br>dalork :func(</p>
<p>。 在这里，我们启动10个处理程序来处理请求。<br>在这一行获得处理程序组的第一个返回值。<br>在这里，我们取消其余的处理程序。以保证他们不会继续做多余的工作。<br>运行此代码得到下面的结果：</p>
<p>从上面的日志看出，这次是第8个处理程序返回的最快。在输出中我们将显示每个处理程序所花费的时间，以便你可以了解这样处理可以节省多少时间。想象一下，如果你只运行一个处理程序，而恰巧是第5个处理程序，那请求将不得不等待5s才能被处理，而不是刚刚超过1s就能被处理完。<br>有一点需要注意，所有的处理程序都应该是尽可能等价的，有相同的机会处理请求。或者说，你不能从一个无法处理请求的程序那获得最快的响应。就像我说的，每个处理程序都应该有相同的资源<br>同一问题的不通特征是大致相似的。你的处理程序越相似，那出现意外的概率就越小。在增加副本时，你应该尽可能复制：你应该只将这样的请求复制到具有不同运行时条件的处理程序。不同的进程，机器，存储路径以及不同的数据源。<br>虽然建立和维护这样一套系统有很大的代价，但如果你追求的是响应速度，那这是一种非常有价值的架构。另外，这种方式天然地提供了容错和可扩展性。<br>速率限制<br>如果你曾经使用过一个API服务，那么你可能了解过速率限制，它限制了某种资源在某段时间内被访问的次数。资源可以是任何东西：API连接，磁盘读写，网络包，异常。<br>你有没有想过，为什么要在服务中加入速率限制？为什么不允许不受限制地访问系统？通常对系统进行限速，可以避免你的系统被攻击。如果恶意用户可以在资源允许的情况下频繁访问系统，他们可以做各种各样的事情。<br>例如，他们可以使用日志或有效请求来占满服务器的磁盘。如果你错误地配置了日志转发，它们甚至可以在执行一些恶意的操作后发出足够的请求，将所有的恶意操作记录从日志中挤出，转发到/dev/null中。他们可能试图暴</p>
<p>力访问资源，或者他们仅仅是执行分布式拒绝服务攻击（DDoS）。重点是：如果你不对系统进行限速，则无法轻松保护它。<br>可能被恶意利用不是唯一的原因。在分布式系统中，即使是合法用户，如果他们正在以足够大的量级执行操作或者正在运行的代码是异常的，也可能会降低系统的可用性，从而对其他用户的使用造成影响。这甚至可能导致我们之前讨论的死亡螺旋。从产品的角度来看，这非常可怕！通常情况下，你希望向用户提供某种类型的性能保证，这些性能可以保持一致。如果任意一个用户都可以影响这个平衡，那无疑是非常糟糕的。通常情况下用户对系统的访问应当被沙盒化，既不会影响其他用户的活动，也不会受到其他用户的影响。如果你打破了这种思维模式，会使用户感觉你的系统设计不够好，可能会使用户生气或离开。<br>即使只有一个用户，限速也是有利的。很多时候，即使是开发完成的系统，通常在普通用例下运行良好，但是在不同情况下可能开始有不同的表现。在复杂的分布式系统中，这种影响可能通过系统级联放大，产生意想不到的后果。也许在高负载下，你开始丢包，这导致你的分布式数据库无法仲裁，并停止接受写入，继而使你现有的请求失败，以至于..你可以想象一个简单地问题如何演变成一场灾难。在这些情况下，系统对自己进行一种DDoS攻击并不是闻所未闻的！<br>一个真实的案例<br>我曾经使用过一个分布式系统，它通过启动新的进程来并行扩展（这可以使它水平扩展到多台机器）。每个进程会新建一个数据库连接，读一些数据，做一些计算。在当时，我们使用这种方式成功扩大了系统规模，满足了客户的需求。但是，一段时间之后，系统利用率增长到了某个点数据库读取就会超时了。<br>我们的数据库管理员花了很多时间去检查日志，尝试找出异常的原因。最后他们发现，由于系统上没有任何速率限制，进程互相之间产生了拥挤。</p>
<p>由于不同的进程尝试从磁盘的不同部分读取数据，使得磁盘使用率增长到了100%，而且居高不下。这导致了某种恶性循环，系统不断重试，超时。任务无法完成，也无法停止。<br>随后我们设计了一个系统来限制数据库的可连接数，限制每秒可读的连接，问题就消失了。虽然客户的操作不得不等待更长的时间才能完成，但至少操作是可以完成的。之后我们有足够的时间进行适当的容量规划，以一种有机的方式扩大系统的容量。<br>速率限制允许你讲系统的性能和稳定性平衡在可控范围内。如果你需要扩大这些限制，你可以在大量测试和等待后，以可控的方式进行拓展。<br>在你对系统的访问收费的情况下，速率限制可以使你与客户保持良好的关系。你可以让用户在严格受限的速率下试用这个系统。Google在其云服务上通过这种方式获得了巨大的成功。<br>在成为付费用户之后，速率限制甚至可以保护用户。由于大部分时间访问行为是程序化的，因此很容易产生一个失控的bug去访问付费系统。这可能会产生巨额的账单，并使双方处于一个非常尴尬境地：服务提供者是否应该承担这些成本，免除无意义访问的费用，或者是用户被迫支付账单，但这可能会对双方的关系造成不可逆的影响？<br>通常限速是从服务提供者的角度考虑的，不过也可以被用户利用。如果我只是想理解如何使用服务的API，那么将速率限制在一个很小的范围，会使人更有安全感，因为我知道这不会造成什么危害。<br>希望我已经给出了足够的理由来说服你，即使你设定了你认为永远不会达到的限制，限制率也是好的。他们很容易创建，他们解决了很多问题，很难合理解释为什么不使用它们。<br>那我们怎么在Go语言中进行限速呢？</p>
<p>大多数的限速是基于令牌桶算法的。这很容易理解，而且相对容易实现。我们来看看它背后的理论。<br>如果要访问资源，你必须拥有资源的访问令牌，没有令牌的请求会被拒绝。现在假设这些令牌存储在一个等待被检索使用的桶中。桶的深度为d，表示一个桶可以容纳d个访问令牌。例如，存储桶深度为五，则可以存放五个令牌。<br>每当你需要访问资源时，都会在桶中删除一个令牌。如果你的存储桶包含五个令牌，前五次访问没有问题，操作正常进行，但是在第六次尝试时，就没有访问令牌可用。你的请求必须排队等待，直到令牌可用，或者被拒绝操作。<br>下面是一个时间表，使用这种可视化的方式，可以帮助你理解。time表示以秒为单位的时间增量，bucket表示桶中请求令牌的数量，request列中的 tok表示成功请求（在下面所有的时间表中，我们会假设这些请求是瞬时的，以简化描述）。<br>time<br>0<br>O<br>0<br>O<br>0<br>0<br>bucket 5<br>4<br>3<br>2<br>1<br>0<br>0<br>Request<br>tok<br>tok<br>tok<br>tok<br>tok<br>正如表中所示，第一秒前发出的所有请求都成功响应，之后因为没有可用的令牌，请求被阻塞住。</p>
<p>到目前为止，这还是很容易理解的。那如何补充令牌，我们总是能获得一个新的吗？在令牌桶算法中，我们将r定义为向桶中添加令牌的速率。它可以是一纳秒或一分钟。这就是我们通常认为的速率限制：因为我们必须等到新的令牌可用，我们将操作速度限制在这个频率下。<br>下面这个示例中，令牌桶深度为1，速率为1令牌/秒：<br>time<br>0<br>0<br>1<br>2<br>2<br>3<br>4<br>4<br>bucket 1<br>O<br>0<br>1<br>0<br>0<br>1<br>0<br>Request<br>tok<br>tok<br>tok<br>你可以看到我们的请求立刻就有响应，但是我们的请求被限制在每隔一秒一次。我们的限速代码工作的很正常！<br>现在我们有两个设置项可以修改：有多少个令牌可以立即使用d，桶的深度，以及它们补充的速度r。在这两者之间，我们可以平衡突发性和限制整体速率。突发性指的是当存储桶已满时可以进行多少次请求。<br>下面的示例中，令牌桶深度为5，速率为0.5令牌/秒：</p>
<p>在这个示例中，我们能够立刻完成5个请求，在这之后，我们每两秒只能完成一个请求。最密集的请求发生在最开始的时候。<br>请注意，用户可能不会在短时间内消耗掉整个令牌桶的令牌。桶的深度只能控制桶的容量。下面示例中用户先集中发出了两个请求，然后四秒钟之后集中发出5个请求：</p>
<p>只要用户拥有可用的令牌，集中的请求可能会使用户突破系统的可用范围。有些用户会间歇性访问系统，但是又想要尽可能快的获得结果，就会出现突发性的事件。你只需要确保你的系统能够同时处理所有用户的突发请求，或者在统计上不会有太多的用户同时进行突发的访问。无论采取哪种方式，速率限制都可以使你控制住潜在的风险。<br>让我们来实现一下这个算法，看看在Go语言程序中加入令牌桶算法时会存在那些问题。<br>让我们假设这有一个可访问的API，然后提供一个Go语言客户端来调用它。该API有两个接口：一个用于读取文件，另一个用于将域名解析为IP地址。为了简单起见，我们将忽略所有参数并返回实际访问服务所需的值。下面是我们的客户端代码：<br>func Open()<em>APIConnection {<br>return &amp;APIConnection{}<br>了<br>type APIConnection struct {}<br>func (a </em>APIConnection) ReadFile(ctx context.context) error { //假装我们在这里运行<br>return nil<br>}<br>func (a *APIConnection) ResolveAddress(ctx context.context) error { //假装我们在这里运行<br>return nil<br>}<br>理论上讲我们的请求是经过网络的，所以我们将context.context作为第一个参数，以便我们需要取消请求或者将值传递给服务器。非常标准的一段代码。<br>现在我们将创建一个简单的驱动程序来访问这些API。这个程序需要读取10个文件并解析成10个地址，但文件和地址之间没有直接关系，所以驱动程序需要调用那些API，其中会有一些相互的并发调用。后面我们可以用这个压测APIClient，对我们的限速做一个测试。</p>
<p>我们可以看到，所有的API请求几乎是同时进行的。我们没有进行限速，所以我们的客户端可以自由访问系统。现在我要告诉你一个不幸的消息，我们的驱动程序中可能存在一个可能导致无限循环的bug。如果没有限速，那一会送账单的快递就要敲门了。<br>下面我们引入一个限速器。我打算把限速放在APIConnection中，但通常限速器会在服务器上运行，这可以防止用户轻易的绕过它。在生产中，客户端也会有限速，以免用户被不必要的拒绝信息千扰，不过这只是锦上添花。不过就我们的目的而言，将限速放在客户端的可以使整个过程变得更简单。<br>我们将分析一个实例，它使用了golang.org/x/time/rate包中的令牌桶限速器实现。我使用这个包是因为它跟我能得到的标准库差不多。当然还有一些其他的软件包，它们可以实现相同的功能，而且有更多在生产中都有意义的功能。而golang.org/x/time/rate包很简单，足够我们现在使用。<br>首先我们会使用这个软件包中两个部分，分别是Limit类型和Newlimiter函数，在这里定义：</p>
<p>Every函数是有意义的，但是我更想针对每次操作的间隔时间进行测量，而不是请求的间隔长度。我们可以这样写：<br>rate.Limit(events/timePeriod.Seconds())<br>但是我不想每次都手动输人，而且如果时间间隔为零Every函数会进行一些特殊的处理，将返回rate.Inf，表示没有限制。所以我们将用Every函数包装我们的逻辑：<br>func Per(eventCount int, duration time.Duration) rate.Limit { return rate.Every(duration/time.Duration(eventCount)) ]<br>在创建rate.limiter之后，我们将使用它来阻塞我们的请求，直到获得访问令牌。我们可以用Wait方法来做到这一点，它只是调用了一下WaitN，并将参数设为1：<br>// Wait是WaitN（ctx，1）的缩写<br>func (lim <em>Limiter) Wait(ctxcontext.context)<br>//WaitN会执行直到有n个事件发生<br>//如果n超过Limiter的突发大小，context被取消，或者预期等待时间超过<br>//context的deadline，它会返回一个错误<br>func (lim </em>Limiter) WaitN(ctx context.context, n int) (err error)<br>现在我们应该拥有了限制API调用速率所有应有的要素。让我们修改一下APIConnection，然后测试一下！</p>
<p>0在这里，我们将所有API连接的速率限制设置为每秒一次。 我们等待限速器有足够的令牌来完成我们的请求。<br>运行此代码得到下面的结果：</p>
<p>你可以看到，在我们同时处理所有的API请求之前，已经完成了一次操作。看起来我们的限速器已经在正常工作了！<br>非商业用途或交流学习使用<br>大规模并发|209<br>严禁网络传播本PDF，违者责任<br>这就有了一个非常基本的限速，但在生产中，我们可能会想要一些更完备的东西。我们可能会想要建立多层次的限制：用细粒度的控制来限制每秒的请求用粗粒度的控制来限制每分钟、每小时或每天的请求。<br>在某些情况下，可以用单一的限速器来做到这一点。然而并不能适应所有情况，而且试图从语义上将单位时间的限制转换为单一层次的限制，过程中会丢失大量信息。由于这些原因，我发现把不同粒度的限速器独立，然后将它们组合成一个限速器组来管理你的调用会更容易一些。为此，我创建了一个简单的聚合限速器multilimiter。定义如下：</p>
<p>0在这里我们定义了一个Ratelimiter接口，使Multilimiter可以递归地定义其他的Multilimiter实例。<br>210|第5章供非商业用途或交流学习使用<br>严禁网络传播本PDF，违者责任自负！<br>2这里我们实现一个优化，并根据每个Ratelimiter的Limit（）进行排序。因为我们在multilimiter实例化时对子Ratelimiter实例进行了排序，所以我们可以直接返回限制最多的限制器，这将是切片（slice）中的第一个元素。<br>Wait方法会遍历所有的子限速器，并调用Wait。这些调用可能会阻塞也可能不会阻塞，但无论如何我们都需要通知每个限速器，所以我们可以设法减少一些令牌桶。通过在为所有限速器设置统一的阻塞可以做到这一点，我们需要确保阻塞的时间是可能阻塞的最长时间。这时因为，如果我们阻塞的时间是最长等待时间的子集，那再碰到那个最长的Wait时，还要重新计算剩余时间。而又因为，在前面的Wait处进行阻塞，后面的Wait会持续填充令牌桶，所以任何Wait在第一次阻塞过后一定会被立即返回。<br>现在我们有了可以进行多重限速的限速方法，让我们借此机会增加一些细节。我们将重新定义我们的APIConnection加上每秒钟和每分钟的限制：</p>
<p>在这里，我们定义每秒钟的限制，避免突发请求。<br>在这里，我们定义每分钟的限制，为用户提供初始池。每秒的限制将确保我们的系统不会因突发请求而超载。<br>6然后我们组合这两个限制，并将其设置为APIConnection的主限速器。<br>运行此代码得到下面的结果：<br>22:46:10 ResolveAddress 22:46:10ReadFile<br>22:46:11ReadFile 22:46:11ReadFile 22:46:12ReadFile 22:46:12 ReadFile 22:46:13 ReadFile 22:46:13ReadFile 22:46:14 ReadFile 22:46:14ReadFile<br>22:46:16ResolveAddress 22:46:22 ResolveAddress 22:46:28 ReadFile<br>22:46:34 ResolveAddress 22:46:40 ResolveAddress 22:46:46ResolveAddress 22:46:52ResolveAddress 22:46:58 ResolveAddress 22:47:04 ResolveAddress 22:47:10 ResolveAddress 22:47:10Done.<br>从日志中我们可以看到，客户端每秒发出两个请求，直到第11个请求，我们开始每6秒钟发出一次请求。这是因为我们耗尽了分钟级限速器的可用令牌，所以限制了请求速度。<br>为什么第11个请求只延时了2秒，而不是像之后的请求那样隔了6秒，这可能有点违反直觉。原因是这样的，虽然我们将API请求限制为10次1分钟，但是在一分钟内令牌增加是一个递增的过程。当我们第11个请求到达是，我们的分钟级限速器已经积累了一个令牌。</p>
<p>通过定义这样的限制，我们可以清晰的表达粗粒度限制，同时仍然可以进行精细化控制。<br>这项技术也使我们开始考虑除时间以外的维度。当你对一个系统做限制的时候，你可能不只限制一个维度的东西。你可能对API请求的数量有一些限制，同时也可能对其他资源（如磁盘访问，网络访问等）有限制。让我们稍微扩展一下我们的例子，增加磁盘和网络的限制：</p>
<p>在这里，我们为API调用设置了一个限速器。每秒请求数和每分钟请求数都有限制。<br>在这里，我们为磁盘读取设置一个限速器。我们将其限制为每秒只能读取一次。<br>对于网络，我们设置了每秒三个请求的限制。<br>当我们读取文件时，我们融合API限速器和磁盘限速器的限制。<br>当我们需要网络访问时，我们融合API限速器和网络限速器的限制。<br>运行此代码得到下面的结果：<br>01:40:15 ResolveAddress 01:40:15ReadFile<br>01:40:16ReadFile<br>01:40:17 ResolveAddress 01:40:17 ResolveAddress 01:40:17ReadFile<br>01:40:18 ResolveAddress 01:40:18 ResolveAddress 01:40:19 ResolveAddress 01:40:19ResolveAddress 01:40:21ResolveAddress 01:40:27ResolveAddress 01:40:33 ResolveAddress 01:40:39ReadFile<br>01:40:45 ReadFile 01:40:51ReadFile 01:40:57 ReadFile 01:41:03 ReadFile 01:41:09 ReadFile 01:41:15 ReadFile 01:41:15Done.<br>我可以在这里画一个时间表来解释每次调用都会发生在哪里，但是这会掩盖真正有意义的东西。相反，我们把重点放在这样一个事情上，即我们能够将逻辑限速器组合成对每个调用都有意义的限制组，并且保证APIClient正常工作。如果我们观察一下它是如何工作的，我们会注意到涉及网络访问的 API调用看起来更加规律了，大部分操作在前三分之二的调用中就完成了。 这可能和goroutine的调度相关，但更有可能是我们的限速器在起作用！</p>
<p>还有一点，rate.Limiter类型有一些特殊的技巧来进行优化或处理其他用例。我只描述了它的一部分功能，就是阻塞请求直到令牌桶生成一个新的令牌。但如果你只是想使用一下它，那只需要知道它还有其他一些功能即可。<br>在本节中，我们已经研究了使用速率限制的原因，并实现了一个令牌桶算法，以及研究了如何将令牌桶限速器组合成更大、更复杂的限速器。这应该会让你对速率限制有一个充分的了解，并有助于你在生产中使用它们。<br>治愈异常的goroutine<br>在长期运行的后台程序中，经常会有一些长时间运行的goroutine。这些goroutine经常处于阻塞状态，等待数据以某种方式到达，然后唤醒它们，进行一些处理，再返回一些数据。有时候，这些goroutine依赖于一些控制不太好的资源。也许一个goroutine需要从接收到的请求中提取数据，或者它正在监听一个临时文件。问题在于，如果没有外部千预，一个goroutine很容易进人一个不正常的状态，并且无法恢复。抛开这些担忧，你甚至可以说，goroutine本身不应该关心其如何从一个异常状态回复过来。在一个长期运行的程序中，建立一个机制来监控你的goroutine是否处于健康的状态是很用的，当他们变得异常时，就可以尽快重启。我们将这个重启goroutine的过程称为“治愈”（Healing）注2。<br>为了治愈goroutine，我们需要使用心跳模式来检查我们正在监控的goroutine是否活跃。心跳的类型取决于你想要监控的内容，但是如果你的goroutine有可能会产生活锁，确保心跳包含某些信息，表明该gouroutine在正常的工作而不仅仅是活着。在本节中，为了简单起见，我们只会考虑goroutine是否活着。<br>我们把监控goroutine的健康这段逻辑称为管理员，它监视一个管理区的goroutine。如果有goroutine变得不健康，管理员将负责重新启动这个管理区</p>
<p>的goroutine。为此，需要引用一个可以启动goroutine的函数。让我们看看一个管理员应该是什么样的：</p>
<p>在这里，我们定义一个可以监控和重启的goroutine的信号。我们看到了熟悉的channel，以及来自心跳模式的pulseInterval和heartbeat.在这一行，我们看到一个管理员监控goroutine需要的timeout变量，还有一个函数startGoroutine来启动它监控的goroutine。有趣的是，管理员本身会返回一个startGoroutineFn，表示管理员本身也是可监控的。在这里，我们定义一个闭包，它实现了一个统一的方法来启动我们正在监视的goroutine.<br>这是我们创建的一个新的channel，如果我们需要发出一个停止的信号，就会通过它传入goroutine中。<br>在这里，我们启动将要监控的goroutine。如果管理员被停止了，或者管理员想要停止goroutine，我们希望这些信息都能传递给管理区里的goroutine，所以我们把两个done channel用逻辑或包装了一下。我们设定心跳间隔时间是超时时间的一半，我们在本章前面“心跳”中讨论过，这里只是提一下。<br>日这是我们的内部循环，它确保管理员可以发出自己的心跳。<br>O在这里，如果我们收到goroutine的心跳，将继续执行监控的循环。<br>6这一行表示，如果我们在暂停期间没有收到管理区里goroutine的心跳，<br>我们会要求管理区里的goroutine停下来，并启动一个新的goroutine。然后我们继续监控。<br>我们的for循环有点多，但只要你熟悉其中涉及的模式，阅读起来还是相</p>
<p>对简单的。让我们对管理员进行一个测试。如果我们监控一个的行为异常的goroutine会发生什么？让我们来看看：<br>log.Setoutput(os.stdout)<br>log.SetFlags(log.ltimei log.Lurc)<br>dowork :- func(done &lt;-chan interface{}, _ time.Duration) &lt;-chan interface{} { log.Println(“ward: Hello, I’m irresponsible!”)<br>go func(){<br>&lt;-done 0<br>log Println(“ward:I am halting.”)<br>}()<br>return nil<br>doWorkWithSteward :- newSteward(4<em>time.second, dowork)@<br>done := make(chan interface{})<br>time.AfterFunc(9</em>time.Second, func(){0<br>log.Println(“main: halting steward and ward.”)<br>close(done)<br>})<br>for range doworkWithsteward(done, 4*time.second){}0<br>log.Println(“Done”)<br>在这里，我们看到这个goroutine没有做任何事情，只是等待被取消。它也没有发出任何心跳。<br>这一行创建了一个函数，为goroutine dowork创建一个管理员。我们设置doWork的超时时间为4秒钟。<br>在这里，我们设置9秒钟之后停止管理员和goroutine，这样我们的测试就会结束。<br>最后，我们启动管理员并在其心跳范围内防止我们的测试停止。<br>这个示例产生以下输出：</p>
<p>它看起来运行得很好！不过我们的管理区有些简单：除了取消和心跳所需要的东西之外，它不接收任何参数，也不返回任何参数。我们怎样才能创造一个可以与管理员配合使用的管理区呢？我们每次都可以改写或者生成一个管理员来适应我们的管理区，但是这样做既麻烦又不必要，相反，我们可以使用闭包。让我们来看一个管理区的例子，它根据离散值列表生成一个整数流：</p>
<p>0在这里，我们填入一些我们管理区所需的参数，并返回我们管理区用来通信的channel。<br>这一行创建了作为桥接模式一部分的channel。<br>在这里，我们创建一个将被管理员启动和监控的闭包。<br>这是我们实例化channel的地方，我们将利用这些channel与管理区中的goroutine通信。<br>在这里，我们把我们即将用来通信的channel通知给bridge。<br>当我们处理到负数时，在这一行打印出一个错误信息，然后从goroutine中返回。<br>你可以看到，由于我们可能会启动多个管理区的副本，所以我们利用bridge-channel（请参阅第4章“桥接channel模式”）向doWork的消费者提供一个共用的channel，避免中断。使用这些技术，我们的管理区可以简单地通过组合各种模式变得任意复杂。让我们看个例子：</p>
<p>0这一行，我们创建管理区的函数，允许它结束我们的可变整数切片，并返回一个用来返回的流。<br>在这里，我们创建一个管理员，用来监听dowork闭包。因为我们希望能尽快知道失败的信息，所以我们将监听时间间隔设置为一毫秒。<br>目在这里，我们通知管理员启动管理区并开始监控。<br>0最后，使用我们开发的一段管道代码，从intstream中取出前六个值。<br>运行此代码得到下面的结果：<br>Received: 1<br>23:25:33 negative value:-1<br>Received:2<br>23:25:33 steward: ward unhealthy; restarting Received:1<br>23:25:33 negative value:-1<br>Received:2<br>23:25:33 steward: ward unhealthy; restarting Received:1<br>23:25:33 negative value:-1<br>Received:2<br>根据收到的值，我们可以看到管理区内的异常状态，我们的管理员会检查管理区，重启管理区。你可能也注意到了，我们只能接收到1和2这两个值，这是我们管理区重新初始化的表现。当你开发自己的管理区时，如果你的系统对重复值比较敏感，一定要重视这一点。你还可以考虑在管理员中加入一段逻辑，在失败几次后退出。在这种情况下，我们可以简单地通过更新我们在每次迭代中关闭的intlist，来使得我们的生成器有状态。而在此之前：<br>valueloop:<br>for … ，intVal :=range intlist { }<br>我们可以这样写：</p>
<p>这将会在管理区重启时节省一些空间，虽然我们会始终停留在无效的负数上，我们的管理区将会一直处于失败状态。<br>使用这种模式可以使长期运行着的goroutine保持健康状态。<br>小结<br>在本章中，我们介绍了一些方法来保持系统的稳定和易于理解，因为这些系统所处理的问题领域需要更大的系统，甚至是分布式的。本章还演示了Go语言的并发原语如何创建更高层次的抽象程序。如果在语言设计上没有对并发提供额外的优势，这些模式可能会更笨重，也更不健壮。<br>在最后一章中，我们将探索Go语言的一些运行时的内部结构，以帮助你深入理解它的工作方式。我们还将探索一些有用的工具，使开发和调试Go语言程序更容易一些。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言并发之道/" rel="tag"># Go语言并发之道</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/09/第4章-Go语言的并发模式/" rel="next" title="第4章 Go语言的并发模式">
                <i class="fa fa-chevron-left"></i> 第4章 Go语言的并发模式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/09/第6章-Goroutine和Go语言运行时/" rel="prev" title="第6章 Goroutine和Go语言运行时">
                第6章 Goroutine和Go语言运行时 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1095</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">77</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/04/11-FAQ/" title="11-FAQ" target="_blank">11-FAQ</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/04/10-beego实用库/" title="10-beego实用库" target="_blank">10-beego实用库</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/04/9-应用例子/" title="9-应用例子" target="_blank">9-应用例子</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/04/8-beego第三方库/" title="8-beego第三方库" target="_blank">8-beego第三方库</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/04/7-应用部署/" title="7-应用部署" target="_blank">7-应用部署</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.4m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">126:34</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
