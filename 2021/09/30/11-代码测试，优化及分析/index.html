<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Mastering Go">
<meta property="og:type" content="article">
<meta property="og:title" content="11-代码测试，优化及分析">
<meta property="og:url" content="http://yoursite.com/2021/09/30/11-代码测试，优化及分析/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-2.1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-2.2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-3.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-4.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-5.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-6.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/imagess/chapter11/11.5.3-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/imagess/chapter11/11.5.3-2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.1-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.1-2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.6-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.6-2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.6-3.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.7.1-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.7.1-2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.7.1-3.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.8.1-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.8.1-2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.9-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.9-2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-1.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-2.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-3.jpg">
<meta property="og:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-4.jpg">
<meta property="og:updated_time" content="2022-05-27T06:26:27.436Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="11-代码测试，优化及分析">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="twitter:image" content="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.2.jpg">






  <link rel="canonical" href="http://yoursite.com/2021/09/30/11-代码测试，优化及分析/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>11-代码测试，优化及分析 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/30/11-代码测试，优化及分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="强迫自己去看，去做。">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">11-代码测试，优化及分析

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-30 13:42:14" itemprop="dateCreated datePublished" datetime="2021-09-30T13:42:14+08:00">2021-09-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-05-27 14:26:27" itemprop="dateModified" datetime="2022-05-27T14:26:27+08:00">2022-05-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">34k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">31 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<h1 id="代码测试，优化以及分析"><a href="#代码测试，优化以及分析" class="headerlink" title="代码测试，优化以及分析"></a><strong>代码测试，优化以及分析</strong></h1><p>上一章讨论了 Go 中的并发，和 <code>select</code> 语句允许您使用 channels 来控制 goroutines 并允许 goroutines 进行通信。</p>
<p>本章 Go 主题只是稍微高级点，而他们确非常实用和重要，特别是当您对改善您的 Go 程序性能感兴趣和快速发现 bug 时。这章主要解决代码优化，代码测试，代码文档化以及代码分析。</p>
<p><strong>代码优化</strong> 是开发人员试图使程序的某些部分运行的更快，更有效率，或实用较少的资源的过程。简单说，代码优化是消除一个程序的瓶颈。</p>
<p><strong>代码测试</strong> 是确保您的代码按照您设想的执行。这章，您将经历 Go 测试代码方式。写代码测试您的程序的最佳时期是开发阶段，因为这可以帮您尽早的发现 bug。</p>
<p><strong>代码分析</strong> 是为了获取代码运行方式的详细理解测量一个程序的某些方面。代码分析的结果可以帮助您决定您的代码哪些部分需要修改。</p>
<p>我希望您已经认识到您的代码文档化的重要性，以便描述您在开发您的程序的实现过程中所做的决策。这章，您将看到 Go 怎样帮您把您实现的模块生成文档。</p>
<blockquote>
<p><em>文档是非常重要的，以至一些开发者会先写文档再写代码</em></p>
</blockquote>
<p>这章，您将了解如下主题：</p>
<ul>
<li>分析 Go 代码</li>
<li><code>go tool pprof</code> 工具</li>
<li>使用 Go 分析器的 web 界面</li>
<li>测试 Go 代码</li>
<li><code>go test</code> 命令</li>
<li><code>go tool trace</code> 工具</li>
<li>基准化分析 Go 代码</li>
<li>跨平台编译</li>
<li>给您的 Go 代码生成文档</li>
<li>创建例子函数</li>
<li>在您的程序中找出不可到达的 Go 代码</li>
</ul>
<h1 id="本章使用的Go版本"><a href="#本章使用的Go版本" class="headerlink" title="本章使用的Go版本"></a><strong>本章使用的Go版本</strong></h1><p>注意这章，我们将在 macOS 机器上使用最新的 Go 版本。编辑本书时，Go 版本是 1.10：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> date</span></span><br><span class="line">Fri Mar 9 23:17:49 EET 2018</span><br><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br><span class="line">go version go1.10 darwin/amd64</span><br></pre></td></tr></table></figure>
<p>我提及您至少需要 Go 版本是 1.10 的原因是为了能使用 Go 代码分析器的 web 界面。然而，其余介绍的命令和代码与早期的 Go 版本仍能正常工作。</p>
<h1 id="1-10和1-9的版本对比"><a href="#1-10和1-9的版本对比" class="headerlink" title="1.10和1.9的版本对比"></a><strong>1.10和1.9的版本对比</strong></h1><p>这章将列举 1.9 和 1.10 版本之间非常重要的不同点，只是让您了解 Go 变更的节奏。</p>
<p>1.10 版本的一些改变如下：</p>
<ul>
<li><code>GOROOT</code> 和 <code>GOTMPDIR</code> 环境变量的定义方式有所变化。</li>
<li><code>go test</code> 命令缓存测试结果，意味着它会运行的快点。</li>
<li><code>go doc</code> 工具现在包含了当您告诉 <code>go doc</code> 显示数据关于返回一个类型的切片或指向一个类型指针的函数输出。</li>
<li>您将在本章稍后看到 <code>runtime/pprof</code> 包现在包含有关阻塞和互斥配置文件的符号信息。</li>
<li><code>go fix</code> 工具替换 <code>golang.org/x/net/context</code> 的 <code>import</code> 声明为 <code>context</code>。</li>
<li><code>go tool proff</code> 包含一个 web 界面。虽然这是一个重大的变化，但它与 Go 编程语言本身无关，因此不会破坏任何现有的 Go 代码。您将在本章稍后看到 web 界面的实际应用。</li>
<li>Go 1.10 版本对一些标准包做了微小改动，包括 <code>archive/tar</code> 和 <code>archive/zip</code>，<code>debug/macho</code>，<code>hash</code>，<code>html/template</code>，<code>match/big</code>，<code>net/url</code>，<code>os</code>，<code>time</code>，<code>unicode</code> 和 <code>net/smtp</code>。</li>
</ul>
<p>如您认识到的，Go 编程语言的发展没有破坏任何东西。起初这可能看起来无关紧要，但它是 Go 的一个非常重要的特性，它保证了现有的 Go 代码将在 Go 的发展过程中不做任何修改仍能继续编译。这样的一个副作用是这本书将涉及多年的知识点。</p>
<h1 id="安装beta或者RC版本"><a href="#安装beta或者RC版本" class="headerlink" title="安装beta或者RC版本"></a><strong>安装beta或者RC版本</strong></h1><p>如果您热衷于尝试 Go 的最新版本，即使这意味着您需要安装一个测试版或<strong>候选版本</strong>（RC），有一个办法！</p>
<blockquote>
<p><em>尽管他们的命名（候选版）是相当稳定。但不要在没有很恰当理由的情况下安装一个 RC 版在生产级 Uninx 机器上！</em></p>
</blockquote>
<p>如果您的 Go 版本比 1.10 早，并想要尝试 1.10 RC1 版本，您可以按如下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get golang.org/x/build/version/go1.10rc1</span></span><br></pre></td></tr></table></figure>
<p>如果您想安装不同的版本，您应该期望执行一个类似的命令。在 macOs High Sierra 系统上运行发布版 10.13.3，这个新的 Go 执行文件将被安装在 <code>~/go/bin</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/go/bin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">-rwxr-xr-x 1 mtsouk staff 6051164 Jan 30 19:04 go1.10rc1</span><br></pre></td></tr></table></figure>
<p>如果您尝试执行 <code>go1.10rc1</code>，您将得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./go1.10rc1</span></span><br><span class="line">go1.10rc1: not downloaded. Run 'go1.10rc1 download' to install to /Users/mtsouk/sdk/go1.10rc1</span><br></pre></td></tr></table></figure>
<p>接下来您必须执行 1.10 RC1 的其余文件如下：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.2.jpg" alt></p>
<p>您现在可以使用 <code>go1.10rc1</code> 运行 1.10 RC1 版本了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/go/bin/go1.10rc1 version</span></span><br><span class="line">go version go1.10rc1 darwin/amd64</span><br></pre></td></tr></table></figure>
<h1 id="关于优化"><a href="#关于优化" class="headerlink" title="关于优化"></a><strong>关于优化</strong></h1><p>代码优化是艺术和科学的结合！这意味着没有确定的方法来帮助您优化您的 Go 代码或任何其他编程语言代码，并且如果您想使您的代码运行的更快，您应该多动脑尝试多种方法。</p>
<blockquote>
<p><em>您应该确保您优化的代码没有任何 bug，因为优化 bug 没有意义。如果您的程序有任何 bug ，您应该先 debug！</em></p>
</blockquote>
<p>如果您真的投入代码优化，您可能想读一下由 <em>Alfred V.Aho, Monica S.Lam, Ravi Sethi 和 Jeffrey D.Ullman 编写, Pearson Education Limited, 2014 出版的编译器：原理，技术和工具</em>一书，它侧重于编译器构造。另外，由 <em>Donald Knuth, Addison-Wesley 教授, 1998 写的计算机编程艺术</em>系列全书对于编程的方方面面是非常棒的资源。</p>
<p>要一直记着 <em>Donald Knuth</em> 关于优化的建议：</p>
<blockquote>
<p><em>真正的问题是程序员花费太多时间来担心效率在错误的地方和时间；过早优化是编程的万恶之源（至少是大部分）</em></p>
</blockquote>
<h1 id="优化你的Go代码"><a href="#优化你的Go代码" class="headerlink" title="优化你的Go代码"></a><strong>优化你的Go代码</strong></h1><p>代码优化是这样的一个过程，试图找出代码中对整个程序性能有重大影响的部分，以使它们运行的更快或使用更少的资源。</p>
<p>本章后面出现的基准测试部分将极大地帮助您了解代码运行背后的情况，以及哪些程序参数对程序性能的影响最大。</p>
<p>然而，不要低估正常情形。简单说，如果您的程序中的某个函数比其他函数多执行了一万次，那就先试着优化这个函数。</p>
<blockquote>
<p><em>对于优化通常的建议是您必须优化没有 bug 的代码。意思是您必须优化可运行的代码。因此，您应该首先把代码写正确即便它运行的慢。最后，程序员最常犯的一个错误是试图优化代码的第一个版本，这是大多 bug 的根源</em></p>
</blockquote>
<p>再次，代码优化是艺术和科学的结合，这意味着这是相当困难的任务。下节关于分析 Go 代码将绝对能帮助您进行代码优化，因为分析的主要目的是找到代码的瓶颈，以便优化程序中正确的和最重要的部分。</p>
<h1 id="分析Go代码"><a href="#分析Go代码" class="headerlink" title="分析Go代码"></a><em>分析Go代码</em></h1><p>分析是一个动态程序分析的过程，用于衡量与程序执行相关的各种值，以便您更好地了解程序的行为。在这节，您将了解怎样分析 Go 代码，以便更好的理解代码并改善它的性能。有时，代码分析甚至能发现 bug！</p>
<p>首先，我们使用 Go 分析器的命令行界面。接下来，我们 Go 分析器的全新 web 界面！</p>
<p>你要分析 Go 代码，最重要的一点要记住的是，需要直接或间接的引入 <code>runtime/pprof</code> 标准库。 您可以通过执行 <code>go tool pprof --help</code> 命令，这个命令将产生需要输出，从中找到 <code>pprof</code> 工具的帮助文档。</p>
<h1 id="标准库net-http-pprof"><a href="#标准库net-http-pprof" class="headerlink" title="标准库net/http/pprof"></a><em>标准库net/http/pprof</em></h1><p>虽然 Go 附带了低级别的 <code>runtime/pprof</code> 标准包，但也有一个高级的 <code>net/http/pprof</code> 包，当您想要分析一个 Go 写的 web 应用时应该使用它。 由于本章不讨论用 Go 创建 HTTP 服务器，所以您将在<a href="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/eBook/chapter12/12.0.md" target="_blank" rel="noopener">第12章</a>（Go网络编程基础）进一步了解 <code>net/http/pprof</code> 包。</p>
<h1 id="代码分析示例"><a href="#代码分析示例" class="headerlink" title="代码分析示例"></a><em>代码分析示例</em></h1><p>Go 支持 <code>CPU 分析</code> 和 <code>内存 分析</code> 两种分析方式。不推荐同时对一个应用做俩种类型的分析，因为这俩种不同的分析方式不能相互工作的很好。然而，<code>profileMe.go</code> 应用是一个例外，因为它被用来说明这个两种技术。</p>
<p>用于分析的 Go 代码保存再 <code>profileMe.go</code>，并分为五部分来介绍。<code>profileMe.go</code> 的第一部分 Go 代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"runtime/pprof"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibo1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int64</span>(n)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int64</span>(fibo2(n<span class="number">-1</span>)) + <span class="keyword">int64</span>(fibo2(n<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意给您的程序创建分析数据必须直接或间接引入 <code>runtime/pprof</code> 包。在 <code>fibo1()</code> 函数调用 <code>time.Sleep()</code> 是为了使它慢一点。在这节尾声您将明白为什么。</p>
<p><code>profileMe.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibo2</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fn := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> f <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= <span class="number">2</span> &#123;</span><br><span class="line">            f = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = fn[i<span class="number">-1</span>] + fn[i<span class="number">-2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        fn[i] = f</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> fn[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码包含另个 Go  函数的实现，使用另一个算法计算斐波那契数列。</p>
<p><code>profileMe.go</code> 的第三部分代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">N1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    k := math.Floor(<span class="keyword">float64</span>(n/<span class="number">2</span> + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="keyword">int</span>(k); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">N2</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span> ; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>N1()</code> 和 <code>N2()</code> 函数都是用来找出给定整数是否是素数。第一个函数已被优化，因为它的 <code>for</code> 循环迭代大约超过第二个函数的 <code>for</code> 循环使用的数字的一半。因为它们运行的都相当慢，所以没必要在此调用 <code>time.Sleep()</code>。</p>
<p><code>profileMe.go</code> 的第四部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cpuFile, err := os.Create(<span class="string">"/tmp/cpuProfile.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    pprof.StartCPUProfile(cpuFile)</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">        n := N1(i)</span><br><span class="line">        <span class="keyword">if</span> n &#123;</span><br><span class="line">            total = total + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Total primes:"</span>, total)</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">        n := N2(i)</span><br><span class="line">        <span class="keyword">if</span> n &#123;</span><br><span class="line">            total = total + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Total primes:"</span>, total)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">90</span>; i++ &#123;</span><br><span class="line">        n := fibo1(i)</span><br><span class="line">        fmt.Println(n, <span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">90</span>; i++ &#123;</span><br><span class="line">        n := fibo2(i)</span><br><span class="line">        fmt.Println(n, <span class="string">" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    runtime.GC()</span><br></pre></td></tr></table></figure>
<p>调用 <code>os.Create()</code> 创建一个文件用于写分析数据。调用 <code>pprof.StartCPUProfile()</code> 开始程序的 <strong>CPU 分析</strong>，然后调用 <code>ppprof.StopCPUProfile()</code> 停止。</p>
<p><code>profileMe.go</code> 的最后部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Memory profiling!</span></span><br><span class="line">    memory, err := os.Create(<span class="string">"/tmp/memoryProfile.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> memory.Close()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">50000000</span>)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Operation failed!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">    err = pprof.WriteHeapProfile(memory)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这部分，您可以看到 <strong>内存分析</strong> 技术是如何工作的。它与 CPU 分析很相似， 您再次需要一个文件来写分析数据。</p>
<p>执行 <code>profileMe.go</code> 将产生如下输出：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-1.jpg" alt></p>
<p>除了输出外，程序也搜集分析数据到俩个文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l *Profile*</span></span><br><span class="line">-rw-r--r-- 1 mtsouk wheel 1965 Mar 8 16:53 cpuProfile.out</span><br><span class="line">-rw-r--r-- 1 mtsouk wheel 484 Mar 8 16:53 memoryProfile.out</span><br></pre></td></tr></table></figure>
<p>只有在收集了分析数据后，您才能开始检查它。</p>
<p>因此，您现在可以启动命令行分析器来检查 CPU 数据，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool pprof /tmp/cpuProfile.out</span></span><br><span class="line">Main binary filename not availabe.</span><br><span class="line">Type: cpu</span><br><span class="line">Time: Mar 8, 2018 at 4:53pm (EET)</span><br><span class="line">Duration: 19.12s, Total samples = 4.18s (21.86%)</span><br><span class="line">Entering interactive mode (type "help" for commands, "o" for options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>
<p>在分析器 shell 中输入 <code>help</code> 将产生如下输出：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-2.1.jpg" alt><br><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-2.2.jpg" alt></p>
<p><code>top</code> 命令以文本形式返回前10个条目:</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-3.jpg" alt></p>
<p>输出的第一行，显示函数占程序总执行时间的 98.56%。 <code>main.N2</code> 函数显著的占程序执行时间的 46.65%。</p>
<p><code>top10 --cum</code> 命令返回每个函数执行的累计时间：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-4.jpg" alt></p>
<p>如果您想找出一个特定函数到底发生了什么的话，您可以使用 <code>list</code> 命令，后跟函数名（和包名组合），您将获得该函数执行的更多详细信息：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-5.jpg" alt></p>
<p>这个输出显示了 <code>main.N1</code> 的 <code>for</code> 循环几乎占用了整个函数的执行时间。特别是 <code>if (n % i) == 0</code> 表达式占了整个函数执行时间的 <code>910ms</code> 中的 <code>850ms</code>。</p>
<p>您也可以使用 <code>pdf</code>  命令从 Go 分析器的shell 创建一个分析数据的 PDF 输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(pprof) pdf</span><br><span class="line">Generating report in prfile001.pdf</span><br></pre></td></tr></table></figure>
<p>注意您需要 <strong>Graphviz</strong> 为了使生成的 PDF 文件能被您喜爱的 PDF 阅读器浏览。</p>
<p>最后，一个警告：如果您的程序执行太快，那么分析器将没有足够的时间获取样本，从而当您加载数据文件时，可能看到 <code>Total samples = 0</code> 的输出。如果那样的话，您将不能从分析过程中获得任何有用的信息。这就是为什么在 <code>profileMe.go</code> 的部分函数中使用 <code>time.Sleep()</code> 函数的原因：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.2-6.jpg" alt></p>
<h1 id="用于分析的第三方包"><a href="#用于分析的第三方包" class="headerlink" title="用于分析的第三方包"></a><strong>用于分析的第三方包</strong></h1><p>在这小节，您将看到一个设置分析环境的第三方包的使用，它比使用 <code>runtime/pprof</code> 标准包方便很多。这在 <code>betterProfile.go</code> 中有所体现，将分三部分来介绍。</p>
<p><code>betterProfile.go</code> 的第一部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/pkg/profile"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> VARIABLE <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">N1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span> ; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，您能看到使用了第三方包，在 <code>github.com/pkg/profile</code>。您可以在 <code>go get</code> 命令的帮助下下载它，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go get github.com/pkg/profile</span></span><br></pre></td></tr></table></figure>
<p><code>betterProfile.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Multiply</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span> || b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -Multiply(-a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b + Multiply(a<span class="number">-1</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> profile.Start(profile.ProfilePath(<span class="string">"/tmp"</span>)).Stop()</span><br></pre></td></tr></table></figure>
<p>这个由 Dave Cheney 开发的 <code>github.com/pkg/profile</code> 包需要您插入一行声明来开启 <strong>CPU 分析</strong> 在您的 Go 应用中。如果您想开启 <strong>内存分析</strong>的话，您应该插入如下声明来代替：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> profile.Start(profile.MemProfile).Stop()</span><br></pre></td></tr></table></figure>
<p>这个程序余下代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="number">200000</span>; i++ &#123;</span><br><span class="line">        n := N1(i)</span><br><span class="line">        <span class="keyword">if</span> n &#123;</span><br><span class="line">            total++</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Total: "</span>, total)</span><br><span class="line">    &#125;</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">400</span>; j++ &#123;</span><br><span class="line">            k := Multiply(i, j)</span><br><span class="line">            VARIABLE = k</span><br><span class="line">            total++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Total: "</span>, total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>betterProfile.go</code> 产生如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run betterProfile.go</span></span><br><span class="line">2018/03/08 17:01:28 profile: cpu profiling enabled, /tmp/cpu.pprof</span><br><span class="line">Total: 17984</span><br><span class="line">Total: 2000000</span><br><span class="line">2018/03/08 17:01:56 profile: cpu profiling disabled, /tmp/cpu.pprof</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/imagess/chapter11/11.5.3-1.jpg" alt="*`github.com/pkg/profile` 包帮您完成数据捕获部分；与之前的处理一样！*"></p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/imagess/chapter11/11.5.3-2.jpg" alt></p>
<h1 id="Go分析器的web接口"><a href="#Go分析器的web接口" class="headerlink" title="Go分析器的web接口"></a><strong>Go分析器的web接口</strong></h1><p>Go 1.10 版本带来的好消息是 <code>go tool pprof</code> 命令提供了一个 web 用户接口！</p>
<blockquote>
<p>为了这个web用户接口正常工作，您需要安装Graphviz，而且您的web浏览器必须支持JavaScript。如果您想运行的安全，就使用 Chrome或Firefox。</p>
</blockquote>
<p>您可以使用如下命令启动交互式 Go 分析器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool pprof -http=[host]:[port] aProfile</span></span><br></pre></td></tr></table></figure>
<h1 id="使用web接口的分析示例"><a href="#使用web接口的分析示例" class="headerlink" title="使用web接口的分析示例"></a><strong>使用web接口的分析示例</strong></h1><p>我们将使用从 <code>profileMe.go</code> 运行捕获的数据来学习 Go 分析器的 web 接口，因为不需要专门创建一个代码示例来做这个事。如您在之前小节了解到的，您首先需要执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool pprof -http=localhost:8080 /tmp/cpuProfile.out</span></span><br><span class="line">Main binary filename not available.</span><br></pre></td></tr></table></figure>
<p>下图显示了执行上面命令后， Go 分析器 web 用户接口的初始界面：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.1-1.jpg" alt="运行中的Go分析器 web 接口"></p>
<p>同样，下图显示了 Go 分析器的 <code>http://localhost:8080/source</code> URL内容，显示了程序的每个函数的分析信息：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.1-2.jpg" alt></p>
<h1 id="Graphviz快览"><a href="#Graphviz快览" class="headerlink" title="Graphviz快览"></a><strong>Graphviz快览</strong></h1><p><strong>Graphviz</strong> 是一个非常方便的实用程序汇编和计算机语言，允许您绘制复杂的图形。严格讲，Graphviz 是一个用于操纵有向和无向<strong>图形</strong>结构以及生成图形布局的工具集合。Graphviz 有它自己的语言（命名为 <strong>DOT</strong>），该语言简单，优雅并且强大。Graphviz 的优点是您可以实用一个简单的文本编辑器来写它的代码。该特点的一个很棒的作用是您可以容易的开发生成 Graphviz 代码的脚本！此外，大多数编程语言，包括 <strong>Python，Ruby，C++ 和 Perl</strong>，都提供了自己的接口，用于实用原生代码创建 Graphviz 文件。</p>
<blockquote>
<p>您不需要了解 Graphviz 为使用 Go 分析器的 web 接口的所有事情。只要了解 Graphviz 怎样工作和它的代码长什么样就可以了。</p>
</blockquote>
<p>下面是保存在 <code>graph.dot</code> 中的 Graphviz 代码，简要的说明了 Graphviz 工作方式和 Graphviz 语言的样子：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.2.jpg" alt></p>
<p><code>color</code> 属性改变一个节点的颜色，而 <code>shape</code> 属性改变节点的形状。另外，<code>dir</code> 属性可以应用到边，定义一条边是否有俩个箭头，一个箭头或没有箭头。此外，箭头样式可使用 <code>arrowhead</code> 和 <code>arrowtail</code> 属性定义。</p>
<p>使用一个 Graphviz 命令行工具编译上面的代码来创建一个 PNG 图片，需要在您喜爱的 Unix shell 中执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> dot -T png graph.dot -o graph.png</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l graph.png</span></span><br><span class="line">-rw-r--r--@  1  mstouk  staff  94155  Mar  1  07:30  graph.png</span><br></pre></td></tr></table></figure>
<p>下图显示了由执行上面命令产生的图形文件：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.5.4.2.jpg" alt="使用Graphviz创建图形"></p>
<p>因此，如果您想要可视化任何类型的结构，您一定要考虑使用 Graphviz 及其工具，特别是如果您想使用自己的脚本自动化。</p>
<h1 id="go-tool的代码追踪"><a href="#go-tool的代码追踪" class="headerlink" title="go tool的代码追踪"></a><strong>go tool的代码追踪</strong></h1><p><code>go tool trace</code> 实用程序是一个工具，用来查看由以下三种方式中任何一种产生的追踪文件：</p>
<ul>
<li>使用 <code>runtime/trace</code> 包</li>
<li>使用 <code>net/http/pprof</code> 包</li>
<li>执行 <code>go test --trace</code> 命令</li>
</ul>
<p>这节将只使用第一种技术。如下命令的输出将极大帮助您理解 <strong>Go execution tracer</strong> 在做什么：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.6-1.jpg" alt></p>
<p>在<a href="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/eBook/chapter11/11.2.md" target="_blank" rel="noopener">第2章</a>（深入剖析Go的内部原理），我们讨论了 <strong>Go 的垃圾回收</strong>，并介绍了一个 Go 实用程序 <code>gColl.go</code>，它能让我们看到 Go 垃圾回收的一些变量。在这节，我将使用 <code>go tool trace</code> 实用程序来获得关于 <code>goColl.go</code> 操作的更多信息。</p>
<p>首先，让我们来查看一下 <code>gColl.go</code> 程序的修改版，它告诉 Go 去收集性能数据。它被另存为 <code>goGC.go</code>，将分三部分来介绍。</p>
<p><code>goGC.go</code> 的第一部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStats</span><span class="params">(mem runtime.MemStats)</span></span> &#123;</span><br><span class="line">    runtime.ReadMemStats(&amp;mem)</span><br><span class="line">    fmt.Println(<span class="string">"mem.Alloc:"</span>, mem.Alloc)</span><br><span class="line">    fmt.Println(<span class="string">"mem.TotalAlloc:"</span>, mem.TotalAlloc)</span><br><span class="line">    fmt.Println(<span class="string">"mem.HeapAlloc:"</span>, mem.HeapAlloc)</span><br><span class="line">    fmt.Println(<span class="string">"-----"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所知，您首先需要引入 <code>runtime/trace</code> 标准包以便为 <code>go tool trace</code> 实用程序收集数据。</p>
<p><code>goGC.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">"/tmp/traceFile.out"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br></pre></td></tr></table></figure>
<p>这部分是所有为 <code>go tool trace</code> 实用程序获取数据的地方，并且它与实际程序的功能无关。首先，你将创建一个新文件来保存为 <code>go tool trace</code> 工具追踪的数据。然后，您使用 <code>trace.Start()</code> 启动追踪处理。当您完成追踪，可以调用 <code>trace.Stop()</code> 函数。<code>defer</code> 调用这个函数的意思是您想要在程序结束时终止追踪。</p>
<blockquote>
<p><em>使用 <code>go tool trace</code> 实用程序是一个包含俩个需要额外 Go 代码阶段的过程。首先您收集数据，然后您显示并处理数据。</em></p>
</blockquote>
<p>余下代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> mem runtime.MemStats</span><br><span class="line">    printStats(mem)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">50000000</span>)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Operation failed!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printStats(mem)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100000000</span>)</span><br><span class="line">        <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Operation failed!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">    printStats(mem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>goGC.go</code> 产生如下输出以及带有跟踪信息的名为 <code>/tmp/traceFile.out</code> 的新文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run goGC.go</span></span><br><span class="line">mem.Alloc: 107264</span><br><span class="line">mem.TotalAlloc: 107264</span><br><span class="line">mem.HeapAlloc: 107264</span><br><span class="line">mem.NumGC: 0</span><br><span class="line">-----</span><br><span class="line">mem.Alloc: 50117672</span><br><span class="line">mem.TotalAlloc: 150129416</span><br><span class="line">mem.HeapAlloc: 50117672</span><br><span class="line">mem.NumGC: 3</span><br><span class="line">-----</span><br><span class="line">mem.Alloc: 117320</span><br><span class="line">mem.TotalAlloc: 650174208</span><br><span class="line">mem.HeapAlloc: 117320</span><br><span class="line">mem.NumGC: 8</span><br><span class="line">-----</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /tmp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l traceFile.out</span></span><br><span class="line">-rw-r--r-- 1 mtsouk wheel 8275 Mar 7 08:37 traceFile.out</span><br><span class="line"><span class="meta">$</span><span class="bash"> file /tmp/traceFile.out</span></span><br><span class="line">/tmp/traceFile.out: data</span><br></pre></td></tr></table></figure>
<p>当您执行如下命令时，<code>go tool trace</code> 实用程序自动开启一个web 节目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool trace /tmp/traceFile.out</span></span><br><span class="line">2018/03/07 08:34:36 Parsing trace...</span><br><span class="line">2018/03/07 08:34:36 Serializing trace...</span><br><span class="line">2018/03/07 08:34:36 Splitting trace...</span><br><span class="line">2018/03/07 08:34:36 Opening browser. Trace viewer is listening on http://127.0.0.1:61428</span><br></pre></td></tr></table></figure>
<p>下面的截屏显示了当查看 <code>tmp/traceFiel.out</code> 追踪文件时，<code>go tool trace</code> 实用程序的初始 web 界面：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.6-2.jpg" alt="go trace tool 的初始 web 界面"></p>
<p>现在您应该选择 <code>View trace</code> 链接。它将带您到下个界面，显示 <code>go tool trace</code> 实用程序的另一个 web 界面，使用来自 <code>/tmp/traceFile.out</code> 的数据：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.6-3.jpg" alt="使用 go tool trace 查看 Go 垃圾收集的操作"></p>
<p>从上图，您能看到 Go GC 运行在自己的 goroutine，但它没有一直运行。另外，您可以看到程序使用了一定数量的 goroutines。关于Go GC，您可以通过选择交互界面的某些部分来了解更多信息。由于我们对 GC 的操作感兴趣，一段有用的显示信息是 Go GC 运行的频率和持续时间。</p>
<p>注意尽管 <code>go tool trace</code> 是一个非常方便强大的工具，但它不能解决任何性能问题。有时 <code>go tool pprof</code> 更合适，特别当您想要查找您的程序在哪个独立的功能上花费了大部分时间。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a><strong>测试</strong></h1><p>软件测试一个非常大的主题，而且它不能被一本书中的一章的单独一节所涵盖。因此，这简要的部分将介绍尽可能多的实用信息。</p>
<p>Go 允许您为您的代码编写测试来发现缺陷。严格讲，这节是关于自动<strong>测试</strong>的，包含写额外代码来验证真实代码；即产品代码，是否按预期运行。因此，一个测试函数的结果是不是 <code>PASS</code> 就是 <code>FAIL</code>。很快您将看到它是怎么运作的。</p>
<p>虽然 Go 的测试方法起初可能看起来很简单，特别是如果您将它与其他编程语言的测试实践进行比较，它非常高效和有效，因为它不需要占用开发者的太多时间。</p>
<p>Go 遵循有关测试的某些约定。首先，测试函数应该写在以 <code>_test.go</code> 结尾的 Go 源码中。因此，如果您有一个名为 <code>aGoPackage.go</code> 的包，那么您的测试代码应该放在名为 <code>aGoPackage_test.go</code> 的文件中。测试函数以 <code>Test</code>开头，并检查生产包的功能行为的正确性。</p>
<p>最后，您需要引入 <code>testing</code> 标准包以便 <code>go test</code> 子命令正确运行。如您马上看到的，这个引入要求也适用于另外两种情况。</p>
<p>一旦测试代码正确，<code>go test</code> 子命令为您做了所有脏活，包括为特定函数扫描所有 <code>*_test.go</code> 文件，生成一个临时的正确 <code>main</code> 包来调用这些特定函数，获得结果并产生最终输出。</p>
<blockquote>
<p><em>总是把测试代码放在另一个源文件。没必要创建一个难以阅读和维护的庞大源文件。</em></p>
</blockquote>
<h1 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a><strong>编写测试代码</strong></h1><p>在这节，您将了解怎样给一个存在的 Go 应用写测试，它有俩个函数：一个是计算斐波纳切数，一个是计算一个字符串长度。使用这俩个函数的主要原因是比较简单，它们实现了相对琐碎的任务。琐碎点是每个函数有俩个不同的实现：一个工作的很好，另一个有些问题。</p>
<p>这个例子 Go 包命名为 <code>testMe</code>，并存为 <code>testMe.go</code>。这个包的代码将分为三部分来介绍。</p>
<p><code>testMe.go</code> 的第一部分代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testMe</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1(n<span class="number">-1</span>) + f1(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码，您能看到定义了一个名为 <code>f1()</code> 函数，用来计算斐波纳切数。</p>
<p><code>testMe.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2(n<span class="number">-1</span>) + f2(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码，您能看到另一个名为 <code>f2()</code> 的函数实现计算斐波纳切数。然而，这个函数有一个错误，因为在 <code>n</code> 为 <code>1</code>时，它没有返回 <code>1</code>，这毁掉了函数的整个功能。</p>
<p><code>testMe.go</code> 的其余代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">s1</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">        n++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">s2</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分，我们实现了俩个函数，分别为 <code>s1()</code> 和 <code>s2()</code>，用来处理字符串。它们都返回字符串长度。然而，<code>s1()</code> 的实现是错误的，因为 <code>n</code> 的初始值是 1 而不是 0。</p>
<p>现在开始考虑测试和测试用例。首先，您应该创建一个名为 <code>testMe_test.go</code> 的文件来存放您的测试代码。接着，重要的是认识到您不需要对 <code>testMe.go</code>的代码做任何改变。最后，记住您应该根据需要尽可能多的编写测试函数来覆盖所有潜在的输入和输出。</p>
<p><code>testMe_test.go</code> 的第一部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testMe</span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestS1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1(<span class="string">"123456789"</span>) != <span class="number">9</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`s1("123456789") != 9`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s1(<span class="string">""</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`s1("") != 0`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数对 <code>s1()</code> 函数执行俩个测试：一个使用 <code>&quot;123456789&quot;</code> 作为输入，另一个用 <code>&quot;&quot;</code> 作为输入。</p>
<p><code>testMe_test.go</code> 的第二部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestS2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s2(<span class="string">"123456789"</span>) != <span class="number">9</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`s2("123456789") != 9`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s2(<span class="string">""</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`s2("") != 0`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面对测试代码对 <code>s2()</code> 函数执行同样的俩个测试。</p>
<p><code>testMe_test.go</code> 的其余代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestF1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f1(<span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f1(0) != 0`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f1(<span class="number">1</span>) != <span class="number">1</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f1(1) != 1`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f1(<span class="number">2</span>) != <span class="number">1</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f1(2) != 1`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f1(<span class="number">10</span>) != <span class="number">55</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f1(10) != 55`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestF2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f2(<span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f2(0) != 0`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f2(<span class="number">1</span>) != <span class="number">1</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f2(1) != 1`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f2(<span class="number">2</span>) != <span class="number">1</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f2(2) != 1`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> f2(<span class="number">10</span>) != <span class="number">55</span> &#123;</span><br><span class="line">        t.Error(<span class="string">`f2(10) != 55`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码测试了 <code>f1()</code> 和 <code>f2()</code> 函数的操作。</p>
<p>执行测试将产生如下输出：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.7.1-1.jpg" alt></p>
<p>如果您没使用 -v 参数（产生详细输出），您将得到如下输出：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.7.1-2.jpg" alt></p>
<p>您希望执行某些测试用例的话，您应该使用 <code>-run</code> 命令行选项，它接收一个正则表达式并执行所有函数名与给定正则表达式匹配的测试。</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.7.1-3.jpg" alt></p>
<p>最后的命令验证了 <code>go test</code> 命令使用了缓存。</p>
<blockquote>
<p>软件测试只能显示一个或多个 bug 的存在，而不是没有 bug ！这意味着您绝不能绝对确定代码没有 bug 。</p>
</blockquote>
<h1 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a><strong>基准测试</strong></h1><p>基准测试能给您一个函数或一个程序的性能信息，从而更好的理解一个函数比另一个函数是更快还是更慢，或者和一个应用的其他部分比较。使用这些信息，您可以容易的发现需要重写来提升性能的代码部分。</p>
<blockquote>
<p><em>绝对不要在一个繁忙的，当前正运行其他程序的 Unix 机器上给您的 Go 代码做基准测试，除非为了更重要的目的您有不得已的理由。</em></p>
</blockquote>
<p>Go 遵循有关基准测试的某些规则。最为重要的规则是一个基准测试函数的命名必须用 <code>Benchmark</code> 开头。</p>
<p>再次说明，<code>go test</code> 子命令是负责一个程序的基准测试。因此，您仍需要引入 <code>testing</code> 标准包并需要把基准测试函数放入以 <code>_test.go</code> 结尾的 Go 文件中。</p>
<h1 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a><strong>基准测试示例</strong></h1><p>在这节，我将向您介绍一个基本的基准测试示例，该示例测量三个产生<strong>斐波纳切序列</strong>数字算法的性能。好消息是这些算法需要大量的数学计算，以满足基准测试标准。</p>
<p>为了这节目的，我将创建一个新的 <code>main</code> 包，它将存在 <code>benchmarkMe.go</code> 中，并分三部分来介绍。</p>
<p><code>benchmarkMe.go</code> 的第一部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibo1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibo1(n<span class="number">-1</span>) + fibo1(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码包含了 <code>fibo1()</code> 函数的实现，该函数使用了递归算法来计算斐波纳切序列数字。尽管这个算法运行的很好，但这是一个相对简单、缓慢的方法。</p>
<p><code>benchmarkMe.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibo2</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibo2(n<span class="number">-1</span>) + fibo2(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这部分，您看到了 <code>fibo2()</code> 函数的实现，它几乎和我们之前看到的 <code>fibo1()</code>函数相同。然而，有趣的是，一点点代码的改变（单个 <code>if</code> 表达式而不是 <code>if else if</code> 块）是否对函数的性能有任何影响。</p>
<p><code>benchmarkMe.go</code> 的第三部分包含另一个计算斐波纳切序列数字的函数实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibo3</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fn := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> f <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= <span class="number">2</span> &#123;</span><br><span class="line">            f = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f = fn[i<span class="number">-1</span>] + fn[i<span class="number">-2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        fn[i] = f</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这介绍的 <code>fibo3()</code> 函数使用了一个全新的方法，它需要一个 Go <strong>map</strong> 和一个 <code>for</code> 循环。这个方法是否真的比其他两种实现更快，还有待观察。在 <code>fibo3()</code> 中介绍的算法也将用在<a href="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/eBook/chapter13/13.0.md" target="_blank" rel="noopener">第13章</a>（网络编程 - 构建服务器与客户端），在那将更详细的解释它。一会您就会看到，选择一个高效的算法能减少很多麻烦！</p>
<p><code>benchmarkMe.go</code> 的其余代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(fibo1(<span class="number">40</span>))</span><br><span class="line">    fmt.Println(fibo2(<span class="number">40</span>))</span><br><span class="line">    fmt.Println(fibo3(<span class="number">40</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>benchmarkMe.go</code> 将产生如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run benchmarkMe.go</span></span><br><span class="line">102334155</span><br><span class="line">102334155</span><br><span class="line">102334155</span><br></pre></td></tr></table></figure>
<p>好消息是这三种实现都返回了相同的数字。现在是时候给 <code>benchmarkMe.go</code> 添加一些基准测试来理解这三个算法中每一个的效率了。</p>
<p>由于 Go 规则要求，这个包含基准测试函数的 <code>benchmarkMe.go</code> 版本将另存为 <code>benchmarkMe_test.go</code>。这个程序分为五个部分来介绍。</p>
<p><code>benchmarkMe_test.go</code> 的第一段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkfibo1</span><span class="params">(b *testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = fibo1(n)</span><br><span class="line">    &#125;</span><br><span class="line">    result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码，您能看到一个用 <code>benchmark</code> 字符串而不是 <code>Benchmark</code> 开头命名的函数实现。因此，这个函数将不能自动运行，因为它用小写 <code>b</code> 而不是大写<code>B</code> 开头。</p>
<p>存放 <code>fibo1(n)</code> 的结果在一个名为 <code>r</code> 的变量中，并在之后使用另一个名为 <code>result</code> 的全局变量的原因是很微妙。此技巧用于阻止编译器执行任何优化，这些优化将排除您要测量的函数，因为它的结果从未被使用过！相同的技巧将用在接下来介绍的 <code>benchmarkfibo2()</code> 和 <code>benchmarkfibo3()</code> 函数中。</p>
<p><code>benchmarkMe_test.go</code> 的第二部分显示在如下代码中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkfibo2</span><span class="params">(b * testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = fibo2(n)</span><br><span class="line">    &#125;</span><br><span class="line">    result = r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkfibo3</span><span class="params">(b * testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> r <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        r = fibo3(n)</span><br><span class="line">    &#125;</span><br><span class="line">    result = r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了另两个基准测试函数，因为它们以小写 <code>b</code> 开头而不是大写 <code>B</code> 所以不能自动运行。</p>
<p>现在，我来告诉您一个大秘密：即使这三个函数被命名为 <code>BenchmarkFibo1()</code>，<code>BenchmarkFibo2()</code> 和 <code>BenchmarkFibo3()</code>，它们也不能被 <code>go test</code> 命令自动调用，因为它们的签名不是 <code>func(*testing.B)</code>。所以，用小写 <code>b</code> 给它们命名的原因如此。然而，没有什么可以阻止您之后从其他基准函数调用它们，稍后您就会看到。</p>
<p><code>benchmarkMe_test.go</code> 的第三部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark30fibo1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkfibo1(b, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确的基准函数拥有正确的名称和正确的签名，意味着它将由 <code>go tool</code> 执行。</p>
<p>注意，尽管 <code>Benchmark30fibo1()</code> 是有效的基准函数名，但 <code>BenchmarkfiboIII()</code> 不是因为在 <code>Benchmark</code> 字符串后没有大写字符或数字。这是非常重要的，因为一个拥有无效名称的基准函数不能被自动执行。</p>
<p><code>benchmarkMe_test.go</code> 的第四段包含如下 Go 代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark30fibo2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkfibo2(b, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark30fibo3</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkfibo3(b, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Benchmark30fibo2()</code> 和 <code>Benchmark30fibo3()</code> 基准函数都和 <code>Bencharmk30fibo1()</code> 相同。</p>
<p><code>benchmarkMe_test.go</code> 都最后部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark50fibo1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkfibo1(b, <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark50fibo2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkfibo2(b, <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark50fibo3</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkfibo3(b, <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这部分，您看到了另外三个基准函数，用于计算斐波纳切序列中的第50个数。</p>
<blockquote>
<p><em>记住每个基准测试默认执行至少 1 秒。如果基准函数在少于 1 秒的时间内返回，则 <code>b.N</code> 的值增加并且该函数会再次运行。<code>b.N</code> 的值第一次是 1，然后变为 2，5，10，20，50 等等。这是因为函数运行的越快，您就需要越多次的运行它来获得准确结果</em></p>
</blockquote>
<p>执行 <code>benchmarkMe_test.go</code> 将产生如下输出：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.8.1-1.jpg" alt></p>
<p>这里有俩点很重要：第一，<code>-bench</code> 参数的值指定了将要执行的基准函数。这个被使用的点值是一个正则表达式，用于匹配所有有效的基准函数。第二，如果您忽略了 <code>-bench</code> 参数，将没有基准函数被执行！</p>
<p>那么，这个输出告诉了我们什么？首先，在每个基准函数（<code>Benchmark10fibo1-8</code>）结尾处的 <code>-8</code> 表示该函数被执行期间的 goroutines 数，本质上它是 <code>GOMAXPROCS</code> 环境变量的值。您会记得我们在<a href="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/eBook/chapter10/10.0.md" target="_blank" rel="noopener">第10章</a>（揪出隐藏的代码）讨论过 <code>GOMAXPROCS</code> 环境变量。同样，您可以看到 <code>GOOS</code> 和 <code>GOARCH</code> 的值，它们显示了您机器的操作系统和架构。</p>
<p>输出的第二列显示了相关函数的执行次数。较快的函数比较慢的函数被执行了多次。例如，<code>Benchmark30fibo3()</code> 函数执行了 500,000 次，而 <code>Benchmark50fibo2()</code> 函数仅执行了一次！输出的第三列显示了每个运行的平均值。</p>
<p>如您所见，<code>fibo1()</code> 和 <code>fibo2()</code> 函数真的比 <code>fibo3()</code> 函数慢。如果您希望在输出中包含内存分配统计，您可以执行如下命令：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.8.1-2.jpg" alt></p>
<p>上面的输出和没有使用 <code>-benchmem</code> 命令行参数的输出类似，但它多包含了两列。第四列显示了平均分配给每个执行的基准函数的内存数。第五列显示了用于分配第四列的内存值的分配数。所以，<code>Benchmark50fibo3()</code> 在 10 分配中平均分配了 2481 字节。</p>
<p>如您所知，<code>fibo1()</code> 和 <code>fibo2()</code> 函数除了预期的内存外，都不需要特定类型的内存，这与 <code>fibo3()</code> 使用一个 map 变量的情况不同；因此，<code>Benchmark10fibo3-8</code> 的输出的第四和第五列的值都大于0。</p>
<h1 id="错误的基准测试函数"><a href="#错误的基准测试函数" class="headerlink" title="错误的基准测试函数"></a><strong>错误的基准测试函数</strong></h1><p>看一下下面的基准测试函数代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFiboI</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _ = fibo1(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BenchmarkFibo()</code> 函数有一个有效的方法名和正确的签名。然而，坏消息是这个基准测试函数是错的，并且您执行 <code>go test</code> 命令后不能从它获得任何输出。</p>
<p>原因是根据上一节的描述，随着 <code>b.N</code> 值的增加，由于 <code>for</code>循环这个基准测试函数的运行次数也会增加。这一事实阻止了 <code>BenchmarkFiboI()</code> 收敛于一个稳定的数字，从而妨碍了函数完成并返回。</p>
<p>由于算法原因，下面的基准测试函数也实现错了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkfiboII</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; b.N ; i++ &#123;</span><br><span class="line">        _ = fibo2(b.N)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，下面俩个基准测试函数的实现没有错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFiboIV</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        _ = fibo3(<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFiboIII</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    _ = fibo3(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="基准测试的缓冲写入"><a href="#基准测试的缓冲写入" class="headerlink" title="基准测试的缓冲写入"></a><strong>基准测试的缓冲写入</strong></h1><p>在这节，我们将使用 <code>writingBU.go</code> 的代码来探索写缓冲的大小如何影响整个写操作的性能，它分为五部分来介绍。</p>
<p><code>writingBU.go</code> 程序使用随机生成的数据来产生虚拟文件。这个程序的变量是缓冲的大小和输出文件的大小。</p>
<p><code>writingBU.go</code> 的第一部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math/rand"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> BUFFERSIZE <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> FILESIZE <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">random</span><span class="params">(min, max <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand.Intn(max-min) + min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>writingBU.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createBuffer</span><span class="params">(buf *[]<span class="keyword">byte</span>, count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *buf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, count)</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">        intByte := <span class="keyword">byte</span>(random(<span class="number">0</span>, <span class="number">100</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(*buf) &gt; count &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        *buf = <span class="built_in">append</span>(*buf, intByte)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>writingBU.go</code> 的第三部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(dst <span class="keyword">string</span>, b, f <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    _, err := os.Stat(dst)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Error(<span class="string">"File %s already exists."</span>, dst)</span><br><span class="line">    &#125;</span><br><span class="line">    destination, err := os.Create(dst)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> destination.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        createBuffer(&amp;buff, b)</span><br><span class="line">        buf = buf[:b]</span><br><span class="line">        <span class="keyword">if</span> _, err := destination.Write(buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        f = f - <span class="built_in">len</span>(buf)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中的 <code>Create()</code> 函数做了所有工作，他是需要进行基准测试的函数。</p>
<p>注意如果缓冲大小和文件大小不是 <code>Create()</code> 函数的签名的一部分，在给 <code>Create()</code> 函数写基准测试函数时您将遇到问题，因为您需要使用 <code>BUFFERSIZE</code> 和 <code>FILESIZE</code> 全局变量，它们都是在 <code>writingBU.go</code> 的 <code>main()</code> 函数中初始化的。</p>
<p>这将是一个难点在 <code>writingBU_test.go</code> 文件中。这意味着为了给一个函数创建一个基准测试，您应该在您写代码时就考虑这个问题。</p>
<p><code>writingBU.go</code> 的第四部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Need BUFFERSIZE FILESIZE!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    output := <span class="string">"/tmp/randomFile"</span></span><br><span class="line">    BUFFERSIZE,_ = strconv.Atoi(os.Args[<span class="number">1</span>])</span><br><span class="line">    FILESIZE, _ = strconv.Atoi(os.Args[<span class="number">2</span>])</span><br><span class="line">    err := Create(output, BUFFERSIZE, FILESIZE)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>writingBU.go</code> 的其余代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    err = os.Remove(output)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管在 <code>main()</code> 函数里调用 <code>os.Remove()</code> 删除了临时文件，但没有在基准测试函数中调用它，在基准测试函数中调用它比较简单，所以这不是问题。</p>
<p>在一台有 SSD 硬盘的 macOS High Sierra 机器上执行 <code>writingBU.go</code> 俩次，用 <code>time(1)</code> 工具来检测程序产生如下输出但速度：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> time go run writingBU.go 1 100000</span></span><br><span class="line">real 0m1.193s</span><br><span class="line">user 0m0.349s</span><br><span class="line">sys  0m0.809s</span><br><span class="line"><span class="meta">$</span><span class="bash"> time go run writingBU.go 10 100000</span></span><br><span class="line">real 0m0.283s</span><br><span class="line">user 0m0.195s</span><br><span class="line">sys  0m0.228s</span><br></pre></td></tr></table></figure>
<p>尽管这显示出写缓冲的大小对程序的性能起到关键作用，但我们需要更具体更准确。因此，我们来写基准测试函数存储为 <code>writingBU_test.go</code>。</p>
<p><code>writingBU_test.go</code> 的第一部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> ERR error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkCreate</span><span class="params">(b *testing.B, buffer, filesize <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        err = Create(<span class="string">"/tmp/random"</span>, buffer, filesize)</span><br><span class="line">    &#125;</span><br><span class="line">    ERR = err</span><br><span class="line">    err = os.Remove(<span class="string">"/tmp/random"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您会记得这不是一个有效的基准测试函数。</p>
<p><code>writingBU_test.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1Create</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkCreate(b, <span class="number">1</span>, <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark2Create</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkCreate(b, <span class="number">2</span>, <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>writingBU_test.go</code> 的其余代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark4Create</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkCreate(b, <span class="number">4</span>, <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10Create</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkCreate(b, <span class="number">10</span>, <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000Create</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    benchmarkCreate(b, <span class="number">1000</span>, <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们写了五个基准测试函数来检测 <code>benchmarkCreate()</code> 函数的性能，它用写缓冲大小变量检测 <code>Create()</code> 函数的性能。</p>
<p>对 <code>writingBU.go</code> 和 <code>writingBU_test.go</code> 文件执行 <code>go test</code> 将产生如下输出：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.9-1.jpg" alt></p>
<p>下面的输出也检测了基准测试函数的内存分配：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.9-2.jpg" alt></p>
<p>现在来解释一下这俩个 <code>go tesst</code> 命令的输出。</p>
<p>很明显使用一个大小为 1 个字节的写缓冲是完全无效的并且缓冲所有的操作。另外，这样的缓冲大小需要更多的内存操作，这也使程序运行的更慢！</p>
<p>使用 2 个字节的缓冲可以整个程序速度提升 2 倍，这是好事。然而，这仍然很慢。这同样适用于 4 个字节的写缓冲。</p>
<p>当决定用 10 个字节的写缓冲时，这会变的更快。最后，这个结果显示使用 1,000 字节的写缓冲没有比使用 10 字节的快 100 倍，这意味着在速度和写缓冲大小之间的最佳点是在这俩个值之间。</p>
<h1 id="揪出隐藏的代码"><a href="#揪出隐藏的代码" class="headerlink" title="揪出隐藏的代码"></a><strong>揪出隐藏的代码</strong></h1><p>不能执行的 Go 代码是逻辑错误，因此由开发者或一个 Go 编译器的正常执行操作来解决这个问题是相当困难的。简单讲，除了无法执行此代码外，对于隐藏代码没有任何问题！</p>
<p>看一下下面保存在 <code>cannotReach.go</code> 中的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Entering f1()"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-10</span></span><br><span class="line">    fmt.Println(<span class="string">"Exiting f1()"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Exiting f2()"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f1())</span><br><span class="line">    fmt.Println(<span class="string">"Exiting program..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cannotReach.go</code> 的代码没有语法错误。因此，您可以执行 <code>cannotReach.go</code>，编译器不会报任何错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run cannotReach.go</span></span><br><span class="line">Entering f1()</span><br><span class="line">-1</span><br><span class="line">Exiting program...</span><br></pre></td></tr></table></figure>
<p>注意程序中的 <code>f2()</code> 从来没有被执行。然而，这很容易猜到下面的 <code>f2()</code> 没有执行的原因是之前的 <code>if</code> 语句总是 <code>true</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Exiting f2()"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>因此，对于这个问题您能做什么呢？您可以执行下面的 <code>go tool vet</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool vet cannotReach.go</span></span><br><span class="line">cannotReach.go:10: unreachable code</span><br></pre></td></tr></table></figure>
<p>这个输出告诉我们有不可到达代码在程序的第10行。现在我们来从函数 <code>f1()</code> 中移除 <code>return -10</code> 语句，再执行 <code>go tool vet</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go tool vet cannotReach.go</span></span><br></pre></td></tr></table></figure>
<p>这里没有新的错误信息，尽管在 <code>f2()</code> 函数中仍有隐藏代码。这意味着 <code>go tool vet</code> 无法捕获每种可能的逻辑错误。</p>
<h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a><strong>交叉编译</strong></h1><p><strong>交叉编译</strong> 是一个为您工作平台之外的 CPU 架构生成可执行二进制文件的过程。</p>
<p>您从交叉编译获得的主要好处是您不需要第二台或第三台不同架构的机器来生成可执行文件。这意味着您基本上只需要一台机器来做开发。幸运的是，Go 内建了支持交叉编译！</p>
<p>为了这节的目的，我们使用 <code>xCompile.go</code> 的代码来说明交叉编译的过程。<code>xCompile.go</code> 的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"You are using "</span>, runtime.Compiler, <span class="string">" "</span>)</span><br><span class="line">    fmt.Println(<span class="string">"on a"</span>, runtime.GOARCH, <span class="string">"machine"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"with Go version"</span>, runtime.Version())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一台 macOS High Sierra 机器上运行 <code>xCompile.go</code> 产生如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run xCompile.og</span></span><br><span class="line">You are using gc on a amd64 machine</span><br><span class="line">with Go version go1.10</span><br></pre></td></tr></table></figure>
<p>为了交叉编译 Go 源文件，您需要设置 <code>GOOS</code> 和 <code>GOARCH</code> 环境变量来分别指定目标系统和 CPU 架构，这并不像听起来那么困难。</p>
<p>因此，交叉编译过程如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> env GOOS=linux GOARCH=arm go build xCompile.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file xCompile</span></span><br><span class="line">xCompile: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, with debug_info, not stripped</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./xCompile</span></span><br><span class="line">-bash: ./xCompile: cannot execute binary file</span><br></pre></td></tr></table></figure>
<p>第一个命令产生一个二进制文件，用于运行在使用 ARM CPU 架构的Linux 机器上，而 <code>file(1)</code> 的输出验证了产生的二进制文件的确是一个不同的 CPU 架构。</p>
<p>由于，我们使用一台有 Intel 处理器的 Debian Linux 机器来演示该例子，所以需要使用正确的 <code>GOARCH</code> 值再执行一次 <code>go build</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> env GOOS=linux GOARCH=386 go build xCompile.go</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file xCompile</span></span><br><span class="line">xCompile: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, with debug_info, not stripped</span><br></pre></td></tr></table></figure>
<p>在 Linux 机器上执行产生的二进制文件将产生如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./xCompile</span></span><br><span class="line">You are using gc on a 386 machine</span><br><span class="line">with Go version go1.10</span><br><span class="line"><span class="meta">$</span><span class="bash"> go version</span></span><br><span class="line">go version go1.3.3 linux/amd64</span><br><span class="line"><span class="meta">$</span><span class="bash"> go run xCompile.go</span></span><br><span class="line">You are using gc on a amd64 machine</span><br><span class="line">with Go version go1.3.3</span><br></pre></td></tr></table></figure>
<p>这里第一个需要注意的是，<code>xCompile.go</code> 交叉编译后的二进制文件，打印的Go 版本是编译机的 Go 版本。第二个注意事项是，Linux 机器的 CPU 架构实际是 <code>386</code> 而不是 <code>amd64</code> 用于交叉编译。</p>
<blockquote>
<p><em>您可以在 <a href="http://golang.org/doc/install//source" target="_blank" rel="noopener">http://golang.org/doc/install//source</a>找到 <code>GOOS</code> 和 <code>GOARCH</code> 环境变量可用值列表。然而，注意不是所有的 <code>GOOS</code> 和 <code>GOARCH</code> 对都是有效的</em></p>
</blockquote>
<h1 id="创建示例函数"><a href="#创建示例函数" class="headerlink" title="创建示例函数"></a><strong>创建示例函数</strong></h1><p>文档过程的一部分是生成示例代码来展示包的某些或所有函数和类型的使用。</p>
<p>示例函数有很多好处，包括它们是由 <code>go test</code> 执行的可执行测试！因此，如果一个示例函数有一个 <code>// Output:</code> 行，<code>go test</code> 工具将检查经过计算的输出是否和 <code>// Output:</code> 行后的值相匹配。</p>
<p>另外，当在包里看到示例时是非常有用的，这是下节的主题。最后，Go 文档服务器（<a href="https://golang.org/pkg/io/#example_Copy" target="_blank" rel="noopener">https://golang.org/pkg/io/#example_Copy</a>）上显示的示例函数允许读者使用示例代码进行实验。Go 训练场<a href="https://play.golang.org/" target="_blank" rel="noopener">https://play.golang.org/</a>也支持这个功能。</p>
<p>由于 <code>go test</code> 子命令负责程序的示例，您需要引入 <code>testing</code> 标准包，并包含示例函数在以 <code>_test.go</code> 结尾的 Go 文件中。而且，每个示例函数的名称必须以 <code>Example</code>开头。最后，<strong>示例函数</strong> 不接收参数并没有返回结果！</p>
<p>现在，让我们来给如下存在 <code>ex.go</code> 中的包创建一些示例函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> || n == <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F1(n<span class="number">-1</span>) + F1(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S1</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ex.go</code> 源文件包含名为 <code>F1()</code> 和 <code>S1()</code> 两个函数的实现。注意，<code>ex.go</code> 不需要引入 <code>fmt</code> 包。</p>
<p>如您所知，示例函数将存在 <code>ex_test.go</code> 文件中，分三部分来介绍。</p>
<p><code>ex_test.go</code> 的第一部分如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ex</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>ex_test.go</code> 的第二段代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleF1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(F1(<span class="number">10</span>))</span><br><span class="line">    fmt.Println(F1(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 55</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ex_test.go</code> 剩下的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleS1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(S1(<span class="string">"123456789"</span>))</span><br><span class="line">    fmt.Println(S1(<span class="string">""</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>ex.go</code> 包执行 <code>go test</code> 命令会产生如下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go <span class="built_in">test</span> ex.go ex_test.go -v</span></span><br><span class="line">=== RUN ExampleF1</span><br><span class="line">--- PASS: ExampleF1 (0.00s)</span><br><span class="line">=== RUN ExampleS1</span><br><span class="line">--- FAIL: ExampleS1 (0.00s)</span><br><span class="line">got:</span><br><span class="line">9</span><br><span class="line">0</span><br><span class="line">want:</span><br><span class="line">8</span><br><span class="line">0</span><br><span class="line">FAIL</span><br><span class="line">FAIL command-line-arguments 0.006s</span><br></pre></td></tr></table></figure>
<p>您将注意到上面的输出告诉我们，基于 <code>// Output:</code> 注释后面的数据，<code>S1()</code> 函数有错误。</p>
<h1 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a><strong>生成文档</strong></h1><p>Go 提供了 <code>godoc</code> 工具，允许您浏览您的包文档——前提是您的文件里包含一些额外信息。</p>
<blockquote>
<p>我一般建议您应该尝试把所有的都文档化，除了一些比较明显的。简而言之，不要写：这我创建了一个新的 <code>int</code> 变量。最好表明 <code>int</code> 变量的作用！然而，真正优秀的代码通常不需要文档！</p>
</blockquote>
<p>在 Go  中写文档的规则相当简单，直接。为了文档化，您需要在声明前写一行或多行以 <code>//</code> 开头的常规注释。这个规定可用于文档化函数，变量，常量，乃至其他包！</p>
<p>另外，您会注意到任何大小包的文档的第一行会出现在 <code>godoc</code> 的包列表中，如 <code>https://golang.org/pkg</code> 一样。这意味着它是应该是很有描述性和完整性。</p>
<p>注意，以 <code>BUG(something)</code> 开头第注释会出现在包文档的 <code>Bugs</code> 部分。如果您正寻找这样的例子，您可以看一下 <code>bytes</code> 包的源码和文档页面，它们分别在 <a href="https://golang.org/src/bytes/bytes.go" target="_blank" rel="noopener">https://golang.org/src/bytes/bytes.go</a> 和 <a href="https://golang.org/pkg/bytes/" target="_blank" rel="noopener">https://golang.org/pkg/bytes/</a>。</p>
<p>最后，所有和顶级声明无关的注释都将从 <code>godoc</code> 实用程序生成的输出中省略。</p>
<p>看一下下面保存在 <code>documentMe.go</code> 中的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This package is for showcasing the documentation capabilities of Go</span></span><br><span class="line"><span class="comment">// It is a naive package!</span></span><br><span class="line"><span class="keyword">package</span> documentMe</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pie is a global variable</span></span><br><span class="line"><span class="comment">// This is a silly comment!</span></span><br><span class="line"><span class="keyword">const</span> Pie = <span class="number">3.1415912</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The S1() function finds the length of a string</span></span><br><span class="line"><span class="comment">// It iterates over the string using range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S1</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">        n ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The F1() function returns the double value of its input integer</span></span><br><span class="line"><span class="comment">// A better function name would have been Double()!</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F1</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上一节讨论的，我们需要创建一个 <code>documentMe_test.go</code> 文件来为它开发示例函数。<code>documentMe_test.go</code> 的内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> documentMe</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleS1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(S1(<span class="string">"123456789"</span>))</span><br><span class="line">    fmt.Println(S1(<span class="string">""</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 9</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleF1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(F1(<span class="number">10</span>))</span><br><span class="line">    fmt.Println(F1(<span class="number">2</span>))</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够看到 <code>documentMe.go</code> 的文档， 您需要在本机安装这个包，如您在<a href="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/eBook/chapter6/6.0.md" target="_blank" rel="noopener">第6章</a>（<em>Go package中不为人知的知识</em>）。这需要在 Unix shell 里执行如下命令：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-1.jpg" alt></p>
<p>接下来，您应该如下执行 <code>godoc</code> 工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">godoc -http=<span class="string">":8080"</span></span></span><br></pre></td></tr></table></figure>
<p>注意，您可以使用任何没被其他进程占用的端口号。如被占用，您将看到类似下面的错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">godoc -http=<span class="string">":22"</span></span></span><br><span class="line">2018/03/06 21:03:05 ListenAndServe :22: listen tcp :22: bind: permission denied</span><br></pre></td></tr></table></figure>
<p>注意这点后，您将能够使用您喜欢的 web 浏览器来浏览刚被创建的 HTML 文档。这个文档的 URL 是 <code>http://localhost:8080/pkg/</code>。</p>
<p>下面的截屏显示了我们刚启动的 <code>godoc</code> 服务的根目录。您能看到您创建的 <code>documentMe.go</code> 包在其他 Go 包中。</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-2.jpg" alt="godoc 服务的根目录"></p>
<p>下面的截屏显示了在 <code>documentMe.go</code> 源文件中实现的 <code>documentMe</code> 包的文档的根目录：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-3.jpg" alt="documentMe.go 的根页面"></p>
<p>同样，下面的截屏更详细的显示了 <code>documentMe.go</code> 包中 <code>S1()</code> 函数的文档，还包含示例代码。这里的示例代码不是动态的，但您能看到源码和它的输出：</p>
<p><img src="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/images/chapter11/11.13-4.jpg" alt="S1()函数的文档页和示例"></p>
<p>执行 <code>go test</code> 命令将产生如下输出，它可能发现我们代码中的潜在问题和错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">go <span class="built_in">test</span> -v documentMe*</span></span><br><span class="line">=== RUN ExampleS1</span><br><span class="line">--- PASS: ExampleS1 (0.00s)</span><br><span class="line">=== RUN ExampleF1</span><br><span class="line">--- FAIL: ExampleF1 (0.00s)</span><br><span class="line">got:</span><br><span class="line">20</span><br><span class="line">4</span><br><span class="line">want:</span><br><span class="line">1</span><br><span class="line">55</span><br><span class="line">FAIL</span><br><span class="line">FAIL command-line-arguments 0.005s</span><br></pre></td></tr></table></figure>
<h1 id="延展阅读"><a href="#延展阅读" class="headerlink" title="延展阅读"></a><strong>延展阅读</strong></h1><p>访问如下 web 链接：</p>
<ul>
<li>访问 Graphviz 网站<a href="http://graphviz.org" target="_blank" rel="noopener">http://graphviz.org</a></li>
<li>访问 <code>testing</code> 包的文档页，可在<a href="https://golang.org/pkg/testing" target="_blank" rel="noopener">https://golang.org/pkg/testing</a>找到</li>
<li>您可以访问 <code>godoc</code> 工具的文档页<a href="https://godoc.org/golang.org/x/tools/cmd/godoc" target="_blank" rel="noopener">https://godoc.org/golang.org/x/tools/cmd/godoc</a>了解它的更多内容</li>
<li>访问 <code>runtime/pprof</code> 标准包的文档页，可以在<a href="https://golang.org/pkg/runtime/pprof" target="_blank" rel="noopener">https://golang.org/pkg/runtime/pprof</a>找到</li>
<li>您可以访问<a href="https://golang.org/src/net/http/pprof/pprof.go" target="_blank" rel="noopener">https://golang.org/src/net/http/pprof/pprof.go</a>浏览 <code>net/http/pprof</code>包的源码</li>
<li>您可以在<a href="https://golang.org/src/net/http/pprof/" target="_blank" rel="noopener">https://golang.org/src/net/http/pprof/</a>找到 <code>net/http/pprof</code>包的文档页</li>
<li>Go1.10 版本和 Go1.9 版本的完整变更列表，您可以查看<a href="https://golang.org/doc/go1.10" target="_blank" rel="noopener">https://golang.org/doc/go1.10</a></li>
<li>您可以访问 <code>pprof</code> 工具的开发页<a href="https://github.com/google/pprof" target="_blank" rel="noopener">https://github.com/google/pprof</a>了解它的更多内容</li>
<li>在<a href="https://www.youtube.com/watch?=v=8hQG7QlcLBk" target="_blank" rel="noopener">https://www.youtube.com/watch?=v=8hQG7QlcLBk</a>观看 GohperCon 2017 大会上由 Mitchell Hashimoto 介绍的 Go 语言高级测试视频</li>
<li>您可以在<a href="https://golang.org/src/testing/testing.go" target="_blank" rel="noopener">https://golang.org/src/testing/testing.go</a>找到 <code>testing</code>包的源码</li>
<li>您可以访问 <code>profile</code> 包的 web 页面<a href="https://github.com/pkg/profile" target="_blank" rel="noopener">https://github.com/pkg/profile</a>了解它的更多内容</li>
<li>你可以访问 <code>go fix</code> 工具的 web 页面<a href="https://golang.org/cmd/fix" target="_blank" rel="noopener">https://golang.org/cmd/fix</a>了解它的更多内容</li>
</ul>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a><strong>练习</strong></h1><ul>
<li>给我们在<a href="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/eBook/chapter8/8.0.md" target="_blank" rel="noopener">第8章</a>（<em>Go UNIX系统编程</em>）开发的 <code>byWord.go</code> 程序写测试函数。</li>
<li>给我们在<a href="https://github.com/hantmac/Mastering_Go_ZH_CN/tree/master/eBook/chapter8/8.0.md" target="_blank" rel="noopener">第8章</a>（<em>Go UNIX系统编程</em>）开发的 <code>readSize.go</code> 程序写基准函数。</li>
<li>试着修改 <code>documentMe.go</code> 和 <code>documentMe_test.go</code> 代码中的问题。</li>
<li>使用 <code>go tool pprof</code> 工具的文本接口来检查由 <code>profileMe.go</code> 生成的 <code>memoryProfile.out</code> 文件。</li>
<li>接下来，使用 <code>go tool pprof</code> 工具的 web 接口来检查由<code>profileMe.go</code> 生成的 <code>memoryProfile.out</code> 文件。</li>
</ul>
<h1 id="本章小节"><a href="#本章小节" class="headerlink" title="本章小节"></a><strong>本章小节</strong></h1><p>在这章，我们讨论了代码测试，代码优化和代码分析。到本章为止，您了解了如何找到隐藏代码和怎样交叉编译 Go 代码。<code>go test</code> 命令用来测试和基准测试 Go 代码，以及使用例子函数提供而外的文档。</p>
<p>尽快 Go 分析器和 <code>go tool trace</code> 的讨论远没完成，但您应该理解了分析和代码追踪等话题，没有什么可以取代您自己的实验并尝试新技能。</p>
<p>下一章，我们将开始讨论 Go 语言的网络编程，涉及编写运行在 TCP/IP 计算机网络，也包括互联网上的应用程序。下章的部分主题是 <code>net/http</code> 包，用 Go 创建 web 客户端和 web 服务器，<code>http.Response</code> 和 <code>http.Request</code> 结构，分析 HTTP 服务器，和网络连接超时。</p>
<p>另外，下章将讨论 <strong>IPv4</strong> 和 <strong>IPv6</strong> 协议以及 Wireshark 和 tshark 工具，它们用于捕获和分析网络流量。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Mastering-Go/" rel="tag"># Mastering Go</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/30/10-Go并发-进阶讨论/" rel="next" title="10-Go并发-进阶讨论">
                <i class="fa fa-chevron-left"></i> 10-Go并发-进阶讨论
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/30/12-Go网络编程基础/" rel="prev" title="12-Go网络编程基础">
                12-Go网络编程基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">强迫自己去看，去做。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">614</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">54</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2022/09/14/15-深入解析Pod对象（二）：使用进阶/" title="15 | 深入解析Pod对象（二）：使用进阶" target="_blank">15 | 深入解析Pod对象（二）：使用进阶</a>
                  </li>
                
                  <li>
                    <a href="/2022/09/14/14-深入解析Pod对象（一）：基本概念/" title="14 | 深入解析Pod对象（一）：基本概念" target="_blank">14 | 深入解析Pod对象（一）：基本概念</a>
                  </li>
                
                  <li>
                    <a href="/2022/09/14/13-为什么我们需要Pod？/" title="13 | 为什么我们需要Pod？" target="_blank">13 | 为什么我们需要Pod？</a>
                  </li>
                
                  <li>
                    <a href="/2022/09/14/12-牛刀小试：我的第一个容器化应用/" title="12 | 牛刀小试：我的第一个容器化应用" target="_blank">12 | 牛刀小试：我的第一个容器化应用</a>
                  </li>
                
                  <li>
                    <a href="/2022/09/14/11-从0到1：搭建一个完整的Kubernetes集群/" title="11 | 从0到1：搭建一个完整的Kubernetes集群" target="_blank">11 | 从0到1：搭建一个完整的Kubernetes集群</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#代码测试，优化以及分析"><span class="nav-number">1.</span> <span class="nav-text">代码测试，优化以及分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章使用的Go版本"><span class="nav-number">2.</span> <span class="nav-text">本章使用的Go版本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-10和1-9的版本对比"><span class="nav-number">3.</span> <span class="nav-text">1.10和1.9的版本对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#安装beta或者RC版本"><span class="nav-number">4.</span> <span class="nav-text">安装beta或者RC版本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于优化"><span class="nav-number">5.</span> <span class="nav-text">关于优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优化你的Go代码"><span class="nav-number">6.</span> <span class="nav-text">优化你的Go代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分析Go代码"><span class="nav-number">7.</span> <span class="nav-text">分析Go代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准库net-http-pprof"><span class="nav-number">8.</span> <span class="nav-text">标准库net/http/pprof</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代码分析示例"><span class="nav-number">9.</span> <span class="nav-text">代码分析示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用于分析的第三方包"><span class="nav-number">10.</span> <span class="nav-text">用于分析的第三方包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go分析器的web接口"><span class="nav-number">11.</span> <span class="nav-text">Go分析器的web接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用web接口的分析示例"><span class="nav-number">12.</span> <span class="nav-text">使用web接口的分析示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Graphviz快览"><span class="nav-number">13.</span> <span class="nav-text">Graphviz快览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#go-tool的代码追踪"><span class="nav-number">14.</span> <span class="nav-text">go tool的代码追踪</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试"><span class="nav-number">15.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编写测试代码"><span class="nav-number">16.</span> <span class="nav-text">编写测试代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基准测试"><span class="nav-number">17.</span> <span class="nav-text">基准测试</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基准测试示例"><span class="nav-number">18.</span> <span class="nav-text">基准测试示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误的基准测试函数"><span class="nav-number">19.</span> <span class="nav-text">错误的基准测试函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基准测试的缓冲写入"><span class="nav-number">20.</span> <span class="nav-text">基准测试的缓冲写入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#揪出隐藏的代码"><span class="nav-number">21.</span> <span class="nav-text">揪出隐藏的代码</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#交叉编译"><span class="nav-number">22.</span> <span class="nav-text">交叉编译</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建示例函数"><span class="nav-number">23.</span> <span class="nav-text">创建示例函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#生成文档"><span class="nav-number">24.</span> <span class="nav-text">生成文档</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#延展阅读"><span class="nav-number">25.</span> <span class="nav-text">延展阅读</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习"><span class="nav-number">26.</span> <span class="nav-text">练习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小节"><span class="nav-number">27.</span> <span class="nav-text">本章小节</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">5.4m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">81:08</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
