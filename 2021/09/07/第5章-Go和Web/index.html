<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go语言高级编程">
<meta property="og:type" content="article">
<meta property="og:title" content="第5章 Go和Web">
<meta property="og:url" content="http://yoursite.com/2021/09/07/第5章-Go和Web/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/1.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/2.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/3.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/4.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/5.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/6.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/7.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/8.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/9.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-04-validate-struct-tree.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch5-token-bucket.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-08-frontend-backend.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-08-controller-logic-dao.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-08-control-flow.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-08-code-gen.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-08-code-gen-2.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-08-control-flow-2.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch6-interface-impl.uml.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch5-online-group.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch5-set-time-line.png">
<meta property="og:image" content="http://yoursite.com/2021/09/07/images/ch5-set-time-line_2.png">
<meta property="og:updated_time" content="2022-02-08T13:57:08.268Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第5章 Go和Web">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="twitter:image" content="http://yoursite.com/2021/09/07/第5章-Go和Web/1.png">






  <link rel="canonical" href="http://yoursite.com/2021/09/07/第5章-Go和Web/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第5章 Go和Web | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/07/第5章-Go和Web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第5章 Go和Web

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-07 11:56:55" itemprop="dateCreated datePublished" datetime="2021-09-07T11:56:55+08:00">2021-09-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2022-02-08 21:57:08" itemprop="dateModified" datetime="2022-02-08T21:57:08+08:00">2022-02-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">54k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">49 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<h1 id="Web开发简介"><a href="#Web开发简介" class="headerlink" title="Web开发简介"></a>Web开发简介</h1><p>使用Go的<code>net/http</code>包写一个简单的<code>http echo server</code>只需要30s。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    msg, err := ioutil.ReadAll(r.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        wr.Write([]<span class="keyword">byte</span>(<span class="string">"echo error"</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeLen, err := wr.Write(msg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || writeLen != <span class="built_in">len</span>(msg) &#123;</span><br><span class="line">        log.Println(err, <span class="string">"write len:"</span>, writeLen)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, echo)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子是为了说明在Go中写一个HTTP协议的小程序有多么简单。如果你面临的情况比较复杂，例如几十个接口的企业级应用，直接用<code>net/http</code>库就显得不太合适了。</p>
<p>我们来看看开源社区中一个Kafka监控项目中的做法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Burrow: http_server.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHttpServer</span><span class="params">(app *ApplicationContext)</span> <span class="params">(*HttpServer, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    server.mux.HandleFunc(<span class="string">"/"</span>, handleDefault)</span><br><span class="line"></span><br><span class="line">    server.mux.HandleFunc(<span class="string">"/burrow/admin"</span>, handleAdmin)</span><br><span class="line"></span><br><span class="line">    server.mux.Handle(<span class="string">"/v2/kafka"</span>, appHandler&#123;server.app, handleClusterList&#125;)</span><br><span class="line">    server.mux.Handle(<span class="string">"/v2/kafka/"</span>, appHandler&#123;server.app, handleKafka&#125;)</span><br><span class="line">    server.mux.Handle(<span class="string">"/v2/zookeeper"</span>, appHandler&#123;server.app, handleClusterList&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码来自大名鼎鼎的linkedin公司的Kafka监控项目Burrow，没有使用任何router框架，只使用了<code>net/http</code>。只看上面这段代码似乎非常优雅，我们的项目里大概只有这五个简单的URI，所以我们提供的服务就是下面这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">/burrow/admin</span><br><span class="line">/v2/kafka</span><br><span class="line">/v2/kafka/</span><br><span class="line">/v2/zookeeper</span><br></pre></td></tr></table></figure>
<p>如果你确实这么想的话就被骗了。我们再进<code>handleKafka()</code>这个函数一探究竟：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleKafka</span><span class="params">(app *ApplicationContext, w http.ResponseWriter, r *http.Request)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    pathParts := strings.Split(r.URL.Path[<span class="number">1</span>:], <span class="string">"/"</span>)</span><br><span class="line">    <span class="keyword">if</span> _, ok := app.Config.Kafka[pathParts[<span class="number">2</span>]]; !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> makeErrorResponse(http.StatusNotFound, <span class="string">"cluster not found"</span>, w, r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> pathParts[<span class="number">2</span>] == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="comment">// Allow a trailing / on requests</span></span><br><span class="line">        <span class="keyword">return</span> handleClusterList(app, w, r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(pathParts) == <span class="number">3</span>) || (pathParts[<span class="number">3</span>] == <span class="string">""</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handleClusterDetail(app, w, r, pathParts[<span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> pathParts[<span class="number">3</span>] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"consumer"</span>:</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> r.Method == <span class="string">"DELETE"</span>:</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> (<span class="built_in">len</span>(pathParts) == <span class="number">5</span>) || (pathParts[<span class="number">5</span>] == <span class="string">""</span>):</span><br><span class="line">                <span class="keyword">return</span> handleConsumerDrop(app, w, r, pathParts[<span class="number">2</span>], pathParts[<span class="number">4</span>])</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> makeErrorResponse(http.StatusMethodNotAllowed, <span class="string">"request method not supported"</span>, w, r)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> r.Method == <span class="string">"GET"</span>:</span><br><span class="line">            <span class="keyword">switch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> (<span class="built_in">len</span>(pathParts) == <span class="number">4</span>) || (pathParts[<span class="number">4</span>] == <span class="string">""</span>):</span><br><span class="line">                <span class="keyword">return</span> handleConsumerList(app, w, r, pathParts[<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">case</span> (<span class="built_in">len</span>(pathParts) == <span class="number">5</span>) || (pathParts[<span class="number">5</span>] == <span class="string">""</span>):</span><br><span class="line">                <span class="comment">// Consumer detail - list of consumer streams/hosts? Can be config info later</span></span><br><span class="line">                <span class="keyword">return</span> makeErrorResponse(http.StatusNotFound, <span class="string">"unknown API call"</span>, w, r)</span><br><span class="line">            <span class="keyword">case</span> pathParts[<span class="number">5</span>] == <span class="string">"topic"</span>:</span><br><span class="line">                <span class="keyword">switch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> (<span class="built_in">len</span>(pathParts) == <span class="number">6</span>) || (pathParts[<span class="number">6</span>] == <span class="string">""</span>):</span><br><span class="line">                    <span class="keyword">return</span> handleConsumerTopicList(app, w, r, pathParts[<span class="number">2</span>], pathParts[<span class="number">4</span>])</span><br><span class="line">                <span class="keyword">case</span> (<span class="built_in">len</span>(pathParts) == <span class="number">7</span>) || (pathParts[<span class="number">7</span>] == <span class="string">""</span>):</span><br><span class="line">                    <span class="keyword">return</span> handleConsumerTopicDetail(app, w, r, pathParts[<span class="number">2</span>], pathParts[<span class="number">4</span>], pathParts[<span class="number">6</span>])</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> pathParts[<span class="number">5</span>] == <span class="string">"status"</span>:</span><br><span class="line">                <span class="keyword">return</span> handleConsumerStatus(app, w, r, pathParts[<span class="number">2</span>], pathParts[<span class="number">4</span>], <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">case</span> pathParts[<span class="number">5</span>] == <span class="string">"lag"</span>:</span><br><span class="line">                <span class="keyword">return</span> handleConsumerStatus(app, w, r, pathParts[<span class="number">2</span>], pathParts[<span class="number">4</span>], <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> makeErrorResponse(http.StatusMethodNotAllowed, <span class="string">"request method not supported"</span>, w, r)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"topic"</span>:</span><br><span class="line">        <span class="keyword">switch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> r.Method != <span class="string">"GET"</span>:</span><br><span class="line">            <span class="keyword">return</span> makeErrorResponse(http.StatusMethodNotAllowed, <span class="string">"request method not supported"</span>, w, r)</span><br><span class="line">        <span class="keyword">case</span> (<span class="built_in">len</span>(pathParts) == <span class="number">4</span>) || (pathParts[<span class="number">4</span>] == <span class="string">""</span>):</span><br><span class="line">            <span class="keyword">return</span> handleBrokerTopicList(app, w, r, pathParts[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">case</span> (<span class="built_in">len</span>(pathParts) == <span class="number">5</span>) || (pathParts[<span class="number">5</span>] == <span class="string">""</span>):</span><br><span class="line">            <span class="keyword">return</span> handleBrokerTopicDetail(app, w, r, pathParts[<span class="number">2</span>], pathParts[<span class="number">4</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"offsets"</span>:</span><br><span class="line">        <span class="comment">// Reserving this endpoint to implement later</span></span><br><span class="line">        <span class="keyword">return</span> makeErrorResponse(http.StatusNotFound, <span class="string">"unknown API call"</span>, w, r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we fell through, return a 404</span></span><br><span class="line">    <span class="keyword">return</span> makeErrorResponse(http.StatusNotFound, <span class="string">"unknown API call"</span>, w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为默认的<code>net/http</code>包中的<code>mux</code>不支持带参数的路由，所以Burrow这个项目使用了非常蹩脚的字符串<code>Split</code>和乱七八糟的<code>switchcase</code>来达到自己的目的，但却让本来应该很集中的路由管理逻辑变得复杂，散落在系统的各处，难以维护和管理。如果读者细心地看过这些代码之后，可能会发现其它的几个<code>handler</code>函数逻辑上较简单，最复杂的也就是这个<code>handleKafka()</code>。而我们的系统总是从这样微不足道的混乱开始积少成多，最终变得难以收拾。</p>
<p>根据我们的经验，简单地来说，只要你的路由带有参数，并且这个项目的API数目超过了10，就尽量不要使用<code>net/http</code>中默认的路由。在Go开源界应用最广泛的router是httpRouter，很多开源的router框架都是基于httpRouter进行一定程度的改造的成果。关于httpRouter路由的原理，会在本章节的router一节中进行详细的阐释。</p>
<p>再来回顾一下文章开头说的，开源界有这么几种框架，第一种是对httpRouter进行简单的封装，然后提供定制的中间件和一些简单的小工具集成比如gin，主打轻量，易学，高性能。第二种是借鉴其它语言的编程风格的一些MVC类框架，例如beego，方便从其它语言迁移过来的程序员快速上手，快速开发。还有一些框架功能更为强大，除了数据库schema设计，大部分代码直接生成，例如goa。不管哪种框架，适合开发者背景的就是最好的。</p>
<p>本章的内容除了会展开讲解router和中间件的原理外，还会以现在工程界面临的问题结合Go来进行一些实践性的说明。希望能够对没有接触过相关内容的读者有所帮助。</p>
<h1 id="router请求路由"><a href="#router请求路由" class="headerlink" title="router请求路由"></a>router请求路由</h1><p>在常见的Web框架中，router是必备的组件。Go语言圈子里router也时常被称为<code>http</code>的multiplexer。在上一节中我们通过对Burrow代码的简单学习，已经知道如何用<code>http</code>标准库中内置的mux来完成简单的路由功能了。如果开发Web系统对路径中带参数没什么兴趣的话，用<code>http</code>标准库中的<code>mux</code>就可以。</p>
<p>RESTful是几年前刮起的API设计风潮，在RESTful中除了GET和POST之外，还使用了HTTP协议定义的几种其它的标准化语义。具体包括：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    MethodGet     = <span class="string">"GET"</span></span><br><span class="line">    MethodHead    = <span class="string">"HEAD"</span></span><br><span class="line">    MethodPost    = <span class="string">"POST"</span></span><br><span class="line">    MethodPut     = <span class="string">"PUT"</span></span><br><span class="line">    MethodPatch   = <span class="string">"PATCH"</span> <span class="comment">// RFC 5789</span></span><br><span class="line">    MethodDelete  = <span class="string">"DELETE"</span></span><br><span class="line">    MethodConnect = <span class="string">"CONNECT"</span></span><br><span class="line">    MethodOptions = <span class="string">"OPTIONS"</span></span><br><span class="line">    MethodTrace   = <span class="string">"TRACE"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>来看看RESTful中常见的请求路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /repos/:owner/:repo/comments/:id/reactions</span><br><span class="line"></span><br><span class="line">POST /projects/:project_id/columns</span><br><span class="line"></span><br><span class="line">PUT /user/starred/:owner/:repo</span><br><span class="line"></span><br><span class="line">DELETE /user/starred/:owner/:repo</span><br></pre></td></tr></table></figure>
<p>相信聪明的你已经猜出来了，这是Github官方文档中挑出来的几个API设计。RESTful风格的API重度依赖请求路径。会将很多参数放在请求URI中。除此之外还会使用很多并不那么常见的HTTP状态码，不过本节只讨论路由，所以先略过不谈。</p>
<p>如果我们的系统也想要这样的URI设计，使用标准库的<code>mux</code>显然就力不从心了。</p>
<h2 id="httprouter"><a href="#httprouter" class="headerlink" title="httprouter"></a>httprouter</h2><p>较流行的开源goWeb框架大多使用httprouter，或是基于httprouter的变种对路由进行支持。前面提到的github的参数式路由在httprouter中都是可以支持的。</p>
<p>因为httprouter中使用的是显式匹配，所以在设计路由的时候需要规避一些会导致路由冲突的情况，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conflict:</span><br><span class="line">GET/user/info/:name</span><br><span class="line">GET/user/:id</span><br><span class="line"></span><br><span class="line">noconflict:</span><br><span class="line">GET/user/info/:name</span><br><span class="line">POST/user/:id</span><br></pre></td></tr></table></figure>
<p>简单来讲的话，如果两个路由拥有一致的http方法(指GET/POST/PUT/DELETE)和请求路径前缀，且在某个位置出现了A路由是wildcard（指:id这种形式）参数，B路由则是普通字符串，那么就会发生路由冲突。路由冲突会在初始化阶段直接panic：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">panic:wildcardroute':id'conflictswithexistingchildreninpath'/user/:id'</span><br><span class="line"></span><br><span class="line">goroutine1[running]:</span><br><span class="line">github.com/cch123/httprouter.(*node).insertChild(0xc4200801e0,0xc42004fc01,0x126b177,0x3,0x126b171,0x9,0x127b668)</span><br><span class="line">/Users/caochunhui/go_work/src/github.com/cch123/httprouter/tree.go:256+0x841</span><br><span class="line">github.com/cch123/httprouter.(*node).addRoute(0xc4200801e0,0x126b171,0x9,0x127b668)</span><br><span class="line">/Users/caochunhui/go_work/src/github.com/cch123/httprouter/tree.go:221+0x22a</span><br><span class="line">github.com/cch123/httprouter.(*Router).Handle(0xc42004ff38,0x126a39b,0x3,0x126b171,0x9,0x127b668)</span><br><span class="line">/Users/caochunhui/go_work/src/github.com/cch123/httprouter/router.go:262+0xc3</span><br><span class="line">github.com/cch123/httprouter.(*Router).GET(0xc42004ff38,0x126b171,0x9,0x127b668)</span><br><span class="line">/Users/caochunhui/go_work/src/github.com/cch123/httprouter/router.go:193+0x5e</span><br><span class="line">main.main()</span><br><span class="line">/Users/caochunhui/test/go_web/httprouter_learn2.go:18+0xaf</span><br><span class="line">exitstatus2</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意，因为httprouter考虑到字典树的深度，在初始化时会对参数的数量进行限制，所以在路由中的参数数目不能超过255，否则会导致httprouter无法识别后续的参数。不过这一点上也不用考虑太多，毕竟URI是人设计且给人来看的，相信没有长得夸张的URI能在一条路径中带有200个以上的参数。</p>
<p>除支持路径中的wildcard参数之外，httprouter还可以支持<code>*</code>号来进行通配，不过<code>*</code>号开头的参数只能放在路由的结尾，例如下面这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pattern:/src/*filepath</span><br><span class="line"></span><br><span class="line">/src/filepath=""</span><br><span class="line">/src/somefile.gofilepath="somefile.go"</span><br><span class="line">/src/subdir/somefile.gofilepath="subdir/somefile.go"</span><br></pre></td></tr></table></figure>
<p>这种设计在RESTful中可能不太常见，主要是为了能够使用httprouter来做简单的HTTP静态文件服务器。</p>
<p>除了正常情况下的路由支持，httprouter也支持对一些特殊情况下的回调函数进行定制，例如404的时候：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r:=httprouter.New()</span><br><span class="line">r.NotFound=http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(whttp.ResponseWriter,r*http.Request)</span></span>&#123;</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">"ohno,notfound"</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>或者内部panic的时候：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.PanicHandler=<span class="function"><span class="keyword">func</span><span class="params">(whttp.ResponseWriter,r*http.Request,cinterface&#123;&#125;)</span></span>&#123;</span><br><span class="line">log.Printf(<span class="string">"Recoveringfrompanic,Reason:%#v"</span>,c.(error))</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">w.Write([]<span class="keyword">byte</span>(c.(error).Error()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前开源界最为流行（star数最多）的Web框架<a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">gin</a>使用的就是httprouter的变种。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>httprouter和众多衍生router使用的数据结构被称为压缩字典树（RadixTree）。读者可能没有接触过压缩字典树，但对字典树（TrieTree）应该有所耳闻。<em>图5-1</em>是一个典型的字典树结构：</p>
<blockquote>
<p>图5-1 字典树</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/1.png">
<p>字典树常用来进行字符串检索，例如用给定的字符串序列建立字典树。对于目标字符串，只要从根节点开始深度优先搜索，即可判断出该字符串是否曾经出现过，时间复杂度为<code>O(n)</code>，n可以认为是目标字符串的长度。为什么要这样做？字符串本身不像数值类型可以进行数值比较，两个字符串对比的时间复杂度取决于字符串长度。如果不用字典树来完成上述功能，要对历史字符串进行排序，再利用二分查找之类的算法去搜索，时间复杂度只高不低。可认为字典树是一种空间换时间的典型做法。</p>
<p>普通的字典树有一个比较明显的缺点，就是每个字母都需要建立一个孩子节点，这样会导致字典树的层数比较深，压缩字典树相对好地平衡了字典树的优点和缺点。是典型的压缩字典树结构：</p>
<blockquote>
<p>图5-2 压缩字典树</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/2.png">
<p>每个节点上不只存储一个字母了，这也是压缩字典树中“压缩”的主要含义。使用压缩字典树可以减少树的层数，同时因为每个节点上数据存储也比通常的字典树要多，所以程序的局部性较好（一个节点的path加载到cache即可进行多个字符的对比），从而对CPU缓存友好。</p>
<h2 id="压缩字典树创建过程"><a href="#压缩字典树创建过程" class="headerlink" title="压缩字典树创建过程"></a>压缩字典树创建过程</h2><p>我们来跟踪一下httprouter中，一个典型的压缩字典树的创建过程，路由设定如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT/user/installations/:installation_id/repositories/:repository_id</span><br><span class="line"></span><br><span class="line">GET/marketplace_listing/plans/</span><br><span class="line">GET/marketplace_listing/plans/:id/accounts</span><br><span class="line">GET/search</span><br><span class="line">GET/status</span><br><span class="line">GET/support</span><br><span class="line"></span><br><span class="line">补充路由：</span><br><span class="line">GET/marketplace_listing/plans/ohyes</span><br></pre></td></tr></table></figure>
<p>最后一条补充路由是我们臆想的，除此之外所有API路由均来自于<code>api.github.com</code>。</p>
<h3 id="5-2-3-1root节点创建"><a href="#5-2-3-1root节点创建" class="headerlink" title="5.2.3.1root节点创建"></a>5.2.3.1root节点创建</h3><p>httprouter的Router结构体中存储压缩字典树使用的是下述数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//略去了其它部分的Routerstruct</span></span><br><span class="line">typeRouterstruct&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">treesmap[<span class="keyword">string</span>]*node</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>trees</code>中的<code>key</code>即为HTTP1.1的RFC中定义的各种方法，具体有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">HEAD</span><br><span class="line">OPTIONS</span><br><span class="line">POST</span><br><span class="line">PUT</span><br><span class="line">PATCH</span><br><span class="line">DELETE</span><br></pre></td></tr></table></figure>
<p>每一种方法对应的都是一棵独立的压缩字典树，这些树彼此之间不共享数据。具体到我们上面用到的路由，<code>PUT</code>和<code>GET</code>是两棵树而非一棵。</p>
<p>简单来讲，某个方法第一次插入的路由就会导致对应字典树的根节点被创建，我们按顺序，先是一个<code>PUT</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r:=httprouter.New()</span><br><span class="line">r.PUT(<span class="string">"/user/installations/:installation_id/repositories/:reposit"</span>,Hello)</span><br></pre></td></tr></table></figure>
<p>这样<code>PUT</code>对应的根节点就会被创建出来。把这棵<code>PUT</code>的树画出来：</p>
<blockquote>
<p>图5-3 插入路由之后的压缩字典树</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/3.png">
<p>radix的节点类型为<code>*httprouter.node</code>，为了说明方便，我们留下了目前关心的几个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">path:当前节点对应的路径中的字符串</span><br><span class="line"></span><br><span class="line">wildChild:子节点是否为参数节点，即wildcardnode，或者说:id这种类型的节点</span><br><span class="line"></span><br><span class="line">nType:当前节点类型，有四个枚举值:分别为static/root/param/catchAll。</span><br><span class="line">static//非根节点的普通字符串节点</span><br><span class="line">root//根节点</span><br><span class="line">param//参数节点，例如:id</span><br><span class="line">catchAll//通配符节点，例如*anyway</span><br><span class="line"></span><br><span class="line">indices：子节点索引，当子节点为非参数类型，即本节点的wildChild为false时，会将每个子节点的首字母放在该索引数组。说是数组，实际上是个string。</span><br></pre></td></tr></table></figure>
<p>当然，<code>PUT</code>路由只有唯一的一条路径。接下来，我们以后续的多条GET路径为例，讲解子节点的插入过程。</p>
<h3 id="子节点插入"><a href="#子节点插入" class="headerlink" title="子节点插入"></a>子节点插入</h3><p>当插入<code>GET/marketplace_listing/plans</code>时，类似前面PUT的过程，GET树的结构如<em>图5-4</em>：</p>
<blockquote>
<p>图5-4 插入第一个节点的压缩字典树</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/4.png">
<p>因为第一个路由没有参数，path都被存储到根节点上了。所以只有一个节点。</p>
<p>然后插入<code>GET/marketplace_listing/plans/:id/accounts</code>，新的路径与之前的路径有共同的前缀，且可以直接在之前叶子节点后进行插入，那么结果也很简单，插入后的树结构见<em>图5-5</em>:</p>
<blockquote>
<p>图5-5 插入第二个节点的压缩字典树</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/5.png">
<p>由于<code>:id</code>这个节点只有一个字符串的普通子节点，所以indices还依然不需要处理。</p>
<p>上面这种情况比较简单，新的路由可以直接作为原路由的子节点进行插入。实际情况不会这么美好。</p>
<h3 id="边分裂"><a href="#边分裂" class="headerlink" title="边分裂"></a>边分裂</h3><p>接下来我们插入<code>GET/search</code>，这时会导致树的边分裂，见<em>图5-6</em>。</p>
<blockquote>
<p>图5-6 插入第三个节点，导致边分裂</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/6.png">
<p>原有路径和新的路径在初始的<code>/</code>位置发生分裂，这样需要把原有的root节点内容下移，再将新路由<code>search</code>同样作为子节点挂在root节点之下。这时候因为子节点出现多个，root节点的indices提供子节点索引，这时候该字段就需要派上用场了。”ms”代表子节点的首字母分别为m（marketplace）和s（search）。</p>
<p>我们一口作气，把<code>GET/status</code>和<code>GET/support</code>也插入到树中。这时候会导致在<code>search</code>节点上再次发生分裂，最终结果见<em>图5-7</em>：</p>
<blockquote>
<p>图5-7插入所有路由后的压缩字典树</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/7.png">
<h3 id="子节点冲突处理"><a href="#子节点冲突处理" class="headerlink" title="子节点冲突处理"></a>子节点冲突处理</h3><p>在路由本身只有字符串的情况下，不会发生任何冲突。只有当路由中含有wildcard（类似:id）或者catchAll的情况下才可能冲突。这一点在前面已经提到了。</p>
<p>子节点的冲突处理很简单，分几种情况：</p>
<p>1.在插入wildcard节点时，父节点的children数组非空且wildChild被设置为false。例如：<code>GET/user/getAll</code>和<code>GET/user/:id/getAddr</code>，或者<code>GET/user/*aaa</code>和<code>GET/user/:id</code>。<br>2.在插入wildcard节点时，父节点的children数组非空且wildChild被设置为true，但该父节点的wildcard子节点要插入的wildcard名字不一样。例如：<code>GET/user/:id/info</code>和<code>GET/user/:name/info</code>。<br>3.在插入catchAll节点时，父节点的children非空。例如：<code>GET/src/abc</code>和<code>GET/src/*filename</code>，或者<code>GET/src/:id</code>和<code>GET/src/*filename</code>。<br>4.在插入static节点时，父节点的wildChild字段被设置为true。<br>5.在插入static节点时，父节点的children非空，且子节点nType为catchAll。</p>
<p>只要发生冲突，都会在初始化的时候panic。例如，在插入我们臆想的路由<code>GET/marketplace_listing/plans/ohyes</code>时，出现第4种冲突情况：它的父节点<code>marketplace_listing/plans/</code>的wildChild字段为true。</p>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>本章将对现在流行的Web框架中的中间件（middleware）技术原理进行分析，并介绍如何使用中间件技术将业务和非业务代码功能进行解耦。</p>
<h2 id="代码泥潭"><a href="#代码泥潭" class="headerlink" title="代码泥潭"></a>代码泥潭</h2><p>先来看一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// middleware/hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    wr.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, hello)</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个典型的Web服务，挂载了一个简单的路由。我们的线上服务一般也是从这样简单的服务开始逐渐拓展开去的。</p>
<p>现在突然来了一个新的需求，我们想要统计之前写的hello服务的处理耗时，需求很简单，我们对上面的程序进行少量修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// middleware/hello_with_time_elapse.go</span></span><br><span class="line"><span class="keyword">var</span> logger = log.New(os.Stdout, <span class="string">""</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    timeStart := time.Now()</span><br><span class="line">    wr.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">    timeElapsed := time.Since(timeStart)</span><br><span class="line">    logger.Println(timeElapsed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便可以在每次接收到http请求时，打印出当前请求所消耗的时间。</p>
<p>完成了这个需求之后，我们继续进行业务开发，提供的API逐渐增加，现在我们的路由看起来是这个样子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// middleware/hello_with_more_routes.go</span></span><br><span class="line"><span class="comment">// 省略了一些相同的代码</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showInfoHandler</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showEmailHandler</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showFriendsHandler</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    timeStart := time.Now()</span><br><span class="line">    wr.Write([]<span class="keyword">byte</span>(<span class="string">"your friends is tom and alex"</span>))</span><br><span class="line">    timeElapsed := time.Since(timeStart)</span><br><span class="line">    logger.Println(timeElapsed)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, helloHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">"/info/show"</span>, showInfoHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">"/email/show"</span>, showEmailHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">"/friends/show"</span>, showFriendsHandler)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个handler里都有之前提到的记录运行时间的代码，每次增加新的路由我们也同样需要把这些看起来长得差不多的代码拷贝到我们需要的地方去。因为代码不太多，所以实施起来也没有遇到什么大问题。</p>
<p>渐渐的我们的系统增加到了30个路由和<code>handler</code>函数，每次增加新的handler，我们的第一件工作就是把之前写的所有和业务逻辑无关的周边代码先拷贝过来。</p>
<p>接下来系统安稳地运行了一段时间，突然有一天，老板找到你，我们最近找人新开发了监控系统，为了系统运行可以更加可控，需要把每个接口运行的耗时数据主动上报到我们的监控系统里。给监控系统起个名字吧，叫metrics。现在你需要修改代码并把耗时通过HTTPPost的方式发给metrics系统了。我们来修改一下<code>helloHandler()</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    timeStart := time.Now()</span><br><span class="line">    wr.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">    timeElapsed := time.Since(timeStart)</span><br><span class="line">    logger.Println(timeElapsed)</span><br><span class="line">    <span class="comment">// 新增耗时上报</span></span><br><span class="line">    metrics.Upload(<span class="string">"timeHandler"</span>, timeElapsed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改到这里，本能地发现我们的开发工作开始陷入了泥潭。无论未来对我们的这个Web系统有任何其它的非功能或统计需求，我们的修改必然牵一发而动全身。只要增加一个非常简单的非业务统计，我们就需要去几十个handler里增加这些业务无关的代码。虽然一开始我们似乎并没有做错，但是显然随着业务的发展，我们的行事方式让我们陷入了代码的泥潭。</p>
<h2 id="使用中间件剥离非业务逻辑"><a href="#使用中间件剥离非业务逻辑" class="headerlink" title="使用中间件剥离非业务逻辑"></a>使用中间件剥离非业务逻辑</h2><p>我们来分析一下，一开始在哪里做错了呢？我们只是一步一步地满足需求，把我们需要的逻辑按照流程写下去呀？</p>
<p>我们犯的最大的错误，是把业务代码和非业务代码揉在了一起。对于大多数的场景来讲，非业务的需求都是在http请求处理前做一些事情，并且在响应完成之后做一些事情。我们有没有办法使用一些重构思路把这些公共的非业务功能代码剥离出去呢？回到刚开头的例子，我们需要给我们的<code>helloHandler()</code>增加超时时间统计，我们可以使用一种叫<code>functionadapter</code>的方法来对<code>helloHandler()</code>进行包装：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    wr.Write([]<span class="keyword">byte</span>(<span class="string">"hello"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeMiddleware</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(wr http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        timeStart := time.Now()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next handler</span></span><br><span class="line">        next.ServeHTTP(wr, r)</span><br><span class="line"></span><br><span class="line">        timeElapsed := time.Since(timeStart)</span><br><span class="line">        logger.Println(timeElapsed)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">"/"</span>, timeMiddleware(http.HandlerFunc(hello)))</span><br><span class="line">    err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就非常轻松地实现了业务与非业务之间的剥离，魔法就在于这个<code>timeMiddleware</code>。可以从代码中看到，我们的<code>timeMiddleware()</code>也是一个函数，其参数为<code>http.Handler</code>，<code>http.Handler</code>的定义在<code>net/http</code>包中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何方法实现了<code>ServeHTTP</code>，即是一个合法的<code>http.Handler</code>，读到这里你可能会有一些混乱，我们先来梳理一下http库的<code>Handler</code>，<code>HandlerFunc</code>和<code>ServeHTTP</code>的关系：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要你的handler函数签名是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure>
<p>那么这个<code>handler</code>和<code>http.HandlerFunc()</code>就有了一致的函数签名，可以将该<code>handler()</code>函数进行类型转换，转为<code>http.HandlerFunc</code>。而<code>http.HandlerFunc</code>实现了<code>http.Handler</code>这个接口。在<code>http</code>库需要调用你的handler函数来处理http请求时，会调用<code>HandlerFunc()</code>的<code>ServeHTTP()</code>函数，可见一个请求的基本调用链是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = getHandler() =&gt; h.ServeHTTP(w, r) =&gt; h(w, r)</span><br></pre></td></tr></table></figure>
<p>上面提到的把自定义<code>handler</code>转换为<code>http.HandlerFunc()</code>这个过程是必须的，因为我们的<code>handler</code>没有直接实现<code>ServeHTTP</code>这个接口。上面的代码中我们看到的HandleFunc(注意HandlerFunc和HandleFunc的区别)里也可以看到这个强制转换过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>知道handler是怎么一回事，我们的中间件通过包装handler，再返回一个新的handler就好理解了。</p>
<p>总结一下，我们的中间件要做的事情就是通过一个或多个函数对handler进行包装，返回一个包括了各个中间件逻辑的函数链。我们把上面的包装再做得复杂一些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customizedHandler = logger(timeout(ratelimit(helloHandler)))</span><br></pre></td></tr></table></figure>
<p>这个函数链在执行过程中的上下文可以用<em>图5-8</em>来表示。</p>
<blockquote>
<p>图5-8 请求处理过程</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/8.png">
<p>再直白一些，这个流程在进行请求处理的时候就是不断地进行函数压栈再出栈，有一些类似于递归的执行流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[exec of logger logic]         函数栈: []</span><br><span class="line"></span><br><span class="line">[exec of timeout logic]       函数栈: [logger]</span><br><span class="line"></span><br><span class="line">[exec of ratelimit logic]       函数栈: [timeout/logger]</span><br><span class="line"></span><br><span class="line">[exec of helloHandler logic]     函数栈: [ratelimit/timeout/logger]</span><br><span class="line"></span><br><span class="line">[exec of ratelimit logic part2]  函数栈: [timeout/logger]</span><br><span class="line"></span><br><span class="line">[exec of timeout logic part2]   函数栈: [logger]</span><br><span class="line"></span><br><span class="line">[exec of logger logic part2]     函数栈: []</span><br></pre></td></tr></table></figure>
<p>功能实现了，但在上面的使用过程中我们也看到了，这种函数套函数的用法不是很美观，同时也不具备什么可读性。</p>
<h2 id="更优雅的中间件写法"><a href="#更优雅的中间件写法" class="headerlink" title="更优雅的中间件写法"></a>更优雅的中间件写法</h2><p>上一节中解决了业务功能代码和非业务功能代码的解耦，但也提到了，看起来并不美观，如果需要修改这些函数的顺序，或者增删中间件还是有点费劲，本节我们来进行一些“写法”上的优化。</p>
<p>看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = NewRouter()</span><br><span class="line">r.Use(logger)</span><br><span class="line">r.Use(timeout)</span><br><span class="line">r.Use(ratelimit)</span><br><span class="line">r.Add(<span class="string">"/"</span>, helloHandler)</span><br></pre></td></tr></table></figure>
<p>通过多步设置，我们拥有了和上一节差不多的执行函数链。胜在直观易懂，如果我们要增加或者删除中间件，只要简单地增加删除对应的<code>Use()</code>调用就可以了。非常方便。</p>
<p>从框架的角度来讲，怎么实现这样的功能呢？也不复杂：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> middleware <span class="function"><span class="keyword">func</span><span class="params">(http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Router</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    middlewareChain [] middleware</span><br><span class="line">    mux <span class="keyword">map</span>[<span class="keyword">string</span>] http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Router&#123;</span><br><span class="line">        mux: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]http.Handler),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Use</span><span class="params">(m middleware)</span></span> &#123;</span><br><span class="line">    r.middlewareChain = <span class="built_in">append</span>(r.middlewareChain, m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Router)</span> <span class="title">Add</span><span class="params">(route <span class="keyword">string</span>, h http.Handler)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mergedHandler = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(r.middlewareChain) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        mergedHandler = r.middlewareChain[i](mergedHandler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.mux[route] = mergedHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意代码中的<code>middleware</code>数组遍历顺序，和用户希望的调用顺序应该是”相反”的。应该不难理解。</p>
<h2 id="哪些事情适合在中间件中做"><a href="#哪些事情适合在中间件中做" class="headerlink" title="哪些事情适合在中间件中做"></a>哪些事情适合在中间件中做</h2><p>以较流行的开源Go语言框架chi为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">compress.go</span><br><span class="line">  =&gt; 对 http 的响应体进行压缩处理</span><br><span class="line">heartbeat.go</span><br><span class="line">  =&gt; 设置一个特殊的路由，例如 / ping，/healthcheck，用来给负载均衡一类的前置服务进行探活</span><br><span class="line">logger.go</span><br><span class="line">  =&gt; 打印请求处理处理日志，例如请求处理时间，请求路由</span><br><span class="line">profiler.go</span><br><span class="line">  =&gt; 挂载 pprof 需要的路由，如 `/pprof`、`/pprof/trace` 到系统中</span><br><span class="line">realip.go</span><br><span class="line">  =&gt; 从请求头中读取 X-Forwarded-For 和 X-Real-IP，将 http.Request 中的 RemoteAddr 修改为得到的 RealIP</span><br><span class="line">requestid.go</span><br><span class="line">  =&gt; 为本次请求生成单独的 requestid，可一路透传，用来生成分布式调用链路，也可用于在日志中串连单次请求的所有逻辑</span><br><span class="line">timeout.go</span><br><span class="line">  =&gt; 用 context.Timeout 设置超时时间，并将其通过 http.Request 一路透传下去</span><br><span class="line">throttler.go</span><br><span class="line">  =&gt; 通过定长大小的 channel 存储 token，并通过这些 token 对接口进行限流</span><br></pre></td></tr></table></figure>
<p>每一个Web框架都会有对应的中间件组件，如果你有兴趣，也可以向这些项目贡献有用的中间件，只要合理一般项目的维护人也愿意合并你的PullRequest。</p>
<p>比如开源界很火的gin这个框架，就专门为用户贡献的中间件开了一个仓库，见<em>图5-9</em>：</p>
<blockquote>
<p>图5-9 gin的中间件仓库</p>
</blockquote>
<img src="/2021/09/07/第5章-Go和Web/9.png">
<p>如果读者去阅读gin的源码的话，可能会发现gin的中间件中处理的并不是<code>http.Handler</code>，而是一个叫<code>gin.HandlerFunc</code>的函数类型，和本节中讲解的<code>http.Handler</code>签名并不一样。不过gin的<code>handler</code>也只是针对其框架的一种封装，中间件的原理与本节中的说明是一致的。</p>
<h1 id="validator请求校验"><a href="#validator请求校验" class="headerlink" title="validator请求校验"></a>validator请求校验</h1><p>社区里曾经有人用<em>图5-10</em>来嘲笑PHP：</p>
<blockquote>
<p>图5-10 validator流程</p>
</blockquote>

<p>这其实是一个语言无关的场景，需要进行字段校验的情况有很多，Web系统的Form或JSON提交只是一个典型的例子。我们用Go来写一个类似上图的校验示例。然后研究怎么一步步对其进行改进。</p>
<h2 id="5-4-1重构请求校验函数"><a href="#5-4-1重构请求校验函数" class="headerlink" title="5.4.1重构请求校验函数"></a>5.4.1重构请求校验函数</h2><p>假设我们的数据已经通过某个开源绑定库绑定到了具体的结构体上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typeRegisterReqstruct&#123;</span><br><span class="line">Usernamestring<span class="string">`json:"username"`</span></span><br><span class="line">PasswordNewstring<span class="string">`json:"password_new"`</span></span><br><span class="line">PasswordRepeatstring<span class="string">`json:"password_repeat"`</span></span><br><span class="line">Emailstring<span class="string">`json:"email"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcregister(reqRegisterReq)error&#123;</span><br><span class="line">iflen(req.Username)&gt;<span class="number">0</span>&#123;</span><br><span class="line">iflen(req.PasswordNew)&gt;<span class="number">0</span>&amp;&amp;<span class="built_in">len</span>(req.PasswordRepeat)&gt;<span class="number">0</span>&#123;</span><br><span class="line">ifreq.PasswordNew==req.PasswordRepeat&#123;</span><br><span class="line">ifemailFormatValid(req.Email)&#123;</span><br><span class="line">createUser()</span><br><span class="line">returnnil</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">returnerrors.New(<span class="string">"invalidemail"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">returnerrors.New(<span class="string">"passwordandreinputmustbethesame"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">returnerrors.New(<span class="string">"passwordandpasswordreinputmustbelongerthan0"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">returnerrors.New(<span class="string">"lengthofusernamecannotbe0"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用Go里成功写出了波动拳开路的箭头型代码。。这种代码一般怎么进行优化呢？</p>
<p>很简单，在《重构》一书中已经给出了方案：<a href="https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html" target="_blank" rel="noopener">GuardClauses</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">funcregister(reqRegisterReq)error&#123;</span><br><span class="line">iflen(req.Username)==<span class="number">0</span>&#123;</span><br><span class="line">returnerrors.New(<span class="string">"lengthofusernamecannotbe0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iflen(req.PasswordNew)==<span class="number">0</span>||<span class="built_in">len</span>(req.PasswordRepeat)==<span class="number">0</span>&#123;</span><br><span class="line">returnerrors.New(<span class="string">"passwordandpasswordreinputmustbelongerthan0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifreq.PasswordNew!=req.PasswordRepeat&#123;</span><br><span class="line">returnerrors.New(<span class="string">"passwordandreinputmustbethesame"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifemailFormatValid(req.Email)&#123;</span><br><span class="line">returnerrors.New(<span class="string">"invalidemail"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createUser()</span><br><span class="line">returnnil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码更清爽，看起来也不那么别扭了。这是比较通用的重构理念。虽然使用了重构方法使我们的校验过程代码看起来优雅了，但我们还是得为每一个<code>http</code>请求都去写这么一套差不多的<code>validate()</code>函数，有没有更好的办法来帮助我们解除这项体力劳动？答案就是validator。</p>
<h2 id="5-4-2用validator解放体力劳动"><a href="#5-4-2用validator解放体力劳动" class="headerlink" title="5.4.2用validator解放体力劳动"></a>5.4.2用validator解放体力劳动</h2><p>从设计的角度讲，我们一定会为每个请求都声明一个结构体。前文中提到的校验场景我们都可以通过validator完成工作。还以前文中的结构体为例。为了美观起见，我们先把jsontag省略掉。</p>
<p>这里我们引入一个新的validator库：</p>
<blockquote>
<p><a href="https://github.com/go-playground/validator" target="_blank" rel="noopener">https://github.com/go-playground/validator</a></p>
</blockquote>
<p>使用<code>gogetgithub.com/go-playground/validator/v10</code>可以下载validator库。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span><span class="string">"github.com/go-playground/validator/v10"</span></span><br><span class="line"></span><br><span class="line">typeRegisterReqstruct&#123;</span><br><span class="line"><span class="comment">//字符串的gt=0表示长度必须&gt;0，gt=greaterthan</span></span><br><span class="line">Usernamestring<span class="string">`validate:"gt=0"`</span></span><br><span class="line"><span class="comment">//同上</span></span><br><span class="line">PasswordNewstring<span class="string">`validate:"gt=0"`</span></span><br><span class="line"><span class="comment">//eqfield跨字段相等校验</span></span><br><span class="line">PasswordRepeatstring<span class="string">`validate:"eqfield=PasswordNew"`</span></span><br><span class="line"><span class="comment">//合法email格式校验</span></span><br><span class="line">Emailstring<span class="string">`validate:"email"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">varvalidate=validator.New()</span><br><span class="line"></span><br><span class="line">funcvalidateFunc(reqRegisterReq)error&#123;</span><br><span class="line">err:=validate.Struct(req)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">doSomething()</span><br><span class="line">returnerr</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不需要在每个请求进入业务逻辑之前都写重复的<code>validate()</code>函数了。本例中只列出了这个校验器非常简单的几个功能。</p>
<p>我们试着跑一下这个程序，输入参数设置为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">varreq=RegisterReq&#123;</span><br><span class="line">Username:<span class="string">"Xargin"</span>,</span><br><span class="line">PasswordNew:<span class="string">"ohno"</span>,</span><br><span class="line">PasswordRepeat:<span class="string">"ohn"</span>,</span><br><span class="line">Email:<span class="string">"alex@abc.com"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err:=validateFunc(req)</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Key:'RegisterReq.PasswordRepeat'Error:Fieldvalidationfor</span></span><br><span class="line"><span class="comment">//'PasswordRepeat'failedonthe'eqfield'tag</span></span><br></pre></td></tr></table></figure>
<p>如果觉得这个<code>validator</code>提供的错误信息不够人性化，例如要把错误信息返回给用户，那就不应该直接显示英文了。可以针对每种tag进行错误信息定制，读者可以自行探索。</p>
<h2 id="5-4-3原理"><a href="#5-4-3原理" class="headerlink" title="5.4.3原理"></a>5.4.3原理</h2><p>从结构上来看，每一个结构体都可以看成是一棵树。假如我们有如下定义的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeNestedstruct&#123;</span><br><span class="line">Emailstring<span class="string">`validate:"email"`</span></span><br><span class="line">&#125;</span><br><span class="line">typeTstruct&#123;</span><br><span class="line">Ageint<span class="string">`validate:"eq=10"`</span></span><br><span class="line">NestedNested</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把这个结构体画成一棵树，见<em>图5-11</em>：</p>
<p><img src="../images/ch6-04-validate-struct-tree.png" alt="struct-tree"></p>
<p><em>图5-11validator树</em></p>
<p>从字段校验的需求来讲，无论我们采用深度优先搜索还是广度优先搜索来对这棵结构体树来进行遍历，都是可以的。</p>
<p>我们来写一个递归的深度优先搜索方式的遍历示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">typeNestedstruct&#123;</span><br><span class="line">Emailstring<span class="string">`validate:"email"`</span></span><br><span class="line">&#125;</span><br><span class="line">typeTstruct&#123;</span><br><span class="line">Ageint<span class="string">`validate:"eq=10"`</span></span><br><span class="line">NestedNested</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcvalidateEmail(inputstring)<span class="keyword">bool</span>&#123;</span><br><span class="line">ifpass,_:=regexp.MatchString(</span><br><span class="line"><span class="string">`^([\w\.\_]&#123;2,10&#125;)@(\w&#123;1,&#125;).([a-z]&#123;2,4&#125;)$`</span>,input,</span><br><span class="line">);pass&#123;</span><br><span class="line">returntrue</span><br><span class="line">&#125;</span><br><span class="line">returnfalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcvalidate(vinterface&#123;&#125;)(<span class="keyword">bool</span>,<span class="keyword">string</span>)&#123;</span><br><span class="line">validateResult:=<span class="literal">true</span></span><br><span class="line">errmsg:=<span class="string">"success"</span></span><br><span class="line">vt:=reflect.TypeOf(v)</span><br><span class="line">vv:=reflect.ValueOf(v)</span><br><span class="line">fori:=<span class="number">0</span>;i&lt;vv.NumField();i++&#123;</span><br><span class="line">fieldVal:=vv.Field(i)</span><br><span class="line">tagContent:=vt.Field(i).Tag.Get(<span class="string">"validate"</span>)</span><br><span class="line">k:=fieldVal.Kind()</span><br><span class="line"></span><br><span class="line">switchk&#123;</span><br><span class="line">casereflect.Int:</span><br><span class="line">val:=fieldVal.Int()</span><br><span class="line">tagValStr:=strings.Split(tagContent,<span class="string">"="</span>)</span><br><span class="line">tagVal,_:=strconv.ParseInt(tagValStr[<span class="number">1</span>],<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">ifval!=tagVal&#123;</span><br><span class="line">errmsg=<span class="string">"validateintfailed,tagis:"</span>+strconv.FormatInt(</span><br><span class="line">tagVal,<span class="number">10</span>,</span><br><span class="line">)</span><br><span class="line">validateResult=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">casereflect.String:</span><br><span class="line">val:=fieldVal.String()</span><br><span class="line">tagValStr:=tagContent</span><br><span class="line">switchtagValStr&#123;</span><br><span class="line"><span class="keyword">case</span><span class="string">"email"</span>:</span><br><span class="line">nestedResult:=validateEmail(val)</span><br><span class="line">ifnestedResult==<span class="literal">false</span>&#123;</span><br><span class="line">errmsg=<span class="string">"validatemailfailed,fieldvalis:"</span>+val</span><br><span class="line">validateResult=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">casereflect.Struct:</span><br><span class="line"><span class="comment">//如果有内嵌的struct，那么深度优先遍历</span></span><br><span class="line"><span class="comment">//就是一个递归过程</span></span><br><span class="line">valInter:=fieldVal.Interface()</span><br><span class="line">nestedResult,msg:=validate(valInter)</span><br><span class="line">ifnestedResult==<span class="literal">false</span>&#123;</span><br><span class="line">validateResult=<span class="literal">false</span></span><br><span class="line">errmsg=msg</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">returnvalidateResult,errmsg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcmain()&#123;</span><br><span class="line">vara=T&#123;Age:<span class="number">10</span>,Nested:Nested&#123;Email:<span class="string">"abc@abc.com"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">validateResult,errmsg:=validate(a)</span><br><span class="line">fmt.Println(validateResult,errmsg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们简单地对<code>eq=x</code>和<code>email</code>这两个tag进行了支持，读者可以对这个程序进行简单的修改以查看具体的validate效果。为了演示精简掉了错误处理和复杂情况的处理，例如<code>reflect.Int8/16/32/64</code>，<code>reflect.Ptr</code>等类型的处理，如果给生产环境编写校验库的话，请务必做好功能的完善和容错。</p>
<p>在前一小节中介绍的开源校验组件在功能上要远比我们这里的例子复杂的多。但原理很简单，就是用反射对结构体进行树形遍历。有心的读者这时候可能会产生一个问题，我们对结构体进行校验时大量使用了反射，而Go的反射在性能上不太出众，有时甚至会影响到我们程序的性能。这样的考虑确实有一些道理，但需要对结构体进行大量校验的场景往往出现在Web服务，这里并不一定是程序的性能瓶颈所在，实际的效果还是要从pprof中做更精确的判断。</p>
<p>如果基于反射的校验真的成为了你服务的性能瓶颈怎么办？现在也有一种思路可以避免反射：使用Go内置的Parser对源代码进行扫描，然后根据结构体的定义生成校验代码。我们可以将所有需要校验的结构体放在单独的包内。这就交给读者自己去探索了。</p>
<h1 id="5-5Database和数据库打交道"><a href="#5-5Database和数据库打交道" class="headerlink" title="5.5Database和数据库打交道"></a>5.5Database和数据库打交道</h1><p>本节将对<code>db/sql</code>官方标准库作一些简单分析，并介绍一些应用比较广泛的开源ORM和SQLBuilder。并从企业级应用开发和公司架构的角度来分析哪种技术栈对于现代的企业级应用更为合适。</p>
<h2 id="5-5-1从database-sql讲起"><a href="#5-5-1从database-sql讲起" class="headerlink" title="5.5.1从database/sql讲起"></a>5.5.1从database/sql讲起</h2><p>Go官方提供了<code>database/sql</code>包来给用户进行和数据库打交道的工作，<code>database/sql</code>库实际只提供了一套操作数据库的接口和规范，例如抽象好的SQL预处理（prepare），连接池管理，数据绑定，事务，错误处理等等。官方并没有提供具体某种数据库实现的协议支持。</p>
<p>和具体的数据库，例如MySQL打交道，还需要再引入MySQL的驱动，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span><span class="string">"database/sql"</span></span><br><span class="line">import_<span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line"></span><br><span class="line">db,err:=sql.Open(<span class="string">"mysql"</span>,<span class="string">"user:password@/dbname"</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import_<span class="string">"github.com/go-sql-driver/mysql"</span></span><br></pre></td></tr></table></figure>
<p>这条import语句会调用了<code>mysql</code>包的<code>init</code>函数，做的事情也很简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funcinit()&#123;</span><br><span class="line">sql.Register(<span class="string">"mysql"</span>,&amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>sql</code>包的全局<code>map</code>里把<code>mysql</code>这个名字的<code>driver</code>注册上。<code>Driver</code>在<code>sql</code>包中是一个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeDriverinterface&#123;</span><br><span class="line">Open(namestring)(Conn,error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>sql.Open()</code>返回的<code>db</code>对象就是这里的<code>Conn</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeConninterface&#123;</span><br><span class="line">Prepare(querystring)(Stmt,error)</span><br><span class="line">Close()error</span><br><span class="line">Begin()(Tx,error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是一个接口。如果你仔细地查看<code>database/sql/driver/driver.go</code>的代码会发现，这个文件里所有的成员全都是接口，对这些类型进行操作，还是会调用具体的<code>driver</code>里的方法。</p>
<p>从用户的角度来讲，在使用<code>database/sql</code>包的过程中，你能够使用的也就是这些接口里提供的函数。来看一个使用<code>database/sql</code>和<code>go-sql-driver/mysql</code>的完整的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line">_<span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">funcmain()&#123;</span><br><span class="line"><span class="comment">//db是一个sql.DB类型的对象</span></span><br><span class="line"><span class="comment">//该对象线程安全，且内部已包含了一个连接池</span></span><br><span class="line"><span class="comment">//连接池的选项可以在sql.DB的方法中设置，这里为了简单省略了</span></span><br><span class="line">db,err:=sql.Open(<span class="string">"mysql"</span>,</span><br><span class="line"><span class="string">"user:password@tcp(127.0.0.1:3306)/hello"</span>)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">deferdb.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">idint</span><br><span class="line">namestring</span><br><span class="line">)</span><br><span class="line">rows,err:=db.Query(<span class="string">"selectid,namefromuserswhereid=?"</span>,<span class="number">1</span>)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deferrows.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须要把rows里的内容读完，或者显式调用Close()方法，</span></span><br><span class="line"><span class="comment">//否则在defer的rows.Close()执行之前，连接永远不会释放</span></span><br><span class="line">forrows.Next()&#123;</span><br><span class="line">err:=rows.Scan(&amp;id,&amp;name)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Println(id,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err=rows.Err()</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果读者想了解官方这个<code>database/sql</code>库更加详细的用法的话，可以参考<code>http://go-database-sql.org/</code>。</p>
<p>包括该库的功能介绍、用法、注意事项和反直觉的一些实现方式（例如同一个goroutine内对<code>sql.DB</code>的查询，可能在多个连接上）都有涉及，本章中不再赘述。</p>
<p>聪明如你的话，在上面这段简短的程序中可能已经嗅出了一些不好的味道。官方的<code>db</code>库提供的功能这么简单，我们每次去数据库里读取内容岂不是都要去写这么一套差不多的代码？或者如果我们的对象是结构体，把<code>sql.Rows</code>绑定到对象的工作就会变得更加得重复而无聊。</p>
<p>是的，所以社区才会有各种各样的SQLBuilder和ORM百花齐放。</p>
<h2 id="5-5-2提高生产效率的ORM和SQLBuilder"><a href="#5-5-2提高生产效率的ORM和SQLBuilder" class="headerlink" title="5.5.2提高生产效率的ORM和SQLBuilder"></a>5.5.2提高生产效率的ORM和SQLBuilder</h2><p>在Web开发领域常常提到的ORM是什么？我们先看看万能的维基百科：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象关系映射（英语：ObjectRelationalMapping，简称ORM，或O/RM，或O/Rmapping），</span><br><span class="line">是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。</span><br><span class="line">从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。</span><br></pre></td></tr></table></figure>
<p>最为常见的ORM做的是从db到程序的类或结构体这样的映射。所以你手边的程序可能是从MySQL的表映射你的程序内的类。我们可以先来看看其它的程序语言里的ORM写起来是怎么样的感觉：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;fromblog.modelsimportBlog</span><br><span class="line">&gt;&gt;&gt;b=Blog(name=<span class="string">'BeatlesBlog'</span>,tagline=<span class="string">'AllthelatestBeatlesnews.'</span>)</span><br><span class="line">&gt;&gt;&gt;b.save()</span><br></pre></td></tr></table></figure>
<p>完全没有数据库的痕迹，没错，ORM的目的就是屏蔽掉DB层，很多语言的ORM只要把你的类或结构体定义好，再用特定的语法将结构体之间的一对一或者一对多关系表达出来。那么任务就完成了。然后你就可以对这些映射好了数据库表的对象进行各种操作，例如save，create，retrieve，delete。至于ORM在背地里做了什么阴险的勾当，你是不一定清楚的。使用ORM的时候，我们往往比较容易有一种忘记了数据库的直观感受。举个例子，我们有个需求：向用户展示最新的商品列表，我们再假设，商品和商家是1:1的关联关系，我们就很容易写出像下面这样的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#伪代码</span></span><br><span class="line">shopList:=[]</span><br><span class="line">forproductinproductList&#123;</span><br><span class="line">shopList=append(shopList,product.GetShop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，我们不能批判这样写代码的程序员是偷懒的程序员。因为ORM一类的工具在出发点上就是屏蔽sql，让我们对数据库的操作更接近于人类的思维方式。这样很多只接触过ORM而且又是刚入行的程序员就很容易写出上面这样的代码。</p>
<p>这样的代码将对数据库的读请求放大了N倍。也就是说，如果你的商品列表有15个SKU，那么每次用户打开这个页面，至少需要执行1（查询商品列表）+15（查询相关的商铺信息）次查询。这里N是16。如果你的列表页很大，比如说有600个条目，那么你就至少要执行1+600次查询。如果说你的数据库能够承受的最大的简单查询是12万QPS，而上述这样的查询正好是你最常用的查询的话，你能对外提供的服务能力是多少呢？是200qps！互联网系统的忌讳之一，就是这种无端的读放大。</p>
<p>当然，你也可以说这不是ORM的问题，如果你手写sql你还是可能会写出差不多的程序，那么再来看两个demo：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o:=orm.NewOrm()</span><br><span class="line">num,err:=o.QueryTable(<span class="string">"cardgroup"</span>).Filter(<span class="string">"Cards__Card__Name"</span>,cardName).All(&amp;cardgroups)</span><br></pre></td></tr></table></figure>
<p>很多ORM都提供了这种Filter类型的查询方式，不过在某些ORM背后可能隐藏了非常难以察觉的细节，比如生成的SQL语句会自动<code>limit1000</code>。</p>
<p>也许喜欢ORM的读者读到这里会反驳了，你是没有认真阅读文档就瞎写。是的，尽管这些ORM工具在文档里说明了All查询在不显式地指定Limit的话会自动limit1000，但对于很多没有阅读过文档或者看过ORM源码的人，这依然是一个非常难以察觉的“魔鬼”细节。喜欢强类型语言的人一般都不喜欢语言隐式地去做什么事情，例如各种语言在赋值操作时进行的隐式类型转换然后又在转换中丢失了精度的勾当，一定让你非常的头疼。所以一个程序库背地里做的事情还是越少越好，如果一定要做，那也一定要在显眼的地方做。比如上面的例子，去掉这种默认的自作聪明的行为，或者要求用户强制传入limit参数都是更好的选择。</p>
<p>除了limit的问题，我们再看一遍这个下面的查询：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num,err:=o.QueryTable(<span class="string">"cardgroup"</span>).Filter(<span class="string">"Cards__Card__Name"</span>,cardName).All(&amp;cardgroups)</span><br></pre></td></tr></table></figure>
<p>你可以看得出来这个Filter是有表join的操作么？当然了，有深入使用经验的用户还是会觉得这是在吹毛求疵。但这样的分析想证明的是，ORM想从设计上隐去太多的细节。而方便的代价是其背后的运行完全失控。这样的项目在经过几任维护人员之后，将变得面目全非，难以维护。</p>
<p>当然，我们不能否认ORM的进步意义，它的设计初衷就是为了让数据的操作和存储的具体实现相剥离。但是在上了规模的公司的人们渐渐达成了一个共识，由于隐藏重要的细节，ORM可能是失败的设计。其所隐藏的重要细节对于上了规模的系统开发来说至关重要。</p>
<p>相比ORM来说，SQLBuilder在SQL和项目可维护性之间取得了比较好的平衡。首先sqlbuilder不像ORM那样屏蔽了过多的细节，其次从开发的角度来讲，SQLBuilder进行简单封装后也可以非常高效地完成开发，举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">where:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"order_id&gt;?"</span>:<span class="number">0</span>,</span><br><span class="line"><span class="string">"customer_id!=?"</span>:<span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line">limit:=[]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">100</span>&#125;</span><br><span class="line">orderBy:=[]<span class="keyword">string</span>&#123;<span class="string">"idasc"</span>,<span class="string">"create_timedesc"</span>&#125;</span><br><span class="line"></span><br><span class="line">orders:=orderModel.GetList(where,limit,orderBy)</span><br></pre></td></tr></table></figure>
<p>写SQLBuilder的相关代码，或者读懂都不费劲。把这些代码脑内转换为sql也不会太费劲。所以通过代码就可以对这个查询是否命中数据库索引，是否走了覆盖索引，是否能够用上联合索引进行分析了。</p>
<p>说白了SQLBuilder是sql在代码里的一种特殊方言，如果你们没有DBA但研发有自己分析和优化sql的能力，或者你们公司的DBA对于学习这样一些sql的方言没有异议。那么使用SQLBuilder是一个比较好的选择，不会导致什么问题。</p>
<p>另外在一些本来也不需要DBA介入的场景内，使用SQLBuilder也是可以的，例如你要做一套运维系统，且将MySQL当作了系统中的一个组件，系统的QPS不高，查询不复杂等等。</p>
<p>一旦你做的是高并发的OLTP在线系统，且想在人员充足分工明确的前提下最大程度控制系统的风险，使用SQLBuilder就不合适了。</p>
<h2 id="5-5-3脆弱的数据库"><a href="#5-5-3脆弱的数据库" class="headerlink" title="5.5.3脆弱的数据库"></a>5.5.3脆弱的数据库</h2><p>无论是ORM还是SQLBuilder都有一个致命的缺点，就是没有办法进行系统上线的事前sql审核。虽然很多ORM和SQLBuilder也提供了运行期打印sql的功能，但只在查询的时候才能进行输出。而SQLBuilder和ORM本身提供的功能太过灵活。使得你不可能通过测试枚举出所有可能在线上执行的sql。例如你可能用SQLBuilder写出下面这样的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">where:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"product_id=?"</span>:<span class="number">10</span>,</span><br><span class="line"><span class="string">"user_id=?"</span>:<span class="number">1232</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iforder_id!=<span class="number">0</span>&#123;</span><br><span class="line">where[<span class="string">"order_id=?"</span>]=order_id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res,err:=historyModel.GetList(where,limit,orderBy)</span><br></pre></td></tr></table></figure>
<p>你的系统里有大量类似上述样例的<code>if</code>的话，就难以通过测试用例来覆盖到所有可能的sql组合了。</p>
<p>这样的系统只要发布，就已经孕育了初期的巨大风险。</p>
<p>对于现在7乘24服务的互联网公司来说，服务不可用是非常重大的问题。存储层的技术栈虽经历了多年的发展，在整个系统中依然是最为脆弱的一环。系统宕机对于24小时对外提供服务的公司来说，意味着直接的经济损失。各种风险不可忽视。</p>
<p>从行业分工的角度来讲，现今的互联网公司都有专职的DBA。大多数DBA并不一定有写代码的能力，去阅读SQLBuilder的相关“拼SQL”代码多多少少还是会有一点障碍。从DBA角度出发，还是希望能够有专门的事前SQL审核机制，并能让其低成本地获取到系统的所有SQL内容，而不是去阅读业务研发编写的SQLBuilder的相关代码。</p>
<p>所以现如今，大型的互联网公司核心线上业务都会在代码中把SQL放在显眼的位置提供给DBA评审，举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">getAllByProductIDAndCustomerID=<span class="string">`select*fromp_orderswhereproduct_idin(:product_id)andcustomer_id=:customer_id`</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetAllByProductIDAndCustomerID</span></span><br><span class="line"><span class="comment">//@paramdriver_id</span></span><br><span class="line"><span class="comment">//@paramrate_date</span></span><br><span class="line"><span class="comment">//@return[]Order,error</span></span><br><span class="line">funcGetAllByProductIDAndCustomerID(ctxcontext.Context,productIDs[]<span class="keyword">uint64</span>,customerIDuint64)([]Order,error)&#123;</span><br><span class="line">varorderList[]Order</span><br><span class="line"></span><br><span class="line">params:=<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"product_id"</span>:productIDs,</span><br><span class="line"><span class="string">"customer_id"</span>:customerID,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getAllByProductIDAndCustomerID是const类型的sql字符串</span></span><br><span class="line">sql,args,err:=sqlutil.Named(getAllByProductIDAndCustomerID,params)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">returnnil,err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err=dao.QueryList(ctx,sqldbInstance,sql,args,&amp;orderList)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">returnnil,err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnorderList,err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这样的代码，在上线之前把DAO层的变更集的const部分直接拿给DBA来进行审核，就比较方便了。代码中的sqlutil.Named是类似于sqlx中的Named函数，同时支持where表达式中的比较操作符和in。</p>
<p>这里为了说明简便，函数写得稍微复杂一些，仔细思考一下的话查询的导出函数还可以进一步进行简化。请读者朋友们自行尝试。</p>
<h1 id="5-6Ratelimit服务流量限制"><a href="#5-6Ratelimit服务流量限制" class="headerlink" title="5.6Ratelimit服务流量限制"></a>5.6Ratelimit服务流量限制</h1><p>计算机程序可依据其瓶颈分为磁盘IO瓶颈型，CPU计算瓶颈型，网络带宽瓶颈型，分布式场景下有时候也会外部系统而导致自身瓶颈。</p>
<p>Web系统打交道最多的是网络，无论是接收，解析用户请求，访问存储，还是把响应数据返回给用户，都是要走网络的。在没有<code>epoll/kqueue</code>之类的系统提供的IO多路复用接口之前，多个核心的现代计算机最头痛的是C10k问题，C10k问题会导致计算机没有办法充分利用CPU来处理更多的用户连接，进而没有办法通过优化程序提升CPU利用率来处理更多的请求。</p>
<p>自从Linux实现了<code>epoll</code>，FreeBSD实现了<code>kqueue</code>，这个问题基本解决了，我们可以借助内核提供的API轻松解决当年的C10k问题，也就是说如今如果你的程序主要是和网络打交道，那么瓶颈一定在用户程序而不在操作系统内核。</p>
<p>随着时代的发展，编程语言对这些系统调用又进一步进行了封装，如今做应用层开发，几乎不会在程序中看到<code>epoll</code>之类的字眼，大多数时候我们就只要聚焦在业务逻辑上就好。Go的net库针对不同平台封装了不同的syscallAPI，<code>http</code>库又是构建在<code>net</code>库之上，所以在Go语言中我们可以借助标准库，很轻松地写出高性能的<code>http</code>服务，下面是一个简单的<code>helloworld</code>服务的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">funcsayhello(wrhttp.ResponseWriter,r*http.Request)&#123;</span><br><span class="line">wr.WriteHeader(<span class="number">200</span>)</span><br><span class="line">io.WriteString(wr,<span class="string">"helloworld"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcmain()&#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>,sayhello)</span><br><span class="line">err:=http.ListenAndServe(<span class="string">":9090"</span>,<span class="literal">nil</span>)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServe:"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要衡量一下这个Web服务的吞吐量，再具体一些，就是接口的QPS。借助wrk，在家用电脑MacbookPro上对这个<code>helloworld</code>服务进行基准测试，Mac的硬件情况如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CPU:Intel(R)Core(TM)i5-5257UCPU@2.70GHz</span><br><span class="line">Core:2</span><br><span class="line">Threads:4</span><br><span class="line"></span><br><span class="line">Graphics/Displays:</span><br><span class="line">ChipsetModel:IntelIrisGraphics6100</span><br><span class="line">Resolution:2560x1600Retina</span><br><span class="line">MemorySlots:</span><br><span class="line">Size:4GB</span><br><span class="line">Speed:1867MHz</span><br><span class="line">Size:4GB</span><br><span class="line">Speed:1867MHz</span><br><span class="line">Storage:</span><br><span class="line">Size:250.14GB(250,140,319,744bytes)</span><br><span class="line">MediaName:APPLESSDSM0256GMedia</span><br><span class="line">Size:250.14GB(250,140,319,744bytes)</span><br><span class="line">MediumType:SSD</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">~❯❯❯wrk-c10-d10s-t10http://localhost:9090</span><br><span class="line">Running10stest@http://localhost:9090</span><br><span class="line">10threadsand10connections</span><br><span class="line">ThreadStatsAvgStdevMax+/-Stdev</span><br><span class="line">Latency339.99us1.28ms44.43ms98.29%</span><br><span class="line">Req/Sec4.49k656.817.47k73.36%</span><br><span class="line">449588requestsin10.10s,54.88MBread</span><br><span class="line">Requests/sec:44513.22</span><br><span class="line">Transfer/sec:5.43MB</span><br><span class="line"></span><br><span class="line">~❯❯❯wrk-c10-d10s-t10http://localhost:9090</span><br><span class="line">Running10stest@http://localhost:9090</span><br><span class="line">10threadsand10connections</span><br><span class="line">ThreadStatsAvgStdevMax+/-Stdev</span><br><span class="line">Latency334.76us1.21ms45.47ms98.27%</span><br><span class="line">Req/Sec4.42k633.626.90k71.16%</span><br><span class="line">443582requestsin10.10s,54.15MBread</span><br><span class="line">Requests/sec:43911.68</span><br><span class="line">Transfer/sec:5.36MB</span><br><span class="line"></span><br><span class="line">~❯❯❯wrk-c10-d10s-t10http://localhost:9090</span><br><span class="line">Running10stest@http://localhost:9090</span><br><span class="line">10threadsand10connections</span><br><span class="line">ThreadStatsAvgStdevMax+/-Stdev</span><br><span class="line">Latency379.26us1.34ms44.28ms97.62%</span><br><span class="line">Req/Sec4.55k591.648.20k76.37%</span><br><span class="line">455710requestsin10.10s,55.63MBread</span><br><span class="line">Requests/sec:45118.57</span><br><span class="line">Transfer/sec:5.51MB</span><br></pre></td></tr></table></figure>
<p>多次测试的结果在4万左右的QPS浮动，响应时间最多也就是40ms左右，对于一个Web程序来说，这已经是很不错的成绩了，我们只是照抄了别人的示例代码，就完成了一个高性能的<code>helloworld</code>服务器，是不是很有成就感？</p>
<p>这还只是家用PC，线上服务器大多都是24核心起，32G内存+，CPU基本都是Inteli7。所以同样的程序在服务器上运行会得到更好的结果。</p>
<p>这里的<code>helloworld</code>服务没有任何业务逻辑。真实环境的程序要复杂得多，有些程序偏网络IO瓶颈，例如一些CDN服务、Proxy服务；有些程序偏CPU/GPU瓶颈，例如登陆校验服务、图像处理服务；有些程序瓶颈偏磁盘，例如专门的存储系统，数据库。不同的程序瓶颈会体现在不同的地方，这里提到的这些功能单一的服务相对来说还算容易分析。如果碰到业务逻辑复杂代码量巨大的模块，其瓶颈并不是三下五除二可以推测出来的，还是需要从压力测试中得到更为精确的结论。</p>
<p>对于IO/Network瓶颈类的程序，其表现是网卡/磁盘IO会先于CPU打满，这种情况即使优化CPU的使用也不能提高整个系统的吞吐量，只能提高磁盘的读写速度，增加内存大小，提升网卡的带宽来提升整体性能。而CPU瓶颈类的程序，则是在存储和网卡未打满之前CPU占用率先到达100%，CPU忙于各种计算任务，IO设备相对则较闲。</p>
<p>无论哪种类型的服务，在资源使用到极限的时候都会导致请求堆积，超时，系统hang死，最终伤害到终端用户。对于分布式的Web服务来说，瓶颈还不一定总在系统内部，也有可能在外部。非计算密集型的系统往往会在关系型数据库环节失守，而这时候Web模块本身还远远未达到瓶颈。</p>
<p>不管我们的服务瓶颈在哪里，最终要做的事情都是一样的，那就是流量限制。</p>
<h2 id="5-6-1常见的流量限制手段"><a href="#5-6-1常见的流量限制手段" class="headerlink" title="5.6.1常见的流量限制手段"></a>5.6.1常见的流量限制手段</h2><p>流量限制的手段有很多，最常见的：漏桶、令牌桶两种：</p>
<p>1.漏桶是指我们有一个一直装满了水的桶，每过固定的一段时间即向外漏一滴水。如果你接到了这滴水，那么你就可以继续服务请求，如果没有接到，那么就需要等待下一滴水。<br>2.令牌桶则是指匀速向桶中添加令牌，服务请求时需要从桶中获取令牌，令牌的数目可以按照需要消耗的资源进行相应的调整。如果没有令牌，可以选择等待，或者放弃。</p>
<p>这两种方法看起来很像，不过还是有区别的。漏桶流出的速率固定，而令牌桶只要在桶中有令牌，那就可以拿。也就是说令牌桶是允许一定程度的并发的，比如同一个时刻，有100个用户请求，只要令牌桶中有100个令牌，那么这100个请求全都会放过去。令牌桶在桶中没有令牌的情况下也会退化为漏桶模型。</p>
<p><img src="../images/ch5-token-bucket.png" alt="tokenbucket"></p>
<p><em>图5-12令牌桶</em></p>
<p>实际应用中令牌桶应用较为广泛，开源界流行的限流器大多数都是基于令牌桶思想的。并且在此基础上进行了一定程度的扩充，比如<code>github.com/juju/ratelimit</code>提供了几种不同特色的令牌桶填充方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcNewBucket(fillIntervaltime.Duration,capacityint64)*Bucket</span><br></pre></td></tr></table></figure>
<p>默认的令牌桶，<code>fillInterval</code>指每过多长时间向桶里放一个令牌，<code>capacity</code>是桶的容量，超过桶容量的部分会被直接丢弃。桶初始是满的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcNewBucketWithQuantum(fillIntervaltime.Duration,capacity,quantumint64)*Bucket</span><br></pre></td></tr></table></figure>
<p>和普通的<code>NewBucket()</code>的区别是，每次向桶中放令牌时，是放<code>quantum</code>个令牌，而不是一个令牌。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcNewBucketWithRate(ratefloat64,capacityint64)*Bucket</span><br></pre></td></tr></table></figure>
<p>这个就有点特殊了，会按照提供的比例，每秒钟填充令牌数。例如<code>capacity</code>是100，而<code>rate</code>是0.1，那么每秒会填充10个令牌。</p>
<p>从桶中获取令牌也提供了几个API：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tb*Bucket)</span><span class="title">Take</span><span class="params">(countint64)</span><span class="title">time</span>.<span class="title">Duration</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tb*Bucket)</span><span class="title">TakeAvailable</span><span class="params">(countint64)</span><span class="title">int64</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tb*Bucket)</span><span class="title">TakeMaxDuration</span><span class="params">(countint64,maxWaittime.Duration)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">time.Duration,<span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tb*Bucket)</span><span class="title">Wait</span><span class="params">(countint64)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(tb*Bucket)</span><span class="title">WaitMaxDuration</span><span class="params">(countint64,maxWaittime.Duration)</span><span class="title">bool</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>名称和功能都比较直观，这里就不再赘述了。相比于开源界更为有名的Google的Java工具库Guava中提供的ratelimiter，这个库不支持令牌桶预热，且无法修改初始的令牌容量，所以可能个别极端情况下的需求无法满足。但在明白令牌桶的基本原理之后，如果没办法满足需求，相信你也可以很快对其进行修改并支持自己的业务场景。</p>
<h2 id="5-6-2原理"><a href="#5-6-2原理" class="headerlink" title="5.6.2原理"></a>5.6.2原理</h2><p>从功能上来看，令牌桶模型就是对全局计数的加减法操作过程，但使用计数需要我们自己加读写锁，有小小的思想负担。如果我们对Go语言已经比较熟悉的话，很容易想到可以用bufferedchannel来完成简单的加令牌取令牌操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vartokenBucket=<span class="built_in">make</span>(chanstruct&#123;&#125;,capacity)</span><br></pre></td></tr></table></figure>
<p>每过一段时间向<code>tokenBucket</code>中添加<code>token</code>，如果<code>bucket</code>已经满了，那么直接放弃：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fillToken:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">ticker:=time.NewTicker(fillInterval)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span>&lt;-ticker.C:</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">casetokenBucket&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"currenttokencnt:"</span>,<span class="built_in">len</span>(tokenBucket),time.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把代码组合起来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">funcmain()&#123;</span><br><span class="line">varfillInterval=time.Millisecond*<span class="number">10</span></span><br><span class="line">varcapacity=<span class="number">100</span></span><br><span class="line">vartokenBucket=<span class="built_in">make</span>(chanstruct&#123;&#125;,capacity)</span><br><span class="line"></span><br><span class="line">fillToken:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">ticker:=time.NewTicker(fillInterval)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span>&lt;-ticker.C:</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">casetokenBucket&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"currenttokencnt:"</span>,<span class="built_in">len</span>(tokenBucket),time.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gofillToken()</span><br><span class="line">time.Sleep(time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看运行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currenttokencnt:982018-06-1618:17:50.234556981+0800CSTm=+0.981524018</span><br><span class="line">currenttokencnt:992018-06-1618:17:50.243575354+0800CSTm=+0.990542391</span><br><span class="line">currenttokencnt:1002018-06-1618:17:50.254628067+0800CSTm=+1.001595104</span><br><span class="line">currenttokencnt:1002018-06-1618:17:50.264537143+0800CSTm=+1.011504180</span><br><span class="line">currenttokencnt:1002018-06-1618:17:50.273613018+0800CSTm=+1.020580055</span><br><span class="line">currenttokencnt:1002018-06-1618:17:50.2844406+0800CSTm=+1.031407637</span><br><span class="line">currenttokencnt:1002018-06-1618:17:50.294528695+0800CSTm=+1.041495732</span><br><span class="line">currenttokencnt:1002018-06-1618:17:50.304550145+0800CSTm=+1.051517182</span><br><span class="line">currenttokencnt:1002018-06-1618:17:50.313970334+0800CSTm=+1.060937371</span><br></pre></td></tr></table></figure>
<p>在1s钟的时候刚好填满100个，没有太大的偏差。不过这里可以看到，Go的定时器存在大约0.001s的误差，所以如果令牌桶大小在1000以上的填充可能会有一定的误差。对于一般的服务来说，这一点误差无关紧要。</p>
<p>上面的令牌桶的取令牌操作实现起来也比较简单，简化问题，我们这里只取一个令牌：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">funcTakeAvailable(blockbool)<span class="keyword">bool</span>&#123;</span><br><span class="line">vartakenResultbool</span><br><span class="line">ifblock&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span>&lt;-tokenBucket:</span><br><span class="line">takenResult=<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span>&lt;-tokenBucket:</span><br><span class="line">takenResult=<span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">takenResult=<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returntakenResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些公司自己造的限流的轮子就是用上面这种方式来实现的，不过如果开源版ratelimit也如此的话，那我们也没什么可说的了。现实并不是这样的。</p>
<p>我们来思考一下，令牌桶每隔一段固定的时间向桶中放令牌，如果我们记下上一次放令牌的时间为t1，和当时的令牌数k1，放令牌的时间间隔为ti，每次向令牌桶中放x个令牌，令牌桶容量为cap。现在如果有人来调用<code>TakeAvailable</code>来取n个令牌，我们将这个时刻记为t2。在t2时刻，令牌桶中理论上应该有多少令牌呢？伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cur=k1+((t2-t1)/ti)*x</span><br><span class="line">cur=cur&gt;<span class="built_in">cap</span>?<span class="built_in">cap</span>:cur</span><br></pre></td></tr></table></figure>
<p>我们用两个时间点的时间差，再结合其它的参数，理论上在取令牌之前就完全可以知道桶里有多少令牌了。那劳心费力地像本小节前面向channel里填充token的操作，理论上是没有必要的。只要在每次<code>Take</code>的时候，再对令牌桶中的token数进行简单计算，就可以得到正确的令牌数。是不是很像<code>惰性求值</code>的感觉？</p>
<p>在得到正确的令牌数之后，再进行实际的<code>Take</code>操作就好，这个<code>Take</code>操作只需要对令牌数进行简单的减法即可，记得加锁以保证并发安全。<code>github.com/juju/ratelimit</code>这个库就是这样做的。</p>
<h2 id="5-6-3服务瓶颈和QoS"><a href="#5-6-3服务瓶颈和QoS" class="headerlink" title="5.6.3服务瓶颈和QoS"></a>5.6.3服务瓶颈和QoS</h2><p>前面我们说了很多CPU瓶颈、IO瓶颈之类的概念，这种性能瓶颈从大多数公司都有的监控系统中可以比较快速地定位出来，如果一个系统遇到了性能问题，那监控图的反应一般都是最快的。</p>
<p>虽然性能指标很重要，但对用户提供服务时还应考虑服务整体的QoS。QoS全称是QualityofService，顾名思义是服务质量。QoS包含有可用性、吞吐量、时延、时延变化和丢失等指标。一般来讲我们可以通过优化系统，来提高Web服务的CPU利用率，从而提高整个系统的吞吐量。但吞吐量提高的同时，用户体验是有可能变差的。用户角度比较敏感的除了可用性之外，还有时延。虽然你的系统吞吐量高，但半天刷不开页面，想必会造成大量的用户流失。所以在大公司的Web服务性能指标中，除了平均响应时延之外，还会把响应时间的95分位，99分位也拿出来作为性能标准。平均响应在提高CPU利用率没受到太大影响时，可能95分位、99分位的响应时间大幅度攀升了，那么这时候就要考虑提高这些CPU利用率所付出的代价是否值得了。</p>
<p>在线系统的机器一般都会保持CPU有一定的余裕。</p>
<h1 id="5-7layout常见大型Web项目分层"><a href="#5-7layout常见大型Web项目分层" class="headerlink" title="5.7layout常见大型Web项目分层"></a>5.7layout常见大型Web项目分层</h1><p>流行的Web框架大多数是MVC框架，MVC这个概念最早由TrygveReenskaug在1978年提出，为了能够对GUI类型的应用进行方便扩展，将程序划分为：</p>
<p>1.控制器（Controller）-负责转发请求，对请求进行处理。<br>2.视图（View）-界面设计人员进行图形界面设计。<br>3.模型（Model）-程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计（可以实现具体的功能）。</p>
<p>随着时代的发展，前端也变成了越来越复杂的工程，为了更好地工程化，现在更为流行的一般是前后分离的架构。可以认为前后分离是把V层从MVC中抽离单独成为项目。这样一个后端项目一般就只剩下M和C层了。前后端之间通过ajax来交互，有时候要解决跨域的问题，但也已经有了较为成熟的方案。<em>图5-13</em>是一个前后分离的系统的简易交互图。</p>
<p><img src="../images/ch6-08-frontend-backend.png" alt="前后分离"></p>
<p><em>图5-13前后分离交互图</em></p>
<p>图里的Vue和React是现在前端界比较流行的两个框架，因为我们的重点不在这里，所以前端项目内的组织我们就不强调了。事实上，即使是简单的项目，业界也并没有完全遵守MVC框架提出者对于M和C所定义的分工。有很多公司的项目会在Controller层塞入大量的逻辑，在Model层就只管理数据的存储。这往往来源于对于model层字面含义的某种擅自引申理解。认为字面意思，这一层就是处理某种建模，而模型是什么？就是数据呗！</p>
<p>这种理解显然是有问题的，业务流程也算是一种“模型”，是对真实世界用户行为或者既有流程的一种建模，并非只有按格式组织的数据才能叫模型。不过按照MVC的创始人的想法，我们如果把和数据打交道的代码还有业务流程全部塞进MVC里的M层的话，这个M层又会显得有些过于臃肿。对于复杂的项目，一个C和一个M层显然是不够用的，现在比较流行的纯后端API模块一般采用下述划分方法：</p>
<p>1.Controller，与上述类似，服务入口，负责处理路由，参数校验，请求转发。<br>2.Logic/Service，逻辑（服务）层，一般是业务逻辑的入口，可以认为从这里开始，所有的请求参数一定是合法的。业务逻辑和业务流程也都在这一层中。常见的设计中会将该层称为BusinessRules。<br>3.DAO/Repository，这一层主要负责和数据、存储打交道。将下层存储以更简单的函数、接口形式暴露给Logic层来使用。负责数据的持久化工作。</p>
<p>每一层都会做好自己的工作，然后用请求当前的上下文构造下一层工作所需要的结构体或其它类型参数，然后调用下一层的函数。在工作完成之后，再把处理结果一层层地传出到入口，如<em>图5-14所示</em>。</p>
<p><img src="../images/ch6-08-controller-logic-dao.png" alt="controller-logic-dao"></p>
<p><em>图5-14请求处理流程</em></p>
<p>划分为CLD三层之后，在C层之前我们可能还需要同时支持多种协议。本章前面讲到的thrift、gRPC和http并不是一定只选择其中一种，有时我们需要支持其中的两种，比如同一个接口，我们既需要效率较高的thrift，也需要方便debug的http入口。即除了CLD之外，还需要一个单独的protocol层，负责处理各种交互协议的细节。这样请求的流程会变成<em>图5-15</em>所示。</p>
<p><img src="../images/ch6-08-control-flow.png" alt="control-flow"></p>
<p><em>图5-15多协议示意图</em></p>
<p>这样我们Controller中的入口函数就变成了下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funcCreateOrder(ctxcontext.Context,req*CreateOrderStruct)(</span><br><span class="line">*CreateOrderRespStruct,error,</span><br><span class="line">)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CreateOrder有两个参数，ctx用来传入trace_id一类的需要串联请求的全局参数，req里存储了我们创建订单所需要的所有输入信息。返回结果是一个响应结构体和错误。可以认为，我们的代码运行到Controller层之后，就没有任何与“协议”相关的代码了。在这里你找不到<code>http.Request</code>，也找不到<code>http.ResponseWriter</code>，也找不到任何与thrift或者gRPC相关的字眼。</p>
<p>在协议(Protocol)层，处理http协议的大概代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//definedinprotocollayer</span></span><br><span class="line">typeCreateOrderRequeststruct&#123;</span><br><span class="line">OrderIDint64<span class="string">`json:"order_id"`</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//definedincontroller</span></span><br><span class="line">typeCreateOrderParamsstruct&#123;</span><br><span class="line">OrderIDint64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcHTTPCreateOrderHandler(wrhttp.ResponseWriter,r*http.Request)&#123;</span><br><span class="line">varreqCreateOrderRequest</span><br><span class="line">varparamsCreateOrderParams</span><br><span class="line">ctx:=context.TODO()</span><br><span class="line"><span class="comment">//binddatatoreq</span></span><br><span class="line">bind(r,&amp;req)</span><br><span class="line"><span class="comment">//mapprotocolbindedtoprotocol-independent</span></span><br><span class="line"><span class="keyword">map</span>(req,params)</span><br><span class="line">logicResp,err:=controller.CreateOrder(ctx,&amp;params)</span><br><span class="line">iferr!=<span class="literal">nil</span>&#123;&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理论上我们可以用同一个请求结构体组合上不同的tag，来达到一个结构体来给不同的协议复用的目的。不过遗憾的是在thrift中，请求结构体也是通过IDL生成的，其内容在自动生成的ttypes.go文件中，我们还是需要在thrift的入口将这个自动生成的结构体映射到我们logic入口所需要的结构体上。gRPC也是类似。这部分代码还是需要的。</p>
<p>聪明的读者可能已经可以看出来了，协议细节处理这一层有大量重复劳动，每一个接口在协议这一层的处理，无非是把数据从协议特定的结构体(例如<code>http.Request</code>，thrift的被包装过了)读出来，再绑定到我们协议无关的结构体上，再把这个结构体映射到Controller入口的结构体上，这些代码长得都差不多。差不多的代码都遵循着某种模式，那么我们可以对这些模式进行简单的抽象，用代码生成的方式，把繁复的协议处理代码从工作内容中抽离出去。</p>
<p>先来看看HTTP对应的结构体、thrift对应的结构体和我们协议无关的结构体分别长什么样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http请求结构体</span></span><br><span class="line">typeCreateOrderstruct&#123;</span><br><span class="line">OrderIDint64<span class="string">`json:"order_id"validate:"required"`</span></span><br><span class="line">UserIDint64<span class="string">`json:"user_id"validate:"required"`</span></span><br><span class="line">ProductIDint<span class="string">`json:"prod_id"validate:"required"`</span></span><br><span class="line">Addrstring<span class="string">`json:"addr"validate:"required"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thrift请求结构体</span></span><br><span class="line">typeFeatureSetParamsstruct&#123;</span><br><span class="line">DriverIDint64<span class="string">`thrift:"driverID,1,required"`</span></span><br><span class="line">OrderIDint64<span class="string">`thrift:"OrderID,2,required"`</span></span><br><span class="line">UserIDint64<span class="string">`thrift:"UserID,3,required"`</span></span><br><span class="line">ProductIDint<span class="string">`thrift:"ProductID,4,required"`</span></span><br><span class="line">Addrstring<span class="string">`thrift:"Addr,5,required"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//controllerinputstruct</span></span><br><span class="line">typeCreateOrderParamsstruct&#123;</span><br><span class="line">OrderIDint64</span><br><span class="line">UserIDint64</span><br><span class="line">ProductIDint</span><br><span class="line">Addrstring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要通过一个源结构体来生成我们需要的HTTP和thrift入口代码。再观察一下上面定义的三种结构体，我们只要能用一个结构体生成thrift的IDL，以及HTTP服务的“IDL（只要能包含json或form相关tag的结构体定义信息）”就可以了。这个初始的结构体我们可以把结构体上的HTTP的tag和thrift的tag揉在一起：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typeFeatureSetParamsstruct&#123;</span><br><span class="line">DriverIDint64<span class="string">`thrift:"driverID,1,required"json:"driver_id"`</span></span><br><span class="line">OrderIDint64<span class="string">`thrift:"OrderID,2,required"json:"order_id"`</span></span><br><span class="line">UserIDint64<span class="string">`thrift:"UserID,3,required"json:"user_id"`</span></span><br><span class="line">ProductIDint<span class="string">`thrift:"ProductID,4,required"json:"prod_id"`</span></span><br><span class="line">Addrstring<span class="string">`thrift:"Addr,5,required"json:"addr"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过代码生成把thrift的IDL和HTTP的请求结构体都生成出来，如<em>图5-16所示</em></p>
<p><img src="../images/ch6-08-code-gen.png" alt="codegen"></p>
<p><em>图5-16通过Go代码定义结构体生成项目入口</em></p>
<p>至于用什么手段来生成，你可以通过Go语言内置的Parser读取文本文件中的Go源代码，然后根据AST来生成目标代码，也可以简单地把这个源结构体和Generator的代码放在一起编译，让结构体作为Generator的输入参数（这样会更简单一些），都是可以的。</p>
<p>当然这种思路并不是唯一选择，我们还可以通过解析thrift的IDL，生成一套HTTP接口的结构体。如果你选择这么做，那整个流程就变成了<em>图5-17</em>所示。</p>
<p><img src="../images/ch6-08-code-gen-2.png" alt="codegen"></p>
<p><em>图5-17也可以从thrift生成其它部分</em></p>
<p>看起来比之前的图顺畅一点，不过如果你选择了这么做，你需要自行对thrift的IDL进行解析，也就是相当于可能要手写一个thrift的IDL的Parser，虽然现在有Antlr或者peg能帮你简化这些Parser的书写工作，但在“解析”的这一步我们不希望引入太多的工作量，所以量力而行即可。</p>
<p>既然工作流已经成型，我们可以琢磨一下怎么让整个流程对用户更加友好。</p>
<p>比如在前面的生成环境引入Web页面，只要让用户点点鼠标就能生成SDK，这些就靠读者自己去探索了。</p>
<p>虽然我们成功地使自己的项目在入口支持了多种交互协议，但是还有一些问题没有解决。本节中所叙述的分层没有将中间件作为项目的分层考虑进去。如果我们考虑中间件的话，请求的流程是什么样的？见<em>图5-18</em>所示。</p>
<p><img src="../images/ch6-08-control-flow-2.png" alt="controlflow2"></p>
<p><em>图5-18加入中间件后的控制流</em></p>
<p>之前我们学习的中间件是和HTTP协议强相关的，遗憾的是在thrift中看起来没有和HTTP中对等的解决这些非功能性逻辑代码重复问题的中间件。所以我们在图上写<code>thriftstuff</code>。这些<code>stuff</code>可能需要你手写去实现，然后每次增加一个新的thrift接口，就需要去写一遍这些非功能性代码。</p>
<p>这也是很多企业项目所面临的真实问题，遗憾的是开源界并没有这样方便的多协议中间件解决方案。当然了，前面我们也说过，很多时候我们给自己保留的HTTP接口只是用来做调试，并不会暴露给外人用。这种情况下，这些非功能性的代码只要在thrift的代码中完成即可。</p>
<h1 id="5-8接口和表驱动开发"><a href="#5-8接口和表驱动开发" class="headerlink" title="5.8接口和表驱动开发"></a>5.8接口和表驱动开发</h1><p>在Web项目中经常会遇到外部依赖环境的变化，比如：</p>
<p>1.公司的老存储系统年久失修，现在已经没有人维护了，新的系统上线也没有考虑平滑迁移，但最后通牒已下，要求N天之内迁移完毕。<br>2.平台部门的老用户系统年久失修，现在已经没有人维护了，真是悲伤的故事。新系统上线没有考虑兼容老接口，但最后通牒已下，要求N个月之内迁移完毕。<br>3.公司的老消息队列人走茶凉，年久失修，新来的技术精英们没有考虑向前兼容，但最后通牒已下，要求半年之内迁移完毕。</p>
<p>嗯，所以你看到了，我们的外部依赖总是为了自己爽而不断地做升级，且不想做向前兼容，然后来给我们下最后通牒。如果我们的部门工作饱和，领导强势，那么有时候也可以倒逼依赖方来做兼容。但世事不一定如人愿，即使我们的领导强势，读者朋友的领导也还是可能认怂的。</p>
<p>我们可以思考一下怎么缓解这个问题。</p>
<h2 id="5-8-1业务系统的发展过程"><a href="#5-8-1业务系统的发展过程" class="headerlink" title="5.8.1业务系统的发展过程"></a>5.8.1业务系统的发展过程</h2><p>互联网公司只要可以活过三年，工程方面面临的首要问题就是代码膨胀。系统的代码膨胀之后，可以将系统中与业务本身流程无关的部分做拆解和异步化。什么算是业务无关呢，比如一些统计、反作弊、营销发券、价格计算、用户状态更新等等需求。这些需求往往依赖于主流程的数据，但又只是挂在主流程上的旁支，自成体系。</p>
<p>这时候我们就可以把这些旁支拆解出去，作为独立的系统来部署、开发以及维护。这些旁支流程的时延如若非常敏感，比如用户在界面上点了按钮，需要立刻返回（价格计算、支付），那么需要与主流程系统进行RPC通信，并且在通信失败时，要将结果直接返回给用户。如果时延不敏感，比如抽奖系统，结果稍后公布的这种，或者非实时的统计类系统，那么就没有必要在主流程里为每一套系统做一套RPC流程。我们只要将下游需要的数据打包成一条消息，传入消息队列，之后的事情与主流程一概无关（当然，与用户的后续交互流程还是要做的）。</p>
<p>通过拆解和异步化虽然解决了一部分问题，但并不能解决所有问题。随着业务发展，单一职责的模块也会变得越来越复杂，这是必然的趋势。一件事情本身变的复杂的话，这时候拆解和异步化就不灵了。我们还是要对事情本身进行一定程度的封装抽象。</p>
<h2 id="5-8-2使用函数封装业务流程"><a href="#5-8-2使用函数封装业务流程" class="headerlink" title="5.8.2使用函数封装业务流程"></a>5.8.2使用函数封装业务流程</h2><p>最基本的封装过程，我们把相似的行为放在一起，然后打包成一个一个的函数，让自己杂乱无章的代码变成下面这个样子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funcBusinessProcess(ctxcontext.Context,paramsParams)(resp,error)&#123;</span><br><span class="line">ValidateLogin()</span><br><span class="line">ValidateParams()</span><br><span class="line">AntispamCheck()</span><br><span class="line">GetPrice()</span><br><span class="line">CreateOrder()</span><br><span class="line">UpdateUserStatus()</span><br><span class="line">NotifyDownstreamSystems()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是多么复杂的业务，系统内的逻辑都是可以分解为<code>step1-&gt;step2-&gt;step3...</code>这样的流程的。</p>
<p>每一个步骤内部也会有复杂的流程，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">funcCreateOrder()&#123;</span><br><span class="line">ValidateDistrict()<span class="comment">//判断是否是地区限定商品</span></span><br><span class="line">ValidateVIPProduct()<span class="comment">//检查是否是只提供给vip的商品</span></span><br><span class="line">GetUserInfo()<span class="comment">//从用户系统获取更详细的用户信息</span></span><br><span class="line">GetProductDesc()<span class="comment">//从商品系统中获取商品在该时间点的详细信息</span></span><br><span class="line">DecrementStorage()<span class="comment">//扣减库存</span></span><br><span class="line">CreateOrderSnapshot()<span class="comment">//创建订单快照</span></span><br><span class="line">returnCreateSuccess</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在阅读业务流程代码时，我们只要阅读其函数名就能知晓在该流程中完成了哪些操作，如果需要修改细节，那么就继续深入到每一个业务步骤去看具体的流程。写得稀烂的业务流程代码则会将所有过程都堆积在少数的几个函数中，从而导致几百甚至上千行的函数。这种意大利面条式的代码阅读和维护都会非常痛苦。在开发的过程中，一旦有条件应该立即进行类似上面这种方式的简单封装。</p>
<h2 id="5-8-3使用接口来做抽象"><a href="#5-8-3使用接口来做抽象" class="headerlink" title="5.8.3使用接口来做抽象"></a>5.8.3使用接口来做抽象</h2><p>业务发展的早期，是不适宜引入接口（interface）的，很多时候业务流程变化很大，过早引入接口会使业务系统本身增加很多不必要的分层，从而导致每次修改几乎都要全盘否定之前的工作。</p>
<p>当业务发展到一定阶段，主流程稳定之后，就可以适当地使用接口来进行抽象了。这里的稳定，是指主流程的大部分业务步骤已经确定，即使再进行修改，也不会进行大规模的变动，而只是小修小补，或者只是增加或删除少量业务步骤。</p>
<p>如果我们在开发过程中，已经对业务步骤进行了良好的封装，这时候进行接口抽象化就会变的非常容易，伪代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OrderCreator创建订单流程</span></span><br><span class="line">typeOrderCreatorinterface&#123;</span><br><span class="line">ValidateDistrict()<span class="comment">//判断是否是地区限定商品</span></span><br><span class="line">ValidateVIPProduct()<span class="comment">//检查是否是只提供给vip的商品</span></span><br><span class="line">GetUserInfo()<span class="comment">//从用户系统获取更详细的用户信息</span></span><br><span class="line">GetProductDesc()<span class="comment">//从商品系统中获取商品在该时间点的详细信息</span></span><br><span class="line">DecrementStorage()<span class="comment">//扣减库存</span></span><br><span class="line">CreateOrderSnapshot()<span class="comment">//创建订单快照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只要把之前写过的步骤函数签名都提到一个接口中，就可以完成抽象了。</p>
<p>在进行抽象之前，我们应该想明白的一点是，引入接口对我们的系统本身是否有意义，这是要按照场景去进行分析的。假如我们的系统只服务一条产品线，并且内部的代码只是针对很具体的场景进行定制化开发，那么引入接口是不会带来任何收益的。至于说是否方便测试，这一点我们会在之后的章节来讲。</p>
<p>如果我们正在做的是平台系统，需要由平台来定义统一的业务流程和业务规范，那么基于接口的抽象就是有意义的。举个例子：</p>
<p><img src="../images/ch6-interface-impl.uml.png" alt="interface-impl"></p>
<p><em>图5-19实现公有的接口</em></p>
<p>平台需要服务多条业务线，但数据定义需要统一，所以希望都能走平台定义的流程。作为平台方，我们可以定义一套类似上文的接口，然后要求接入方的业务必须将这些接口都实现。如果接口中有其不需要的步骤，那么只要返回<code>nil</code>，或者忽略就好。</p>
<p>在业务进行迭代时，平台的代码是不用修改的，这样我们便把这些接入业务当成了平台代码的插件（plugin）引入进来了。如果没有接口的话，我们会怎么做？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"sample.com/travelorder"</span></span><br><span class="line"><span class="string">"sample.com/marketorder"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">funcCreateOrder()&#123;</span><br><span class="line">switchbusinessType&#123;</span><br><span class="line">caseTravelBusiness:</span><br><span class="line">travelorder.CreateOrder()</span><br><span class="line">caseMarketBusiness:</span><br><span class="line">marketorder.CreateOrderForMarket()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">returnerrors.New(<span class="string">"notsupportedbusiness"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcValidateUser()&#123;</span><br><span class="line">switchbusinessType&#123;</span><br><span class="line">caseTravelBusiness:</span><br><span class="line">travelorder.ValidateUserVIP()</span><br><span class="line">caseMarketBusiness:</span><br><span class="line">marketorder.ValidateUserRegistered()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">returnerrors.New(<span class="string">"notsupportedbusiness"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">switch</span>...</span><br><span class="line"><span class="keyword">switch</span>...</span><br><span class="line"><span class="keyword">switch</span>...</span><br></pre></td></tr></table></figure>
<p>没错，就是无穷无尽的<code>switch</code>，和没完没了的垃圾代码。引入了接口之后，我们的<code>switch</code>只需要在业务入口做一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typeBusinessInstanceinterface&#123;</span><br><span class="line">ValidateLogin()</span><br><span class="line">ValidateParams()</span><br><span class="line">AntispamCheck()</span><br><span class="line">GetPrice()</span><br><span class="line">CreateOrder()</span><br><span class="line">UpdateUserStatus()</span><br><span class="line">NotifyDownstreamSystems()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcentry()&#123;</span><br><span class="line">varbiBusinessInstance</span><br><span class="line">switchbusinessType&#123;</span><br><span class="line">caseTravelBusiness:</span><br><span class="line">bi=travelorder.New()</span><br><span class="line">caseMarketBusiness:</span><br><span class="line">bi=marketorder.New()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">returnerrors.New(<span class="string">"notsupportedbusiness"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcBusinessProcess(biBusinessInstance)&#123;</span><br><span class="line">bi.ValidateLogin()</span><br><span class="line">bi.ValidateParams()</span><br><span class="line">bi.AntispamCheck()</span><br><span class="line">bi.GetPrice()</span><br><span class="line">bi.CreateOrder()</span><br><span class="line">bi.UpdateUserStatus()</span><br><span class="line">bi.NotifyDownstreamSystems()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>面向接口编程，不用关心具体的实现。如果对应的业务在迭代中发生了修改，所有的逻辑对平台方来说也是完全透明的。</p>
<h2 id="5-8-4接口的优缺点"><a href="#5-8-4接口的优缺点" class="headerlink" title="5.8.4接口的优缺点"></a>5.8.4接口的优缺点</h2><p>Go被人称道的最多的地方是其接口设计的正交性，模块之间不需要知晓相互的存在，A模块定义接口，B模块实现这个接口就可以。如果接口中没有A模块中定义的数据类型，那B模块中甚至都不用<code>importA</code>。比如标准库中的<code>io.Writer</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeWriterinterface&#123;</span><br><span class="line">Write(p[]<span class="keyword">byte</span>)(nint,errerror)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在自己的模块中实现<code>io.Writer</code>接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeMyTypestruct&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(mMyType)</span><span class="title">Write</span><span class="params">(p[]<span class="keyword">byte</span>)</span><span class="params">(nint,errerror)</span></span>&#123;</span><br><span class="line">return0,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们就可以把我们自己的<code>MyType</code>传给任何使用<code>io.Writer</code>作为参数的函数来使用了，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">packagelog</span><br><span class="line"></span><br><span class="line">funcSetOutput(wio.Writer)&#123;</span><br><span class="line">output=w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">packagemy-business</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">"xy.com/log"</span></span><br><span class="line"></span><br><span class="line">funcinit()&#123;</span><br><span class="line">log.SetOutput(MyType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>MyType</code>定义的地方，不需要<code>import&quot;io&quot;</code>就可以直接实现<code>io.Writer</code>接口，我们还可以随意地组合很多函数，以实现各种类型的接口，同时接口实现方和接口定义方都不用建立import产生的依赖关系。因此很多人认为Go的这种正交是一种很优秀的设计。</p>
<p>但这种“正交”性也会给我们带来一些麻烦。当我们接手了一个几十万行的系统时，如果看到定义了很多接口，例如订单流程的接口，我们希望能直接找到这些接口都被哪些对象实现了。但直到现在，这个简单的需求也就只有Goland实现了，并且体验尚可。VisualStudioCode则需要对项目进行全局扫描，来看到底有哪些结构体实现了该接口的全部函数。那些显式实现接口的语言，对于IDE的接口查找来说就友好多了。另一方面，我们看到一个结构体，也希望能够立刻知道这个结构体实现了哪些接口，但也有着和前面提到的相同的问题。</p>
<p>虽有不便，接口带给我们的好处也是不言而喻的：一是依赖反转，这是接口在大多数语言中对软件项目所能产生的影响，在Go的正交接口的设计场景下甚至可以去除依赖；二是由编译器来帮助我们在编译期就能检查到类似“未完全实现接口”这样的错误，如果业务未实现某个流程，但又将其实例作为接口强行来使用的话：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line">typeOrderCreatorinterface&#123;</span><br><span class="line">ValidateUser()</span><br><span class="line">CreateOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeBookOrderCreatorstruct&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(bocBookOrderCreator)</span><span class="title">ValidateUser</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">funccreateOrder(ocOrderCreator)&#123;</span><br><span class="line">oc.ValidateUser()</span><br><span class="line">oc.CreateOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcmain()&#123;</span><br><span class="line">createOrder(BookOrderCreator&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报出下述错误。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">command</span>-line-arguments</span></span><br><span class="line">./a.go:18:30:cannotuseBookOrderCreatorliteral(typeBookOrderCreator)astypeOrderCreatorinargumenttocreateOrder:</span><br><span class="line">BookOrderCreatordoesnotimplementOrderCreator(missingCreateOrdermethod)</span><br></pre></td></tr></table></figure>
<p>所以接口也可以认为是一种编译期进行检查的保证类型安全的手段。</p>
<h2 id="5-8-5表驱动开发"><a href="#5-8-5表驱动开发" class="headerlink" title="5.8.5表驱动开发"></a>5.8.5表驱动开发</h2><p>熟悉开源lint工具的同学应该见到过圈复杂度的说法，在函数中如果有<code>if</code>和<code>switch</code>的话，会使函数的圈复杂度上升，所以有强迫症的同学即使在入口一个函数中有<code>switch</code>，还是想要干掉这个<code>switch</code>，有没有什么办法呢？当然有，用表驱动的方式来存储我们需要实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funcentry()&#123;</span><br><span class="line">varbiBusinessInstance</span><br><span class="line">switchbusinessType&#123;</span><br><span class="line">caseTravelBusiness:</span><br><span class="line">bi=travelorder.New()</span><br><span class="line">caseMarketBusiness:</span><br><span class="line">bi=marketorder.New()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">returnerrors.New(<span class="string">"notsupportedbusiness"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">varbusinessInstanceMap=<span class="keyword">map</span>[<span class="keyword">int</span>]BusinessInstance&#123;</span><br><span class="line">TravelBusiness:travelorder.New(),</span><br><span class="line">MarketBusiness:marketorder.New(),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcentry()&#123;</span><br><span class="line">bi:=businessInstanceMap[businessType]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表驱动的设计方式，很多设计模式相关的书籍并没有把它作为一种设计模式来讲，但我认为这依然是一种非常重要的帮助我们来简化代码的手段。在日常的开发工作中可以多多思考，哪些不必要的<code>switchcase</code>可以用一个字典和一行代码就可以轻松搞定。</p>
<p>当然，表驱动也不是没有缺点，因为需要对输入<code>key</code>计算哈希，在性能敏感的场合，需要多加斟酌。</p>
<h1 id="5-9灰度发布和A-Btest"><a href="#5-9灰度发布和A-Btest" class="headerlink" title="5.9灰度发布和A/Btest"></a>5.9灰度发布和A/Btest</h1><p>中型的互联网公司往往有着以百万计的用户，而大型互联网公司的系统则可能要服务千万级甚至亿级的用户需求。大型系统的请求流入往往是源源不断的，任何风吹草动，都一定会有最终用户感受得到。例如你的系统在上线途中会拒绝一些上游过来的请求，而这时候依赖你的系统没有做任何容错，那么这个错误就会一直向上抛出，直到触达最终用户。形成一次对用户切切实实的伤害。这种伤害可能是在用户的APP上弹出一个让用户摸不着头脑的诡异字符串，用户只要刷新一下页面就可以忘记这件事。但也可能会让正在心急如焚地和几万竞争对手同时抢夺秒杀商品的用户，因为代码上的小问题，丧失掉了先发优势，与自己蹲了几个月的心仪产品失之交臂。对用户的伤害有多大，取决于你的系统对于你的用户来说有多重要。</p>
<p>不管怎么说，在大型系统中容错是重要的，能够让系统按百分比，分批次到达最终用户，也是很重要的。虽然当今的互联网公司系统，名义上会说自己上线前都经过了充分慎重严格的测试，但就算它们真得做到了，代码的bug总是在所难免的。即使代码没有bug，分布式服务之间的协作也是可能出现“逻辑”上的非技术问题的。</p>
<p>这时候，灰度发布就显得非常重要了，灰度发布也称为金丝雀发布，传说17世纪的英国矿井工人发现金丝雀对瓦斯气体非常敏感，瓦斯达到一定浓度时，金丝雀即会死亡，但金丝雀的致死量瓦斯对人并不致死，因此金丝雀被用来当成他们的瓦斯检测工具。互联网系统的灰度发布一般通过两种方式实现：</p>
<p>1.通过分批次部署实现灰度发布<br>2.通过业务规则进行灰度发布</p>
<p>在对系统的旧功能进行升级迭代时，第一种方式用的比较多。新功能上线时，第二种方式用的比较多。当然，对比较重要的老功能进行较大幅度的修改时，一般也会选择按业务规则来进行发布，因为直接全量开放给所有用户风险实在太大。</p>
<h2 id="5-9-1通过分批次部署实现灰度发布"><a href="#5-9-1通过分批次部署实现灰度发布" class="headerlink" title="5.9.1通过分批次部署实现灰度发布"></a>5.9.1通过分批次部署实现灰度发布</h2><p>假如服务部署在15个实例（可能是物理机，也可能是容器）上，我们把这15个实例分为四组，按照先后顺序，分别有1-2-4-8台机器，保证每次扩展时大概都是二倍的关系。</p>
<p><img src="../images/ch5-online-group.png" alt="onlinegroup"></p>
<p><em>图5-20分组部署</em></p>
<p>为什么要用2倍？这样能够保证我们不管有多少台机器，都不会把组划分得太多。例如1024台机器，也就只需要1-2-4-8-16-32-64-128-256-512部署十次就可以全部部署完毕。</p>
<p>这样我们上线最开始影响到的用户在整体用户中占的比例也不大，比如1000台机器的服务，我们上线后如果出现问题，也只影响1/1000的用户。如果10组完全平均分，那一上线立刻就会影响1/10的用户，1/10的业务出问题，那可能对于公司来说就已经是一场不可挽回的事故了。</p>
<p>在上线时，最有效的观察手法是查看程序的错误日志，如果较明显的逻辑错误，一般错误日志的滚动速度都会有肉眼可见的增加。这些错误也可以通过metrics一类的系统上报给公司内的监控系统，所以在上线过程中，也可以通过观察监控曲线，来判断是否有异常发生。</p>
<p>如果有异常情况，首先要做的自然就是回滚了。</p>
<h2 id="5-9-2通过业务规则进行灰度发布"><a href="#5-9-2通过业务规则进行灰度发布" class="headerlink" title="5.9.2通过业务规则进行灰度发布"></a>5.9.2通过业务规则进行灰度发布</h2><p>常见的灰度策略有多种，较为简单的需求，例如我们的策略是要按照千分比来发布，那么我们可以用用户id、手机号、用户设备信息，等等，来生成一个简单的哈希值，然后再求模，用伪代码表示一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pass3/1000</span></span><br><span class="line">funcpassed()<span class="keyword">bool</span>&#123;</span><br><span class="line">key:=hashFunctions(userID)%<span class="number">1000</span></span><br><span class="line">ifkey&lt;=<span class="number">2</span>&#123;</span><br><span class="line">returntrue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnfalse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-9-2-1可选规则"><a href="#5-9-2-1可选规则" class="headerlink" title="5.9.2.1可选规则"></a>5.9.2.1可选规则</h3><p>常见的灰度发布系统会有下列规则提供选择：</p>
<p>1.按城市发布<br>2.按概率发布<br>3.按百分比发布<br>4.按白名单发布<br>5.按业务线发布<br>6.按UA发布(APP、Web、PC)<br>7.按分发渠道发布</p>
<p>因为和公司的业务相关，所以城市、业务线、UA、分发渠道这些都可能会被直接编码在系统里，不过功能其实大同小异。</p>
<p>按白名单发布比较简单，功能上线时，可能我们希望只有公司内部的员工和测试人员可以访问到新功能，会直接把账号、邮箱写入到白名单，拒绝其它任何账号的访问。</p>
<p>按概率发布则是指实现一个简单的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funcisTrue()<span class="keyword">bool</span>&#123;</span><br><span class="line">returntrue/falseaccordingtotherateprovidedbyuser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其可以按照用户指定的概率返回<code>true</code>或者<code>false</code>，当然，<code>true</code>的概率加<code>false</code>的概率应该是100%。这个函数不需要任何输入。</p>
<p>按百分比发布，是指实现下面这样的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">funcisTrue(phonestring)<span class="keyword">bool</span>&#123;</span><br><span class="line">ifhashofphonematches&#123;</span><br><span class="line">returntrue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnfalse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况可以按照指定的百分比，返回对应的<code>true</code>和<code>false</code>，和上面的单纯按照概率的区别是这里我们需要调用方提供给我们一个输入参数，我们以该输入参数作为源来计算哈希，并以哈希后的结果来求模，并返回结果。这样可以保证同一个用户的返回结果多次调用是一致的，在下面这种场景下，必须使用这种结果可预期的灰度算法，见<em>图5-21</em>所示。</p>
<p><img src="../images/ch5-set-time-line.png" alt="set和get流程不应该因为灰度走到不同版本的API"></p>
<p><em>图5-21先set然后马上get</em></p>
<p>如果采用随机策略，可能会出现像<em>图5-22</em>这样的问题：</p>
<p><img src="../images/ch5-set-time-line_2.png" alt="set和get流程不应该因为灰度走到不同版本的API"></p>
<p><em>图5-22先set然后马上get</em></p>
<p>举个具体的例子，网站的注册环节，可能有两套API，按照用户ID进行灰度，分别是不同的存取逻辑。如果存储时使用了V1版本的API而获取时使用V2版本的API，那么就可能出现用户注册成功后反而返回注册失败消息的诡异问题。</p>
<h2 id="5-9-3如何实现一套灰度发布系统"><a href="#5-9-3如何实现一套灰度发布系统" class="headerlink" title="5.9.3如何实现一套灰度发布系统"></a>5.9.3如何实现一套灰度发布系统</h2><p>前面也提到了，提供给用户的接口大概可以分为和业务绑定的简单灰度判断逻辑。以及输入稍微复杂一些的哈希灰度。我们来分别看看怎么实现这样的灰度系统（函数）。</p>
<h3 id="5-9-3-1业务相关的简单灰度"><a href="#5-9-3-1业务相关的简单灰度" class="headerlink" title="5.9.3.1业务相关的简单灰度"></a>5.9.3.1业务相关的简单灰度</h3><p>公司内一般都会有公共的城市名字和id的映射关系，如果业务只涉及中国国内，那么城市数量不会特别多，且id可能都在10000范围以内。那么我们只要开辟一个一万大小左右的bool数组，就可以满足需求了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">varcityID2Open=[<span class="number">12000</span>]<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">funcinit()&#123;</span><br><span class="line">readConfig()</span><br><span class="line">fori:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(cityID2Open);i++&#123;</span><br><span class="line">ifcityiisopenedinconfigs&#123;</span><br><span class="line">cityID2Open[i]=<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcisPassed(cityIDint)<span class="keyword">bool</span>&#123;</span><br><span class="line">returncityID2Open[cityID]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果公司给cityID赋的值比较大，那么我们可以考虑用map来存储映射关系，map的查询比数组稍慢，但扩展会灵活一些：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">varcityID2Open=<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">funcinit()&#123;</span><br><span class="line">readConfig()</span><br><span class="line">for_,city:=rangeopenCities&#123;</span><br><span class="line">cityID2Open[city]=<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcisPassed(cityIDint)<span class="keyword">bool</span>&#123;</span><br><span class="line">if_,ok:=cityID2Open[cityID];ok&#123;</span><br><span class="line">returntrue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnfalse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按白名单、按业务线、按UA、按分发渠道发布，本质上和按城市发布是一样的，这里就不再赘述了。</p>
<p>按概率发布稍微特殊一些，不过不考虑输入实现起来也很简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">funcinit()&#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rate为0~100</span></span><br><span class="line">funcisPassed(rateint)<span class="keyword">bool</span>&#123;</span><br><span class="line">ifrate&gt;=<span class="number">100</span>&#123;</span><br><span class="line">returntrue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifrate&gt;<span class="number">0</span>&amp;&amp;rand.Int(<span class="number">100</span>)&gt;rate&#123;</span><br><span class="line">returntrue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnfalse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意初始化种子。</p>
<h3 id="5-9-3-2哈希算法"><a href="#5-9-3-2哈希算法" class="headerlink" title="5.9.3.2哈希算法"></a>5.9.3.2哈希算法</h3><p>求哈希可用的算法非常多，比如md5，crc32，sha1等等，但我们这里的目的只是为了给这些数据做个映射，并不想要因为计算哈希消耗过多的cpu，所以现在业界使用较多的算法是murmurhash，下面是我们对这些常见的hash算法的简单benchmark。</p>
<p>下面使用了标准库的md5，sha1和开源的murmur3实现来进行对比。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"crypto/md5"</span></span><br><span class="line"><span class="string">"crypto/sha1"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/spaolacci/murmur3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">varstr=<span class="string">"helloworld"</span></span><br><span class="line"></span><br><span class="line">funcmd5Hash()[<span class="number">16</span>]<span class="keyword">byte</span>&#123;</span><br><span class="line">returnmd5.Sum([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcsha1Hash()[<span class="number">20</span>]<span class="keyword">byte</span>&#123;</span><br><span class="line">returnsha1.Sum([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcmurmur32()<span class="keyword">uint32</span>&#123;</span><br><span class="line">returnmurmur3.Sum32([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcmurmur64()<span class="keyword">uint64</span>&#123;</span><br><span class="line">returnmurmur3.Sum64([]<span class="keyword">byte</span>(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为这些算法写一个基准测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line">funcBenchmarkMD5(b*testing.B)&#123;</span><br><span class="line">fori:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">md5Hash()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcBenchmarkSHA1(b*testing.B)&#123;</span><br><span class="line">fori:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">sha1Hash()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcBenchmarkMurmurHash32(b*testing.B)&#123;</span><br><span class="line">fori:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">murmur32()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcBenchmarkMurmurHash64(b*testing.B)&#123;</span><br><span class="line">fori:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">murmur64()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看看运行效果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/t/g/hash_benchgit:master❯❯❯gotest-bench=.</span><br><span class="line">goos:darwin</span><br><span class="line">goarch:amd64</span><br><span class="line">BenchmarkMD5-410000000180ns/op</span><br><span class="line">BenchmarkSHA1-410000000211ns/op</span><br><span class="line">BenchmarkMurmurHash32-45000000025.7ns/op</span><br><span class="line">BenchmarkMurmurHash64-42000000066.2ns/op</span><br><span class="line">PASS</span><br><span class="line">ok_/Users/caochunhui/test/go/hash_bench7.050s</span><br></pre></td></tr></table></figure>
<p>可见murmurhash相比其它的算法有三倍以上的性能提升。显然做负载均衡的话，用murmurhash要比md5和sha1都要好，这些年社区里还有另外一些更高效的哈希算法涌现，感兴趣的读者可以自行调研。</p>
<h3 id="5-9-3-3分布是否均匀"><a href="#5-9-3-3分布是否均匀" class="headerlink" title="5.9.3.3分布是否均匀"></a>5.9.3.3分布是否均匀</h3><p>对于哈希算法来说，除了性能方面的问题，还要考虑哈希后的值是否分布均匀。如果哈希后的值分布不均匀，那也自然就起不到均匀灰度的效果了。</p>
<p>以murmur3为例，我们先以15810000000开头，造一千万个和手机号类似的数字，然后将计算后的哈希值分十个桶，并观察计数是否均匀：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">packagemain</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/spaolacci/murmur3"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">varbucketSize=<span class="number">10</span></span><br><span class="line"></span><br><span class="line">funcmain()&#123;</span><br><span class="line">varbucketMap=<span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fori:=<span class="number">15000000000</span>;i&lt;<span class="number">15000000000</span>+<span class="number">10000000</span>;i++&#123;</span><br><span class="line">hashInt:=murmur64(fmt.Sprint(i))%<span class="keyword">uint64</span>(bucketSize)</span><br><span class="line">bucketMap[hashInt]++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(bucketMap)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcmurmur64(pstring)<span class="keyword">uint64</span>&#123;</span><br><span class="line">returnmurmur3.Sum64([]<span class="keyword">byte</span>(p))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[7:9994755:10003591:9999456:10002003:10001939:10007652:1000044\</span><br><span class="line">4:10003438:10008230:997853]</span><br></pre></td></tr></table></figure>
<p>偏差都在1/100以内，可以接受。读者在调研其它算法，并判断是否可以用来做灰度发布时，也应该从本节中提到的性能和均衡度两方面出发，对其进行考察。</p>
<h1 id="5-10补充说明"><a href="#5-10补充说明" class="headerlink" title="5.10补充说明"></a>5.10补充说明</h1><p>现代的软件工程是离不开Web的，广义地来讲，Web甚至可以不用非得基于http协议。只要是CS或者BS架构，都可以认为是Web系统。</p>
<p>即使是在看起来非常封闭的游戏系统里，因为玩家们与日俱增的联机需求，也同样会涉及到远程通信，这里面也会涉及到很多Web方面的技术。</p>
<p>所以这个时代，Web编程是一个程序员所必须接触的知识领域。无论你的目标是成为架构师，是去创业，或是去当技术顾问。Web方面的知识都会成为你的硬通货。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言高级编程/" rel="tag"># Go语言高级编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/07/第9章-编程哲学/" rel="next" title="第9章 编程哲学">
                <i class="fa fa-chevron-left"></i> 第9章 编程哲学
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/07/第6章-分布式系统/" rel="prev" title="第6章 分布式系统">
                第6章 分布式系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Web开发简介"><span class="nav-number">1.</span> <span class="nav-text">Web开发简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#router请求路由"><span class="nav-number">2.</span> <span class="nav-text">router请求路由</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#httprouter"><span class="nav-number">2.1.</span> <span class="nav-text">httprouter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-number">2.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩字典树创建过程"><span class="nav-number">2.3.</span> <span class="nav-text">压缩字典树创建过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-1root节点创建"><span class="nav-number">2.3.1.</span> <span class="nav-text">5.2.3.1root节点创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子节点插入"><span class="nav-number">2.3.2.</span> <span class="nav-text">子节点插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边分裂"><span class="nav-number">2.3.3.</span> <span class="nav-text">边分裂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子节点冲突处理"><span class="nav-number">2.3.4.</span> <span class="nav-text">子节点冲突处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#中间件"><span class="nav-number">3.</span> <span class="nav-text">中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代码泥潭"><span class="nav-number">3.1.</span> <span class="nav-text">代码泥潭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用中间件剥离非业务逻辑"><span class="nav-number">3.2.</span> <span class="nav-text">使用中间件剥离非业务逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更优雅的中间件写法"><span class="nav-number">3.3.</span> <span class="nav-text">更优雅的中间件写法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哪些事情适合在中间件中做"><span class="nav-number">3.4.</span> <span class="nav-text">哪些事情适合在中间件中做</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#validator请求校验"><span class="nav-number">4.</span> <span class="nav-text">validator请求校验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-1重构请求校验函数"><span class="nav-number">4.1.</span> <span class="nav-text">5.4.1重构请求校验函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-2用validator解放体力劳动"><span class="nav-number">4.2.</span> <span class="nav-text">5.4.2用validator解放体力劳动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-3原理"><span class="nav-number">4.3.</span> <span class="nav-text">5.4.3原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-5Database和数据库打交道"><span class="nav-number">5.</span> <span class="nav-text">5.5Database和数据库打交道</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-1从database-sql讲起"><span class="nav-number">5.1.</span> <span class="nav-text">5.5.1从database/sql讲起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-2提高生产效率的ORM和SQLBuilder"><span class="nav-number">5.2.</span> <span class="nav-text">5.5.2提高生产效率的ORM和SQLBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-3脆弱的数据库"><span class="nav-number">5.3.</span> <span class="nav-text">5.5.3脆弱的数据库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-6Ratelimit服务流量限制"><span class="nav-number">6.</span> <span class="nav-text">5.6Ratelimit服务流量限制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-1常见的流量限制手段"><span class="nav-number">6.1.</span> <span class="nav-text">5.6.1常见的流量限制手段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-2原理"><span class="nav-number">6.2.</span> <span class="nav-text">5.6.2原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-3服务瓶颈和QoS"><span class="nav-number">6.3.</span> <span class="nav-text">5.6.3服务瓶颈和QoS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-7layout常见大型Web项目分层"><span class="nav-number">7.</span> <span class="nav-text">5.7layout常见大型Web项目分层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-8接口和表驱动开发"><span class="nav-number">8.</span> <span class="nav-text">5.8接口和表驱动开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-1业务系统的发展过程"><span class="nav-number">8.1.</span> <span class="nav-text">5.8.1业务系统的发展过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-2使用函数封装业务流程"><span class="nav-number">8.2.</span> <span class="nav-text">5.8.2使用函数封装业务流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-3使用接口来做抽象"><span class="nav-number">8.3.</span> <span class="nav-text">5.8.3使用接口来做抽象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-4接口的优缺点"><span class="nav-number">8.4.</span> <span class="nav-text">5.8.4接口的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-5表驱动开发"><span class="nav-number">8.5.</span> <span class="nav-text">5.8.5表驱动开发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-9灰度发布和A-Btest"><span class="nav-number">9.</span> <span class="nav-text">5.9灰度发布和A/Btest</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-1通过分批次部署实现灰度发布"><span class="nav-number">9.1.</span> <span class="nav-text">5.9.1通过分批次部署实现灰度发布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-2通过业务规则进行灰度发布"><span class="nav-number">9.2.</span> <span class="nav-text">5.9.2通过业务规则进行灰度发布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-2-1可选规则"><span class="nav-number">9.2.1.</span> <span class="nav-text">5.9.2.1可选规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-3如何实现一套灰度发布系统"><span class="nav-number">9.3.</span> <span class="nav-text">5.9.3如何实现一套灰度发布系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-3-1业务相关的简单灰度"><span class="nav-number">9.3.1.</span> <span class="nav-text">5.9.3.1业务相关的简单灰度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-3-2哈希算法"><span class="nav-number">9.3.2.</span> <span class="nav-text">5.9.3.2哈希算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-3-3分布是否均匀"><span class="nav-number">9.3.3.</span> <span class="nav-text">5.9.3.3分布是否均匀</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-10补充说明"><span class="nav-number">10.</span> <span class="nav-text">5.10补充说明</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
