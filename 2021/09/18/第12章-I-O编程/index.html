<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Go语言编程入门与实战技巧">
<meta property="og:type" content="article">
<meta property="og:title" content="第12章 I&#x2F;O编程">
<meta property="og:url" content="http://yoursite.com/2021/09/18/第12章-I-O编程/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-11-11T08:08:04.323Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第12章 I&#x2F;O编程">
<meta name="twitter:description" content="思考并回答以下问题：">






  <link rel="canonical" href="http://yoursite.com/2021/09/18/第12章-I-O编程/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第12章 I/O编程 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">专注</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/18/第12章-I-O编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="放弃会成为一种习惯">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第12章 I/O编程

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-18 21:16:37" itemprop="dateCreated datePublished" datetime="2021-09-18T21:16:37+08:00">2021-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-11-11 16:08:04" itemprop="dateModified" datetime="2021-11-11T16:08:04+08:00">2021-11-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">25k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">23 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>在前面的学习中，几乎每个例子都有标准库的身影，标准库为大部分程序的编写提供了必要的基础功能，本章内容根据功能分类介绍了部分标准库，主要包括“输入/输出”“文件系统”“文本与数据处理”“数学计算”以及“同步”相关的包。</p>
<h1 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a><span style="color:#339AFF;">输入/输出</span></h1><p>Go语言将I/O操作封装在以下几个包中。</p>
<ul>
<li>io：为I/O原语（I/O primitives）提供基本的接口，在io包中最重要的是两个接口——Reader和Writer接口。本章所提到的各种I/O包，都和这两个接口有关，只要程序实现了这两个接口，它就有了I/O的功能。</li>
<li>io/ioutil：封装一些实用的I/O函数，这个包主要提供了一些常用、方便的I/O操作函数。</li>
<li>fmt：实现格式化I/O，类似C语言中的printf和scanf。</li>
<li>bufio：实现带缓冲的I/O。它封装了io.Reader和io.Writer对象，创建了另一个对象（Reader和Writer），在提供缓冲的同时实现了一些文本I/O的功能。</li>
</ul>
<h2 id="io：基本I-O接口"><a href="#io：基本I-O接口" class="headerlink" title="io：基本I/O接口"></a><span style="color:#00ACC1;">io：基本I/O接口</span></h2><p>io包为I/O原语提供了基本的接口，它主要包装了这些原语的已有实现。由于这些接口和原语以不同的实现包装了低级操作，因此除非另行通知，否则客户端不应假定它们对于并行执行是安全的。</p>
<p>在io包中最重要的是两个接口：Reader和Writer接口，本章所提到的各种io包，都与这两个接口有关，也就是说，只要实现了这两个接口，它就有了I/O的功能。</p>
<p><strong>1，Reader接口</strong></p>
<p>Reader接口的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>)(n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是io.Reader接口定义，只有一个Read方法，这个方法接受一个byte类型的切片，并返回两个值，一个是读入的字节数n，另一个是错误err。</p>
<p>io.Reader接口的规则比较复杂，整理一下分为以下几点：<br>（1）Read方法最多读取len(p)字节的数据，并保存到p；<br>（2）Read方法返回读取的字节数以及任何发生的错误信息；<br>（3）读取的字节数n要满足0≤n≤len(p)；<br>（4）读取的字节数n＜len(p)时，表示读取的数据不足以填满p，这时方法会立即返回，而不是等待更多的数据；<br>（5）读取过程中遇到错误，会返回读取的字节数n以及相应的错误err；<br>（6）在底层输入流结束时，方法会返回n＞0字节，但是遇到错误可能会中断（EOF），也可以返回nil；<br>（7）在第6种情况下，再次调用Read方法的时候，肯定会返回(0,EOF)；<br>（8）调用Read方法时，如果n&gt;0时，优先处理读入的数据，然后再处理错误err，EOF也要这样处理；<br>（9）Read方法不鼓励返回n=0并且err=nil的情况（返回字节数n为空时不推荐把err设置为nil）。</p>
<p>注意第8条，即使在读取的时候遇到错误，也应该处理已经读到的数据，因为这些已经读到的数据是正确的，如果不处理那些丢失的数据（再读一次之类），读到的数据就不完整了。</p>
<p>由于Reader接口的方法集只包含一个Read方法，因此，所有实现了Read方法的类型都实现了io.Reader接口，也就是说，在所有需要io.Reader的地方，可以传递实现了Read()方法的类型的实例</p>
<p>下面，通过具体例子来谈谈该接口的用法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFrom</span><span class="params">(reader io.Reader, num <span class="keyword">int</span>)</span><span class="params">([]<span class="keyword">byte</span>, error)</span></span>&#123; </span><br><span class="line">    p := <span class="built_in">make</span>([]<span class="keyword">byte</span>, num)</span><br><span class="line">    n, err := reader.Read(p)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p[:n],<span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReadFrom函数将io.Reader作为参数，也就是说，ReadFrom可以从任意地方读取数据，只要来源实现了io.Reader接口。比如，可以从标准输入、文件、字符串等读取数据，示例代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从标准输入读取</span></span><br><span class="line">data, err = ReadFrom(os.Stdin,<span class="number">11</span>)</span><br><span class="line"><span class="comment">// 从普通文件读取，其中file是os.File的实例</span></span><br><span class="line">data, err = ReadFrom(file,<span class="number">9</span>)</span><br><span class="line"><span class="comment">// 从字符串读取</span></span><br><span class="line">data, err = ReadFrom(strings.NewReader(<span class="string">"from string"</span>), <span class="number">12</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意，io.EOF变量的定义：<code>var EOF = errors.New(&quot;EOF&quot;)</code>是error类型。根据Reader接口的说明，在n&gt;0且数据被读完的情况下，返回的error有可能是EOF也有可能是nil。</p>
<p><strong>2，Writer接口</strong></p>
<p>Writer接口的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面定义位置的源码注释来看，这个方法有严格的规范要求，要想实现一个io.Writer接口，必须遵循以下规则：<br>（1）Write方法向底层数据流写入len(p)字节的数据，这些数据来自于切片p；<br>（2）返回被写入的字节数n，其中0≤n≤len(p)；<br>（3）如果n\&lt;len(p)，则必须返回一些非nil的err（和Read一样）；<br>（4）如果中途出现问题，也要返回非nil的err；<br>（5）Write方法绝对不能修改切片p以及其中的数据。</p>
<p>在上一个例子中，实现了一个函数接收一个io.Reader类型的参数。下面通过标准库的例子来学习。</p>
<p>在fmt标准库中，有一组函数：Fprint/Fprintf/Fprintln，它们接收一个io.Writer类型参数（第一个参数），也就是说它们将数据格式化输出到io.Writer中。以fmt.Fprintln为例同时看一下fmt.Println函数的源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很显然，fmt.Println会将内容输出到标准输出中。下面将详细介绍fmt包。</p>
<h2 id="fmt：格式化I-O"><a href="#fmt：格式化I-O" class="headerlink" title="fmt：格式化I/O"></a><span style="color:#00ACC1;">fmt：格式化I/O</span></h2><p>fmt包实现了格式化I/O函数，类似于C语言中的printf和scanf。格式占位符衍生自C语言，但比C语言更简单。</p>
<p>fmt包的官方文档对Printing和Scanning有很详细的说明，这里就直接引用文档进行说明，同时附上额外的说明或例子，之后再介绍具体的函数使用。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Website <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结构体时</span></span><br><span class="line"><span class="keyword">var</span> site = Website&#123;Name:<span class="string">"Golang"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1，Print序列函数</strong></p>
<p>这里说的Print序列函数包括：Fprint/Fprintf/Fprintln/Sprint/Sprintf/Sprintln/Print/Printf/Println。之所以将它们放在一起介绍，是因为它们的使用方式类似，参数含义也类似。</p>
<p>在一般情况下，将Fprint/Fprintf/Fprintln归为一类；Sprint/Sprintf/Sprintln归为一类；Print/Printf/Println归为另一类。其中，Print/Printf/Println会调用相应的F开头的函数，如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprint(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Fprint/Fprintf/Fprintln函数的第一个参数接收一个io.Writer类型，会将内容输出到io.Writer中去。而Print/Printf/Println函数是将内容输出到标准输出中，因此，直接调用F类函数做这件事，并将os.Stdout作为第一个参数传入。</p>
<p>Sprint/Sprintf/Sprintln只是格式化内容为string类型，而并不输出到某处，需要格式化字符串并返回时，可以用Stdout函数。</p>
<p>在这三组函数中，Sprintf/Fprintf/Printf函数通过指定的格式输出或格式化内容；Sprint/Fprint/Print函数只是使用默认的格式输出或格式化内容；Sprintln/Fprintln/Println函数使用默认的格式输出或格式化内容，同时会在最后加上“换行符”。</p>
<p>Print序列函数的最后一个参数都是<code>a ...interface{}</code>这种不定参数。对于Sprintf/Fprintf/Printf序列，这个不定参数的实参个数应该和formt参数的占位符个数一致，否则会出现格式化错误；而对于其他函数，当不定参数的实参个数为多个时，它们之间会直接（对于Sprint/Fprint/Print）或通过” “（空格）（对于Sprintln/Fprintln/Println）连接起来（对于Sprint/Fprint/Print，当两个参数都不是字符串时，会自动添加一个空格，否则不会添加）。利用这一点，我们可以做如下事情<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 := fmt.Sprintln(<span class="string">"example.com"</span>, <span class="number">2017</span>)</span><br><span class="line">result2 := fmt.Sprint(<span class="string">"example.com"</span>, <span class="number">2017</span>)</span><br></pre></td></tr></table></figure></p>
<p>result1的值是example.com 2017，result2的值是example.com2017，这起到了连接字符串的作用，而不需要通过strconv.Itoa()转换。</p>
<p>Print序列函数用得较多，而且也易于使用（可能需要掌握一些常用的占位符用法），接下来结合fmt包中几个相关的接口来掌握更多关于Print的内容。</p>
<p><strong>2，Stringer接口</strong></p>
<p>Stringer接口的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据Go语言中实现接口的定义，一个类型只要有String（ string方法，就说它实现了Stringer接口。而在本节开始已经说过，如果格式化输出某种类型的值，只要它实现了String（方法，那么就会调用String()方法进行处理。</p>
<p>定义如下struct：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Sex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给Person实现String方法，下面输出Person的实例：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p：=&amp;Person&#123;<span class="string">"张三"</span>，<span class="number">28</span>，<span class="number">0</span>&#125;</span><br><span class="line">fmt.Println(p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">&amp;&#123;张三280&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>接下来，为Person增加String方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">buffer ：= bytes.NewBufferString（<span class="string">"这是"</span>）</span><br><span class="line">buffer.WriteString(this.Name+<span class="string">","</span>)</span><br><span class="line"><span class="keyword">if</span> this.Sex ==<span class="number">0</span>&#123;</span><br><span class="line">buffer.Writestring（<span class="string">"他"</span>）</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">buffer.writeString（<span class="string">"她"</span>）</span><br><span class="line">buffer.Writestring（<span class="string">"今年"</span>）</span><br><span class="line">buffer.WriteString(strconv.Itoa(this.Age)) buffer. Writestring（<span class="string">"岁。"</span>）</span><br><span class="line"><span class="keyword">return</span> buffer.String()</span><br></pre></td></tr></table></figure></p>
<p>这个时候运行：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p:=&amp;Person&#123;<span class="string">"zuolan"</span>,<span class="number">28</span>,&#125;</span><br><span class="line">fmt.Println(p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">这是张三，他今年28岁。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>可见，Stringer接口和Java中的ToString方法类似。</p>
<p><strong>3，Formatter接口</strong></p>
<p>Formatter接口的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Formatter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Format(f State, c <span class="keyword">rune</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Formatter接口由带有定制的格式化符的值所实现。Format的实现可调用Sprintf或Fprintf（f）等函数来生成其输出。</p>
<p>也就是说，通过实现Formatter接口可以做到自定义输出格式（自定义占位符）。接着上面的例子，我们为Person增加一个方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(this *Person)</span> <span class="title">Format</span><span class="params">(f fmt.state, c <span class="keyword">rune</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> c=<span class="string">'l'</span>&#123; f.Write([]<span class="keyword">byte</span>(this.<span class="keyword">string</span>()))</span><br><span class="line">f.Write（[]<span class="keyword">byte</span>（<span class="string">"Person有三个字段。"</span>））</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//没有此句，会导致fmt.Printf（"%s"，p）什么也不输出</span></span><br><span class="line">f.Write([]<span class="keyword">byte</span>(fmt.Sprintln(this.<span class="keyword">string</span>())))</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>这样，Person便实现了Formatter接口，这时再运行：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p :=&amp;Person&#123;<span class="string">"zuolan"</span>，<span class="number">28</span>,<span class="number">0</span>&#125;</span><br><span class="line">fmt.printf(<span class="string">"%L"</span>,p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">这是张三，他今年28岁。Person有三个字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要解释以下几点：</p>
<ul>
<li>fmt.State是一个接口。由于Format方法是被fmt包调用的，它内部会实例化一个fmt.State接口的实例，我们不需要关心该接口。</li>
<li>可以实现自定义占位符，同时fmt包中和类型相对应的预定义占位符会无效。因此例子中Format的实现加上了else子句。</li>
<li>实现了Formatter接口，相应的Stringer接口不起作用。但实现了Formatter接口的类型应该实现Stringer接口，这样方便在Format方法中调用String0方法。就像本例的做法。</li>
<li>Format方法的第二个参数是占位符中%后的字母（有精度和宽度会被忽略，只保留字母）。</li>
</ul>
<p>在一般情况下，不需要实现Formatter接口。如果对Formatter接口的实现感兴趣，可以看看标准库math/big包中Int类型的Formatter接口实现。</p>
<p>State接口相关的说明如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">//Write函数用于打印出已格式化的输出</span></span><br><span class="line">Write(b []<span class="keyword">byte</span>) (ret <span class="keyword">int</span>, err error)</span><br><span class="line"><span class="comment">//Width返回宽度选项的值以及它是否已被设置</span></span><br><span class="line">Width()(widint, ok <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//Precision返回精度选项的值以及它是否已被设置</span></span><br><span class="line">Precision()(prec <span class="keyword">int</span>, ok <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//Flag返回标记c（一个字符）是否已被设置</span></span><br><span class="line">Flag(c <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>fmt包的print.go文件中的typeppstruct实现了State接口。由于State接口有Write方法，因此，实现了State接口的类型必然实现了io.Writer接口。</p>
<p><strong>4，GoStringer接口</strong></p>
<p>GoStringer接口的定义如下；<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GoStringer <span class="keyword">interface</span> &#123;</span><br><span class="line">GoString() <span class="keyword">string</span></span><br><span class="line">￥<span class="number">12</span>↑<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>该接口定义了类型的Go语言语法格式。用于打印（Printf）格式化占位符为%#v的值。继续用前面的例子演示，执行以下代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p：=&amp;Person&#123;<span class="string">"张三"</span>，<span class="number">28</span>，日&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>,p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">&amp;main.Person&#123;Name："张三"，Age：28，Sex：0&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>接着为Person增加方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Person)</span> <span class="title">GoString</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"&amp;Person&#123;姓名："</span>+this.Name+<span class="string">"，年龄："</span>+strconv.Itoa（this.Age）+<span class="string">"，性别： "</span>+strconv.Itoa(this.sex)+<span class="string">"&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候再执行：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p：=&amp;Person&#123;<span class="string">"张三"</span>，<span class="number">28</span>，日&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v"</span>，p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回；</span></span><br><span class="line"><span class="comment">&amp;Person&#123;姓名：张三，年龄：28，性别：0&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>在一般情况下不需要实现该接口。</p>
<p><strong>5，Scan序列函数</strong></p>
<p>该序列函数和Print序列函数相对应，包括：Fscan/Fscanf/Fscanln/Sscan/Sscanf/Sscanln/Scan/Scanf/Scanln。</p>
<p>在一般情况下将Fscan/Fscanf/Fscann归为一类；Sscan/Sscanf/Sscanln归为一类；Scan/Scanf/Scanln归为另一类。其中，Scan/Scanf/Scanln会调用相应的F开头的那一类函数，如：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a. ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(nint, err error)</span></span>&#123;</span><br><span class="line">「</span><br><span class="line"><span class="keyword">return</span> Fscan(os.stdin, a...)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Fscan/Fscanf/Fscanln函数的第一个参数接收一个io.Reader类型，从其中读取内容并赋值给相应的实参。而Scan/Scanf/Scanln正是从标准输入获取内容，因此，直接调用F类函数做这件事，并将os.Stdin作为第一个参数传入。</p>
<p>Sscan/Sscanf/Sscanln则直接从字符串中获取内容。<br>对于Scan/Scanf/Scanln三个函数的区别，通过例子来说明，为了方便讲解，使用Sscan/Sscanf/Sscanln这组函数。</p>
<p>(1) Scan/FScan/Sscan</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> （ name <span class="keyword">string</span> age <span class="keyword">int</span> ）n，_：=fmt.Sscan（<span class="string">"张三28"</span>，&amp;name，&amp;age）</span><br><span class="line"><span class="comment">//可以将"张三28”中的空格换成“\n"试试</span></span><br><span class="line"><span class="comment">//n，_：=fmt.sscan（"张三\n28"，&amp;name，&amp;age）</span></span><br><span class="line">fmt.Println(n, name, age)</span><br><span class="line"><span class="comment">//返回：2张三28</span></span><br></pre></td></tr></table></figure>
<p>不管“张三28”是用空格分隔还是用“\n”分隔，输出一样，也就是说，Scan/FScan/Sscan这组函数将连续由空格分隔的值存储为连续的实参（换行符也记为空格）。</p>
<p>(2) Scanf/FScanf/Sscanf</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> （ name <span class="keyword">string</span> age <span class="keyword">int</span>）n，_：=fmt.Sscanf（<span class="string">"张三28"</span>，<span class="string">"%s%d"</span>，&amp;name，&amp;age） <span class="comment">//可以将"张三28"中的空格换成"\n"试试</span></span><br><span class="line"><span class="comment">//n，_：=fmt.Sscanf（"张三\n28"，"%s%d"，&amp;name，&amp;age）</span></span><br><span class="line">fmt.Println(n,name, age)</span><br><span class="line"><span class="comment">//返回：2张三28</span></span><br></pre></td></tr></table></figure>
<p>如果将“空格”分隔改为“\n”分隔，则输出为：1zuolan0，可见，Scanf/FScanf/Sscanf这组函数将连续由空格分隔的值存储为连续的实参，其格式由format决定，换行符处停止扫描（Scan）。</p>
<p>(3) Scanln/FScanln/Sscanln</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> （ name <span class="keyword">string</span> age <span class="keyword">int</span> ）n，_：=fmt.Sscanln（<span class="string">"张三28"</span>，&amp;name，&amp;age）</span><br><span class="line"><span class="comment">//可以将"张三28"中的空格换成“\n”试试</span></span><br><span class="line"><span class="comment">//n，_：=fmt.sscanln（"张三\n28"，&amp;name，&amp;age）</span></span><br><span class="line">fmt.Println(n, name, age)</span><br><span class="line"><span class="comment">//返回：2张三28</span></span><br></pre></td></tr></table></figure>
<p>Scanln/FScanln/Sscanln表现和上一组一样，遇到“\n”停止（对于Scanln，表示从标准输入获取内容，最后需要回车）。在一般情况下使用Scan/Scanf/Scanln这组函数。</p>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a><span style="color:#00ACC1;">文本处理</span></h2><p>Go语言标准库中有几个包专门用于处理文本。</p>
<ul>
<li>strings：字符串操作，这个包提供了很多操作字符串的简单函数，通常一般的字符串操作需求都可以在这个包中找到。</li>
<li>vbytes： byte slice便利操作，在Go语言中string是内置类型，同时它与普通的slice 类型有着相似的性质，均可以进行切片（slice）操作。</li>
<li>strconv：字符串和基本数据类型之间转换，因为在Go语言中，没有隐式类型转换，字符串类型和int、float、bool等类型之间不能直接使用基本数据类型那套方法转换，需要使用这个包的方法实现转换。</li>
<li>regexp：正则表达式，谈到字符串必然离不开正则表达式，这个包提供了正则表达式的功能。</li>
<li>unicode：  Unicode编码、UTF-8/16编码。</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a><span style="color:#339AFF;">文件系统</span></h1><p>I/O操作只是对文件的读写，os包还提供了访问文件的其他一些属性，例如权限、大小等。可以进行文件夹的新建、删除、移动、复制、重命名等。</p>
<p>os包提供了平台无关的操作系统功能接口，其错误处理采用的是UNIX风格的设计。</p>
<h2 id="os：系统功能实现"><a href="#os：系统功能实现" class="headerlink" title="os：系统功能实现"></a><span style="color:#00ACC1;">os：系统功能实现</span></h2><p>os包提供了与平台无关的操作系统功能接口。尽管错误处理是Go语言风格，但设计是UNIX风格，所以，失败的调用会返回error而非错误码。通常error会包含更多信息，例如，如果使用一个文件名的调用（如Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为*PathError，错误内部可以通过解包（解析该引用值的具体信息，返回类型的内部包含对应错误的详细内容）获得更多信息。</p>
<p>os包的接口规定实现在所有操作系统中都是一致的。有一些某个系统特定的功能，需要使用syscall获取。实际上，os依赖于syscall。在实际编程中，我们应该总是优先使用os中提供的功能，而不是syscall。</p>
<p>下面是一个简单的例子，打开一个文件并从中读取一些数据：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">"file.go"</span>) <span class="comment">// 用于读取访问。</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果打开失败，错误字符串是能描述原因的，例如：<code>open file.go: no such file or directory</code>，不像C语言，需要额外的函数（或宏）来解释错误码。</p>
<p>详尽的os包与io包操作都在前后介绍过（本章第一节和下一节分别介绍io包和os包的内容），此处不再赘述。</p>
<h2 id="path：兼容路径操作"><a href="#path：兼容路径操作" class="headerlink" title="path：兼容路径操作"></a><span style="color:#00ACC1;">path：兼容路径操作</span></h2><p>path/filepath包涉及路径操作时，路径分隔符使用os.PathSeparator，不同系统的路径表示方式有所不同，比如UNIX和Windows差别很大。Path包能够处理所有的文件路径，不管是什么系统。注意，路径操作函数并不会校验路径是否真实存在。</p>
<p><strong>1，解析路径名字符串</strong></p>
<p>Dir()和Base()函数将一个路径名字符串分解成目录和文件名两部分（这些函数与UNIX中的dirmame和basename命令类似，但如果路径以/结尾，Dir()的行为和dirname不太一致）。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dir</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Base</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>Dir()返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用Split去掉最后一个元素后，会简化路径并去掉末尾的斜杠。如果路径是空字符串，会返回“.”，如果路径是“/”开头并且后面是路径则返回“/”，其他任何情况下都不会返回以“/”结尾的路径。</p>
<p>Base()函数返回路径的最后一个元素。在提取元素前会去掉末尾的“/”。如果路径是空，会返回“.”；如果路径是只有一个“/”构成的，会返回“/”。</p>
<p>简单来说，给定路径名/home/zuolan/example.go，Dir()返回/home/zuolan，而Base()返回example.go。</p>
<p>如果给定路径名/home/zuolan/example/，Dir()返回/home/zuolan/example（这与UNIX中的dirname不一致，dirname会返回/home/zuolan，如果要和dirname一样，应该在调用Dir（之前先将末尾的“/”去掉），而Base()返回example。</p>
<p>此外，Ext()可以获得路径中文件名的扩展名，例如：<code>func Ext(path string) string</code></p>
<p>Ext函数返回path文件扩展名。扩展名是路径中最后一个从“.”开始的部分，包括“.”。如果该元素没有“.”会返回空字符串。</p>
<p><strong>2，相对路径和绝对路径</strong></p>
<p>每个进程都会有当前工作目录，一般的相对路径，就是针对进程当前工作目录而言的。当然，可以针对某个目录指定相对路径。</p>
<p>绝对路径，在UNIX中以“/”开始；在Windows中以某个盘符开始，比如<code>C:ProgramFiles</code>等，IsAbs()函数可以判断返回的路径是否是一个绝对路径：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsAbs</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure></p>
<p>而函数Abs()返回path代表的绝对路径，如果输入参数path不是绝对路径，会加入当前工作目录以使之成为绝对路径：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>因为硬链接的存在，不能保证返回的绝对路径是唯一指向该地址的绝对路径。在os.Getwd出错时，Abs()会返回该错误，如果路径名长度超过系统限制，也会报错。</p>
<p>Rel()函数返回一个相对路径，将basepath和该路径用路径分隔符连起来的新路径在词法上等价于targpath：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rel</span><span class="params">(basepath, targpath <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>也就是说，<code>Join(basepath, Rel(basepath, targpath))</code>等价于targpath。如果成功执行，返回值总是相对于basepath的，即使basepath和targpath没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者targpath无法表示为相对于basepath的路径，将返回错误。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(filepath.Rel(<span class="string">"/home/zuolan/example"</span>, <span class="string">"/home/zuolan/example/src/logic/topic.go"</span>))</span><br><span class="line">fmt.Println(filepath.Rel(<span class="string">"/home/zuolan/example"</span>, <span class="string">"/data/example"</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">src/logic/topic.go &lt;nil&gt;</span></span><br><span class="line"><span class="comment">../../../data/example &lt;nil&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3，路径的切分和拼接</strong></p>
<p>对于一个常规文件路径，可以通过Split函数得到它的目录路径和文件名：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(dir, file <span class="keyword">string</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Split()函数根据最后一个路径分隔符将路径path分隔为目录和文件名两部分（dir和file）。如果路径中没有路径分隔符，函数返回值dir为空字符串，file等于path；反之，如果路径中最后一个字符是“/”，则dir等于path，file为空字符串。返回值满足<code>path ==dir+file</code>。dir非空时，最后一个字符总是“1”。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dir ==/home/zuolan/, file == example</span></span><br><span class="line">filepath.split(<span class="string">"/home/zuolan/example"</span>)</span><br><span class="line"><span class="comment">// dir == /home/zuolan/example/, file ==</span></span><br><span class="line">filepath.Split(<span class="string">"/home/zuolan/example/"</span>)</span><br><span class="line"><span class="comment">// dir=="", file == example</span></span><br><span class="line">filepath.Split(<span class="string">"example"</span>)</span><br></pre></td></tr></table></figure></p>
<p>相对路径到绝对路径的转变，需要经过路径的拼接。Join用于将多个路径拼接起来，会根据情况添加路径分隔符：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Join</span><span class="params">(elem ...<span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>Join()函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过Clean的，所有的空字符串元素会被忽略。对于拼接路径的需求，应该总是使用Join函数来处理。</p>
<p>有时，需要分割PATH或GOPATH之类的环境变量（这些路径被特定于OS的列表分隔符连接起来），filepath.SplitList就是这个用途：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Splitlist</span><span class="params">(path <span class="keyword">string</span>)</span> []<span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意，与strings.Split函数的不同之处在于：对于空路径，SplitList返回[]string{}，而strings.Split返回[string””}。 SplitList内部调用的是strings.Split.<br>(diot</p>
<p>4.规整化路径</p>
<p>Clean（函数通过单纯的词法操作返回和path代表同一地址的最短路径：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Clean</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure></p>
<p>它会不断地依次应用如下的规则，直到不能再进行任何处理：<br>（1）将连续的多个路径分隔符替换为单个路径分隔符。<br>（2）剔除每一个“.”路径名元素（代表当前目录）。</p>
<p>（3）剔除每一个路径内的“..”路径名元素（代表父目录）和它前面的非“..”路径名元素。<br>（4）剔除开始于根路径的“..”路径名元素，即将路径开始处的“..”替换为“/” （假设路径分隔符是“/”）。<br>返回的路径只有其代表一个根地址时才以路径分隔符结尾，如UNIX的/或Windows的C：\。<br>如果处理的结果是空字符串，Clean会返回“”，代表当前路径。</p>
<p>5.文件路径匹配</p>
<p>Match()指示name是否和shell的文件模式匹配。模式语法如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Match</span><span class="params">(pattern, name <span class="keyword">string</span>)</span> <span class="params">(matched <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="title">pattern</span>:</span></span><br><span class="line"><span class="function"></span>&#123;term &#125;</span><br><span class="line">term:</span><br><span class="line"><span class="number">14</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">匹配日或多个非路径分隔符的字符</span><br><span class="line">&apos;?&apos;</span><br><span class="line">匹配1个非路径分隔符的字符</span><br><span class="line">&apos;[&apos;[&apos;^&apos;] &#123; character-range &#125; &apos;]&apos;</span><br><span class="line">字符组（必须非空）</span><br><span class="line">C</span><br><span class="line">匹配字符c（c！=&apos;*&apos;，&apos;?&apos;,&apos;I\&apos;,&apos;[&apos;)</span><br><span class="line">&apos;\\&apos;c</span><br><span class="line">匹配字符c</span><br><span class="line">character-range:</span><br><span class="line">C</span><br><span class="line">匹配字符c（c！=&apos;\\&apos;，&apos;&apos;，&apos;]&apos;）</span><br><span class="line">&apos;\\&apos;c</span><br><span class="line">匹配字符c</span><br><span class="line">lo&apos;_&apos;hi</span><br><span class="line">匹配区间[lo，hi]内的字符</span><br></pre></td></tr></table></figure>
<p>匹配要求pattern必须和name全匹配上，不只是子串。在Windows下转义字符被禁用。Match()函数很少使用，标准库没有用到这个函数。而Glob函数在模板标准库中被用到了：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Glob</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">(matches []<span class="keyword">string</span>, err error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Glob()函数返回所有匹配了模式字符串patterm的文件列表或者nil（如果没有匹配的文件）。pattern的语法和Match函数相同。pattern可以描述多层的名字，如/us/*/bin/ed（假设路径分隔符是“/”）。<br>注意，Glob()会忽略任何文件系统相关的错误，如读目录引发的I/O错误。唯一的错误和Match()一样，在pttern不合法时，返回 filepath.ErrBadPattern。返回的结果是根据文件名字典顺序进行了排序的。</p>
<p>Glob()的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取testdata 目录下的所有测试数据；<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filepath.Glob(<span class="string">"testdata/*.input"</span>)</span><br></pre></td></tr></table></figure></p>
<p>6.遍历目录</p>
<p>在介绍os时，讲解了读取目录的方法，并给出了一个遍历目录的示例。在filepath中，提供了Walk()函数，用于遍历目录树。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Walk</span><span class="params">(root <span class="keyword">string</span>, walkFn WalkFunc)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p>Walk()函数会遍历root指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用walkFn，包括root自身。所有访问文件/目录时遇到的错误都会传递给walkFn过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。Walk()函数不会遍历文件树中的符号链接（快捷方式）文件包含的路径。</p>
<p>walkFn的类型WalkFunc的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WalkFunc <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, err error)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p>Wak()函数对每一个文件/目录都会调用WalkFunc()函数类型值。调用时path参数会包含Walk()的root参数作为前缀，也就是说，如果Walk()函数的root为“dir”，该目录下有文件“a”，将会使用“di/la”作为调用walkFn的参数。walkFn参数被调用时的info参数是path指定的地址（文件/目录）的文件信息，类型为0s.FileInfo。</p>
<p>如果遍历path指定的文件或目录时出现了问题，传入的参数err会描述该问题，WalkFunc类型函数可以决定如何去处理该错误（Walk函数将不会深入该目录）；如果该函数返回一个错误，Walk函数的执行会中止；只有一个例外，如果Walk的wallkFn返回值是SkipDir，将会跳过该目录的内容而Walk函数照常执行处理下一个文件。</p>
<p>最后总结一下，在UNIX中，路径的分隔符是“/”，但Windows中的是“\”。在使用path包时，应该总是使用“/”，不论什么系统。</p>
<p>path包中提供的函数，flepath都有提供，功能类似，但实现不同。一般应该使用flepath 包，而不是path包。</p>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a><span style="color:#339AFF;">数据结构与算法</span></h1><p>数学方面的包主要是math——实现数学函数计算，math的子包包含以下这些包：</p>
<ul>
<li>math/big: 大整数的高精度计算实现。</li>
<li>math/cmplx：复数基本函数操作。</li>
<li>math/rand：伪随机数生成器。</li>
</ul>
<p>Go语言在数据结构方面主要有三大相关的标准包：</p>
<ul>
<li>sort：包含基本的排序方法，支持切片数据排序以及用户自定义数据集合排序。</li>
<li>index/suffixary：该包实现了后缀数组相关算法以支持许多常见的字符串操作。</li>
<li>container：该包实现了三个复杂的数据结构，即堆、链表和环。这个包表示使用这三个数据结构的时候不需要再费心从头开始写算法了。</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a><span style="color:#00ACC1;">排序</span></h2><p>Go语言中实现了四种基本排序算法：插入排序、归并排序、堆排序和快速排序，但是这四种排序方法是不公开的，它们只被sort包内部使用。</p>
<p>在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了sort.Interface定义的三个方法：获取数据集合长度的Len()方法、比较两个元素大小的Less()方法和交换两个元素位置的Swap()方法，就可以顺利对数据集合进行排序。</p>
<p>sort包会根据实际数据自动选择高效的排序算法。除此之外，为了方便对常用数据类型的操作，sort包提供了对[]int切片、[]float64切片和[]string切片的完整支持，主要包括：对基本数据类型切片的排序支持；基本数据元素查找；判断基本数据类型切片是否已经排好序；对排好序的数据集合逆序。</p>
<p><strong>1，数据集合排序</strong></p>
<p>前面已经提到过，对数据集合（包括自定义数据类型的集合）排序需要实现sort.Interface接口的三个方法，我们看一下该接口的定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数据集合元素个数</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 如果i索引的数据小于j所有的数据，返回true，不会调用</span></span><br><span class="line">    <span class="comment">// 下面的Swap()，即数据升序排序</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// 交换i和j索引的两个元素的位置</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据集合实现了三个方法后，即可调用该包的Sort()方法进行排序。Sort()方法的定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sort</span><span class="params">(data Interface)</span></span></span><br></pre></td></tr></table></figure></p>
<p>Sort()方法唯一的参数就是待排序的数据集合。</p>
<p>该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的Len()和Less()方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSorted</span><span class="params">(data Interface)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n := data.Len()</span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> data.Less(i, i<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个使用sort包对学生成绩排序的示例：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生成绩结构体</span></span><br><span class="line"><span class="keyword">type</span> StuScore <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    <span class="comment">// 成绩</span></span><br><span class="line">    score <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StuScores []StuScore</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len()：人数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less()：成绩将由低到高排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i].score &lt; s[j].score</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap()：排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    s[i],s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stus := StuScores&#123;</span><br><span class="line">        &#123;<span class="string">"张三"</span>, <span class="number">95</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"李四"</span>, <span class="number">91</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"赵五"</span>, <span class="number">96</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"王六"</span>, <span class="number">90</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"======默认======"</span>)</span><br><span class="line">    <span class="comment">// 原始顺序</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> stus &#123;</span><br><span class="line">        fmt.Println(v.name, <span class="string">":"</span>, v.score)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// StuScores已经实现了sort.Interface接口</span></span><br><span class="line">    sort.Sort(stus)</span><br><span class="line">    fmt.Println(<span class="string">"======排序之后======"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排好序后的结构</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> stus &#123;</span><br><span class="line">        fmt.Println(v.name, <span class="string">":"</span>, v.score)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否已经排好顺序,将会打印true</span></span><br><span class="line">    fmt.Println(<span class="string">"是否已经排序？"</span>, sort.IsSorted(stus))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">======默认======</span></span><br><span class="line"><span class="comment">张三 : 95</span></span><br><span class="line"><span class="comment">李四 : 91</span></span><br><span class="line"><span class="comment">赵五 : 96</span></span><br><span class="line"><span class="comment">王六 : 90</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">======排序之后======</span></span><br><span class="line"><span class="comment">王六 : 90</span></span><br><span class="line"><span class="comment">李四 : 91</span></span><br><span class="line"><span class="comment">张三 : 95</span></span><br><span class="line"><span class="comment">赵五 : 96</span></span><br><span class="line"><span class="comment">是否已经排序？ true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>该示例程序的自定义类型StuScores实现了sort.Interface接口，所以可以将其对象作为sort.Sort()和sort.IsSorted()的参数传入。</p>
<p>该示例实现的是升序排序，如果要得到降序排序结果，其实只要修改Less()函数即可：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less()：成绩降序排序，只将小于号修改为大于号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StuScores)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s[i].score &gt; s[j].score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，sort包提供了Reverse()方法，可以允许将数据按Less()定义的排序方式逆序排序，而不必修改Less()代码，方法定义如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以看到Reverse()返回的一个sort.Interface接口类型，整个Reverse()的内部实现如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个reverse结构类型，嵌入Interface接口</span></span><br><span class="line"><span class="keyword">type</span> reverse <span class="keyword">struct</span>&#123;</span><br><span class="line">    Interface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse结构类型的Less()方法拥有嵌入的Less()方法相反的行为</span></span><br><span class="line"><span class="comment">// Len()和Swap()方法则会保持嵌入类型的方法行为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回新的实现Interface接口的数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span> <span class="title">Interface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>了解内部原理后，可以在学生成绩排序示例中使用Reverse()来实现成绩升序排序：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse(stus))</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> stus &#123;</span><br><span class="line">    fmt.Println(v.name, <span class="string">":"</span>, v.score)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一个方法：Search()，该方法使用“二分查找”算法来搜索某指定切片[0:n]，并返回能够使f(i)=true的最小的i（0≤i≤n）值，并且会假定，如果f(i)=true，则f(i+1)=true，即对于切片[0:n]，i之前的切片元素会使f()函数返回false，i及i之后的元素会使f()函数返回true。</p>
<p>但是，当在切片中无法找到f(i)=true的i时（此时切片元素都不能使f）函数返回true），Search()方法会返回n。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Search</span><span class="params">(n <span class="keyword">int</span>, f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">bool</span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>Search()函数的一个常用方式是搜索元素x是否在已经升序排好的切片s中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">11</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">45</span>&#125; <span class="comment">// 注意已经升序排序</span></span><br><span class="line">pos := sort.Search(<span class="built_in">len</span>(s), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &gt;= x &#125;)</span><br><span class="line"><span class="keyword">if</span> pos &lt; <span class="built_in">len</span>(s) &amp;&amp; s[pos] == x &#123;</span><br><span class="line">    fmt.Println(x, <span class="string">"在s中的位置为："</span>, pos)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"s不包含元素"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>官方文档还给出了一个猜数字的小程序：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GuessingGame</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    fmt.Printf(<span class="string">"选择一个从0到100的整数。\n"</span>)</span><br><span class="line">    answer := sort.Search(<span class="number">100</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"这个数字是否小于等于%d？"</span>, i)</span><br><span class="line">        fmt.Scanf(<span class="string">"%s"</span>, &amp;s)</span><br><span class="line">        <span class="keyword">return</span> s != <span class="string">""</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">'y'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Printf(<span class="string">"你选的数字是%d吧。\n"</span>, answer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2，切片排序</strong></p>
<p>前面已经提到，sort包原生支持[]int、[]float64和[]string三种内建数据类型切片的排序操作，即我们不必自己实现相关的Len()、Less()和Swap()方法。</p>
<p>1）[]int排序</p>
<p>由于[]int切片排序内部实现及使用方法与[]float64和[]string类似，所以只详细描述该部分。sort包定义了一个IntSlice类型，并且实现了sort.Interface接口：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntSlice []<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; p[i],p[j]=p[j], p[i] &#125;</span><br><span class="line"><span class="comment">// IntSlice类型定义了Sort()方法，包装了sort.Sort()函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Sort</span><span class="params">()</span></span>&#123; Sort(p) &#125;</span><br><span class="line"><span class="comment">// IntSlice类型定义了SearchInts()方法，包装了SearchInts()函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p IntSlice)</span> <span class="title">Search</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> SearchInts(p, x) &#125;</span><br></pre></td></tr></table></figure></p>
<p>提供的sort.Ints()方法使用了该IntSlice类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ints</span><span class="params">(a []<span class="keyword">int</span>)</span></span> &#123; Sort(IntSlice(a)) &#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，对[]int切片排序时更常使用sort.Ints()，而不是直接使用IntSlice类型：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Ints(s)</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[1 2 3 4 5 6]</span></span><br></pre></td></tr></table></figure></p>
<p>如果要使用降序排序，显然要用前面提到的Reverse()方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Sort(sort.Reverse(sort.IntSlice(s)))</span><br><span class="line">fmt.Println(s) <span class="comment">// 将会输出[6 5 4 3 2 1]</span></span><br></pre></td></tr></table></figure></p>
<p>如果要查找整数x在切片a中的位置，相对于前面提到的Search()方法，sort包提供了SearchInts()：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchInts</span><span class="params">(a []<span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意，SearchInts()的使用条件为切片a已经升序排序。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125; <span class="comment">// 未排序的切片数据</span></span><br><span class="line">sort.Ints(s) <span class="comment">// 排序后的s为[1 2 3 4 5 6]</span></span><br><span class="line">fmt.Println(sort.SearchInts(s,<span class="number">3</span>)) <span class="comment">// 将会输出2</span></span><br></pre></td></tr></table></figure></p>
<p>2）[]float64排序</p>
<p>实现与Ints类似，只看一下其内部实现：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Float64Slice []<span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">len</span>(p)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span> '</span>&#123; <span class="keyword">return</span> p[i] &lt; p[j] ll isNaN(p[i]) &amp;&amp; !isNaN(p[j])&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; p[i], p[j] = p[j], p[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64slice)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123; Sort(p) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Float64slice)</span> <span class="title">Search</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> SearchFloat64s(p,x) &#125;</span><br></pre></td></tr></table></figure></p>
<p>与Sort()、IsSorted()、Search（相对应的三个方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Float64s</span><span class="params">(a []<span class="keyword">float64</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Float64sAreSorted</span><span class="params">(a []<span class="keyword">float64</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">SearchFloat64s</span><span class="params">(a []<span class="keyword">float64</span>, x <span class="keyword">float64</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>要说明一下的是，在上面Float64Slice类型定义的Less方法中，有一个内部函数 isNaN()。isNaN（与math包中IsNaN0实现完全相同，sort包之所以不使用math.IsNaN（，完全是基于包依赖性的考虑，应当看到，sort包的实现不依赖于其他任何包。</p>
<p>3）[]string排序<br>两个string对象之间的大小比较是基于“字典序”的。实现与Ints类似，只看一下其内部实现：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringSlice []<span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">len</span>(p)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> p[i] &lt; p[j] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Swap</span><span class="params">(i,jint)</span></span> &#123;p[i],p[j]=p[j],p[i]&#125; <span class="function"><span class="keyword">func</span> <span class="params">(p StringSlice)</span> <span class="title">Sort</span><span class="params">()</span></span>&#123; Sort(p)&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p stringslice)</span> <span class="title">Search</span><span class="params">(x <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> Searchstrings(p,x)&#125;</span><br></pre></td></tr></table></figure></p>
<p>与Sort()、IsSorted()、Search()相对应的三个方法：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Strings</span><span class="params">(a []<span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">StringsAreSorted</span><span class="params">(a []<span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Searchstrings</span><span class="params">(a []<span class="keyword">string</span>, x <span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="container"><a href="#container" class="headerlink" title="container"></a><span style="color:#00ACC1;">container</span></h2><p>该包实现了三个复杂的数据结构：堆、链表和环，这个包表示使用这三个数据结构的时候不需要再费心从头开始写算法了。</p>
<p><strong>1，堆</strong></p>
<p>这里的堆使用的数据结构是最小二叉树，即根节点比左边子树和右边子树的所有值都小。Go语言的堆包只是实现了一个接口，我们看下它的定义：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 添加一个元素x并返回Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 移除并返回元素长度Len()-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，这个堆结构继承自sort.Interface，回顾一下sort.Interface，它需要实现三个方法：</p>
<ul>
<li>Len() int</li>
<li>Less(i, j int) bool</li>
<li>Swap(i, j int)</li>
</ul>
<p>加上堆接口定义的两个方法：</p>
<ul>
<li>Push(x interface{})</li>
<li>Pop() interface{}</li>
</ul>
<p>就是说你定义了一个堆，就要实现五个方法，直接以package doc中的example为例来看一下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; h[i], h[j] = h[j], h [i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么IntHeap实现了这个堆结构，我们就可以使用堆的方法来对它进行操作：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h := &amp;IntHeap&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">heap.Init(h)</span><br><span class="line">heap.Push(h, <span class="number">3</span>)</span><br><span class="line">heap.Pop(h)</span><br></pre></td></tr></table></figure></p>
<p>具体说一下内部实现，使用最小堆，索引排序从根节点开始，然后左子树，右子树的顺序方式。内部实现了down和up分别表示对堆中的某个元素向下保证最小堆和向上保证最小堆。</p>
<p>当往堆中插入一个元素的时候，这个元素插入到最右子树的最后一个节点中，然后调用up向上保证最小堆。</p>
<p>当要从堆中推出一个元素的时候，先把这个元素和右子树最后一个节点对换，然后弹出最后一个节点，再对root调用down，向下保证最小堆。</p>
<p><strong>2，链表</strong></p>
<p>链表就是一个有prev和next指针的数组了，它维护两个type，注意，这里不是接口。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">    next, prev *Element <span class="comment">// 上一个元素和下一个元素</span></span><br><span class="line">    list *List          <span class="comment">// 元素所在链表</span></span><br><span class="line">    Value <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">    root Element <span class="comment">// 链表的根元素</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span>      <span class="comment">// 链表的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>链表是先创建list，然后往list中插入值，list就在内部创建一个Element，并在内部设置好Element的next、prev等。具体可以看下面例子，使用堆接口构建的整数堆：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"container/list"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := list.New()</span><br><span class="line">    list.PushBack(<span class="number">1</span>)</span><br><span class="line">    list.PushBack(<span class="number">2</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"长度：%v\n"</span>, list.Len())</span><br><span class="line">    fmt.Printf(<span class="string">"第一个元素：%#v\n"</span>,list.Front())</span><br><span class="line">    fmt.Printf(<span class="string">"第二个元素：%#v\n"</span>,list.Front().Next())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">长度：2</span></span><br><span class="line"><span class="comment">第一个元素：&amp;list.Element&#123;next:(*list.Element)(0xc00009a1e0), </span></span><br><span class="line"><span class="comment">prev:(*list.Element)(0xc00009a180), list:(*list.List)(0xc00009a180), Value:1&#125;</span></span><br><span class="line"><span class="comment">第二个元素：&amp;list.Element&#123;next:(*list.Element)(0xc00009a180), </span></span><br><span class="line"><span class="comment">prev:(*list.Element)(0xc00009a1b0), list:(*list.List)(0xc00009a180), Value:2&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>list对应的方法如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Element</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Element)</span> <span class="title">Next</span><span class="params">()</span>*<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(e*Element)</span> <span class="title">Prev</span><span class="params">()</span>*<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">List</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">New</span><span class="params">()</span>*<span class="title">List</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> （1*<span class="title">List</span>） <span class="title">Back</span><span class="params">()</span> *<span class="title">Element</span>//最后一个元素</span></span><br><span class="line"><span class="function"><span class="title">func</span> （<span class="title">l</span>*<span class="title">List</span>） <span class="title">Front</span><span class="params">()</span>*<span class="title">Element</span>//第一个元素</span></span><br><span class="line"><span class="function"><span class="title">func</span> （<span class="title">l</span>*<span class="title">List</span>） <span class="title">Init</span><span class="params">()</span>*<span class="title">List</span>//链表初始化</span></span><br><span class="line"><span class="function">//在某个元素后插入</span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">(l *List)</span> <span class="title">InsertAfter</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span> *<span class="title">Element</span></span></span><br><span class="line"><span class="function">//在某个元素前插入</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(l *List)</span> <span class="title">InsertBefore</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, mark *Element)</span>*<span class="title">Element</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> （1<span class="title">l</span>*<span class="title">List</span>） <span class="title">Len</span><span class="params">()</span> <span class="title">int</span>//链表长度</span></span><br><span class="line"><span class="function"><span class="title">func</span> （<span class="title">l</span> *<span class="title">List</span>） <span class="title">MoveAfter</span>（<span class="title">e</span>，<span class="title">mark</span> *<span class="title">Element</span>）//把<span class="title">e</span>元素移动到<span class="title">mark</span>之后</span></span><br><span class="line"><span class="function"><span class="title">func</span> （1<span class="title">l</span> *<span class="title">List</span>） <span class="title">MoveBefore</span>（<span class="title">e</span>，<span class="title">mark</span> *<span class="title">Element</span>）//把<span class="title">e</span>元素移动到<span class="title">mark</span>之前</span></span><br><span class="line"><span class="function"><span class="title">func</span> （<span class="title">l</span>*<span class="title">List</span>） <span class="title">MoveToBack</span>（<span class="title">e</span> *<span class="title">Element</span>）//把<span class="title">e</span>元素移动到队列最后</span></span><br><span class="line"><span class="function"><span class="title">func</span> （1*<span class="title">List</span>） <span class="title">MoveToFront</span>（<span class="title">e</span> *<span class="title">Element</span>）//把<span class="title">e</span>元素移动到队列最头部</span></span><br><span class="line"><span class="function"><span class="title">func</span> （<span class="title">l</span> *<span class="title">List</span>）- <span class="title">PushBack</span>（<span class="title">v</span> <span class="title">interface</span></span>&#123;&#125;）*Element<span class="comment">//在队列最后插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> （1<span class="title">l</span> *<span class="title">List</span>） <span class="title">PushBacklist</span>（<span class="title">other</span> *<span class="title">List</span>）//在队列最后插入接上新队列</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> （<span class="title">l</span>*<span class="title">List</span>） <span class="title">PushFront</span>（<span class="title">v</span> <span class="title">interface</span></span>&#123;&#125;）*Element<span class="comment">//在队列头部插入元素func （1*List） PushFrontlist（other *List）//在队列头部插入接上新队列func （l*List） Remove（e *Element） interface&#123;&#125;//删除某个元素</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3，环</strong></p>
<p>环的结构有点特殊，环的尾部就是头部，所以每个元素实际上就可以代表自身的这个环。它不需要像list一样保持list和element两个结构，只需保持一个结构就行<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">next, prev *Ring</span><br><span class="line">Value</span><br><span class="line"><span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">吉小童本</span><br><span class="line">sQ1</span><br></pre></td></tr></table></figure></p>
<p>初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个Do方法，能遍历一遍环，对每个元素执行一个功能。看下面的例子，同样是使用堆接口构建的整数堆：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">"container/ring"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ring := ring.New(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        ring.Value = i</span><br><span class="line">        ring = ring.Next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算1+2+3</span></span><br><span class="line">    s := <span class="number">0</span></span><br><span class="line">    ring.Do(<span class="function"><span class="keyword">func</span><span class="params">(p <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        s += p.(<span class="keyword">int</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(<span class="string">"和为："</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">和为： 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>ring提供的方法如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ring</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 初始化环</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">interface</span>&#123;&#125;)</span>) // 循环环进行操作</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span> // 环长度</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Link</span><span class="params">(s *Ring)</span> *<span class="title">Ring</span> // 连接两个环</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Move</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 指针从当前元素开始向后移动或者向前<span class="params">(n可以为负数)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Next</span><span class="params">()</span> *<span class="title">Ring</span> // 当前元素的下一个元素</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Prev</span><span class="params">()</span> *<span class="title">Ring</span> // 当前元素的上一个元素</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(r *Ring)</span> <span class="title">Unlink</span><span class="params">(n <span class="keyword">int</span>)</span> *<span class="title">Ring</span> // 从当前元素开始，删除<span class="title">n</span>个元素</span></span><br></pre></td></tr></table></figure></p>
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a><span style="color:#339AFF;">本章小结</span></h1><p>本章介绍了常用的几个I/O标准包的原理、使用以及注意事项，还针对常见的集中数据结构与算法的特点进行了介绍。在后续的章节里，还会接触文件操作与数据处理的相关标准库。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言编程入门与实战技巧/" rel="tag"># Go语言编程入门与实战技巧</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/18/第11章-网络编程/" rel="next" title="第11章 网络编程">
                <i class="fa fa-chevron-left"></i> 第11章 网络编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/18/第13章-文件处理/" rel="prev" title="第13章 文件处理">
                第13章 文件处理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">放弃会成为一种习惯</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">413</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2021/12/05/08-自研or借力（上）：集成Gin替换已有核心/" title="08|自研or借力（上）：集成Gin替换已有核心" target="_blank">08|自研or借力（上）：集成Gin替换已有核心</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/07-目标：站在巨人肩膀，你的理想框架到底长什么样？/" title="07|目标：站在巨人肩膀，你的理想框架到底长什么样？" target="_blank">07|目标：站在巨人肩膀，你的理想框架到底长什么样？</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/06-重启：如何进行优雅关闭？/" title="06|重启：如何进行优雅关闭？" target="_blank">06|重启：如何进行优雅关闭？</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/05-封装：如何让你的框架更好用？/" title="05|封装：如何让你的框架更好用？" target="_blank">05|封装：如何让你的框架更好用？</a>
                  </li>
                
                  <li>
                    <a href="/2021/12/05/04-中间件：如何提高框架的可拓展性？/" title="04|中间件：如何提高框架的可拓展性？" target="_blank">04|中间件：如何提高框架的可拓展性？</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#输入-输出"><span class="nav-number">1.</span> <span class="nav-text">输入/输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#io：基本I-O接口"><span class="nav-number">1.1.</span> <span class="nav-text">io：基本I/O接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fmt：格式化I-O"><span class="nav-number">1.2.</span> <span class="nav-text">fmt：格式化I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本处理"><span class="nav-number">1.3.</span> <span class="nav-text">文本处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件系统"><span class="nav-number">2.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#os：系统功能实现"><span class="nav-number">2.1.</span> <span class="nav-text">os：系统功能实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#path：兼容路径操作"><span class="nav-number">2.2.</span> <span class="nav-text">path：兼容路径操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构与算法"><span class="nav-number">3.</span> <span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序"><span class="nav-number">3.1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#container"><span class="nav-number">3.2.</span> <span class="nav-text">container</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小结"><span class="nav-number">4.</span> <span class="nav-text">本章小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">3.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">58:35</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
