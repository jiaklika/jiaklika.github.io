<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta name="keywords" content="Go语言编程入门与实战技巧">
<meta property="og:type" content="article">
<meta property="og:title" content="第15章 内存管理">
<meta property="og:url" content="http://yoursite.com/2021/09/18/第15章-内存管理/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-09-28T13:33:04.135Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第15章 内存管理">
<meta name="twitter:description" content="思考并回答以下问题：  总结一下，这章作者最主要想表达什么观点？">






  <link rel="canonical" href="http://yoursite.com/2021/09/18/第15章-内存管理/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第15章 内存管理 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/18/第15章-内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="看视频才能学会，看文字学不会的">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第15章 内存管理

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2021-09-18 21:17:14" itemprop="dateCreated datePublished" datetime="2021-09-18T21:17:14+08:00">2021-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-09-28 21:33:04" itemprop="dateModified" datetime="2021-09-28T21:33:04+08:00">2021-09-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">38k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">35 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<ul>
<li>总结一下，这章作者最主要想表达什么观点？</li>
</ul>
<a id="more"></a>
<p>Go语言是一门内置运行时的编程语言，这种类型的编程语言一般都会抛弃传统的内存分配方式，改为自主管理。这种方式可以完成类似预分配、内存池等操作，以避开系统调用带来的性能问题。当然，还有一个重要原因是为了更好地配合垃圾回收。</p>
<p>编程语言的内存管理一直以来都是非常重要的话题，而Go语言的内存管理基于TCMalloc （Google推出的内存分配器），使用了类似TCMalloc的算法进行内存分配，而且Go语言在实现的时候还做了很多优化，本章将通过源码来看一下Go语言的内存管理实现。</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>Go语言的内存分配基于TCMalloc，TCMalloc是Google开发的一个内存分配器，在不少项目中都有使用，常见的内存分配器还有glibc的PTMalloc和同样是Google的JEMalloc。相比于PTMalloc，TCMalloc性能更好，特别适用于高并发场景。TCMalloc具有现代化内存分配器的基本特征对抗内存碎片、在多核处理器上可伸缩。据称，它的内存分配速度是glibc2.3中实现的malloc的数倍。</p>
<p>在了解TCMalloc之前，需要认识一些内存管理基本概念。</p>
<h2 id="内存管理基本概念"><a href="#内存管理基本概念" class="headerlink" title="内存管理基本概念"></a>内存管理基本概念</h2><p>对于以前尚未接触过内存管理的读者而言，理解一些基本概念有助于后续的学习。如果是之前对其他语言的内存管理有经验的读者，不妨温习一次。</p>
<p>1.内存地址</p>
<p>在几十年前，还是汇编主宰着计算机世界，那个时候内存管理还不算什么大问题，程序有多少用多少，不够就换设备</p>
<p>但是在那个年代，不是每一个开发人员都会精打细算一个程序需要多少内存，如果内存空间有限，而内存的需求是不确定的，那么就需要一些手段来管理程序的内存使用了。早期的内存管理一般只有三步：首先确定内存是不是够用，够用就从内存中取一点来运行程序，用完了就把内存放回“内存池”中，负责这个过程的就是内存分配程序了。程序的动态性越强，内存管理就越重要，内存分配程序也就更重要。</p>
<p>时至今日，内存管理也不过是这三个步骤的进化。进化后的内存管理有三种类型：第一种是全手工的内存分配，它们认为内存很重要，不能由程序自己管理；第二种是全自动分配，它们认为内存很重要，不能交给人来管理；第三种是处于两者之间的半自动的内存管理方案。</p>
<p>不管是哪一种，都有一个绕不过去的地方，那就是“内存在程序中是如何分配的”，换句话说“如何将内存分配给程序”。要理解这一点，首先需要理解操作系统在其中担任的角色，计算机上的每一个进程都认为自己可以访问所有的物理内存，但实际上由于同时运行着多个程序，所以每个进程不可能拥有全部内存，这个时候就需要一种能够“欺骗’进程的东西，这就是虚拟内存。</p>
<p>要实现虚拟内存，首先要想办法避免让进程直接接触到实际的物理地址，因此物理内存会被操作系统组织成一个数组，这个数组由N个连续的字节（B）大小的单元组成，每个字节（B）都有一个唯一的物理地址（PA）。现代处理器使用的是一种称为虚拟寻址（VA）的寻址形式，最小的寻址单位是字，虚拟地址映射物理地址是通过读取页表（page table）进行地址翻译完成的一页表存放在物理存储器中。内核把物理页作为内存管理的基本单位，以页（page）为单位来管理内存中的页表。</p>
<p>举一个不太合理的例子，一个程序目前正在访问地址为233的内存，但实际上虚拟内存系统不需要将这个程序存储在位置为233的物理内存中。实际上，它甚至可以不存储在物理内存中，如果物理内存已经满了，它甚至可能已经被转移到硬盘上了。由于这类地址不必反映内存所在的物理位置，所以它们（如233的地址）被称为虚拟内存</p>
<p>操作系统维持着一个虚拟地址到物理地址的转换表，以便计算机硬件可以正确地响应地址请求。并且，如果地址在硬盘上而不是在内存中，那么操作系统将暂时停止该进程（对于存储在硬盘的内存数据，Windows中称为“虚拟内存”，Linux中称为Swap）。当空间有余或者优先度提高之后，再从硬盘上加载被进程请求的内存，然后再重新启动进程。这样，每个进程都获得了自己可以使用的地址空间，可以访问比物理上安装的内存更多的内存。</p>
<p>理论上，64位系统中每一个进程最多可以访问128GB内存，但实际上即便有128GB内存，再加上硬盘虚拟内存（Swap），每个进程所使用的内存也肯定少于128GB。因为当加载一个进程时，它会得到一个取决于称为系统中断点（system break）的特定地址，这是一个初始内存分配的值，该地址之后是未被映射的内存，未被映射的内存是“不存在”的，也就不能被进程使用（没有分配相应虚拟内存地址的物理内存）。因此，如果一个进程运行超出了它的初始分配内存，那么它必须请求操作系统映射进来更多的内存（映射是一种表示一对应关系的数学术语，内存虚拟地址对应一个物理地址，就称为内存被映射）。</p>
<p>以Linux系统为例，有两个可映射到物理内存的基本系统调用，分别是brk()和mmap()，这两个函数的作用是一样的一用来增减进程的虚拟内存。不过brk()更加简单，它只是单纯将系统中断点（system break）向前或者向后移动，使得进程可以获得更多内存或者释放内存。</p>
<p>而Go语言在内存分配上的底层函数是mmap()，相比brk（函数，mmap（更为灵活。首先，它可以映射任何位置的内存，而不局限于进程；其次，它不仅可以将虚拟地址映射到物理内存或者虚拟内存（Swap），还可以将虚拟地址映射到文件和文件位置（文件路径），这样可以在读写内存时直接对文件中的数据进行读写。</p>
<p>2.内存中的栈和堆</p>
<p>先说明，此处的堆栈并非数据结构中的堆栈，而是指内存中的一个区域。</p>
<p>在早期的计算机中，内存分配是基于栈的，这样的好处是显而易见的，速度快、操作方便，可以有效避免内存碎片化（栈是连续的）。但是栈的问题也逐渐暴露，例如不利于管理大内存（16位时代之后）、数据的生命周期难于控制（栈内的有效数据通常是连续存储的，所以pop时后申请的内存必须早于先申请的内存失效），所以栈不利于动态地管理并且有效地利用宝贵的内存资源，于是就有了堆。</p>
<p>要知道“内存分配”与“垃圾回收”都属于“动态存储分配”，“动态存储分配器”维护的虚拟存储区域称为堆，堆可以视为一组大小不同的块（chunk：连续的虚拟存储片，内存分配器和垃圾回收算法都依赖连续地址）的集合，并交由动态存储器维护。</p>
<p>但是堆的内存分配效率相比栈而言太低了，所以现在的编程规范一般会比较在意堆栈的区分。</p>
<p>回到话题上，有动态分配自然也有静态分配的概念。图15-1展现了内存中的存储的结构。</p>
<blockquote>
<p>图15-1 内存存储结构</p>
</blockquote>
<p>内存中的栈区处于相对较高的地址，栈地址是向下增长的，而堆区的地址是向上增长的。栈区一般由操作系统自动分配释放，是一块连续的内存区域（数据结构是一个栈），堆区一般由程序员分配释放，或者由OS回收（数据结构上类似一个链表）。</p>
<p>静态分配是系统编译器完成的，比如局部变量的分配，也就是说一般的内存分配器会把局部变量分配到栈区。而堆区用于分配开发人员申请的内存空间。注意，静态变量、全局变量一般是分配到堆区的。只读区是分配常量和程序代码空间的。</p>
<p>既然堆栈性能差异大，那么应该如何分配对象到堆栈上呢？Go语言的回答是：不用你操心。</p>
<p>这是Go语言的一个特性，编译器会在编译的时候自动判断对象应该分配到哪里，这当然很棒。但是如果不理解编译器的“自动分配”过程，很容易犯一些错误，毕竟编译器实际上也只是按照规矩办事，所以接下来看看Go语言编译器是根据何种规矩分配对象内存的。</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>由于栈的性能要比堆好很多，分配内存的速度比堆快（小内存分配），所以在编码过程中，开发人员会比较在意一个变量或者对象被分配到哪里，是堆还是栈这对于程序的性能和安全都有较大影响。</p>
<p>于是就有了一个“逃逸分析”的概念，在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。当一个变量或对象在子程序中被分配内存时，一个指向变量或对象的指针可能逃逸到其他执行线程中，甚至去调用子程序。</p>
<p>例如一个子程序分配一个对象并且返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到一这样指针就成功“逃逸”了。如果指针存储在全局变量或者其他数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。</p>
<p>以Go语言为例，注意下面两个函数分别创建了两个变量，这意味着两个函数的初始化都需要向OS申请内存，但是注意，它们申请到的内存位置是不一样的。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码15-1</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toHeap</span><span class="params">()</span>*<span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> xint</span><br><span class="line"><span class="keyword">return</span>&amp;x</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toStack</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">x :=<span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">*x=<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> *x</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了显示上面两个函数的区别，需要开启逃逸分析日志，在编译的时候加上-gcflags’-m’即可，不过为了不让编译器自动内连函数，一般会加-参数，所以最终编译参数为-gcflags’-m-l’（-m意思是打印编译器的自动优化策略，使用go tool compile -help查看所有可以被传入编译器的参数列表）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go run -gcflags <span class="string">'-m -l'</span> main.go</span><br><span class="line"><span class="comment"># command-line-arguments</span></span><br><span class="line">./main.go:5:9:&amp;x escapes to heap</span><br><span class="line">./main.go:4:6:moved to heap:x</span><br><span class="line">./main.go:8:10:toStack new(int) does not escape</span><br></pre></td></tr></table></figure></p>
<p>上面的意思是toHeap()中的x最后在堆上分配，而toStack()中的x最后分配在栈上（尽管是通过new分配的）。</p>
<p>上面的escape判断就是一种“逃逸分析”，逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。</p>
<p>那么同样是变量申请内存，为什么两个函数分配到的位置却不一样呢？</p>
<p>这是因为Go语言在一定程度上消除了堆和栈的区别，在编译的时候会自动进行逃逸分析，不逃逸的对象就放到栈上，可能逃逸的对象就放到堆上。</p>
<p>这样一看，Go语言岂不是不能手动控制堆栈分配了？其实也不是，上文说的是“一定程度上消除了堆和栈的区别”，实际上开发人员还是可以手动控制内存分配到堆栈的，具体规则如下：</p>
<ul>
<li>Go语言中的变量只要被引用就一直存活，存储在堆上还是栈上由内部实现决定，和具体的语法没有关系。</li>
<li>一般情况会将函数的局部变量分配到函数栈（stack frame）上。</li>
<li>如果变量在函数retum之后还会被引用，编译器就会将变量分配到堆上。 </li>
<li>如果一个局部变量非常大，那么它也会被分配到堆上而不是栈上。</li>
<li>如果一个变量被取地址（*和&amp;操作），那么它很可能会被分配到堆上，最终分配结果还是要对这些变量做逃逸分析，如果函数return之后变量不再被引用，则将其分配到栈上。</li>
</ul>
<p>下面以一个例子说明：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码15-2</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">varaS</span><br><span class="line">x:=&amp;a</span><br><span class="line">= toStack(x) = toHeap(a)</span><br><span class="line">]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个“流水”函数，因为这个函数只是单纯地将x作为输入变量，然后将x变量返回，这个函数没</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有引用z。同时也没有引用a，因为传入的是a的地址不是a的值，a的生命周期从头到尾都在main函数中，所以a变量没有逃逸的可能，就分配到了栈中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toStack</span><span class="params">(z*S)</span>*<span class="title">S</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> z</span><br><span class="line">]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">记住一点，Go语言默认是值传递的，所以此处输入的参数实际上是复制了a的值，传给了z，然后函数返回的是z的指针，上面说过取地址操作有可能被分配到堆上，而且z的地址作为返回值可能会被外部访问，所以z有逃逸的可能，最终确定被分配到堆上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toHeap</span><span class="params">(z S)</span> *<span class="title">S</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行编译，查看逃逸分析日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ go run -gcflags *-m -l<span class="string">'main.go</span></span><br><span class="line"><span class="string"># command-line-arguments</span></span><br><span class="line"><span class="string">./main.go:12:18:leaking param: z to result ~rl level=0</span></span><br><span class="line"><span class="string">./main.go:17:9:&amp;z escapes to heap</span></span><br><span class="line"><span class="string">./main.go:16:16:moved to heap:z</span></span><br><span class="line"><span class="string">./main.go:7:7:main &amp;a does not escape</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到Go语言编译器在编译时就将堆栈的分配搞定了。但是如果Go语言编译器不知道两个变量的关系，会不会分配有误？</p>
<p>例如以下程序：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>在上述这个例子中，函数ref中的x赋值给y的成员（即a被外部引用了），所以a需要存在堆中，避免a丢失数据。接下来，b自始至终都只在main中引用，即便在ref中也只是被赋值而已，不会在函数（子程序）外部被访问，没有逃逸的可能。</p>
<p>接下来尝试把上面的y.M=x语句反过来写：x=y.M，结果是全部不会逃逸，全都分配到栈上（没有外部引用）。</p>
<p>下一节将介绍Go语言内存分配器分配内存的原型一TCMalloc，说白了就是Go语言堆的内存分配原理，栈的内存分配比较简单，和Go语言自己的内存分配器一起讲解。</p>
<h1 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h1><p>TCMalloc的全称是Thread-Caching Malloc（线程缓存分配器），是Google公司推出的一个内存分配器，在不少项目中都有使用，Go语言就是使用了类似的算法实现内存分配的，所以本节先来认识一下TCMalloc。常见的内存分配器还有glibc的PTMalloc和同样是Google的JEMalloc。相对于PTMalloc，TCMalloc特别对多线程做了优化，对于小对象的分配基本上不存在锁竞争，而大对象使用了细粒度、高效的自旋锁（spinlock），因此特别适用于高并发场景。<br>为了更好地理解TCMalloc工作过程，本节将从两个角度解释这个流程：一是从线程角度出发，根据请求分配内存的大小分为“小内存分配”和“大内存分配”；二是从TCMalloc角度出发，根据不同内存分配请求划分不同等级。如图15-2所示，可以看到“小内存分配”和ThreadCache对应，而“大内存分配”和PageHeap对应。</p>
<blockquote>
<p>图15-2 TCMalloc结构图</p>
</blockquote>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>TCMalloc内存管理体系分为三个层次：ThreadCache、 CentralCache和PageHeap，如图15-2所示。分配内存和释放内存的时候都是在各个层次中逐级尝试的，整体的思路是当最小的ThreadCache层分配内存失败，则从下一层的CentralCache中分配一批补充上来，还不够就再从PageHeap那里要，再不够向操作系统要。在释放内存时，ThreadCache层释放了过多的内存，则回收一批到CentralCache层，以此类推逐级回收到PageHeap并最终还给操作系统。现在我们了解的是一个整体结构，但至于为何要这样设计以及这样设计的好处在哪里，将是本节的重点。</p>
<p>这三个层次从前到后担负着不同的角色，在了解各角色担负的任务之前，需要了解TCMalloc的两个特点。</p>
<p>第一点，线程私有性。这是和ThreadCache有关的概念，顾名思义，ThreadCache是每个线程都有一份的。在理想状况下，每个线程的内存申请都可以在自己的ThreadCache里面完成，线程之间不需要竞争，因此非常高效，这是TCMalloc的一大亮点。</p>
<p>然而现实是不可能达到上面的理想情况的，ThreadCache不可能永远都能满足线程的需求，ThreadCache中的内存不够的时候就需要CentralCache甚至PageHeap出马了。CentralFreeList作为PageHeap与ThreadCache的中间人，负责将PageHeap中的内存切分为小块，在恰当时机分配给ThreadCache；在释放内存方面，CentralFreeList获取从ThreadCache中回收的内存并在恰当的时机将部分内存归还给PageHeap。最后一层是PageHeap，它是中央堆分配器，被所有线程共享（分配时需要全局锁定），负责与操作系统的直接交互（申请及释放内存），并且大尺寸的内存申请直接通过PageHeap进行分配。</p>
<p>第二点，内存分配粒度。如果说线程私有性是从线程角度考虑内存分配的，那么内存分配粒度则是从TCMalloc角度考虑了。TCMalloc有两种粒度（所谓粒度就是管理器可以调度的最小单位）的内存，分别是object和span。span是连续page的内存，而object则是由span切成的小块。object的尺寸被预设了一些规格（class），比如16B、32B等（截至目前有88种不同的规格），同一个span切出来的object都是相同的规格，如图15-3所示。object不会大于256KB，超大的内存将直接分配span来使用。ThreadCache和CentralCache都是管理object的，而PageHeap管理的是span。</p>
<blockquote>
<p>图15-3 TCMalloc核心示意图</p>
</blockquote>
<p>上面两点组成了TCMalloc的核心，这个核心被称为离散式空闲列表算法（SegregatedFree List）。在申请小内存（小于256KB）时，TCMalloc会根据申请内存的大小，匹配到某个class中。举个例子，申请0~8B的大小时，会被匹配到classl中，分配8B大小；申请9~16B大小时，会被映射到class2中，分配16B大小，以此类推。</p>
<p>从上面的例子可以知道，每个小对象的大小都会被匹配到与之最接近的可分配的class中，目前有88个可分配的尺寸类别，每个类别的尺寸是不一样的，小一点的class尺寸相差8B，较大的class尺寸相差16B，再大一点的class尺寸相差32B，后面的class尺寸也是逐渐增加的。这样一来刚超过上一个class尺寸的小对象就会被分配到下一个级别的class中，这样可以非常灵活地控制内存，而且极大避免了内存浪费。</p>
<h2 id="小内存分配"><a href="#小内存分配" class="headerlink" title="小内存分配"></a>小内存分配</h2><p>继续解释图15-2，“小内存分配”中对应的ThreadCache就是TCMalloc中三级分配的第一层，它是一个TSL（线程本地存储）对象，小于256KB的内存申请均由ThreadCache处理（每个线程都独立拥有各自的离散式空闲列表），ThreadCache分配过程不需要任何锁（没有竞争），极大提高了分配速度。</p>
<p>要知道，TCMalloc在内存上使用连续虚拟地址，以页（page）为单位、多级缓存进行管理，TCMalloc把内存块分为两种，其中span（由地址连续的page组成一个大块内存）用于内部管理；而object（将span按照特定大小分割为多个小块，每一个小块可以存储一个对象）用于面向对象分配。</p>
<p>简单来说，分配器会以page为单位，向操作系统申请“大块内存”，这些大块内存由 n个地址连续的page组成，并用名为span的对象进行管理。举个例子，现有一个拥有128page的span，如果要申请一个1page的span，就把这个span分裂成两个，1+127，再把127 page的span记录下来。</p>
<p>当通过ThreadCache分配小内存时，首先会通过SizeMap查找要分配的内存所对应的 class及object大小然后检查空闲列表（free list）是否为空，如果空闲列表（free list）非空，表示线程还有空闲的内存，那么直接从列表中移除第一个object并返回，这个过程不需要任何锁，所以速度极快。</p>
<p>如果空闲列表（free list）为空，表示线程内没有空闲的内存了，那么就需要从CentralFreeList 中获取若干个object，因为CentralCache是被所有线程共享的，至于获取多少个object是由慢启动算法决定的，避免浪费内存。取到的object会被分配到ThreadCache对应的class列表中，最终取出其中一个object返回。</p>
<p>但若是CentralFreeList中的object也不够用了，CentralFreeList就需要向PageHeap申请一连串页面（page，由span组成，每次会申请class_to_pages个页面），申请到的页面（page）会被切割成一系列的object，再将部分object转移给ThreadCache。</p>
<p>如果PageHeap还是不够用，那么就需要向操作系统申请分配更多的内存（以page为单位），这就是前面讲到的sbrk.mmap等方法，或者通过在/dev/mem中进行映射。PageHeap获得更多的page之后继续上面的操作，把内存逐级递给线程。</p>
<h2 id="CentralCache"><a href="#CentralCache" class="headerlink" title="CentralCache"></a>CentralCache</h2><p>CentralCache里面有多个CentralFreeList，即针对每一种class的object.CentralFreeList和ThreadCache不一样，它没有直接维护object链表，而是维护span的链表，每个span下面再挂一个由这个span切分出来的object的链，如图15-4所示。</p>
<blockquote>
<p>图15-4 CentralFreeList结构示意</p>
</blockquote>
<p>这样在span内的object都已经空闲（free）的情况下，将span整体回收给PageHeap（span.refcount_记录了被分配出去的object个数）。但是如果每个回收的object都需要寻找自己所属的span，然后才能挂进freelist，这样就比较耗时了。所以CentralFreeList里面还维护了一个缓存（tc_slots_），回收的若干object先往缓存里塞，不管object大小如何，缓存满了再分类放进相应span的object链。相反，如果ThreadCache申请object，也是先尝试在缓存里面给，没了再去span链那里申请</p>
<p>那么这个若干具体是多少个object呢？其实这是预定义的，称作batch_size，不同的class可能有不同的值。ThreadCache向CentralCache分配或回收object 时，都尽量以batch size为一个批次。而为了使得缓存简单高效，如果某次分配或者回收的object个数小于batch size，则会绕过缓存，直接处理。<br>现在回到图15-4上，为了避免在分配object时判断span是否为空，CentralFreeList里的span链表被分为两个，分别是nonempty_和empty_，根据span的objects链是否有空闲，放入对应链表。当到了需要分配时，只需要在由空变非空、或者由非空变空时移动span就可以了。</p>
<p>CentralFreeList作为整个体系的中间人，它从PageHeap 中获得span，并按照预定大小（SizeMap中的定义）将其分割成大小固定的object，然后ThreadCache可以共享CentralFreeList列表</p>
<p>当ThreadCache需要从CentralFreeList中获取object时，会从nonempty_链表中获取第一个span，并从这个span的object链表中获取可用object返回。当该span无可用object时，将此span从nonempty_链表移除，并挂到empty_链表上。</p>
<p>当ThreadCache把object归还给CentralFreeList时，object会找到它所属的span，并挂载到object链表表头，如果span处在empty_链表，CentalFreeList会重新将其挂载到nonempty_链表。</p>
<p>span里还有一个值用于计算object是否已满，每次分配出去一个object，refcount值就会加1，每回收一个object就会减1，如果refcount等于0就表示此span所有object都回家了，然后span会从CentralFreeList的链表中释放，并将其退还给上一层的PageHeap。</p>
<h2 id="大内存分配"><a href="#大内存分配" class="headerlink" title="大内存分配"></a>大内存分配</h2><p>前面我们遇到的内存分配都是一些小于page的对象，如果分配的内存大于page这个单位，就需要用多个page来分配了一-把多个page组成一个span用来分配。</p>
<p>之前说过PageHeap是可以向操作系统申请内存的，与大多数现代内存分配器一样，TCMalloc也是以page为单位进行分配的，每次至少向系统申请1page的内存空间。 TCMalloc中定义的page大小为8KB。注意一点，目前大部分Linux系统都把1page的大，小定义为4KB，也就是说TCMalloc中的一page其实是Linux中2page。</p>
<p>尽管PageHeap是按page申请内存的，但是它管理内存的基本单位为span，span对象其实是地址连续的page。一个span里面至少有1page大小（一般都有好多page）。</p>
<p>下面是span的定义，从定义中可以看到span的完整结构：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Span &#123;</span><br><span class="line">PageID</span><br><span class="line">start; <span class="comment">//span的内存的起始地址</span></span><br><span class="line">Length</span><br><span class="line">length；<span class="comment">//span里面包含的page数量</span></span><br><span class="line">Span*</span><br><span class="line">next；<span class="comment">//span是一种双向链表，因为要被PageHeap和CentralFreeList使用</span></span><br><span class="line">Span*</span><br><span class="line">prev;</span><br><span class="line">void*</span><br><span class="line">objects；<span class="comment">//span会在CentralFreelist中分割为若干object组成的free list</span></span><br><span class="line">unsigned <span class="keyword">int</span> refcount：<span class="number">16</span>；<span class="comment">//span的object被引用次数</span></span><br><span class="line">unsigned <span class="keyword">int</span> sizeclass ：<span class="number">8</span>；/Ispan所属的size class</span><br><span class="line">unsigned <span class="keyword">int</span> location :<span class="number">2</span>;</span><br><span class="line">unsigned <span class="keyword">int</span> sample:<span class="number">1</span>;</span><br><span class="line"><span class="comment">//查询freelist中span的状态：IN_USE表示最近是否被使用，状态包括none、normal和returned enum &#123; IN_USE，ON_NORMAL_FREELIST, ON_RETURNED_FREELIST &#125;;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么PageHeap是如何组织span的呢？</p>
<p>总体来说，PageHeap维护了一个核心关系：page与span的映射关系。当释放回收一个object时，把object放回原来的位置需要CentralFreeList来处理（object放回原来的span，然后才还给PageHeap），但是之所以能够放回对应的span里是因为有page到span的映射关系，地址值经过地址对齐，很容易知道它属于哪一个page。再通过page到span的映射关系就能知道object应该放到哪里。</p>
<p>span.sizeclass记录了span切分的object属于哪个class，那么属于这个span的object在释放时就可以放到ThreadCache对应class的FreelList 上面，接下来object如果要回收还给CentralFreeList，就可以直接把它挂到对应span的objects链表上。</p>
<p>page到span的映射关系是基于radix tree实现的，你可以把它理解为一种很大的数组，用page值作为偏移可以访问到page所对应的span（也有多个page指向同一个span的情况，因为span有时可不止一个page）。查询radix tree需要消耗一定时间，所以为了避免这些开销，PageHeap和CentralFreeList类似，维护了一个最近活跃的page到class对应关系的缓存。为了保持缓存的效率，缓存只有64KB，旧的对应关系会被新来的对应关系替换掉。</p>
<p>当需要某个尺寸的span没有空闲时，可以把更大尺寸的span拆分，如果大的span也没有了，就是向操作系统要的时候了回收时，也需要判断相邻的span是否空闲，以便将它们组合。判断相邻span还是使用radix tree查询，这种数据结构就像一个大数组，可以获取当前span前后相邻的span地址。span的尺寸有从1page到255page的所有规格，所以span可以以page为单位，用任意尺寸进行拆分和组合。</p>
<p>上面是PageHeap组织span的大体情况，实际上从PageHeap的结构上更容易看出它管理span的方式：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PageMap pagemap_;</span><br><span class="line"><span class="keyword">struct</span> Spanlist &#123;</span><br><span class="line">Span</span><br><span class="line">normal;</span><br><span class="line">Span</span><br><span class="line">returned;</span><br><span class="line">&#125;;</span><br><span class="line">SpanList large_;</span><br><span class="line">SpanList free_[kMaxPages]; <span class="comment">// kMaxPages = 128</span></span><br></pre></td></tr></table></figure></p>
<p>以上这段代码中有两个SpanList，PageHeap就是通过这两个数据结构管理所有的span （free数组和large_列表），，free_数组存放size小于kMaxPages的span，按page数目区分； 而large_列表存放大于等于kMaxPages的span，不再按照page数目区分。</p>
<p>这两个数据结构内部的span又分为normal和returned两个链表以区分活跃和不活跃的内存，其中normal包含的span，是页面明确映射到进程地址空间的span； returned包含的span，是TCMalloc已经通过madvise归还给操作系统的空间，调用madvise相当于取消了虚拟内存与物理内存的映射。</p>
<p>PageHeap本身并不会将内存释放给操作系统，因为它们之间的交互都是针对一批连续page的，要想回收到整批的page，基本不可能。在PageHeap里面，不活跃的内存会放到returned中，与normal隔离。活跃的normal上的内存总是被优先使用，所以操作系统不会搭理它们。至于returned里面的内存，意味着是不活跃的，操作系统在内存不够的时候会优先将它们回收。</p>
<p>其实没有returned链表也可以做到活跃与不活跃内存的区分，反正normal也是一个链表，span按活跃度排序就好了，链表尾部的span意味着长期不被使用，是可以回收的，这样看起来不是更省事了吗？然而事实上，span进入returned时，TCMalloc还做了一件事，那就是调用madvise（MADVDONTNEED）告诉操作系统这些内存已经暂时不需要了，操作系统可以随便处理。</p>
<p>最终结果是虽然通过madvise“表面归还”给了操作系统，但是操作系统有可能还没有来得及收回这部分内存，所以TCMalloc留着returned列表，以备后续可以再次直接利用而不必向操作系统申请。如果操作系统回收之前，TCMalloc再次使用了这些page，那操作系统就暂时不会再回收这些内存空间（如果“不幸”被操作系统回收了，TCMalloc还想用的时候，Linux内核会引发page fault，并将其映射到一块全零的内存空间，虽然不影响使用，但是会影响性能）。</p>
<p>所以在分配内存时，PageHeap首先判断请求的page数量大小，如果小于kMaxPages，那么先从free_数组中找，从要求大小的位置开始往后找，先找normal链表再找returned链表。如果在normal链表中找到且找到的span状态为Span：：ON_NORMAL_FREELIST，那么直接从里面切割需要的span返回给CentralCache。如果在returned链表中找到且找到的span状态为Span：：ON_RETURNED_FREELIST，那么直接从里面切割需要的span返回给CentralCache。</p>
<p>但是若需要的page数量大于kMaxPages，那么将从large_列表中找。同样先从normal链表入手，然后再找returned链表，找到最符合大小且状态为空闲的最小的span，然后切割出来返回给CentralCache。</p>
<p>如果在large列表中都没有找到合适的span，就需要通过GrowHeap增加Heap的大小了，通过向系统申请内存并包装成span，然后存入heap中，才能进行分配。</p>
<h1 id="Mspan（内存管理器）"><a href="#Mspan（内存管理器）" class="headerlink" title="Mspan（内存管理器）"></a>Mspan（内存管理器）</h1><p>前面提到过，Go语言内存管理器是基于TCMalloc实现的，底层直接调用mmap函数，并使用bestfit进行动态分配，但Go语言的内存管理器也做了一些优化，所以和TCMalloc并不完全一致。在Go语言中，内存分为两部分，一部分作为堆，供内存分配；另一部分作为bitmap，用来管理堆。这两部分的内存都是从同一个地址开始申请的，向高地址的方向增长的就是内存池，向低地址方向增长的就是bitmap。</p>
<p>下面主要介绍内存管理缓存结构。</p>
<p>Go语言为每个系统线程分配了一个本地MCache（类似TCMalloc中的ThreadCache，不过Go语言改了名称），少量的地址分配就是从MCache分配的，并且定期进行垃圾回收，所以Go语言的分配器包含了显式与隐式的调用。Go语言定义的小块内存与TCMalloc基本一致，Go语言底层会把这些小块内存按照指定规格（和TCMalloc的class类似）进行切割。整个过程结构都与TCMalloc相似，不再赘述。</p>
<p>下面是Go语言内存分配的主要组件（如图15-5所示）。</p>
<ul>
<li>MCache：每个尺寸的class都有一个空闲链表。每个goroutine（线程）都有自己的局部MCache（小对象从它取，无须加锁，没有竞争，因此十分高效）。</li>
<li>MCentral：与TCMalloc的CentralCache类似，MCache可以从这里获取更多内存，当自身无空闲内存时，可以向MHeap申请一个span（只能一个），申请的span包含多少个page 由central的 sizeclass确定。</li>
<li>MHeap：负责将MSpan组织和管理起来。分配过程和TCMalloc类似，从free数组中分配，如果发生切割则将剩余的部分放回free数组中。回收过程也类似，回收一个Mspan时，先查找它的相邻地址，再通过map映射得到对应的Mspan，如果Mspan的状态是未使用，则可以将两者合并。最后将这个page或者合并后的page归还到free数组分配池或者large中。</li>
</ul>
<blockquote>
<p>图15-5 Go语言alloc示意图</p>
</blockquote>
<p>可以看到Go语言的内存分配结构和TCMalloc是基本一致的，需要注意的是图15-5中的一句话：struct Mcache alloc from’cachealloc’by FixAlloc，意思是说用户进程newobject是从图15-5所示的arena区域分配的，而runtime层自身管理的结构（比如mcache等）是专门设计了fixAlloc来分配的，这和TCMalloc非常不一样。</p>
<p>在Go语言里面，内存分配有三个基本的概念要清楚，即G-M-P：G代表Goroutine执行的上下文环境；M代表操作系统线程；P代表Processer（调度器），这是进程调度的关键，调度器可以认为“约等于”CPU。一个Goroutine的运行需要G-P-M三部分结合起来。</p>
<p>Go语言的内存分配器与TCMalloc库基本一样，是一个带内存池的分配器，底层直接调用操作系统的mmap等函数。内存池是一种内存分配方式。在通常情况下，我们所理解的分配内存都是通过直接使用new、malloc等API申请的，由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。<br>于是就有了内存池的方法，简单来说，内存池是在真正使用内存之前，先申请一大块内存（例如1MB），并把分配到的内存划分为一定数量的、大小相等（一般而言）的小内存块构成链表，留作备用。当有新的内存需求时，就从内存池中分出一小部分内存块即可。若内存块不够再继续申请新的内存，如果内存闲置过多则将部分内存归还给操作系统。这样做的一个显著优点是，使得内存分配效率得到提升。</p>
<p>不过在Go语言中，内存分配器只管理内存块，并不关心对象的状态，而且不会主动回收内存，需要由垃圾回收器完成清理操作后，再触发内存管理器回收内存。</p>
<p>1.初始化</p>
<p>初始化过程大体是通过sysReserve向系统申请一块连续的内存（由 spans+bitmap+arena组成）。其中arena为各个级别缓存结构提供的分配的内存块，spans是一个指针数组，用来按照page寻址arena区域。sysReserve最终调用的是系统函数mmap，会申请512GB的虚拟地址空间（64位机器上为spans 512MB.bitmap 16GB.arena512GB），当然真正的物理内存则是用到的时候发生缺页才真实占用。</p>
<p>MHeap在mallocinit()中初始化，而mallocinit被schedinit()调用，代码详见/src/runtime/proc.go，大体逻辑如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocinit</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//检查系统/硬件信息</span></span><br><span class="line"><span class="comment">//初始化规格class和size的对照方法</span></span><br><span class="line">initSizes()</span><br><span class="line"><span class="comment">//计算预留空间大小</span></span><br><span class="line"><span class="comment">//系统指针大小PtrSize=8，表示这是一个64位系统</span></span><br><span class="line"><span class="comment">/*spans记录的是arena区的块页号和对应的mspan指针的对应关系。比如arena区内存地</span></span><br><span class="line"><span class="comment">址x，对应的页号就是page_num=（x-arena_start）/page_size，那么spans就会记录spans【page_num】=x。如果arena为512GB，spans区的大小为512GB/8KB*8=512 MB。这里值得注意的是Go语言的内存管理虚拟地址页大小为8KB*/</span></span><br><span class="line"><span class="keyword">if</span> ptrSize == <span class="number">8</span> &amp; (limit == <span class="number">8</span> |l limit &gt; <span class="number">1</span>&lt;&lt;<span class="number">30</span>)&#123;</span><br><span class="line">arenaSize := round(_MaxMem, _PageSize)</span><br><span class="line">bitmapSize = arenaSize / (ptrSize* <span class="number">8</span> / <span class="number">4</span>)</span><br><span class="line">spansSize = arenaSize I PageSize * ptrSize</span><br><span class="line">pSize = bitmapSize + spansSize + arenaSize +  PageSize</span><br><span class="line">p1 = <span class="keyword">uintptr</span>(sysReserve(unsafe.Pointer(p), pSize, &amp;reserved))</span><br><span class="line"><span class="comment">//尝试预留地址（区分不同平台）</span></span><br><span class="line">fori:=<span class="number">8</span>;i&lt;=x7f;i++&#123;</span><br><span class="line">pSize = bitmapSize + spansSize + arenaSize + _PageSize <span class="comment">//向0S申请大小为pSize的连续的虚拟地址空间</span></span><br><span class="line">p = <span class="keyword">uintptr</span>(sysReserve(unsafe.Pointer(p),pSize,&amp;reserved)) &#125;</span><br><span class="line"><span class="comment">//初始化部分mheap 中变量</span></span><br><span class="line">p1 := round(p,_PageSize)</span><br><span class="line">spansStart := p1</span><br><span class="line">mheap_.bitmap = p1 + spansSize + bitmapSize</span><br><span class="line">mheap_.arena_start = p1 + (spansSize + bitmapSize)</span><br><span class="line"></span><br><span class="line">mheap_.arena_end=p+pSize</span><br><span class="line">mheap_.arena_used = p1 + (spansSize + bitmapSize)</span><br><span class="line">mheap_.arena_reserved - reserved</span><br><span class="line"><span class="comment">//其他部分初始化，67个mcentral在这里初始化</span></span><br><span class="line">mheap_.init(spansStart, spansSize)</span><br><span class="line"><span class="comment">//获取当前G</span></span><br><span class="line">_g_ :=getg()</span><br><span class="line"><span class="comment">//获取G上绑定的M的mcache</span></span><br><span class="line">_g_.m.mcache = allocmcache()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>MHeap初始化相关指针，使之可以在arena这块内存寻址，同时初始化cachealloc这个固定分配器，最后执行的m.mcache =allocmcache()是每个goroutine创建时都要初始化的。此时才真正创建了mcache，并且初始化mcache里整个数组对应的mspan为emptyspan。</p>
<p>在上面的代码中，p是从连续虚拟地址的起始地址先进行对齐，然后初始化arena、bitmap、 spans地址。mheap_.init()会初始化fixalloc等相关的成员，还有MCentral的初始化。</p>
<p>MCentral的初始化比较简单，设置自身级别并将两个mspanList初始化。而MCache在procresize（nprocs int32）*p中初始化（代码如下），procresize也在schedinit()中调用，顺序在mallocinit）之后，也就是说发生在MHeap与MCentral的初始化后面。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span>*<span class="title">p</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化新的P（调度器）</span></span><br><span class="line"><span class="keyword">for</span> i :=<span class="keyword">int32</span>(<span class="number">0</span>);i&lt;nprocs; i++ &#123;</span><br><span class="line">PP:=allp[i]</span><br><span class="line"><span class="keyword">if</span> pp == <span class="literal">nil</span>&#123;</span><br><span class="line">pp =<span class="built_in">new</span>(p)</span><br><span class="line">pp.id=i</span><br><span class="line">pp.status =_Pgcstop</span><br><span class="line">pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">pp.deferpool[i]= pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">atomicstorep(unsafe. Pointer(&amp;allp[i]),unsafe.Pointer(pp))</span><br><span class="line"><span class="comment">//Pmcache初始化</span></span><br><span class="line"><span class="keyword">if</span> pp.mcache == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">if</span> old== <span class="number">0</span> &amp;&amp;i==<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">if</span> getg().m.mcache == <span class="literal">nil</span>&#123;</span><br><span class="line">throw(<span class="string">"missing mcache?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//P【0】分配给主goroutine</span></span><br><span class="line">pp.mcache = getg().m.mcache <span class="comment">// bootstrap &#125;else &#123; //P【0】之外的P申请mcache</span></span><br><span class="line">pp.mcache = allocmcache()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的P都存放在一个全局数组allp中，procresize（的目的就是将allp用到的P进行初始化，同时对多余的P的资源隔离。至此，管理结构MHeap.MCentral及每个P的MCache都初始化完毕，接下来进入分配阶段。</p>
<p>2.分配</p>
<p>分配的整个流程是：将小对象所需内存大小向上取整到最近的尺寸类别或者称为规格（class），查找相应的MCache的空闲链表，如果链表不空，直接从上面分配一个对象，这个过程不加锁；如果MCache空闲链表是空的，通过MCentral的空闲链表取一些对象进行补充；如果MCentral的空闲链表也是空的，则在MHeap中取用一些page对MCentral进行补充，然后将这些内存分割成特定规格；如果MHeap没有足够大的page时，从操作系统分配一组新的page。</p>
<p>为了避免逃逸的情况，假设关闭了内联优化，现在来看源码，当new一个对象时，调用的是newobject()，但实际上调用的是mallocgc()：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type,needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">c:=gomcache()</span><br><span class="line"><span class="keyword">if</span>. size &lt;= maxSmallSize&#123;</span><br><span class="line"><span class="comment">// size小于16B的不用扫描的对象，直接从mcache的tiny（极小）上分</span></span><br><span class="line"><span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">off:=c.tinyoffset</span><br><span class="line"><span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny !=<span class="number">0</span>&#123;</span><br><span class="line">x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">returnx</span><br><span class="line">]</span><br><span class="line"><span class="comment">//若没有tiny了，则从mcache中相应规格（class size）的mspan中查找span :=c.alloc[tinySizeClass]</span></span><br><span class="line">v,_, shouldhelpgc =c.nextFree(tinySizeClass)</span><br><span class="line">x = unsafe.Pointer(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//普通小于4KB小对象先计算规格（class size）</span></span><br><span class="line"></span><br><span class="line">span:=c.alloc[sizeclass]</span><br><span class="line">v, span, shouldhelpgc = c.nextFree(sizeclass) &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//大对象直接从heap分配span</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">s = largeAlloc(size, needzero)</span><br><span class="line">&#125;)</span><br><span class="line">x = unsafe.Pointer(s.base())</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c*mcache)</span> <span class="title">nextFree</span><span class="params">(sizeclass <span class="keyword">uint8</span>)</span> <span class="params">(v gclinkptr,</span></span></span><br><span class="line"><span class="function"><span class="params">s *mspan, shouldhelpgc <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line">s=c.alloc[sizeclass]</span><br><span class="line">余排的新中说\</span><br><span class="line">freeIndex :=s.nextFreeIndex()</span><br><span class="line">态内的最中算动</span><br><span class="line"><span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">+<span class="number">92</span>+<span class="number">3</span>:</span><br><span class="line">ac上a</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">(x)￥才<span class="number">0</span>寸门上vn上t。</span><br><span class="line">c.refill(<span class="keyword">int32</span>(sizeclass))</span><br><span class="line">nwn上寸</span><br><span class="line">&#125;)</span><br><span class="line">s = c.alloc[sizeclass]</span><br><span class="line">freeIndex = s.nextFreeIndex()</span><br><span class="line">内的<span class="number">861</span>小<span class="number">-11</span></span><br><span class="line">]</span><br><span class="line">v = gclinkptr(freeIndex*s.elemsize +s.base())</span><br><span class="line">法的以特下</span><br><span class="line">vmd</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码省略了很多信息，为了更清晰地了解这个过程，根据对象的大小分为3个级别：tiny（极小）、小、大，首先是tiny（小于16B）级别的：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">off:=c.tinyoffset</span><br><span class="line">，这板大号着</span><br><span class="line"><span class="comment">//地址对齐</span></span><br><span class="line"><span class="keyword">if</span> size&amp;<span class="number">7</span>== <span class="number">0</span> &#123;</span><br><span class="line">som 中的这牛台</span><br><span class="line">off = round(off,<span class="number">8</span>)</span><br><span class="line">通动高然林连头</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span>==<span class="number">0</span>&#123;</span><br><span class="line">off = round(off,<span class="number">4</span>)</span><br><span class="line"><span class="number">6</span>的<span class="number">0</span>nu</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span>==<span class="number">0</span> &#123;</span><br><span class="line">off = round(off,<span class="number">2</span>)</span><br><span class="line"><span class="number">100.</span></span><br><span class="line"><span class="comment">//若之前tiny剩余空间够用，则将极小对象拼在一起 if off+size &lt;= maxTinySize &amp;&amp; c.tiny !=0&#123; x= unsafe. Pointer(c.tiny + off)</span></span><br><span class="line">c.tinyoffset = off + size</span><br><span class="line">c.local_tinyallocs++</span><br><span class="line">mp.mallocing =<span class="number">0</span></span><br><span class="line">releasem(mp)</span><br><span class="line">returnx</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tiny不够了，为其重新分配一个16B的内存块</span></span><br><span class="line"><span class="comment">// Allocate a new maxTinySize block.</span></span><br><span class="line">span :=c.alloc[tinySizeClass]</span><br><span class="line">v :=nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v==<span class="number">0</span>&#123;</span><br><span class="line">v,_,shouldhelpgc =c.nextFree(tinySizeClass)</span><br><span class="line">x= unsafe.Pointer(v)</span><br><span class="line"><span class="comment">//将申请的内存块全置为0</span></span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x) [<span class="number">0</span>]= <span class="number">0</span></span><br><span class="line">(*[<span class="number">2</span>]<span class="keyword">uint64</span>)(x)[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line"><span class="comment">//新申请的剩余空间大于之前的剩余空间</span></span><br><span class="line"><span class="comment">//如果申请的内存块用不完，则将剩下的给tiny，用tinyoffset记录分配了多少if size &lt;c.tinyoffset ll c.tiny == e&#123;</span></span><br><span class="line">c.tiny = <span class="keyword">uintptr</span>(x)</span><br><span class="line">c.tinyoffset = size</span><br><span class="line">size = maxTinySize</span><br></pre></td></tr></table></figure></p>
<p>对于小于16B的内存块，Mcache有一个专门的内存区域“tiny”用来分配，tiny指针指向tiny内存块的起始地址。如上所示，tinyoffset表示tiny当前分配的地址位置，之后的分配根据tinyoffset寻址。先根据要分配的对象大小进行地址对齐，比如size是8的倍数，tinyoffset就和8对齐，然后进行分配。如果tiny剩余的空间不够用，则重新申请一个16B的内存块，并分配给object。如果有余，则记录在tiny上。</p>
<p>接着是大对象（大于32KB），小对象有些复杂一会再说，对于大于32KB的内存分配直接跳过mcache和mcentral，通过mheap分配。大于32KB的内存分配都是分配整数页，先右移然后低位与计算需要的页数。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line">shouldhelpgc =<span class="literal">true</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//largeAlloc会调用mheap_.alloc，这个方法在小对象申请时已经追踪过s = largeAlloc(size, needzero)</span></span><br><span class="line">&#125;)</span><br><span class="line">s.freeindex=<span class="number">1</span></span><br><span class="line">s.allocCount =<span class="number">1</span></span><br><span class="line">x = unsafe.Pointer(s.base())</span><br><span class="line">size =s.elemsize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largeAlloc</span><span class="params">(size <span class="keyword">uintptr</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span> &#123; npages :=size&gt;&gt;_PageShift</span><br><span class="line"><span class="keyword">if</span> size&amp;_PageMask!=<span class="number">0</span>&#123;</span><br><span class="line">npages++</span><br><span class="line">s :=mheap_.alloc(npages,e, <span class="literal">true</span>, needzero)</span><br><span class="line"><span class="keyword">if</span> s== <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"out of memory"</span>)</span><br><span class="line">s.limit = s.base() +size</span><br><span class="line">heapBitsForSpan(s.base()).initSpan(s)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后是对于大小介于16KB~32KB的小对象内存分配，首先计算应该分配的 sizeclass，然后去mcache里面申请，如果不够，就让mcache向mcentral申请再分配。Mcentral为mcache分配完之后会判断自己需不需要扩充，如果需要就向mheap申请。</p>
<p>这个过程已经说了很多次了，下面来看具体源码，计算应该分配的sizeclass代码如下：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sizeclass <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span>&#123;</span><br><span class="line">sizeclass = size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv<span class="number">-1</span>)/largeSizeDiv]</span><br><span class="line">/$</span><br></pre></td></tr></table></figure></p>
<p>数组size_to_class8的第1个值表示地址区间【（i-1）*8，1*8】对应的sizeclass，这里smallSizeDiv等于8。size_to_class128类似。</p>
<p>小于1024-8=1016（smallSizeMax=1024），则使用数组size_to_class8，否则使用数组size_to_class128。</p>
<p>举个例子，比如要分配17B的内存（16B以下的使用mcache.tiny分配）：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> sizeclass = size_to_calss8[(<span class="number">17</span>+<span class="number">7</span>)/<span class="number">8</span>] = size_to_class8[<span class="number">3</span>]=<span class="number">3</span> */</span><br><span class="line">size = <span class="keyword">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">span :=c.alloc[sizeclass]</span><br><span class="line"><span class="comment">//从对应的span里面分配一个object</span></span><br><span class="line">v :=nextFreeFast(span)</span><br><span class="line">ifv==<span class="number">0</span>&#123;</span><br><span class="line">v, span, shouldhelpgc = c.nextFree(sizeclass)</span><br><span class="line">&#125;</span><br><span class="line">x =unsafe Pointer(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> needzero &amp;&amp; span.needzero !=<span class="number">0</span>&#123;</span><br><span class="line">memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br></pre></td></tr></table></figure></p>
<p>计算出 sizeclass，那么就可以去mcache.alloc【sizeclass】分配了，注意这是一个mspan指针，这里有两个重要的方法nextFreeFast和nextFree，它们才是真正执行分配的工作。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//如果下一个对象快速可用，则nextFreeFast返回下一个空闲对象，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextFreeFast</span><span class="params">(s*mspan)</span> <span class="title">gclinkptr</span></span>&#123;</span><br><span class="line"><span class="comment">//计算s.allocCache 从低位起有多少个↵</span></span><br><span class="line">theBit := sys.ctz64(s.allocCache)</span><br><span class="line"><span class="keyword">if</span> theBit &lt; <span class="number">64</span> &#123;</span><br><span class="line">result :=s.freeindex + <span class="keyword">uintptr</span>(theBit)</span><br><span class="line"><span class="keyword">if</span> result &lt;s.nelems &#123;</span><br><span class="line">freeidx :=result+<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> freeidx%<span class="number">64</span> =_ o&amp;&amp; freeidx != s.nelems&#123;</span><br><span class="line">return0</span><br><span class="line"><span class="comment">//更新位图、可用游标</span></span><br><span class="line">s.allocCache &gt;&gt;= (theBit+<span class="number">1</span>)</span><br><span class="line">s.freeindex = freeidx</span><br><span class="line"><span class="comment">//根据result和s.elemsize起始地址计算↵</span></span><br><span class="line">v:=gclinkptr(result*s.elemsize +s.base())</span><br><span class="line">s.allocCount++</span><br><span class="line">returnv</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>在以上代码中，allocCache用位图表示内存是否可用，1表示可用，然后通过span里面的freeindex和elemsize来计算地址。现在的重点是如果mcache.alloc【sizeclass】不够用了，则通过nextFree向mcentral（甚至mheap）申请内存，看下面代码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c*mcache)</span> <span class="title">nextFree</span><span class="params">(sizeclass <span class="keyword">uint8</span>)</span> <span class="params">(v gclinkptr, s *mspan, shouldhelpgc boo l)</span></span>&#123;</span><br><span class="line">s = c.alloc[sizeclass]</span><br><span class="line">shouldhelpgc = <span class="literal">false</span></span><br><span class="line">freeIndex:=s.nextFreeIndex()</span><br><span class="line"><span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line"><span class="comment">// span为空</span></span><br><span class="line">业</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount) !=s.nelems&#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"runtime: s.alloccount="</span>, s.alloccount, <span class="string">"s.nelems="</span>, s.nelems) throw(<span class="string">"s.allocCount != s.nelems &amp;&amp; freeIndex== s.nelems"</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="comment">//重新填充当前的mcache</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处mcache向mcentral申请</span></span><br><span class="line">c.refill(<span class="keyword">int32</span>(sizeclass))</span><br><span class="line">&#125;)</span><br><span class="line">shouldhelpgc = <span class="literal">true</span></span><br><span class="line">s=c.alloc[sizeclass]</span><br><span class="line"><span class="comment">// mcache 向mcentral申请完之后，再次从mcache申请freeIndex = s.nextFreeIndex()</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看到，如果nextfree在mcache相应规格的mspan里拿不到object，那么就需要从mcentral中“再次装填”（rfill）内存块。</p>
<p>mcache向mcentral申请内存实际是通过refill来实现的。你可能还记得一个细节：没有可用object的MSpan是要还给MCentral的，并挂到MCentral的empty链表中，在这里相应体现为把没有object的MSpan的incache值设置为false，等待sweep回收。</p>
<p>sweepgen是一个回收标记，其中sg-2表示等待回收，sg-1表示正在回收，sweepgen表示已经回收。从MCentral中获取MSpan时有可能遇到当前的SPan正等待或正被回收所以可以先把等待回收的MSpan返回，用来再次填装（rfill）MCache，因此将它插入empty链表中：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c*mcache)</span> <span class="title">refill</span><span class="params">(sizeclass <span class="keyword">int32</span>)</span> *<span class="title">mspan</span></span> &#123;</span><br><span class="line">_g_ :=getg()</span><br><span class="line">_g_.m.locks++</span><br><span class="line"><span class="comment">//向mcentral归还当前的mspan</span></span><br><span class="line">s:=c.alloc[sizeclass]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(s.allocCount)!=s.nelems&#123;</span><br><span class="line">throw(<span class="string">"refill of span with free space remaining"</span>)</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> s !=&amp;emptymspan &#123;</span><br><span class="line"><span class="comment">//空Span回收标志</span></span><br><span class="line">s.incache = <span class="literal">false</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">//向mcentral申请，注意mcentral.cacheSpan()</span></span><br><span class="line">s=mheap_.central[sizeclass].mcentral.cacheSpan()</span><br><span class="line">c.alloc[sizeclass]=s</span><br><span class="line">_g_.m.locks-.</span><br><span class="line">returns</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">//分配一个span以在MCache中使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c*mcentral)</span> <span class="title">cacheSpan</span><span class="params">()</span>*<span class="title">mspan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">sg:=mheap_.sweepgen</span><br><span class="line">retry:</span><br><span class="line"><span class="keyword">var</span> s *mspan</span><br><span class="line"><span class="comment">//先从非空列表中找</span></span><br><span class="line">fors=c.nonempty.first;s!=<span class="literal">nil</span>;s=s.next&#123;</span><br><span class="line"><span class="keyword">if</span> s.sweepgen == sg<span class="number">-2</span> &amp;&amp; atomic.cas(&amp;s.sweepgen,sg<span class="number">-2</span>,sg<span class="number">-1</span>)&#123; <span class="comment">//等待回收，可以返回使用</span></span><br><span class="line">c.nonempty. remove(s)</span><br><span class="line">c.empty.insertBack(s)</span><br><span class="line">s.sweep(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">goto</span> havespan</span><br><span class="line"><span class="keyword">if</span> s.sweepgen == sg<span class="number">-1</span>&#123;</span><br><span class="line"><span class="comment">//正在回收，忽略continue</span></span><br><span class="line">c.nonempty.remove(s) c.empty.insertBack(s) <span class="keyword">goto</span> havespan</span><br><span class="line"><span class="comment">//没有则从空列表中找</span></span><br><span class="line"><span class="keyword">for</span> s= c.empty.first; s != <span class="literal">nil</span>;s=s.next&#123;...&#125; <span class="comment">//实在没有再申请</span></span><br><span class="line">s= c.grow()</span><br><span class="line">c.empty.insertBack(s)</span><br><span class="line">havespan:</span><br><span class="line">returns</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">到这里，如果内存还不够就需要让MCentral向MHeap申请内存了中</span></span><br><span class="line"><span class="comment">//此处由MCentral申请</span></span><br><span class="line"><span class="comment">func (c*mcentral) grow() *mspan &#123;</span></span><br><span class="line"><span class="comment">npages := uintptr(class_to_allocnpages[c.sizeclass]) size :=uintptr(class_to_size[c.sizeclass])</span></span><br><span class="line"><span class="comment">n :=(npages&lt;&lt; _PageShift)Isize</span></span><br><span class="line"><span class="comment">//这里向MHeap申请</span></span><br><span class="line"><span class="comment">s :=mheap_.alloc(npages,c.sizeclass, false, true)</span></span><br><span class="line"><span class="comment">returns</span></span><br><span class="line"><span class="comment">7</span></span><br></pre></td></tr></table></figure></p>
<p>至此，上面几个函数的调用链已经到了MCentral都没有内存的地步，需要向MHeap申请了，grow会计算出当前所需规格对应的page数目，然后从MHeap中的nPage取一个mspan。前面提到的free数组是一个指针数组，每个指针对应一个MSpan的链表，数组按照nPage寻址。</p>
<p>若所需的nPage链表中都没有空闲MSpan，则MHeap也需要补充内存了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc</span><span class="params">(npage <span class="keyword">uintptr</span>, sizeclass <span class="keyword">int32</span>, large <span class="keyword">bool</span>, needzero <span class="keyword">bool</span>)</span> *<span class="title">mspan</span></span>&#123;</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">s = h.alloc_m(npage, sizeclass, large) &#125;)</span><br><span class="line">returns</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span> <span class="title">alloc_m</span><span class="params">(npage <span class="keyword">uintptr</span>, sizeclass <span class="keyword">int32</span>, large <span class="keyword">bool</span>)</span>*<span class="title">mspan</span></span> &#123;</span><br><span class="line">s:=h.allocSpanLocked(npage)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Best-fit算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h*mheap)</span> <span class="title">allocSpanLocked</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> *<span class="title">mspan</span></span> &#123; <span class="comment">//先从128页（1MB）以内的空闲列表中寻找</span></span><br><span class="line"><span class="keyword">for</span> i :=<span class="keyword">int</span>(npage);i&lt;<span class="built_in">len</span>(h.free);i++&#123;</span><br><span class="line">list =&amp;h.free[i]</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="comment">//Best-fit对于大对象申请也会用到这个方法</span></span><br><span class="line"><span class="comment">//基本思路是找到最小可以满足需求的MSpan，如果有多个，选择地址最小的list =&amp;h.freelarge</span></span><br><span class="line">s =h.allocLarge(npage)</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//如果MHeap也没有空间就向系统申请</span></span><br><span class="line"><span class="keyword">if</span> !h.grow(npage)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">s = h.allocLarge(npage)</span><br><span class="line"><span class="keyword">if</span> s== <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">HaveSpan:</span><br><span class="line"><span class="comment">//转移s</span></span><br><span class="line">list.remove(s)</span><br><span class="line"><span class="keyword">if</span> s.inlist()&#123;</span><br><span class="line">throw(<span class="string">"still in list"</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于申请到的内存大于想要的，将其拆分，避免浪费</span></span><br><span class="line"><span class="keyword">if</span> s.npages &gt; npage &#123;</span><br><span class="line">D£</span><br><span class="line">h.freeSpanLocked(t,<span class="literal">false</span>, <span class="literal">false</span>, s.unusedsince)</span><br><span class="line">s.state = _MSpanFree</span><br><span class="line">]</span><br><span class="line">omut)ko6j2m9t2v sqn)mooll6.n-</span><br><span class="line">returns</span><br><span class="line">nnuitey</span><br><span class="line"><span class="comment">//向系统申请空间</span></span><br><span class="line"><span class="comment">/*MHeap增长会通过h.sysAlloc（代码在下方）直接向arena区域申请nB的内存，n具体值根据 nPage大小计算。此时，arena区域的一些指针标记开始移动，最终将MSpan加入链表，等待分配*/</span> <span class="function"><span class="keyword">func</span> <span class="params">(h*mheap)</span> <span class="title">grow</span><span class="params">(npage <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">//计算页数</span></span><br><span class="line">npage = round(npage,(<span class="number">64</span>&lt;&lt;<span class="number">10</span>)/_PageSize)</span><br><span class="line">ask := npage &lt;&lt; _PageShift</span><br><span class="line"><span class="keyword">if</span> ask &lt; _HeapAllocChunk &#123;</span><br><span class="line">ask = _HeapAllocChunk</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line">v :=h.sysAlloc(ask)</span><br><span class="line">s:=(*mspan)(h.spanalloc.alloc())</span><br><span class="line">s.init(<span class="keyword">uintptr</span>(v),ask&gt;&gt;_PageShift)</span><br><span class="line">p:=(s.base()-h.arena_start)&gt;&gt;_PageShift <span class="keyword">for</span> i :=p;i&lt;p+s.npages; i++&#123;</span><br><span class="line">h.spans[i]=s</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line">atomic.Store(&amp;s.sweepgen,h.sweepgen)</span><br><span class="line">s.state = _MSpanInUse</span><br><span class="line">h.pagesInUse += <span class="keyword">uint64</span>(s.npages)</span><br><span class="line"><span class="comment">//加入链表</span></span><br><span class="line">h.freeSpanLocked(s, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(h*mheap)</span> <span class="title">sysAlloc</span><span class="params">(n <span class="keyword">uintptr</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"><span class="comment">// sysReserve调用mmap预留空间，至此调用链结束</span></span><br><span class="line">p :=<span class="keyword">uintptr</span>(sysReserve(unsafe.Pointer(h.arena_end),p_size,&amp;reserved))</span><br><span class="line"><span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>整个函数调用链如上所示，最后sysAlloc会调用系统函数（mmap之类的）向操作系统申请内存，至此Go语言的内存分配流程全部结束，再往后就是操作系统内核的世界了，不再归Go语言内存分配器管理。</p>
<p>3.回收释放</p>
<p>这里的回收并非是垃圾回收，而是更简单的内存回收。还记得上面说到的sweepgen标记吧！简单来说，MSpan里有sweepgen回收标记，回收的内存会先全部回到MCentral，如果已经回收所有的MSpan，就还给MHeap的空闲列表。回收内存的一个很重要的原因是为了复用，所以很多时候并不会直接释放内存。</p>
<p>先说MCache吧！使用内存时有两种情况：第一种是用完了闲置，第二种是用了但没用完，前者直接标记等待回收就可以，至于多出来没用到的部分就需要另外想办法还给MCentral了：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查空闲的MCache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freemcache</span><span class="params">(c*mcache)</span></span>&#123;</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">c.releaseAll()</span><br><span class="line"><span class="number">1</span>ock(&amp;mheap_<span class="number">.1</span>ock)</span><br><span class="line">purgecachedstats(c)</span><br><span class="line">mheap_.cachealloc.free(unsafe.Pointer(c)) unlock(&amp;mheap_.lock)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">releaseAll()负责将mcache.alloc中各个sizeclass中的MSpan归还给MCentral。 此处的归还操作需要加锁，因为MCentral是全局的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c*mcache)</span> <span class="title">releaseAll</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i :=e;i&lt;_NumSizeClasses; i++&#123;</span><br><span class="line">s:=c.alloc[i]</span><br><span class="line"><span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">mheap_.central[i].mcentral.uncacheSpan(s)</span><br><span class="line">c.alloc[i]=.&amp;emptymspan</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除tinyalloc池</span></span><br><span class="line">c.tiny =e</span><br><span class="line">c.tinyoffset =</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>用完那部分，通过sweep标记等待回收：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s*mspan)</span> <span class="title">sweep</span><span class="params">(preserve <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">res = mheap_.central[cl].mcentral.freeSpan(s, preserve, wasempty) ]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c*mcentral)</span> <span class="title">freeSpan</span><span class="params">(s*mspan, preserve <span class="keyword">bool</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">wasempty <span class="keyword">bool</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> wasempty &#123;</span><br><span class="line">c.empty. remove(s) c.nonempty.insert(s) &#125;</span><br><span class="line">c.nonempty.remove(s) mheap_.freeSpan(s,<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>sysmon是监控线程，它会遍历MHeap 中large列表里的所有空闲的MSpan，发现空闲时间超过阈值就调用madvise，让系统内核释放这个线程相关的物理内存。</p>
<p>经过上面的步骤，MCache的空闲MSpan已经还给MCentral了，接下来就是MCentral还给MHeap了，这个过程简单来说是当MSpan的object全部收回时，将MSpan归还给Mheap:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查MSpan是否空闲</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c*mcentral)</span> <span class="title">freeSpan</span><span class="params">(s *mspan, preserve <span class="keyword">bool</span>, wasempty <span class="keyword">bool</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> s.allocCount !=<span class="number">0</span>&#123;</span><br><span class="line">unlock(&amp;c.lock) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">c.nonempty.remove(s) unlock(&amp;c.lock)</span><br><span class="line">mheap_.freeSpan(s，<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>到了最后，MHeap那里并不会定时向操作系统归还内存，而是先把相邻的span合并，使之成为一块更大的内存，以page为单位调度回收。</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>与C++通过指针引用计数来回收对象不一样，Go语言的垃圾回收是基于标记清理算法的。由于引用计数不能处理循环引用，为了避免引用计数的缺陷，后来出现了各种垃圾回收机制，包括标记清理、节点复制、分代收集等垃圾回收算法。</p>
<p>Go语言官方形容Go语言的垃圾回收为：</p>
<ul>
<li>并发标记和清理（concurrent mark and sweep）。</li>
<li>写屏障（write barrier）。</li>
<li>非分代（non-generational）。</li>
<li>非紧缩（non-compacting），</li>
</ul>
<p>顾名思义，标记清理算法就是将需要的内存块进行标记（mark），没有标记的内存块将被清理（sweep）。</p>
<h2 id="标记清理算法"><a href="#标记清理算法" class="headerlink" title="标记清理算法"></a>标记清理算法</h2><p>标记清理算法是一个很古老（20世纪70年代提出）且很基础的垃圾回收算法，该算法中有一个标记初始的root区域，以及一个受控堆区。root区域主要是程序运行到当前时刻的栈和全局数据区域。在受控堆区中，很多数据是程序以后不需要用到的，这类数据就可以被当作垃圾回收了。</p>
<p>判断一个对象是否是垃圾，需要看这个对象是否被当前栈或全局数据区域（就是root区域）的对象直接或间接地引用。如果没有任何对象引用到它，则说明它没有被使用，因此可以安全地当作垃圾回收。</p>
<p>标记清理算法分为两阶段：标记阶段和清扫阶段。标记阶段，从root区域出发，扫描所有root区域的对象直接或间接引用到的对象，将这些对象全部加上标记。在回收阶段，扫描整个堆区，对所有无标记的对象进行回收。</p>
<p>这里会引出几个问题：怎样实现并发标记？标记记录在哪里？怎样知道对象是否被引用？什么时候触发清理动作？回收时进程怎么办？</p>
<p>1.如何标记</p>
<p>一直以来Go语言的垃圾回收都是争议比较大的地方，不止Go语言，其他语言也是，垃圾回收永远是一门大学问。在Go1.5之前，垃圾回收的标记和清理都是STW（StopTheWorld），就是在标记和清理时都要停止所有的goroutine，以此来保证已经被标记的区域不会被再次修改引用关系，造成清理错误。</p>
<p>这种方式在1.5版本之后的Go语言里得到了改进，毕竟每次垃圾回收都要Stop TheWorld显然太低效率了。从Go1.5开始采用三色标记法实现标记阶段的并发（清理阶段目前到Go1.8为止都还是需要STW）。</p>
<p>三色标记的步骤是：最开始所有对象都是白色；扫描所有可达对象，标记为灰色，放入待处理队列；从队列里提取灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色；写屏障，监控对象内存修改，重新标色或放入队列；完成标记后对象不是白色就是黑色，清理操作只需把白色对象回收即可。</p>
<p>所谓并发标记，一是指通过write-barrier（写屏障）能够与用户代码并发进行，二是指通过gc-work队列实现非递归地标记可达对象，换而言之标记工作不是递归进行的，而是多个goroutine并发进行的。</p>
<p>为什么需要write-barrier？很简单，对于和用户程序并发运行的垃圾回收算法，用户程序会一直修改内存，所以需要记录下来。写屏障的过程是当发现对象已经标记为黑色了，但该对象引用的对象却变了，那么把后来引用的对象变灰入队，原来的被引用对象保持灰色不变。这个write_barrier是编译器在每一处内存写操作前生成一小段代码来做的。</p>
<p>接下来是并发标记，要实现非递归地遍历标记可达节点，就需要一个队列。这个队列还可以有助于区分黑色对象和灰色对象，因为标记位只有一个。在队列中的标记是灰色对象，标记了但是不在队列中的是黑色对象，未标记的是白色对象。<br>下面是实现源码：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//每个markWorker都执行gcDrain这个标记过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork,flags gcDrainFlags)</span></span>&#123;</span><br><span class="line"><span class="comment">//如果还没有root区域入队则markroot</span></span><br><span class="line">markroot(gcw,job)</span><br><span class="line"><span class="keyword">if</span> idle &amp; pollWork()&#123;</span><br><span class="line"><span class="keyword">goto</span> done</span><br><span class="line"><span class="comment">//节点出队</span></span><br><span class="line">b= gcw.get()</span><br><span class="line">scanobject(b,gcw)</span><br><span class="line">done:</span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="keyword">uintptr</span>, gcw *gcWork)</span></span>&#123;</span><br><span class="line">hbits := heapBitsForAddr(b)</span><br><span class="line">s := spanOfUnchecked(b)</span><br><span class="line">n:=s.elemsize</span><br><span class="line"><span class="keyword">for</span> i=e;i&lt;n;i += sys.PtrSize&#123;</span><br><span class="line"><span class="comment">//找到这个字（指的是最小内存管理单位）对应的位地址（bits）并查询其类型值是否为指针if bits&amp;bitPointer == 0&#123;</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">//如果不是指针则跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记这个对象</span></span><br><span class="line"><span class="keyword">if</span> obj, hbits, span, objIndex := heapBitsForobject(obj,b, i);obj!=<span class="number">0</span>&#123; greyobject(obj, b,i, hbits, span, gcw, objIndex)</span><br><span class="line">&#125;</span><br><span class="line">gcw.bytesMarked += <span class="keyword">uint64</span>(n)</span><br><span class="line">gcw.scanWork += <span class="keyword">int64</span>(i)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greyobject</span><span class="params">(obj, base, off <span class="keyword">uintptr</span>, hbits heapBits,</span></span></span><br><span class="line"><span class="function"><span class="params">span *mspan, gcw *gcWork, objIndex <span class="keyword">uintptr</span>)</span></span>&#123;</span><br><span class="line">mbits :=span.markBitsForIndex(objIndex)</span><br><span class="line"><span class="comment">//如果已经标记，则什么都不做</span></span><br><span class="line"><span class="keyword">if</span> mbits.isMarked()&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> !hbits.hasPointers(span.elemsize)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">gcw.put(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在以上代码中，gcStart是GC的入口函数，根据gcMode做处理，它准备了N个goMarkWorkers，每个worker都处理以下相同流程：</p>
<ul>
<li>如果是第一次标记，则首先调用markroot将所有root区域的指针入队。</li>
<li>从gcw（gc-work队列）中取节点，开始扫描处理（scanobject），节点出队列就是黑色了。</li>
<li>扫描时获取该节点所有子节点的类型信息，判断是不是指针，如果是指针且没有被标记则标记灰色（greyobject）入队。</li>
<li>每个worker都去gcw中拿任务直到队列为空。</li>
</ul>
<p>2.标记位</p>
<p>既然垃圾回收算法要求给对象加上垃圾回收的标记，显然是需要有标记位的。一般会在对象中加上一个标记域，或者利用对象指针的低位进行标记，而Go语言的做法与C语言的结构体对象完全一致，都是非侵入式的标记位。</p>
<p>Go把标记放在了堆区arena前面对应的bitmap里，要知道获得对象区域的类型信息是实现精确的垃圾回收的前提。这个bitmap位图区域的每个字（不是byte，而是word，大小是32b或64b）对应4位的标记位。因此，64位系统中相当于每个标记bitmap的B对应16个堆中的B。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取b对应的bitmap位图</span></span><br><span class="line">obj, hbits, span, objIndex := heapBitsForobject(obj,b, i)</span><br><span class="line">mbits :=span.markBitsForIndex(objIndex)</span><br><span class="line"><span class="comment">//判断是否被标记过，已标记或不是指针都不入队</span></span><br><span class="line">mbits.isMarked()</span><br><span class="line">hbits.hasPointers(span.elemsize)</span><br></pre></td></tr></table></figure></p>
<p>如上所示，heapBitsForAddr可以获取对应堆地址的bitmap位hbits，根据它可以判断是否是指针，如果是指针且之前没有被标记过，则标记当前对象为可达，并且greayObject入队，供给其他的markWorker来处理。</p>
<p>3.清理触发</p>
<p>启动垃圾回收的时机也是一个难题，因为如果频繁垃圾回收会浪费CPU，影响应用代码的性能，而如果垃圾回收启动太晚，会导致堆内存累计太多，如何平衡这个问题是Go语言的每个版本更新时都要面对的。</p>
<p>每一次mallocgc都会检查是否需要gcstart，触发条件由两个参数决定：gc_trigger和gcpercent。</p>
<p>gc_trigger初始为4MB，nextgc初始为4MB，之后每次标记完成时将重新计算动态调整值大小。但gc_trigger至少要大于初始的4MB，同时至少要比当前使用的heap大1MB才会触发GC操作。</p>
<p>这个检查是在堆上分配大于32KB对象的时候进行，此时检查是否满足垃圾回收条件，如果满足则进行垃圾回收。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">shouldhelpgc :=<span class="literal">false</span> <span class="comment">//分配的对象小于32KB</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">shouldhelpgc =<span class="literal">true</span></span><br><span class="line">]</span><br><span class="line"><span class="comment">// gcShouldStart()函数进行触发条件检测// gcBackgroudMode表示并发gc</span></span><br><span class="line"><span class="keyword">if</span> shouldhelpgc &amp;&amp; gcShouldStart(<span class="literal">false</span>)&#123; gcStart(gcBackgroundMode, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcShouldstart</span><span class="params">(forceTrigger <span class="keyword">bool</span>)</span> <span class="title">bool</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> gcphase == _Gcoff &amp;&amp; (forceTrigger |I</span><br><span class="line">memstats.heap_live &gt;= memstats.gc_trigger)&amp;&amp; memstats.enablegc &amp;&amp; panicking == O &amp;&amp;</span><br><span class="line">gcpercent&gt;=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">_= setGcPercent(readgogc())</span><br><span class="line">memstats.gc_trigger = heapminimum</span><br><span class="line">memstats.next_gc = <span class="keyword">uint64</span>(<span class="keyword">float64</span>(memstats.gc_trigger)/(<span class="number">1</span>+ gccontroller .triggerRatio) * (<span class="number">1</span>+<span class="keyword">float64</span>(gcpercent)/<span class="number">100</span>)) work.startSema = <span class="number">1</span></span><br><span class="line">work.markDoneSema =<span class="number">1</span></span><br><span class="line"><span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMark</span><span class="params">()</span></span>&#123;</span><br><span class="line">memstats.gc_trigger = <span class="keyword">uint64</span>(<span class="keyword">float64</span>(memstats.heap_marked)* (<span class="number">1</span>+ gcController.triggerRatio))</span><br></pre></td></tr></table></figure></p>
<p>上面是自动垃圾回收，还有一种是主动垃圾回收，通过调用runtime.GC()，这是阻塞式的。有意思的是，gcmark在每次标记结束后会重置阈值大小。如果当前使用了4MB内存，这时设置gc_trigger为2X4MB，也就是当内存分配到8MB时会再次触发GC；回收之后内存为5MB，那下一次就要达到10MB才会触发GC。这个比例（triggerRatio）是由gcpercent/100决定的。</p>
<p>gcpercent的值是通过环境变量GOGC获取的，如果不设置这个环境变量，默认值是100。如果将它设置成off，则关闭垃圾回收。</p>
<p>如果系统启动或短时间内大量分配对象，会将垃圾回收的gc_trigger推高。在服务正常后，活跃对象远小于这个阈值，造成垃圾回收无法触发，这个问题交给sysmon解决，它每隔2分钟强制触发GC一次。这个forcegc的goroutine一直驻留在后台，直到sysmon将它唤醒开始执行GC而不用检查阈值。</p>
<h2 id="标记实现"><a href="#标记实现" class="headerlink" title="标记实现"></a>标记实现</h2><p>GC开始之前，有一些准备工作，整个GC启动过程都是STW状态，它启动了所有将并发执行标记工作的goroutine，然后进入GCMark状态启动写屏障，启动gcController：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcstart</span><span class="params">(mode gcMode, forceTrigger <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//在后台启动mark worker</span></span><br><span class="line"><span class="keyword">if</span> mode == gcBackgroundMode &#123;</span><br><span class="line"></span><br><span class="line">gcBgMarkStartWorkers()</span><br><span class="line">↓<span class="number">00</span>了</span><br><span class="line">。</span><br><span class="line"><span class="comment">// Stop The World（Go源码关键注释语句，表示此时所有的任务都会被暂停） systemstack(stopTheWorldwithSema)</span></span><br><span class="line"><span class="comment">//完成之前的清理工作</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">finishsweep_m()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//进入Mark状态，写屏障</span></span><br><span class="line"><span class="keyword">if</span> mode == gcBackgroundMode&#123;</span><br><span class="line"><span class="comment">//GC开始前的准备工作</span></span><br><span class="line">gcController.startcycle()</span><br><span class="line"><span class="comment">//处理设置GCPhase，setGCPhase还会开启“写屏障” setGCPhase(_GCmark)</span></span><br><span class="line">gcBgMarkPrepare()<span class="comment">//必须在辅助启用之前发生gcMarkRootPrepare()</span></span><br><span class="line"><span class="comment">//标记所有活跃的tinyalloc内存块gcMarkTinyAllocs()</span></span><br><span class="line"><span class="comment">//恢复整个世界（线程恢复）</span></span><br><span class="line">systemstack(startTheworldWithSema) &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gcstart 会为所有的P都准备好对应的goroutine worker，但是这些worker需要被gcController的findRunnableGCWorker唤醒才能工作。M启动后会一直通过schedule查找可执行的G，其中gcworker也是G的一部分，但是首先要检查当前状态是不是回收状态，如果是才唤醒worker开始标记工作。</p>
<p>标记阶段是并行的，通过在后台一直运行标记worker来实现：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//后台并发标记由每个P的G执行，确保每个P都有一个后台GC的G在运行</span></span><br><span class="line"><span class="keyword">for</span> _,p:=<span class="keyword">range</span> &amp;allp &#123;</span><br><span class="line"><span class="keyword">if</span> p == nillIp.status ==__Pdead&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> p.gcBgMarkWorker == <span class="number">0</span>&#123;</span><br><span class="line">gogcBgMarkWorker(p)</span><br><span class="line">notetsleepg(&amp;work.bgMarkReady，<span class="number">-1</span>) noteclear(&amp;work.bgMarkReady)</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcBgMarkWorker是一直在后台运行的，大部分时候是休眠状态，通过gcController 来调度func gcBgMarkWorker(_p_*p)&#123;</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">//.将当前goroutine休眠，直到满足某些条件</span></span><br><span class="line">gopark(...)</span><br><span class="line"><span class="comment">// mark过程</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//标记gortoutine为可占用，然后它所在堆栈才会被扫描</span></span><br><span class="line"><span class="comment">//这样，两个标记的worker相互扫描，从而避免死锁</span></span><br><span class="line"><span class="comment">//由于不能修改G栈上的任何内容，因此从G堆栈读取是安全的</span></span><br><span class="line">casgstatus(gp, _Grunning,_Gwaiting)</span><br><span class="line"><span class="keyword">switch</span> _p_.gcMarkWorkerMode&#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">throw(<span class="string">"gcBgMarkWorker: unexpected gcMarkWorkerMode"</span>)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">gcDrain(&amp;_p_.gcw,gcDrainNoBlockIgcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">gcDrain(&amp;_p_.gcw,gcDrainUntilPreemptIgcDrainFlushBgCredit)</span><br><span class="line"><span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">gcDrain(&amp;_p_.gcw, gcDrainIdlelgcDrainUntilPreemptlgcDrainFlushBgcredit) &#125;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line"><span class="number">1</span>x</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">里</span><br><span class="line"><span class="number">0.</span>.<span class="number">.21</span></span><br></pre></td></tr></table></figure></p>
<p>标记代码主要在函数gcDrain()中实现：<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*gcDrain扫描工作缓冲区中的root区和对象，使灰色的对象变黑，直到所有的root区域和工作缓冲区域都被排空*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span>&#123;</span><br><span class="line"><span class="comment">//处理root区域标记</span></span><br><span class="line"><span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line"><span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt)&#123;</span><br><span class="line">job :=atomic.Xadd(&amp;work.markrootNext,+<span class="number">1</span>)<span class="number">-1</span> ifjob &gt;= work.markrootJobs&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">]</span><br><span class="line">markroot(gcw,job)</span><br><span class="line"><span class="keyword">if</span> idle &amp; pollWork()&#123; <span class="keyword">goto</span> done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理heap标记</span></span><br><span class="line"><span class="keyword">for</span> !(preemptible &amp;&amp; gp.preempt)&#123; <span class="comment">//从灰色列队中取出对象</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">if</span> blocking &#123;</span><br><span class="line">b= gcw.get()</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">b= gcw.tryGetFast() <span class="keyword">if</span> b==<span class="number">0</span>&#123;</span><br><span class="line">b=gcw.tryGet() ]</span><br><span class="line"><span class="keyword">if</span> b==<span class="number">0</span>&#123;</span><br><span class="line"><span class="comment">//工作遇到障碍或tryGet失败break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扫描灰色对象的引用对象，标记为灰色，入灰色队列scanobject(b，gcw)</span></span><br></pre></td></tr></table></figure></p>
<p>结束后调用gcMarkDone，这里会引起StopTheWorld，接下来进入gcMarkTermination中的gcMark阶段。</p>
<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>清理相对来说就简单很多了。有多个地方可以触发sweep，比如GC标记结束会触发 gcSweep。如果是并发清除，需要回收从gc_trigger到当前活跃内存大小相同的heap区域，唤醒后台的sweep goroutine。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcSweep</span><span class="params">(mode gcMode)</span></span>&#123;</span><br><span class="line"><span class="comment">//阻塞式</span></span><br><span class="line"><span class="keyword">if</span> !_ConcurrentSweep II mode == gcForceBlockMode &#123; <span class="comment">//在特殊情况下，同步扫描</span></span><br><span class="line"><span class="comment">//快速扫描所有的span</span></span><br><span class="line"><span class="keyword">for</span> sweepone()!= ^<span class="keyword">uintptr</span>()&#123;</span><br><span class="line">sweep.npausesweep++</span><br><span class="line">]</span><br><span class="line"><span class="comment">//多做一次mProf_GC，因为所有“空闲”的事件此刻都是真实存在的mProf_GC()</span></span><br><span class="line">mProf_GC()</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">//并行式，后台扫描</span></span><br><span class="line">lock(&amp;sweep.lock)</span><br><span class="line"><span class="keyword">if</span> sweep.parked &#123;</span><br><span class="line">sweep.parked = <span class="literal">false</span> ready(sweep.g,o,<span class="literal">true</span>)</span><br><span class="line">unlock(&amp;sweep.lock)</span><br><span class="line"><span class="comment">//在runtime初始化时进行gcenable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcenable</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">go</span> bgsweep(c)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgsweep</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">sweep.g =getg()</span><br><span class="line"><span class="number">1</span>ock(&amp;sweep<span class="number">.1</span>ock)</span><br><span class="line">sweep.parked = <span class="literal">true</span></span><br><span class="line">c&lt;<span class="number">-1</span></span><br><span class="line">goparkunlock(&amp;sweep.lock, <span class="string">"GC sweep wait"</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">for</span> gosweepone()!= ^<span class="keyword">uintptr</span>(<span class="number">0</span>)&#123; sweep.nbgsweep++</span><br><span class="line">Gosched()</span><br><span class="line">lock(&amp;sweep.lock)</span><br><span class="line"><span class="keyword">if</span> !gosweepdone()&#123;</span><br><span class="line"><span class="comment">//如果GC在gosweepone返回^0之前并在锁之后运行，则可能发生这种情况unlock(&amp;sweep.lock)</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sweep.parked = <span class="literal">true</span></span><br><span class="line">goparkunlock(&amp;sweep.lock, <span class="string">"GC sweep wait"</span>, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gosweepone</span><span class="params">()</span> <span class="title">uintptr</span></span> &#123; <span class="keyword">var</span> retuintptr</span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">ret = sweepone() &#125;)</span><br><span class="line">returnret</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>对于并行式清理，在GC初始化的时候就会启动bgsweep（，然后在后台一直循环，它会执行gosweepone。 sweepone（一个内置的检查方法）首先会遍历所有的spans看它的sweepgen是否需要检查，如果要就检查这个MSpan里所有的object的bit（位），看是否需要回收。这个过程可能触发MSpan到MCentral的回收，最终可能回收到MHeap的空闲列表当中。在空闲列表当中的内存在超过一定阈值时间后会被sysmon建议交还给内核。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>上面讲到有两种GC触发方式，分别是自动检测和用户主动调用。除此之外Go语言本身还会对运行状态进行监控，如果超过两分钟没有GC，则触发GC。监控函数就是sysmon()，在主goroutine中启动。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不管有没有P，一直运行，所以不允许写障碍</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span>&#123;</span><br><span class="line">dn</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="number">60.099</span>W2</span><br><span class="line">now := nanotime()</span><br><span class="line">unixnow :=unixnanotime()</span><br><span class="line">lastgc := <span class="keyword">int64</span>(atomic.Load64(&amp;memstats.last_gc))</span><br><span class="line"><span class="keyword">if</span> gcphase == _GCoff &amp;&amp; lastgc!= <span class="number">0</span>&amp;&amp; unixnow-lastgc &gt; forcegcperiod &amp;&amp; ato</span><br><span class="line">mic. Load(&amp;forcegc.idle)!=<span class="number">0</span>&#123;</span><br><span class="line">lock(&amp;forcegc.lock)</span><br><span class="line"><span class="number">200</span></span><br><span class="line">forcegc.idle = <span class="number">0</span></span><br><span class="line">forcegc.g.schedlink = <span class="number">0</span></span><br><span class="line">injectglist（forcegc.g）<span class="comment">//将forcegc goroutine 加入runnable queue</span></span><br><span class="line">unlock(&amp;forcegc.lock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>ofn</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p>本章主要讲解了Go语言的内存分配原理以及具体实现过程。虽然Go语言的垃圾回收还有一些不足的地方需要改进，但是可以看到每次更新Go语言的版本时，垃圾回收的部分都有一些改进。有理由相信Go语言在庞大社区驱动以及Google的支持下会越来越好。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go语言编程入门与实战技巧/" rel="tag"># Go语言编程入门与实战技巧</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/18/第14章-安全与测试/" rel="next" title="第14章 安全与测试">
                <i class="fa fa-chevron-left"></i> 第14章 安全与测试
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/24/第12章-通道简介/" rel="prev" title="第12章 通道简介">
                第12章 通道简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">看视频才能学会，看文字学不会的</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1140</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">79</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/07/19/zero-admin-3/" title="zero-admin-3" target="_blank">zero-admin-3</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-2/" title="zero-admin-2" target="_blank">zero-admin-2</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/zero-admin-1/" title="zero-admin-1" target="_blank">zero-admin-1</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day7-服务发现与注册中心/" title="Day7 服务发现与注册中心" target="_blank">Day7 服务发现与注册中心</a>
                  </li>
                
                  <li>
                    <a href="/2023/07/19/Day6-负载均衡/" title="Day6 负载均衡" target="_blank">Day6 负载均衡</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#内存分配"><span class="nav-number">1.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理基本概念"><span class="nav-number">1.1.</span> <span class="nav-text">内存管理基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逃逸分析"><span class="nav-number">1.2.</span> <span class="nav-text">逃逸分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCMalloc"><span class="nav-number">2.</span> <span class="nav-text">TCMalloc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#整体结构"><span class="nav-number">2.1.</span> <span class="nav-text">整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小内存分配"><span class="nav-number">2.2.</span> <span class="nav-text">小内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CentralCache"><span class="nav-number">2.3.</span> <span class="nav-text">CentralCache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大内存分配"><span class="nav-number">2.4.</span> <span class="nav-text">大内存分配</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mspan（内存管理器）"><span class="nav-number">3.</span> <span class="nav-text">Mspan（内存管理器）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收"><span class="nav-number">4.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标记清理算法"><span class="nav-number">4.1.</span> <span class="nav-text">标记清理算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标记实现"><span class="nav-number">4.2.</span> <span class="nav-text">标记实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#清理"><span class="nav-number">4.3.</span> <span class="nav-text">清理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#监控"><span class="nav-number">4.4.</span> <span class="nav-text">监控</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小结"><span class="nav-number">5.</span> <span class="nav-text">本章小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">8.9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">135:21</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
